import e from"node:path";const t=({file:e,modulePath:t,symbol:n,symbolFile:r})=>{let i=[],a=[],o={aliases:{},from:t};if(n.importKind&&(n.importKind===`default`?(o.defaultBinding=n.placeholder,n.kind===`type`&&(o.typeDefaultBinding=!0)):n.importKind===`namespace`&&(o.namespaceBinding=n.placeholder,n.kind===`type`&&(o.typeNamespaceBinding=!0))),n.importKind===`named`||!i.length&&!o.defaultBinding&&!o.namespaceBinding){let t=n.placeholder,s=e.resolvedNames.get(n.id);if(s){let e=r.resolvedNames.get(n.id);e?e!==s&&(t=e,o.aliases[t]=s):n.name&&s!==n.name&&(t=n.name,o.aliases[t]=n.placeholder)}i.push(t),n.kind===`type`&&a.push(t)}for(let e of a)i.includes(e)||i.push(e);return o.names=i,o.typeNames=a,o},n=(e,t)=>{e.aliases={...e.aliases,...t.aliases},t.defaultBinding!==void 0&&(e.defaultBinding=t.defaultBinding),e.names=[...new Set([...e.names??[],...t.names??[]])],t.namespaceBinding!==void 0&&(e.namespaceBinding=t.namespaceBinding),t.typeDefaultBinding!==void 0&&(e.typeDefaultBinding=t.typeDefaultBinding),e.typeNames=[...new Set([...e.typeNames??[],...t.typeNames??[]])],t.typeNamespaceBinding!==void 0&&(e.typeNamespaceBinding=t.typeNamespaceBinding)};var r=class{map=new Map;reverse=new Map;delete(e){let t=this.map.get(e);return t!==void 0&&this.reverse.delete(t),this.map.delete(e)}deleteValue(e){let t=this.reverse.get(e);return t!==void 0&&this.map.delete(t),this.reverse.delete(e)}entries(){return this.map.entries()}get(e){return this.map.get(e)}getKey(e){return this.reverse.get(e)}hasKey(e){return this.map.has(e)}hasValue(e){return this.reverse.has(e)}keys(){return this.map.keys()}set(e,t){let n=this.map.get(e);n!==void 0&&n!==t&&this.reverse.delete(n);let r=this.reverse.get(t);return r!==void 0&&r!==e&&this.map.delete(r),this.map.set(e,t),this.reverse.set(t,e),this}get size(){return this.map.size}values(){return this.map.values()}[Symbol.iterator](){return this.map[Symbol.iterator]()}},i=class{_id=0;referenceOrder=new Set;registerOrder=new Set;selectorToId=new Map;values=new Map;get(e){let t=this.identifierToFile(e);if(t.id!==void 0)return this.values.get(t.id);let n=t.selector===void 0?void 0:JSON.stringify(t.selector);if(n){let e=this.selectorToId.get(n);if(e!==void 0)return this.values.get(e)}}get id(){return this._id++}identifierToFile(e){return typeof e==`number`?{id:e}:{selector:e}}isRegistered(e){let t=this.get(e);return t?this.registerOrder.has(t.id):!1}reference(e){let t=this.identifierToFile(e);return this.register(t)}*referenced(){for(let e of this.referenceOrder.values())yield this.values.get(e)}register(e){if(e.id!==void 0){let t=this.values.get(e.id);if(!t)throw Error(`File with ID ${e.id} not found. To register a new file, leave the ID undefined.`);return t}let t=Object.keys(e).some(e=>![`id`,`selector`].includes(e)),n,i=e.selector===void 0?void 0:JSON.stringify(e.selector);if(i){let e=this.selectorToId.get(i);if(e!==void 0){if(n=this.values.get(e),!n)throw Error(`File with ID ${e} not found. The selector ${i} matched an ID, but there was no result. This is likely an issue with the application logic.`);if(!t)return n}}let a=n?.id===void 0?this.id:n.id;return n={...n,...e,id:a,resolvedNames:n?.resolvedNames??new r,symbols:n?.symbols??{body:[],exports:[],imports:[]}},this.values.set(a,n),t?(this.registerOrder.add(a),this.referenceOrder.has(a)&&this.referenceOrder.delete(a)):this.referenceOrder.add(a),i&&this.selectorToId.set(i,a),n}*registered(){for(let e of this.registerOrder.values())yield this.values.get(e)}};const a=e=>`_heyapi_${e}_`,o=e=>e.slice(8,-1),s=()=>new RegExp(a(`\\d+`),`g`),c=(e,t)=>e.replace(s(),e=>t(Number.parseInt(o(e),10))||e);var l=class{_id=0;indices=new Map;nodes=new Map;queryCache=new Map;queryCacheDependencies=new Map;registerOrder=new Set;stubCache=new Map;stubs=new Set;values=new Map;get(e){return typeof e==`number`?this.values.get(e):this.query(e)[0]}getValue(e){return this.nodes.get(e)}hasValue(e){return this.nodes.has(e)}get id(){return this._id++}isRegistered(e){let t=this.get(e);return t?this.registerOrder.has(t.id):!1}query(e){let t=this.buildCacheKey(e),n=this.queryCache.get(t);if(n)return n.map(e=>this.values.get(e));let r=[],i=this.buildIndexKeySpace(e),a=new Set,o=!1;for(let e of i){a.add(this.serializeIndexEntry(e));let t=this.indices.get(e[0]);if(!t){o=!0;break}let n=t.get(e[1]);if(!n){o=!0;break}r.push(n)}if(o||!r.length)return this.queryCacheDependencies.set(t,a),this.queryCache.set(t,[]),[];let s=new Set(r[0]);for(let e of r.slice(1))s=new Set([...s].filter(t=>e.has(t)));let c=[...s];return this.queryCacheDependencies.set(t,a),this.queryCache.set(t,c),c.map(e=>this.values.get(e))}reference(e){let[t]=this.query(e);if(t)return t;let n=this.buildCacheKey(e),r=this.stubCache.get(n);if(r!==void 0)return this.values.get(r);let i=this.id,o={exportFrom:[],id:i,meta:e,placeholder:a(String(i))};return this.values.set(o.id,o),this.stubs.add(o.id),this.stubCache.set(n,o.id),o}register(e){let t=e.id===void 0?this.id:e.id,n={...e,exportFrom:e.exportFrom??[],id:t,placeholder:e.placeholder??a(String(t))};if(this.values.set(n.id,n),this.registerOrder.add(n.id),n.meta){let e=this.buildIndexKeySpace(n.meta);this.indexSymbol(n.id,e),this.invalidateCache(e),this.replaceStubs(n,e)}return n}*registered(){for(let e of this.registerOrder.values())yield this.values.get(e)}setValue(e,t){return this.nodes.set(e,t)}buildCacheKey(e){return this.buildIndexKeySpace(e).map(e=>this.serializeIndexEntry(e)).sort().join(`|`)}buildIndexKeySpace(e,t=``){let n=[];for(let[r,i]of Object.entries(e)){let e=t?`${t}.${r}`:r;i&&typeof i==`object`&&!Array.isArray(i)?n.push(...this.buildIndexKeySpace(i,e)):n.push([e,i])}return n}indexSymbol(e,t){for(let[n,r]of t){this.indices.has(n)||this.indices.set(n,new Map);let t=this.indices.get(n),i=t.get(r)??new Set;i.add(e),t.set(r,i)}}invalidateCache(e){let t=e.map(e=>this.serializeIndexEntry(e));for(let[e,n]of this.queryCacheDependencies.entries())for(let r of t)if(n.has(r)){this.queryCacheDependencies.delete(e),this.queryCache.delete(e);break}}isSubset(e,t){let n=new Map(t);for(let[t,r]of e)if(!n.has(t)||n.get(t)!==r)return!1;return!0}replaceStubs(e,t){for(let n of this.stubs.values()){let r=this.values.get(n);if(r?.meta&&this.isSubset(this.buildIndexKeySpace(r.meta),t)){let t=this.buildCacheKey(r.meta);this.stubCache.delete(t),this.values.set(n,Object.assign(r,e)),this.stubs.delete(n)}}}serializeIndexEntry(e){return`${e[0]}:${JSON.stringify(e[1])}`}},u=class{symbolIdToFileIds=new Map;defaultFileName;files=new i;fileName;renderers={};root;symbols=new l;constructor({defaultFileName:e,fileName:t,renderers:n,root:r}){this.defaultFileName=e??`main`,this.fileName=typeof t==`string`?()=>t:t,this.renderers=n,this.root=r}getRenderer(e){return e.extension?this.renderers[e.extension]:void 0}prepareFiles(){for(let e of this.symbols.registered()){let t=this.symbolToFileSelector(e),n=this.files.reference(t);n.symbols.body.push(e.id);let r=this.symbolIdToFileIds.get(e.id)??new Set;r.add(n.id),this.symbolIdToFileIds.set(e.id,r);for(let t of e.exportFrom){let r=[t],i=this.files.reference(r);i.id!==n.id&&i.symbols.exports.push(e.id)}}for(let t of this.files.referenced()){if(!t.selector)continue;if(t.selector[0]===`@`){let n=t.selector[1];if(!n){this.files.register({external:!0,selector:t.selector});continue}let r=e.extname(n);if(!r){this.files.register({external:!0,path:n,selector:t.selector});continue}this.files.register({extension:r,external:!0,path:n,selector:t.selector});continue}let n=t.selector.slice(0,-1),r=t.selector[t.selector.length-1];r=this.fileName?.(r)||r,this.files.register({extension:`.ts`,name:r,path:e.resolve(this.root,...n,`${r}.ts`),selector:t.selector})}}render(e){this.prepareFiles();let t=new Map;for(let n of this.files.registered()){if(n.external||!n.path)continue;let r=this.getRenderer(n);r&&t.set(n.id,{content:r.renderSymbols(n,this,e),path:n.path})}for(let[n,r]of t.entries()){let i=this.files.get(n),a=this.getRenderer(i).renderFile(r.content,i,this,e);a?t.set(i.id,{...r,content:a}):t.delete(i.id)}return Array.from(t.values())}symbolIdToFiles(e){let t=this.symbolIdToFileIds.get(e);return Array.from(t??[]).map(e=>this.files.get(e))}symbolToFileSelector(e){if(e.external)return[`@`,e.external];let t=e.getFilePath?.(e);return t?t.split(`/`):[this.defaultFileName]}};export{u as Project,t as createBinding,n as mergeBindings,c as renderIds};
//# sourceMappingURL=index.js.map