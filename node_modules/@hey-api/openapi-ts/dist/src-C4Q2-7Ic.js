import{i as e,r as t,t as n}from"./chunk-C-EqMg7d.js";import{A as r,C as i,D as a,E as o,F as s,I as c,M as l,N as u,O as d,P as f,S as p,T as m,d as h,f as g,g as _,h as v,i as y,j as b,k as ee,l as te,m as ne,n as re,o as x,p as S,t as ie,u as ae,v as C,w,y as T}from"./getSpec-NJ6vig64.js";import"@hey-api/codegen-core";import E from"ansi-colors";import oe from"color-support";import D from"node:fs";import O from"node:path";import{$RefParser as se}from"@hey-api/json-schema-ref-parser";import k from"handlebars";const ce=()=>{if(typeof Bun<`u`){let[e]=Bun.version.split(`.`).map(Number);if(e<1)throw new a(`Unsupported Bun version ${Bun.version}. Please use Bun 1.0.0 or newer.`)}else if(typeof process<`u`&&process.versions?.node){let[e]=process.versions.node.split(`.`).map(Number);if(e<20)throw new a(`Unsupported Node version ${process.versions.node}. Please use Node 20 or newer.`)}},A=e=>{switch(e){case`legacy/angular`:return`AngularHttpRequest`;case`legacy/axios`:return`AxiosHttpRequest`;case`legacy/fetch`:return`FetchHttpRequest`;case`legacy/node`:return`NodeHttpRequest`;case`legacy/xhr`:return`XHRHttpRequest`;default:return``}},le=async(e,t,n,r)=>{let a=i(),s=o(a),c=r.client({$config:a,...n,httpRequest:A(s.name),models:g(n.models),services:g(n.services)});m(a)&&(f(t),D.writeFileSync(O.resolve(t,`${m(a)}.ts`),c))},j=async(e,t,n)=>{let r=i();if(r.exportCore){let i=o(r),a={httpRequest:A(i.name),server:r.base===void 0?t.server:r.base,version:t.version};if(D.rmSync(O.resolve(e),{force:!0,recursive:!0}),D.mkdirSync(O.resolve(e),{recursive:!0}),await D.writeFileSync(O.resolve(e,`OpenAPI.ts`),n.core.settings({$config:r,...a})),await D.writeFileSync(O.resolve(e,`ApiError.ts`),n.core.apiError({$config:r,...a})),await D.writeFileSync(O.resolve(e,`ApiRequestOptions.ts`),n.core.apiRequestOptions({$config:r,...a})),await D.writeFileSync(O.resolve(e,`ApiResult.ts`),n.core.apiResult({$config:r,...a})),i.name!==`legacy/angular`&&await D.writeFileSync(O.resolve(e,`CancelablePromise.ts`),n.core.cancelablePromise({$config:r,...a})),await D.writeFileSync(O.resolve(e,`request.ts`),n.core.request({$config:r,...a})),m(r)&&(await D.writeFileSync(O.resolve(e,`BaseHttpRequest.ts`),n.core.baseHttpRequest({$config:r,...a})),await D.writeFileSync(O.resolve(e,`${a.httpRequest}.ts`),n.core.httpRequest({$config:r,...a}))),r.request){let t=O.resolve(process.cwd(),r.request);if(!await D.existsSync(t))throw Error(`Custom request file "${t}" does not exists`);await D.copyFileSync(t,O.resolve(e,`request.ts`))}}},M=({files:e})=>{let t=i();e.index=new y({dir:t.output.path,id:`index`,name:`index.ts`}),m(t)&&e.index.add(C.exportNamedDeclaration({exports:m(t),module:`./${m(t)}`})),t.exportCore&&(e.index.add(C.exportNamedDeclaration({exports:`ApiError`,module:`./core/ApiError`})),t.plugins[`@hey-api/sdk`]?.config.response===`response`&&e.index.add(C.exportNamedDeclaration({exports:{asType:!0,name:`ApiResult`},module:`./core/ApiResult`})),m(t)&&e.index.add(C.exportNamedDeclaration({exports:`BaseHttpRequest`,module:`./core/BaseHttpRequest`})),o(t).name!==`legacy/angular`&&e.index.add(C.exportNamedDeclaration({exports:[`CancelablePromise`,`CancelError`],module:`./core/CancelablePromise`})),e.index.add(C.exportNamedDeclaration({exports:[`OpenAPI`,{asType:!0,name:`OpenAPIConfig`}],module:`./core/OpenAPI`}))),Object.keys(e).sort().forEach(t=>{let n=e[t];t===`index`||n.isEmpty()||n.exportFromIndex&&e.index.add(C.exportAllDeclaration({module:`./${n.nameWithoutExtension()}`}))})},N=async({client:e,openApi:t,templates:n})=>{let r=i(),a=t;if(e){if(r.plugins[`@hey-api/sdk`]?.config.include&&r.plugins[`@hey-api/sdk`].config.asClass){let t=new RegExp(r.plugins[`@hey-api/sdk`].config.include);e.services=e.services.filter(e=>t.test(e.name))}if(r.plugins[`@hey-api/typescript`]?.config.include){let t=new RegExp(r.plugins[`@hey-api/typescript`].config.include);e.models=e.models.filter(e=>t.test(e.name))}}let c=O.resolve(r.output.path);r.output.clean&&s(c);let l=o(r);!w(r)&&`bundle`in l.config&&l.config.bundle&&!r.dryRun&&x({meta:{importFileExtension:r.output.importFileExtension},outputPath:c,plugin:l}),await le(a,c,e,n),await j(O.resolve(r.output.path,`core`),e,n);let u={};for(let t of r.pluginOrder){let n=r.plugins[t],i=(n.output??``).split(`/`),o=O.resolve(r.output.path,...i.slice(0,i.length-1));u[n.name]=new y({dir:o,id:`legacy-unused-${n.name}`,name:`${i[i.length-1]}.ts`}),n.handlerLegacy?.({client:e,files:u,openApi:a,plugin:n})}M({files:u}),Object.entries(u).forEach(([e,t])=>{r.dryRun||(e===`index`?t.write(`
`,r.output.tsConfig):t.write(`

`,r.output.tsConfig))})},P=async({context:e})=>{let t=O.resolve(e.config.output.path);e.config.output.clean&&s(t);let n={importFileExtension:e.config.output.importFileExtension},r=o(e.config);`bundle`in r.config&&r.config.bundle&&!e.config.dryRun&&(e.config._FRAGILE_CLIENT_BUNDLE_RENAMED=x({meta:n,outputPath:t,plugin:r,project:e.gen}));for(let t of e.registerPlugins())await t.run();for(let r of e.gen.render(n)){let n=O.resolve(t,r.path),i=O.dirname(n);e.config.dryRun||(D.mkdirSync(i,{recursive:!0}),D.writeFileSync(n,r.content,{encoding:`utf8`}))}},F=({patchOptions:e,spec:t})=>{if(!e)return;let n=t;if(`swagger`in n){if(e.version&&n.swagger&&(n.swagger=typeof e.version==`string`?e.version:e.version(n.swagger)),e.meta&&n.info&&e.meta(n.info),e.schemas&&n.definitions)for(let t in e.schemas){let r=n.definitions[t];if(!r||typeof r!=`object`)continue;let i=e.schemas[t];i(r)}if(e.operations&&n.paths)for(let t in e.operations){let[r,i]=t.split(` `);if(!r||!i)continue;let a=n.paths[i];if(!a)continue;let o=a[r.toLocaleLowerCase()]||a[r.toLocaleUpperCase()];if(!o||typeof o!=`object`)continue;let s=e.operations[t];s(o)}return}if(e.version&&n.openapi&&(n.openapi=typeof e.version==`string`?e.version:e.version(n.openapi)),e.meta&&n.info&&e.meta(n.info),n.components){if(e.schemas&&n.components.schemas)for(let t in e.schemas){let r=n.components.schemas[t];if(!r||typeof r!=`object`)continue;let i=e.schemas[t];i(r)}if(e.parameters&&n.components.parameters)for(let t in e.parameters){let r=n.components.parameters[t];if(!r||typeof r!=`object`)continue;let i=e.parameters[t];i(r)}if(e.requestBodies&&n.components.requestBodies)for(let t in e.requestBodies){let r=n.components.requestBodies[t];if(!r||typeof r!=`object`)continue;let i=e.requestBodies[t];i(r)}if(e.responses&&n.components.responses)for(let t in e.responses){let r=n.components.responses[t];if(!r||typeof r!=`object`)continue;let i=e.responses[t];i(r)}}if(e.operations&&n.paths)for(let t in e.operations){let[r,i]=t.split(` `);if(!r||!i)continue;let a=n.paths[i];if(!a)continue;let o=a[r.toLocaleLowerCase()]||a[r.toLocaleUpperCase()];if(!o||typeof o!=`object`)continue;let s=e.operations[t];s(o)}};var I=n(((e,n)=>{n.exports=o,o.sync=s;var r=t(`fs`);function i(e,t){var n=t.pathExt===void 0?process.env.PATHEXT:t.pathExt;if(!n||(n=n.split(`;`),n.indexOf(``)!==-1))return!0;for(var r=0;r<n.length;r++){var i=n[r].toLowerCase();if(i&&e.substr(-i.length).toLowerCase()===i)return!0}return!1}function a(e,t,n){return!e.isSymbolicLink()&&!e.isFile()?!1:i(t,n)}function o(e,t,n){r.stat(e,function(r,i){n(r,r?!1:a(i,e,t))})}function s(e,t){return a(r.statSync(e),e,t)}})),L=n(((e,n)=>{n.exports=i,i.sync=a;var r=t(`fs`);function i(e,t,n){r.stat(e,function(e,r){n(e,e?!1:o(r,t))})}function a(e,t){return o(r.statSync(e),t)}function o(e,t){return e.isFile()&&s(e,t)}function s(e,t){var n=e.mode,r=e.uid,i=e.gid,a=t.uid===void 0?process.getuid&&process.getuid():t.uid,o=t.gid===void 0?process.getgid&&process.getgid():t.gid,s=64,c=8,l=1,u=s|c;return n&l||n&c&&i===o||n&s&&r===a||n&u&&a===0}})),R=n(((e,n)=>{t(`fs`);var r=process.platform===`win32`||global.TESTING_WINDOWS?I():L();n.exports=i,i.sync=a;function i(e,t,n){if(typeof t==`function`&&(n=t,t={}),!n){if(typeof Promise!=`function`)throw TypeError(`callback not provided`);return new Promise(function(n,r){i(e,t||{},function(e,t){e?r(e):n(t)})})}r(e,t||{},function(e,r){e&&(e.code===`EACCES`||t&&t.ignoreErrors)&&(e=null,r=!1),n(e,r)})}function a(e,t){try{return r.sync(e,t||{})}catch(e){if(t&&t.ignoreErrors||e.code===`EACCES`)return!1;throw e}}})),z=n(((e,n)=>{let r=process.platform===`win32`||process.env.OSTYPE===`cygwin`||process.env.OSTYPE===`msys`,i=t(`path`),a=r?`;`:`:`,o=R(),s=e=>Object.assign(Error(`not found: ${e}`),{code:`ENOENT`}),c=(e,t)=>{let n=t.colon||a,i=e.match(/\//)||r&&e.match(/\\/)?[``]:[...r?[process.cwd()]:[],...(t.path||process.env.PATH||``).split(n)],o=r?t.pathExt||process.env.PATHEXT||`.EXE;.CMD;.BAT;.COM`:``,s=r?o.split(n):[``];return r&&e.indexOf(`.`)!==-1&&s[0]!==``&&s.unshift(``),{pathEnv:i,pathExt:s,pathExtExe:o}},l=(e,t,n)=>{typeof t==`function`&&(n=t,t={}),t||={};let{pathEnv:r,pathExt:a,pathExtExe:l}=c(e,t),u=[],d=n=>new Promise((a,o)=>{if(n===r.length)return t.all&&u.length?a(u):o(s(e));let c=r[n],l=/^".*"$/.test(c)?c.slice(1,-1):c,d=i.join(l,e);a(f(!l&&/^\.[\\\/]/.test(e)?e.slice(0,2)+d:d,n,0))}),f=(e,n,r)=>new Promise((i,s)=>{if(r===a.length)return i(d(n+1));let c=a[r];o(e+c,{pathExt:l},(a,o)=>{if(!a&&o)if(t.all)u.push(e+c);else return i(e+c);return i(f(e,n,r+1))})});return n?d(0).then(e=>n(null,e),n):d(0)};n.exports=l,l.sync=(e,t)=>{t||={};let{pathEnv:n,pathExt:r,pathExtExe:a}=c(e,t),l=[];for(let s=0;s<n.length;s++){let c=n[s],u=/^".*"$/.test(c)?c.slice(1,-1):c,d=i.join(u,e),f=!u&&/^\.[\\\/]/.test(e)?e.slice(0,2)+d:d;for(let e=0;e<r.length;e++){let n=f+r[e];try{if(o.sync(n,{pathExt:a}))if(t.all)l.push(n);else return n}catch{}}}if(t.all&&l.length)return l;if(t.nothrow)return null;throw s(e)}})),B=n(((e,t)=>{let n=(e={})=>{let t=e.env||process.env;return(e.platform||process.platform)===`win32`?Object.keys(t).reverse().find(e=>e.toUpperCase()===`PATH`)||`Path`:`PATH`};t.exports=n,t.exports.default=n})),V=n(((e,n)=>{let r=t(`path`),i=z(),a=B();function o(e,t){let n=e.options.env||process.env,o=process.cwd(),s=e.options.cwd!=null,c=s&&process.chdir!==void 0&&!process.chdir.disabled;if(c)try{process.chdir(e.options.cwd)}catch{}let l;try{l=i.sync(e.command,{path:n[a({env:n})],pathExt:t?r.delimiter:void 0})}catch{}finally{c&&process.chdir(o)}return l&&=r.resolve(s?e.options.cwd:``,l),l}function s(e){return o(e)||o(e,!0)}n.exports=s})),H=n(((e,t)=>{let n=/([()\][%!^"`<>&|;, *?])/g;function r(e){return e=e.replace(n,`^$1`),e}function i(e,t){return e=`${e}`,e=e.replace(/(?=(\\+?)?)\1"/g,`$1$1\\"`),e=e.replace(/(?=(\\+?)?)\1$/,`$1$1`),e=`"${e}"`,e=e.replace(n,`^$1`),t&&(e=e.replace(n,`^$1`)),e}t.exports.command=r,t.exports.argument=i})),U=n(((e,t)=>{t.exports=/^#!(.*)/})),W=n(((e,t)=>{let n=U();t.exports=(e=``)=>{let t=e.match(n);if(!t)return null;let[r,i]=t[0].replace(/#! ?/,``).split(` `),a=r.split(`/`).pop();return a===`env`?i:i?`${a} ${i}`:a}})),ue=n(((e,n)=>{let r=t(`fs`),i=W();function a(e){let t=Buffer.alloc(150),n;try{n=r.openSync(e,`r`),r.readSync(n,t,0,150,0),r.closeSync(n)}catch{}return i(t.toString())}n.exports=a})),de=n(((e,n)=>{let r=t(`path`),i=V(),a=H(),o=ue(),s=process.platform===`win32`,c=/\.(?:com|exe)$/i,l=/node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;function u(e){e.file=i(e);let t=e.file&&o(e.file);return t?(e.args.unshift(e.file),e.command=t,i(e)):e.file}function d(e){if(!s)return e;let t=u(e),n=!c.test(t);if(e.options.forceShell||n){let n=l.test(t);e.command=r.normalize(e.command),e.command=a.command(e.command),e.args=e.args.map(e=>a.argument(e,n)),e.args=[`/d`,`/s`,`/c`,`"${[e.command].concat(e.args).join(` `)}"`],e.command=process.env.comspec||`cmd.exe`,e.options.windowsVerbatimArguments=!0}return e}function f(e,t,n){t&&!Array.isArray(t)&&(n=t,t=null),t=t?t.slice(0):[],n=Object.assign({},n);let r={command:e,args:t,options:n,file:void 0,original:{command:e,args:t}};return n.shell?r:d(r)}n.exports=f})),fe=n(((e,t)=>{let n=process.platform===`win32`;function r(e,t){return Object.assign(Error(`${t} ${e.command} ENOENT`),{code:`ENOENT`,errno:`ENOENT`,syscall:`${t} ${e.command}`,path:e.command,spawnargs:e.args})}function i(e,t){if(!n)return;let r=e.emit;e.emit=function(n,i){if(n===`exit`){let n=a(i,t);if(n)return r.call(e,`error`,n)}return r.apply(e,arguments)}}function a(e,t){return n&&e===1&&!t.file?r(t.original,`spawn`):null}function o(e,t){return n&&e===1&&!t.file?r(t.original,`spawnSync`):null}t.exports={hookChildProcess:i,verifyENOENT:a,verifyENOENTSync:o,notFoundError:r}})),G=e(n(((e,n)=>{let r=t(`child_process`),i=de(),a=fe();function o(e,t,n){let o=i(e,t,n),s=r.spawn(o.command,o.args,o.options);return a.hookChildProcess(s,o),s}function s(e,t,n){let o=i(e,t,n),s=r.spawnSync(o.command,o.args,o.options);return s.error=s.error||a.verifyENOENTSync(s.status,o),s}n.exports=o,n.exports.spawn=o,n.exports.sync=s,n.exports._parse=i,n.exports._enoent=a}))(),1);const pe={biome:{args:e=>[`format`,`--write`,e],command:`biome`,name:`Biome (Format)`},prettier:{args:e=>[`--ignore-unknown`,e,`--write`,`--ignore-path`,`./.prettierignore`],command:`prettier`,name:`Prettier`}},me={biome:{args:e=>[`lint`,`--apply`,e],command:`biome`,name:`Biome (Lint)`},eslint:{args:e=>[e,`--fix`],command:`eslint`,name:`ESLint`},oxlint:{args:e=>[`--fix`,e],command:`oxlint`,name:`oxlint`}},he=({config:e})=>{if(e.output.format){let t=pe[e.output.format];console.log(`✨ Running ${t.name}`),(0,G.sync)(t.command,t.args(e.output.path))}if(e.output.lint){let t=me[e.output.lint];console.log(`✨ Running ${t.name}`),(0,G.sync)(t.command,t.args(e.output.path))}};function ge(e,t){return{...e,config:t,models:e.models.map(e=>_e(e)),services:ve(e.operations).map(ye),types:{}}}const _e=e=>({...e,$refs:e.$refs.filter((e,t,n)=>S(e,t,n)),enum:e.enum.filter((e,t,n)=>n.findIndex(t=>t.value===e.value)===t),enums:e.enums.filter((e,t,n)=>n.findIndex(t=>t.name===e.name)===t),imports:e.imports.filter((t,n,r)=>S(t,n,r)&&t!==e.name).sort(h)}),ve=e=>{let t=i(),n=new Map;return e.forEach(e=>{(e.tags?.length&&(t.plugins[`@hey-api/sdk`]?.config.asClass||m(t))?e.tags.filter(S):[`Default`]).forEach(t=>{let r={...e,service:Se(t)},i=n.get(r.service)||xe(r);i.$refs=[...i.$refs,...r.$refs],i.imports=[...i.imports,...r.imports],i.operations=[...i.operations,r],n.set(r.service,i)})}),Array.from(n.values())},ye=e=>{let t={...e};return t.operations=be(t),t.operations.forEach(e=>{t.imports.push(...e.imports)}),t.imports=t.imports.filter(S).sort(h),t},be=e=>{let t=new Map;return e.operations.map(e=>{let n={...e};n.imports.push(...n.parameters.flatMap(e=>e.imports));let r=n.responses.filter(e=>e.responseTypes.includes(`success`));n.imports.push(...r.flatMap(e=>e.imports));let i=n.name,a=t.get(i)||0;return a>0&&(n.name=`${i}${a}`),t.set(i,a+1),n})},xe=e=>({$refs:[],imports:[],name:e.service,operations:[]}),Se=e=>T({case:`PascalCase`,value:_(e)}),Ce=e=>{let t={...e,path:``};if(e.path&&(typeof e.path!=`string`||e.registry!==`hey-api`))return t.path=e.path,t;let[n,r]=e.path.split(`?`),i=(r||``).split(`&`).map(e=>e.split(`=`)),a=n||``;a.endsWith(`/`)&&(a=a.slice(0,a.length-1));let[,o]=a.split(`://`),[s,c,l]=(o||``).split(`/`);t.organization=c||e.organization,t.project=l||e.project;let u=[],d=`api_key`;t.api_key=i.find(([e])=>e===d)?.[1]||e.api_key||process.env.HEY_API_TOKEN,t.api_key&&u.push(`${d}=${t.api_key}`);let f=`branch`;t.branch=i.find(([e])=>e===f)?.[1]||e.branch,t.branch&&u.push(`${f}=${t.branch}`);let p=`commit_sha`;t.commit_sha=i.find(([e])=>e===p)?.[1]||e.commit_sha,t.commit_sha&&u.push(`${p}=${t.commit_sha}`);let m=`tags`;t.tags=i.find(([e])=>e===m)?.[1]?.split(`,`)||e.tags,t.tags?.length&&u.push(`${m}=${t.tags.join(`,`)}`);let h=`version`;if(t.version=i.find(([e])=>e===h)?.[1]||e.version,t.version&&u.push(`${h}=${t.version}`),!t.organization)throw Error(`missing organization - from which Hey API Platform organization do you want to generate your output?`);if(!t.project)throw Error(`missing project - from which Hey API Platform project do you want to generate your output?`);let g=u.join(`&`),_=s||`get.heyapi.dev`,v=_.startsWith(`localhost`),y=[v?`http`:`https`,_].join(`://`),b=v?[y,`v1`,`get`,t.organization,t.project].join(`/`):[y,t.organization,t.project].join(`/`);return t.path=g?`${b}?${g}`:b,t},K=(e,t)=>{let n=[],r=E.gray(`[Job ${t+1}] `),i=e.length,a=E.cyan(`Generating from ${i} ${i===1?`input`:`inputs`}:`);n.push(`${r}⏳ ${a}`),e.forEach((e,t)=>{let i=`  [${t+1}] `,a=E.cyan(i),o=` `.repeat(i.length);if(typeof e.path!=`string`){n.push(`${r}${a}raw OpenAPI specification`);return}switch(e.registry){case`hey-api`:{let t=[e.organization,e.project].filter(Boolean).join(`/`);n.push(`${r}${a}${t}`),e.branch&&n.push(`${r}${o}${E.gray(`branch:`)} ${E.green(e.branch)}`),e.commit_sha&&n.push(`${r}${o}${E.gray(`commit:`)} ${E.green(e.commit_sha)}`),e.tags?.length&&n.push(`${r}${o}${E.gray(`tags:`)} ${E.green(e.tags.join(`, `))}`),e.version&&n.push(`${r}${o}${E.gray(`version:`)} ${E.green(e.version)}`),n.push(`${r}${o}${E.gray(`registry:`)} ${E.green(`Hey API`)}`);break}case`readme`:{let t=[e.organization,e.project].filter(Boolean).join(`/`);t?n.push(`${r}${a}${t}`):n.push(`${r}${a}${e.path}`),e.uuid&&n.push(`${r}${o}${E.gray(`uuid:`)} ${E.green(e.uuid)}`),n.push(`${r}${o}${E.gray(`registry:`)} ${E.green(`ReadMe`)}`);break}case`scalar`:{let t=[e.organization,e.project].filter(Boolean).join(`/`);n.push(`${r}${a}${t}`),n.push(`${r}${o}${E.gray(`registry:`)} ${E.green(`Scalar`)}`);break}default:n.push(`${r}${a}${e.path}`);break}});for(let e of n)console.log(e)},q=async({config:e,dependencies:t,jobIndex:n,logger:r,templates:i,watches:a})=>{let o=a||Array.from({length:e.input.length},()=>({headers:new Headers})),s=e.input.map(e=>Ce(e));e.logs.level!==`silent`&&!a&&K(s,n);let c=async(e,t)=>{let n=r.timeEvent(`spec`),{arrayBuffer:i,error:c,resolvedInput:l,response:u}=await ie({fetchOptions:e.fetch,inputPath:s[t].path,timeout:e.watch.timeout,watch:o[t]});if(n.timeEnd(),c&&!a)throw Error(`Request failed with status ${u.status}: ${u.statusText}`);return{arrayBuffer:i,resolvedInput:l}},l=(await Promise.all(e.input.map((e,t)=>c(e,t)))).filter(e=>e.arrayBuffer||e.resolvedInput),u,d;if(l.length){let o=new se,c=l.length>1?await o.bundleMany({arrayBuffer:l.map(e=>e.arrayBuffer),pathOrUrlOrSchemas:[],resolvedInputs:l.map(e=>e.resolvedInput)}):await o.bundle({arrayBuffer:l[0].arrayBuffer,pathOrUrlOrSchema:void 0,resolvedInput:l[0].resolvedInput});e.logs.level!==`silent`&&a&&(console.clear(),K(s,n));let f=r.timeEvent(`input.patch`);F({patchOptions:e.parser.patch,spec:c}),f.timeEnd();let p=r.timeEvent(`parser`);e.experimentalParser&&!w(e)&&!m(e)&&(d=ae({config:e,dependencies:t,logger:r,spec:c})),d?d.graph=v(d.ir,r).graph:u=ge(te({openApi:c}),e),p.timeEnd();let h=r.timeEvent(`generator`);d?await P({context:d}):u&&await N({client:u,openApi:c,templates:i}),h.timeEnd();let g=r.timeEvent(`postprocess`);if(!e.dryRun&&(he({config:e}),e.logs.level!==`silent`)){let t=process.env.INIT_CWD?`./${O.relative(process.env.INIT_CWD,e.output.path)}`:e.output.path,r=E.gray(`[Job ${n+1}] `);console.log(`${r}${E.green(`✅ Done!`)} Your output is in ${E.cyanBright(t)}`)}g.timeEnd()}let f=e.input.find((e,t)=>e.watch.enabled&&typeof s[t].path==`string`);return f&&setTimeout(()=>{q({config:e,dependencies:t,jobIndex:n,logger:r,templates:i,watches:o})},f.watch.interval),d||u},we=(e,t)=>{let n=[],r=Array.from({length:t?.padding??0}).fill(``);n.push(...r);let i=0,a=``;for(let t of e)t===`
`?a&&=(n.push(a),i=Math.max(i,a.length),``):a+=t;return n.push(...r),{lines:n,maxLineLength:i}};function Te(){let e=c(),t=we(`
888   |                           e      888~-_   888
888___|  e88~~8e  Y88b  /        d8b     888   \\  888
888   | d888  88b  Y888/        /Y88b    888    | 888
888   | 8888__888   Y8/        /  Y88b   888   /  888
888   | Y888    ,    Y        /____Y88b  888_-~   888
888   |  "88___/    /        /      Y88b 888      888
                  _/
`,{padding:1});for(let e of t.lines)console.log(E.cyan(e));console.log(E.gray(`${e.name} v${e.version}`)),console.log(``)}var Ee={1:function(e,t,n,r,i){return`import { NgModule} from '@angular/core';
import { HttpClientModule } from '@angular/common/http';

import { AngularHttpRequest } from './core/AngularHttpRequest';
import { BaseHttpRequest } from './core/BaseHttpRequest';
import type { OpenAPIConfig } from './core/OpenAPI';
import { OpenAPI } from './core/OpenAPI';
import { Interceptors } from './core/OpenAPI';
`},3:function(e,t,n,r,i){var a=e.strict,o=e.lambda;return`import type { BaseHttpRequest } from './core/BaseHttpRequest';
import type { OpenAPIConfig } from './core/OpenAPI';
import { Interceptors } from './core/OpenAPI';
import { `+(o(a(t,`httpRequest`,{start:{line:14,column:12},end:{line:14,column:23}}),t)??``)+` } from './core/`+(o(a(t,`httpRequest`,{start:{line:14,column:45},end:{line:14,column:56}}),t)??``)+`';
`},5:function(e,t,n,r,i){var a=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return a(n,`each`).call(t??(e.nullContext||{}),a(t,`services`),{name:`each`,hash:{},fn:e.program(6,i,0),inverse:e.noop,data:i,loc:{start:{line:18,column:0},end:{line:20,column:9}}})??``},6:function(e,t,n,r,i){var a=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return`import { `+(a(n,`transformServiceName`).call(t??(e.nullContext||{}),a(t,`name`),{name:`transformServiceName`,hash:{},data:i,loc:{start:{line:19,column:9},end:{line:19,column:40}}})??``)+` } from './sdk.gen';
`},8:function(e,t,n,r,i){var a=e.strict,o=e.lambda,s=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return`@NgModule({
	imports: [HttpClientModule],
	providers: [
		{
			provide: OpenAPI,
			useValue: {
				BASE: OpenAPI?.BASE ?? '`+(o(a(t,`server`,{start:{line:30,column:31},end:{line:30,column:37}}),t)??``)+`',
				VERSION: OpenAPI?.VERSION ?? '`+(o(a(t,`version`,{start:{line:31,column:37},end:{line:31,column:44}}),t)??``)+`',
				WITH_CREDENTIALS: OpenAPI?.WITH_CREDENTIALS ?? false,
				CREDENTIALS: OpenAPI?.CREDENTIALS ?? 'include',
				TOKEN: OpenAPI?.TOKEN,
				USERNAME: OpenAPI?.USERNAME,
				PASSWORD: OpenAPI?.PASSWORD,
				HEADERS: OpenAPI?.HEADERS,
				ENCODE_PATH: OpenAPI?.ENCODE_PATH,
				interceptors: {
					response: OpenAPI?.interceptors?.response ?? new Interceptors(),
				},
			} as OpenAPIConfig,
		},
		{
			provide: BaseHttpRequest,
			useClass: AngularHttpRequest,
		},
`+(s(n,`each`).call(t??(e.nullContext||{}),s(t,`services`),{name:`each`,hash:{},fn:e.program(9,i,0),inverse:e.noop,data:i,loc:{start:{line:48,column:2},end:{line:50,column:11}}})??``)+`	]
})
export class `+(o(a(s(s(i,`root`),`$config`),`name`,{start:{line:53,column:16},end:{line:53,column:34}}),t)??``)+` {}
`},9:function(e,t,n,r,i){var a=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return`		`+(a(n,`transformServiceName`).call(t??(e.nullContext||{}),a(t,`name`),{name:`transformServiceName`,hash:{},data:i,loc:{start:{line:49,column:2},end:{line:49,column:33}}})??``)+`,
`},11:function(e,t,n,r,i){var a=e.strict,o=e.lambda,s=t??(e.nullContext||{}),c=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return`type HttpRequestConstructor = new (config: OpenAPIConfig) => BaseHttpRequest;

export class `+(o(a(c(c(i,`root`),`$config`),`name`,{start:{line:57,column:16},end:{line:57,column:34}}),t)??``)+` {

`+(c(n,`each`).call(s,c(t,`services`),{name:`each`,hash:{},fn:e.program(12,i,0),inverse:e.noop,data:i,loc:{start:{line:59,column:1},end:{line:61,column:10}}})??``)+`
	public readonly request: BaseHttpRequest;

	constructor(config?: Partial<OpenAPIConfig>, HttpRequest: HttpRequestConstructor = `+(o(a(t,`httpRequest`,{start:{line:65,column:87},end:{line:65,column:98}}),t)??``)+`) {
		this.request = new HttpRequest({
			BASE: config?.BASE ?? '`+(o(a(t,`server`,{start:{line:67,column:29},end:{line:67,column:35}}),t)??``)+`',
			VERSION: config?.VERSION ?? '`+(o(a(t,`version`,{start:{line:68,column:35},end:{line:68,column:42}}),t)??``)+`',
			WITH_CREDENTIALS: config?.WITH_CREDENTIALS ?? false,
			CREDENTIALS: config?.CREDENTIALS ?? 'include',
			TOKEN: config?.TOKEN,
			USERNAME: config?.USERNAME,
			PASSWORD: config?.PASSWORD,
			HEADERS: config?.HEADERS,
			ENCODE_PATH: config?.ENCODE_PATH,
			interceptors: {
				request: config?.interceptors?.request ?? new Interceptors(),
				response: config?.interceptors?.response ?? new Interceptors(),
      },
		});

`+(c(n,`each`).call(s,c(t,`services`),{name:`each`,hash:{},fn:e.program(14,i,0),inverse:e.noop,data:i,loc:{start:{line:82,column:2},end:{line:84,column:11}}})??``)+`	}
}
`},12:function(e,t,n,r,i){var a=t??(e.nullContext||{}),o=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return`	public readonly `+(o(n,`camelCase`).call(a,o(t,`name`),{name:`camelCase`,hash:{},data:i,loc:{start:{line:60,column:17},end:{line:60,column:37}}})??``)+`: `+(o(n,`transformServiceName`).call(a,o(t,`name`),{name:`transformServiceName`,hash:{},data:i,loc:{start:{line:60,column:39},end:{line:60,column:70}}})??``)+`;
`},14:function(e,t,n,r,i){var a=t??(e.nullContext||{}),o=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return`		this.`+(o(n,`camelCase`).call(a,o(t,`name`),{name:`camelCase`,hash:{},data:i,loc:{start:{line:83,column:7},end:{line:83,column:27}}})??``)+` = new `+(o(n,`transformServiceName`).call(a,o(t,`name`),{name:`transformServiceName`,hash:{},data:i,loc:{start:{line:83,column:34},end:{line:83,column:65}}})??``)+`(this.request);
`},compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){var a=t??(e.nullContext||{}),o=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(1,i,0),inverse:e.program(3,i,0),data:i,loc:{start:{line:1,column:0},end:{line:15,column:11}}})??``)+`
`+(o(n,`if`).call(a,o(t,`services`),{name:`if`,hash:{},fn:e.program(5,i,0),inverse:e.noop,data:i,loc:{start:{line:17,column:0},end:{line:21,column:7}}})??``)+`
`+(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(8,i,0),inverse:e.program(11,i,0),data:i,loc:{start:{line:23,column:0},end:{line:87,column:11}}})??``)},useData:!0},De={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getHeaders = <T>(config: OpenAPIConfig, options: ApiRequestOptions<T>): Observable<HttpHeaders> => {
	return forkJoin({
		// @ts-ignore
		token: resolve(options, config.TOKEN),
		// @ts-ignore
		username: resolve(options, config.USERNAME),
		// @ts-ignore
		password: resolve(options, config.PASSWORD),
		// @ts-ignore
		additionalHeaders: resolve(options, config.HEADERS),
	}).pipe(
		map(({ token, username, password, additionalHeaders }) => {
			const headers = Object.entries({
				Accept: 'application/json',
				...additionalHeaders,
				...options.headers,
			})
				.filter(([, value]) => value !== undefined && value !== null)
				.reduce((headers, [key, value]) => ({
					...headers,
					[key]: String(value),
				}), {} as Record<string, string>);

			if (isStringWithValue(token)) {
				headers['Authorization'] = \`Bearer \${token}\`;
			}

			if (isStringWithValue(username) && isStringWithValue(password)) {
				const credentials = base64(\`\${username}:\${password}\`);
				headers['Authorization'] = \`Basic \${credentials}\`;
			}

			if (options.body !== undefined) {
				if (options.mediaType) {
					headers['Content-Type'] = options.mediaType;
				} else if (isBlob(options.body)) {
					headers['Content-Type'] = options.body.type || 'application/octet-stream';
				} else if (isString(options.body)) {
					headers['Content-Type'] = 'text/plain';
				} else if (!isFormData(options.body)) {
					headers['Content-Type'] = 'application/json';
				}
			}

			return new HttpHeaders(headers);
		}),
	);
};`},useData:!0},Oe={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getRequestBody = (options: ApiRequestOptions): unknown => {
	if (options.body) {
		if (options.mediaType?.includes('application/json') || options.mediaType?.includes('+json')) {
			return JSON.stringify(options.body);
		} else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {
			return options.body;
		} else {
			return JSON.stringify(options.body);
		}
	}
	return undefined;
};`},useData:!0},ke={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getResponseBody = <T>(response: HttpResponse<T>): T | undefined => {
	if (response.status !== 204 && response.body !== null) {
		return response.body;
	}
	return undefined;
};`},useData:!0},Ae={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getResponseHeader = <T>(response: HttpResponse<T>, responseHeader?: string): string | undefined => {
	if (responseHeader) {
		const value = response.headers.get(responseHeader);
		if (isString(value)) {
			return value;
		}
	}
	return undefined;
};`},useData:!0},je={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){var a=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return`import { HttpClient, HttpHeaders } from '@angular/common/http';
import type { HttpResponse, HttpErrorResponse } from '@angular/common/http';
import { forkJoin, of, throwError } from 'rxjs';
import { catchError, map, switchMap } from 'rxjs/operators';
import type { Observable } from 'rxjs';

import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import type { OpenAPIConfig } from './OpenAPI';

`+(e.invokePartial(a(r,`functions/isString`),t,{name:`functions/isString`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`functions/isStringWithValue`),t,{name:`functions/isStringWithValue`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`functions/isBlob`),t,{name:`functions/isBlob`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`functions/isFormData`),t,{name:`functions/isFormData`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`functions/base64`),t,{name:`functions/base64`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`functions/getQueryString`),t,{name:`functions/getQueryString`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`functions/getUrl`),t,{name:`functions/getUrl`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`functions/getFormData`),t,{name:`functions/getFormData`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`functions/resolve`),t,{name:`functions/resolve`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`angular/getHeaders`),t,{name:`angular/getHeaders`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`angular/getRequestBody`),t,{name:`angular/getRequestBody`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`angular/sendRequest`),t,{name:`angular/sendRequest`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`angular/getResponseHeader`),t,{name:`angular/getResponseHeader`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`angular/getResponseBody`),t,{name:`angular/getResponseBody`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(a(r,`functions/catchErrorCodes`),t,{name:`functions/catchErrorCodes`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param http The Angular HTTP client
 * @param options The request options from the service
 * @returns Observable<T>
 * @throws ApiError
 */
export const request = <T>(config: OpenAPIConfig, http: HttpClient, options: ApiRequestOptions<T>): Observable<T> => {
	const url = getUrl(config, options);
	const formData = getFormData(options);
	const body = getRequestBody(options);

	return getHeaders(config, options).pipe(
		switchMap(headers => {
			return sendRequest<T>(config, options, http, url, body, formData, headers);
		}),
		switchMap(async response => {
			for (const fn of config.interceptors.response._fns) {
				response = await fn(response);
			}
			const responseBody = getResponseBody(response);
			const responseHeader = getResponseHeader(response, options.responseHeader);

			let transformedBody = responseBody;
			if (options.responseTransformer && response.ok) {
				transformedBody = await options.responseTransformer(responseBody)
			}

			return {
				url,
				ok: response.ok,
				status: response.status,
				statusText: response.statusText,
				body: responseHeader ?? transformedBody,
			} as ApiResult;
		}),
		catchError((error: HttpErrorResponse) => {
			if (!error.status) {
				return throwError(() => error);
			}
			return of({
				url,
				ok: error.ok,
				status: error.status,
				statusText: error.statusText,
				body: error.error ?? error.statusText,
			} as ApiResult);
		}),
		map(result => {
			catchErrorCodes(options, result);
			return result.body as T;
		}),
		catchError((error: ApiError) => {
			return throwError(() => error);
		}),
	);
};`},usePartial:!0,useData:!0},Me={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const sendRequest = <T>(
	config: OpenAPIConfig,
	options: ApiRequestOptions<T>,
	http: HttpClient,
	url: string,
	body: unknown,
	formData: FormData | undefined,
	headers: HttpHeaders
): Observable<HttpResponse<T>> => {
	return http.request<T>(options.method, url, {
		headers,
		body: body ?? formData,
		withCredentials: config.WITH_CREDENTIALS,
		observe: 'response',
	});
};`},useData:!0},Ne={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';

export class ApiError extends Error {
	public readonly url: string;
	public readonly status: number;
	public readonly statusText: string;
	public readonly body: unknown;
	public readonly request: ApiRequestOptions;

	constructor(request: ApiRequestOptions, response: ApiResult, message: string) {
		super(message);

		this.name = 'ApiError';
		this.url = response.url;
		this.status = response.status;
		this.statusText = response.statusText;
		this.body = response.body;
		this.request = request;
	}
}`},useData:!0},Pe={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export type ApiRequestOptions<T = unknown> = {
	readonly body?: any;
	readonly cookies?: Record<string, unknown>;
	readonly errors?: Record<number | string, string>;
	readonly formData?: Record<string, unknown> | any[] | Blob | File;
	readonly headers?: Record<string, unknown>;
	readonly mediaType?: string;
	readonly method:
		| 'DELETE'
		| 'GET'
		| 'HEAD'
		| 'OPTIONS'
		| 'PATCH'
		| 'POST'
		| 'PUT';
	readonly path?: Record<string, unknown>;
	readonly query?: Record<string, unknown>;
	readonly responseHeader?: string;
	readonly responseTransformer?: (data: unknown) => Promise<T>;
	readonly url: string;
};`},useData:!0},Fe={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export type ApiResult<TData = any> = {
	readonly body: TData;
	readonly ok: boolean;
	readonly status: number;
	readonly statusText: string;
	readonly url: string;
};`},useData:!0},Ie={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getHeaders = async <T>(config: OpenAPIConfig, options: ApiRequestOptions<T>): Promise<Record<string, string>> => {
	const [token, username, password, additionalHeaders] = await Promise.all([
		// @ts-ignore
		resolve(options, config.TOKEN),
		// @ts-ignore
		resolve(options, config.USERNAME),
		// @ts-ignore
		resolve(options, config.PASSWORD),
		// @ts-ignore
		resolve(options, config.HEADERS),
	]);

	const headers = Object.entries({
		Accept: 'application/json',
		...additionalHeaders,
		...options.headers,
	})
	.filter(([, value]) => value !== undefined && value !== null)
	.reduce((headers, [key, value]) => ({
		...headers,
		[key]: String(value),
	}), {} as Record<string, string>);

	if (isStringWithValue(token)) {
		headers['Authorization'] = \`Bearer \${token}\`;
	}

	if (isStringWithValue(username) && isStringWithValue(password)) {
		const credentials = base64(\`\${username}:\${password}\`);
		headers['Authorization'] = \`Basic \${credentials}\`;
	}

	if (options.body !== undefined) {
		if (options.mediaType) {
			headers['Content-Type'] = options.mediaType;
		} else if (isBlob(options.body)) {
			headers['Content-Type'] = options.body.type || 'application/octet-stream';
		} else if (isString(options.body)) {
			headers['Content-Type'] = 'text/plain';
		} else if (!isFormData(options.body)) {
			headers['Content-Type'] = 'application/json';
		}
	} else if (options.formData !== undefined) {
		if (options.mediaType) {
			headers['Content-Type'] = options.mediaType;
		}
	}

	return headers;
};`},useData:!0},Le={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getRequestBody = (options: ApiRequestOptions): unknown => {
	if (options.body) {
		return options.body;
	}
	return undefined;
};`},useData:!0},Re={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getResponseBody = (response: AxiosResponse<unknown>): unknown => {
	if (response.status !== 204) {
		return response.data;
	}
	return undefined;
};`},useData:!0},ze={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getResponseHeader = (response: AxiosResponse<unknown>, responseHeader?: string): string | undefined => {
	if (responseHeader) {
		const content = response.headers[responseHeader];
		if (isString(content)) {
			return content;
		}
	}
	return undefined;
};`},useData:!0},Be={1:function(e,t,n,r,i){return`ApiResult<T>`},3:function(e,t,n,r,i){return`T`},5:function(e,t,n,r,i){return`result.body`},7:function(e,t,n,r,i){return`result`},compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){var a=t??(e.nullContext||{}),o=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return`import axios from 'axios';
import type { AxiosError, AxiosRequestConfig, AxiosResponse, AxiosInstance } from 'axios';

import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import { CancelablePromise } from './CancelablePromise';
import type { OnCancel } from './CancelablePromise';
import type { OpenAPIConfig } from './OpenAPI';

`+(e.invokePartial(o(r,`functions/isString`),t,{name:`functions/isString`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/isStringWithValue`),t,{name:`functions/isStringWithValue`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/isBlob`),t,{name:`functions/isBlob`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/isFormData`),t,{name:`functions/isFormData`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/isSuccess`),t,{name:`functions/isSuccess`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/base64`),t,{name:`functions/base64`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/getQueryString`),t,{name:`functions/getQueryString`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/getUrl`),t,{name:`functions/getUrl`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/getFormData`),t,{name:`functions/getFormData`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/resolve`),t,{name:`functions/resolve`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`axios/getHeaders`),t,{name:`axios/getHeaders`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`axios/getRequestBody`),t,{name:`axios/getRequestBody`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`axios/sendRequest`),t,{name:`axios/sendRequest`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`axios/getResponseHeader`),t,{name:`axios/getResponseHeader`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`axios/getResponseBody`),t,{name:`axios/getResponseBody`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/catchErrorCodes`),t,{name:`functions/catchErrorCodes`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @param axiosClient The axios client instance to use
 * @returns CancelablePromise<`+(o(n,`ifServicesResponse`).call(a,`response`,{name:`ifServicesResponse`,hash:{},fn:e.program(1,i,0),inverse:e.program(3,i,0),data:i,loc:{start:{line:64,column:30},end:{line:64,column:108}}})??``)+`>
 * @throws ApiError
 */
export const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions<T>, axiosClient: AxiosInstance = axios): CancelablePromise<`+(o(n,`ifServicesResponse`).call(a,`response`,{name:`ifServicesResponse`,hash:{},fn:e.program(1,i,0),inverse:e.program(3,i,0),data:i,loc:{start:{line:67,column:136},end:{line:67,column:214}}})??``)+`> => {
	return new CancelablePromise(async (resolve, reject, onCancel) => {
		try {
			const url = getUrl(config, options);
			const formData = getFormData(options);
			const body = getRequestBody(options);
			const headers = await getHeaders(config, options);

			if (!onCancel.isCancelled) {
				let response = await sendRequest<T>(config, options, url, body, formData, headers, onCancel, axiosClient);

				for (const fn of config.interceptors.response._fns) {
					response = await fn(response);
				}

				const responseBody = getResponseBody(response);
				const responseHeader = getResponseHeader(response, options.responseHeader);

				let transformedBody = responseBody;
				if (options.responseTransformer && isSuccess(response.status)) {
					transformedBody = await options.responseTransformer(responseBody)
				}

				const result: ApiResult = {
					url,
					ok: isSuccess(response.status),
					status: response.status,
					statusText: response.statusText,
					body: responseHeader ?? transformedBody,
				};

				catchErrorCodes(options, result);

				resolve(`+(o(n,`ifServicesResponse`).call(a,`body`,{name:`ifServicesResponse`,hash:{},fn:e.program(5,i,0),inverse:e.program(7,i,0),data:i,loc:{start:{line:100,column:12},end:{line:100,column:90}}})??``)+`);
			}
		} catch (error) {
			reject(error);
		}
	});
};`},usePartial:!0,useData:!0},Ve={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const sendRequest = async <T>(
	config: OpenAPIConfig,
	options: ApiRequestOptions<T>,
	url: string,
	body: unknown,
	formData: FormData | undefined,
	headers: Record<string, string>,
	onCancel: OnCancel,
	axiosClient: AxiosInstance
): Promise<AxiosResponse<T>> => {
	const controller = new AbortController();

	let requestConfig: AxiosRequestConfig = {
		data: body ?? formData,
		headers,
		method: options.method,
		signal: controller.signal,
		url,
		withCredentials: config.WITH_CREDENTIALS,
	};

	onCancel(() => controller.abort());

	for (const fn of config.interceptors.request._fns) {
		requestConfig = await fn(requestConfig);
	}

	try {
		return await axiosClient.request(requestConfig);
	} catch (error) {
		const axiosError = error as AxiosError<T>;
		if (axiosError.response) {
			return axiosError.response;
		}
		throw error;
	}
};`},useData:!0},He={1:function(e,t,n,r,i){return`import type { HttpClient } from '@angular/common/http';
import type { Observable } from 'rxjs';

import type { ApiRequestOptions } from './ApiRequestOptions';
import type { OpenAPIConfig } from './OpenAPI';
`},3:function(e,t,n,r,i){return`import type { ApiRequestOptions } from './ApiRequestOptions';
import type { CancelablePromise } from './CancelablePromise';
import type { OpenAPIConfig } from './OpenAPI';
`},5:function(e,t,n,r,i){return`	constructor(
		public readonly config: OpenAPIConfig,
		public readonly http: HttpClient,
	) {}
`},7:function(e,t,n,r,i){return`	constructor(public readonly config: OpenAPIConfig) {}
`},9:function(e,t,n,r,i){return`	public abstract request<T>(options: ApiRequestOptions<T>): Observable<T>;
`},11:function(e,t,n,r,i){return`	public abstract request<T>(options: ApiRequestOptions<T>): CancelablePromise<T>;
`},compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){var a=t??(e.nullContext||{}),o=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(1,i,0),inverse:e.program(3,i,0),data:i,loc:{start:{line:1,column:0},end:{line:11,column:11}}})??``)+`
export abstract class BaseHttpRequest {

`+(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(5,i,0),inverse:e.program(7,i,0),data:i,loc:{start:{line:15,column:1},end:{line:22,column:12}}})??``)+`
`+(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(9,i,0),inverse:e.program(11,i,0),data:i,loc:{start:{line:24,column:1},end:{line:28,column:12}}})??``)+`}`},useData:!0},Ue={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export class CancelError extends Error {
	constructor(message: string) {
		super(message);
		this.name = 'CancelError';
	}

	public get isCancelled(): boolean {
		return true;
	}
}

export interface OnCancel {
	readonly isResolved: boolean;
	readonly isRejected: boolean;
	readonly isCancelled: boolean;

	(cancelHandler: () => void): void;
}

export class CancelablePromise<T> implements Promise<T> {
	private _isResolved: boolean;
	private _isRejected: boolean;
	private _isCancelled: boolean;
	readonly cancelHandlers: (() => void)[];
	readonly promise: Promise<T>;
	private _resolve?: (value: T | PromiseLike<T>) => void;
	private _reject?: (reason?: unknown) => void;

	constructor(
		executor: (
			resolve: (value: T | PromiseLike<T>) => void,
			reject: (reason?: unknown) => void,
			onCancel: OnCancel
		) => void
	) {
		this._isResolved = false;
		this._isRejected = false;
		this._isCancelled = false;
		this.cancelHandlers = [];
		this.promise = new Promise<T>((resolve, reject) => {
			this._resolve = resolve;
			this._reject = reject;

			const onResolve = (value: T | PromiseLike<T>): void => {
				if (this._isResolved || this._isRejected || this._isCancelled) {
					return;
				}
				this._isResolved = true;
				if (this._resolve) this._resolve(value);
			};

			const onReject = (reason?: unknown): void => {
				if (this._isResolved || this._isRejected || this._isCancelled) {
					return;
				}
				this._isRejected = true;
				if (this._reject) this._reject(reason);
			};

			const onCancel = (cancelHandler: () => void): void => {
				if (this._isResolved || this._isRejected || this._isCancelled) {
					return;
				}
				this.cancelHandlers.push(cancelHandler);
			};

			Object.defineProperty(onCancel, 'isResolved', {
				get: (): boolean => this._isResolved,
			});

			Object.defineProperty(onCancel, 'isRejected', {
				get: (): boolean => this._isRejected,
			});

			Object.defineProperty(onCancel, 'isCancelled', {
				get: (): boolean => this._isCancelled,
			});

			return executor(onResolve, onReject, onCancel as OnCancel);
		});
	}

	get [Symbol.toStringTag](): string {
		return "Cancellable Promise";
	}

	public then<TResult1 = T, TResult2 = never>(
		onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
		onRejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null
	): Promise<TResult1 | TResult2> {
		return this.promise.then(onFulfilled, onRejected);
	}

	public catch<TResult = never>(
		onRejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null
	): Promise<T | TResult> {
		return this.promise.catch(onRejected);
	}

	public finally(onFinally?: (() => void) | null): Promise<T> {
		return this.promise.finally(onFinally);
	}

	public cancel(): void {
		if (this._isResolved || this._isRejected || this._isCancelled) {
			return;
		}
		this._isCancelled = true;
		if (this.cancelHandlers.length) {
			try {
				for (const cancelHandler of this.cancelHandlers) {
					cancelHandler();
				}
			} catch (error) {
				console.warn('Cancellation threw an error', error);
				return;
			}
		}
		this.cancelHandlers.length = 0;
		if (this._reject) this._reject(new CancelError('Request aborted'));
	}

	public get isCancelled(): boolean {
		return this._isCancelled;
	}
}`},useData:!0},We={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getHeaders = async <T>(config: OpenAPIConfig, options: ApiRequestOptions<T>): Promise<Headers> => {
	const [token, username, password, additionalHeaders] = await Promise.all([
		// @ts-ignore
		resolve(options, config.TOKEN),
		// @ts-ignore
		resolve(options, config.USERNAME),
		// @ts-ignore
		resolve(options, config.PASSWORD),
		// @ts-ignore
		resolve(options, config.HEADERS),
	]);

	const headers = Object.entries({
		Accept: 'application/json',
		...additionalHeaders,
		...options.headers,
	})
		.filter(([, value]) => value !== undefined && value !== null)
		.reduce((headers, [key, value]) => ({
			...headers,
			[key]: String(value),
		}), {} as Record<string, string>);

	if (isStringWithValue(token)) {
		headers['Authorization'] = \`Bearer \${token}\`;
	}

	if (isStringWithValue(username) && isStringWithValue(password)) {
		const credentials = base64(\`\${username}:\${password}\`);
		headers['Authorization'] = \`Basic \${credentials}\`;
	}

	if (options.body !== undefined) {
		if (options.mediaType) {
			headers['Content-Type'] = options.mediaType;
		} else if (isBlob(options.body)) {
			headers['Content-Type'] = options.body.type || 'application/octet-stream';
		} else if (isString(options.body)) {
			headers['Content-Type'] = 'text/plain';
		} else if (!isFormData(options.body)) {
			headers['Content-Type'] = 'application/json';
		}
	}

	return new Headers(headers);
};`},useData:!0},Ge={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getRequestBody = (options: ApiRequestOptions): unknown => {
	if (options.body !== undefined) {
		if (options.mediaType?.includes('application/json') || options.mediaType?.includes('+json')) {
			return JSON.stringify(options.body);
		} else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {
			return options.body;
		} else {
			return JSON.stringify(options.body);
		}
	}
	return undefined;
};`},useData:!0},Ke={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getResponseBody = async (response: Response): Promise<unknown> => {
	if (response.status !== 204) {
		try {
			const contentType = response.headers.get('Content-Type');
			if (contentType) {
				const binaryTypes = ['application/octet-stream', 'application/pdf', 'application/zip', 'audio/', 'image/', 'video/'];
				if (contentType.includes('application/json') || contentType.includes('+json')) {
					return await response.json();
				} else if (binaryTypes.some(type => contentType.includes(type))) {
					return await response.blob();
				} else if (contentType.includes('multipart/form-data')) {
					return await response.formData();
				} else if (contentType.includes('text/')) {
					return await response.text();
				}
			}
		} catch (error) {
			console.error(error);
		}
	}
	return undefined;
};`},useData:!0},qe={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getResponseHeader = (response: Response, responseHeader?: string): string | undefined => {
	if (responseHeader) {
		const content = response.headers.get(responseHeader);
		if (isString(content)) {
			return content;
		}
	}
	return undefined;
};`},useData:!0},Je={1:function(e,t,n,r,i){return`import fetch, { FormData, Headers } from 'node-fetch';
import type { RequestInit, Response } from 'node-fetch';

`},3:function(e,t,n,r,i){return`ApiResult<T>`},5:function(e,t,n,r,i){return`T`},7:function(e,t,n,r,i){return`result.body`},9:function(e,t,n,r,i){return`result`},compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){var a=t??(e.nullContext||{}),o=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/node`,{name:`equals`,hash:{},fn:e.program(1,i,0),inverse:e.noop,data:i,loc:{start:{line:1,column:0},end:{line:5,column:11}}})??``)+`import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import { CancelablePromise } from './CancelablePromise';
import type { OnCancel } from './CancelablePromise';
import type { OpenAPIConfig } from './OpenAPI';

`+(e.invokePartial(o(r,`functions/isString`),t,{name:`functions/isString`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/isStringWithValue`),t,{name:`functions/isStringWithValue`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/isBlob`),t,{name:`functions/isBlob`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/isFormData`),t,{name:`functions/isFormData`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/base64`),t,{name:`functions/base64`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/getQueryString`),t,{name:`functions/getQueryString`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/getUrl`),t,{name:`functions/getUrl`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/getFormData`),t,{name:`functions/getFormData`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/resolve`),t,{name:`functions/resolve`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`fetch/getHeaders`),t,{name:`fetch/getHeaders`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`fetch/getRequestBody`),t,{name:`fetch/getRequestBody`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`fetch/sendRequest`),t,{name:`fetch/sendRequest`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`fetch/getResponseHeader`),t,{name:`fetch/getResponseHeader`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`fetch/getResponseBody`),t,{name:`fetch/getResponseBody`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/catchErrorCodes`),t,{name:`functions/catchErrorCodes`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @returns CancelablePromise<`+(o(n,`ifServicesResponse`).call(a,`response`,{name:`ifServicesResponse`,hash:{},fn:e.program(3,i,0),inverse:e.program(5,i,0),data:i,loc:{start:{line:62,column:30},end:{line:62,column:108}}})??``)+`>
 * @throws ApiError
 */
export const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions<T>): CancelablePromise<`+(o(n,`ifServicesResponse`).call(a,`response`,{name:`ifServicesResponse`,hash:{},fn:e.program(3,i,0),inverse:e.program(5,i,0),data:i,loc:{start:{line:65,column:100},end:{line:65,column:178}}})??``)+`> => {
	return new CancelablePromise(async (resolve, reject, onCancel) => {
		try {
			const url = getUrl(config, options);
			const formData = getFormData(options);
			const body = getRequestBody(options);
			const headers = await getHeaders(config, options);

			if (!onCancel.isCancelled) {
				let response = await sendRequest(config, options, url, body, formData, headers, onCancel);

				for (const fn of config.interceptors.response._fns) {
					response = await fn(response);
				}

				const responseBody = await getResponseBody(response);
				const responseHeader = getResponseHeader(response, options.responseHeader);

				let transformedBody = responseBody;
				if (options.responseTransformer && response.ok) {
					transformedBody = await options.responseTransformer(responseBody)
				}

				const result: ApiResult = {
					url,
					ok: response.ok,
					status: response.status,
					statusText: response.statusText,
					body: responseHeader ?? transformedBody,
				};

				catchErrorCodes(options, result);

				resolve(`+(o(n,`ifServicesResponse`).call(a,`body`,{name:`ifServicesResponse`,hash:{},fn:e.program(7,i,0),inverse:e.program(9,i,0),data:i,loc:{start:{line:98,column:12},end:{line:98,column:90}}})??``)+`);
			}
		} catch (error) {
			reject(error);
		}
	});
};`},usePartial:!0,useData:!0},Ye={1:function(e,t,n,r,i){return`	if (config.WITH_CREDENTIALS) {
		request.credentials = config.CREDENTIALS;
	}
`},compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){var a=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return`export const sendRequest = async (
	config: OpenAPIConfig,
	options: ApiRequestOptions,
	url: string,
	body: any,
	formData: FormData | undefined,
	headers: Headers,
	onCancel: OnCancel
): Promise<Response> => {
	const controller = new AbortController();

	let request: RequestInit = {
		headers,
		body: body ?? formData,
		method: options.method,
		signal: controller.signal,
	};

`+(a(n,`equals`).call(t??(e.nullContext||{}),a(a(a(a(i,`root`),`$config`),`client`),`name`),`legacy/fetch`,{name:`equals`,hash:{},fn:e.program(1,i,0),inverse:e.noop,data:i,loc:{start:{line:19,column:1},end:{line:23,column:12}}})??``)+`
	for (const fn of config.interceptors.request._fns) {
		request = await fn(request);
	}

	onCancel(() => controller.abort());

	return await fetch(url, request);
};`},useData:!0},Xe={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const base64 = (str: string): string => {
	try {
		return btoa(str);
	} catch (err) {
		// @ts-ignore
		return Buffer.from(str).toString('base64');
	}
};`},useData:!0},Ze={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const catchErrorCodes = (options: ApiRequestOptions, result: ApiResult): void => {
	const errors: Record<number, string> = {
		400: 'Bad Request',
		401: 'Unauthorized',
		402: 'Payment Required',
		403: 'Forbidden',
		404: 'Not Found',
		405: 'Method Not Allowed',
		406: 'Not Acceptable',
		407: 'Proxy Authentication Required',
		408: 'Request Timeout',
		409: 'Conflict',
		410: 'Gone',
		411: 'Length Required',
		412: 'Precondition Failed',
		413: 'Payload Too Large',
		414: 'URI Too Long',
		415: 'Unsupported Media Type',
		416: 'Range Not Satisfiable',
		417: 'Expectation Failed',
		418: 'Im a teapot',
		421: 'Misdirected Request',
		422: 'Unprocessable Content',
		423: 'Locked',
		424: 'Failed Dependency',
		425: 'Too Early',
		426: 'Upgrade Required',
		428: 'Precondition Required',
		429: 'Too Many Requests',
		431: 'Request Header Fields Too Large',
		451: 'Unavailable For Legal Reasons',
		500: 'Internal Server Error',
		501: 'Not Implemented',
		502: 'Bad Gateway',
		503: 'Service Unavailable',
		504: 'Gateway Timeout',
		505: 'HTTP Version Not Supported',
		506: 'Variant Also Negotiates',
		507: 'Insufficient Storage',
		508: 'Loop Detected',
		510: 'Not Extended',
		511: 'Network Authentication Required',
		...options.errors,
	}

	const error = errors[result.status];
	if (error) {
		throw new ApiError(options, result, error);
	}

	if (!result.ok) {
		const errorStatus = result.status ?? 'unknown';
		const errorStatusText = result.statusText ?? 'unknown';
		const errorBody = (() => {
			try {
				return JSON.stringify(result.body, null, 2);
			} catch (e) {
				return undefined;
			}
		})();

		throw new ApiError(options, result,
			\`Generic Error: status: \${errorStatus}; status text: \${errorStatusText}; body: \${errorBody}\`
		);
	}
};`},useData:!0},Qe={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getFormData = (options: ApiRequestOptions): FormData | undefined => {
	if (options.formData) {
		const formData = new FormData();

		const process = (key: string, value: unknown) => {
			if (isString(value) || isBlob(value)) {
				formData.append(key, value);
			} else {
				formData.append(key, JSON.stringify(value));
			}
		};

		Object.entries(options.formData)
			.filter(([, value]) => value !== undefined && value !== null)
			.forEach(([key, value]) => {
				if (Array.isArray(value)) {
					value.forEach(v => process(key, v));
				} else {
					process(key, value);
				}
			});

		return formData;
	}
	return undefined;
};`},useData:!0},$e={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getQueryString = (params: Record<string, unknown>): string => {
	const qs: string[] = [];

	const append = (key: string, value: unknown) => {
		qs.push(\`\${encodeURIComponent(key)}=\${encodeURIComponent(String(value))}\`);
	};

	const encodePair = (key: string, value: unknown) => {
		if (value === undefined || value === null) {
			return;
		}

		if (value instanceof Date) {
			append(key, value.toISOString());
		} else if (Array.isArray(value)) {
			value.forEach(v => encodePair(key, v));
		} else if (typeof value === 'object') {
			Object.entries(value).forEach(([k, v]) => encodePair(\`\${key}[\${k}]\`, v));
		} else {
			append(key, value);
		}
	};

	Object.entries(params).forEach(([key, value]) => encodePair(key, value));

	return qs.length ? \`?\${qs.join('&')}\` : '';
};`},useData:!0},et={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`const getUrl = (config: OpenAPIConfig, options: ApiRequestOptions): string => {
	const encoder = config.ENCODE_PATH || encodeURI;

	const path = options.url
		.replace('{api-version}', config.VERSION)
		.replace(/{(.*?)}/g, (substring: string, group: string) => {
			if (options.path?.hasOwnProperty(group)) {
				return encoder(String(options.path[group]));
			}
			return substring;
		});

	const url = config.BASE + path;
	return options.query ? url + getQueryString(options.query) : url;
};`},useData:!0},tt={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const isBlob = (value: any): value is Blob => {
	return value instanceof Blob;
};`},useData:!0},nt={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const isFormData = (value: unknown): value is FormData => {
	return value instanceof FormData;
};`},useData:!0},rt={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const isString = (value: unknown): value is string => {
	return typeof value === 'string';
};`},useData:!0},it={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const isStringWithValue = (value: unknown): value is string => {
	return isString(value) && value !== '';
};`},useData:!0},at={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const isSuccess = (status: number): boolean => {
	return status >= 200 && status < 300;
};`},useData:!0},ot={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`type Resolver<T> = (options: ApiRequestOptions<T>) => Promise<T>;

export const resolve = async <T>(options: ApiRequestOptions<T>, resolver?: T | Resolver<T>): Promise<T | undefined> => {
	if (typeof resolver === 'function') {
		return (resolver as Resolver<T>)(options);
	}
	return resolver;
};`},useData:!0},st={1:function(e,t,n,r,i){return`import { Inject, Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import type { Observable } from 'rxjs';

import type { ApiRequestOptions } from './ApiRequestOptions';
import { BaseHttpRequest } from './BaseHttpRequest';
import type { OpenAPIConfig } from './OpenAPI';
import { OpenAPI } from './OpenAPI';
import { request as __request } from './request';
`},3:function(e,t,n,r,i){return`import type { ApiRequestOptions } from './ApiRequestOptions';
import { BaseHttpRequest } from './BaseHttpRequest';
import type { CancelablePromise } from './CancelablePromise';
import type { OpenAPIConfig } from './OpenAPI';
import { request as __request } from './request';
`},5:function(e,t,n,r,i){return`@Injectable()
`},7:function(e,t,n,r,i){return`	constructor(
		@Inject(OpenAPI)
		config: OpenAPIConfig,
		http: HttpClient,
	) {
		super(config, http);
	}
`},9:function(e,t,n,r,i){return`	constructor(config: OpenAPIConfig) {
		super(config);
	}
`},11:function(e,t,n,r,i){return`	/**
	 * Request method
	 * @param options The request options from the service
	 * @returns Observable<T>
	 * @throws ApiError
	 */
	public override request<T>(options: ApiRequestOptions<T>): Observable<T> {
		return __request(this.config, this.http, options);
	}
`},13:function(e,t,n,r,i){return`	/**
	 * Request method
	 * @param options The request options from the service
	 * @returns CancelablePromise<T>
	 * @throws ApiError
	 */
	public override request<T>(options: ApiRequestOptions<T>): CancelablePromise<T> {
		return __request(this.config, options);
	}
`},compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){var a=t??(e.nullContext||{}),o=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(1,i,0),inverse:e.program(3,i,0),data:i,loc:{start:{line:1,column:0},end:{line:17,column:11}}})??``)+`
`+(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(5,i,0),inverse:e.noop,data:i,loc:{start:{line:19,column:0},end:{line:21,column:11}}})??``)+`export class `+(e.lambda(e.strict(t,`httpRequest`,{start:{line:22,column:15},end:{line:22,column:26}}),t)??``)+` extends BaseHttpRequest {

`+(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(7,i,0),inverse:e.program(9,i,0),data:i,loc:{start:{line:24,column:1},end:{line:36,column:12}}})??``)+`
`+(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(11,i,0),inverse:e.program(13,i,0),data:i,loc:{start:{line:38,column:1},end:{line:58,column:12}}})??``)+`}`},useData:!0},ct={1:function(e,t,n,r,i){return`import type { HttpResponse } from '@angular/common/http';
`},3:function(e,t,n,r,i){return`import type { AxiosRequestConfig, AxiosResponse } from 'axios';
`},5:function(e,t,n,r,i){return`import type { RequestInit, Response } from 'node-fetch';
`},7:function(e,t,n,r,i){return`		response: Interceptors<HttpResponse<any>>;
`},9:function(e,t,n,r,i){return`		request: Interceptors<AxiosRequestConfig>;
		response: Interceptors<AxiosResponse>;
`},11:function(e,t,n,r,i){return`		request: Interceptors<RequestInit>;
		response: Interceptors<Response>;
`},13:function(e,t,n,r,i){return`		request: Interceptors<XMLHttpRequest>;
		response: Interceptors<XMLHttpRequest>;
`},15:function(e,t,n,r,i){return`		request: new Interceptors(),
`},compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){var a=t??(e.nullContext||{}),o=e.strict,s=e.lambda,c=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return(c(n,`equals`).call(a,c(c(c(c(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(1,i,0),inverse:e.noop,data:i,loc:{start:{line:1,column:0},end:{line:3,column:11}}})??``)+(c(n,`equals`).call(a,c(c(c(c(i,`root`),`$config`),`client`),`name`),`legacy/axios`,{name:`equals`,hash:{},fn:e.program(3,i,0),inverse:e.noop,data:i,loc:{start:{line:4,column:0},end:{line:6,column:11}}})??``)+(c(n,`equals`).call(a,c(c(c(c(i,`root`),`$config`),`client`),`name`),`legacy/node`,{name:`equals`,hash:{},fn:e.program(5,i,0),inverse:e.noop,data:i,loc:{start:{line:7,column:0},end:{line:9,column:11}}})??``)+`import type { ApiRequestOptions } from './ApiRequestOptions';

type Headers = Record<string, string>;
type Middleware<T> = (value: T) => T | Promise<T>;
type Resolver<T> = (options: ApiRequestOptions<T>) => Promise<T>;

export class Interceptors<T> {
  _fns: Middleware<T>[];

  constructor() {
    this._fns = [];
  }

  eject(fn: Middleware<T>): void {
    const index = this._fns.indexOf(fn);
    if (index !== -1) {
      this._fns = [...this._fns.slice(0, index), ...this._fns.slice(index + 1)];
    }
  }

  use(fn: Middleware<T>): void {
    this._fns = [...this._fns, fn];
  }
}

export type OpenAPIConfig = {
	BASE: string;
	CREDENTIALS: 'include' | 'omit' | 'same-origin';
	ENCODE_PATH?: ((path: string) => string) | undefined;
	HEADERS?: Headers | Resolver<Headers> | undefined;
	PASSWORD?: string | Resolver<string> | undefined;
	TOKEN?: string | Resolver<string> | undefined;
	USERNAME?: string | Resolver<string> | undefined;
	VERSION: string;
	WITH_CREDENTIALS: boolean;
	interceptors: {
`+(c(n,`equals`).call(a,c(c(c(c(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(7,i,0),inverse:e.noop,data:i,loc:{start:{line:46,column:2},end:{line:48,column:13}}})??``)+(c(n,`equals`).call(a,c(c(c(c(i,`root`),`$config`),`client`),`name`),`legacy/axios`,{name:`equals`,hash:{},fn:e.program(9,i,0),inverse:e.noop,data:i,loc:{start:{line:49,column:2},end:{line:52,column:13}}})??``)+(c(n,`equals`).call(a,c(c(c(c(i,`root`),`$config`),`client`),`name`),`legacy/fetch`,{name:`equals`,hash:{},fn:e.program(11,i,0),inverse:e.noop,data:i,loc:{start:{line:53,column:2},end:{line:56,column:13}}})??``)+(c(n,`equals`).call(a,c(c(c(c(i,`root`),`$config`),`client`),`name`),`legacy/node`,{name:`equals`,hash:{},fn:e.program(11,i,0),inverse:e.noop,data:i,loc:{start:{line:57,column:2},end:{line:60,column:13}}})??``)+(c(n,`equals`).call(a,c(c(c(c(i,`root`),`$config`),`client`),`name`),`legacy/xhr`,{name:`equals`,hash:{},fn:e.program(13,i,0),inverse:e.noop,data:i,loc:{start:{line:61,column:2},end:{line:64,column:13}}})??``)+`	};
};

export const OpenAPI: OpenAPIConfig = {
	BASE: '`+(s(o(t,`server`,{start:{line:69,column:11},end:{line:69,column:17}}),t)??``)+`',
	CREDENTIALS: 'include',
	ENCODE_PATH: undefined,
	HEADERS: undefined,
	PASSWORD: undefined,
	TOKEN: undefined,
	USERNAME: undefined,
	VERSION: '`+(s(o(t,`version`,{start:{line:76,column:14},end:{line:76,column:21}}),t)??``)+`',
	WITH_CREDENTIALS: false,
	interceptors: {
`+(c(n,`notEquals`).call(a,c(c(c(c(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`notEquals`,hash:{},fn:e.program(15,i,0),inverse:e.noop,data:i,loc:{start:{line:79,column:2},end:{line:81,column:16}}})??``)+`		response: new Interceptors(),
	},
};`},useData:!0},lt={1:function(e,t,n,r,i){var a=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return e.invokePartial(a(r,`angular/request`),t,{name:`angular/request`,data:i,helpers:n,partials:r,decorators:e.decorators})??``},3:function(e,t,n,r,i){var a=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return e.invokePartial(a(r,`axios/request`),t,{name:`axios/request`,data:i,helpers:n,partials:r,decorators:e.decorators})??``},5:function(e,t,n,r,i){var a=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return e.invokePartial(a(r,`fetch/request`),t,{name:`fetch/request`,data:i,helpers:n,partials:r,decorators:e.decorators})??``},7:function(e,t,n,r,i){var a=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return e.invokePartial(a(r,`xhr/request`),t,{name:`xhr/request`,data:i,helpers:n,partials:r,decorators:e.decorators})??``},compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){var a=t??(e.nullContext||{}),o=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/angular`,{name:`equals`,hash:{},fn:e.program(1,i,0),inverse:e.noop,data:i,loc:{start:{line:1,column:0},end:{line:1,column:87}}})??``)+(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/axios`,{name:`equals`,hash:{},fn:e.program(3,i,0),inverse:e.noop,data:i,loc:{start:{line:2,column:0},end:{line:2,column:83}}})??``)+(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/fetch`,{name:`equals`,hash:{},fn:e.program(5,i,0),inverse:e.noop,data:i,loc:{start:{line:3,column:0},end:{line:3,column:83}}})??``)+(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/node`,{name:`equals`,hash:{},fn:e.program(5,i,0),inverse:e.noop,data:i,loc:{start:{line:4,column:0},end:{line:4,column:82}}})??``)+(o(n,`equals`).call(a,o(o(o(o(i,`root`),`$config`),`client`),`name`),`legacy/xhr`,{name:`equals`,hash:{},fn:e.program(7,i,0),inverse:e.noop,data:i,loc:{start:{line:5,column:0},end:{line:5,column:79}}})??``)},usePartial:!0,useData:!0},ut={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getHeaders = async <T>(config: OpenAPIConfig, options: ApiRequestOptions<T>): Promise<Headers> => {
	const [token, username, password, additionalHeaders] = await Promise.all([
		// @ts-ignore
		resolve(options, config.TOKEN),
		// @ts-ignore
		resolve(options, config.USERNAME),
		// @ts-ignore
		resolve(options, config.PASSWORD),
		// @ts-ignore
		resolve(options, config.HEADERS),
	]);

	const headers = Object.entries({
		Accept: 'application/json',
		...additionalHeaders,
		...options.headers,
	})
		.filter(([, value]) => value !== undefined && value !== null)
		.reduce((headers, [key, value]) => ({
			...headers,
			[key]: String(value),
		}), {} as Record<string, string>);

	if (isStringWithValue(token)) {
		headers['Authorization'] = \`Bearer \${token}\`;
	}

	if (isStringWithValue(username) && isStringWithValue(password)) {
		const credentials = base64(\`\${username}:\${password}\`);
		headers['Authorization'] = \`Basic \${credentials}\`;
	}

	if (options.body !== undefined) {
		if (options.mediaType) {
			headers['Content-Type'] = options.mediaType;
		} else if (isBlob(options.body)) {
			headers['Content-Type'] = options.body.type || 'application/octet-stream';
		} else if (isString(options.body)) {
			headers['Content-Type'] = 'text/plain';
		} else if (!isFormData(options.body)) {
			headers['Content-Type'] = 'application/json';
		}
	}

	return new Headers(headers);
};`},useData:!0},dt={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getRequestBody = (options: ApiRequestOptions): unknown => {
	if (options.body !== undefined) {
		if (options.mediaType?.includes('application/json') || options.mediaType?.includes('+json')) {
			return JSON.stringify(options.body);
		} else if (isString(options.body) || isBlob(options.body) || isFormData(options.body)) {
			return options.body;
		} else {
			return JSON.stringify(options.body);
		}
	}
	return undefined;
};`},useData:!0},ft={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getResponseBody = (xhr: XMLHttpRequest): unknown => {
	if (xhr.status !== 204) {
		try {
			const contentType = xhr.getResponseHeader('Content-Type');
			if (contentType) {
				if (contentType.includes('application/json') || contentType.includes('+json')) {
					return JSON.parse(xhr.responseText);
				} else {
					return xhr.responseText;
				}
			}
		} catch (error) {
			console.error(error);
		}
	}
	return undefined;
};`},useData:!0},pt={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const getResponseHeader = (xhr: XMLHttpRequest, responseHeader?: string): string | undefined => {
	if (responseHeader) {
		const content = xhr.getResponseHeader(responseHeader);
		if (isString(content)) {
			return content;
		}
	}
	return undefined;
};`},useData:!0},mt={1:function(e,t,n,r,i){return`ApiResult<T>`},3:function(e,t,n,r,i){return`T`},5:function(e,t,n,r,i){return`result.body`},7:function(e,t,n,r,i){return`result`},compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){var a=t??(e.nullContext||{}),o=e.lookupProperty||function(e,t){if(Object.prototype.hasOwnProperty.call(e,t))return e[t]};return`import { ApiError } from './ApiError';
import type { ApiRequestOptions } from './ApiRequestOptions';
import type { ApiResult } from './ApiResult';
import { CancelablePromise } from './CancelablePromise';
import type { OnCancel } from './CancelablePromise';
import type { OpenAPIConfig } from './OpenAPI';

`+(e.invokePartial(o(r,`functions/isString`),t,{name:`functions/isString`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/isStringWithValue`),t,{name:`functions/isStringWithValue`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/isBlob`),t,{name:`functions/isBlob`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/isFormData`),t,{name:`functions/isFormData`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/isSuccess`),t,{name:`functions/isSuccess`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/base64`),t,{name:`functions/base64`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/getQueryString`),t,{name:`functions/getQueryString`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/getUrl`),t,{name:`functions/getUrl`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/getFormData`),t,{name:`functions/getFormData`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/resolve`),t,{name:`functions/resolve`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`fetch/getHeaders`),t,{name:`fetch/getHeaders`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`xhr/getRequestBody`),t,{name:`xhr/getRequestBody`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`xhr/sendRequest`),t,{name:`xhr/sendRequest`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`xhr/getResponseHeader`),t,{name:`xhr/getResponseHeader`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`xhr/getResponseBody`),t,{name:`xhr/getResponseBody`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

`+(e.invokePartial(o(r,`functions/catchErrorCodes`),t,{name:`functions/catchErrorCodes`,data:i,helpers:n,partials:r,decorators:e.decorators})??``)+`

/**
 * Request method
 * @param config The OpenAPI configuration object
 * @param options The request options from the service
 * @returns CancelablePromise<`+(o(n,`ifServicesResponse`).call(a,`response`,{name:`ifServicesResponse`,hash:{},fn:e.program(1,i,0),inverse:e.program(3,i,0),data:i,loc:{start:{line:60,column:30},end:{line:60,column:108}}})??``)+`>
 * @throws ApiError
 */
export const request = <T>(config: OpenAPIConfig, options: ApiRequestOptions<T>): CancelablePromise<`+(o(n,`ifServicesResponse`).call(a,`response`,{name:`ifServicesResponse`,hash:{},fn:e.program(1,i,0),inverse:e.program(3,i,0),data:i,loc:{start:{line:63,column:100},end:{line:63,column:178}}})??``)+`> => {
	return new CancelablePromise(async (resolve, reject, onCancel) => {
		try {
			const url = getUrl(config, options);
			const formData = getFormData(options);
			const body = getRequestBody(options);
			const headers = await getHeaders(config, options);

			if (!onCancel.isCancelled) {
				let response = await sendRequest(config, options, url, body, formData, headers, onCancel);

				for (const fn of config.interceptors.response._fns) {
					response = await fn(response);
				}

				const responseBody = getResponseBody(response);
				const responseHeader = getResponseHeader(response, options.responseHeader);

				let transformedBody = responseBody;
				if (options.responseTransformer && isSuccess(response.status)) {
					transformedBody = await options.responseTransformer(responseBody)
				}

				const result: ApiResult = {
					url,
					ok: isSuccess(response.status),
					status: response.status,
					statusText: response.statusText,
					body: responseHeader ?? transformedBody,
				};

				catchErrorCodes(options, result);

				resolve(`+(o(n,`ifServicesResponse`).call(a,`body`,{name:`ifServicesResponse`,hash:{},fn:e.program(5,i,0),inverse:e.program(7,i,0),data:i,loc:{start:{line:96,column:12},end:{line:96,column:90}}})??``)+`);
			}
		} catch (error) {
			reject(error);
		}
	});
};`},usePartial:!0,useData:!0},ht={compiler:[8,`>= 4.3.0`],main:function(e,t,n,r,i){return`export const sendRequest = async (
	config: OpenAPIConfig,
	options: ApiRequestOptions,
	url: string,
	body: any,
	formData: FormData | undefined,
	headers: Headers,
	onCancel: OnCancel
): Promise<XMLHttpRequest> => {
	let xhr = new XMLHttpRequest();
	xhr.open(options.method, url, true);
	xhr.withCredentials = config.WITH_CREDENTIALS;

	headers.forEach((value, key) => {
		xhr.setRequestHeader(key, value);
	});

	return new Promise<XMLHttpRequest>(async (resolve, reject) => {
		xhr.onload = () => resolve(xhr);
		xhr.onabort = () => reject(new Error('Request aborted'));
		xhr.onerror = () => reject(new Error('Network error'));

		for (const fn of config.interceptors.request._fns) {
			xhr = await fn(xhr);
		}

		xhr.send(body ?? formData);

		onCancel(() => xhr.abort());
	});
};`},useData:!0};const gt=()=>{k.registerHelper(`camelCase`,function(e){return T({case:`camelCase`,value:e})}),k.registerHelper(`equals`,function(e,t,n){return e===t?n.fn(this):n.inverse(this)}),k.registerHelper(`ifServicesResponse`,function(e,t){return i().plugins[`@hey-api/sdk`]?.config.response===e?t.fn(this):t.inverse(this)}),k.registerHelper(`ifdef`,function(...e){let t=e.pop();return e.every(e=>!e)?t.inverse(this):t.fn(this)}),k.registerHelper(`notEquals`,function(e,t,n){return e===t?n.inverse(this):n.fn(this)}),k.registerHelper(`transformServiceName`,function(e){return ne({config:i(),name:e})})},_t=()=>{gt();let e={client:k.template(Ee),core:{apiError:k.template(Ne),apiRequestOptions:k.template(Pe),apiResult:k.template(Fe),baseHttpRequest:k.template(He),cancelablePromise:k.template(Ue),httpRequest:k.template(st),request:k.template(lt),settings:k.template(ct)}};return k.registerPartial(`functions/base64`,k.template(Xe)),k.registerPartial(`functions/catchErrorCodes`,k.template(Ze)),k.registerPartial(`functions/getFormData`,k.template(Qe)),k.registerPartial(`functions/getQueryString`,k.template($e)),k.registerPartial(`functions/getUrl`,k.template(et)),k.registerPartial(`functions/isBlob`,k.template(tt)),k.registerPartial(`functions/isFormData`,k.template(nt)),k.registerPartial(`functions/isString`,k.template(rt)),k.registerPartial(`functions/isStringWithValue`,k.template(it)),k.registerPartial(`functions/isSuccess`,k.template(at)),k.registerPartial(`functions/resolve`,k.template(ot)),k.registerPartial(`fetch/getHeaders`,k.template(We)),k.registerPartial(`fetch/getRequestBody`,k.template(Ge)),k.registerPartial(`fetch/getResponseBody`,k.template(Ke)),k.registerPartial(`fetch/getResponseHeader`,k.template(qe)),k.registerPartial(`fetch/request`,k.template(Je)),k.registerPartial(`fetch/sendRequest`,k.template(Ye)),k.registerPartial(`xhr/getHeaders`,k.template(ut)),k.registerPartial(`xhr/getRequestBody`,k.template(dt)),k.registerPartial(`xhr/getResponseBody`,k.template(ft)),k.registerPartial(`xhr/getResponseHeader`,k.template(pt)),k.registerPartial(`xhr/request`,k.template(mt)),k.registerPartial(`xhr/sendRequest`,k.template(ht)),k.registerPartial(`axios/getHeaders`,k.template(Ie)),k.registerPartial(`axios/getRequestBody`,k.template(Le)),k.registerPartial(`axios/getResponseBody`,k.template(Re)),k.registerPartial(`axios/getResponseHeader`,k.template(ze)),k.registerPartial(`axios/request`,k.template(Be)),k.registerPartial(`axios/sendRequest`,k.template(Ve)),k.registerPartial(`angular/getHeaders`,k.template(De)),k.registerPartial(`angular/getRequestBody`,k.template(Oe)),k.registerPartial(`angular/getResponseBody`,k.template(ke)),k.registerPartial(`angular/getResponseHeader`,k.template(Ae)),k.registerPartial(`angular/request`,k.template(je)),k.registerPartial(`angular/sendRequest`,k.template(Me)),e};let J=0;const Y=e=>`${e}-${J++}`,X=e=>`${e}-end`,Z=e=>`${e}-length`,Q=e=>`${e}-start`,vt=(e,t)=>{if(e>200)return{color:E.red,type:`duration`};if(t>30)return{color:E.red,type:`percentage`};if(e>50)return{color:E.yellow,type:`duration`};if(t>10)return{color:E.yellow,type:`percentage`}};var $=class{events=[];end(e){let t,n=this.events;for(let r of e.position)t=n[r],t?.events&&(n=t.events);t&&!t.end&&(t.end=performance.mark(X(t.id)))}endAllEvents(e){for(let t of e)t.end||=performance.mark(X(t.id)),t.events.length>0&&this.endAllEvents(t.events)}report(e=!0){let t=this.events[0];if(!t)return;this.endAllEvents(this.events);let n=this.events[this.events.length-1],r=`root`,i=Y(r);try{let a=performance.measure(Z(i),Q(t.id),X(n.id));return e&&this.reportEvent({end:n.end,events:this.events,id:i,indent:0,measure:a,name:r,start:t.start}),a}catch{return}}reportEvent({indent:e,...t}){let n=e?E.gray:E.cyan,r=t.events.length-1;t.events.forEach((i,a)=>{try{let o=performance.measure(Z(i.id),Q(i.id),X(i.id)),s=Math.ceil(o.duration*100)/100,c=Math.ceil(o.duration/t.measure.duration*100*100)/100,l=e?vt(s,c):void 0,u=`${s.toFixed(2).padStart(8)}ms`;l?.type===`duration`&&(u=l.color(u));let d=a===r?`└─ `:`├─ `,f=e?`│  `.repeat(e-1)+d:``,p=38-f.length,m=e?`↳ `:``,h=`${e?` `.repeat(e-1)+m:``}${c.toFixed(2)}%`;l?.type===`percentage`&&(h=l.color(h));let g=E.gray(`[root] `);console.log(`${g}${E.gray(f)}${n(`${i.name.padEnd(p)} ${u} (${h})`)}`),this.reportEvent({...i,indent:e+1,measure:o})}catch{}})}start(e){return performance.mark(Q(e))}storeEvent({result:e,...t}){let n=t.events.length-1,r=t.events[n];if(r&&!r.end){e.position=[...e.position,n],this.storeEvent({...t,events:r.events,result:e});return}let i=t.events.push({...t,events:[]});e.position=[...e.position,i-1]}timeEvent(e){let t=Y(e),n=this.start(t),r={events:this.events,id:t,name:e,start:n},i={position:[]};return this.storeEvent({...r,result:i}),{mark:n,timeEnd:()=>this.end(i)}}};const yt=async(e,t=new $)=>{let n=typeof e==`function`?await e():e,i=n?n instanceof Array?n:[n]:[],a=i.find(e=>p(e).level!==`silent`)?.logs;typeof a==`string`&&(a=p({logs:a}));let o;try{ce();let e=t.timeEvent(`createClient`),n=t.timeEvent(`config`);o=await re({logger:t,userConfigs:i}),o.results.some(e=>e.config.logs.level!==`silent`)&&Te(),n.timeEnd();let r=o.results.flatMap(e=>e.errors.map(t=>({error:t,jobIndex:e.jobIndex})));if(r.length)throw new d(r);let a=t.timeEvent(`handlebars`),s=_t();a.timeEnd();let c=(await Promise.all(o.results.map(async e=>{try{return await q({config:e.config,dependencies:o.dependencies,jobIndex:e.jobIndex,logger:t,templates:s})}catch(t){throw new ee(``,{error:t,jobIndex:e.jobIndex})}}))).filter(e=>!!e);e.timeEnd();let l=o.results.some(e=>e.config.logs.level===`debug`);return t.report(l),c}catch(e){let t=o?.results??[],n=t.find(e=>e.config.logs.level!==`silent`)?.config.logs??t[0]?.config.logs??a,s=t.some(e=>e.config.dryRun)??i.some(e=>e.dryRun)??!1,c=n?.file&&!s?r(e,n.path??``):void 0;throw(!n||n.level!==`silent`)&&(l({error:e,logPath:c}),await u({error:e,isInteractive:t.some(e=>e.config.interactive)??i.some(e=>e.interactive)??!1})&&await b(e)),e}},bt={stringCase:T};E.enabled=oe().hasBasic;const xt=async e=>typeof e==`function`?await e():e;export{$ as i,bt as n,yt as r,xt as t};
//# sourceMappingURL=src-C4Q2-7Ic.js.map