"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useMemo } from "react";
import { webLocalStorage } from "../../../../utils/storage/webStorage.js";
import { usePaymentMachine, } from "../../../core/machines/paymentMachine.js";
import { webWindowAdapter } from "../../adapters/WindowAdapter.js";
import en from "../ConnectWallet/locale/en.js";
import { ExecutingTxScreen } from "../TransactionButton/ExecutingScreen.js";
import { Container } from "../components/basic.js";
import { DirectPayment } from "./DirectPayment.js";
import { ErrorBanner } from "./ErrorBanner.js";
import { FundWallet } from "./FundWallet.js";
import { QuoteLoader } from "./QuoteLoader.js";
import { StepRunner } from "./StepRunner.js";
import { TransactionPayment } from "./TransactionPayment.js";
import { PaymentDetails } from "./payment-details/PaymentDetails.js";
import { PaymentSelection } from "./payment-selection/PaymentSelection.js";
import { SuccessScreen } from "./payment-success/SuccessScreen.js";
export function BridgeOrchestrator({ client, uiOptions, receiverAddress, onComplete, onError, onCancel, connectOptions, connectLocale, purchaseData, paymentLinkId, presetOptions, }) {
    // Initialize adapters
    const adapters = useMemo(() => ({
        window: webWindowAdapter,
        storage: webLocalStorage,
    }), []);
    // Use the payment machine hook
    const [state, send] = usePaymentMachine(adapters, uiOptions.mode);
    // Handle buy completion
    const handleBuyComplete = useCallback(() => {
        if (uiOptions.mode === "transaction") {
            send({ type: "CONTINUE_TO_TRANSACTION" });
        }
        else {
            onComplete?.();
            send({ type: "RESET" });
        }
    }, [onComplete, send, uiOptions.mode]);
    // Handle post-buy transaction completion
    const handlePostBuyTransactionComplete = useCallback(() => {
        onComplete?.();
        send({ type: "RESET" });
    }, [onComplete, send]);
    // Handle errors
    const handleError = useCallback((error) => {
        onError?.(error);
        send({ type: "ERROR_OCCURRED", error });
    }, [onError, send]);
    // Handle payment method selection
    const handlePaymentMethodSelected = useCallback((paymentMethod) => {
        send({ type: "PAYMENT_METHOD_SELECTED", paymentMethod });
    }, [send]);
    // Handle quote received
    const handleQuoteReceived = useCallback((quote, request) => {
        send({ type: "QUOTE_RECEIVED", quote, request });
    }, [send]);
    // Handle route confirmation
    const handleRouteConfirmed = useCallback(() => {
        send({ type: "ROUTE_CONFIRMED" });
    }, [send]);
    // Handle execution complete
    const handleExecutionComplete = useCallback((completedStatuses) => {
        send({ type: "EXECUTION_COMPLETE", completedStatuses });
    }, [send]);
    // Handle retry
    const handleRetry = useCallback(() => {
        send({ type: "RETRY" });
    }, [send]);
    // Handle requirements resolved from FundWallet and DirectPayment
    const handleRequirementsResolved = useCallback((amount, token, receiverAddress) => {
        send({
            type: "DESTINATION_CONFIRMED",
            destinationToken: token,
            receiverAddress,
            destinationAmount: amount,
        });
    }, [send]);
    return (_jsxs(Container, { flex: "column", fullHeight: true, children: [state.value === "error" && state.context.currentError && (_jsx(ErrorBanner, { error: state.context.currentError, onRetry: handleRetry, onCancel: onCancel })), state.value === "init" && uiOptions.mode === "fund_wallet" && (_jsx(FundWallet, { uiOptions: uiOptions, receiverAddress: receiverAddress, client: client, onContinue: handleRequirementsResolved, connectOptions: connectOptions, presetOptions: presetOptions })), state.value === "init" && uiOptions.mode === "direct_payment" && (_jsx(DirectPayment, { uiOptions: uiOptions, client: client, onContinue: handleRequirementsResolved, connectOptions: connectOptions })), state.value === "init" && uiOptions.mode === "transaction" && (_jsx(TransactionPayment, { uiOptions: uiOptions, client: client, onContinue: handleRequirementsResolved, connectOptions: connectOptions })), state.value === "methodSelection" &&
                state.context.destinationToken &&
                state.context.destinationAmount &&
                state.context.receiverAddress && (_jsx(PaymentSelection, { destinationToken: state.context.destinationToken, client: client, destinationAmount: state.context.destinationAmount, receiverAddress: state.context.receiverAddress, onPaymentMethodSelected: handlePaymentMethodSelected, onError: handleError, onBack: () => {
                    send({ type: "BACK" });
                }, connectOptions: connectOptions, connectLocale: connectLocale || en, includeDestinationToken: uiOptions.mode !== "fund_wallet" })), state.value === "quote" &&
                state.context.selectedPaymentMethod &&
                state.context.receiverAddress &&
                state.context.destinationToken &&
                state.context.destinationAmount && (_jsx(QuoteLoader, { destinationToken: state.context.destinationToken, purchaseData: purchaseData, paymentLinkId: paymentLinkId, paymentMethod: state.context.selectedPaymentMethod, receiver: state.context.receiverAddress, amount: state.context.destinationAmount, client: client, onQuoteReceived: handleQuoteReceived, onError: handleError, onBack: () => {
                    send({ type: "BACK" });
                } })), state.value === "preview" &&
                state.context.selectedPaymentMethod &&
                state.context.quote && (_jsx(PaymentDetails, { uiOptions: uiOptions, client: client, paymentMethod: state.context.selectedPaymentMethod, preparedQuote: state.context.quote, onConfirm: handleRouteConfirmed, onBack: () => {
                    send({ type: "BACK" });
                }, onError: handleError })), state.value === "execute" &&
                state.context.quote &&
                state.context.request &&
                state.context.selectedPaymentMethod?.payerWallet && (_jsx(StepRunner, { request: state.context.request, wallet: state.context.selectedPaymentMethod?.payerWallet, client: client, autoStart: true, windowAdapter: webWindowAdapter, onComplete: handleExecutionComplete, onCancel: onCancel, onBack: () => {
                    send({ type: "BACK" });
                } })), state.value === "success" &&
                state.context.quote &&
                state.context.completedStatuses && (_jsx(SuccessScreen, { uiOptions: uiOptions, preparedQuote: state.context.quote, completedStatuses: state.context.completedStatuses, onDone: handleBuyComplete, windowAdapter: webWindowAdapter })), state.value === "post-buy-transaction" &&
                uiOptions.mode === "transaction" &&
                uiOptions.transaction && (_jsx(ExecutingTxScreen, { tx: uiOptions.transaction, windowAdapter: webWindowAdapter, closeModal: handlePostBuyTransactionComplete, onTxSent: () => {
                    // Do nothing
                } }))] }));
}
//# sourceMappingURL=BridgeOrchestrator.js.map