import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useMemo } from "react";
import { getCachedChain } from "../../../../../chains/utils.js";
import { NATIVE_TOKEN_ADDRESS } from "../../../../../constants/addresses.js";
import { resolveScheme } from "../../../../../utils/ipfs.js";
import { useCustomTheme } from "../../../../core/design-system/CustomThemeProvider.js";
import { iconSize, spacing } from "../../../../core/design-system/index.js";
import { useChainIconUrl, useChainMetadata, } from "../../../../core/hooks/others/useChainQuery.js";
import { genericTokenIcon } from "../../../../core/utils/walletIcon.js";
import { isNativeToken } from "../../ConnectWallet/screens/nativeToken.js";
import { ChainName } from "../../components/ChainName.js";
import { Img } from "../../components/Img.js";
import { Container } from "../../components/basic.js";
import { fallbackChainIcon } from "../../components/fallbackChainIcon.js";
import { Text } from "../../components/text.js";
export function TokenAndChain({ token, client, size, style, }) {
    const theme = useCustomTheme();
    const chain = getCachedChain(token.chainId);
    return (_jsxs(Container, { flex: "row", center: "y", gap: "sm", style: {
            flexWrap: "nowrap",
            ...style,
        }, children: [_jsxs(Container, { style: {
                    position: "relative",
                    width: iconSize[size],
                    height: iconSize[size],
                }, children: [_jsx(TokenIconWithFallback, { token: token, size: size, client: client }), chain.id !== 1 && (_jsx(Container, { style: {
                            position: "absolute",
                            bottom: "-2px",
                            right: "-6px",
                            width: size === "lg" || size === "xl" ? iconSize.sm : iconSize.xs,
                            height: size === "lg" || size === "xl" ? iconSize.sm : iconSize.xs,
                            borderRadius: "50%",
                            background: theme.colors.borderColor,
                            border: `1.5px solid ${theme.colors.modalBg}`,
                        }, children: _jsx(ChainIcon, { chain: chain, size: size === "xl" || size === "lg" ? "sm" : "xs", client: client }) }))] }), _jsxs(Container, { flex: "column", gap: "3xs", style: { minWidth: 0 }, children: [_jsx(Text, { size: size === "xl" ? "lg" : "sm", color: "primaryText", weight: 600, style: {
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap",
                        }, children: token.name }), _jsx(ChainName, { chain: chain, size: size === "xl" ? "sm" : "xs", client: client, short: true })] })] }));
}
function TokenIconWithFallback(props) {
    const chain = getCachedChain(props.token.chainId);
    const chainMeta = useChainMetadata(chain).data;
    const theme = useCustomTheme();
    const tokenImage = useMemo(() => {
        if (isNativeToken(props.token) ||
            props.token.address === NATIVE_TOKEN_ADDRESS) {
            if (chainMeta?.nativeCurrency.symbol === "ETH") {
                return "ipfs://QmcxZHpyJa8T4i63xqjPYrZ6tKrt55tZJpbXcjSDKuKaf9/ethereum/512.png"; // ETH icon
            }
            return chainMeta?.icon?.url;
        }
        return props.token.iconUri;
    }, [props.token, chainMeta?.icon?.url, chainMeta?.nativeCurrency.symbol]);
    return tokenImage ? (_jsx(Img, { src: tokenImage, style: {
            borderRadius: "50%",
        }, width: iconSize[props.size], height: iconSize[props.size], fallbackImage: genericTokenIcon, client: props.client })) : (_jsx(Container, { style: {
            width: `${iconSize.md}px`,
            height: `${iconSize.md}px`,
            borderRadius: "50%",
            backgroundColor: theme.colors.secondaryButtonBg,
            border: `1px solid ${theme.colors.borderColor}`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            padding: spacing.xs,
        }, children: _jsx(Text, { size: props.size === "xl" ? "sm" : "xs", color: "secondaryText", style: { fontWeight: 600 }, children: props.token.symbol.slice(0, 1) }) }));
}
export const ChainIcon = (props) => {
    const { url } = useChainIconUrl(props.chain);
    return (_jsx(Container, { style: {
            position: "relative",
            display: "flex",
            flexShrink: 0,
            alignItems: "center",
        }, children: _jsx(Img, { src: getSrcChainIcon({
                client: props.client,
                chainIconUrl: url,
            }), width: iconSize[props.size], height: iconSize[props.size], fallbackImage: fallbackChainIcon, client: props.client }) }));
};
const getSrcChainIcon = (props) => {
    const url = props.chainIconUrl;
    if (!url) {
        return fallbackChainIcon;
    }
    try {
        return resolveScheme({
            uri: url,
            client: props.client,
        });
    }
    catch {
        return fallbackChainIcon;
    }
};
//# sourceMappingURL=TokenAndChain.js.map