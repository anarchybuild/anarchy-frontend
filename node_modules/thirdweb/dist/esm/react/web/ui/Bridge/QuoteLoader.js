"use client";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect } from "react";
import { NATIVE_TOKEN_ADDRESS } from "../../../../constants/addresses.js";
import { toUnits } from "../../../../utils/units.js";
import { useBridgePrepare, } from "../../../core/hooks/useBridgePrepare.js";
import { Spacer } from "../components/Spacer.js";
import { Spinner } from "../components/Spinner.js";
import { Container } from "../components/basic.js";
import { Text } from "../components/text.js";
export function QuoteLoader({ destinationToken, paymentMethod, amount, sender, receiver, client, onQuoteReceived, onError, purchaseData, paymentLinkId, feePayer, }) {
    // For now, we'll use a simple buy operation
    // This will be expanded to handle different bridge types based on the payment method
    const request = getBridgeParams({
        paymentMethod,
        amount,
        destinationToken,
        receiver,
        sender,
        client,
        purchaseData,
        paymentLinkId,
        feePayer,
    });
    const prepareQuery = useBridgePrepare(request);
    // Handle successful quote
    useEffect(() => {
        if (prepareQuery.data) {
            onQuoteReceived(prepareQuery.data, request);
        }
    }, [prepareQuery.data, onQuoteReceived, request]);
    // Handle errors
    useEffect(() => {
        if (prepareQuery.error) {
            onError(prepareQuery.error);
        }
    }, [prepareQuery.error, onError]);
    return (_jsxs(Container, { flex: "column", center: "both", p: "lg", fullHeight: true, style: { minHeight: "350px" }, children: [_jsx(Spinner, { size: "xl", color: "secondaryText" }), _jsx(Spacer, { y: "md" }), _jsx(Text, { size: "lg", color: "primaryText", center: true, style: { fontWeight: 600 }, children: "Finding the best route..." }), _jsx(Spacer, { y: "sm" }), _jsx(Text, { size: "sm", color: "secondaryText", center: true, children: "We're searching for the most efficient path for this payment." })] }));
}
function getBridgeParams(args) {
    const { paymentMethod, amount, destinationToken, receiver, client, sender } = args;
    switch (paymentMethod.type) {
        case "fiat":
            return {
                type: "onramp",
                client,
                amount: toUnits(amount, destinationToken.decimals),
                receiver,
                sender,
                chainId: destinationToken.chainId,
                tokenAddress: destinationToken.address,
                onramp: paymentMethod.onramp || "coinbase",
                purchaseData: args.purchaseData,
                currency: paymentMethod.currency,
                onrampTokenAddress: NATIVE_TOKEN_ADDRESS, // always onramp to native token
                paymentLinkId: args.paymentLinkId,
                enabled: !!(destinationToken && amount && client),
            };
        case "wallet":
            // if the origin token is the same as the destination token, use transfer type
            if (paymentMethod.originToken.chainId === destinationToken.chainId &&
                paymentMethod.originToken.address.toLowerCase() ===
                    destinationToken.address.toLowerCase()) {
                return {
                    type: "transfer",
                    client,
                    chainId: destinationToken.chainId,
                    tokenAddress: destinationToken.address,
                    feePayer: args.feePayer || "sender",
                    amount: toUnits(amount, destinationToken.decimals),
                    sender: sender ||
                        paymentMethod.payerWallet.getAccount()?.address ||
                        receiver,
                    receiver,
                    purchaseData: args.purchaseData,
                    paymentLinkId: args.paymentLinkId,
                    enabled: !!(destinationToken && amount && client),
                };
            }
            return {
                type: "buy",
                client,
                originChainId: paymentMethod.originToken.chainId,
                originTokenAddress: paymentMethod.originToken.address,
                destinationChainId: destinationToken.chainId,
                destinationTokenAddress: destinationToken.address,
                amount: toUnits(amount, destinationToken.decimals),
                sender: sender || paymentMethod.payerWallet.getAccount()?.address || receiver,
                receiver,
                purchaseData: args.purchaseData,
                paymentLinkId: args.paymentLinkId,
                enabled: !!(destinationToken && amount && client),
            };
    }
}
//# sourceMappingURL=QuoteLoader.js.map