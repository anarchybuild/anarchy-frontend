"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BridgeOrchestrator = BridgeOrchestrator;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const webStorage_js_1 = require("../../../../utils/storage/webStorage.js");
const paymentMachine_js_1 = require("../../../core/machines/paymentMachine.js");
const WindowAdapter_js_1 = require("../../adapters/WindowAdapter.js");
const en_js_1 = require("../ConnectWallet/locale/en.js");
const ExecutingScreen_js_1 = require("../TransactionButton/ExecutingScreen.js");
const basic_js_1 = require("../components/basic.js");
const DirectPayment_js_1 = require("./DirectPayment.js");
const ErrorBanner_js_1 = require("./ErrorBanner.js");
const FundWallet_js_1 = require("./FundWallet.js");
const QuoteLoader_js_1 = require("./QuoteLoader.js");
const StepRunner_js_1 = require("./StepRunner.js");
const TransactionPayment_js_1 = require("./TransactionPayment.js");
const PaymentDetails_js_1 = require("./payment-details/PaymentDetails.js");
const PaymentSelection_js_1 = require("./payment-selection/PaymentSelection.js");
const SuccessScreen_js_1 = require("./payment-success/SuccessScreen.js");
function BridgeOrchestrator({ client, uiOptions, receiverAddress, onComplete, onError, onCancel, connectOptions, connectLocale, purchaseData, paymentLinkId, presetOptions, }) {
    // Initialize adapters
    const adapters = (0, react_1.useMemo)(() => ({
        window: WindowAdapter_js_1.webWindowAdapter,
        storage: webStorage_js_1.webLocalStorage,
    }), []);
    // Use the payment machine hook
    const [state, send] = (0, paymentMachine_js_1.usePaymentMachine)(adapters, uiOptions.mode);
    // Handle buy completion
    const handleBuyComplete = (0, react_1.useCallback)(() => {
        if (uiOptions.mode === "transaction") {
            send({ type: "CONTINUE_TO_TRANSACTION" });
        }
        else {
            onComplete?.();
            send({ type: "RESET" });
        }
    }, [onComplete, send, uiOptions.mode]);
    // Handle post-buy transaction completion
    const handlePostBuyTransactionComplete = (0, react_1.useCallback)(() => {
        onComplete?.();
        send({ type: "RESET" });
    }, [onComplete, send]);
    // Handle errors
    const handleError = (0, react_1.useCallback)((error) => {
        onError?.(error);
        send({ type: "ERROR_OCCURRED", error });
    }, [onError, send]);
    // Handle payment method selection
    const handlePaymentMethodSelected = (0, react_1.useCallback)((paymentMethod) => {
        send({ type: "PAYMENT_METHOD_SELECTED", paymentMethod });
    }, [send]);
    // Handle quote received
    const handleQuoteReceived = (0, react_1.useCallback)((quote, request) => {
        send({ type: "QUOTE_RECEIVED", quote, request });
    }, [send]);
    // Handle route confirmation
    const handleRouteConfirmed = (0, react_1.useCallback)(() => {
        send({ type: "ROUTE_CONFIRMED" });
    }, [send]);
    // Handle execution complete
    const handleExecutionComplete = (0, react_1.useCallback)((completedStatuses) => {
        send({ type: "EXECUTION_COMPLETE", completedStatuses });
    }, [send]);
    // Handle retry
    const handleRetry = (0, react_1.useCallback)(() => {
        send({ type: "RETRY" });
    }, [send]);
    // Handle requirements resolved from FundWallet and DirectPayment
    const handleRequirementsResolved = (0, react_1.useCallback)((amount, token, receiverAddress) => {
        send({
            type: "DESTINATION_CONFIRMED",
            destinationToken: token,
            receiverAddress,
            destinationAmount: amount,
        });
    }, [send]);
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", fullHeight: true, children: [state.value === "error" && state.context.currentError && ((0, jsx_runtime_1.jsx)(ErrorBanner_js_1.ErrorBanner, { error: state.context.currentError, onRetry: handleRetry, onCancel: onCancel })), state.value === "init" && uiOptions.mode === "fund_wallet" && ((0, jsx_runtime_1.jsx)(FundWallet_js_1.FundWallet, { uiOptions: uiOptions, receiverAddress: receiverAddress, client: client, onContinue: handleRequirementsResolved, connectOptions: connectOptions, presetOptions: presetOptions })), state.value === "init" && uiOptions.mode === "direct_payment" && ((0, jsx_runtime_1.jsx)(DirectPayment_js_1.DirectPayment, { uiOptions: uiOptions, client: client, onContinue: handleRequirementsResolved, connectOptions: connectOptions })), state.value === "init" && uiOptions.mode === "transaction" && ((0, jsx_runtime_1.jsx)(TransactionPayment_js_1.TransactionPayment, { uiOptions: uiOptions, client: client, onContinue: handleRequirementsResolved, connectOptions: connectOptions })), state.value === "methodSelection" &&
                state.context.destinationToken &&
                state.context.destinationAmount &&
                state.context.receiverAddress && ((0, jsx_runtime_1.jsx)(PaymentSelection_js_1.PaymentSelection, { destinationToken: state.context.destinationToken, client: client, destinationAmount: state.context.destinationAmount, receiverAddress: state.context.receiverAddress, onPaymentMethodSelected: handlePaymentMethodSelected, onError: handleError, onBack: () => {
                    send({ type: "BACK" });
                }, connectOptions: connectOptions, connectLocale: connectLocale || en_js_1.default, includeDestinationToken: uiOptions.mode !== "fund_wallet" })), state.value === "quote" &&
                state.context.selectedPaymentMethod &&
                state.context.receiverAddress &&
                state.context.destinationToken &&
                state.context.destinationAmount && ((0, jsx_runtime_1.jsx)(QuoteLoader_js_1.QuoteLoader, { destinationToken: state.context.destinationToken, purchaseData: purchaseData, paymentLinkId: paymentLinkId, paymentMethod: state.context.selectedPaymentMethod, receiver: state.context.receiverAddress, amount: state.context.destinationAmount, client: client, onQuoteReceived: handleQuoteReceived, onError: handleError, onBack: () => {
                    send({ type: "BACK" });
                } })), state.value === "preview" &&
                state.context.selectedPaymentMethod &&
                state.context.quote && ((0, jsx_runtime_1.jsx)(PaymentDetails_js_1.PaymentDetails, { uiOptions: uiOptions, client: client, paymentMethod: state.context.selectedPaymentMethod, preparedQuote: state.context.quote, onConfirm: handleRouteConfirmed, onBack: () => {
                    send({ type: "BACK" });
                }, onError: handleError })), state.value === "execute" &&
                state.context.quote &&
                state.context.request &&
                state.context.selectedPaymentMethod?.payerWallet && ((0, jsx_runtime_1.jsx)(StepRunner_js_1.StepRunner, { request: state.context.request, wallet: state.context.selectedPaymentMethod?.payerWallet, client: client, autoStart: true, windowAdapter: WindowAdapter_js_1.webWindowAdapter, onComplete: handleExecutionComplete, onCancel: onCancel, onBack: () => {
                    send({ type: "BACK" });
                } })), state.value === "success" &&
                state.context.quote &&
                state.context.completedStatuses && ((0, jsx_runtime_1.jsx)(SuccessScreen_js_1.SuccessScreen, { uiOptions: uiOptions, preparedQuote: state.context.quote, completedStatuses: state.context.completedStatuses, onDone: handleBuyComplete, windowAdapter: WindowAdapter_js_1.webWindowAdapter })), state.value === "post-buy-transaction" &&
                uiOptions.mode === "transaction" &&
                uiOptions.transaction && ((0, jsx_runtime_1.jsx)(ExecutingScreen_js_1.ExecutingTxScreen, { tx: uiOptions.transaction, windowAdapter: WindowAdapter_js_1.webWindowAdapter, closeModal: handlePostBuyTransactionComplete, onTxSent: () => {
                    // Do nothing
                } }))] }));
}
//# sourceMappingURL=BridgeOrchestrator.js.map