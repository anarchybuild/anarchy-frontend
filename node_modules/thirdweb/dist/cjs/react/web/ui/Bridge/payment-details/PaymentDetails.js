"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaymentDetails = PaymentDetails;
const jsx_runtime_1 = require("react/jsx-runtime");
const CustomThemeProvider_js_1 = require("../../../../core/design-system/CustomThemeProvider.js");
const index_js_1 = require("../../../../core/design-system/index.js");
const formatTokenBalance_js_1 = require("../../ConnectWallet/screens/formatTokenBalance.js");
const Spacer_js_1 = require("../../components/Spacer.js");
const basic_js_1 = require("../../components/basic.js");
const buttons_js_1 = require("../../components/buttons.js");
const text_js_1 = require("../../components/text.js");
const PaymentOverview_js_1 = require("./PaymentOverview.js");
function PaymentDetails({ uiOptions, client, paymentMethod, preparedQuote, onConfirm, onBack, onError, }) {
    const theme = (0, CustomThemeProvider_js_1.useCustomTheme)();
    const handleConfirm = () => {
        try {
            onConfirm();
        }
        catch (error) {
            onError(error);
        }
    };
    // Extract common data based on quote type
    const getDisplayData = () => {
        switch (preparedQuote.type) {
            case "transfer": {
                const token = paymentMethod.type === "wallet"
                    ? paymentMethod.originToken
                    : undefined;
                if (!token) {
                    // can never happen
                    onError(new Error("Invalid payment method"));
                    return {
                        originToken: undefined,
                        destinationToken: undefined,
                        originAmount: "0",
                        destinationAmount: "0",
                        estimatedTime: 0,
                    };
                }
                return {
                    originToken: token,
                    destinationToken: token,
                    originAmount: (0, formatTokenBalance_js_1.formatTokenAmount)(preparedQuote.originAmount, token.decimals),
                    destinationAmount: (0, formatTokenBalance_js_1.formatTokenAmount)(preparedQuote.destinationAmount, token.decimals),
                    estimatedTime: preparedQuote.estimatedExecutionTimeMs,
                };
            }
            case "buy": {
                const method = paymentMethod.type === "wallet" ? paymentMethod : undefined;
                if (!method) {
                    // can never happen
                    onError(new Error("Invalid payment method"));
                    return {
                        originToken: undefined,
                        destinationToken: undefined,
                        originAmount: "0",
                        destinationAmount: "0",
                        estimatedTime: 0,
                    };
                }
                return {
                    originToken: paymentMethod.type === "wallet"
                        ? paymentMethod.originToken
                        : undefined,
                    destinationToken: preparedQuote.steps[preparedQuote.steps.length - 1]
                        ?.destinationToken,
                    originAmount: (0, formatTokenBalance_js_1.formatTokenAmount)(preparedQuote.originAmount, method.originToken.decimals),
                    destinationAmount: (0, formatTokenBalance_js_1.formatTokenAmount)(preparedQuote.destinationAmount, preparedQuote.steps[preparedQuote.steps.length - 1]
                        ?.destinationToken?.decimals ?? 18),
                    estimatedTime: preparedQuote.estimatedExecutionTimeMs,
                };
            }
            case "onramp": {
                const method = paymentMethod.type === "fiat" ? paymentMethod : undefined;
                if (!method) {
                    // can never happen
                    onError(new Error("Invalid payment method"));
                    return {
                        originToken: undefined,
                        destinationToken: undefined,
                        originAmount: "0",
                        destinationAmount: "0",
                        estimatedTime: 0,
                    };
                }
                return {
                    originToken: undefined, // Onramp starts with fiat
                    destinationToken: preparedQuote.destinationToken,
                    originAmount: (0, formatTokenBalance_js_1.formatCurrencyAmount)(method.currency, Number(preparedQuote.currencyAmount)),
                    destinationAmount: (0, formatTokenBalance_js_1.formatTokenAmount)(preparedQuote.destinationAmount, preparedQuote.destinationToken.decimals),
                    estimatedTime: undefined,
                };
            }
            default: {
                throw new Error(`Unsupported bridge prepare type: ${preparedQuote.type}`);
            }
        }
    };
    const displayData = getDisplayData();
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", fullHeight: true, p: "lg", children: [(0, jsx_runtime_1.jsx)(basic_js_1.ModalHeader, { title: "Payment Details", onBack: onBack }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "xl" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", children: [displayData.destinationToken && ((0, jsx_runtime_1.jsx)(PaymentOverview_js_1.PaymentOverview, { uiOptions: uiOptions, sender: preparedQuote.intent.sender ||
                                    paymentMethod.payerWallet.getAccount()?.address, client: client, paymentMethod: paymentMethod, toToken: displayData.destinationToken, receiver: preparedQuote.intent.receiver, fromAmount: displayData.originAmount, toAmount: displayData.destinationAmount })), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "sm", children: [(0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xs", style: { justifyContent: "center", flex: 1 }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "secondaryText", children: "Estimated Time" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "primaryText", children: displayData.estimatedTime
                                                    ? `~${Math.ceil(displayData.estimatedTime / 60000)} min`
                                                    : "~2 min" })] }), preparedQuote.steps.length > 1 ? ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "xs", style: { justifyContent: "center", flex: 1 }, children: [(0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "secondaryText", children: "Route Length" }), (0, jsx_runtime_1.jsxs)(text_js_1.Text, { size: "sm", color: "primaryText", children: [preparedQuote.steps.length, " step", preparedQuote.steps.length !== 1 ? "s" : ""] })] })) : null] })] }), preparedQuote.steps.length > 1 && ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", children: [(0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "sm", style: {
                                    border: `1px solid ${theme.colors.borderColor}`,
                                    borderRadius: index_js_1.radius.md,
                                    backgroundColor: theme.colors.tertiaryBg,
                                    padding: `${index_js_1.spacing.sm} ${index_js_1.spacing.md}`,
                                }, children: preparedQuote.steps.map((step, stepIndex) => ((0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "sm", children: (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "row", gap: "md", style: { alignItems: "center" }, children: [(0, jsx_runtime_1.jsx)(basic_js_1.Container, { center: "both", flex: "row", style: {
                                                    width: "24px",
                                                    height: "24px",
                                                    borderRadius: "50%",
                                                    backgroundColor: theme.colors.accentButtonBg,
                                                    color: theme.colors.accentButtonText,
                                                    fontSize: "12px",
                                                    fontWeight: "bold",
                                                    flexShrink: 0,
                                                }, children: (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "xs", color: "accentButtonText", children: stepIndex + 1 }) }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "row", center: "y", gap: "sm", style: { flex: 1 }, children: (0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", gap: "3xs", style: { flex: 1 }, children: [(0, jsx_runtime_1.jsxs)(text_js_1.Text, { size: "sm", color: "primaryText", children: [step.originToken.symbol, " \u2192", " ", step.destinationToken.symbol] }), (0, jsx_runtime_1.jsxs)(text_js_1.Text, { size: "xs", color: "secondaryText", children: [step.originToken.name, " to", " ", step.destinationToken.name] })] }) })] }) }, `step-${stepIndex}-${step.originToken.address}-${step.destinationToken.address}`))) })] })), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "lg" }), (0, jsx_runtime_1.jsx)(basic_js_1.Container, { flex: "column", gap: "sm", children: (0, jsx_runtime_1.jsx)(buttons_js_1.Button, { variant: "accent", fullWidth: true, onClick: handleConfirm, children: "Confirm Payment" }) })] })] }));
}
//# sourceMappingURL=PaymentDetails.js.map