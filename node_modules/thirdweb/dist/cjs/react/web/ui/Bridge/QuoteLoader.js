"use strict";
"use client";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuoteLoader = QuoteLoader;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = require("react");
const addresses_js_1 = require("../../../../constants/addresses.js");
const units_js_1 = require("../../../../utils/units.js");
const useBridgePrepare_js_1 = require("../../../core/hooks/useBridgePrepare.js");
const Spacer_js_1 = require("../components/Spacer.js");
const Spinner_js_1 = require("../components/Spinner.js");
const basic_js_1 = require("../components/basic.js");
const text_js_1 = require("../components/text.js");
function QuoteLoader({ destinationToken, paymentMethod, amount, sender, receiver, client, onQuoteReceived, onError, purchaseData, paymentLinkId, feePayer, }) {
    // For now, we'll use a simple buy operation
    // This will be expanded to handle different bridge types based on the payment method
    const request = getBridgeParams({
        paymentMethod,
        amount,
        destinationToken,
        receiver,
        sender,
        client,
        purchaseData,
        paymentLinkId,
        feePayer,
    });
    const prepareQuery = (0, useBridgePrepare_js_1.useBridgePrepare)(request);
    // Handle successful quote
    (0, react_1.useEffect)(() => {
        if (prepareQuery.data) {
            onQuoteReceived(prepareQuery.data, request);
        }
    }, [prepareQuery.data, onQuoteReceived, request]);
    // Handle errors
    (0, react_1.useEffect)(() => {
        if (prepareQuery.error) {
            onError(prepareQuery.error);
        }
    }, [prepareQuery.error, onError]);
    return ((0, jsx_runtime_1.jsxs)(basic_js_1.Container, { flex: "column", center: "both", p: "lg", fullHeight: true, style: { minHeight: "350px" }, children: [(0, jsx_runtime_1.jsx)(Spinner_js_1.Spinner, { size: "xl", color: "secondaryText" }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "md" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "lg", color: "primaryText", center: true, style: { fontWeight: 600 }, children: "Finding the best route..." }), (0, jsx_runtime_1.jsx)(Spacer_js_1.Spacer, { y: "sm" }), (0, jsx_runtime_1.jsx)(text_js_1.Text, { size: "sm", color: "secondaryText", center: true, children: "We're searching for the most efficient path for this payment." })] }));
}
function getBridgeParams(args) {
    const { paymentMethod, amount, destinationToken, receiver, client, sender } = args;
    switch (paymentMethod.type) {
        case "fiat":
            return {
                type: "onramp",
                client,
                amount: (0, units_js_1.toUnits)(amount, destinationToken.decimals),
                receiver,
                sender,
                chainId: destinationToken.chainId,
                tokenAddress: destinationToken.address,
                onramp: paymentMethod.onramp || "coinbase",
                purchaseData: args.purchaseData,
                currency: paymentMethod.currency,
                onrampTokenAddress: addresses_js_1.NATIVE_TOKEN_ADDRESS, // always onramp to native token
                paymentLinkId: args.paymentLinkId,
                enabled: !!(destinationToken && amount && client),
            };
        case "wallet":
            // if the origin token is the same as the destination token, use transfer type
            if (paymentMethod.originToken.chainId === destinationToken.chainId &&
                paymentMethod.originToken.address.toLowerCase() ===
                    destinationToken.address.toLowerCase()) {
                return {
                    type: "transfer",
                    client,
                    chainId: destinationToken.chainId,
                    tokenAddress: destinationToken.address,
                    feePayer: args.feePayer || "sender",
                    amount: (0, units_js_1.toUnits)(amount, destinationToken.decimals),
                    sender: sender ||
                        paymentMethod.payerWallet.getAccount()?.address ||
                        receiver,
                    receiver,
                    purchaseData: args.purchaseData,
                    paymentLinkId: args.paymentLinkId,
                    enabled: !!(destinationToken && amount && client),
                };
            }
            return {
                type: "buy",
                client,
                originChainId: paymentMethod.originToken.chainId,
                originTokenAddress: paymentMethod.originToken.address,
                destinationChainId: destinationToken.chainId,
                destinationTokenAddress: destinationToken.address,
                amount: (0, units_js_1.toUnits)(amount, destinationToken.decimals),
                sender: sender || paymentMethod.payerWallet.getAccount()?.address || receiver,
                receiver,
                purchaseData: args.purchaseData,
                paymentLinkId: args.paymentLinkId,
                enabled: !!(destinationToken && amount && client),
            };
    }
}
//# sourceMappingURL=QuoteLoader.js.map