"use strict";
var sG = Object.create;
var Xc = Object.defineProperty;
var nG = Object.getOwnPropertyDescriptor;
var aG = Object.getOwnPropertyNames;
var oG = Object.getPrototypeOf, uG = Object.prototype.hasOwnProperty;
var n = (e, t) => Xc(e, "name", { value: t, configurable: !0 });
var ph = (e, t) => () => (e && (t = e(e = 0)), t);
var E = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), hh = (e, t) => {
  for (var r in t)
    Xc(e, r, { get: t[r], enumerable: !0 });
}, t4 = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of aG(t))
      !uG.call(e, s) && s !== r && Xc(e, s, { get: () => t[s], enumerable: !(i = nG(t, s)) || i.enumerable });
  return e;
};
var We = (e, t, r) => (r = e != null ? sG(oG(e)) : {}, t4(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? Xc(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), mh = (e) => t4(Xc({}, "__esModule", { value: !0 }), e);

// ../node_modules/kleur/index.js
var $t = E((pet, f4) => {
  "use strict";
  var { FORCE_COLOR: pG, NODE_DISABLE_COLORS: hG, TERM: mG } = process.env, yt = {
    enabled: !hG && mG !== "dumb" && pG !== "0",
    // modifiers
    reset: Et(0, 0),
    bold: Et(1, 22),
    dim: Et(2, 22),
    italic: Et(3, 23),
    underline: Et(4, 24),
    inverse: Et(7, 27),
    hidden: Et(8, 28),
    strikethrough: Et(9, 29),
    // colors
    black: Et(30, 39),
    red: Et(31, 39),
    green: Et(32, 39),
    yellow: Et(33, 39),
    blue: Et(34, 39),
    magenta: Et(35, 39),
    cyan: Et(36, 39),
    white: Et(37, 39),
    gray: Et(90, 39),
    grey: Et(90, 39),
    // background colors
    bgBlack: Et(40, 49),
    bgRed: Et(41, 49),
    bgGreen: Et(42, 49),
    bgYellow: Et(43, 49),
    bgBlue: Et(44, 49),
    bgMagenta: Et(45, 49),
    bgCyan: Et(46, 49),
    bgWhite: Et(47, 49)
  };
  function c4(e, t) {
    let r = 0, i, s = "", a = "";
    for (; r < e.length; r++)
      i = e[r], s += i.open, a += i.close, t.includes(i.close) && (t = t.replace(i.rgx, i.close + i.open));
    return s + t + a;
  }
  n(c4, "run");
  function yG(e, t) {
    let r = { has: e, keys: t };
    return r.reset = yt.reset.bind(r), r.bold = yt.bold.bind(r), r.dim = yt.dim.bind(r), r.italic = yt.italic.bind(r), r.underline = yt.underline.
    bind(r), r.inverse = yt.inverse.bind(r), r.hidden = yt.hidden.bind(r), r.strikethrough = yt.strikethrough.bind(r), r.black = yt.black.bind(
    r), r.red = yt.red.bind(r), r.green = yt.green.bind(r), r.yellow = yt.yellow.bind(r), r.blue = yt.blue.bind(r), r.magenta = yt.magenta.bind(
    r), r.cyan = yt.cyan.bind(r), r.white = yt.white.bind(r), r.gray = yt.gray.bind(r), r.grey = yt.grey.bind(r), r.bgBlack = yt.bgBlack.bind(
    r), r.bgRed = yt.bgRed.bind(r), r.bgGreen = yt.bgGreen.bind(r), r.bgYellow = yt.bgYellow.bind(r), r.bgBlue = yt.bgBlue.bind(r), r.bgMagenta =
    yt.bgMagenta.bind(r), r.bgCyan = yt.bgCyan.bind(r), r.bgWhite = yt.bgWhite.bind(r), r;
  }
  n(yG, "chain");
  function Et(e, t) {
    let r = {
      open: `\x1B[${e}m`,
      close: `\x1B[${t}m`,
      rgx: new RegExp(`\\x1b\\[${t}m`, "g")
    };
    return function(i) {
      return this !== void 0 && this.has !== void 0 ? (this.has.includes(e) || (this.has.push(e), this.keys.push(r)), i === void 0 ? this : yt.
      enabled ? c4(this.keys, i + "") : i + "") : i === void 0 ? yG([e], [r]) : yt.enabled ? c4([r], i + "") : i + "";
    };
  }
  n(Et, "init");
  f4.exports = yt;
});

// ../node_modules/prompts/dist/util/action.js
var p4 = E((met, d4) => {
  "use strict";
  d4.exports = (e, t) => {
    if (!(e.meta && e.name !== "escape")) {
      if (e.ctrl) {
        if (e.name === "a") return "first";
        if (e.name === "c" || e.name === "d") return "abort";
        if (e.name === "e") return "last";
        if (e.name === "g") return "reset";
      }
      if (t) {
        if (e.name === "j") return "down";
        if (e.name === "k") return "up";
      }
      return e.name === "return" || e.name === "enter" ? "submit" : e.name === "backspace" ? "delete" : e.name === "delete" ? "deleteForward" :
      e.name === "abort" ? "abort" : e.name === "escape" ? "exit" : e.name === "tab" ? "next" : e.name === "pagedown" ? "nextPage" : e.name ===
      "pageup" ? "prevPage" : e.name === "home" ? "home" : e.name === "end" ? "end" : e.name === "up" ? "up" : e.name === "down" ? "down" : e.
      name === "right" ? "right" : e.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/dist/util/strip.js
var bh = E((yet, h4) => {
  "use strict";
  h4.exports = (e) => {
    let t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|"), r = new RegExp(t, "g");
    return typeof e == "string" ? e.replace(r, "") : e;
  };
});

// ../node_modules/sisteransi/src/index.js
var Wt = E((get, m4) => {
  "use strict";
  var _b = "\x1B", Vt = `${_b}[`, gG = "\x07", Pb = {
    to(e, t) {
      return t ? `${Vt}${t + 1};${e + 1}H` : `${Vt}${e + 1}G`;
    },
    move(e, t) {
      let r = "";
      return e < 0 ? r += `${Vt}${-e}D` : e > 0 && (r += `${Vt}${e}C`), t < 0 ? r += `${Vt}${-t}A` : t > 0 && (r += `${Vt}${t}B`), r;
    },
    up: /* @__PURE__ */ n((e = 1) => `${Vt}${e}A`, "up"),
    down: /* @__PURE__ */ n((e = 1) => `${Vt}${e}B`, "down"),
    forward: /* @__PURE__ */ n((e = 1) => `${Vt}${e}C`, "forward"),
    backward: /* @__PURE__ */ n((e = 1) => `${Vt}${e}D`, "backward"),
    nextLine: /* @__PURE__ */ n((e = 1) => `${Vt}E`.repeat(e), "nextLine"),
    prevLine: /* @__PURE__ */ n((e = 1) => `${Vt}F`.repeat(e), "prevLine"),
    left: `${Vt}G`,
    hide: `${Vt}?25l`,
    show: `${Vt}?25h`,
    save: `${_b}7`,
    restore: `${_b}8`
  }, bG = {
    up: /* @__PURE__ */ n((e = 1) => `${Vt}S`.repeat(e), "up"),
    down: /* @__PURE__ */ n((e = 1) => `${Vt}T`.repeat(e), "down")
  }, DG = {
    screen: `${Vt}2J`,
    up: /* @__PURE__ */ n((e = 1) => `${Vt}1J`.repeat(e), "up"),
    down: /* @__PURE__ */ n((e = 1) => `${Vt}J`.repeat(e), "down"),
    line: `${Vt}2K`,
    lineEnd: `${Vt}K`,
    lineStart: `${Vt}1K`,
    lines(e) {
      let t = "";
      for (let r = 0; r < e; r++)
        t += this.line + (r < e - 1 ? Pb.up() : "");
      return e && (t += Pb.left), t;
    }
  };
  m4.exports = { cursor: Pb, scroll: bG, erase: DG, beep: gG };
});

// ../node_modules/prompts/dist/util/clear.js
var v4 = E((Det, D4) => {
  "use strict";
  function vG(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = xG(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var i = 0, s = /* @__PURE__ */ n(function() {
        }, "F");
        return { s, n: /* @__PURE__ */ n(function() {
          return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] };
        }, "n"), e: /* @__PURE__ */ n(function(c) {
          throw c;
        }, "e"), f: s };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var a = !0, o = !1, u;
    return { s: /* @__PURE__ */ n(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ n(function() {
      var c = r.next();
      return a = c.done, c;
    }, "n"), e: /* @__PURE__ */ n(function(c) {
      o = !0, u = c;
    }, "e"), f: /* @__PURE__ */ n(function() {
      try {
        !a && r.return != null && r.return();
      } finally {
        if (o) throw u;
      }
    }, "f") };
  }
  n(vG, "_createForOfIteratorHelper");
  function xG(e, t) {
    if (e) {
      if (typeof e == "string") return y4(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return y4(e, t);
    }
  }
  n(xG, "_unsupportedIterableToArray");
  function y4(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
    return i;
  }
  n(y4, "_arrayLikeToArray");
  var EG = bh(), b4 = Wt(), g4 = b4.erase, SG = b4.cursor, TG = /* @__PURE__ */ n((e) => [...EG(e)].length, "width");
  D4.exports = function(e, t) {
    if (!t) return g4.line + SG.to(0);
    let r = 0, i = e.split(/\r?\n/);
    var s = vG(i), a;
    try {
      for (s.s(); !(a = s.n()).done; ) {
        let o = a.value;
        r += 1 + Math.floor(Math.max(TG(o) - 1, 0) / t);
      }
    } catch (o) {
      s.e(o);
    } finally {
      s.f();
    }
    return g4.lines(r);
  };
});

// ../node_modules/prompts/dist/util/figures.js
var Fb = E((xet, x4) => {
  "use strict";
  var Zc = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, CG = {
    arrowUp: Zc.arrowUp,
    arrowDown: Zc.arrowDown,
    arrowLeft: Zc.arrowLeft,
    arrowRight: Zc.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, wG = process.platform === "win32" ? CG : Zc;
  x4.exports = wG;
});

// ../node_modules/prompts/dist/util/style.js
var S4 = E((Eet, E4) => {
  "use strict";
  var Ku = $t(), po = Fb(), Ib = Object.freeze({
    password: {
      scale: 1,
      render: /* @__PURE__ */ n((e) => "*".repeat(e.length), "render")
    },
    emoji: {
      scale: 2,
      render: /* @__PURE__ */ n((e) => "\u{1F603}".repeat(e.length), "render")
    },
    invisible: {
      scale: 0,
      render: /* @__PURE__ */ n((e) => "", "render")
    },
    default: {
      scale: 1,
      render: /* @__PURE__ */ n((e) => `${e}`, "render")
    }
  }), AG = /* @__PURE__ */ n((e) => Ib[e] || Ib.default, "render"), Qc = Object.freeze({
    aborted: Ku.red(po.cross),
    done: Ku.green(po.tick),
    exited: Ku.yellow(po.cross),
    default: Ku.cyan("?")
  }), _G = /* @__PURE__ */ n((e, t, r) => t ? Qc.aborted : r ? Qc.exited : e ? Qc.done : Qc.default, "symbol"), PG = /* @__PURE__ */ n((e) => Ku.
  gray(e ? po.ellipsis : po.pointerSmall), "delimiter"), FG = /* @__PURE__ */ n((e, t) => Ku.gray(e ? t ? po.pointerSmall : "+" : po.line), "\
item");
  E4.exports = {
    styles: Ib,
    render: AG,
    symbols: Qc,
    symbol: _G,
    delimiter: PG,
    item: FG
  };
});

// ../node_modules/prompts/dist/util/lines.js
var C4 = E((Cet, T4) => {
  "use strict";
  var IG = bh();
  T4.exports = function(e, t) {
    let r = String(IG(e) || "").split(/\r?\n/);
    return t ? r.map((i) => Math.ceil(i.length / t)).reduce((i, s) => i + s) : r.length;
  };
});

// ../node_modules/prompts/dist/util/wrap.js
var A4 = E((wet, w4) => {
  "use strict";
  w4.exports = (e, t = {}) => {
    let r = Number.isSafeInteger(parseInt(t.margin)) ? new Array(parseInt(t.margin)).fill(" ").join("") : t.margin || "", i = t.width;
    return (e || "").split(/\r?\n/g).map((s) => s.split(/\s+/g).reduce((a, o) => (o.length + r.length >= i || a[a.length - 1].length + o.length +
    1 < i ? a[a.length - 1] += ` ${o}` : a.push(`${r}${o}`), a), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/dist/util/entriesToDisplay.js
var P4 = E((Aet, _4) => {
  "use strict";
  _4.exports = (e, t, r) => {
    r = r || t;
    let i = Math.min(t - r, e - Math.floor(r / 2));
    i < 0 && (i = 0);
    let s = Math.min(i + r, t);
    return {
      startIndex: i,
      endIndex: s
    };
  };
});

// ../node_modules/prompts/dist/util/index.js
var ls = E((_et, F4) => {
  "use strict";
  F4.exports = {
    action: p4(),
    clear: v4(),
    style: S4(),
    strip: bh(),
    figures: Fb(),
    lines: C4(),
    wrap: A4(),
    entriesToDisplay: P4()
  };
});

// ../node_modules/prompts/dist/elements/prompt.js
var hn = E((Pet, k4) => {
  "use strict";
  var I4 = require("readline"), OG = ls(), kG = OG.action, BG = require("events"), O4 = Wt(), NG = O4.beep, MG = O4.cursor, RG = $t(), Ob = class extends BG {
    static {
      n(this, "Prompt");
    }
    constructor(t = {}) {
      super(), this.firstRender = !0, this.in = t.stdin || process.stdin, this.out = t.stdout || process.stdout, this.onRender = (t.onRender ||
      (() => {
      })).bind(this);
      let r = I4.createInterface({
        input: this.in,
        escapeCodeTimeout: 50
      });
      I4.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let i = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, s = /* @__PURE__ */ n((a, o) => {
        let u = kG(o, i);
        u === !1 ? this._ && this._(a, o) : typeof this[u] == "function" ? this[u](o) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(MG.show), this.in.removeListener("keypress", s), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.aborted ?
        "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", s);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(NG);
    }
    render() {
      this.onRender(RG), this.firstRender && (this.firstRender = !1);
    }
  };
  k4.exports = Ob;
});

// ../node_modules/prompts/dist/elements/text.js
var L4 = E((Iet, R4) => {
  "use strict";
  function B4(e, t, r, i, s, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(B4, "asyncGeneratorStep");
  function N4(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var a = e.apply(t, r);
        function o(l) {
          B4(a, i, s, o, u, "next", l);
        }
        n(o, "_next");
        function u(l) {
          B4(a, i, s, o, u, "throw", l);
        }
        n(u, "_throw"), o(void 0);
      });
    };
  }
  n(N4, "_asyncToGenerator");
  var Dh = $t(), LG = hn(), M4 = Wt(), jG = M4.erase, ef = M4.cursor, vh = ls(), kb = vh.style, Bb = vh.clear, qG = vh.lines, UG = vh.figures,
  Nb = class extends LG {
    static {
      n(this, "TextPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = kb.render(t.style), this.scale = this.transform.scale, this.msg = t.message, this.initial = t.initial || "",
      this.validator = t.validate || (() => !0), this.value = "", this.errorMsg = t.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = Bb("", this.out.columns), this.render();
    }
    set value(t) {
      !t && this.initial ? (this.placeholder = !0, this.rendered = Dh.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(t)), this._value = t, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    validate() {
      var t = this;
      return N4(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return N4(function* () {
        if (t.value = t.value || t.initial, t.cursorOffset = 0, t.cursor = t.rendered.length, yield t.validate(), t.error) {
          t.red = !0, t.fire(), t.render();
          return;
        }
        t.done = !0, t.aborted = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(t) {
      this.placeholder || (this.cursor = this.cursor + t, this.cursorOffset += t);
    }
    _(t, r) {
      let i = this.value.slice(0, this.cursor), s = this.value.slice(this.cursor);
      this.value = `${i}${t}${s}`, this.red = !1, this.cursor = this.placeholder ? 0 : i.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let t = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let t = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(ef.down(qG(this.outputError, this.out.columns) - 1) + Bb(this.
      outputError, this.out.columns)), this.out.write(Bb(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [kb.symbol(this.done, this.aborted), Dh.bold(this.msg), kb.delimiter(this.done), this.red ? Dh.red(this.rendered) : this.rendered].join(
      " "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : UG.pointerSmall} ${Dh.red().italic(r)}`, "")), this.out.write(jG.line + ef.to(0) + this.outputText + ef.save + this.outputError +
      ef.restore + ef.move(this.cursorOffset, 0)));
    }
  };
  R4.exports = Nb;
});

// ../node_modules/prompts/dist/elements/select.js
var $4 = E((ket, U4) => {
  "use strict";
  var mn = $t(), $G = hn(), tf = ls(), j4 = tf.style, q4 = tf.clear, xh = tf.figures, VG = tf.wrap, WG = tf.entriesToDisplay, HG = Wt(), KG = HG.
  cursor, Mb = class extends $G {
    static {
      n(this, "SelectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.hint = t.hint || "- Use arrow-keys. Return to submit.", this.warn = t.warn || "- This option is d\
isabled", this.cursor = t.initial || 0, this.choices = t.choices.map((r, i) => (typeof r == "string" && (r = {
        title: r,
        value: i
      }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? i : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = t.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = q4("", this.out.
      columns), this.render();
    }
    moveCursor(t) {
      this.cursor = t, this.value = this.choices[t].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(t, r) {
      if (t === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(KG.hide) : this.out.write(q4(this.outputText, this.out.columns)), super.render();
      let t = WG(this.cursor, this.choices.length, this.optionsPerPage), r = t.startIndex, i = t.endIndex;
      if (this.outputText = [j4.symbol(this.done, this.aborted), mn.bold(this.msg), j4.delimiter(!1), this.done ? this.selection.title : this.
      selection.disabled ? mn.yellow(this.warn) : mn.gray(this.hint)].join(" "), !this.done) {
        this.outputText += `
`;
        for (let s = r; s < i; s++) {
          let a, o, u = "", l = this.choices[s];
          s === r && r > 0 ? o = xh.arrowUp : s === i - 1 && i < this.choices.length ? o = xh.arrowDown : o = " ", l.disabled ? (a = this.cursor ===
          s ? mn.gray().underline(l.title) : mn.strikethrough().gray(l.title), o = (this.cursor === s ? mn.bold().gray(xh.pointer) + " " : "\
  ") + o) : (a = this.cursor === s ? mn.cyan().underline(l.title) : l.title, o = (this.cursor === s ? mn.cyan(xh.pointer) + " " : "  ") + o,
          l.description && this.cursor === s && (u = ` - ${l.description}`, (o.length + a.length + u.length >= this.out.columns || l.description.
          split(/\r?\n/).length > 1) && (u = `
` + VG(l.description, {
            margin: 3,
            width: this.out.columns
          })))), this.outputText += `${o} ${a}${mn.gray(u)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  U4.exports = Mb;
});

// ../node_modules/prompts/dist/elements/toggle.js
var J4 = E((Net, z4) => {
  "use strict";
  var Eh = $t(), zG = hn(), H4 = ls(), V4 = H4.style, JG = H4.clear, K4 = Wt(), W4 = K4.cursor, XG = K4.erase, Rb = class extends zG {
    static {
      n(this, "TogglePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = !!t.initial, this.active = t.active || "on", this.inactive = t.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.value = !this.value;
      else if (t === "1")
        this.value = !0;
      else if (t === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(W4.hide) : this.out.write(JG(this.outputText, this.out.columns)), super.render(), this.
      outputText = [V4.symbol(this.done, this.aborted), Eh.bold(this.msg), V4.delimiter(this.done), this.value ? this.inactive : Eh.cyan().underline(
      this.inactive), Eh.gray("/"), this.value ? Eh.cyan().underline(this.active) : this.active].join(" "), this.out.write(XG.line + W4.to(0) +
      this.outputText));
    }
  };
  z4.exports = Rb;
});

// ../node_modules/prompts/dist/dateparts/datepart.js
var Ns = E((Ret, X4) => {
  "use strict";
  var Lb = class e {
    static {
      n(this, "DatePart");
    }
    constructor({
      token: t,
      date: r,
      parts: i,
      locales: s
    }) {
      this.token = t, this.date = r || /* @__PURE__ */ new Date(), this.parts = i || [this], this.locales = s || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let t = this.parts.indexOf(this);
      return this.parts.find((r, i) => i > t && r instanceof e);
    }
    setTo(t) {
    }
    prev() {
      let t = [].concat(this.parts).reverse(), r = t.indexOf(this);
      return t.find((i, s) => s > r && i instanceof e);
    }
    toString() {
      return String(this.date);
    }
  };
  X4.exports = Lb;
});

// ../node_modules/prompts/dist/dateparts/meridiem.js
var G4 = E((jet, Y4) => {
  "use strict";
  var YG = Ns(), jb = class extends YG {
    static {
      n(this, "Meridiem");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let t = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? t.toUpperCase() : t;
    }
  };
  Y4.exports = jb;
});

// ../node_modules/prompts/dist/dateparts/day.js
var Q4 = E((Uet, Z4) => {
  "use strict";
  var GG = Ns(), ZG = /* @__PURE__ */ n((e) => (e = e % 10, e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th"), "pos"), qb = class extends GG {
    static {
      n(this, "Day");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(t) {
      this.date.setDate(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(t).padStart(2, "0") : this.token === "Do" ? t + ZG(t) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : t;
    }
  };
  Z4.exports = qb;
});

// ../node_modules/prompts/dist/dateparts/hours.js
var t8 = E((Vet, e8) => {
  "use strict";
  var QG = Ns(), Ub = class extends QG {
    static {
      n(this, "Hours");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(t) {
      this.date.setHours(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getHours();
      return /h/.test(this.token) && (t = t % 12 || 12), this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  e8.exports = Ub;
});

// ../node_modules/prompts/dist/dateparts/milliseconds.js
var i8 = E((Het, r8) => {
  "use strict";
  var eZ = Ns(), $b = class extends eZ {
    static {
      n(this, "Milliseconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(t) {
      this.date.setMilliseconds(parseInt(t.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  r8.exports = $b;
});

// ../node_modules/prompts/dist/dateparts/minutes.js
var n8 = E((zet, s8) => {
  "use strict";
  var tZ = Ns(), Vb = class extends tZ {
    static {
      n(this, "Minutes");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(t) {
      this.date.setMinutes(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getMinutes();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  s8.exports = Vb;
});

// ../node_modules/prompts/dist/dateparts/month.js
var o8 = E((Xet, a8) => {
  "use strict";
  var rZ = Ns(), Wb = class extends rZ {
    static {
      n(this, "Month");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(t) {
      t = parseInt(t.substr(-2)) - 1, this.date.setMonth(t < 0 ? 0 : t);
    }
    toString() {
      let t = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(t + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[t] : r === 4 ? this.locales.months[t] : String(t +
      1);
    }
  };
  a8.exports = Wb;
});

// ../node_modules/prompts/dist/dateparts/seconds.js
var l8 = E((Get, u8) => {
  "use strict";
  var iZ = Ns(), Hb = class extends iZ {
    static {
      n(this, "Seconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(t) {
      this.date.setSeconds(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getSeconds();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  u8.exports = Hb;
});

// ../node_modules/prompts/dist/dateparts/year.js
var f8 = E((Qet, c8) => {
  "use strict";
  var sZ = Ns(), Kb = class extends sZ {
    static {
      n(this, "Year");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(t) {
      this.date.setFullYear(t.substr(-4));
    }
    toString() {
      let t = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? t.substr(-2) : t;
    }
  };
  c8.exports = Kb;
});

// ../node_modules/prompts/dist/dateparts/index.js
var p8 = E((ttt, d8) => {
  "use strict";
  d8.exports = {
    DatePart: Ns(),
    Meridiem: G4(),
    Day: Q4(),
    Hours: t8(),
    Milliseconds: i8(),
    Minutes: n8(),
    Month: o8(),
    Seconds: l8(),
    Year: f8()
  };
});

// ../node_modules/prompts/dist/elements/date.js
var S8 = E((rtt, E8) => {
  "use strict";
  function h8(e, t, r, i, s, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(h8, "asyncGeneratorStep");
  function m8(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var a = e.apply(t, r);
        function o(l) {
          h8(a, i, s, o, u, "next", l);
        }
        n(o, "_next");
        function u(l) {
          h8(a, i, s, o, u, "throw", l);
        }
        n(u, "_throw"), o(void 0);
      });
    };
  }
  n(m8, "_asyncToGenerator");
  var zb = $t(), nZ = hn(), Xb = ls(), y8 = Xb.style, g8 = Xb.clear, aZ = Xb.figures, x8 = Wt(), oZ = x8.erase, b8 = x8.cursor, yn = p8(), D8 = yn.
  DatePart, uZ = yn.Meridiem, lZ = yn.Day, cZ = yn.Hours, fZ = yn.Milliseconds, dZ = yn.Minutes, pZ = yn.Month, hZ = yn.Seconds, mZ = yn.Year,
  yZ = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g, v8 = {
    1: ({
      token: e
    }) => e.replace(/\\(.)/g, "$1"),
    2: (e) => new lZ(e),
    // Day // TODO
    3: (e) => new pZ(e),
    // Month
    4: (e) => new mZ(e),
    // Year
    5: (e) => new uZ(e),
    // AM/PM // TODO (special)
    6: (e) => new cZ(e),
    // Hours
    7: (e) => new dZ(e),
    // Minutes
    8: (e) => new hZ(e),
    // Seconds
    9: (e) => new fZ(e)
    // Fractional seconds
  }, gZ = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, Jb = class extends nZ {
    static {
      n(this, "DatePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(gZ, t.locales), this._date = t.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.mask =
      t.mask || "YYYY-MM-DD HH:mm:ss", this.clear = g8("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(t) {
      t && this._date.setTime(t.getTime());
    }
    set mask(t) {
      let r;
      for (this.parts = []; r = yZ.exec(t); ) {
        let s = r.shift(), a = r.findIndex((o) => o != null);
        this.parts.push(a in v8 ? v8[a]({
          token: r[a] || s,
          date: this.date,
          parts: this.parts,
          locales: this.locales
        }) : r[a] || s);
      }
      let i = this.parts.reduce((s, a) => (typeof a == "string" && typeof s[s.length - 1] == "string" ? s[s.length - 1] += a : s.push(a), s),
      []);
      this.parts.splice(0), this.parts.push(...i), this.reset();
    }
    moveCursor(t) {
      this.typed = "", this.cursor = t, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((t) => t instanceof D8)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    validate() {
      var t = this;
      return m8(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return m8(function* () {
        if (yield t.validate(), t.error) {
          t.color = "red", t.fire(), t.render();
          return;
        }
        t.done = !0, t.aborted = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let t = this.parts[this.cursor].prev();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    right() {
      let t = this.parts[this.cursor].next();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    next() {
      let t = this.parts[this.cursor].next();
      this.moveCursor(t ? this.parts.indexOf(t) : this.parts.findIndex((r) => r instanceof D8)), this.render();
    }
    _(t) {
      /\d/.test(t) && (this.typed += t, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(b8.hide) : this.out.write(g8(this.outputText, this.out.columns)), super.render(), this.
      outputText = [y8.symbol(this.done, this.aborted), zb.bold(this.msg), y8.delimiter(!1), this.parts.reduce((t, r, i) => t.concat(i === this.
      cursor && !this.done ? zb.cyan().underline(r.toString()) : r), []).join("")].join(" "), this.error && (this.outputText += this.errorMsg.
      split(`
`).reduce((t, r, i) => t + `
${i ? " " : aZ.pointerSmall} ${zb.red().italic(r)}`, "")), this.out.write(oZ.line + b8.to(0) + this.outputText));
    }
  };
  E8.exports = Jb;
});

// ../node_modules/prompts/dist/elements/number.js
var F8 = E((stt, P8) => {
  "use strict";
  function T8(e, t, r, i, s, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(T8, "asyncGeneratorStep");
  function C8(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var a = e.apply(t, r);
        function o(l) {
          T8(a, i, s, o, u, "next", l);
        }
        n(o, "_next");
        function u(l) {
          T8(a, i, s, o, u, "throw", l);
        }
        n(u, "_throw"), o(void 0);
      });
    };
  }
  n(C8, "_asyncToGenerator");
  var Sh = $t(), bZ = hn(), _8 = Wt(), Th = _8.cursor, DZ = _8.erase, Ch = ls(), Yb = Ch.style, vZ = Ch.figures, w8 = Ch.clear, xZ = Ch.lines,
  EZ = /[0-9]/, Gb = /* @__PURE__ */ n((e) => e !== void 0, "isDef"), A8 = /* @__PURE__ */ n((e, t) => {
    let r = Math.pow(10, t);
    return Math.round(e * r) / r;
  }, "round"), Zb = class extends bZ {
    static {
      n(this, "NumberPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = Yb.render(t.style), this.msg = t.message, this.initial = Gb(t.initial) ? t.initial : "", this.float = !!t.float,
      this.round = t.round || 2, this.inc = t.increment || 1, this.min = Gb(t.min) ? t.min : -1 / 0, this.max = Gb(t.max) ? t.max : 1 / 0, this.
      errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(t) {
      !t && t !== 0 ? (this.placeholder = !0, this.rendered = Sh.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${A8(t, this.round)}`), this._value = A8(t, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(t) {
      return this.float ? parseFloat(t) : parseInt(t);
    }
    valid(t) {
      return t === "-" || t === "." && this.float || EZ.test(t);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    validate() {
      var t = this;
      return C8(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return C8(function* () {
        if (yield t.validate(), t.error) {
          t.color = "red", t.fire(), t.render();
          return;
        }
        let r = t.value;
        t.value = r !== "" ? r : t.initial, t.done = !0, t.aborted = !1, t.error = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let t = this.value.toString();
      if (t.length === 0) return this.bell();
      this.value = this.parse(t = t.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(t, r) {
      if (!this.valid(t)) return this.bell();
      let i = Date.now();
      if (i - this.lastHit > 1e3 && (this.typed = ""), this.typed += t, this.lastHit = i, this.color = "cyan", t === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Th.down(xZ(this.outputError, this.out.columns) - 1) + w8(this.
      outputError, this.out.columns)), this.out.write(w8(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [Yb.symbol(this.done, this.aborted), Sh.bold(this.msg), Yb.delimiter(this.done), !this.done || !this.done && !this.placeholder ? Sh[this.
      color]().underline(this.rendered) : this.rendered].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : vZ.pointerSmall} ${Sh.red().italic(r)}`, "")), this.out.write(DZ.line + Th.to(0) + this.outputText + Th.save + this.outputError +
      Th.restore));
    }
  };
  P8.exports = Zb;
});

// ../node_modules/prompts/dist/elements/multiselect.js
var e2 = E((att, k8) => {
  "use strict";
  var Ms = $t(), SZ = Wt(), TZ = SZ.cursor, CZ = hn(), rf = ls(), I8 = rf.clear, fa = rf.figures, O8 = rf.style, wZ = rf.wrap, AZ = rf.entriesToDisplay,
  Qb = class extends CZ {
    static {
      n(this, "MultiselectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = t.cursor || 0, this.scrollIndex = t.cursor || 0, this.hint = t.hint || "", this.warn = t.
      warn || "- This option is disabled -", this.minSelected = t.min, this.showMinError = !1, this.maxChoices = t.max, this.instructions = t.
      instructions, this.optionsPerPage = t.optionsPerPage || 10, this.value = t.choices.map((r, i) => (typeof r == "string" && (r = {
        title: r,
        value: i
      }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? i : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = I8("", this.out.columns), t.overrideRender || this.render();
    }
    reset() {
      this.value.map((t) => !t.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((t) => t.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let t = this.value.filter((r) => r.selected);
      this.minSelected && t.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let t = this.value[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let t = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = t), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.handleSpaceToggle();
      else if (t === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${fa.arrowUp}/${fa.arrowDown}: Highlight option
    ${fa.arrowLeft}/${fa.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(t, r, i, s) {
      let a = (r.selected ? Ms.green(fa.radioOn) : fa.radioOff) + " " + s + " ", o, u;
      return r.disabled ? o = t === i ? Ms.gray().underline(r.title) : Ms.strikethrough().gray(r.title) : (o = t === i ? Ms.cyan().underline(
      r.title) : r.title, t === i && r.description && (u = ` - ${r.description}`, (a.length + o.length + u.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (u = `
` + wZ(r.description, {
        margin: a.length,
        width: this.out.columns
      })))), a + o + Ms.gray(u || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(t) {
      if (t.length === 0)
        return Ms.red("No matches for this query.");
      let r = AZ(this.cursor, t.length, this.optionsPerPage), i = r.startIndex, s = r.endIndex, a, o = [];
      for (let u = i; u < s; u++)
        u === i && i > 0 ? a = fa.arrowUp : u === s - 1 && s < t.length ? a = fa.arrowDown : a = " ", o.push(this.renderOption(this.cursor, t[u],
        u, a));
      return `
` + o.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(t) {
      return this.done ? "" : this.paginateOptions(t);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [Ms.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && t.push(Ms.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(TZ.hide), super.render();
      let t = [O8.symbol(this.done, this.aborted), Ms.bold(this.msg), O8.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (t += Ms.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.value), this.out.write(this.clear + t), this.clear = I8(t, this.out.columns);
    }
  };
  k8.exports = Qb;
});

// ../node_modules/prompts/dist/elements/autocomplete.js
var q8 = E((utt, j8) => {
  "use strict";
  function B8(e, t, r, i, s, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(B8, "asyncGeneratorStep");
  function _Z(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var a = e.apply(t, r);
        function o(l) {
          B8(a, i, s, o, u, "next", l);
        }
        n(o, "_next");
        function u(l) {
          B8(a, i, s, o, u, "throw", l);
        }
        n(u, "_throw"), o(void 0);
      });
    };
  }
  n(_Z, "_asyncToGenerator");
  var sf = $t(), PZ = hn(), L8 = Wt(), FZ = L8.erase, N8 = L8.cursor, nf = ls(), t2 = nf.style, M8 = nf.clear, r2 = nf.figures, IZ = nf.wrap,
  OZ = nf.entriesToDisplay, R8 = /* @__PURE__ */ n((e, t) => e[t] && (e[t].value || e[t].title || e[t]), "getVal"), kZ = /* @__PURE__ */ n((e, t) => e[t] &&
  (e[t].title || e[t].value || e[t]), "getTitle"), BZ = /* @__PURE__ */ n((e, t) => {
    let r = e.findIndex((i) => i.value === t || i.title === t);
    return r > -1 ? r : void 0;
  }, "getIndex"), i2 = class extends PZ {
    static {
      n(this, "AutocompletePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.suggest = t.suggest, this.choices = t.choices, this.initial = typeof t.initial == "number" ? t.initial :
      BZ(t.choices, t.initial), this.select = this.initial || t.cursor || 0, this.i18n = {
        noMatches: t.noMatches || "no matches found"
      }, this.fallback = t.fallback || this.initial, this.clearFirst = t.clearFirst || !1, this.suggestions = [], this.input = "", this.limit =
      t.limit || 10, this.cursor = 0, this.transform = t2.render(t.style), this.scale = this.transform.scale, this.render = this.render.bind(
      this), this.complete = this.complete.bind(this), this.clear = M8("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(t) {
      this._fb = Number.isSafeInteger(parseInt(t)) ? parseInt(t) : t;
    }
    get fallback() {
      let t;
      return typeof this._fb == "number" ? t = this.choices[this._fb] : typeof this._fb == "string" && (t = {
        title: this._fb
      }), t || this._fb || {
        title: this.i18n.noMatches
      };
    }
    moveSelect(t) {
      this.select = t, this.suggestions.length > 0 ? this.value = R8(this.suggestions, t) : this.value = this.fallback.value, this.fire();
    }
    complete(t) {
      var r = this;
      return _Z(function* () {
        let i = r.completing = r.suggest(r.input, r.choices), s = yield i;
        if (r.completing !== i) return;
        r.suggestions = s.map((o, u, l) => ({
          title: kZ(l, u),
          value: R8(l, u),
          description: o.description
        })), r.completing = !1;
        let a = Math.max(s.length - 1, 0);
        r.moveSelect(Math.min(a, r.select)), t && t();
      })();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      let i = this.input.slice(0, this.cursor), s = this.input.slice(this.cursor);
      this.input = `${i}${t}${s}`, this.cursor = i.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let t = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${t}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let t = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${t}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(t, r, i, s) {
      let a, o = i ? r2.arrowUp : s ? r2.arrowDown : " ", u = r ? sf.cyan().underline(t.title) : t.title;
      return o = (r ? sf.cyan(r2.pointer) + " " : "  ") + o, t.description && (a = ` - ${t.description}`, (o.length + u.length + a.length >=
      this.out.columns || t.description.split(/\r?\n/).length > 1) && (a = `
` + IZ(t.description, {
        margin: 3,
        width: this.out.columns
      }))), o + " " + u + sf.gray(a || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(N8.hide) : this.out.write(M8(this.outputText, this.out.columns)), super.render();
      let t = OZ(this.select, this.choices.length, this.limit), r = t.startIndex, i = t.endIndex;
      if (this.outputText = [t2.symbol(this.done, this.aborted, this.exited), sf.bold(this.msg), t2.delimiter(this.completing), this.done &&
      this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" "), !this.
      done) {
        let s = this.suggestions.slice(r, i).map((a, o) => this.renderOption(a, this.select === o + r, o === 0 && r > 0, o + r === i - 1 && i <
        this.choices.length)).join(`
`);
        this.outputText += `
` + (s || sf.gray(this.fallback.title));
      }
      this.out.write(FZ.line + N8.to(0) + this.outputText);
    }
  };
  j8.exports = i2;
});

// ../node_modules/prompts/dist/elements/autocompleteMultiselect.js
var W8 = E((ctt, V8) => {
  "use strict";
  var gn = $t(), NZ = Wt(), MZ = NZ.cursor, RZ = e2(), n2 = ls(), U8 = n2.clear, $8 = n2.style, zu = n2.figures, s2 = class extends RZ {
    static {
      n(this, "AutocompleteMultiselectPrompt");
    }
    constructor(t = {}) {
      t.overrideRender = !0, super(t), this.inputValue = "", this.clear = U8("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let t = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((i) => this.inputValue ? !!(typeof i.title == "string" && i.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof i.value == "string" && i.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((i) => i === t);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let t = this.filteredOptions[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    handleInputChange(t) {
      this.inputValue = this.inputValue + t, this.updateFilteredOptions();
    }
    _(t, r) {
      t === " " ? this.handleSpaceToggle() : this.handleInputChange(t);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${zu.arrowUp}/${zu.arrowDown}: Highlight option
    ${zu.arrowLeft}/${zu.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : gn.gray("Enter something to filter")}
`;
    }
    renderOption(t, r, i) {
      let s;
      return r.disabled ? s = t === i ? gn.gray().underline(r.title) : gn.strikethrough().gray(r.title) : s = t === i ? gn.cyan().underline(
      r.title) : r.title, (r.selected ? gn.green(zu.radioOn) : zu.radioOff) + "  " + s;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [gn.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && t.push(gn.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(MZ.hide), super.render();
      let t = [$8.symbol(this.done, this.aborted), gn.bold(this.msg), $8.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (t += gn.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + t), this.clear = U8(t, this.out.columns);
    }
  };
  V8.exports = s2;
});

// ../node_modules/prompts/dist/elements/confirm.js
var G8 = E((dtt, Y8) => {
  "use strict";
  var H8 = $t(), LZ = hn(), J8 = ls(), K8 = J8.style, jZ = J8.clear, X8 = Wt(), qZ = X8.erase, z8 = X8.cursor, a2 = class extends LZ {
    static {
      n(this, "ConfirmPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = t.initial, this.initialValue = !!t.initial, this.yesMsg = t.yes || "yes", this.yesOption =
      t.yesOption || "(Y/n)", this.noMsg = t.no || "no", this.noOption = t.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      return t.toLowerCase() === "y" ? (this.value = !0, this.submit()) : t.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(z8.hide) : this.out.write(jZ(this.outputText, this.out.columns)), super.render(), this.
      outputText = [K8.symbol(this.done, this.aborted), H8.bold(this.msg), K8.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.
      noMsg : H8.gray(this.initialValue ? this.yesOption : this.noOption)].join(" "), this.out.write(qZ.line + z8.to(0) + this.outputText));
    }
  };
  Y8.exports = a2;
});

// ../node_modules/prompts/dist/elements/index.js
var Q8 = E((htt, Z8) => {
  "use strict";
  Z8.exports = {
    TextPrompt: L4(),
    SelectPrompt: $4(),
    TogglePrompt: J4(),
    DatePrompt: S8(),
    NumberPrompt: F8(),
    MultiselectPrompt: e2(),
    AutocompletePrompt: q8(),
    AutocompleteMultiselectPrompt: W8(),
    ConfirmPrompt: G8()
  };
});

// ../node_modules/prompts/dist/prompts.js
var tF = E((eF) => {
  "use strict";
  var fi = eF, UZ = Q8(), wh = /* @__PURE__ */ n((e) => e, "noop");
  function Rs(e, t, r = {}) {
    return new Promise((i, s) => {
      let a = new UZ[e](t), o = r.onAbort || wh, u = r.onSubmit || wh, l = r.onExit || wh;
      a.on("state", t.onState || wh), a.on("submit", (c) => i(u(c))), a.on("exit", (c) => i(l(c))), a.on("abort", (c) => s(o(c)));
    });
  }
  n(Rs, "toPrompt");
  fi.text = (e) => Rs("TextPrompt", e);
  fi.password = (e) => (e.style = "password", fi.text(e));
  fi.invisible = (e) => (e.style = "invisible", fi.text(e));
  fi.number = (e) => Rs("NumberPrompt", e);
  fi.date = (e) => Rs("DatePrompt", e);
  fi.confirm = (e) => Rs("ConfirmPrompt", e);
  fi.list = (e) => {
    let t = e.separator || ",";
    return Rs("TextPrompt", e, {
      onSubmit: /* @__PURE__ */ n((r) => r.split(t).map((i) => i.trim()), "onSubmit")
    });
  };
  fi.toggle = (e) => Rs("TogglePrompt", e);
  fi.select = (e) => Rs("SelectPrompt", e);
  fi.multiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ n((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return Rs("MultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  fi.autocompleteMultiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ n((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return Rs("AutocompleteMultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  var $Z = /* @__PURE__ */ n((e, t) => Promise.resolve(t.filter((r) => r.title.slice(0, e.length).toLowerCase() === e.toLowerCase())), "byTi\
tle");
  fi.autocomplete = (e) => (e.suggest = e.suggest || $Z, e.choices = [].concat(e.choices || []), Rs("AutocompletePrompt", e));
});

// ../node_modules/prompts/dist/index.js
var lF = E((gtt, uF) => {
  "use strict";
  function rF(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      t && (i = i.filter(function(s) {
        return Object.getOwnPropertyDescriptor(e, s).enumerable;
      })), r.push.apply(r, i);
    }
    return r;
  }
  n(rF, "ownKeys");
  function iF(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2 ? rF(Object(r), !0).forEach(function(i) {
        VZ(e, i, r[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : rF(Object(r)).forEach(function(i) {
        Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
      });
    }
    return e;
  }
  n(iF, "_objectSpread");
  function VZ(e, t, r) {
    return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
  }
  n(VZ, "_defineProperty");
  function WZ(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = HZ(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var i = 0, s = /* @__PURE__ */ n(function() {
        }, "F");
        return { s, n: /* @__PURE__ */ n(function() {
          return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] };
        }, "n"), e: /* @__PURE__ */ n(function(c) {
          throw c;
        }, "e"), f: s };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var a = !0, o = !1, u;
    return { s: /* @__PURE__ */ n(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ n(function() {
      var c = r.next();
      return a = c.done, c;
    }, "n"), e: /* @__PURE__ */ n(function(c) {
      o = !0, u = c;
    }, "e"), f: /* @__PURE__ */ n(function() {
      try {
        !a && r.return != null && r.return();
      } finally {
        if (o) throw u;
      }
    }, "f") };
  }
  n(WZ, "_createForOfIteratorHelper");
  function HZ(e, t) {
    if (e) {
      if (typeof e == "string") return sF(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return sF(e, t);
    }
  }
  n(HZ, "_unsupportedIterableToArray");
  function sF(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
    return i;
  }
  n(sF, "_arrayLikeToArray");
  function nF(e, t, r, i, s, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(nF, "asyncGeneratorStep");
  function aF(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var a = e.apply(t, r);
        function o(l) {
          nF(a, i, s, o, u, "next", l);
        }
        n(o, "_next");
        function u(l) {
          nF(a, i, s, o, u, "throw", l);
        }
        n(u, "_throw"), o(void 0);
      });
    };
  }
  n(aF, "_asyncToGenerator");
  var o2 = tF(), KZ = ["suggest", "format", "onState", "validate", "onRender", "type"], oF = /* @__PURE__ */ n(() => {
  }, "noop");
  function da() {
    return u2.apply(this, arguments);
  }
  n(da, "prompt");
  function u2() {
    return u2 = aF(function* (e = [], {
      onSubmit: t = oF,
      onCancel: r = oF
    } = {}) {
      let i = {}, s = da._override || {};
      e = [].concat(e);
      let a, o, u, l, c, f, m = /* @__PURE__ */ function() {
        var g = aF(function* (b, D, x = !1) {
          if (!(!x && b.validate && b.validate(D) !== !0))
            return b.format ? yield b.format(D, i) : D;
        });
        return /* @__PURE__ */ n(function(D, x) {
          return g.apply(this, arguments);
        }, "getFormattedAnswer");
      }();
      var h = WZ(e), d;
      try {
        for (h.s(); !(d = h.n()).done; ) {
          o = d.value;
          var y = o;
          if (l = y.name, c = y.type, typeof c == "function" && (c = yield c(a, iF({}, i), o), o.type = c), !!c) {
            for (let g in o) {
              if (KZ.includes(g)) continue;
              let b = o[g];
              o[g] = typeof b == "function" ? yield b(a, iF({}, i), f) : b;
            }
            if (f = o, typeof o.message != "string")
              throw new Error("prompt message is required");
            var p = o;
            if (l = p.name, c = p.type, o2[c] === void 0)
              throw new Error(`prompt type (${c}) is not defined`);
            if (s[o.name] !== void 0 && (a = yield m(o, s[o.name]), a !== void 0)) {
              i[l] = a;
              continue;
            }
            try {
              a = da._injected ? zZ(da._injected, o.initial) : yield o2[c](o), i[l] = a = yield m(o, a, !0), u = yield t(o, a, i);
            } catch {
              u = !(yield r(o, i));
            }
            if (u) return i;
          }
        }
      } catch (g) {
        h.e(g);
      } finally {
        h.f();
      }
      return i;
    }), u2.apply(this, arguments);
  }
  n(u2, "_prompt");
  function zZ(e, t) {
    let r = e.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? t : r;
  }
  n(zZ, "getInjectedAnswer");
  function JZ(e) {
    da._injected = (da._injected || []).concat(e);
  }
  n(JZ, "inject");
  function XZ(e) {
    da._override = Object.assign({}, e);
  }
  n(XZ, "override");
  uF.exports = Object.assign(da, {
    prompt: da,
    prompts: o2,
    inject: JZ,
    override: XZ
  });
});

// ../node_modules/prompts/lib/util/action.js
var fF = E((Dtt, cF) => {
  "use strict";
  cF.exports = (e, t) => {
    if (!(e.meta && e.name !== "escape")) {
      if (e.ctrl) {
        if (e.name === "a") return "first";
        if (e.name === "c" || e.name === "d") return "abort";
        if (e.name === "e") return "last";
        if (e.name === "g") return "reset";
      }
      if (t) {
        if (e.name === "j") return "down";
        if (e.name === "k") return "up";
      }
      return e.name === "return" || e.name === "enter" ? "submit" : e.name === "backspace" ? "delete" : e.name === "delete" ? "deleteForward" :
      e.name === "abort" ? "abort" : e.name === "escape" ? "exit" : e.name === "tab" ? "next" : e.name === "pagedown" ? "nextPage" : e.name ===
      "pageup" ? "prevPage" : e.name === "home" ? "home" : e.name === "end" ? "end" : e.name === "up" ? "up" : e.name === "down" ? "down" : e.
      name === "right" ? "right" : e.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/lib/util/strip.js
var Ah = E((vtt, dF) => {
  "use strict";
  dF.exports = (e) => {
    let t = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
    ].join("|"), r = new RegExp(t, "g");
    return typeof e == "string" ? e.replace(r, "") : e;
  };
});

// ../node_modules/prompts/lib/util/clear.js
var mF = E((xtt, hF) => {
  "use strict";
  var YZ = Ah(), { erase: pF, cursor: GZ } = Wt(), ZZ = /* @__PURE__ */ n((e) => [...YZ(e)].length, "width");
  hF.exports = function(e, t) {
    if (!t) return pF.line + GZ.to(0);
    let r = 0, i = e.split(/\r?\n/);
    for (let s of i)
      r += 1 + Math.floor(Math.max(ZZ(s) - 1, 0) / t);
    return pF.lines(r);
  };
});

// ../node_modules/prompts/lib/util/figures.js
var l2 = E((Stt, yF) => {
  "use strict";
  var af = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, QZ = {
    arrowUp: af.arrowUp,
    arrowDown: af.arrowDown,
    arrowLeft: af.arrowLeft,
    arrowRight: af.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, eQ = process.platform === "win32" ? QZ : af;
  yF.exports = eQ;
});

// ../node_modules/prompts/lib/util/style.js
var bF = E((Ttt, gF) => {
  "use strict";
  var Ju = $t(), ho = l2(), c2 = Object.freeze({
    password: { scale: 1, render: /* @__PURE__ */ n((e) => "*".repeat(e.length), "render") },
    emoji: { scale: 2, render: /* @__PURE__ */ n((e) => "\u{1F603}".repeat(e.length), "render") },
    invisible: { scale: 0, render: /* @__PURE__ */ n((e) => "", "render") },
    default: { scale: 1, render: /* @__PURE__ */ n((e) => `${e}`, "render") }
  }), tQ = /* @__PURE__ */ n((e) => c2[e] || c2.default, "render"), of = Object.freeze({
    aborted: Ju.red(ho.cross),
    done: Ju.green(ho.tick),
    exited: Ju.yellow(ho.cross),
    default: Ju.cyan("?")
  }), rQ = /* @__PURE__ */ n((e, t, r) => t ? of.aborted : r ? of.exited : e ? of.done : of.default, "symbol"), iQ = /* @__PURE__ */ n((e) => Ju.
  gray(e ? ho.ellipsis : ho.pointerSmall), "delimiter"), sQ = /* @__PURE__ */ n((e, t) => Ju.gray(e ? t ? ho.pointerSmall : "+" : ho.line), "\
item");
  gF.exports = {
    styles: c2,
    render: tQ,
    symbols: of,
    symbol: rQ,
    delimiter: iQ,
    item: sQ
  };
});

// ../node_modules/prompts/lib/util/lines.js
var vF = E((wtt, DF) => {
  "use strict";
  var nQ = Ah();
  DF.exports = function(e, t) {
    let r = String(nQ(e) || "").split(/\r?\n/);
    return t ? r.map((i) => Math.ceil(i.length / t)).reduce((i, s) => i + s) : r.length;
  };
});

// ../node_modules/prompts/lib/util/wrap.js
var EF = E((Att, xF) => {
  "use strict";
  xF.exports = (e, t = {}) => {
    let r = Number.isSafeInteger(parseInt(t.margin)) ? new Array(parseInt(t.margin)).fill(" ").join("") : t.margin || "", i = t.width;
    return (e || "").split(/\r?\n/g).map((s) => s.split(/\s+/g).reduce((a, o) => (o.length + r.length >= i || a[a.length - 1].length + o.length +
    1 < i ? a[a.length - 1] += ` ${o}` : a.push(`${r}${o}`), a), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/lib/util/entriesToDisplay.js
var TF = E((_tt, SF) => {
  "use strict";
  SF.exports = (e, t, r) => {
    r = r || t;
    let i = Math.min(t - r, e - Math.floor(r / 2));
    i < 0 && (i = 0);
    let s = Math.min(i + r, t);
    return { startIndex: i, endIndex: s };
  };
});

// ../node_modules/prompts/lib/util/index.js
var cs = E((Ptt, CF) => {
  "use strict";
  CF.exports = {
    action: fF(),
    clear: mF(),
    style: bF(),
    strip: Ah(),
    figures: l2(),
    lines: vF(),
    wrap: EF(),
    entriesToDisplay: TF()
  };
});

// ../node_modules/prompts/lib/elements/prompt.js
var bn = E((Ftt, AF) => {
  "use strict";
  var wF = require("readline"), { action: aQ } = cs(), oQ = require("events"), { beep: uQ, cursor: lQ } = Wt(), cQ = $t(), f2 = class extends oQ {
    static {
      n(this, "Prompt");
    }
    constructor(t = {}) {
      super(), this.firstRender = !0, this.in = t.stdin || process.stdin, this.out = t.stdout || process.stdout, this.onRender = (t.onRender ||
      (() => {
      })).bind(this);
      let r = wF.createInterface({ input: this.in, escapeCodeTimeout: 50 });
      wF.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let i = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, s = /* @__PURE__ */ n((a, o) => {
        let u = aQ(o, i);
        u === !1 ? this._ && this._(a, o) : typeof this[u] == "function" ? this[u](o) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(lQ.show), this.in.removeListener("keypress", s), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.aborted ?
        "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", s);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(uQ);
    }
    render() {
      this.onRender(cQ), this.firstRender && (this.firstRender = !1);
    }
  };
  AF.exports = f2;
});

// ../node_modules/prompts/lib/elements/text.js
var PF = E((Ott, _F) => {
  var _h = $t(), fQ = bn(), { erase: dQ, cursor: uf } = Wt(), { style: d2, clear: p2, lines: pQ, figures: hQ } = cs(), h2 = class extends fQ {
    static {
      n(this, "TextPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = d2.render(t.style), this.scale = this.transform.scale, this.msg = t.message, this.initial = t.initial || "",
      this.validator = t.validate || (() => !0), this.value = "", this.errorMsg = t.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = p2("", this.out.columns), this.render();
    }
    set value(t) {
      !t && this.initial ? (this.placeholder = !0, this.rendered = _h.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(t)), this._value = t, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (this.value = this.value || this.initial, this.cursorOffset = 0, this.cursor = this.rendered.length, await this.validate(), this.error) {
        this.red = !0, this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(t) {
      this.placeholder || (this.cursor = this.cursor + t, this.cursorOffset += t);
    }
    _(t, r) {
      let i = this.value.slice(0, this.cursor), s = this.value.slice(this.cursor);
      this.value = `${i}${t}${s}`, this.red = !1, this.cursor = this.placeholder ? 0 : i.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let t = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let t = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(uf.down(pQ(this.outputError, this.out.columns) - 1) + p2(this.
      outputError, this.out.columns)), this.out.write(p2(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        d2.symbol(this.done, this.aborted),
        _h.bold(this.msg),
        d2.delimiter(this.done),
        this.red ? _h.red(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : hQ.pointerSmall} ${_h.red().italic(r)}`, "")), this.out.write(dQ.line + uf.to(0) + this.outputText + uf.save + this.outputError +
      uf.restore + uf.move(this.cursorOffset, 0)));
    }
  };
  _F.exports = h2;
});

// ../node_modules/prompts/lib/elements/select.js
var kF = E((Btt, OF) => {
  "use strict";
  var Dn = $t(), mQ = bn(), { style: FF, clear: IF, figures: Ph, wrap: yQ, entriesToDisplay: gQ } = cs(), { cursor: bQ } = Wt(), m2 = class extends mQ {
    static {
      n(this, "SelectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.hint = t.hint || "- Use arrow-keys. Return to submit.", this.warn = t.warn || "- This option is d\
isabled", this.cursor = t.initial || 0, this.choices = t.choices.map((r, i) => (typeof r == "string" && (r = { title: r, value: i }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? i : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = t.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = IF("", this.out.
      columns), this.render();
    }
    moveCursor(t) {
      this.cursor = t, this.value = this.choices[t].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(t, r) {
      if (t === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(bQ.hide) : this.out.write(IF(this.outputText, this.out.columns)), super.render();
      let { startIndex: t, endIndex: r } = gQ(this.cursor, this.choices.length, this.optionsPerPage);
      if (this.outputText = [
        FF.symbol(this.done, this.aborted),
        Dn.bold(this.msg),
        FF.delimiter(!1),
        this.done ? this.selection.title : this.selection.disabled ? Dn.yellow(this.warn) : Dn.gray(this.hint)
      ].join(" "), !this.done) {
        this.outputText += `
`;
        for (let i = t; i < r; i++) {
          let s, a, o = "", u = this.choices[i];
          i === t && t > 0 ? a = Ph.arrowUp : i === r - 1 && r < this.choices.length ? a = Ph.arrowDown : a = " ", u.disabled ? (s = this.cursor ===
          i ? Dn.gray().underline(u.title) : Dn.strikethrough().gray(u.title), a = (this.cursor === i ? Dn.bold().gray(Ph.pointer) + " " : "\
  ") + a) : (s = this.cursor === i ? Dn.cyan().underline(u.title) : u.title, a = (this.cursor === i ? Dn.cyan(Ph.pointer) + " " : "  ") + a,
          u.description && this.cursor === i && (o = ` - ${u.description}`, (a.length + s.length + o.length >= this.out.columns || u.description.
          split(/\r?\n/).length > 1) && (o = `
` + yQ(u.description, { margin: 3, width: this.out.columns })))), this.outputText += `${a} ${s}${Dn.gray(o)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  OF.exports = m2;
});

// ../node_modules/prompts/lib/elements/toggle.js
var RF = E((Mtt, MF) => {
  var Fh = $t(), DQ = bn(), { style: BF, clear: vQ } = cs(), { cursor: NF, erase: xQ } = Wt(), y2 = class extends DQ {
    static {
      n(this, "TogglePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = !!t.initial, this.active = t.active || "on", this.inactive = t.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.value = !this.value;
      else if (t === "1")
        this.value = !0;
      else if (t === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(NF.hide) : this.out.write(vQ(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        BF.symbol(this.done, this.aborted),
        Fh.bold(this.msg),
        BF.delimiter(this.done),
        this.value ? this.inactive : Fh.cyan().underline(this.inactive),
        Fh.gray("/"),
        this.value ? Fh.cyan().underline(this.active) : this.active
      ].join(" "), this.out.write(xQ.line + NF.to(0) + this.outputText));
    }
  };
  MF.exports = y2;
});

// ../node_modules/prompts/lib/dateparts/datepart.js
var Ls = E((Ltt, LF) => {
  "use strict";
  var g2 = class e {
    static {
      n(this, "DatePart");
    }
    constructor({ token: t, date: r, parts: i, locales: s }) {
      this.token = t, this.date = r || /* @__PURE__ */ new Date(), this.parts = i || [this], this.locales = s || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let t = this.parts.indexOf(this);
      return this.parts.find((r, i) => i > t && r instanceof e);
    }
    setTo(t) {
    }
    prev() {
      let t = [].concat(this.parts).reverse(), r = t.indexOf(this);
      return t.find((i, s) => s > r && i instanceof e);
    }
    toString() {
      return String(this.date);
    }
  };
  LF.exports = g2;
});

// ../node_modules/prompts/lib/dateparts/meridiem.js
var qF = E((qtt, jF) => {
  "use strict";
  var EQ = Ls(), b2 = class extends EQ {
    static {
      n(this, "Meridiem");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let t = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? t.toUpperCase() : t;
    }
  };
  jF.exports = b2;
});

// ../node_modules/prompts/lib/dateparts/day.js
var $F = E(($tt, UF) => {
  "use strict";
  var SQ = Ls(), TQ = /* @__PURE__ */ n((e) => (e = e % 10, e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th"), "pos"), D2 = class extends SQ {
    static {
      n(this, "Day");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(t) {
      this.date.setDate(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(t).padStart(2, "0") : this.token === "Do" ? t + TQ(t) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : t;
    }
  };
  UF.exports = D2;
});

// ../node_modules/prompts/lib/dateparts/hours.js
var WF = E((Wtt, VF) => {
  "use strict";
  var CQ = Ls(), v2 = class extends CQ {
    static {
      n(this, "Hours");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(t) {
      this.date.setHours(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getHours();
      return /h/.test(this.token) && (t = t % 12 || 12), this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  VF.exports = v2;
});

// ../node_modules/prompts/lib/dateparts/milliseconds.js
var KF = E((Ktt, HF) => {
  "use strict";
  var wQ = Ls(), x2 = class extends wQ {
    static {
      n(this, "Milliseconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(t) {
      this.date.setMilliseconds(parseInt(t.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  HF.exports = x2;
});

// ../node_modules/prompts/lib/dateparts/minutes.js
var JF = E((Jtt, zF) => {
  "use strict";
  var AQ = Ls(), E2 = class extends AQ {
    static {
      n(this, "Minutes");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(t) {
      this.date.setMinutes(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getMinutes();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  zF.exports = E2;
});

// ../node_modules/prompts/lib/dateparts/month.js
var YF = E((Ytt, XF) => {
  "use strict";
  var _Q = Ls(), S2 = class extends _Q {
    static {
      n(this, "Month");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(t) {
      t = parseInt(t.substr(-2)) - 1, this.date.setMonth(t < 0 ? 0 : t);
    }
    toString() {
      let t = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(t + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[t] : r === 4 ? this.locales.months[t] : String(t +
      1);
    }
  };
  XF.exports = S2;
});

// ../node_modules/prompts/lib/dateparts/seconds.js
var ZF = E((Ztt, GF) => {
  "use strict";
  var PQ = Ls(), T2 = class extends PQ {
    static {
      n(this, "Seconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(t) {
      this.date.setSeconds(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getSeconds();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  GF.exports = T2;
});

// ../node_modules/prompts/lib/dateparts/year.js
var e6 = E((ert, QF) => {
  "use strict";
  var FQ = Ls(), C2 = class extends FQ {
    static {
      n(this, "Year");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(t) {
      this.date.setFullYear(t.substr(-4));
    }
    toString() {
      let t = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? t.substr(-2) : t;
    }
  };
  QF.exports = C2;
});

// ../node_modules/prompts/lib/dateparts/index.js
var r6 = E((rrt, t6) => {
  "use strict";
  t6.exports = {
    DatePart: Ls(),
    Meridiem: qF(),
    Day: $F(),
    Hours: WF(),
    Milliseconds: KF(),
    Minutes: JF(),
    Month: YF(),
    Seconds: ZF(),
    Year: e6()
  };
});

// ../node_modules/prompts/lib/elements/date.js
var l6 = E((irt, u6) => {
  "use strict";
  var w2 = $t(), IQ = bn(), { style: i6, clear: s6, figures: OQ } = cs(), { erase: kQ, cursor: n6 } = Wt(), { DatePart: a6, Meridiem: BQ, Day: NQ,
  Hours: MQ, Milliseconds: RQ, Minutes: LQ, Month: jQ, Seconds: qQ, Year: UQ } = r6(), $Q = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g,
  o6 = {
    1: ({ token: e }) => e.replace(/\\(.)/g, "$1"),
    2: (e) => new NQ(e),
    // Day // TODO
    3: (e) => new jQ(e),
    // Month
    4: (e) => new UQ(e),
    // Year
    5: (e) => new BQ(e),
    // AM/PM // TODO (special)
    6: (e) => new MQ(e),
    // Hours
    7: (e) => new LQ(e),
    // Minutes
    8: (e) => new qQ(e),
    // Seconds
    9: (e) => new RQ(e)
    // Fractional seconds
  }, VQ = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, A2 = class extends IQ {
    static {
      n(this, "DatePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(VQ, t.locales), this._date = t.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.mask =
      t.mask || "YYYY-MM-DD HH:mm:ss", this.clear = s6("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(t) {
      t && this._date.setTime(t.getTime());
    }
    set mask(t) {
      let r;
      for (this.parts = []; r = $Q.exec(t); ) {
        let s = r.shift(), a = r.findIndex((o) => o != null);
        this.parts.push(a in o6 ? o6[a]({ token: r[a] || s, date: this.date, parts: this.parts, locales: this.locales }) : r[a] || s);
      }
      let i = this.parts.reduce((s, a) => (typeof a == "string" && typeof s[s.length - 1] == "string" ? s[s.length - 1] += a : s.push(a), s),
      []);
      this.parts.splice(0), this.parts.push(...i), this.reset();
    }
    moveCursor(t) {
      this.typed = "", this.cursor = t, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((t) => t instanceof a6)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let t = this.parts[this.cursor].prev();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    right() {
      let t = this.parts[this.cursor].next();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    next() {
      let t = this.parts[this.cursor].next();
      this.moveCursor(t ? this.parts.indexOf(t) : this.parts.findIndex((r) => r instanceof a6)), this.render();
    }
    _(t) {
      /\d/.test(t) && (this.typed += t, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(n6.hide) : this.out.write(s6(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        i6.symbol(this.done, this.aborted),
        w2.bold(this.msg),
        i6.delimiter(!1),
        this.parts.reduce((t, r, i) => t.concat(i === this.cursor && !this.done ? w2.cyan().underline(r.toString()) : r), []).join("")
      ].join(" "), this.error && (this.outputText += this.errorMsg.split(`
`).reduce(
        (t, r, i) => t + `
${i ? " " : OQ.pointerSmall} ${w2.red().italic(r)}`,
        ""
      )), this.out.write(kQ.line + n6.to(0) + this.outputText));
    }
  };
  u6.exports = A2;
});

// ../node_modules/prompts/lib/elements/number.js
var p6 = E((nrt, d6) => {
  var Ih = $t(), WQ = bn(), { cursor: Oh, erase: HQ } = Wt(), { style: _2, figures: KQ, clear: c6, lines: zQ } = cs(), JQ = /[0-9]/, P2 = /* @__PURE__ */ n(
  (e) => e !== void 0, "isDef"), f6 = /* @__PURE__ */ n((e, t) => {
    let r = Math.pow(10, t);
    return Math.round(e * r) / r;
  }, "round"), F2 = class extends WQ {
    static {
      n(this, "NumberPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = _2.render(t.style), this.msg = t.message, this.initial = P2(t.initial) ? t.initial : "", this.float = !!t.float,
      this.round = t.round || 2, this.inc = t.increment || 1, this.min = P2(t.min) ? t.min : -1 / 0, this.max = P2(t.max) ? t.max : 1 / 0, this.
      errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(t) {
      !t && t !== 0 ? (this.placeholder = !0, this.rendered = Ih.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${f6(t, this.round)}`), this._value = f6(t, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(t) {
      return this.float ? parseFloat(t) : parseInt(t);
    }
    valid(t) {
      return t === "-" || t === "." && this.float || JQ.test(t);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = !0, this.aborted = !1, this.error = !1, this.fire(), this.render(), this.out.write(
      `
`), this.close();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let t = this.value.toString();
      if (t.length === 0) return this.bell();
      this.value = this.parse(t = t.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(t, r) {
      if (!this.valid(t)) return this.bell();
      let i = Date.now();
      if (i - this.lastHit > 1e3 && (this.typed = ""), this.typed += t, this.lastHit = i, this.color = "cyan", t === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Oh.down(zQ(this.outputError, this.out.columns) - 1) + c6(this.
      outputError, this.out.columns)), this.out.write(c6(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        _2.symbol(this.done, this.aborted),
        Ih.bold(this.msg),
        _2.delimiter(this.done),
        !this.done || !this.done && !this.placeholder ? Ih[this.color]().underline(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : KQ.pointerSmall} ${Ih.red().italic(r)}`, "")), this.out.write(HQ.line + Oh.to(0) + this.outputText + Oh.save + this.outputError +
      Oh.restore));
    }
  };
  d6.exports = F2;
});

// ../node_modules/prompts/lib/elements/multiselect.js
var O2 = E((ort, y6) => {
  "use strict";
  var js = $t(), { cursor: XQ } = Wt(), YQ = bn(), { clear: h6, figures: pa, style: m6, wrap: GQ, entriesToDisplay: ZQ } = cs(), I2 = class extends YQ {
    static {
      n(this, "MultiselectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = t.cursor || 0, this.scrollIndex = t.cursor || 0, this.hint = t.hint || "", this.warn = t.
      warn || "- This option is disabled -", this.minSelected = t.min, this.showMinError = !1, this.maxChoices = t.max, this.instructions = t.
      instructions, this.optionsPerPage = t.optionsPerPage || 10, this.value = t.choices.map((r, i) => (typeof r == "string" && (r = { title: r,
      value: i }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? i : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = h6("", this.out.columns), t.overrideRender || this.render();
    }
    reset() {
      this.value.map((t) => !t.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((t) => t.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let t = this.value.filter((r) => r.selected);
      this.minSelected && t.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let t = this.value[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let t = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = t), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.handleSpaceToggle();
      else if (t === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${pa.arrowUp}/${pa.arrowDown}: Highlight option
    ${pa.arrowLeft}/${pa.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(t, r, i, s) {
      let a = (r.selected ? js.green(pa.radioOn) : pa.radioOff) + " " + s + " ", o, u;
      return r.disabled ? o = t === i ? js.gray().underline(r.title) : js.strikethrough().gray(r.title) : (o = t === i ? js.cyan().underline(
      r.title) : r.title, t === i && r.description && (u = ` - ${r.description}`, (a.length + o.length + u.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (u = `
` + GQ(r.description, { margin: a.length, width: this.out.columns })))), a + o + js.gray(u || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(t) {
      if (t.length === 0)
        return js.red("No matches for this query.");
      let { startIndex: r, endIndex: i } = ZQ(this.cursor, t.length, this.optionsPerPage), s, a = [];
      for (let o = r; o < i; o++)
        o === r && r > 0 ? s = pa.arrowUp : o === i - 1 && i < t.length ? s = pa.arrowDown : s = " ", a.push(this.renderOption(this.cursor, t[o],
        o, s));
      return `
` + a.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(t) {
      return this.done ? "" : this.paginateOptions(t);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [js.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && t.push(js.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(XQ.hide), super.render();
      let t = [
        m6.symbol(this.done, this.aborted),
        js.bold(this.msg),
        m6.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (t += js.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.value), this.out.write(this.clear + t), this.clear = h6(t, this.out.columns);
    }
  };
  y6.exports = I2;
});

// ../node_modules/prompts/lib/elements/autocomplete.js
var x6 = E((lrt, v6) => {
  "use strict";
  var lf = $t(), QQ = bn(), { erase: eee, cursor: g6 } = Wt(), { style: k2, clear: b6, figures: B2, wrap: tee, entriesToDisplay: ree } = cs(),
  D6 = /* @__PURE__ */ n((e, t) => e[t] && (e[t].value || e[t].title || e[t]), "getVal"), iee = /* @__PURE__ */ n((e, t) => e[t] && (e[t].title ||
  e[t].value || e[t]), "getTitle"), see = /* @__PURE__ */ n((e, t) => {
    let r = e.findIndex((i) => i.value === t || i.title === t);
    return r > -1 ? r : void 0;
  }, "getIndex"), N2 = class extends QQ {
    static {
      n(this, "AutocompletePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.suggest = t.suggest, this.choices = t.choices, this.initial = typeof t.initial == "number" ? t.initial :
      see(t.choices, t.initial), this.select = this.initial || t.cursor || 0, this.i18n = { noMatches: t.noMatches || "no matches found" }, this.
      fallback = t.fallback || this.initial, this.clearFirst = t.clearFirst || !1, this.suggestions = [], this.input = "", this.limit = t.limit ||
      10, this.cursor = 0, this.transform = k2.render(t.style), this.scale = this.transform.scale, this.render = this.render.bind(this), this.
      complete = this.complete.bind(this), this.clear = b6("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(t) {
      this._fb = Number.isSafeInteger(parseInt(t)) ? parseInt(t) : t;
    }
    get fallback() {
      let t;
      return typeof this._fb == "number" ? t = this.choices[this._fb] : typeof this._fb == "string" && (t = { title: this._fb }), t || this.
      _fb || { title: this.i18n.noMatches };
    }
    moveSelect(t) {
      this.select = t, this.suggestions.length > 0 ? this.value = D6(this.suggestions, t) : this.value = this.fallback.value, this.fire();
    }
    async complete(t) {
      let r = this.completing = this.suggest(this.input, this.choices), i = await r;
      if (this.completing !== r) return;
      this.suggestions = i.map((a, o, u) => ({ title: iee(u, o), value: D6(u, o), description: a.description })), this.completing = !1;
      let s = Math.max(i.length - 1, 0);
      this.moveSelect(Math.min(s, this.select)), t && t();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      let i = this.input.slice(0, this.cursor), s = this.input.slice(this.cursor);
      this.input = `${i}${t}${s}`, this.cursor = i.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let t = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${t}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let t = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${t}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(t, r, i, s) {
      let a, o = i ? B2.arrowUp : s ? B2.arrowDown : " ", u = r ? lf.cyan().underline(t.title) : t.title;
      return o = (r ? lf.cyan(B2.pointer) + " " : "  ") + o, t.description && (a = ` - ${t.description}`, (o.length + u.length + a.length >=
      this.out.columns || t.description.split(/\r?\n/).length > 1) && (a = `
` + tee(t.description, { margin: 3, width: this.out.columns }))), o + " " + u + lf.gray(a || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(g6.hide) : this.out.write(b6(this.outputText, this.out.columns)), super.render();
      let { startIndex: t, endIndex: r } = ree(this.select, this.choices.length, this.limit);
      if (this.outputText = [
        k2.symbol(this.done, this.aborted, this.exited),
        lf.bold(this.msg),
        k2.delimiter(this.completing),
        this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
      ].join(" "), !this.done) {
        let i = this.suggestions.slice(t, r).map((s, a) => this.renderOption(
          s,
          this.select === a + t,
          a === 0 && t > 0,
          a + t === r - 1 && r < this.choices.length
        )).join(`
`);
        this.outputText += `
` + (i || lf.gray(this.fallback.title));
      }
      this.out.write(eee.line + g6.to(0) + this.outputText);
    }
  };
  v6.exports = N2;
});

// ../node_modules/prompts/lib/elements/autocompleteMultiselect.js
var C6 = E((frt, T6) => {
  "use strict";
  var vn = $t(), { cursor: nee } = Wt(), aee = O2(), { clear: E6, style: S6, figures: Xu } = cs(), M2 = class extends aee {
    static {
      n(this, "AutocompleteMultiselectPrompt");
    }
    constructor(t = {}) {
      t.overrideRender = !0, super(t), this.inputValue = "", this.clear = E6("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let t = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((i) => this.inputValue ? !!(typeof i.title == "string" && i.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof i.value == "string" && i.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((i) => i === t);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let t = this.filteredOptions[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    handleInputChange(t) {
      this.inputValue = this.inputValue + t, this.updateFilteredOptions();
    }
    _(t, r) {
      t === " " ? this.handleSpaceToggle() : this.handleInputChange(t);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${Xu.arrowUp}/${Xu.arrowDown}: Highlight option
    ${Xu.arrowLeft}/${Xu.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : vn.gray("Enter something to filter")}
`;
    }
    renderOption(t, r, i) {
      let s;
      return r.disabled ? s = t === i ? vn.gray().underline(r.title) : vn.strikethrough().gray(r.title) : s = t === i ? vn.cyan().underline(
      r.title) : r.title, (r.selected ? vn.green(Xu.radioOn) : Xu.radioOff) + "  " + s;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [vn.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && t.push(vn.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(nee.hide), super.render();
      let t = [
        S6.symbol(this.done, this.aborted),
        vn.bold(this.msg),
        S6.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (t += vn.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + t), this.clear = E6(t, this.out.columns);
    }
  };
  T6.exports = M2;
});

// ../node_modules/prompts/lib/elements/confirm.js
var F6 = E((prt, P6) => {
  var w6 = $t(), oee = bn(), { style: A6, clear: uee } = cs(), { erase: lee, cursor: _6 } = Wt(), R2 = class extends oee {
    static {
      n(this, "ConfirmPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = t.initial, this.initialValue = !!t.initial, this.yesMsg = t.yes || "yes", this.yesOption =
      t.yesOption || "(Y/n)", this.noMsg = t.no || "no", this.noOption = t.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      return t.toLowerCase() === "y" ? (this.value = !0, this.submit()) : t.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(_6.hide) : this.out.write(uee(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        A6.symbol(this.done, this.aborted),
        w6.bold(this.msg),
        A6.delimiter(this.done),
        this.done ? this.value ? this.yesMsg : this.noMsg : w6.gray(this.initialValue ? this.yesOption : this.noOption)
      ].join(" "), this.out.write(lee.line + _6.to(0) + this.outputText));
    }
  };
  P6.exports = R2;
});

// ../node_modules/prompts/lib/elements/index.js
var O6 = E((mrt, I6) => {
  "use strict";
  I6.exports = {
    TextPrompt: PF(),
    SelectPrompt: kF(),
    TogglePrompt: RF(),
    DatePrompt: l6(),
    NumberPrompt: p6(),
    MultiselectPrompt: O2(),
    AutocompletePrompt: x6(),
    AutocompleteMultiselectPrompt: C6(),
    ConfirmPrompt: F6()
  };
});

// ../node_modules/prompts/lib/prompts.js
var B6 = E((k6) => {
  "use strict";
  var di = k6, cee = O6(), kh = /* @__PURE__ */ n((e) => e, "noop");
  function qs(e, t, r = {}) {
    return new Promise((i, s) => {
      let a = new cee[e](t), o = r.onAbort || kh, u = r.onSubmit || kh, l = r.onExit || kh;
      a.on("state", t.onState || kh), a.on("submit", (c) => i(u(c))), a.on("exit", (c) => i(l(c))), a.on("abort", (c) => s(o(c)));
    });
  }
  n(qs, "toPrompt");
  di.text = (e) => qs("TextPrompt", e);
  di.password = (e) => (e.style = "password", di.text(e));
  di.invisible = (e) => (e.style = "invisible", di.text(e));
  di.number = (e) => qs("NumberPrompt", e);
  di.date = (e) => qs("DatePrompt", e);
  di.confirm = (e) => qs("ConfirmPrompt", e);
  di.list = (e) => {
    let t = e.separator || ",";
    return qs("TextPrompt", e, {
      onSubmit: /* @__PURE__ */ n((r) => r.split(t).map((i) => i.trim()), "onSubmit")
    });
  };
  di.toggle = (e) => qs("TogglePrompt", e);
  di.select = (e) => qs("SelectPrompt", e);
  di.multiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ n((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return qs("MultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  di.autocompleteMultiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ n((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return qs("AutocompleteMultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  var fee = /* @__PURE__ */ n((e, t) => Promise.resolve(
    t.filter((r) => r.title.slice(0, e.length).toLowerCase() === e.toLowerCase())
  ), "byTitle");
  di.autocomplete = (e) => (e.suggest = e.suggest || fee, e.choices = [].concat(e.choices || []), qs("AutocompletePrompt", e));
});

// ../node_modules/prompts/lib/index.js
var R6 = E((brt, M6) => {
  "use strict";
  var L2 = B6(), dee = ["suggest", "format", "onState", "validate", "onRender", "type"], N6 = /* @__PURE__ */ n(() => {
  }, "noop");
  async function ha(e = [], { onSubmit: t = N6, onCancel: r = N6 } = {}) {
    let i = {}, s = ha._override || {};
    e = [].concat(e);
    let a, o, u, l, c, f, m = /* @__PURE__ */ n(async (h, d, y = !1) => {
      if (!(!y && h.validate && h.validate(d) !== !0))
        return h.format ? await h.format(d, i) : d;
    }, "getFormattedAnswer");
    for (o of e)
      if ({ name: l, type: c } = o, typeof c == "function" && (c = await c(a, { ...i }, o), o.type = c), !!c) {
        for (let h in o) {
          if (dee.includes(h)) continue;
          let d = o[h];
          o[h] = typeof d == "function" ? await d(a, { ...i }, f) : d;
        }
        if (f = o, typeof o.message != "string")
          throw new Error("prompt message is required");
        if ({ name: l, type: c } = o, L2[c] === void 0)
          throw new Error(`prompt type (${c}) is not defined`);
        if (s[o.name] !== void 0 && (a = await m(o, s[o.name]), a !== void 0)) {
          i[l] = a;
          continue;
        }
        try {
          a = ha._injected ? pee(ha._injected, o.initial) : await L2[c](o), i[l] = a = await m(o, a, !0), u = await t(o, a, i);
        } catch {
          u = !await r(o, i);
        }
        if (u) return i;
      }
    return i;
  }
  n(ha, "prompt");
  function pee(e, t) {
    let r = e.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? t : r;
  }
  n(pee, "getInjectedAnswer");
  function hee(e) {
    ha._injected = (ha._injected || []).concat(e);
  }
  n(hee, "inject");
  function mee(e) {
    ha._override = Object.assign({}, e);
  }
  n(mee, "override");
  M6.exports = Object.assign(ha, { prompt: ha, prompts: L2, inject: hee, override: mee });
});

// ../node_modules/prompts/index.js
var j2 = E((vrt, L6) => {
  function yee(e) {
    e = (Array.isArray(e) ? e : e.split(".")).map(Number);
    let t = 0, r = process.versions.node.split(".").map(Number);
    for (; t < e.length; t++) {
      if (r[t] > e[t]) return !1;
      if (e[t] > r[t]) return !0;
    }
    return !1;
  }
  n(yee, "isNodeLT");
  L6.exports = yee("8.6.0") ? lF() : R6();
});

// ../node_modules/picocolors/picocolors.js
var Mh = E((Ert, q2) => {
  var Nh = process || {}, j6 = Nh.argv || [], Bh = Nh.env || {}, gee = !(Bh.NO_COLOR || j6.includes("--no-color")) && (!!Bh.FORCE_COLOR || j6.
  includes("--color") || Nh.platform === "win32" || (Nh.stdout || {}).isTTY && Bh.TERM !== "dumb" || !!Bh.CI), bee = /* @__PURE__ */ n((e, t, r = e) => (i) => {
    let s = "" + i, a = s.indexOf(t, e.length);
    return ~a ? e + Dee(s, t, r, a) + t : e + s + t;
  }, "formatter"), Dee = /* @__PURE__ */ n((e, t, r, i) => {
    let s = "", a = 0;
    do
      s += e.substring(a, i) + r, a = i + t.length, i = e.indexOf(t, a);
    while (~i);
    return s + e.substring(a);
  }, "replaceClose"), q6 = /* @__PURE__ */ n((e = gee) => {
    let t = e ? bee : () => String;
    return {
      isColorSupported: e,
      reset: t("\x1B[0m", "\x1B[0m"),
      bold: t("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: t("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: t("\x1B[3m", "\x1B[23m"),
      underline: t("\x1B[4m", "\x1B[24m"),
      inverse: t("\x1B[7m", "\x1B[27m"),
      hidden: t("\x1B[8m", "\x1B[28m"),
      strikethrough: t("\x1B[9m", "\x1B[29m"),
      black: t("\x1B[30m", "\x1B[39m"),
      red: t("\x1B[31m", "\x1B[39m"),
      green: t("\x1B[32m", "\x1B[39m"),
      yellow: t("\x1B[33m", "\x1B[39m"),
      blue: t("\x1B[34m", "\x1B[39m"),
      magenta: t("\x1B[35m", "\x1B[39m"),
      cyan: t("\x1B[36m", "\x1B[39m"),
      white: t("\x1B[37m", "\x1B[39m"),
      gray: t("\x1B[90m", "\x1B[39m"),
      bgBlack: t("\x1B[40m", "\x1B[49m"),
      bgRed: t("\x1B[41m", "\x1B[49m"),
      bgGreen: t("\x1B[42m", "\x1B[49m"),
      bgYellow: t("\x1B[43m", "\x1B[49m"),
      bgBlue: t("\x1B[44m", "\x1B[49m"),
      bgMagenta: t("\x1B[45m", "\x1B[49m"),
      bgCyan: t("\x1B[46m", "\x1B[49m"),
      bgWhite: t("\x1B[47m", "\x1B[49m"),
      blackBright: t("\x1B[90m", "\x1B[39m"),
      redBright: t("\x1B[91m", "\x1B[39m"),
      greenBright: t("\x1B[92m", "\x1B[39m"),
      yellowBright: t("\x1B[93m", "\x1B[39m"),
      blueBright: t("\x1B[94m", "\x1B[39m"),
      magentaBright: t("\x1B[95m", "\x1B[39m"),
      cyanBright: t("\x1B[96m", "\x1B[39m"),
      whiteBright: t("\x1B[97m", "\x1B[39m"),
      bgBlackBright: t("\x1B[100m", "\x1B[49m"),
      bgRedBright: t("\x1B[101m", "\x1B[49m"),
      bgGreenBright: t("\x1B[102m", "\x1B[49m"),
      bgYellowBright: t("\x1B[103m", "\x1B[49m"),
      bgBlueBright: t("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: t("\x1B[105m", "\x1B[49m"),
      bgCyanBright: t("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: t("\x1B[107m", "\x1B[49m")
    };
  }, "createColors");
  q2.exports = q6();
  q2.exports.createColors = q6;
});

// ../node_modules/wrappy/wrappy.js
var W6 = E((_rt, V6) => {
  V6.exports = $6;
  function $6(e, t) {
    if (e && t) return $6(e)(t);
    if (typeof e != "function")
      throw new TypeError("need wrapper function");
    return Object.keys(e).forEach(function(i) {
      r[i] = e[i];
    }), r;
    function r() {
      for (var i = new Array(arguments.length), s = 0; s < i.length; s++)
        i[s] = arguments[s];
      var a = e.apply(this, i), o = i[i.length - 1];
      return typeof a == "function" && a !== o && Object.keys(o).forEach(function(u) {
        a[u] = o[u];
      }), a;
    }
    n(r, "wrapper");
  }
  n($6, "wrappy");
});

// ../node_modules/once/once.js
var Lh = E((Frt, W2) => {
  var H6 = W6();
  W2.exports = H6(Rh);
  W2.exports.strict = H6(K6);
  Rh.proto = Rh(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: /* @__PURE__ */ n(function() {
        return Rh(this);
      }, "value"),
      configurable: !0
    }), Object.defineProperty(Function.prototype, "onceStrict", {
      value: /* @__PURE__ */ n(function() {
        return K6(this);
      }, "value"),
      configurable: !0
    });
  });
  function Rh(e) {
    var t = /* @__PURE__ */ n(function() {
      return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments));
    }, "f");
    return t.called = !1, t;
  }
  n(Rh, "once");
  function K6(e) {
    var t = /* @__PURE__ */ n(function() {
      if (t.called)
        throw new Error(t.onceError);
      return t.called = !0, t.value = e.apply(this, arguments);
    }, "f"), r = e.name || "Function wrapped with `once`";
    return t.onceError = r + " shouldn't be called more than once", t.called = !1, t;
  }
  n(K6, "onceStrict");
});

// ../node_modules/end-of-stream/index.js
var Yu = E((Ort, J6) => {
  var Tee = Lh(), Cee = /* @__PURE__ */ n(function() {
  }, "noop"), wee = /* @__PURE__ */ n(function(e) {
    return e.setHeader && typeof e.abort == "function";
  }, "isRequest"), Aee = /* @__PURE__ */ n(function(e) {
    return e.stdio && Array.isArray(e.stdio) && e.stdio.length === 3;
  }, "isChildProcess"), z6 = /* @__PURE__ */ n(function(e, t, r) {
    if (typeof t == "function") return z6(e, null, t);
    t || (t = {}), r = Tee(r || Cee);
    var i = e._writableState, s = e._readableState, a = t.readable || t.readable !== !1 && e.readable, o = t.writable || t.writable !== !1 &&
    e.writable, u = !1, l = /* @__PURE__ */ n(function() {
      e.writable || c();
    }, "onlegacyfinish"), c = /* @__PURE__ */ n(function() {
      o = !1, a || r.call(e);
    }, "onfinish"), f = /* @__PURE__ */ n(function() {
      a = !1, o || r.call(e);
    }, "onend"), m = /* @__PURE__ */ n(function(g) {
      r.call(e, g ? new Error("exited with error code: " + g) : null);
    }, "onexit"), h = /* @__PURE__ */ n(function(g) {
      r.call(e, g);
    }, "onerror"), d = /* @__PURE__ */ n(function() {
      process.nextTick(y);
    }, "onclose"), y = /* @__PURE__ */ n(function() {
      if (!u) {
        if (a && !(s && s.ended && !s.destroyed)) return r.call(e, new Error("premature close"));
        if (o && !(i && i.ended && !i.destroyed)) return r.call(e, new Error("premature close"));
      }
    }, "onclosenexttick"), p = /* @__PURE__ */ n(function() {
      e.req.on("finish", c);
    }, "onrequest");
    return wee(e) ? (e.on("complete", c), e.on("abort", d), e.req ? p() : e.on("request", p)) : o && !i && (e.on("end", l), e.on("close", l)),
    Aee(e) && e.on("exit", m), e.on("end", f), e.on("finish", c), t.error !== !1 && e.on("error", h), e.on("close", d), function() {
      u = !0, e.removeListener("complete", c), e.removeListener("abort", d), e.removeListener("request", p), e.req && e.req.removeListener("\
finish", c), e.removeListener("end", l), e.removeListener("close", l), e.removeListener("finish", c), e.removeListener("exit", m), e.removeListener(
      "end", f), e.removeListener("error", h), e.removeListener("close", d);
    };
  }, "eos");
  J6.exports = z6;
});

// ../node_modules/pump/index.js
var H2 = E((Brt, Y6) => {
  var _ee = Lh(), Pee = Yu(), jh;
  try {
    jh = require("fs");
  } catch {
  }
  var ff = /* @__PURE__ */ n(function() {
  }, "noop"), Fee = /^v?\.0/.test(process.version), qh = /* @__PURE__ */ n(function(e) {
    return typeof e == "function";
  }, "isFn"), Iee = /* @__PURE__ */ n(function(e) {
    return !Fee || !jh ? !1 : (e instanceof (jh.ReadStream || ff) || e instanceof (jh.WriteStream || ff)) && qh(e.close);
  }, "isFS"), Oee = /* @__PURE__ */ n(function(e) {
    return e.setHeader && qh(e.abort);
  }, "isRequest"), kee = /* @__PURE__ */ n(function(e, t, r, i) {
    i = _ee(i);
    var s = !1;
    e.on("close", function() {
      s = !0;
    }), Pee(e, { readable: t, writable: r }, function(o) {
      if (o) return i(o);
      s = !0, i();
    });
    var a = !1;
    return function(o) {
      if (!s && !a) {
        if (a = !0, Iee(e)) return e.close(ff);
        if (Oee(e)) return e.abort();
        if (qh(e.destroy)) return e.destroy();
        i(o || new Error("stream was destroyed"));
      }
    };
  }, "destroyer"), X6 = /* @__PURE__ */ n(function(e) {
    e();
  }, "call"), Bee = /* @__PURE__ */ n(function(e, t) {
    return e.pipe(t);
  }, "pipe"), Nee = /* @__PURE__ */ n(function() {
    var e = Array.prototype.slice.call(arguments), t = qh(e[e.length - 1] || ff) && e.pop() || ff;
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new Error("pump requires two streams per minimum");
    var r, i = e.map(function(s, a) {
      var o = a < e.length - 1, u = a > 0;
      return kee(s, o, u, function(l) {
        r || (r = l), l && i.forEach(X6), !o && (i.forEach(X6), t(r));
      });
    });
    return e.reduce(Bee);
  }, "pump");
  Y6.exports = Nee;
});

// ../node_modules/tar-fs/node_modules/chownr/chownr.js
var iI = E((Mrt, rI) => {
  "use strict";
  var Ri = require("fs"), mo = require("path"), Mee = Ri.lchown ? "lchown" : "chown", Ree = Ri.lchownSync ? "lchownSync" : "chownSync", Z6 = Ri.
  lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/), G6 = /* @__PURE__ */ n((e, t, r) => {
    try {
      return Ri[Ree](e, t, r);
    } catch (i) {
      if (i.code !== "ENOENT")
        throw i;
    }
  }, "lchownSync"), Lee = /* @__PURE__ */ n((e, t, r) => {
    try {
      return Ri.chownSync(e, t, r);
    } catch (i) {
      if (i.code !== "ENOENT")
        throw i;
    }
  }, "chownSync"), jee = Z6 ? (e, t, r, i) => (s) => {
    !s || s.code !== "EISDIR" ? i(s) : Ri.chown(e, t, r, i);
  } : (e, t, r, i) => i, K2 = Z6 ? (e, t, r) => {
    try {
      return G6(e, t, r);
    } catch (i) {
      if (i.code !== "EISDIR")
        throw i;
      Lee(e, t, r);
    }
  } : (e, t, r) => G6(e, t, r), qee = process.version, Q6 = /* @__PURE__ */ n((e, t, r) => Ri.readdir(e, t, r), "readdir"), Uee = /* @__PURE__ */ n(
  (e, t) => Ri.readdirSync(e, t), "readdirSync");
  /^v4\./.test(qee) && (Q6 = /* @__PURE__ */ n((e, t, r) => Ri.readdir(e, r), "readdir"));
  var Uh = /* @__PURE__ */ n((e, t, r, i) => {
    Ri[Mee](e, t, r, jee(e, t, r, (s) => {
      i(s && s.code !== "ENOENT" ? s : null);
    }));
  }, "chown"), eI = /* @__PURE__ */ n((e, t, r, i, s) => {
    if (typeof t == "string")
      return Ri.lstat(mo.resolve(e, t), (a, o) => {
        if (a)
          return s(a.code !== "ENOENT" ? a : null);
        o.name = t, eI(e, o, r, i, s);
      });
    if (t.isDirectory())
      z2(mo.resolve(e, t.name), r, i, (a) => {
        if (a)
          return s(a);
        let o = mo.resolve(e, t.name);
        Uh(o, r, i, s);
      });
    else {
      let a = mo.resolve(e, t.name);
      Uh(a, r, i, s);
    }
  }, "chownrKid"), z2 = /* @__PURE__ */ n((e, t, r, i) => {
    Q6(e, { withFileTypes: !0 }, (s, a) => {
      if (s) {
        if (s.code === "ENOENT")
          return i();
        if (s.code !== "ENOTDIR" && s.code !== "ENOTSUP")
          return i(s);
      }
      if (s || !a.length)
        return Uh(e, t, r, i);
      let o = a.length, u = null, l = /* @__PURE__ */ n((c) => {
        if (!u) {
          if (c)
            return i(u = c);
          if (--o === 0)
            return Uh(e, t, r, i);
        }
      }, "then");
      a.forEach((c) => eI(e, c, t, r, l));
    });
  }, "chownr"), $ee = /* @__PURE__ */ n((e, t, r, i) => {
    if (typeof t == "string")
      try {
        let s = Ri.lstatSync(mo.resolve(e, t));
        s.name = t, t = s;
      } catch (s) {
        if (s.code === "ENOENT")
          return;
        throw s;
      }
    t.isDirectory() && tI(mo.resolve(e, t.name), r, i), K2(mo.resolve(e, t.name), r, i);
  }, "chownrKidSync"), tI = /* @__PURE__ */ n((e, t, r) => {
    let i;
    try {
      i = Uee(e, { withFileTypes: !0 });
    } catch (s) {
      if (s.code === "ENOENT")
        return;
      if (s.code === "ENOTDIR" || s.code === "ENOTSUP")
        return K2(e, t, r);
      throw s;
    }
    return i && i.length && i.forEach((s) => $ee(e, s, t, r)), K2(e, t, r);
  }, "chownrSync");
  rI.exports = z2;
  z2.sync = tI;
});

// ../node_modules/readable-stream/lib/internal/streams/stream.js
var J2 = E((Lrt, sI) => {
  sI.exports = require("stream");
});

// ../node_modules/readable-stream/lib/internal/streams/buffer_list.js
var cI = E((jrt, lI) => {
  "use strict";
  function nI(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      t && (i = i.filter(function(s) {
        return Object.getOwnPropertyDescriptor(e, s).enumerable;
      })), r.push.apply(r, i);
    }
    return r;
  }
  n(nI, "ownKeys");
  function aI(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2 ? nI(Object(r), !0).forEach(function(i) {
        Vee(e, i, r[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : nI(Object(r)).forEach(function(i) {
        Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
      });
    }
    return e;
  }
  n(aI, "_objectSpread");
  function Vee(e, t, r) {
    return t = uI(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
  }
  n(Vee, "_defineProperty");
  function Wee(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  n(Wee, "_classCallCheck");
  function oI(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, uI(i.key), i);
    }
  }
  n(oI, "_defineProperties");
  function Hee(e, t, r) {
    return t && oI(e.prototype, t), r && oI(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
  }
  n(Hee, "_createClass");
  function uI(e) {
    var t = Kee(e, "string");
    return typeof t == "symbol" ? t : String(t);
  }
  n(uI, "_toPropertyKey");
  function Kee(e, t) {
    if (typeof e != "object" || e === null) return e;
    var r = e[Symbol.toPrimitive];
    if (r !== void 0) {
      var i = r.call(e, t || "default");
      if (typeof i != "object") return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  n(Kee, "_toPrimitive");
  var zee = require("buffer"), $h = zee.Buffer, Jee = require("util"), X2 = Jee.inspect, Xee = X2 && X2.custom || "inspect";
  function Yee(e, t, r) {
    $h.prototype.copy.call(e, t, r);
  }
  n(Yee, "copyBuffer");
  lI.exports = /* @__PURE__ */ function() {
    function e() {
      Wee(this, e), this.head = null, this.tail = null, this.length = 0;
    }
    return n(e, "BufferList"), Hee(e, [{
      key: "push",
      value: /* @__PURE__ */ n(function(r) {
        var i = {
          data: r,
          next: null
        };
        this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
      }, "push")
    }, {
      key: "unshift",
      value: /* @__PURE__ */ n(function(r) {
        var i = {
          data: r,
          next: this.head
        };
        this.length === 0 && (this.tail = i), this.head = i, ++this.length;
      }, "unshift")
    }, {
      key: "shift",
      value: /* @__PURE__ */ n(function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      }, "shift")
    }, {
      key: "clear",
      value: /* @__PURE__ */ n(function() {
        this.head = this.tail = null, this.length = 0;
      }, "clear")
    }, {
      key: "join",
      value: /* @__PURE__ */ n(function(r) {
        if (this.length === 0) return "";
        for (var i = this.head, s = "" + i.data; i = i.next; ) s += r + i.data;
        return s;
      }, "join")
    }, {
      key: "concat",
      value: /* @__PURE__ */ n(function(r) {
        if (this.length === 0) return $h.alloc(0);
        for (var i = $h.allocUnsafe(r >>> 0), s = this.head, a = 0; s; )
          Yee(s.data, i, a), a += s.data.length, s = s.next;
        return i;
      }, "concat")
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: /* @__PURE__ */ n(function(r, i) {
        var s;
        return r < this.head.data.length ? (s = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.
        length ? s = this.shift() : s = i ? this._getString(r) : this._getBuffer(r), s;
      }, "consume")
    }, {
      key: "first",
      value: /* @__PURE__ */ n(function() {
        return this.head.data;
      }, "first")
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: /* @__PURE__ */ n(function(r) {
        var i = this.head, s = 1, a = i.data;
        for (r -= a.length; i = i.next; ) {
          var o = i.data, u = r > o.length ? o.length : r;
          if (u === o.length ? a += o : a += o.slice(0, r), r -= u, r === 0) {
            u === o.length ? (++s, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = o.slice(u));
            break;
          }
          ++s;
        }
        return this.length -= s, a;
      }, "_getString")
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: /* @__PURE__ */ n(function(r) {
        var i = $h.allocUnsafe(r), s = this.head, a = 1;
        for (s.data.copy(i), r -= s.data.length; s = s.next; ) {
          var o = s.data, u = r > o.length ? o.length : r;
          if (o.copy(i, i.length - r, 0, u), r -= u, r === 0) {
            u === o.length ? (++a, s.next ? this.head = s.next : this.head = this.tail = null) : (this.head = s, s.data = o.slice(u));
            break;
          }
          ++a;
        }
        return this.length -= a, i;
      }, "_getBuffer")
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Xee,
      value: /* @__PURE__ */ n(function(r, i) {
        return X2(this, aI(aI({}, i), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }, "value")
    }]), e;
  }();
});

// ../node_modules/readable-stream/lib/internal/streams/destroy.js
var G2 = E((Urt, dI) => {
  "use strict";
  function Gee(e, t) {
    var r = this, i = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return i || s ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.
    nextTick(Y2, this, e)) : process.nextTick(Y2, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState &&
    (this._writableState.destroyed = !0), this._destroy(e || null, function(a) {
      !t && a ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Vh, r) : (r._writableState.errorEmitted = !0, process.nextTick(
      fI, r, a)) : process.nextTick(fI, r, a) : t ? (process.nextTick(Vh, r), t(a)) : process.nextTick(Vh, r);
    }), this);
  }
  n(Gee, "destroy");
  function fI(e, t) {
    Y2(e, t), Vh(e);
  }
  n(fI, "emitErrorAndCloseNT");
  function Vh(e) {
    e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
  }
  n(Vh, "emitCloseNT");
  function Zee() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.
    endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending =
    !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted =
    !1);
  }
  n(Zee, "undestroy");
  function Y2(e, t) {
    e.emit("error", t);
  }
  n(Y2, "emitErrorNT");
  function Qee(e, t) {
    var r = e._readableState, i = e._writableState;
    r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
  }
  n(Qee, "errorOrDestroy");
  dI.exports = {
    destroy: Gee,
    undestroy: Zee,
    errorOrDestroy: Qee
  };
});

// ../node_modules/readable-stream/errors.js
var ma = E((Vrt, mI) => {
  "use strict";
  var hI = {};
  function Li(e, t, r) {
    r || (r = Error);
    function i(a, o, u) {
      return typeof t == "string" ? t : t(a, o, u);
    }
    n(i, "getMessage");
    class s extends r {
      static {
        n(this, "NodeError");
      }
      constructor(o, u, l) {
        super(i(o, u, l));
      }
    }
    s.prototype.name = r.name, s.prototype.code = e, hI[e] = s;
  }
  n(Li, "createErrorType");
  function pI(e, t) {
    if (Array.isArray(e)) {
      let r = e.length;
      return e = e.map((i) => String(i)), r > 2 ? `one of ${t} ${e.slice(0, r - 1).join(", ")}, or ` + e[r - 1] : r === 2 ? `one of ${t} ${e[0]}\
 or ${e[1]}` : `of ${t} ${e[0]}`;
    } else
      return `of ${t} ${String(e)}`;
  }
  n(pI, "oneOf");
  function ete(e, t, r) {
    return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
  }
  n(ete, "startsWith");
  function tte(e, t, r) {
    return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
  }
  n(tte, "endsWith");
  function rte(e, t, r) {
    return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
  }
  n(rte, "includes");
  Li("ERR_INVALID_OPT_VALUE", function(e, t) {
    return 'The value "' + t + '" is invalid for option "' + e + '"';
  }, TypeError);
  Li("ERR_INVALID_ARG_TYPE", function(e, t, r) {
    let i;
    typeof t == "string" && ete(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
    let s;
    if (tte(e, " argument"))
      s = `The ${e} ${i} ${pI(t, "type")}`;
    else {
      let a = rte(e, ".") ? "property" : "argument";
      s = `The "${e}" ${a} ${i} ${pI(t, "type")}`;
    }
    return s += `. Received type ${typeof r}`, s;
  }, TypeError);
  Li("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  Li("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
    return "The " + e + " method is not implemented";
  });
  Li("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  Li("ERR_STREAM_DESTROYED", function(e) {
    return "Cannot call " + e + " after a stream was destroyed";
  });
  Li("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  Li("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  Li("ERR_STREAM_WRITE_AFTER_END", "write after end");
  Li("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  Li("ERR_UNKNOWN_ENCODING", function(e) {
    return "Unknown encoding: " + e;
  }, TypeError);
  Li("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  mI.exports.codes = hI;
});

// ../node_modules/readable-stream/lib/internal/streams/state.js
var Z2 = E((Hrt, yI) => {
  "use strict";
  var ite = ma().codes.ERR_INVALID_OPT_VALUE;
  function ste(e, t, r) {
    return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
  }
  n(ste, "highWaterMarkFrom");
  function nte(e, t, r, i) {
    var s = ste(t, i, r);
    if (s != null) {
      if (!(isFinite(s) && Math.floor(s) === s) || s < 0) {
        var a = i ? r : "highWaterMark";
        throw new ite(a, s);
      }
      return Math.floor(s);
    }
    return e.objectMode ? 16 : 16 * 1024;
  }
  n(nte, "getHighWaterMark");
  yI.exports = {
    getHighWaterMark: nte
  };
});

// ../node_modules/inherits/inherits_browser.js
var gI = E((zrt, Q2) => {
  typeof Object.create == "function" ? Q2.exports = /* @__PURE__ */ n(function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  }, "inherits") : Q2.exports = /* @__PURE__ */ n(function(t, r) {
    if (r) {
      t.super_ = r;
      var i = /* @__PURE__ */ n(function() {
      }, "TempCtor");
      i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
    }
  }, "inherits");
});

// ../node_modules/inherits/inherits.js
var St = E((Xrt, tD) => {
  try {
    if (eD = require("util"), typeof eD.inherits != "function") throw "";
    tD.exports = eD.inherits;
  } catch {
    tD.exports = gI();
  }
  var eD;
});

// ../node_modules/util-deprecate/node.js
var df = E((Yrt, bI) => {
  bI.exports = require("util").deprecate;
});

// ../node_modules/readable-stream/lib/_stream_writable.js
var sD = E((Grt, TI) => {
  "use strict";
  TI.exports = zt;
  function vI(e) {
    var t = this;
    this.next = null, this.entry = null, this.finish = function() {
      Ote(t, e);
    };
  }
  n(vI, "CorkedRequest");
  var Gu;
  zt.WritableState = hf;
  var ate = {
    deprecate: df()
  }, xI = J2(), Hh = require("buffer").Buffer, ote = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self :
  {}).Uint8Array || function() {
  };
  function ute(e) {
    return Hh.from(e);
  }
  n(ute, "_uint8ArrayToBuffer");
  function lte(e) {
    return Hh.isBuffer(e) || e instanceof ote;
  }
  n(lte, "_isUint8Array");
  var iD = G2(), cte = Z2(), fte = cte.getHighWaterMark, ya = ma().codes, dte = ya.ERR_INVALID_ARG_TYPE, pte = ya.ERR_METHOD_NOT_IMPLEMENTED,
  hte = ya.ERR_MULTIPLE_CALLBACK, mte = ya.ERR_STREAM_CANNOT_PIPE, yte = ya.ERR_STREAM_DESTROYED, gte = ya.ERR_STREAM_NULL_VALUES, bte = ya.
  ERR_STREAM_WRITE_AFTER_END, Dte = ya.ERR_UNKNOWN_ENCODING, Zu = iD.errorOrDestroy;
  St()(zt, xI);
  function vte() {
  }
  n(vte, "nop");
  function hf(e, t, r) {
    Gu = Gu || yo(), e = e || {}, typeof r != "boolean" && (r = t instanceof Gu), this.objectMode = !!e.objectMode, r && (this.objectMode = this.
    objectMode || !!e.writableObjectMode), this.highWaterMark = fte(this, e, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain =
    !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var i = e.decodeStrings === !1;
    this.decodeStrings = !i, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync =
    !0, this.bufferProcessing = !1, this.onwrite = function(s) {
      Ate(t, s);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished =
    !1, this.errorEmitted = !1, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.
    corkedRequestsFree = new vI(this);
  }
  n(hf, "WritableState");
  hf.prototype.getBuffer = /* @__PURE__ */ n(function() {
    for (var t = this.bufferedRequest, r = []; t; )
      r.push(t), t = t.next;
    return r;
  }, "getBuffer");
  (function() {
    try {
      Object.defineProperty(hf.prototype, "buffer", {
        get: ate.deprecate(/* @__PURE__ */ n(function() {
          return this.getBuffer();
        }, "writableStateBufferGetter"), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var Wh;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Wh = Function.prototype[Symbol.
  hasInstance], Object.defineProperty(zt, Symbol.hasInstance, {
    value: /* @__PURE__ */ n(function(t) {
      return Wh.call(this, t) ? !0 : this !== zt ? !1 : t && t._writableState instanceof hf;
    }, "value")
  })) : Wh = /* @__PURE__ */ n(function(t) {
    return t instanceof this;
  }, "realHasInstance");
  function zt(e) {
    Gu = Gu || yo();
    var t = this instanceof Gu;
    if (!t && !Wh.call(zt, this)) return new zt(e);
    this._writableState = new hf(e, this, t), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev ==
    "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this.
    _final = e.final)), xI.call(this);
  }
  n(zt, "Writable");
  zt.prototype.pipe = function() {
    Zu(this, new mte());
  };
  function xte(e, t) {
    var r = new bte();
    Zu(e, r), process.nextTick(t, r);
  }
  n(xte, "writeAfterEnd");
  function Ete(e, t, r, i) {
    var s;
    return r === null ? s = new gte() : typeof r != "string" && !t.objectMode && (s = new dte("chunk", ["string", "Buffer"], r)), s ? (Zu(e,
    s), process.nextTick(i, s), !1) : !0;
  }
  n(Ete, "validChunk");
  zt.prototype.write = function(e, t, r) {
    var i = this._writableState, s = !1, a = !i.objectMode && lte(e);
    return a && !Hh.isBuffer(e) && (e = ute(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding),
    typeof r != "function" && (r = vte), i.ending ? xte(this, r) : (a || Ete(this, i, e, r)) && (i.pendingcb++, s = Tte(this, i, a, e, t, r)),
    s;
  };
  zt.prototype.cork = function() {
    this._writableState.corked++;
  };
  zt.prototype.uncork = function() {
    var e = this._writableState;
    e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && EI(this, e));
  };
  zt.prototype.setDefaultEncoding = /* @__PURE__ */ n(function(t) {
    if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "\
utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new Dte(t);
    return this._writableState.defaultEncoding = t, this;
  }, "setDefaultEncoding");
  Object.defineProperty(zt.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState && this._writableState.getBuffer();
    }, "get")
  });
  function Ste(e, t, r) {
    return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = Hh.from(t, r)), t;
  }
  n(Ste, "decodeChunk");
  Object.defineProperty(zt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function Tte(e, t, r, i, s, a) {
    if (!r) {
      var o = Ste(t, i, s);
      i !== o && (r = !0, s = "buffer", i = o);
    }
    var u = t.objectMode ? 1 : i.length;
    t.length += u;
    var l = t.length < t.highWaterMark;
    if (l || (t.needDrain = !0), t.writing || t.corked) {
      var c = t.lastBufferedRequest;
      t.lastBufferedRequest = {
        chunk: i,
        encoding: s,
        isBuf: r,
        callback: a,
        next: null
      }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
    } else
      rD(e, t, !1, u, i, s, a);
    return l;
  }
  n(Tte, "writeOrBuffer");
  function rD(e, t, r, i, s, a, o) {
    t.writelen = i, t.writecb = o, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new yte("write")) : r ? e._writev(s, t.onwrite) : e.
    _write(s, a, t.onwrite), t.sync = !1;
  }
  n(rD, "doWrite");
  function Cte(e, t, r, i, s) {
    --t.pendingcb, r ? (process.nextTick(s, i), process.nextTick(pf, e, t), e._writableState.errorEmitted = !0, Zu(e, i)) : (s(i), e._writableState.
    errorEmitted = !0, Zu(e, i), pf(e, t));
  }
  n(Cte, "onwriteError");
  function wte(e) {
    e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
  }
  n(wte, "onwriteStateUpdate");
  function Ate(e, t) {
    var r = e._writableState, i = r.sync, s = r.writecb;
    if (typeof s != "function") throw new hte();
    if (wte(r), t) Cte(e, r, i, t, s);
    else {
      var a = SI(r) || e.destroyed;
      !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && EI(e, r), i ? process.nextTick(DI, e, r, a, s) : DI(e, r, a, s);
    }
  }
  n(Ate, "onwrite");
  function DI(e, t, r, i) {
    r || _te(e, t), t.pendingcb--, i(), pf(e, t);
  }
  n(DI, "afterWrite");
  function _te(e, t) {
    t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
  }
  n(_te, "onwriteDrain");
  function EI(e, t) {
    t.bufferProcessing = !0;
    var r = t.bufferedRequest;
    if (e._writev && r && r.next) {
      var i = t.bufferedRequestCount, s = new Array(i), a = t.corkedRequestsFree;
      a.entry = r;
      for (var o = 0, u = !0; r; )
        s[o] = r, r.isBuf || (u = !1), r = r.next, o += 1;
      s.allBuffers = u, rD(e, t, !0, t.length, s, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree =
      a.next, a.next = null) : t.corkedRequestsFree = new vI(t), t.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var l = r.chunk, c = r.encoding, f = r.callback, m = t.objectMode ? 1 : l.length;
        if (rD(e, t, !1, m, l, c, f), r = r.next, t.bufferedRequestCount--, t.writing)
          break;
      }
      r === null && (t.lastBufferedRequest = null);
    }
    t.bufferedRequest = r, t.bufferProcessing = !1;
  }
  n(EI, "clearBuffer");
  zt.prototype._write = function(e, t, r) {
    r(new pte("_write()"));
  };
  zt.prototype._writev = null;
  zt.prototype.end = function(e, t, r) {
    var i = this._writableState;
    return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t),
    i.corked && (i.corked = 1, this.uncork()), i.ending || Ite(this, i, r), this;
  };
  Object.defineProperty(zt.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.length;
    }, "get")
  });
  function SI(e) {
    return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
  }
  n(SI, "needFinish");
  function Pte(e, t) {
    e._final(function(r) {
      t.pendingcb--, r && Zu(e, r), t.prefinished = !0, e.emit("prefinish"), pf(e, t);
    });
  }
  n(Pte, "callFinal");
  function Fte(e, t) {
    !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = !0, process.nextTick(
    Pte, e, t)) : (t.prefinished = !0, e.emit("prefinish")));
  }
  n(Fte, "prefinish");
  function pf(e, t) {
    var r = SI(t);
    if (r && (Fte(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
      var i = e._readableState;
      (!i || i.autoDestroy && i.endEmitted) && e.destroy();
    }
    return r;
  }
  n(pf, "finishMaybe");
  function Ite(e, t, r) {
    t.ending = !0, pf(e, t), r && (t.finished ? process.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
  }
  n(Ite, "endWritable");
  function Ote(e, t, r) {
    var i = e.entry;
    for (e.entry = null; i; ) {
      var s = i.callback;
      t.pendingcb--, s(r), i = i.next;
    }
    t.corkedRequestsFree.next = e;
  }
  n(Ote, "onCorkedFinish");
  Object.defineProperty(zt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(t) {
      this._writableState && (this._writableState.destroyed = t);
    }, "set")
  });
  zt.prototype.destroy = iD.destroy;
  zt.prototype._undestroy = iD.undestroy;
  zt.prototype._destroy = function(e, t) {
    t(e);
  };
});

// ../node_modules/readable-stream/lib/_stream_duplex.js
var yo = E((Qrt, wI) => {
  "use strict";
  var kte = Object.keys || function(e) {
    var t = [];
    for (var r in e) t.push(r);
    return t;
  };
  wI.exports = Us;
  var CI = oD(), aD = sD();
  St()(Us, CI);
  for (nD = kte(aD.prototype), Kh = 0; Kh < nD.length; Kh++)
    zh = nD[Kh], Us.prototype[zh] || (Us.prototype[zh] = aD.prototype[zh]);
  var nD, zh, Kh;
  function Us(e) {
    if (!(this instanceof Us)) return new Us(e);
    CI.call(this, e), aD.call(this, e), this.allowHalfOpen = !0, e && (e.readable === !1 && (this.readable = !1), e.writable === !1 && (this.
    writable = !1), e.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", Bte)));
  }
  n(Us, "Duplex");
  Object.defineProperty(Us.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  Object.defineProperty(Us.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState && this._writableState.getBuffer();
    }, "get")
  });
  Object.defineProperty(Us.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.length;
    }, "get")
  });
  function Bte() {
    this._writableState.ended || process.nextTick(Nte, this);
  }
  n(Bte, "onend");
  function Nte(e) {
    e.end();
  }
  n(Nte, "onEndNT");
  Object.defineProperty(Us.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(t) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t, this._writableState.destroyed =
      t);
    }, "set")
  });
});

// ../node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var Jh = E((tit, PI) => {
  "use strict";
  var AI = ma().codes.ERR_STREAM_PREMATURE_CLOSE;
  function Mte(e) {
    var t = !1;
    return function() {
      if (!t) {
        t = !0;
        for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++)
          i[s] = arguments[s];
        e.apply(this, i);
      }
    };
  }
  n(Mte, "once");
  function Rte() {
  }
  n(Rte, "noop");
  function Lte(e) {
    return e.setHeader && typeof e.abort == "function";
  }
  n(Lte, "isRequest");
  function _I(e, t, r) {
    if (typeof t == "function") return _I(e, null, t);
    t || (t = {}), r = Mte(r || Rte);
    var i = t.readable || t.readable !== !1 && e.readable, s = t.writable || t.writable !== !1 && e.writable, a = /* @__PURE__ */ n(function() {
      e.writable || u();
    }, "onlegacyfinish"), o = e._writableState && e._writableState.finished, u = /* @__PURE__ */ n(function() {
      s = !1, o = !0, i || r.call(e);
    }, "onfinish"), l = e._readableState && e._readableState.endEmitted, c = /* @__PURE__ */ n(function() {
      i = !1, l = !0, s || r.call(e);
    }, "onend"), f = /* @__PURE__ */ n(function(y) {
      r.call(e, y);
    }, "onerror"), m = /* @__PURE__ */ n(function() {
      var y;
      if (i && !l)
        return (!e._readableState || !e._readableState.ended) && (y = new AI()), r.call(e, y);
      if (s && !o)
        return (!e._writableState || !e._writableState.ended) && (y = new AI()), r.call(e, y);
    }, "onclose"), h = /* @__PURE__ */ n(function() {
      e.req.on("finish", u);
    }, "onrequest");
    return Lte(e) ? (e.on("complete", u), e.on("abort", m), e.req ? h() : e.on("request", h)) : s && !e._writableState && (e.on("end", a), e.
    on("close", a)), e.on("end", c), e.on("finish", u), t.error !== !1 && e.on("error", f), e.on("close", m), function() {
      e.removeListener("complete", u), e.removeListener("abort", m), e.removeListener("request", h), e.req && e.req.removeListener("finish",
      u), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", u), e.removeListener("end", c), e.removeListener(
      "error", f), e.removeListener("close", m);
    };
  }
  n(_I, "eos");
  PI.exports = _I;
});

// ../node_modules/readable-stream/lib/internal/streams/async_iterator.js
var II = E((iit, FI) => {
  "use strict";
  var Xh;
  function ga(e, t, r) {
    return t = jte(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
  }
  n(ga, "_defineProperty");
  function jte(e) {
    var t = qte(e, "string");
    return typeof t == "symbol" ? t : String(t);
  }
  n(jte, "_toPropertyKey");
  function qte(e, t) {
    if (typeof e != "object" || e === null) return e;
    var r = e[Symbol.toPrimitive];
    if (r !== void 0) {
      var i = r.call(e, t || "default");
      if (typeof i != "object") return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  n(qte, "_toPrimitive");
  var Ute = Jh(), ba = Symbol("lastResolve"), go = Symbol("lastReject"), mf = Symbol("error"), Yh = Symbol("ended"), bo = Symbol("lastPromis\
e"), uD = Symbol("handlePromise"), Do = Symbol("stream");
  function Da(e, t) {
    return {
      value: e,
      done: t
    };
  }
  n(Da, "createIterResult");
  function $te(e) {
    var t = e[ba];
    if (t !== null) {
      var r = e[Do].read();
      r !== null && (e[bo] = null, e[ba] = null, e[go] = null, t(Da(r, !1)));
    }
  }
  n($te, "readAndResolve");
  function Vte(e) {
    process.nextTick($te, e);
  }
  n(Vte, "onReadable");
  function Wte(e, t) {
    return function(r, i) {
      e.then(function() {
        if (t[Yh]) {
          r(Da(void 0, !0));
          return;
        }
        t[uD](r, i);
      }, i);
    };
  }
  n(Wte, "wrapForNext");
  var Hte = Object.getPrototypeOf(function() {
  }), Kte = Object.setPrototypeOf((Xh = {
    get stream() {
      return this[Do];
    },
    next: /* @__PURE__ */ n(function() {
      var t = this, r = this[mf];
      if (r !== null)
        return Promise.reject(r);
      if (this[Yh])
        return Promise.resolve(Da(void 0, !0));
      if (this[Do].destroyed)
        return new Promise(function(o, u) {
          process.nextTick(function() {
            t[mf] ? u(t[mf]) : o(Da(void 0, !0));
          });
        });
      var i = this[bo], s;
      if (i)
        s = new Promise(Wte(i, this));
      else {
        var a = this[Do].read();
        if (a !== null)
          return Promise.resolve(Da(a, !1));
        s = new Promise(this[uD]);
      }
      return this[bo] = s, s;
    }, "next")
  }, ga(Xh, Symbol.asyncIterator, function() {
    return this;
  }), ga(Xh, "return", /* @__PURE__ */ n(function() {
    var t = this;
    return new Promise(function(r, i) {
      t[Do].destroy(null, function(s) {
        if (s) {
          i(s);
          return;
        }
        r(Da(void 0, !0));
      });
    });
  }, "_return")), Xh), Hte), zte = /* @__PURE__ */ n(function(t) {
    var r, i = Object.create(Kte, (r = {}, ga(r, Do, {
      value: t,
      writable: !0
    }), ga(r, ba, {
      value: null,
      writable: !0
    }), ga(r, go, {
      value: null,
      writable: !0
    }), ga(r, mf, {
      value: null,
      writable: !0
    }), ga(r, Yh, {
      value: t._readableState.endEmitted,
      writable: !0
    }), ga(r, uD, {
      value: /* @__PURE__ */ n(function(a, o) {
        var u = i[Do].read();
        u ? (i[bo] = null, i[ba] = null, i[go] = null, a(Da(u, !1))) : (i[ba] = a, i[go] = o);
      }, "value"),
      writable: !0
    }), r));
    return i[bo] = null, Ute(t, function(s) {
      if (s && s.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var a = i[go];
        a !== null && (i[bo] = null, i[ba] = null, i[go] = null, a(s)), i[mf] = s;
        return;
      }
      var o = i[ba];
      o !== null && (i[bo] = null, i[ba] = null, i[go] = null, o(Da(void 0, !0))), i[Yh] = !0;
    }), t.on("readable", Vte.bind(null, i)), i;
  }, "createReadableStreamAsyncIterator");
  FI.exports = zte;
});

// ../node_modules/readable-stream/lib/internal/streams/from.js
var NI = E((nit, BI) => {
  "use strict";
  function OI(e, t, r, i, s, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      r(c);
      return;
    }
    u.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(OI, "asyncGeneratorStep");
  function Jte(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var a = e.apply(t, r);
        function o(l) {
          OI(a, i, s, o, u, "next", l);
        }
        n(o, "_next");
        function u(l) {
          OI(a, i, s, o, u, "throw", l);
        }
        n(u, "_throw"), o(void 0);
      });
    };
  }
  n(Jte, "_asyncToGenerator");
  function kI(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      t && (i = i.filter(function(s) {
        return Object.getOwnPropertyDescriptor(e, s).enumerable;
      })), r.push.apply(r, i);
    }
    return r;
  }
  n(kI, "ownKeys");
  function Xte(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2 ? kI(Object(r), !0).forEach(function(i) {
        Yte(e, i, r[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : kI(Object(r)).forEach(function(i) {
        Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
      });
    }
    return e;
  }
  n(Xte, "_objectSpread");
  function Yte(e, t, r) {
    return t = Gte(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
  }
  n(Yte, "_defineProperty");
  function Gte(e) {
    var t = Zte(e, "string");
    return typeof t == "symbol" ? t : String(t);
  }
  n(Gte, "_toPropertyKey");
  function Zte(e, t) {
    if (typeof e != "object" || e === null) return e;
    var r = e[Symbol.toPrimitive];
    if (r !== void 0) {
      var i = r.call(e, t || "default");
      if (typeof i != "object") return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  n(Zte, "_toPrimitive");
  var Qte = ma().codes.ERR_INVALID_ARG_TYPE;
  function ere(e, t, r) {
    var i;
    if (t && typeof t.next == "function")
      i = t;
    else if (t && t[Symbol.asyncIterator]) i = t[Symbol.asyncIterator]();
    else if (t && t[Symbol.iterator]) i = t[Symbol.iterator]();
    else throw new Qte("iterable", ["Iterable"], t);
    var s = new e(Xte({
      objectMode: !0
    }, r)), a = !1;
    s._read = function() {
      a || (a = !0, o());
    };
    function o() {
      return u.apply(this, arguments);
    }
    n(o, "next");
    function u() {
      return u = Jte(function* () {
        try {
          var l = yield i.next(), c = l.value, f = l.done;
          f ? s.push(null) : s.push(yield c) ? o() : a = !1;
        } catch (m) {
          s.destroy(m);
        }
      }), u.apply(this, arguments);
    }
    return n(u, "_next2"), s;
  }
  n(ere, "from");
  BI.exports = ere;
});

// ../node_modules/readable-stream/lib/_stream_readable.js
var oD = E((uit, HI) => {
  "use strict";
  HI.exports = st;
  var Qu;
  st.ReadableState = jI;
  var oit = require("events").EventEmitter, LI = /* @__PURE__ */ n(function(t, r) {
    return t.listeners(r).length;
  }, "EElistenerCount"), gf = J2(), Gh = require("buffer").Buffer, tre = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self <
  "u" ? self : {}).Uint8Array || function() {
  };
  function rre(e) {
    return Gh.from(e);
  }
  n(rre, "_uint8ArrayToBuffer");
  function ire(e) {
    return Gh.isBuffer(e) || e instanceof tre;
  }
  n(ire, "_isUint8Array");
  var lD = require("util"), Xe;
  lD && lD.debuglog ? Xe = lD.debuglog("stream") : Xe = /* @__PURE__ */ n(function() {
  }, "debug");
  var sre = cI(), yD = G2(), nre = Z2(), are = nre.getHighWaterMark, Zh = ma().codes, ore = Zh.ERR_INVALID_ARG_TYPE, ure = Zh.ERR_STREAM_PUSH_AFTER_EOF,
  lre = Zh.ERR_METHOD_NOT_IMPLEMENTED, cre = Zh.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, el, cD, fD;
  St()(st, gf);
  var yf = yD.errorOrDestroy, dD = ["error", "close", "destroy", "pause", "resume"];
  function fre(e, t, r) {
    if (typeof e.prependListener == "function") return e.prependListener(t, r);
    !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
  }
  n(fre, "prependListener");
  function jI(e, t, r) {
    Qu = Qu || yo(), e = e || {}, typeof r != "boolean" && (r = t instanceof Qu), this.objectMode = !!e.objectMode, r && (this.objectMode = this.
    objectMode || !!e.readableObjectMode), this.highWaterMark = are(this, e, "readableHighWaterMark", r), this.buffer = new sre(), this.length =
    0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0,
    this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose =
    e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain =
    0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (el || (el = require("string_decoder/").StringDecoder),
    this.decoder = new el(e.encoding), this.encoding = e.encoding);
  }
  n(jI, "ReadableState");
  function st(e) {
    if (Qu = Qu || yo(), !(this instanceof st)) return new st(e);
    var t = this instanceof Qu;
    this._readableState = new jI(e, this, t), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy ==
    "function" && (this._destroy = e.destroy)), gf.call(this);
  }
  n(st, "Readable");
  Object.defineProperty(st.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(t) {
      this._readableState && (this._readableState.destroyed = t);
    }, "set")
  });
  st.prototype.destroy = yD.destroy;
  st.prototype._undestroy = yD.undestroy;
  st.prototype._destroy = function(e, t) {
    t(e);
  };
  st.prototype.push = function(e, t) {
    var r = this._readableState, i;
    return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = Gh.from(e, t), t = ""), i =
    !0), qI(this, e, t, !1, i);
  };
  st.prototype.unshift = function(e) {
    return qI(this, e, null, !0, !1);
  };
  function qI(e, t, r, i, s) {
    Xe("readableAddChunk", t);
    var a = e._readableState;
    if (t === null)
      a.reading = !1, hre(e, a);
    else {
      var o;
      if (s || (o = dre(a, t)), o)
        yf(e, o);
      else if (a.objectMode || t && t.length > 0)
        if (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(t) !== Gh.prototype && (t = rre(t)), i)
          a.endEmitted ? yf(e, new cre()) : pD(e, a, t, !0);
        else if (a.ended)
          yf(e, new ure());
        else {
          if (a.destroyed)
            return !1;
          a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode || t.length !== 0 ? pD(e, a, t, !1) : mD(e, a)) : pD(e, a,
          t, !1);
        }
      else i || (a.reading = !1, mD(e, a));
    }
    return !a.ended && (a.length < a.highWaterMark || a.length === 0);
  }
  n(qI, "readableAddChunk");
  function pD(e, t, r, i) {
    t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.
    unshift(r) : t.buffer.push(r), t.needReadable && Qh(e)), mD(e, t);
  }
  n(pD, "addChunk");
  function dre(e, t) {
    var r;
    return !ire(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new ore("chunk", ["string", "Buffer", "Uint8Array"], t)),
    r;
  }
  n(dre, "chunkInvalid");
  st.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  };
  st.prototype.setEncoding = function(e) {
    el || (el = require("string_decoder/").StringDecoder);
    var t = new el(e);
    this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var r = this._readableState.buffer.head, i = ""; r !== null; )
      i += t.write(r.data), r = r.next;
    return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
  };
  var MI = 1073741824;
  function pre(e) {
    return e >= MI ? e = MI : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
  }
  n(pre, "computeNewHighWaterMark");
  function RI(e, t) {
    return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length :
    (e > t.highWaterMark && (t.highWaterMark = pre(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
  }
  n(RI, "howMuchToRead");
  st.prototype.read = function(e) {
    Xe("read", e), e = parseInt(e, 10);
    var t = this._readableState, r = e;
    if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length >
    0) || t.ended))
      return Xe("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? hD(this) : Qh(this), null;
    if (e = RI(e, t), e === 0 && t.ended)
      return t.length === 0 && hD(this), null;
    var i = t.needReadable;
    Xe("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, Xe("length less than watermark", i)), t.ended || t.
    reading ? (i = !1, Xe("reading or ended", i)) : i && (Xe("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0),
    this._read(t.highWaterMark), t.sync = !1, t.reading || (e = RI(r, t)));
    var s;
    return e > 0 ? s = VI(e, t) : s = null, s === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain =
    0), t.length === 0 && (t.ended || (t.needReadable = !0), r !== e && t.ended && hD(this)), s !== null && this.emit("data", s), s;
  };
  function hre(e, t) {
    if (Xe("onEofChunk"), !t.ended) {
      if (t.decoder) {
        var r = t.decoder.end();
        r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
      }
      t.ended = !0, t.sync ? Qh(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, UI(e)));
    }
  }
  n(hre, "onEofChunk");
  function Qh(e) {
    var t = e._readableState;
    Xe("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (Xe("emitReadable", t.flowing), t.emittedReadable =
    !0, process.nextTick(UI, e));
  }
  n(Qh, "emitReadable");
  function UI(e) {
    var t = e._readableState;
    Xe("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1),
    t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, gD(e);
  }
  n(UI, "emitReadable_");
  function mD(e, t) {
    t.readingMore || (t.readingMore = !0, process.nextTick(mre, e, t));
  }
  n(mD, "maybeReadMore");
  function mre(e, t) {
    for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
      var r = t.length;
      if (Xe("maybeReadMore read 0"), e.read(0), r === t.length)
        break;
    }
    t.readingMore = !1;
  }
  n(mre, "maybeReadMore_");
  st.prototype._read = function(e) {
    yf(this, new lre("_read()"));
  };
  st.prototype.pipe = function(e, t) {
    var r = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = e;
        break;
      case 1:
        i.pipes = [i.pipes, e];
        break;
      default:
        i.pipes.push(e);
        break;
    }
    i.pipesCount += 1, Xe("pipe count=%d opts=%j", i.pipesCount, t);
    var s = (!t || t.end !== !1) && e !== process.stdout && e !== process.stderr, a = s ? u : p;
    i.endEmitted ? process.nextTick(a) : r.once("end", a), e.on("unpipe", o);
    function o(g, b) {
      Xe("onunpipe"), g === r && b && b.hasUnpiped === !1 && (b.hasUnpiped = !0, f());
    }
    n(o, "onunpipe");
    function u() {
      Xe("onend"), e.end();
    }
    n(u, "onend");
    var l = yre(r);
    e.on("drain", l);
    var c = !1;
    function f() {
      Xe("cleanup"), e.removeListener("close", d), e.removeListener("finish", y), e.removeListener("drain", l), e.removeListener("error", h),
      e.removeListener("unpipe", o), r.removeListener("end", u), r.removeListener("end", p), r.removeListener("data", m), c = !0, i.awaitDrain &&
      (!e._writableState || e._writableState.needDrain) && l();
    }
    n(f, "cleanup"), r.on("data", m);
    function m(g) {
      Xe("ondata");
      var b = e.write(g);
      Xe("dest.write", b), b === !1 && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && WI(i.pipes, e) !== -1) && !c && (Xe("fal\
se write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
    }
    n(m, "ondata");
    function h(g) {
      Xe("onerror", g), p(), e.removeListener("error", h), LI(e, "error") === 0 && yf(e, g);
    }
    n(h, "onerror"), fre(e, "error", h);
    function d() {
      e.removeListener("finish", y), p();
    }
    n(d, "onclose"), e.once("close", d);
    function y() {
      Xe("onfinish"), e.removeListener("close", d), p();
    }
    n(y, "onfinish"), e.once("finish", y);
    function p() {
      Xe("unpipe"), r.unpipe(e);
    }
    return n(p, "unpipe"), e.emit("pipe", r), i.flowing || (Xe("pipe resume"), r.resume()), e;
  };
  function yre(e) {
    return /* @__PURE__ */ n(function() {
      var r = e._readableState;
      Xe("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && LI(e, "data") && (r.flowing = !0, gD(e));
    }, "pipeOnDrainFunctionResult");
  }
  n(yre, "pipeOnDrain");
  st.prototype.unpipe = function(e) {
    var t = this._readableState, r = {
      hasUnpiped: !1
    };
    if (t.pipesCount === 0) return this;
    if (t.pipesCount === 1)
      return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r),
      this);
    if (!e) {
      var i = t.pipes, s = t.pipesCount;
      t.pipes = null, t.pipesCount = 0, t.flowing = !1;
      for (var a = 0; a < s; a++) i[a].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var o = WI(t.pipes, e);
    return o === -1 ? this : (t.pipes.splice(o, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r),
    this);
  };
  st.prototype.on = function(e, t) {
    var r = gf.prototype.on.call(this, e, t), i = this._readableState;
    return e === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : e === "readable" &&
    !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, Xe("on read\
able", i.length, i.reading), i.length ? Qh(this) : i.reading || process.nextTick(gre, this)), r;
  };
  st.prototype.addListener = st.prototype.on;
  st.prototype.removeListener = function(e, t) {
    var r = gf.prototype.removeListener.call(this, e, t);
    return e === "readable" && process.nextTick($I, this), r;
  };
  st.prototype.removeAllListeners = function(e) {
    var t = gf.prototype.removeAllListeners.apply(this, arguments);
    return (e === "readable" || e === void 0) && process.nextTick($I, this), t;
  };
  function $I(e) {
    var t = e._readableState;
    t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.
    resume();
  }
  n($I, "updateReadableListening");
  function gre(e) {
    Xe("readable nexttick read 0"), e.read(0);
  }
  n(gre, "nReadingNextTick");
  st.prototype.resume = function() {
    var e = this._readableState;
    return e.flowing || (Xe("resume"), e.flowing = !e.readableListening, bre(this, e)), e.paused = !1, this;
  };
  function bre(e, t) {
    t.resumeScheduled || (t.resumeScheduled = !0, process.nextTick(Dre, e, t));
  }
  n(bre, "resume");
  function Dre(e, t) {
    Xe("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), gD(e), t.flowing && !t.reading && e.read(0);
  }
  n(Dre, "resume_");
  st.prototype.pause = function() {
    return Xe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Xe("pause"), this._readableState.
    flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function gD(e) {
    var t = e._readableState;
    for (Xe("flow", t.flowing); t.flowing && e.read() !== null; ) ;
  }
  n(gD, "flow");
  st.prototype.wrap = function(e) {
    var t = this, r = this._readableState, i = !1;
    e.on("end", function() {
      if (Xe("wrapped end"), r.decoder && !r.ended) {
        var o = r.decoder.end();
        o && o.length && t.push(o);
      }
      t.push(null);
    }), e.on("data", function(o) {
      if (Xe("wrapped data"), r.decoder && (o = r.decoder.write(o)), !(r.objectMode && o == null) && !(!r.objectMode && (!o || !o.length))) {
        var u = t.push(o);
        u || (i = !0, e.pause());
      }
    });
    for (var s in e)
      this[s] === void 0 && typeof e[s] == "function" && (this[s] = (/* @__PURE__ */ n(function(u) {
        return /* @__PURE__ */ n(function() {
          return e[u].apply(e, arguments);
        }, "methodWrapReturnFunction");
      }, "methodWrap"))(s));
    for (var a = 0; a < dD.length; a++)
      e.on(dD[a], this.emit.bind(this, dD[a]));
    return this._read = function(o) {
      Xe("wrapped _read", o), i && (i = !1, e.resume());
    }, this;
  };
  typeof Symbol == "function" && (st.prototype[Symbol.asyncIterator] = function() {
    return cD === void 0 && (cD = II()), cD(this);
  });
  Object.defineProperty(st.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.highWaterMark;
    }, "get")
  });
  Object.defineProperty(st.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState && this._readableState.buffer;
    }, "get")
  });
  Object.defineProperty(st.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.flowing;
    }, "get"),
    set: /* @__PURE__ */ n(function(t) {
      this._readableState && (this._readableState.flowing = t);
    }, "set")
  });
  st._fromList = VI;
  Object.defineProperty(st.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.length;
    }, "get")
  });
  function VI(e, t) {
    if (t.length === 0) return null;
    var r;
    return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.
    first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
  }
  n(VI, "fromList");
  function hD(e) {
    var t = e._readableState;
    Xe("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, process.nextTick(vre, t, e));
  }
  n(hD, "endReadable");
  function vre(e, t) {
    if (Xe("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.
    autoDestroy)) {
      var r = t._writableState;
      (!r || r.autoDestroy && r.finished) && t.destroy();
    }
  }
  n(vre, "endReadableNT");
  typeof Symbol == "function" && (st.from = function(e, t) {
    return fD === void 0 && (fD = NI()), fD(st, e, t);
  });
  function WI(e, t) {
    for (var r = 0, i = e.length; r < i; r++)
      if (e[r] === t) return r;
    return -1;
  }
  n(WI, "indexOf");
});

// ../node_modules/readable-stream/lib/_stream_transform.js
var bD = E((cit, zI) => {
  "use strict";
  zI.exports = xn;
  var e0 = ma().codes, xre = e0.ERR_METHOD_NOT_IMPLEMENTED, Ere = e0.ERR_MULTIPLE_CALLBACK, Sre = e0.ERR_TRANSFORM_ALREADY_TRANSFORMING, Tre = e0.
  ERR_TRANSFORM_WITH_LENGTH_0, t0 = yo();
  St()(xn, t0);
  function Cre(e, t) {
    var r = this._transformState;
    r.transforming = !1;
    var i = r.writecb;
    if (i === null)
      return this.emit("error", new Ere());
    r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
    var s = this._readableState;
    s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
  n(Cre, "afterTransform");
  function xn(e) {
    if (!(this instanceof xn)) return new xn(e);
    t0.call(this, e), this._transformState = {
      afterTransform: Cre.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.
    transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", wre);
  }
  n(xn, "Transform");
  function wre() {
    var e = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
      KI(e, t, r);
    }) : KI(this, null, null);
  }
  n(wre, "prefinish");
  xn.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, t0.prototype.push.call(this, e, t);
  };
  xn.prototype._transform = function(e, t, r) {
    r(new xre("_transform()"));
  };
  xn.prototype._write = function(e, t, r) {
    var i = this._transformState;
    if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
      var s = this._readableState;
      (i.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
    }
  };
  xn.prototype._read = function(e) {
    var t = this._transformState;
    t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform =
    !0;
  };
  xn.prototype._destroy = function(e, t) {
    t0.prototype._destroy.call(this, e, function(r) {
      t(r);
    });
  };
  function KI(e, t, r) {
    if (t) return e.emit("error", t);
    if (r != null && e.push(r), e._writableState.length) throw new Tre();
    if (e._transformState.transforming) throw new Sre();
    return e.push(null);
  }
  n(KI, "done");
});

// ../node_modules/readable-stream/lib/_stream_passthrough.js
var YI = E((dit, XI) => {
  "use strict";
  XI.exports = bf;
  var JI = bD();
  St()(bf, JI);
  function bf(e) {
    if (!(this instanceof bf)) return new bf(e);
    JI.call(this, e);
  }
  n(bf, "PassThrough");
  bf.prototype._transform = function(e, t, r) {
    r(null, e);
  };
});

// ../node_modules/readable-stream/lib/internal/streams/pipeline.js
var t5 = E((hit, e5) => {
  "use strict";
  var DD;
  function Are(e) {
    var t = !1;
    return function() {
      t || (t = !0, e.apply(void 0, arguments));
    };
  }
  n(Are, "once");
  var QI = ma().codes, _re = QI.ERR_MISSING_ARGS, Pre = QI.ERR_STREAM_DESTROYED;
  function GI(e) {
    if (e) throw e;
  }
  n(GI, "noop");
  function Fre(e) {
    return e.setHeader && typeof e.abort == "function";
  }
  n(Fre, "isRequest");
  function Ire(e, t, r, i) {
    i = Are(i);
    var s = !1;
    e.on("close", function() {
      s = !0;
    }), DD === void 0 && (DD = Jh()), DD(e, {
      readable: t,
      writable: r
    }, function(o) {
      if (o) return i(o);
      s = !0, i();
    });
    var a = !1;
    return function(o) {
      if (!s && !a) {
        if (a = !0, Fre(e)) return e.abort();
        if (typeof e.destroy == "function") return e.destroy();
        i(o || new Pre("pipe"));
      }
    };
  }
  n(Ire, "destroyer");
  function ZI(e) {
    e();
  }
  n(ZI, "call");
  function Ore(e, t) {
    return e.pipe(t);
  }
  n(Ore, "pipe");
  function kre(e) {
    return !e.length || typeof e[e.length - 1] != "function" ? GI : e.pop();
  }
  n(kre, "popCallback");
  function Bre() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    var i = kre(t);
    if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
      throw new _re("streams");
    var s, a = t.map(function(o, u) {
      var l = u < t.length - 1, c = u > 0;
      return Ire(o, l, c, function(f) {
        s || (s = f), f && a.forEach(ZI), !l && (a.forEach(ZI), i(s));
      });
    });
    return t.reduce(Ore);
  }
  n(Bre, "pipeline");
  e5.exports = Bre;
});

// ../node_modules/readable-stream/readable.js
var tl = E((ji, vf) => {
  var Df = require("stream");
  process.env.READABLE_STREAM === "disable" && Df ? (vf.exports = Df.Readable, Object.assign(vf.exports, Df), vf.exports.Stream = Df) : (ji =
  vf.exports = oD(), ji.Stream = Df || ji, ji.Readable = ji, ji.Writable = sD(), ji.Duplex = yo(), ji.Transform = bD(), ji.PassThrough = YI(),
  ji.finished = Jh(), ji.pipeline = t5());
});

// ../node_modules/bl/BufferList.js
var s5 = E((yit, i5) => {
  "use strict";
  var { Buffer: fs } = require("buffer"), r5 = Symbol.for("BufferList");
  function Tt(e) {
    if (!(this instanceof Tt))
      return new Tt(e);
    Tt._init.call(this, e);
  }
  n(Tt, "BufferList");
  Tt._init = /* @__PURE__ */ n(function(t) {
    Object.defineProperty(this, r5, { value: !0 }), this._bufs = [], this.length = 0, t && this.append(t);
  }, "_init");
  Tt.prototype._new = /* @__PURE__ */ n(function(t) {
    return new Tt(t);
  }, "_new");
  Tt.prototype._offset = /* @__PURE__ */ n(function(t) {
    if (t === 0)
      return [0, 0];
    let r = 0;
    for (let i = 0; i < this._bufs.length; i++) {
      let s = r + this._bufs[i].length;
      if (t < s || i === this._bufs.length - 1)
        return [i, t - r];
      r = s;
    }
  }, "_offset");
  Tt.prototype._reverseOffset = function(e) {
    let t = e[0], r = e[1];
    for (let i = 0; i < t; i++)
      r += this._bufs[i].length;
    return r;
  };
  Tt.prototype.get = /* @__PURE__ */ n(function(t) {
    if (t > this.length || t < 0)
      return;
    let r = this._offset(t);
    return this._bufs[r[0]][r[1]];
  }, "get");
  Tt.prototype.slice = /* @__PURE__ */ n(function(t, r) {
    return typeof t == "number" && t < 0 && (t += this.length), typeof r == "number" && r < 0 && (r += this.length), this.copy(null, 0, t, r);
  }, "slice");
  Tt.prototype.copy = /* @__PURE__ */ n(function(t, r, i, s) {
    if ((typeof i != "number" || i < 0) && (i = 0), (typeof s != "number" || s > this.length) && (s = this.length), i >= this.length || s <=
    0)
      return t || fs.alloc(0);
    let a = !!t, o = this._offset(i), u = s - i, l = u, c = a && r || 0, f = o[1];
    if (i === 0 && s === this.length) {
      if (!a)
        return this._bufs.length === 1 ? this._bufs[0] : fs.concat(this._bufs, this.length);
      for (let m = 0; m < this._bufs.length; m++)
        this._bufs[m].copy(t, c), c += this._bufs[m].length;
      return t;
    }
    if (l <= this._bufs[o[0]].length - f)
      return a ? this._bufs[o[0]].copy(t, r, f, f + l) : this._bufs[o[0]].slice(f, f + l);
    a || (t = fs.allocUnsafe(u));
    for (let m = o[0]; m < this._bufs.length; m++) {
      let h = this._bufs[m].length - f;
      if (l > h)
        this._bufs[m].copy(t, c, f), c += h;
      else {
        this._bufs[m].copy(t, c, f, f + l), c += h;
        break;
      }
      l -= h, f && (f = 0);
    }
    return t.length > c ? t.slice(0, c) : t;
  }, "copy");
  Tt.prototype.shallowSlice = /* @__PURE__ */ n(function(t, r) {
    if (t = t || 0, r = typeof r != "number" ? this.length : r, t < 0 && (t += this.length), r < 0 && (r += this.length), t === r)
      return this._new();
    let i = this._offset(t), s = this._offset(r), a = this._bufs.slice(i[0], s[0] + 1);
    return s[1] === 0 ? a.pop() : a[a.length - 1] = a[a.length - 1].slice(0, s[1]), i[1] !== 0 && (a[0] = a[0].slice(i[1])), this._new(a);
  }, "shallowSlice");
  Tt.prototype.toString = /* @__PURE__ */ n(function(t, r, i) {
    return this.slice(r, i).toString(t);
  }, "toString");
  Tt.prototype.consume = /* @__PURE__ */ n(function(t) {
    if (t = Math.trunc(t), Number.isNaN(t) || t <= 0) return this;
    for (; this._bufs.length; )
      if (t >= this._bufs[0].length)
        t -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
      else {
        this._bufs[0] = this._bufs[0].slice(t), this.length -= t;
        break;
      }
    return this;
  }, "consume");
  Tt.prototype.duplicate = /* @__PURE__ */ n(function() {
    let t = this._new();
    for (let r = 0; r < this._bufs.length; r++)
      t.append(this._bufs[r]);
    return t;
  }, "duplicate");
  Tt.prototype.append = /* @__PURE__ */ n(function(t) {
    if (t == null)
      return this;
    if (t.buffer)
      this._appendBuffer(fs.from(t.buffer, t.byteOffset, t.byteLength));
    else if (Array.isArray(t))
      for (let r = 0; r < t.length; r++)
        this.append(t[r]);
    else if (this._isBufferList(t))
      for (let r = 0; r < t._bufs.length; r++)
        this.append(t._bufs[r]);
    else
      typeof t == "number" && (t = t.toString()), this._appendBuffer(fs.from(t));
    return this;
  }, "append");
  Tt.prototype._appendBuffer = /* @__PURE__ */ n(function(t) {
    this._bufs.push(t), this.length += t.length;
  }, "appendBuffer");
  Tt.prototype.indexOf = function(e, t, r) {
    if (r === void 0 && typeof t == "string" && (r = t, t = void 0), typeof e == "function" || Array.isArray(e))
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    if (typeof e == "number" ? e = fs.from([e]) : typeof e == "string" ? e = fs.from(e, r) : this._isBufferList(e) ? e = e.slice() : Array.isArray(
    e.buffer) ? e = fs.from(e.buffer, e.byteOffset, e.byteLength) : fs.isBuffer(e) || (e = fs.from(e)), t = Number(t || 0), isNaN(t) && (t =
    0), t < 0 && (t = this.length + t), t < 0 && (t = 0), e.length === 0)
      return t > this.length ? this.length : t;
    let i = this._offset(t), s = i[0], a = i[1];
    for (; s < this._bufs.length; s++) {
      let o = this._bufs[s];
      for (; a < o.length; )
        if (o.length - a >= e.length) {
          let l = o.indexOf(e, a);
          if (l !== -1)
            return this._reverseOffset([s, l]);
          a = o.length - e.length + 1;
        } else {
          let l = this._reverseOffset([s, a]);
          if (this._match(l, e))
            return l;
          a++;
        }
      a = 0;
    }
    return -1;
  };
  Tt.prototype._match = function(e, t) {
    if (this.length - e < t.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (this.get(e + r) !== t[r])
        return !1;
    return !0;
  };
  (function() {
    let e = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1,
      readIntBE: null,
      readIntLE: null,
      readUIntBE: null,
      readUIntLE: null
    };
    for (let t in e)
      (function(r) {
        e[r] === null ? Tt.prototype[r] = function(i, s) {
          return this.slice(i, i + s)[r](0, s);
        } : Tt.prototype[r] = function(i = 0) {
          return this.slice(i, i + e[r])[r](0);
        };
      })(t);
  })();
  Tt.prototype._isBufferList = /* @__PURE__ */ n(function(t) {
    return t instanceof Tt || Tt.isBufferList(t);
  }, "_isBufferList");
  Tt.isBufferList = /* @__PURE__ */ n(function(t) {
    return t != null && t[r5];
  }, "isBufferList");
  i5.exports = Tt;
});

// ../node_modules/bl/bl.js
var n5 = E((bit, r0) => {
  "use strict";
  var vD = tl().Duplex, Nre = St(), xf = s5();
  function Lr(e) {
    if (!(this instanceof Lr))
      return new Lr(e);
    if (typeof e == "function") {
      this._callback = e;
      let t = (/* @__PURE__ */ n(function(i) {
        this._callback && (this._callback(i), this._callback = null);
      }, "piper")).bind(this);
      this.on("pipe", /* @__PURE__ */ n(function(i) {
        i.on("error", t);
      }, "onPipe")), this.on("unpipe", /* @__PURE__ */ n(function(i) {
        i.removeListener("error", t);
      }, "onUnpipe")), e = null;
    }
    xf._init.call(this, e), vD.call(this);
  }
  n(Lr, "BufferListStream");
  Nre(Lr, vD);
  Object.assign(Lr.prototype, xf.prototype);
  Lr.prototype._new = /* @__PURE__ */ n(function(t) {
    return new Lr(t);
  }, "_new");
  Lr.prototype._write = /* @__PURE__ */ n(function(t, r, i) {
    this._appendBuffer(t), typeof i == "function" && i();
  }, "_write");
  Lr.prototype._read = /* @__PURE__ */ n(function(t) {
    if (!this.length)
      return this.push(null);
    t = Math.min(t, this.length), this.push(this.slice(0, t)), this.consume(t);
  }, "_read");
  Lr.prototype.end = /* @__PURE__ */ n(function(t) {
    vD.prototype.end.call(this, t), this._callback && (this._callback(null, this.slice()), this._callback = null);
  }, "end");
  Lr.prototype._destroy = /* @__PURE__ */ n(function(t, r) {
    this._bufs.length = 0, this.length = 0, r(t);
  }, "_destroy");
  Lr.prototype._isBufferList = /* @__PURE__ */ n(function(t) {
    return t instanceof Lr || t instanceof xf || Lr.isBufferList(t);
  }, "_isBufferList");
  Lr.isBufferList = xf.isBufferList;
  r0.exports = Lr;
  r0.exports.BufferListStream = Lr;
  r0.exports.BufferList = xf;
});

// ../node_modules/tar-stream/headers.js
var SD = E((il) => {
  var Mre = Buffer.alloc, Rre = "0000000000000000000", Lre = "7777777777777777777", a5 = 48, o5 = Buffer.from("ustar\0", "binary"), jre = Buffer.
  from("00", "binary"), qre = Buffer.from("ustar ", "binary"), Ure = Buffer.from(" \0", "binary"), $re = parseInt("7777", 8), Ef = 257, ED = 263,
  Vre = /* @__PURE__ */ n(function(e, t, r) {
    return typeof e != "number" ? r : (e = ~~e, e >= t ? t : e >= 0 || (e += t, e >= 0) ? e : 0);
  }, "clamp"), Wre = /* @__PURE__ */ n(function(e) {
    switch (e) {
      case 0:
        return "file";
      case 1:
        return "link";
      case 2:
        return "symlink";
      case 3:
        return "character-device";
      case 4:
        return "block-device";
      case 5:
        return "directory";
      case 6:
        return "fifo";
      case 7:
        return "contiguous-file";
      case 72:
        return "pax-header";
      case 55:
        return "pax-global-header";
      case 27:
        return "gnu-long-link-path";
      case 28:
      case 30:
        return "gnu-long-path";
    }
    return null;
  }, "toType"), Hre = /* @__PURE__ */ n(function(e) {
    switch (e) {
      case "file":
        return 0;
      case "link":
        return 1;
      case "symlink":
        return 2;
      case "character-device":
        return 3;
      case "block-device":
        return 4;
      case "directory":
        return 5;
      case "fifo":
        return 6;
      case "contiguous-file":
        return 7;
      case "pax-header":
        return 72;
    }
    return 0;
  }, "toTypeflag"), u5 = /* @__PURE__ */ n(function(e, t, r, i) {
    for (; r < i; r++)
      if (e[r] === t) return r;
    return i;
  }, "indexOf"), l5 = /* @__PURE__ */ n(function(e) {
    for (var t = 256, r = 0; r < 148; r++) t += e[r];
    for (var i = 156; i < 512; i++) t += e[i];
    return t;
  }, "cksum"), va = /* @__PURE__ */ n(function(e, t) {
    return e = e.toString(8), e.length > t ? Lre.slice(0, t) + " " : Rre.slice(0, t - e.length) + e + " ";
  }, "encodeOct");
  function Kre(e) {
    var t;
    if (e[0] === 128) t = !0;
    else if (e[0] === 255) t = !1;
    else return null;
    for (var r = [], i = e.length - 1; i > 0; i--) {
      var s = e[i];
      t ? r.push(s) : r.push(255 - s);
    }
    var a = 0, o = r.length;
    for (i = 0; i < o; i++)
      a += r[i] * Math.pow(256, i);
    return t ? a : -1 * a;
  }
  n(Kre, "parse256");
  var xa = /* @__PURE__ */ n(function(e, t, r) {
    if (e = e.slice(t, t + r), t = 0, e[t] & 128)
      return Kre(e);
    for (; t < e.length && e[t] === 32; ) t++;
    for (var i = Vre(u5(e, 32, t, e.length), e.length, e.length); t < i && e[t] === 0; ) t++;
    return i === t ? 0 : parseInt(e.slice(t, i).toString(), 8);
  }, "decodeOct"), rl = /* @__PURE__ */ n(function(e, t, r, i) {
    return e.slice(t, u5(e, 0, t, t + r)).toString(i);
  }, "decodeStr"), xD = /* @__PURE__ */ n(function(e) {
    var t = Buffer.byteLength(e), r = Math.floor(Math.log(t) / Math.log(10)) + 1;
    return t + r >= Math.pow(10, r) && r++, t + r + e;
  }, "addLength");
  il.decodeLongPath = function(e, t) {
    return rl(e, 0, e.length, t);
  };
  il.encodePax = function(e) {
    var t = "";
    e.name && (t += xD(" path=" + e.name + `
`)), e.linkname && (t += xD(" linkpath=" + e.linkname + `
`));
    var r = e.pax;
    if (r)
      for (var i in r)
        t += xD(" " + i + "=" + r[i] + `
`);
    return Buffer.from(t);
  };
  il.decodePax = function(e) {
    for (var t = {}; e.length; ) {
      for (var r = 0; r < e.length && e[r] !== 32; ) r++;
      var i = parseInt(e.slice(0, r).toString(), 10);
      if (!i) return t;
      var s = e.slice(r + 1, i - 1).toString(), a = s.indexOf("=");
      if (a === -1) return t;
      t[s.slice(0, a)] = s.slice(a + 1), e = e.slice(i);
    }
    return t;
  };
  il.encode = function(e) {
    var t = Mre(512), r = e.name, i = "";
    if (e.typeflag === 5 && r[r.length - 1] !== "/" && (r += "/"), Buffer.byteLength(r) !== r.length) return null;
    for (; Buffer.byteLength(r) > 100; ) {
      var s = r.indexOf("/");
      if (s === -1) return null;
      i += i ? "/" + r.slice(0, s) : r.slice(0, s), r = r.slice(s + 1);
    }
    return Buffer.byteLength(r) > 100 || Buffer.byteLength(i) > 155 || e.linkname && Buffer.byteLength(e.linkname) > 100 ? null : (t.write(r),
    t.write(va(e.mode & $re, 6), 100), t.write(va(e.uid, 6), 108), t.write(va(e.gid, 6), 116), t.write(va(e.size, 11), 124), t.write(va(e.mtime.
    getTime() / 1e3 | 0, 11), 136), t[156] = a5 + Hre(e.type), e.linkname && t.write(e.linkname, 157), o5.copy(t, Ef), jre.copy(t, ED), e.uname &&
    t.write(e.uname, 265), e.gname && t.write(e.gname, 297), t.write(va(e.devmajor || 0, 6), 329), t.write(va(e.devminor || 0, 6), 337), i &&
    t.write(i, 345), t.write(va(l5(t), 6), 148), t);
  };
  il.decode = function(e, t, r) {
    var i = e[156] === 0 ? 0 : e[156] - a5, s = rl(e, 0, 100, t), a = xa(e, 100, 8), o = xa(e, 108, 8), u = xa(e, 116, 8), l = xa(e, 124, 12),
    c = xa(e, 136, 12), f = Wre(i), m = e[157] === 0 ? null : rl(e, 157, 100, t), h = rl(e, 265, 32), d = rl(e, 297, 32), y = xa(e, 329, 8),
    p = xa(e, 337, 8), g = l5(e);
    if (g === 8 * 32) return null;
    if (g !== xa(e, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    if (o5.compare(e, Ef, Ef + 6) === 0)
      e[345] && (s = rl(e, 345, 155, t) + "/" + s);
    else if (!(qre.compare(e, Ef, Ef + 6) === 0 && Ure.compare(e, ED, ED + 2) === 0)) {
      if (!r)
        throw new Error("Invalid tar header: unknown format.");
    }
    return i === 0 && s && s[s.length - 1] === "/" && (i = 5), {
      name: s,
      mode: a,
      uid: o,
      gid: u,
      size: l,
      mtime: new Date(1e3 * c),
      type: f,
      linkname: m,
      uname: h,
      gname: d,
      devmajor: y,
      devminor: p
    };
  };
});

// ../node_modules/tar-stream/extract.js
var y5 = E((Eit, m5) => {
  var f5 = require("util"), zre = n5(), Sf = SD(), d5 = tl().Writable, p5 = tl().PassThrough, h5 = /* @__PURE__ */ n(function() {
  }, "noop"), c5 = /* @__PURE__ */ n(function(e) {
    return e &= 511, e && 512 - e;
  }, "overflow"), Jre = /* @__PURE__ */ n(function(e, t) {
    var r = new i0(e, t);
    return r.end(), r;
  }, "emptyStream"), Xre = /* @__PURE__ */ n(function(e, t) {
    return t.path && (e.name = t.path), t.linkpath && (e.linkname = t.linkpath), t.size && (e.size = parseInt(t.size, 10)), e.pax = t, e;
  }, "mixinPax"), i0 = /* @__PURE__ */ n(function(e, t) {
    this._parent = e, this.offset = t, p5.call(this, { autoDestroy: !1 });
  }, "Source");
  f5.inherits(i0, p5);
  i0.prototype.destroy = function(e) {
    this._parent.destroy(e);
  };
  var En = /* @__PURE__ */ n(function(e) {
    if (!(this instanceof En)) return new En(e);
    d5.call(this, e), e = e || {}, this._offset = 0, this._buffer = zre(), this._missing = 0, this._partial = !1, this._onparse = h5, this._header =
    null, this._stream = null, this._overflow = null, this._cb = null, this._locked = !1, this._destroyed = !1, this._pax = null, this._paxGlobal =
    null, this._gnuLongPath = null, this._gnuLongLinkPath = null;
    var t = this, r = t._buffer, i = /* @__PURE__ */ n(function() {
      t._continue();
    }, "oncontinue"), s = /* @__PURE__ */ n(function(h) {
      if (t._locked = !1, h) return t.destroy(h);
      t._stream || i();
    }, "onunlock"), a = /* @__PURE__ */ n(function() {
      t._stream = null;
      var h = c5(t._header.size);
      h ? t._parse(h, o) : t._parse(512, m), t._locked || i();
    }, "onstreamend"), o = /* @__PURE__ */ n(function() {
      t._buffer.consume(c5(t._header.size)), t._parse(512, m), i();
    }, "ondrain"), u = /* @__PURE__ */ n(function() {
      var h = t._header.size;
      t._paxGlobal = Sf.decodePax(r.slice(0, h)), r.consume(h), a();
    }, "onpaxglobalheader"), l = /* @__PURE__ */ n(function() {
      var h = t._header.size;
      t._pax = Sf.decodePax(r.slice(0, h)), t._paxGlobal && (t._pax = Object.assign({}, t._paxGlobal, t._pax)), r.consume(h), a();
    }, "onpaxheader"), c = /* @__PURE__ */ n(function() {
      var h = t._header.size;
      this._gnuLongPath = Sf.decodeLongPath(r.slice(0, h), e.filenameEncoding), r.consume(h), a();
    }, "ongnulongpath"), f = /* @__PURE__ */ n(function() {
      var h = t._header.size;
      this._gnuLongLinkPath = Sf.decodeLongPath(r.slice(0, h), e.filenameEncoding), r.consume(h), a();
    }, "ongnulonglinkpath"), m = /* @__PURE__ */ n(function() {
      var h = t._offset, d;
      try {
        d = t._header = Sf.decode(r.slice(0, 512), e.filenameEncoding, e.allowUnknownFormat);
      } catch (y) {
        t.emit("error", y);
      }
      if (r.consume(512), !d) {
        t._parse(512, m), i();
        return;
      }
      if (d.type === "gnu-long-path") {
        t._parse(d.size, c), i();
        return;
      }
      if (d.type === "gnu-long-link-path") {
        t._parse(d.size, f), i();
        return;
      }
      if (d.type === "pax-global-header") {
        t._parse(d.size, u), i();
        return;
      }
      if (d.type === "pax-header") {
        t._parse(d.size, l), i();
        return;
      }
      if (t._gnuLongPath && (d.name = t._gnuLongPath, t._gnuLongPath = null), t._gnuLongLinkPath && (d.linkname = t._gnuLongLinkPath, t._gnuLongLinkPath =
      null), t._pax && (t._header = d = Xre(d, t._pax), t._pax = null), t._locked = !0, !d.size || d.type === "directory") {
        t._parse(512, m), t.emit("entry", d, Jre(t, h), s);
        return;
      }
      t._stream = new i0(t, h), t.emit("entry", d, t._stream, s), t._parse(d.size, a), i();
    }, "onheader");
    this._onheader = m, this._parse(512, m);
  }, "Extract");
  f5.inherits(En, d5);
  En.prototype.destroy = function(e) {
    this._destroyed || (this._destroyed = !0, e && this.emit("error", e), this.emit("close"), this._stream && this._stream.emit("close"));
  };
  En.prototype._parse = function(e, t) {
    this._destroyed || (this._offset += e, this._missing = e, t === this._onheader && (this._partial = !1), this._onparse = t);
  };
  En.prototype._continue = function() {
    if (!this._destroyed) {
      var e = this._cb;
      this._cb = h5, this._overflow ? this._write(this._overflow, void 0, e) : e();
    }
  };
  En.prototype._write = function(e, t, r) {
    if (!this._destroyed) {
      var i = this._stream, s = this._buffer, a = this._missing;
      if (e.length && (this._partial = !0), e.length < a)
        return this._missing -= e.length, this._overflow = null, i ? i.write(e, r) : (s.append(e), r());
      this._cb = r, this._missing = 0;
      var o = null;
      e.length > a && (o = e.slice(a), e = e.slice(0, a)), i ? i.end(e) : s.append(e), this._overflow = o, this._onparse();
    }
  };
  En.prototype._final = function(e) {
    if (this._partial) return this.destroy(new Error("Unexpected end of data"));
    e();
  };
  m5.exports = En;
});

// ../node_modules/fs-constants/index.js
var b5 = E((Tit, g5) => {
  g5.exports = require("fs").constants || require("constants");
});

// ../node_modules/tar-stream/pack.js
var S5 = E((Cit, E5) => {
  var sl = b5(), D5 = Yu(), n0 = St(), Yre = Buffer.alloc, v5 = tl().Readable, nl = tl().Writable, Gre = require("string_decoder").StringDecoder,
  s0 = SD(), Zre = parseInt("755", 8), Qre = parseInt("644", 8), x5 = Yre(1024), CD = /* @__PURE__ */ n(function() {
  }, "noop"), TD = /* @__PURE__ */ n(function(e, t) {
    t &= 511, t && e.push(x5.slice(0, 512 - t));
  }, "overflow");
  function eie(e) {
    switch (e & sl.S_IFMT) {
      case sl.S_IFBLK:
        return "block-device";
      case sl.S_IFCHR:
        return "character-device";
      case sl.S_IFDIR:
        return "directory";
      case sl.S_IFIFO:
        return "fifo";
      case sl.S_IFLNK:
        return "symlink";
    }
    return "file";
  }
  n(eie, "modeToType");
  var a0 = /* @__PURE__ */ n(function(e) {
    nl.call(this), this.written = 0, this._to = e, this._destroyed = !1;
  }, "Sink");
  n0(a0, nl);
  a0.prototype._write = function(e, t, r) {
    if (this.written += e.length, this._to.push(e)) return r();
    this._to._drain = r;
  };
  a0.prototype.destroy = function() {
    this._destroyed || (this._destroyed = !0, this.emit("close"));
  };
  var o0 = /* @__PURE__ */ n(function() {
    nl.call(this), this.linkname = "", this._decoder = new Gre("utf-8"), this._destroyed = !1;
  }, "LinkSink");
  n0(o0, nl);
  o0.prototype._write = function(e, t, r) {
    this.linkname += this._decoder.write(e), r();
  };
  o0.prototype.destroy = function() {
    this._destroyed || (this._destroyed = !0, this.emit("close"));
  };
  var Tf = /* @__PURE__ */ n(function() {
    nl.call(this), this._destroyed = !1;
  }, "Void");
  n0(Tf, nl);
  Tf.prototype._write = function(e, t, r) {
    r(new Error("No body allowed for this entry"));
  };
  Tf.prototype.destroy = function() {
    this._destroyed || (this._destroyed = !0, this.emit("close"));
  };
  var $s = /* @__PURE__ */ n(function(e) {
    if (!(this instanceof $s)) return new $s(e);
    v5.call(this, e), this._drain = CD, this._finalized = !1, this._finalizing = !1, this._destroyed = !1, this._stream = null;
  }, "Pack");
  n0($s, v5);
  $s.prototype.entry = function(e, t, r) {
    if (this._stream) throw new Error("already piping an entry");
    if (!(this._finalized || this._destroyed)) {
      typeof t == "function" && (r = t, t = null), r || (r = CD);
      var i = this;
      if ((!e.size || e.type === "symlink") && (e.size = 0), e.type || (e.type = eie(e.mode)), e.mode || (e.mode = e.type === "directory" ? Zre :
      Qre), e.uid || (e.uid = 0), e.gid || (e.gid = 0), e.mtime || (e.mtime = /* @__PURE__ */ new Date()), typeof t == "string" && (t = Buffer.
      from(t)), Buffer.isBuffer(t)) {
        e.size = t.length, this._encode(e);
        var s = this.push(t);
        return TD(i, e.size), s ? process.nextTick(r) : this._drain = r, new Tf();
      }
      if (e.type === "symlink" && !e.linkname) {
        var a = new o0();
        return D5(a, function(u) {
          if (u)
            return i.destroy(), r(u);
          e.linkname = a.linkname, i._encode(e), r();
        }), a;
      }
      if (this._encode(e), e.type !== "file" && e.type !== "contiguous-file")
        return process.nextTick(r), new Tf();
      var o = new a0(this);
      return this._stream = o, D5(o, function(u) {
        if (i._stream = null, u)
          return i.destroy(), r(u);
        if (o.written !== e.size)
          return i.destroy(), r(new Error("size mismatch"));
        TD(i, e.size), i._finalizing && i.finalize(), r();
      }), o;
    }
  };
  $s.prototype.finalize = function() {
    if (this._stream) {
      this._finalizing = !0;
      return;
    }
    this._finalized || (this._finalized = !0, this.push(x5), this.push(null));
  };
  $s.prototype.destroy = function(e) {
    this._destroyed || (this._destroyed = !0, e && this.emit("error", e), this.emit("close"), this._stream && this._stream.destroy && this._stream.
    destroy());
  };
  $s.prototype._encode = function(e) {
    if (!e.pax) {
      var t = s0.encode(e);
      if (t) {
        this.push(t);
        return;
      }
    }
    this._encodePax(e);
  };
  $s.prototype._encodePax = function(e) {
    var t = s0.encodePax({
      name: e.name,
      linkname: e.linkname,
      pax: e.pax
    }), r = {
      name: "PaxHeader",
      mode: e.mode,
      uid: e.uid,
      gid: e.gid,
      size: t.length,
      mtime: e.mtime,
      type: "pax-header",
      linkname: e.linkname && "PaxHeader",
      uname: e.uname,
      gname: e.gname,
      devmajor: e.devmajor,
      devminor: e.devminor
    };
    this.push(s0.encode(r)), this.push(t), TD(this, t.length), r.size = e.size, r.type = e.type, this.push(s0.encode(r));
  };
  $s.prototype._read = function(e) {
    var t = this._drain;
    this._drain = CD, t();
  };
  E5.exports = $s;
});

// ../node_modules/tar-stream/index.js
var T5 = E((wD) => {
  wD.extract = y5();
  wD.pack = S5();
});

// ../node_modules/mkdirp-classic/index.js
var _5 = E((_it, A5) => {
  var u0 = require("path"), C5 = require("fs"), w5 = parseInt("0777", 8);
  A5.exports = al.mkdirp = al.mkdirP = al;
  function al(e, t, r, i) {
    typeof t == "function" ? (r = t, t = {}) : (!t || typeof t != "object") && (t = { mode: t });
    var s = t.mode, a = t.fs || C5;
    s === void 0 && (s = w5 & ~process.umask()), i || (i = null);
    var o = r || function() {
    };
    e = u0.resolve(e), a.mkdir(e, s, function(u) {
      if (!u)
        return i = i || e, o(null, i);
      switch (u.code) {
        case "ENOENT":
          al(u0.dirname(e), t, function(l, c) {
            l ? o(l, c) : al(e, t, o, c);
          });
          break;
        // In the case of any other error, just see if there's a dir
        // there already.  If so, then hooray!  If not, then something
        // is borked.
        default:
          a.stat(e, function(l, c) {
            l || !c.isDirectory() ? o(u, i) : o(null, i);
          });
          break;
      }
    });
  }
  n(al, "mkdirP");
  al.sync = /* @__PURE__ */ n(function e(t, r, i) {
    (!r || typeof r != "object") && (r = { mode: r });
    var s = r.mode, a = r.fs || C5;
    s === void 0 && (s = w5 & ~process.umask()), i || (i = null), t = u0.resolve(t);
    try {
      a.mkdirSync(t, s), i = i || t;
    } catch (u) {
      switch (u.code) {
        case "ENOENT":
          i = e(u0.dirname(t), r, i), e(t, r, i);
          break;
        // In the case of any other error, just see if there's a dir
        // there already.  If so, then hooray!  If not, then something
        // is borked.
        default:
          var o;
          try {
            o = a.statSync(t);
          } catch {
            throw u;
          }
          if (!o.isDirectory()) throw u;
          break;
      }
    }
    return i;
  }, "sync");
});

// ../node_modules/tar-fs/index.js
var M5 = E((PD) => {
  var tie = iI(), F5 = T5(), I5 = H2(), rie = _5(), O5 = require("fs"), jr = require("path"), iie = require("os"), Cf = iie.platform() === "\
win32", wf = /* @__PURE__ */ n(function() {
  }, "noop"), _D = /* @__PURE__ */ n(function(e) {
    return e;
  }, "echo"), AD = Cf ? function(e) {
    return e.replace(/\\/g, "/").replace(/[:?<>|]/g, "_");
  } : _D, sie = /* @__PURE__ */ n(function(e, t, r, i, s, a) {
    var o = s || ["."];
    return /* @__PURE__ */ n(function(l) {
      if (!o.length) return l();
      var c = o.shift(), f = jr.join(r, c);
      t.call(e, f, function(m, h) {
        if (m) return l(m);
        if (!h.isDirectory()) return l(null, c, h);
        e.readdir(f, function(d, y) {
          if (d) return l(d);
          a && y.sort();
          for (var p = 0; p < y.length; p++)
            i(jr.join(r, c, y[p])) || o.push(jr.join(c, y[p]));
          l(null, c, h);
        });
      });
    }, "loop");
  }, "statAll"), k5 = /* @__PURE__ */ n(function(e, t) {
    return function(r) {
      r.name = r.name.split("/").slice(t).join("/");
      var i = r.linkname;
      return i && (r.type === "link" || jr.isAbsolute(i)) && (r.linkname = i.split("/").slice(t).join("/")), e(r);
    };
  }, "strip");
  PD.pack = function(e, t) {
    e || (e = "."), t || (t = {});
    var r = t.fs || O5, i = t.ignore || t.filter || wf, s = t.map || wf, a = t.mapStream || _D, o = sie(r, t.dereference ? r.stat : r.lstat,
    e, i, t.entries, t.sort), u = t.strict !== !1, l = typeof t.umask == "number" ? ~t.umask : ~B5(), c = typeof t.dmode == "number" ? t.dmode :
    0, f = typeof t.fmode == "number" ? t.fmode : 0, m = t.pack || F5.pack(), h = t.finish || wf;
    t.strip && (s = k5(s, t.strip)), t.readable && (c |= parseInt(555, 8), f |= parseInt(444, 8)), t.writable && (c |= parseInt(333, 8), f |=
    parseInt(222, 8));
    var d = /* @__PURE__ */ n(function(g, b) {
      r.readlink(jr.join(e, g), function(D, x) {
        if (D) return m.destroy(D);
        b.linkname = AD(x), m.entry(b, p);
      });
    }, "onsymlink"), y = /* @__PURE__ */ n(function(g, b, D) {
      if (g) return m.destroy(g);
      if (!b)
        return t.finalize !== !1 && m.finalize(), h(m);
      if (D.isSocket()) return p();
      var x = {
        name: AD(b),
        mode: (D.mode | (D.isDirectory() ? c : f)) & l,
        mtime: D.mtime,
        size: D.size,
        type: "file",
        uid: D.uid,
        gid: D.gid
      };
      if (D.isDirectory())
        return x.size = 0, x.type = "directory", x = s(x) || x, m.entry(x, p);
      if (D.isSymbolicLink())
        return x.size = 0, x.type = "symlink", x = s(x) || x, d(b, x);
      if (x = s(x) || x, !D.isFile())
        return u ? m.destroy(new Error("unsupported type for " + b)) : p();
      var T = m.entry(x, p);
      if (T) {
        var w = a(r.createReadStream(jr.join(e, b), { start: 0, end: x.size > 0 ? x.size - 1 : x.size }), x);
        w.on("error", function(B) {
          T.destroy(B);
        }), I5(w, T);
      }
    }, "onstat"), p = /* @__PURE__ */ n(function(g) {
      if (g) return m.destroy(g);
      o(y);
    }, "onnextentry");
    return p(), m;
  };
  var nie = /* @__PURE__ */ n(function(e) {
    return e.length ? e[e.length - 1] : null;
  }, "head"), aie = /* @__PURE__ */ n(function() {
    return process.getuid ? process.getuid() : -1;
  }, "processGetuid"), B5 = /* @__PURE__ */ n(function() {
    return process.umask ? process.umask() : 0;
  }, "processUmask");
  PD.extract = function(e, t) {
    e || (e = "."), t || (t = {});
    var r = t.fs || O5, i = t.ignore || t.filter || wf, s = t.map || wf, a = t.mapStream || _D, o = t.chown !== !1 && !Cf && aie() === 0, u = t.
    extract || F5.extract(), l = [], c = /* @__PURE__ */ new Date(), f = typeof t.umask == "number" ? ~t.umask : ~B5(), m = typeof t.dmode ==
    "number" ? t.dmode : 0, h = typeof t.fmode == "number" ? t.fmode : 0, d = t.strict !== !1;
    t.strip && (s = k5(s, t.strip)), t.readable && (m |= parseInt(555, 8), h |= parseInt(444, 8)), t.writable && (m |= parseInt(333, 8), h |=
    parseInt(222, 8));
    var y = /* @__PURE__ */ n(function(b, D) {
      for (var x; (x = nie(l)) && b.slice(0, x[0].length) !== x[0]; ) l.pop();
      if (!x) return D();
      r.utimes(x[0], c, x[1], D);
    }, "utimesParent"), p = /* @__PURE__ */ n(function(b, D, x) {
      if (t.utimes === !1) return x();
      if (D.type === "directory") return r.utimes(b, c, D.mtime, x);
      if (D.type === "symlink") return y(b, x);
      r.utimes(b, c, D.mtime, function(T) {
        if (T) return x(T);
        y(b, x);
      });
    }, "utimes"), g = /* @__PURE__ */ n(function(b, D, x) {
      var T = D.type === "symlink", w = T ? r.lchmod : r.chmod, B = T ? r.lchown : r.chown;
      if (!w) return x();
      var k = (D.mode | (D.type === "directory" ? m : h)) & f;
      B && o ? B.call(r, b, D.uid, D.gid, q) : q(null);
      function q(V) {
        if (V) return x(V);
        if (!w) return x();
        w.call(r, b, k, x);
      }
      n(q, "onchown");
    }, "chperm");
    return u.on("entry", function(b, D, x) {
      b = s(b) || b, b.name = AD(b.name);
      var T = jr.join(e, jr.join("/", b.name));
      if (i(T, b))
        return D.resume(), x();
      var w = /* @__PURE__ */ n(function(Y) {
        if (Y) return x(Y);
        p(T, b, function(G) {
          if (G) return x(G);
          if (Cf) return x();
          g(T, b, x);
        });
      }, "stat"), B = /* @__PURE__ */ n(function() {
        if (Cf) return x();
        r.unlink(T, function() {
          var Y = jr.resolve(jr.dirname(T), b.linkname);
          if (!Y.startsWith(jr.resolve(e))) return x(new Error(T + " is not a valid symlink"));
          r.symlink(b.linkname, T, w);
        });
      }, "onsymlink"), k = /* @__PURE__ */ n(function() {
        if (Cf) return x();
        r.unlink(T, function() {
          var Y = jr.join(e, jr.join("/", b.linkname));
          r.link(Y, T, function(G) {
            if (G && G.code === "EPERM" && t.hardlinkAsFilesFallback)
              return D = r.createReadStream(Y), q();
            w(G);
          });
        });
      }, "onlink"), q = /* @__PURE__ */ n(function() {
        var Y = r.createWriteStream(T), G = a(D, b);
        Y.on("error", function(ye) {
          G.destroy(ye);
        }), I5(G, Y, function(ye) {
          if (ye) return x(ye);
          Y.on("close", w);
        });
      }, "onfile");
      if (b.type === "directory")
        return l.push([T, b.mtime]), P5(T, {
          fs: r,
          own: o,
          uid: b.uid,
          gid: b.gid
        }, w);
      var V = jr.dirname(T);
      N5(r, V, jr.join(e, "."), function(Y, G) {
        if (Y) return x(Y);
        if (!G) return x(new Error(V + " is not a valid path"));
        P5(V, {
          fs: r,
          own: o,
          uid: b.uid,
          gid: b.gid
        }, function(ye) {
          if (ye) return x(ye);
          switch (b.type) {
            case "file":
              return q();
            case "link":
              return k();
            case "symlink":
              return B();
          }
          if (d) return x(new Error("unsupported type for " + T + " (" + b.type + ")"));
          D.resume(), x();
        });
      });
    }), t.finish && u.on("finish", t.finish), u;
  };
  function N5(e, t, r, i) {
    if (t === r) return i(null, !0);
    e.lstat(t, function(s, a) {
      if (s && s.code !== "ENOENT") return i(s);
      if (s || a.isDirectory()) return N5(e, jr.join(t, ".."), r, i);
      i(null, !1);
    });
  }
  n(N5, "validate");
  function P5(e, t, r) {
    rie(e, { fs: t.fs }, function(i, s) {
      !i && s && t.own ? tie(s, t.uid, t.gid, r) : r(i);
    });
  }
  n(P5, "mkdirfix");
});

// ../node_modules/process-nextick-args/index.js
var Ei = E((Oit, FD) => {
  "use strict";
  typeof process > "u" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.
  indexOf("v1.8.") !== 0 ? FD.exports = { nextTick: oie } : FD.exports = process;
  function oie(e, t, r, i) {
    if (typeof e != "function")
      throw new TypeError('"callback" argument must be a function');
    var s = arguments.length, a, o;
    switch (s) {
      case 0:
      case 1:
        return process.nextTick(e);
      case 2:
        return process.nextTick(/* @__PURE__ */ n(function() {
          e.call(null, t);
        }, "afterTickOne"));
      case 3:
        return process.nextTick(/* @__PURE__ */ n(function() {
          e.call(null, t, r);
        }, "afterTickTwo"));
      case 4:
        return process.nextTick(/* @__PURE__ */ n(function() {
          e.call(null, t, r, i);
        }, "afterTickThree"));
      default:
        for (a = new Array(s - 1), o = 0; o < a.length; )
          a[o++] = arguments[o];
        return process.nextTick(/* @__PURE__ */ n(function() {
          e.apply(null, a);
        }, "afterTick"));
    }
  }
  n(oie, "nextTick");
});

// ../node_modules/peek-stream/node_modules/isarray/index.js
var L5 = E((Bit, R5) => {
  var uie = {}.toString;
  R5.exports = Array.isArray || function(e) {
    return uie.call(e) == "[object Array]";
  };
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/internal/streams/stream.js
var ID = E((Nit, j5) => {
  j5.exports = require("stream");
});

// ../node_modules/peek-stream/node_modules/safe-buffer/index.js
var c0 = E((OD, U5) => {
  var l0 = require("buffer"), Sn = l0.Buffer;
  function q5(e, t) {
    for (var r in e)
      t[r] = e[r];
  }
  n(q5, "copyProps");
  Sn.from && Sn.alloc && Sn.allocUnsafe && Sn.allocUnsafeSlow ? U5.exports = l0 : (q5(l0, OD), OD.Buffer = ol);
  function ol(e, t, r) {
    return Sn(e, t, r);
  }
  n(ol, "SafeBuffer");
  q5(Sn, ol);
  ol.from = function(e, t, r) {
    if (typeof e == "number")
      throw new TypeError("Argument must not be a number");
    return Sn(e, t, r);
  };
  ol.alloc = function(e, t, r) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    var i = Sn(e);
    return t !== void 0 ? typeof r == "string" ? i.fill(t, r) : i.fill(t) : i.fill(0), i;
  };
  ol.allocUnsafe = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return Sn(e);
  };
  ol.allocUnsafeSlow = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return l0.SlowBuffer(e);
  };
});

// ../node_modules/core-util-is/lib/util.js
var dr = E((qr) => {
  function lie(e) {
    return Array.isArray ? Array.isArray(e) : f0(e) === "[object Array]";
  }
  n(lie, "isArray");
  qr.isArray = lie;
  function cie(e) {
    return typeof e == "boolean";
  }
  n(cie, "isBoolean");
  qr.isBoolean = cie;
  function fie(e) {
    return e === null;
  }
  n(fie, "isNull");
  qr.isNull = fie;
  function die(e) {
    return e == null;
  }
  n(die, "isNullOrUndefined");
  qr.isNullOrUndefined = die;
  function pie(e) {
    return typeof e == "number";
  }
  n(pie, "isNumber");
  qr.isNumber = pie;
  function hie(e) {
    return typeof e == "string";
  }
  n(hie, "isString");
  qr.isString = hie;
  function mie(e) {
    return typeof e == "symbol";
  }
  n(mie, "isSymbol");
  qr.isSymbol = mie;
  function yie(e) {
    return e === void 0;
  }
  n(yie, "isUndefined");
  qr.isUndefined = yie;
  function gie(e) {
    return f0(e) === "[object RegExp]";
  }
  n(gie, "isRegExp");
  qr.isRegExp = gie;
  function bie(e) {
    return typeof e == "object" && e !== null;
  }
  n(bie, "isObject");
  qr.isObject = bie;
  function Die(e) {
    return f0(e) === "[object Date]";
  }
  n(Die, "isDate");
  qr.isDate = Die;
  function vie(e) {
    return f0(e) === "[object Error]" || e instanceof Error;
  }
  n(vie, "isError");
  qr.isError = vie;
  function xie(e) {
    return typeof e == "function";
  }
  n(xie, "isFunction");
  qr.isFunction = xie;
  function Eie(e) {
    return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || // ES6 symbol
    typeof e > "u";
  }
  n(Eie, "isPrimitive");
  qr.isPrimitive = Eie;
  qr.isBuffer = require("buffer").Buffer.isBuffer;
  function f0(e) {
    return Object.prototype.toString.call(e);
  }
  n(f0, "objectToString");
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/internal/streams/BufferList.js
var V5 = E((jit, kD) => {
  "use strict";
  function Sie(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  n(Sie, "_classCallCheck");
  var $5 = c0().Buffer, Af = require("util");
  function Tie(e, t, r) {
    e.copy(t, r);
  }
  n(Tie, "copyBuffer");
  kD.exports = function() {
    function e() {
      Sie(this, e), this.head = null, this.tail = null, this.length = 0;
    }
    return n(e, "BufferList"), e.prototype.push = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: null };
      this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
    }, "push"), e.prototype.unshift = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: this.head };
      this.length === 0 && (this.tail = i), this.head = i, ++this.length;
    }, "unshift"), e.prototype.shift = /* @__PURE__ */ n(function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    }, "shift"), e.prototype.clear = /* @__PURE__ */ n(function() {
      this.head = this.tail = null, this.length = 0;
    }, "clear"), e.prototype.join = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return "";
      for (var i = this.head, s = "" + i.data; i = i.next; )
        s += r + i.data;
      return s;
    }, "join"), e.prototype.concat = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return $5.alloc(0);
      for (var i = $5.allocUnsafe(r >>> 0), s = this.head, a = 0; s; )
        Tie(s.data, i, a), a += s.data.length, s = s.next;
      return i;
    }, "concat"), e;
  }();
  Af && Af.inspect && Af.inspect.custom && (kD.exports.prototype[Af.inspect.custom] = function() {
    var e = Af.inspect({ length: this.length });
    return this.constructor.name + " " + e;
  });
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
var BD = E((Uit, W5) => {
  "use strict";
  var d0 = Ei();
  function Cie(e, t) {
    var r = this, i = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return i || s ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, d0.nextTick(
    p0, this, e)) : d0.nextTick(p0, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this.
    _writableState.destroyed = !0), this._destroy(e || null, function(a) {
      !t && a ? r._writableState ? r._writableState.errorEmitted || (r._writableState.errorEmitted = !0, d0.nextTick(p0, r, a)) : d0.nextTick(
      p0, r, a) : t && t(a);
    }), this);
  }
  n(Cie, "destroy");
  function wie() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.
    endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending =
    !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted =
    !1);
  }
  n(wie, "undestroy");
  function p0(e, t) {
    e.emit("error", t);
  }
  n(p0, "emitErrorNT");
  W5.exports = {
    destroy: Cie,
    undestroy: wie
  };
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/_stream_writable.js
var MD = E((Vit, Z5) => {
  "use strict";
  var vo = Ei();
  Z5.exports = nr;
  function K5(e) {
    var t = this;
    this.next = null, this.entry = null, this.finish = function() {
      Wie(t, e);
    };
  }
  n(K5, "CorkedRequest");
  var Aie = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : vo.nextTick, ul;
  nr.WritableState = Pf;
  var z5 = Object.create(dr());
  z5.inherits = St();
  var _ie = {
    deprecate: df()
  }, J5 = ID(), m0 = c0().Buffer, Pie = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array ||
  function() {
  };
  function Fie(e) {
    return m0.from(e);
  }
  n(Fie, "_uint8ArrayToBuffer");
  function Iie(e) {
    return m0.isBuffer(e) || e instanceof Pie;
  }
  n(Iie, "_isUint8Array");
  var X5 = BD();
  z5.inherits(nr, J5);
  function Oie() {
  }
  n(Oie, "nop");
  function Pf(e, t) {
    ul = ul || xo(), e = e || {};
    var r = t instanceof ul;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode);
    var i = e.highWaterMark, s = e.writableHighWaterMark, a = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = a, this.highWaterMark = Math.
    floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed =
    !1;
    var o = e.decodeStrings === !1;
    this.decodeStrings = !o, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync =
    !0, this.bufferProcessing = !1, this.onwrite = function(u) {
      jie(t, u);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished =
    !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new K5(this);
  }
  n(Pf, "WritableState");
  Pf.prototype.getBuffer = /* @__PURE__ */ n(function() {
    for (var t = this.bufferedRequest, r = []; t; )
      r.push(t), t = t.next;
    return r;
  }, "getBuffer");
  (function() {
    try {
      Object.defineProperty(Pf.prototype, "buffer", {
        get: _ie.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var h0;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (h0 = Function.prototype[Symbol.
  hasInstance], Object.defineProperty(nr, Symbol.hasInstance, {
    value: /* @__PURE__ */ n(function(e) {
      return h0.call(this, e) ? !0 : this !== nr ? !1 : e && e._writableState instanceof Pf;
    }, "value")
  })) : h0 = /* @__PURE__ */ n(function(e) {
    return e instanceof this;
  }, "realHasInstance");
  function nr(e) {
    if (ul = ul || xo(), !h0.call(nr, this) && !(this instanceof ul))
      return new nr(e);
    this._writableState = new Pf(e, this), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev ==
    "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this.
    _final = e.final)), J5.call(this);
  }
  n(nr, "Writable");
  nr.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function kie(e, t) {
    var r = new Error("write after end");
    e.emit("error", r), vo.nextTick(t, r);
  }
  n(kie, "writeAfterEnd");
  function Bie(e, t, r, i) {
    var s = !0, a = !1;
    return r === null ? a = new TypeError("May not write null values to stream") : typeof r != "string" && r !== void 0 && !t.objectMode && (a =
    new TypeError("Invalid non-string/buffer chunk")), a && (e.emit("error", a), vo.nextTick(i, a), s = !1), s;
  }
  n(Bie, "validChunk");
  nr.prototype.write = function(e, t, r) {
    var i = this._writableState, s = !1, a = !i.objectMode && Iie(e);
    return a && !m0.isBuffer(e) && (e = Fie(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding),
    typeof r != "function" && (r = Oie), i.ended ? kie(this, r) : (a || Bie(this, i, e, r)) && (i.pendingcb++, s = Mie(this, i, a, e, t, r)),
    s;
  };
  nr.prototype.cork = function() {
    var e = this._writableState;
    e.corked++;
  };
  nr.prototype.uncork = function() {
    var e = this._writableState;
    e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Y5(this, e));
  };
  nr.prototype.setDefaultEncoding = /* @__PURE__ */ n(function(t) {
    if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "\
utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + t);
    return this._writableState.defaultEncoding = t, this;
  }, "setDefaultEncoding");
  function Nie(e, t, r) {
    return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = m0.from(t, r)), t;
  }
  n(Nie, "decodeChunk");
  Object.defineProperty(nr.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function Mie(e, t, r, i, s, a) {
    if (!r) {
      var o = Nie(t, i, s);
      i !== o && (r = !0, s = "buffer", i = o);
    }
    var u = t.objectMode ? 1 : i.length;
    t.length += u;
    var l = t.length < t.highWaterMark;
    if (l || (t.needDrain = !0), t.writing || t.corked) {
      var c = t.lastBufferedRequest;
      t.lastBufferedRequest = {
        chunk: i,
        encoding: s,
        isBuf: r,
        callback: a,
        next: null
      }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
    } else
      ND(e, t, !1, u, i, s, a);
    return l;
  }
  n(Mie, "writeOrBuffer");
  function ND(e, t, r, i, s, a, o) {
    t.writelen = i, t.writecb = o, t.writing = !0, t.sync = !0, r ? e._writev(s, t.onwrite) : e._write(s, a, t.onwrite), t.sync = !1;
  }
  n(ND, "doWrite");
  function Rie(e, t, r, i, s) {
    --t.pendingcb, r ? (vo.nextTick(s, i), vo.nextTick(_f, e, t), e._writableState.errorEmitted = !0, e.emit("error", i)) : (s(i), e._writableState.
    errorEmitted = !0, e.emit("error", i), _f(e, t));
  }
  n(Rie, "onwriteError");
  function Lie(e) {
    e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
  }
  n(Lie, "onwriteStateUpdate");
  function jie(e, t) {
    var r = e._writableState, i = r.sync, s = r.writecb;
    if (Lie(r), t) Rie(e, r, i, t, s);
    else {
      var a = G5(r);
      !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && Y5(e, r), i ? Aie(H5, e, r, a, s) : H5(e, r, a, s);
    }
  }
  n(jie, "onwrite");
  function H5(e, t, r, i) {
    r || qie(e, t), t.pendingcb--, i(), _f(e, t);
  }
  n(H5, "afterWrite");
  function qie(e, t) {
    t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
  }
  n(qie, "onwriteDrain");
  function Y5(e, t) {
    t.bufferProcessing = !0;
    var r = t.bufferedRequest;
    if (e._writev && r && r.next) {
      var i = t.bufferedRequestCount, s = new Array(i), a = t.corkedRequestsFree;
      a.entry = r;
      for (var o = 0, u = !0; r; )
        s[o] = r, r.isBuf || (u = !1), r = r.next, o += 1;
      s.allBuffers = u, ND(e, t, !0, t.length, s, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree =
      a.next, a.next = null) : t.corkedRequestsFree = new K5(t), t.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var l = r.chunk, c = r.encoding, f = r.callback, m = t.objectMode ? 1 : l.length;
        if (ND(e, t, !1, m, l, c, f), r = r.next, t.bufferedRequestCount--, t.writing)
          break;
      }
      r === null && (t.lastBufferedRequest = null);
    }
    t.bufferedRequest = r, t.bufferProcessing = !1;
  }
  n(Y5, "clearBuffer");
  nr.prototype._write = function(e, t, r) {
    r(new Error("_write() is not implemented"));
  };
  nr.prototype._writev = null;
  nr.prototype.end = function(e, t, r) {
    var i = this._writableState;
    typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked &&
    (i.corked = 1, this.uncork()), i.ending || Vie(this, i, r);
  };
  function G5(e) {
    return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
  }
  n(G5, "needFinish");
  function Uie(e, t) {
    e._final(function(r) {
      t.pendingcb--, r && e.emit("error", r), t.prefinished = !0, e.emit("prefinish"), _f(e, t);
    });
  }
  n(Uie, "callFinal");
  function $ie(e, t) {
    !t.prefinished && !t.finalCalled && (typeof e._final == "function" ? (t.pendingcb++, t.finalCalled = !0, vo.nextTick(Uie, e, t)) : (t.prefinished =
    !0, e.emit("prefinish")));
  }
  n($ie, "prefinish");
  function _f(e, t) {
    var r = G5(t);
    return r && ($ie(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"))), r;
  }
  n(_f, "finishMaybe");
  function Vie(e, t, r) {
    t.ending = !0, _f(e, t), r && (t.finished ? vo.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
  }
  n(Vie, "endWritable");
  function Wie(e, t, r) {
    var i = e.entry;
    for (e.entry = null; i; ) {
      var s = i.callback;
      t.pendingcb--, s(r), i = i.next;
    }
    t.corkedRequestsFree.next = e;
  }
  n(Wie, "onCorkedFinish");
  Object.defineProperty(nr.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._writableState && (this._writableState.destroyed = e);
    }, "set")
  });
  nr.prototype.destroy = X5.destroy;
  nr.prototype._undestroy = X5.undestroy;
  nr.prototype._destroy = function(e, t) {
    this.end(), t(e);
  };
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/_stream_duplex.js
var xo = E((Hit, r7) => {
  "use strict";
  var Q5 = Ei(), Hie = Object.keys || function(e) {
    var t = [];
    for (var r in e)
      t.push(r);
    return t;
  };
  r7.exports = Tn;
  var e7 = Object.create(dr());
  e7.inherits = St();
  var t7 = jD(), LD = MD();
  e7.inherits(Tn, t7);
  for (RD = Hie(LD.prototype), y0 = 0; y0 < RD.length; y0++)
    g0 = RD[y0], Tn.prototype[g0] || (Tn.prototype[g0] = LD.prototype[g0]);
  var RD, g0, y0;
  function Tn(e) {
    if (!(this instanceof Tn)) return new Tn(e);
    t7.call(this, e), LD.call(this, e), e && e.readable === !1 && (this.readable = !1), e && e.writable === !1 && (this.writable = !1), this.
    allowHalfOpen = !0, e && e.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", Kie);
  }
  n(Tn, "Duplex");
  Object.defineProperty(Tn.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function Kie() {
    this.allowHalfOpen || this._writableState.ended || Q5.nextTick(zie, this);
  }
  n(Kie, "onend");
  function zie(e) {
    e.end();
  }
  n(zie, "onEndNT");
  Object.defineProperty(Tn.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed =
      e);
    }, "set")
  });
  Tn.prototype._destroy = function(e, t) {
    this.push(null), this.end(), Q5.nextTick(t, e);
  };
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/_stream_readable.js
var jD = E((Jit, h7) => {
  "use strict";
  var cl = Ei();
  h7.exports = Pt;
  var Jie = L5(), Ff;
  Pt.ReadableState = l7;
  var zit = require("events").EventEmitter, a7 = /* @__PURE__ */ n(function(e, t) {
    return e.listeners(t).length;
  }, "EElistenerCount"), WD = ID(), If = c0().Buffer, Xie = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ?
  self : {}).Uint8Array || function() {
  };
  function Yie(e) {
    return If.from(e);
  }
  n(Yie, "_uint8ArrayToBuffer");
  function Gie(e) {
    return If.isBuffer(e) || e instanceof Xie;
  }
  n(Gie, "_isUint8Array");
  var o7 = Object.create(dr());
  o7.inherits = St();
  var qD = require("util"), ct = void 0;
  qD && qD.debuglog ? ct = qD.debuglog("stream") : ct = /* @__PURE__ */ n(function() {
  }, "debug");
  var Zie = V5(), u7 = BD(), ll;
  o7.inherits(Pt, WD);
  var UD = ["error", "close", "destroy", "pause", "resume"];
  function Qie(e, t, r) {
    if (typeof e.prependListener == "function") return e.prependListener(t, r);
    !e._events || !e._events[t] ? e.on(t, r) : Jie(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
  }
  n(Qie, "prependListener");
  function l7(e, t) {
    Ff = Ff || xo(), e = e || {};
    var r = t instanceof Ff;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode);
    var i = e.highWaterMark, s = e.readableHighWaterMark, a = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = a, this.highWaterMark = Math.
    floor(this.highWaterMark), this.buffer = new Zie(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended =
    !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening =
    !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore =
    !1, this.decoder = null, this.encoding = null, e.encoding && (ll || (ll = require("string_decoder/").StringDecoder), this.decoder = new ll(
    e.encoding), this.encoding = e.encoding);
  }
  n(l7, "ReadableState");
  function Pt(e) {
    if (Ff = Ff || xo(), !(this instanceof Pt)) return new Pt(e);
    this._readableState = new l7(e, this), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy ==
    "function" && (this._destroy = e.destroy)), WD.call(this);
  }
  n(Pt, "Readable");
  Object.defineProperty(Pt.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState && (this._readableState.destroyed = e);
    }, "set")
  });
  Pt.prototype.destroy = u7.destroy;
  Pt.prototype._undestroy = u7.undestroy;
  Pt.prototype._destroy = function(e, t) {
    this.push(null), t(e);
  };
  Pt.prototype.push = function(e, t) {
    var r = this._readableState, i;
    return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = If.from(e, t), t = ""), i =
    !0), c7(this, e, t, !1, i);
  };
  Pt.prototype.unshift = function(e) {
    return c7(this, e, null, !0, !1);
  };
  function c7(e, t, r, i, s) {
    var a = e._readableState;
    if (t === null)
      a.reading = !1, ise(e, a);
    else {
      var o;
      s || (o = ese(a, t)), o ? e.emit("error", o) : a.objectMode || t && t.length > 0 ? (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(
      t) !== If.prototype && (t = Yie(t)), i ? a.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : $D(e, a, t, !0) :
      a.ended ? e.emit("error", new Error("stream.push() after EOF")) : (a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode ||
      t.length !== 0 ? $D(e, a, t, !1) : f7(e, a)) : $D(e, a, t, !1))) : i || (a.reading = !1);
    }
    return tse(a);
  }
  n(c7, "readableAddChunk");
  function $D(e, t, r, i) {
    t.flowing && t.length === 0 && !t.sync ? (e.emit("data", r), e.read(0)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(
    r) : t.buffer.push(r), t.needReadable && b0(e)), f7(e, t);
  }
  n($D, "addChunk");
  function ese(e, t) {
    var r;
    return !Gie(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new TypeError("Invalid non-string/buffer chunk")), r;
  }
  n(ese, "chunkInvalid");
  function tse(e) {
    return !e.ended && (e.needReadable || e.length < e.highWaterMark || e.length === 0);
  }
  n(tse, "needMoreData");
  Pt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  };
  Pt.prototype.setEncoding = function(e) {
    return ll || (ll = require("string_decoder/").StringDecoder), this._readableState.decoder = new ll(e), this._readableState.encoding = e,
    this;
  };
  var i7 = 8388608;
  function rse(e) {
    return e >= i7 ? e = i7 : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
  }
  n(rse, "computeNewHighWaterMark");
  function s7(e, t) {
    return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length :
    (e > t.highWaterMark && (t.highWaterMark = rse(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
  }
  n(s7, "howMuchToRead");
  Pt.prototype.read = function(e) {
    ct("read", e), e = parseInt(e, 10);
    var t = this._readableState, r = e;
    if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && (t.length >= t.highWaterMark || t.ended))
      return ct("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? VD(this) : b0(this), null;
    if (e = s7(e, t), e === 0 && t.ended)
      return t.length === 0 && VD(this), null;
    var i = t.needReadable;
    ct("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, ct("length less than watermark", i)), t.ended || t.
    reading ? (i = !1, ct("reading or ended", i)) : i && (ct("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0),
    this._read(t.highWaterMark), t.sync = !1, t.reading || (e = s7(r, t)));
    var s;
    return e > 0 ? s = d7(e, t) : s = null, s === null ? (t.needReadable = !0, e = 0) : t.length -= e, t.length === 0 && (t.ended || (t.needReadable =
    !0), r !== e && t.ended && VD(this)), s !== null && this.emit("data", s), s;
  };
  function ise(e, t) {
    if (!t.ended) {
      if (t.decoder) {
        var r = t.decoder.end();
        r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
      }
      t.ended = !0, b0(e);
    }
  }
  n(ise, "onEofChunk");
  function b0(e) {
    var t = e._readableState;
    t.needReadable = !1, t.emittedReadable || (ct("emitReadable", t.flowing), t.emittedReadable = !0, t.sync ? cl.nextTick(n7, e) : n7(e));
  }
  n(b0, "emitReadable");
  function n7(e) {
    ct("emit readable"), e.emit("readable"), HD(e);
  }
  n(n7, "emitReadable_");
  function f7(e, t) {
    t.readingMore || (t.readingMore = !0, cl.nextTick(sse, e, t));
  }
  n(f7, "maybeReadMore");
  function sse(e, t) {
    for (var r = t.length; !t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark && (ct("maybeReadMore read 0"), e.read(0), r !==
    t.length); )
      r = t.length;
    t.readingMore = !1;
  }
  n(sse, "maybeReadMore_");
  Pt.prototype._read = function(e) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Pt.prototype.pipe = function(e, t) {
    var r = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = e;
        break;
      case 1:
        i.pipes = [i.pipes, e];
        break;
      default:
        i.pipes.push(e);
        break;
    }
    i.pipesCount += 1, ct("pipe count=%d opts=%j", i.pipesCount, t);
    var s = (!t || t.end !== !1) && e !== process.stdout && e !== process.stderr, a = s ? u : g;
    i.endEmitted ? cl.nextTick(a) : r.once("end", a), e.on("unpipe", o);
    function o(b, D) {
      ct("onunpipe"), b === r && D && D.hasUnpiped === !1 && (D.hasUnpiped = !0, f());
    }
    n(o, "onunpipe");
    function u() {
      ct("onend"), e.end();
    }
    n(u, "onend");
    var l = nse(r);
    e.on("drain", l);
    var c = !1;
    function f() {
      ct("cleanup"), e.removeListener("close", y), e.removeListener("finish", p), e.removeListener("drain", l), e.removeListener("error", d),
      e.removeListener("unpipe", o), r.removeListener("end", u), r.removeListener("end", g), r.removeListener("data", h), c = !0, i.awaitDrain &&
      (!e._writableState || e._writableState.needDrain) && l();
    }
    n(f, "cleanup");
    var m = !1;
    r.on("data", h);
    function h(b) {
      ct("ondata"), m = !1;
      var D = e.write(b);
      D === !1 && !m && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && p7(i.pipes, e) !== -1) && !c && (ct("false write respon\
se, pause", i.awaitDrain), i.awaitDrain++, m = !0), r.pause());
    }
    n(h, "ondata");
    function d(b) {
      ct("onerror", b), g(), e.removeListener("error", d), a7(e, "error") === 0 && e.emit("error", b);
    }
    n(d, "onerror"), Qie(e, "error", d);
    function y() {
      e.removeListener("finish", p), g();
    }
    n(y, "onclose"), e.once("close", y);
    function p() {
      ct("onfinish"), e.removeListener("close", y), g();
    }
    n(p, "onfinish"), e.once("finish", p);
    function g() {
      ct("unpipe"), r.unpipe(e);
    }
    return n(g, "unpipe"), e.emit("pipe", r), i.flowing || (ct("pipe resume"), r.resume()), e;
  };
  function nse(e) {
    return function() {
      var t = e._readableState;
      ct("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, t.awaitDrain === 0 && a7(e, "data") && (t.flowing = !0, HD(e));
    };
  }
  n(nse, "pipeOnDrain");
  Pt.prototype.unpipe = function(e) {
    var t = this._readableState, r = { hasUnpiped: !1 };
    if (t.pipesCount === 0) return this;
    if (t.pipesCount === 1)
      return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r),
      this);
    if (!e) {
      var i = t.pipes, s = t.pipesCount;
      t.pipes = null, t.pipesCount = 0, t.flowing = !1;
      for (var a = 0; a < s; a++)
        i[a].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var o = p7(t.pipes, e);
    return o === -1 ? this : (t.pipes.splice(o, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r),
    this);
  };
  Pt.prototype.on = function(e, t) {
    var r = WD.prototype.on.call(this, e, t);
    if (e === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (e === "readable") {
      var i = this._readableState;
      !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.emittedReadable = !1, i.reading ? i.length && b0(
      this) : cl.nextTick(ase, this));
    }
    return r;
  };
  Pt.prototype.addListener = Pt.prototype.on;
  function ase(e) {
    ct("readable nexttick read 0"), e.read(0);
  }
  n(ase, "nReadingNextTick");
  Pt.prototype.resume = function() {
    var e = this._readableState;
    return e.flowing || (ct("resume"), e.flowing = !0, ose(this, e)), this;
  };
  function ose(e, t) {
    t.resumeScheduled || (t.resumeScheduled = !0, cl.nextTick(use, e, t));
  }
  n(ose, "resume");
  function use(e, t) {
    t.reading || (ct("resume read 0"), e.read(0)), t.resumeScheduled = !1, t.awaitDrain = 0, e.emit("resume"), HD(e), t.flowing && !t.reading &&
    e.read(0);
  }
  n(use, "resume_");
  Pt.prototype.pause = function() {
    return ct("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ct("pause"), this._readableState.
    flowing = !1, this.emit("pause")), this;
  };
  function HD(e) {
    var t = e._readableState;
    for (ct("flow", t.flowing); t.flowing && e.read() !== null; )
      ;
  }
  n(HD, "flow");
  Pt.prototype.wrap = function(e) {
    var t = this, r = this._readableState, i = !1;
    e.on("end", function() {
      if (ct("wrapped end"), r.decoder && !r.ended) {
        var o = r.decoder.end();
        o && o.length && t.push(o);
      }
      t.push(null);
    }), e.on("data", function(o) {
      if (ct("wrapped data"), r.decoder && (o = r.decoder.write(o)), !(r.objectMode && o == null) && !(!r.objectMode && (!o || !o.length))) {
        var u = t.push(o);
        u || (i = !0, e.pause());
      }
    });
    for (var s in e)
      this[s] === void 0 && typeof e[s] == "function" && (this[s] = /* @__PURE__ */ function(o) {
        return function() {
          return e[o].apply(e, arguments);
        };
      }(s));
    for (var a = 0; a < UD.length; a++)
      e.on(UD[a], this.emit.bind(this, UD[a]));
    return this._read = function(o) {
      ct("wrapped _read", o), i && (i = !1, e.resume());
    }, this;
  };
  Object.defineProperty(Pt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.highWaterMark;
    }, "get")
  });
  Pt._fromList = d7;
  function d7(e, t) {
    if (t.length === 0) return null;
    var r;
    return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.
    head.data : r = t.buffer.concat(t.length), t.buffer.clear()) : r = lse(e, t.buffer, t.decoder), r;
  }
  n(d7, "fromList");
  function lse(e, t, r) {
    var i;
    return e < t.head.data.length ? (i = t.head.data.slice(0, e), t.head.data = t.head.data.slice(e)) : e === t.head.data.length ? i = t.shift() :
    i = r ? cse(e, t) : fse(e, t), i;
  }
  n(lse, "fromListPartial");
  function cse(e, t) {
    var r = t.head, i = 1, s = r.data;
    for (e -= s.length; r = r.next; ) {
      var a = r.data, o = e > a.length ? a.length : e;
      if (o === a.length ? s += a : s += a.slice(0, e), e -= o, e === 0) {
        o === a.length ? (++i, r.next ? t.head = r.next : t.head = t.tail = null) : (t.head = r, r.data = a.slice(o));
        break;
      }
      ++i;
    }
    return t.length -= i, s;
  }
  n(cse, "copyFromBufferString");
  function fse(e, t) {
    var r = If.allocUnsafe(e), i = t.head, s = 1;
    for (i.data.copy(r), e -= i.data.length; i = i.next; ) {
      var a = i.data, o = e > a.length ? a.length : e;
      if (a.copy(r, r.length - e, 0, o), e -= o, e === 0) {
        o === a.length ? (++s, i.next ? t.head = i.next : t.head = t.tail = null) : (t.head = i, i.data = a.slice(o));
        break;
      }
      ++s;
    }
    return t.length -= s, r;
  }
  n(fse, "copyFromBuffer");
  function VD(e) {
    var t = e._readableState;
    if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    t.endEmitted || (t.ended = !0, cl.nextTick(dse, t, e));
  }
  n(VD, "endReadable");
  function dse(e, t) {
    !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"));
  }
  n(dse, "endReadableNT");
  function p7(e, t) {
    for (var r = 0, i = e.length; r < i; r++)
      if (e[r] === t) return r;
    return -1;
  }
  n(p7, "indexOf");
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/_stream_transform.js
var KD = E((Yit, g7) => {
  "use strict";
  g7.exports = Cn;
  var D0 = xo(), y7 = Object.create(dr());
  y7.inherits = St();
  y7.inherits(Cn, D0);
  function pse(e, t) {
    var r = this._transformState;
    r.transforming = !1;
    var i = r.writecb;
    if (!i)
      return this.emit("error", new Error("write callback called multiple times"));
    r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
    var s = this._readableState;
    s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
  n(pse, "afterTransform");
  function Cn(e) {
    if (!(this instanceof Cn)) return new Cn(e);
    D0.call(this, e), this._transformState = {
      afterTransform: pse.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.
    transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", hse);
  }
  n(Cn, "Transform");
  function hse() {
    var e = this;
    typeof this._flush == "function" ? this._flush(function(t, r) {
      m7(e, t, r);
    }) : m7(this, null, null);
  }
  n(hse, "prefinish");
  Cn.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, D0.prototype.push.call(this, e, t);
  };
  Cn.prototype._transform = function(e, t, r) {
    throw new Error("_transform() is not implemented");
  };
  Cn.prototype._write = function(e, t, r) {
    var i = this._transformState;
    if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
      var s = this._readableState;
      (i.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
    }
  };
  Cn.prototype._read = function(e) {
    var t = this._transformState;
    t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) :
    t.needTransform = !0;
  };
  Cn.prototype._destroy = function(e, t) {
    var r = this;
    D0.prototype._destroy.call(this, e, function(i) {
      t(i), r.emit("close");
    });
  };
  function m7(e, t, r) {
    if (t) return e.emit("error", t);
    if (r != null && e.push(r), e._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (e._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return e.push(null);
  }
  n(m7, "done");
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/_stream_passthrough.js
var x7 = E((Zit, v7) => {
  "use strict";
  v7.exports = Of;
  var b7 = KD(), D7 = Object.create(dr());
  D7.inherits = St();
  D7.inherits(Of, b7);
  function Of(e) {
    if (!(this instanceof Of)) return new Of(e);
    b7.call(this, e);
  }
  n(Of, "PassThrough");
  Of.prototype._transform = function(e, t, r) {
    r(null, e);
  };
});

// ../node_modules/peek-stream/node_modules/readable-stream/readable.js
var E7 = E((Ar, v0) => {
  var Vs = require("stream");
  process.env.READABLE_STREAM === "disable" && Vs ? (v0.exports = Vs, Ar = v0.exports = Vs.Readable, Ar.Readable = Vs.Readable, Ar.Writable =
  Vs.Writable, Ar.Duplex = Vs.Duplex, Ar.Transform = Vs.Transform, Ar.PassThrough = Vs.PassThrough, Ar.Stream = Vs) : (Ar = v0.exports = jD(),
  Ar.Stream = Vs || Ar, Ar.Readable = Ar, Ar.Writable = MD(), Ar.Duplex = xo(), Ar.Transform = KD(), Ar.PassThrough = x7());
});

// ../node_modules/stream-shift/index.js
var zD = E((est, S7) => {
  S7.exports = mse;
  function mse(e) {
    var t = e._readableState;
    return t ? t.objectMode || typeof e._duplexState == "number" ? e.read() : e.read(yse(t)) : null;
  }
  n(mse, "shift");
  function yse(e) {
    if (e.buffer.length) {
      var t = e.bufferIndex || 0;
      if (e.buffer.head)
        return e.buffer.head.data.length;
      if (e.buffer.length - t > 0 && e.buffer[t])
        return e.buffer[t].length;
    }
    return e.length;
  }
  n(yse, "getStateLength");
});

// ../node_modules/peek-stream/node_modules/duplexify/index.js
var _7 = E((rst, A7) => {
  var x0 = E7(), T7 = Yu(), gse = St(), bse = zD(), C7 = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]),
  JD = /* @__PURE__ */ n(function(e, t) {
    e._corked ? e.once("uncork", t) : t();
  }, "onuncork"), Dse = /* @__PURE__ */ n(function(e, t) {
    e._autoDestroy && e.destroy(t);
  }, "autoDestroy"), w7 = /* @__PURE__ */ n(function(e, t) {
    return function(r) {
      r ? Dse(e, r.message === "premature close" ? null : r) : t && !e._ended && e.end();
    };
  }, "destroyer"), vse = /* @__PURE__ */ n(function(e, t) {
    if (!e || e._writableState && e._writableState.finished) return t();
    if (e._writableState) return e.end(t);
    e.end(), t();
  }, "end"), xse = /* @__PURE__ */ n(function(e) {
    return new x0.Readable({ objectMode: !0, highWaterMark: 16 }).wrap(e);
  }, "toStreams2"), _r = /* @__PURE__ */ n(function(e, t, r) {
    if (!(this instanceof _r)) return new _r(e, t, r);
    x0.Duplex.call(this, r), this._writable = null, this._readable = null, this._readable2 = null, this._autoDestroy = !r || r.autoDestroy !==
    !1, this._forwardDestroy = !r || r.destroy !== !1, this._forwardEnd = !r || r.end !== !1, this._corked = 1, this._ondrain = null, this._drained =
    !1, this._forwarding = !1, this._unwrite = null, this._unread = null, this._ended = !1, this.destroyed = !1, e && this.setWritable(e), t &&
    this.setReadable(t);
  }, "Duplexify");
  gse(_r, x0.Duplex);
  _r.obj = function(e, t, r) {
    return r || (r = {}), r.objectMode = !0, r.highWaterMark = 16, new _r(e, t, r);
  };
  _r.prototype.cork = function() {
    ++this._corked === 1 && this.emit("cork");
  };
  _r.prototype.uncork = function() {
    this._corked && --this._corked === 0 && this.emit("uncork");
  };
  _r.prototype.setWritable = function(e) {
    if (this._unwrite && this._unwrite(), this.destroyed) {
      e && e.destroy && e.destroy();
      return;
    }
    if (e === null || e === !1) {
      this.end();
      return;
    }
    var t = this, r = T7(e, { writable: !0, readable: !1 }, w7(this, this._forwardEnd)), i = /* @__PURE__ */ n(function() {
      var a = t._ondrain;
      t._ondrain = null, a && a();
    }, "ondrain"), s = /* @__PURE__ */ n(function() {
      t._writable.removeListener("drain", i), r();
    }, "clear");
    this._unwrite && process.nextTick(i), this._writable = e, this._writable.on("drain", i), this._unwrite = s, this.uncork();
  };
  _r.prototype.setReadable = function(e) {
    if (this._unread && this._unread(), this.destroyed) {
      e && e.destroy && e.destroy();
      return;
    }
    if (e === null || e === !1) {
      this.push(null), this.resume();
      return;
    }
    var t = this, r = T7(e, { writable: !1, readable: !0 }, w7(this)), i = /* @__PURE__ */ n(function() {
      t._forward();
    }, "onreadable"), s = /* @__PURE__ */ n(function() {
      t.push(null);
    }, "onend"), a = /* @__PURE__ */ n(function() {
      t._readable2.removeListener("readable", i), t._readable2.removeListener("end", s), r();
    }, "clear");
    this._drained = !0, this._readable = e, this._readable2 = e._readableState ? e : xse(e), this._readable2.on("readable", i), this._readable2.
    on("end", s), this._unread = a, this._forward();
  };
  _r.prototype._read = function() {
    this._drained = !0, this._forward();
  };
  _r.prototype._forward = function() {
    if (!(this._forwarding || !this._readable2 || !this._drained)) {
      this._forwarding = !0;
      for (var e; this._drained && (e = bse(this._readable2)) !== null; )
        this.destroyed || (this._drained = this.push(e));
      this._forwarding = !1;
    }
  };
  _r.prototype.destroy = function(e) {
    if (!this.destroyed) {
      this.destroyed = !0;
      var t = this;
      process.nextTick(function() {
        t._destroy(e);
      });
    }
  };
  _r.prototype._destroy = function(e) {
    if (e) {
      var t = this._ondrain;
      this._ondrain = null, t ? t(e) : this.emit("error", e);
    }
    this._forwardDestroy && (this._readable && this._readable.destroy && this._readable.destroy(), this._writable && this._writable.destroy &&
    this._writable.destroy()), this.emit("close");
  };
  _r.prototype._write = function(e, t, r) {
    if (this.destroyed) return r();
    if (this._corked) return JD(this, this._write.bind(this, e, t, r));
    if (e === C7) return this._finish(r);
    if (!this._writable) return r();
    this._writable.write(e) === !1 ? this._ondrain = r : r();
  };
  _r.prototype._finish = function(e) {
    var t = this;
    this.emit("preend"), JD(this, function() {
      vse(t._forwardEnd && t._writable, function() {
        t._writableState.prefinished === !1 && (t._writableState.prefinished = !0), t.emit("prefinish"), JD(t, e);
      });
    });
  };
  _r.prototype.end = function(e, t, r) {
    return typeof e == "function" ? this.end(null, null, e) : typeof t == "function" ? this.end(e, null, t) : (this._ended = !0, e && this.write(
    e), this._writableState.ending || this.write(C7), x0.Writable.prototype.end.call(this, r));
  };
  A7.exports = _r;
});

// ../node_modules/through2/node_modules/isarray/index.js
var F7 = E((sst, P7) => {
  var Ese = {}.toString;
  P7.exports = Array.isArray || function(e) {
    return Ese.call(e) == "[object Array]";
  };
});

// ../node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream.js
var XD = E((nst, I7) => {
  I7.exports = require("stream");
});

// ../node_modules/through2/node_modules/safe-buffer/index.js
var S0 = E((YD, k7) => {
  var E0 = require("buffer"), wn = E0.Buffer;
  function O7(e, t) {
    for (var r in e)
      t[r] = e[r];
  }
  n(O7, "copyProps");
  wn.from && wn.alloc && wn.allocUnsafe && wn.allocUnsafeSlow ? k7.exports = E0 : (O7(E0, YD), YD.Buffer = fl);
  function fl(e, t, r) {
    return wn(e, t, r);
  }
  n(fl, "SafeBuffer");
  O7(wn, fl);
  fl.from = function(e, t, r) {
    if (typeof e == "number")
      throw new TypeError("Argument must not be a number");
    return wn(e, t, r);
  };
  fl.alloc = function(e, t, r) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    var i = wn(e);
    return t !== void 0 ? typeof r == "string" ? i.fill(t, r) : i.fill(t) : i.fill(0), i;
  };
  fl.allocUnsafe = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return wn(e);
  };
  fl.allocUnsafeSlow = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return E0.SlowBuffer(e);
  };
});

// ../node_modules/through2/node_modules/readable-stream/lib/internal/streams/BufferList.js
var N7 = E((ost, GD) => {
  "use strict";
  function Sse(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  n(Sse, "_classCallCheck");
  var B7 = S0().Buffer, kf = require("util");
  function Tse(e, t, r) {
    e.copy(t, r);
  }
  n(Tse, "copyBuffer");
  GD.exports = function() {
    function e() {
      Sse(this, e), this.head = null, this.tail = null, this.length = 0;
    }
    return n(e, "BufferList"), e.prototype.push = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: null };
      this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
    }, "push"), e.prototype.unshift = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: this.head };
      this.length === 0 && (this.tail = i), this.head = i, ++this.length;
    }, "unshift"), e.prototype.shift = /* @__PURE__ */ n(function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    }, "shift"), e.prototype.clear = /* @__PURE__ */ n(function() {
      this.head = this.tail = null, this.length = 0;
    }, "clear"), e.prototype.join = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return "";
      for (var i = this.head, s = "" + i.data; i = i.next; )
        s += r + i.data;
      return s;
    }, "join"), e.prototype.concat = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return B7.alloc(0);
      for (var i = B7.allocUnsafe(r >>> 0), s = this.head, a = 0; s; )
        Tse(s.data, i, a), a += s.data.length, s = s.next;
      return i;
    }, "concat"), e;
  }();
  kf && kf.inspect && kf.inspect.custom && (GD.exports.prototype[kf.inspect.custom] = function() {
    var e = kf.inspect({ length: this.length });
    return this.constructor.name + " " + e;
  });
});

// ../node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js
var ZD = E((lst, M7) => {
  "use strict";
  var T0 = Ei();
  function Cse(e, t) {
    var r = this, i = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return i || s ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, T0.nextTick(
    C0, this, e)) : T0.nextTick(C0, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this.
    _writableState.destroyed = !0), this._destroy(e || null, function(a) {
      !t && a ? r._writableState ? r._writableState.errorEmitted || (r._writableState.errorEmitted = !0, T0.nextTick(C0, r, a)) : T0.nextTick(
      C0, r, a) : t && t(a);
    }), this);
  }
  n(Cse, "destroy");
  function wse() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.
    endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending =
    !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted =
    !1);
  }
  n(wse, "undestroy");
  function C0(e, t) {
    e.emit("error", t);
  }
  n(C0, "emitErrorNT");
  M7.exports = {
    destroy: Cse,
    undestroy: wse
  };
});

// ../node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js
var ev = E((fst, W7) => {
  "use strict";
  var Eo = Ei();
  W7.exports = ar;
  function L7(e) {
    var t = this;
    this.next = null, this.entry = null, this.finish = function() {
      Wse(t, e);
    };
  }
  n(L7, "CorkedRequest");
  var Ase = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : Eo.nextTick, dl;
  ar.WritableState = Nf;
  var j7 = Object.create(dr());
  j7.inherits = St();
  var _se = {
    deprecate: df()
  }, q7 = XD(), A0 = S0().Buffer, Pse = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array ||
  function() {
  };
  function Fse(e) {
    return A0.from(e);
  }
  n(Fse, "_uint8ArrayToBuffer");
  function Ise(e) {
    return A0.isBuffer(e) || e instanceof Pse;
  }
  n(Ise, "_isUint8Array");
  var U7 = ZD();
  j7.inherits(ar, q7);
  function Ose() {
  }
  n(Ose, "nop");
  function Nf(e, t) {
    dl = dl || So(), e = e || {};
    var r = t instanceof dl;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode);
    var i = e.highWaterMark, s = e.writableHighWaterMark, a = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = a, this.highWaterMark = Math.
    floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed =
    !1;
    var o = e.decodeStrings === !1;
    this.decodeStrings = !o, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync =
    !0, this.bufferProcessing = !1, this.onwrite = function(u) {
      jse(t, u);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished =
    !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new L7(this);
  }
  n(Nf, "WritableState");
  Nf.prototype.getBuffer = /* @__PURE__ */ n(function() {
    for (var t = this.bufferedRequest, r = []; t; )
      r.push(t), t = t.next;
    return r;
  }, "getBuffer");
  (function() {
    try {
      Object.defineProperty(Nf.prototype, "buffer", {
        get: _se.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var w0;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (w0 = Function.prototype[Symbol.
  hasInstance], Object.defineProperty(ar, Symbol.hasInstance, {
    value: /* @__PURE__ */ n(function(e) {
      return w0.call(this, e) ? !0 : this !== ar ? !1 : e && e._writableState instanceof Nf;
    }, "value")
  })) : w0 = /* @__PURE__ */ n(function(e) {
    return e instanceof this;
  }, "realHasInstance");
  function ar(e) {
    if (dl = dl || So(), !w0.call(ar, this) && !(this instanceof dl))
      return new ar(e);
    this._writableState = new Nf(e, this), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev ==
    "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this.
    _final = e.final)), q7.call(this);
  }
  n(ar, "Writable");
  ar.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function kse(e, t) {
    var r = new Error("write after end");
    e.emit("error", r), Eo.nextTick(t, r);
  }
  n(kse, "writeAfterEnd");
  function Bse(e, t, r, i) {
    var s = !0, a = !1;
    return r === null ? a = new TypeError("May not write null values to stream") : typeof r != "string" && r !== void 0 && !t.objectMode && (a =
    new TypeError("Invalid non-string/buffer chunk")), a && (e.emit("error", a), Eo.nextTick(i, a), s = !1), s;
  }
  n(Bse, "validChunk");
  ar.prototype.write = function(e, t, r) {
    var i = this._writableState, s = !1, a = !i.objectMode && Ise(e);
    return a && !A0.isBuffer(e) && (e = Fse(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding),
    typeof r != "function" && (r = Ose), i.ended ? kse(this, r) : (a || Bse(this, i, e, r)) && (i.pendingcb++, s = Mse(this, i, a, e, t, r)),
    s;
  };
  ar.prototype.cork = function() {
    var e = this._writableState;
    e.corked++;
  };
  ar.prototype.uncork = function() {
    var e = this._writableState;
    e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && $7(this, e));
  };
  ar.prototype.setDefaultEncoding = /* @__PURE__ */ n(function(t) {
    if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "\
utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + t);
    return this._writableState.defaultEncoding = t, this;
  }, "setDefaultEncoding");
  function Nse(e, t, r) {
    return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = A0.from(t, r)), t;
  }
  n(Nse, "decodeChunk");
  Object.defineProperty(ar.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function Mse(e, t, r, i, s, a) {
    if (!r) {
      var o = Nse(t, i, s);
      i !== o && (r = !0, s = "buffer", i = o);
    }
    var u = t.objectMode ? 1 : i.length;
    t.length += u;
    var l = t.length < t.highWaterMark;
    if (l || (t.needDrain = !0), t.writing || t.corked) {
      var c = t.lastBufferedRequest;
      t.lastBufferedRequest = {
        chunk: i,
        encoding: s,
        isBuf: r,
        callback: a,
        next: null
      }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
    } else
      QD(e, t, !1, u, i, s, a);
    return l;
  }
  n(Mse, "writeOrBuffer");
  function QD(e, t, r, i, s, a, o) {
    t.writelen = i, t.writecb = o, t.writing = !0, t.sync = !0, r ? e._writev(s, t.onwrite) : e._write(s, a, t.onwrite), t.sync = !1;
  }
  n(QD, "doWrite");
  function Rse(e, t, r, i, s) {
    --t.pendingcb, r ? (Eo.nextTick(s, i), Eo.nextTick(Bf, e, t), e._writableState.errorEmitted = !0, e.emit("error", i)) : (s(i), e._writableState.
    errorEmitted = !0, e.emit("error", i), Bf(e, t));
  }
  n(Rse, "onwriteError");
  function Lse(e) {
    e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
  }
  n(Lse, "onwriteStateUpdate");
  function jse(e, t) {
    var r = e._writableState, i = r.sync, s = r.writecb;
    if (Lse(r), t) Rse(e, r, i, t, s);
    else {
      var a = V7(r);
      !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && $7(e, r), i ? Ase(R7, e, r, a, s) : R7(e, r, a, s);
    }
  }
  n(jse, "onwrite");
  function R7(e, t, r, i) {
    r || qse(e, t), t.pendingcb--, i(), Bf(e, t);
  }
  n(R7, "afterWrite");
  function qse(e, t) {
    t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
  }
  n(qse, "onwriteDrain");
  function $7(e, t) {
    t.bufferProcessing = !0;
    var r = t.bufferedRequest;
    if (e._writev && r && r.next) {
      var i = t.bufferedRequestCount, s = new Array(i), a = t.corkedRequestsFree;
      a.entry = r;
      for (var o = 0, u = !0; r; )
        s[o] = r, r.isBuf || (u = !1), r = r.next, o += 1;
      s.allBuffers = u, QD(e, t, !0, t.length, s, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree =
      a.next, a.next = null) : t.corkedRequestsFree = new L7(t), t.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var l = r.chunk, c = r.encoding, f = r.callback, m = t.objectMode ? 1 : l.length;
        if (QD(e, t, !1, m, l, c, f), r = r.next, t.bufferedRequestCount--, t.writing)
          break;
      }
      r === null && (t.lastBufferedRequest = null);
    }
    t.bufferedRequest = r, t.bufferProcessing = !1;
  }
  n($7, "clearBuffer");
  ar.prototype._write = function(e, t, r) {
    r(new Error("_write() is not implemented"));
  };
  ar.prototype._writev = null;
  ar.prototype.end = function(e, t, r) {
    var i = this._writableState;
    typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked &&
    (i.corked = 1, this.uncork()), i.ending || Vse(this, i, r);
  };
  function V7(e) {
    return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
  }
  n(V7, "needFinish");
  function Use(e, t) {
    e._final(function(r) {
      t.pendingcb--, r && e.emit("error", r), t.prefinished = !0, e.emit("prefinish"), Bf(e, t);
    });
  }
  n(Use, "callFinal");
  function $se(e, t) {
    !t.prefinished && !t.finalCalled && (typeof e._final == "function" ? (t.pendingcb++, t.finalCalled = !0, Eo.nextTick(Use, e, t)) : (t.prefinished =
    !0, e.emit("prefinish")));
  }
  n($se, "prefinish");
  function Bf(e, t) {
    var r = V7(t);
    return r && ($se(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"))), r;
  }
  n(Bf, "finishMaybe");
  function Vse(e, t, r) {
    t.ending = !0, Bf(e, t), r && (t.finished ? Eo.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
  }
  n(Vse, "endWritable");
  function Wse(e, t, r) {
    var i = e.entry;
    for (e.entry = null; i; ) {
      var s = i.callback;
      t.pendingcb--, s(r), i = i.next;
    }
    t.corkedRequestsFree.next = e;
  }
  n(Wse, "onCorkedFinish");
  Object.defineProperty(ar.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._writableState && (this._writableState.destroyed = e);
    }, "set")
  });
  ar.prototype.destroy = U7.destroy;
  ar.prototype._undestroy = U7.undestroy;
  ar.prototype._destroy = function(e, t) {
    this.end(), t(e);
  };
});

// ../node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js
var So = E((pst, J7) => {
  "use strict";
  var H7 = Ei(), Hse = Object.keys || function(e) {
    var t = [];
    for (var r in e)
      t.push(r);
    return t;
  };
  J7.exports = An;
  var K7 = Object.create(dr());
  K7.inherits = St();
  var z7 = iv(), rv = ev();
  K7.inherits(An, z7);
  for (tv = Hse(rv.prototype), _0 = 0; _0 < tv.length; _0++)
    P0 = tv[_0], An.prototype[P0] || (An.prototype[P0] = rv.prototype[P0]);
  var tv, P0, _0;
  function An(e) {
    if (!(this instanceof An)) return new An(e);
    z7.call(this, e), rv.call(this, e), e && e.readable === !1 && (this.readable = !1), e && e.writable === !1 && (this.writable = !1), this.
    allowHalfOpen = !0, e && e.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", Kse);
  }
  n(An, "Duplex");
  Object.defineProperty(An.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function Kse() {
    this.allowHalfOpen || this._writableState.ended || H7.nextTick(zse, this);
  }
  n(Kse, "onend");
  function zse(e) {
    e.end();
  }
  n(zse, "onEndNT");
  Object.defineProperty(An.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed =
      e);
    }, "set")
  });
  An.prototype._destroy = function(e, t) {
    this.push(null), this.end(), H7.nextTick(t, e);
  };
});

// ../node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js
var iv = E((yst, a9) => {
  "use strict";
  var hl = Ei();
  a9.exports = Ft;
  var Jse = F7(), Mf;
  Ft.ReadableState = t9;
  var mst = require("events").EventEmitter, Z7 = /* @__PURE__ */ n(function(e, t) {
    return e.listeners(t).length;
  }, "EElistenerCount"), uv = XD(), Rf = S0().Buffer, Xse = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ?
  self : {}).Uint8Array || function() {
  };
  function Yse(e) {
    return Rf.from(e);
  }
  n(Yse, "_uint8ArrayToBuffer");
  function Gse(e) {
    return Rf.isBuffer(e) || e instanceof Xse;
  }
  n(Gse, "_isUint8Array");
  var Q7 = Object.create(dr());
  Q7.inherits = St();
  var sv = require("util"), ft = void 0;
  sv && sv.debuglog ? ft = sv.debuglog("stream") : ft = /* @__PURE__ */ n(function() {
  }, "debug");
  var Zse = N7(), e9 = ZD(), pl;
  Q7.inherits(Ft, uv);
  var nv = ["error", "close", "destroy", "pause", "resume"];
  function Qse(e, t, r) {
    if (typeof e.prependListener == "function") return e.prependListener(t, r);
    !e._events || !e._events[t] ? e.on(t, r) : Jse(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
  }
  n(Qse, "prependListener");
  function t9(e, t) {
    Mf = Mf || So(), e = e || {};
    var r = t instanceof Mf;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode);
    var i = e.highWaterMark, s = e.readableHighWaterMark, a = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = a, this.highWaterMark = Math.
    floor(this.highWaterMark), this.buffer = new Zse(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended =
    !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening =
    !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore =
    !1, this.decoder = null, this.encoding = null, e.encoding && (pl || (pl = require("string_decoder/").StringDecoder), this.decoder = new pl(
    e.encoding), this.encoding = e.encoding);
  }
  n(t9, "ReadableState");
  function Ft(e) {
    if (Mf = Mf || So(), !(this instanceof Ft)) return new Ft(e);
    this._readableState = new t9(e, this), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy ==
    "function" && (this._destroy = e.destroy)), uv.call(this);
  }
  n(Ft, "Readable");
  Object.defineProperty(Ft.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState && (this._readableState.destroyed = e);
    }, "set")
  });
  Ft.prototype.destroy = e9.destroy;
  Ft.prototype._undestroy = e9.undestroy;
  Ft.prototype._destroy = function(e, t) {
    this.push(null), t(e);
  };
  Ft.prototype.push = function(e, t) {
    var r = this._readableState, i;
    return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = Rf.from(e, t), t = ""), i =
    !0), r9(this, e, t, !1, i);
  };
  Ft.prototype.unshift = function(e) {
    return r9(this, e, null, !0, !1);
  };
  function r9(e, t, r, i, s) {
    var a = e._readableState;
    if (t === null)
      a.reading = !1, ine(e, a);
    else {
      var o;
      s || (o = ene(a, t)), o ? e.emit("error", o) : a.objectMode || t && t.length > 0 ? (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(
      t) !== Rf.prototype && (t = Yse(t)), i ? a.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : av(e, a, t, !0) :
      a.ended ? e.emit("error", new Error("stream.push() after EOF")) : (a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode ||
      t.length !== 0 ? av(e, a, t, !1) : i9(e, a)) : av(e, a, t, !1))) : i || (a.reading = !1);
    }
    return tne(a);
  }
  n(r9, "readableAddChunk");
  function av(e, t, r, i) {
    t.flowing && t.length === 0 && !t.sync ? (e.emit("data", r), e.read(0)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(
    r) : t.buffer.push(r), t.needReadable && F0(e)), i9(e, t);
  }
  n(av, "addChunk");
  function ene(e, t) {
    var r;
    return !Gse(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new TypeError("Invalid non-string/buffer chunk")), r;
  }
  n(ene, "chunkInvalid");
  function tne(e) {
    return !e.ended && (e.needReadable || e.length < e.highWaterMark || e.length === 0);
  }
  n(tne, "needMoreData");
  Ft.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  };
  Ft.prototype.setEncoding = function(e) {
    return pl || (pl = require("string_decoder/").StringDecoder), this._readableState.decoder = new pl(e), this._readableState.encoding = e,
    this;
  };
  var X7 = 8388608;
  function rne(e) {
    return e >= X7 ? e = X7 : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
  }
  n(rne, "computeNewHighWaterMark");
  function Y7(e, t) {
    return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length :
    (e > t.highWaterMark && (t.highWaterMark = rne(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
  }
  n(Y7, "howMuchToRead");
  Ft.prototype.read = function(e) {
    ft("read", e), e = parseInt(e, 10);
    var t = this._readableState, r = e;
    if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && (t.length >= t.highWaterMark || t.ended))
      return ft("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? ov(this) : F0(this), null;
    if (e = Y7(e, t), e === 0 && t.ended)
      return t.length === 0 && ov(this), null;
    var i = t.needReadable;
    ft("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, ft("length less than watermark", i)), t.ended || t.
    reading ? (i = !1, ft("reading or ended", i)) : i && (ft("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0),
    this._read(t.highWaterMark), t.sync = !1, t.reading || (e = Y7(r, t)));
    var s;
    return e > 0 ? s = s9(e, t) : s = null, s === null ? (t.needReadable = !0, e = 0) : t.length -= e, t.length === 0 && (t.ended || (t.needReadable =
    !0), r !== e && t.ended && ov(this)), s !== null && this.emit("data", s), s;
  };
  function ine(e, t) {
    if (!t.ended) {
      if (t.decoder) {
        var r = t.decoder.end();
        r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
      }
      t.ended = !0, F0(e);
    }
  }
  n(ine, "onEofChunk");
  function F0(e) {
    var t = e._readableState;
    t.needReadable = !1, t.emittedReadable || (ft("emitReadable", t.flowing), t.emittedReadable = !0, t.sync ? hl.nextTick(G7, e) : G7(e));
  }
  n(F0, "emitReadable");
  function G7(e) {
    ft("emit readable"), e.emit("readable"), lv(e);
  }
  n(G7, "emitReadable_");
  function i9(e, t) {
    t.readingMore || (t.readingMore = !0, hl.nextTick(sne, e, t));
  }
  n(i9, "maybeReadMore");
  function sne(e, t) {
    for (var r = t.length; !t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark && (ft("maybeReadMore read 0"), e.read(0), r !==
    t.length); )
      r = t.length;
    t.readingMore = !1;
  }
  n(sne, "maybeReadMore_");
  Ft.prototype._read = function(e) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Ft.prototype.pipe = function(e, t) {
    var r = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = e;
        break;
      case 1:
        i.pipes = [i.pipes, e];
        break;
      default:
        i.pipes.push(e);
        break;
    }
    i.pipesCount += 1, ft("pipe count=%d opts=%j", i.pipesCount, t);
    var s = (!t || t.end !== !1) && e !== process.stdout && e !== process.stderr, a = s ? u : g;
    i.endEmitted ? hl.nextTick(a) : r.once("end", a), e.on("unpipe", o);
    function o(b, D) {
      ft("onunpipe"), b === r && D && D.hasUnpiped === !1 && (D.hasUnpiped = !0, f());
    }
    n(o, "onunpipe");
    function u() {
      ft("onend"), e.end();
    }
    n(u, "onend");
    var l = nne(r);
    e.on("drain", l);
    var c = !1;
    function f() {
      ft("cleanup"), e.removeListener("close", y), e.removeListener("finish", p), e.removeListener("drain", l), e.removeListener("error", d),
      e.removeListener("unpipe", o), r.removeListener("end", u), r.removeListener("end", g), r.removeListener("data", h), c = !0, i.awaitDrain &&
      (!e._writableState || e._writableState.needDrain) && l();
    }
    n(f, "cleanup");
    var m = !1;
    r.on("data", h);
    function h(b) {
      ft("ondata"), m = !1;
      var D = e.write(b);
      D === !1 && !m && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && n9(i.pipes, e) !== -1) && !c && (ft("false write respon\
se, pause", i.awaitDrain), i.awaitDrain++, m = !0), r.pause());
    }
    n(h, "ondata");
    function d(b) {
      ft("onerror", b), g(), e.removeListener("error", d), Z7(e, "error") === 0 && e.emit("error", b);
    }
    n(d, "onerror"), Qse(e, "error", d);
    function y() {
      e.removeListener("finish", p), g();
    }
    n(y, "onclose"), e.once("close", y);
    function p() {
      ft("onfinish"), e.removeListener("close", y), g();
    }
    n(p, "onfinish"), e.once("finish", p);
    function g() {
      ft("unpipe"), r.unpipe(e);
    }
    return n(g, "unpipe"), e.emit("pipe", r), i.flowing || (ft("pipe resume"), r.resume()), e;
  };
  function nne(e) {
    return function() {
      var t = e._readableState;
      ft("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, t.awaitDrain === 0 && Z7(e, "data") && (t.flowing = !0, lv(e));
    };
  }
  n(nne, "pipeOnDrain");
  Ft.prototype.unpipe = function(e) {
    var t = this._readableState, r = { hasUnpiped: !1 };
    if (t.pipesCount === 0) return this;
    if (t.pipesCount === 1)
      return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r),
      this);
    if (!e) {
      var i = t.pipes, s = t.pipesCount;
      t.pipes = null, t.pipesCount = 0, t.flowing = !1;
      for (var a = 0; a < s; a++)
        i[a].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var o = n9(t.pipes, e);
    return o === -1 ? this : (t.pipes.splice(o, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r),
    this);
  };
  Ft.prototype.on = function(e, t) {
    var r = uv.prototype.on.call(this, e, t);
    if (e === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (e === "readable") {
      var i = this._readableState;
      !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.emittedReadable = !1, i.reading ? i.length && F0(
      this) : hl.nextTick(ane, this));
    }
    return r;
  };
  Ft.prototype.addListener = Ft.prototype.on;
  function ane(e) {
    ft("readable nexttick read 0"), e.read(0);
  }
  n(ane, "nReadingNextTick");
  Ft.prototype.resume = function() {
    var e = this._readableState;
    return e.flowing || (ft("resume"), e.flowing = !0, one(this, e)), this;
  };
  function one(e, t) {
    t.resumeScheduled || (t.resumeScheduled = !0, hl.nextTick(une, e, t));
  }
  n(one, "resume");
  function une(e, t) {
    t.reading || (ft("resume read 0"), e.read(0)), t.resumeScheduled = !1, t.awaitDrain = 0, e.emit("resume"), lv(e), t.flowing && !t.reading &&
    e.read(0);
  }
  n(une, "resume_");
  Ft.prototype.pause = function() {
    return ft("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ft("pause"), this._readableState.
    flowing = !1, this.emit("pause")), this;
  };
  function lv(e) {
    var t = e._readableState;
    for (ft("flow", t.flowing); t.flowing && e.read() !== null; )
      ;
  }
  n(lv, "flow");
  Ft.prototype.wrap = function(e) {
    var t = this, r = this._readableState, i = !1;
    e.on("end", function() {
      if (ft("wrapped end"), r.decoder && !r.ended) {
        var o = r.decoder.end();
        o && o.length && t.push(o);
      }
      t.push(null);
    }), e.on("data", function(o) {
      if (ft("wrapped data"), r.decoder && (o = r.decoder.write(o)), !(r.objectMode && o == null) && !(!r.objectMode && (!o || !o.length))) {
        var u = t.push(o);
        u || (i = !0, e.pause());
      }
    });
    for (var s in e)
      this[s] === void 0 && typeof e[s] == "function" && (this[s] = /* @__PURE__ */ function(o) {
        return function() {
          return e[o].apply(e, arguments);
        };
      }(s));
    for (var a = 0; a < nv.length; a++)
      e.on(nv[a], this.emit.bind(this, nv[a]));
    return this._read = function(o) {
      ft("wrapped _read", o), i && (i = !1, e.resume());
    }, this;
  };
  Object.defineProperty(Ft.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.highWaterMark;
    }, "get")
  });
  Ft._fromList = s9;
  function s9(e, t) {
    if (t.length === 0) return null;
    var r;
    return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.
    head.data : r = t.buffer.concat(t.length), t.buffer.clear()) : r = lne(e, t.buffer, t.decoder), r;
  }
  n(s9, "fromList");
  function lne(e, t, r) {
    var i;
    return e < t.head.data.length ? (i = t.head.data.slice(0, e), t.head.data = t.head.data.slice(e)) : e === t.head.data.length ? i = t.shift() :
    i = r ? cne(e, t) : fne(e, t), i;
  }
  n(lne, "fromListPartial");
  function cne(e, t) {
    var r = t.head, i = 1, s = r.data;
    for (e -= s.length; r = r.next; ) {
      var a = r.data, o = e > a.length ? a.length : e;
      if (o === a.length ? s += a : s += a.slice(0, e), e -= o, e === 0) {
        o === a.length ? (++i, r.next ? t.head = r.next : t.head = t.tail = null) : (t.head = r, r.data = a.slice(o));
        break;
      }
      ++i;
    }
    return t.length -= i, s;
  }
  n(cne, "copyFromBufferString");
  function fne(e, t) {
    var r = Rf.allocUnsafe(e), i = t.head, s = 1;
    for (i.data.copy(r), e -= i.data.length; i = i.next; ) {
      var a = i.data, o = e > a.length ? a.length : e;
      if (a.copy(r, r.length - e, 0, o), e -= o, e === 0) {
        o === a.length ? (++s, i.next ? t.head = i.next : t.head = t.tail = null) : (t.head = i, i.data = a.slice(o));
        break;
      }
      ++s;
    }
    return t.length -= s, r;
  }
  n(fne, "copyFromBuffer");
  function ov(e) {
    var t = e._readableState;
    if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    t.endEmitted || (t.ended = !0, hl.nextTick(dne, t, e));
  }
  n(ov, "endReadable");
  function dne(e, t) {
    !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"));
  }
  n(dne, "endReadableNT");
  function n9(e, t) {
    for (var r = 0, i = e.length; r < i; r++)
      if (e[r] === t) return r;
    return -1;
  }
  n(n9, "indexOf");
});

// ../node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js
var cv = E((bst, l9) => {
  "use strict";
  l9.exports = _n;
  var I0 = So(), u9 = Object.create(dr());
  u9.inherits = St();
  u9.inherits(_n, I0);
  function pne(e, t) {
    var r = this._transformState;
    r.transforming = !1;
    var i = r.writecb;
    if (!i)
      return this.emit("error", new Error("write callback called multiple times"));
    r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
    var s = this._readableState;
    s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
  n(pne, "afterTransform");
  function _n(e) {
    if (!(this instanceof _n)) return new _n(e);
    I0.call(this, e), this._transformState = {
      afterTransform: pne.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.
    transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", hne);
  }
  n(_n, "Transform");
  function hne() {
    var e = this;
    typeof this._flush == "function" ? this._flush(function(t, r) {
      o9(e, t, r);
    }) : o9(this, null, null);
  }
  n(hne, "prefinish");
  _n.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, I0.prototype.push.call(this, e, t);
  };
  _n.prototype._transform = function(e, t, r) {
    throw new Error("_transform() is not implemented");
  };
  _n.prototype._write = function(e, t, r) {
    var i = this._transformState;
    if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
      var s = this._readableState;
      (i.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
    }
  };
  _n.prototype._read = function(e) {
    var t = this._transformState;
    t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) :
    t.needTransform = !0;
  };
  _n.prototype._destroy = function(e, t) {
    var r = this;
    I0.prototype._destroy.call(this, e, function(i) {
      t(i), r.emit("close");
    });
  };
  function o9(e, t, r) {
    if (t) return e.emit("error", t);
    if (r != null && e.push(r), e._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (e._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return e.push(null);
  }
  n(o9, "done");
});

// ../node_modules/through2/node_modules/readable-stream/lib/_stream_passthrough.js
var p9 = E((vst, d9) => {
  "use strict";
  d9.exports = Lf;
  var c9 = cv(), f9 = Object.create(dr());
  f9.inherits = St();
  f9.inherits(Lf, c9);
  function Lf(e) {
    if (!(this instanceof Lf)) return new Lf(e);
    c9.call(this, e);
  }
  n(Lf, "PassThrough");
  Lf.prototype._transform = function(e, t, r) {
    r(null, e);
  };
});

// ../node_modules/through2/node_modules/readable-stream/readable.js
var h9 = E((Pr, O0) => {
  var Ws = require("stream");
  process.env.READABLE_STREAM === "disable" && Ws ? (O0.exports = Ws, Pr = O0.exports = Ws.Readable, Pr.Readable = Ws.Readable, Pr.Writable =
  Ws.Writable, Pr.Duplex = Ws.Duplex, Pr.Transform = Ws.Transform, Pr.PassThrough = Ws.PassThrough, Pr.Stream = Ws) : (Pr = O0.exports = iv(),
  Pr.Stream = Ws || Pr, Pr.Readable = Pr, Pr.Writable = ev(), Pr.Duplex = So(), Pr.Transform = cv(), Pr.PassThrough = p9());
});

// ../node_modules/xtend/immutable.js
var y9 = E((Est, m9) => {
  m9.exports = yne;
  var mne = Object.prototype.hasOwnProperty;
  function yne() {
    for (var e = {}, t = 0; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        mne.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }
  n(yne, "extend");
});

// ../node_modules/through2/through2.js
var dv = E((Tst, k0) => {
  var g9 = h9().Transform, b9 = require("util").inherits, D9 = y9();
  function ml(e) {
    g9.call(this, e), this._destroyed = !1;
  }
  n(ml, "DestroyableTransform");
  b9(ml, g9);
  ml.prototype.destroy = function(e) {
    if (!this._destroyed) {
      this._destroyed = !0;
      var t = this;
      process.nextTick(function() {
        e && t.emit("error", e), t.emit("close");
      });
    }
  };
  function gne(e, t, r) {
    r(null, e);
  }
  n(gne, "noop");
  function fv(e) {
    return function(t, r, i) {
      return typeof t == "function" && (i = r, r = t, t = {}), typeof r != "function" && (r = gne), typeof i != "function" && (i = null), e(
      t, r, i);
    };
  }
  n(fv, "through2");
  k0.exports = fv(function(e, t, r) {
    var i = new ml(e);
    return i._transform = t, r && (i._flush = r), i;
  });
  k0.exports.ctor = fv(function(e, t, r) {
    function i(s) {
      if (!(this instanceof i))
        return new i(s);
      this.options = D9(e, s), ml.call(this, this.options);
    }
    return n(i, "Through2"), b9(i, ml), i.prototype._transform = t, r && (i.prototype._flush = r), i;
  });
  k0.exports.obj = fv(function(e, t, r) {
    var i = new ml(D9({ objectMode: !0, highWaterMark: 16 }, e));
    return i._transform = t, r && (i._flush = r), i;
  });
});

// ../node_modules/buffer-from/index.js
var x9 = E((wst, v9) => {
  var bne = Object.prototype.toString, pv = typeof Buffer < "u" && typeof Buffer.alloc == "function" && typeof Buffer.allocUnsafe == "functi\
on" && typeof Buffer.from == "function";
  function Dne(e) {
    return bne.call(e).slice(8, -1) === "ArrayBuffer";
  }
  n(Dne, "isArrayBuffer");
  function vne(e, t, r) {
    t >>>= 0;
    var i = e.byteLength - t;
    if (i < 0)
      throw new RangeError("'offset' is out of bounds");
    if (r === void 0)
      r = i;
    else if (r >>>= 0, r > i)
      throw new RangeError("'length' is out of bounds");
    return pv ? Buffer.from(e.slice(t, t + r)) : new Buffer(new Uint8Array(e.slice(t, t + r)));
  }
  n(vne, "fromArrayBuffer");
  function xne(e, t) {
    if ((typeof t != "string" || t === "") && (t = "utf8"), !Buffer.isEncoding(t))
      throw new TypeError('"encoding" must be a valid string encoding');
    return pv ? Buffer.from(e, t) : new Buffer(e, t);
  }
  n(xne, "fromString");
  function Ene(e, t, r) {
    if (typeof e == "number")
      throw new TypeError('"value" argument must not be a number');
    return Dne(e) ? vne(e, t, r) : typeof e == "string" ? xne(e, t) : pv ? Buffer.from(e) : new Buffer(e);
  }
  n(Ene, "bufferFrom");
  v9.exports = Ene;
});

// ../node_modules/peek-stream/index.js
var T9 = E((_st, S9) => {
  var Sne = _7(), Tne = dv(), Cne = x9(), wne = /* @__PURE__ */ n(function(e) {
    return !Buffer.isBuffer(e) && typeof e != "string";
  }, "isObject"), E9 = /* @__PURE__ */ n(function(e, t) {
    if (typeof e == "number" && (e = { maxBuffer: e }), typeof e == "function") return E9(null, e);
    e || (e = {});
    var r = typeof e.maxBuffer == "number" ? e.maxBuffer : 65535, i = e.strict, s = e.newline !== !1, a = [], o = 0, u = Sne.obj(), l = Tne.
    obj({ highWaterMark: 1 }, function(m, h, d) {
      if (wne(m)) return f(m, null, d);
      if (Buffer.isBuffer(m) || (m = Cne(m)), s) {
        var y = Array.prototype.indexOf.call(m, 10);
        if (y > 0 && m[y - 1] === 13 && y--, y > -1)
          return a.push(m.slice(0, y)), f(Buffer.concat(a), m.slice(y), d);
      }
      if (a.push(m), o += m.length, o < r) return d();
      if (i) return d(new Error("No newline found"));
      f(Buffer.concat(a), null, d);
    }), c = /* @__PURE__ */ n(function() {
      if (i) return u.destroy(new Error("No newline found"));
      u.cork(), f(Buffer.concat(a), null, function(m) {
        if (m) return u.destroy(m);
        u.uncork();
      });
    }, "onpreend"), f = /* @__PURE__ */ n(function(m, h, d) {
      u.removeListener("preend", c), t(m, function(y, p) {
        if (y) return d(y);
        u.setWritable(p), u.setReadable(p), m && p.write(m), h && p.write(h), h = a = l = null, d();
      });
    }, "ready");
    return u.on("preend", c), u.setWritable(l), u;
  }, "peek");
  S9.exports = E9;
});

// ../node_modules/pumpify/node_modules/pump/index.js
var A9 = E((Fst, w9) => {
  var Ane = Lh(), _ne = Yu(), hv = require("fs"), jf = /* @__PURE__ */ n(function() {
  }, "noop"), Pne = /^v?\.0/.test(process.version), B0 = /* @__PURE__ */ n(function(e) {
    return typeof e == "function";
  }, "isFn"), Fne = /* @__PURE__ */ n(function(e) {
    return !Pne || !hv ? !1 : (e instanceof (hv.ReadStream || jf) || e instanceof (hv.WriteStream || jf)) && B0(e.close);
  }, "isFS"), Ine = /* @__PURE__ */ n(function(e) {
    return e.setHeader && B0(e.abort);
  }, "isRequest"), One = /* @__PURE__ */ n(function(e, t, r, i) {
    i = Ane(i);
    var s = !1;
    e.on("close", function() {
      s = !0;
    }), _ne(e, { readable: t, writable: r }, function(o) {
      if (o) return i(o);
      s = !0, i();
    });
    var a = !1;
    return function(o) {
      if (!s && !a) {
        if (a = !0, Fne(e)) return e.close(jf);
        if (Ine(e)) return e.abort();
        if (B0(e.destroy)) return e.destroy();
        i(o || new Error("stream was destroyed"));
      }
    };
  }, "destroyer"), C9 = /* @__PURE__ */ n(function(e) {
    e();
  }, "call"), kne = /* @__PURE__ */ n(function(e, t) {
    return e.pipe(t);
  }, "pipe"), Bne = /* @__PURE__ */ n(function() {
    var e = Array.prototype.slice.call(arguments), t = B0(e[e.length - 1] || jf) && e.pop() || jf;
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new Error("pump requires two streams per minimum");
    var r, i = e.map(function(s, a) {
      var o = a < e.length - 1, u = a > 0;
      return One(s, o, u, function(l) {
        r || (r = l), l && i.forEach(C9), !o && (i.forEach(C9), t(r));
      });
    });
    e.reduce(kne);
  }, "pump");
  w9.exports = Bne;
});

// ../node_modules/pumpify/node_modules/isarray/index.js
var P9 = E((Ost, _9) => {
  var Nne = {}.toString;
  _9.exports = Array.isArray || function(e) {
    return Nne.call(e) == "[object Array]";
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/internal/streams/stream.js
var mv = E((kst, F9) => {
  F9.exports = require("stream");
});

// ../node_modules/pumpify/node_modules/safe-buffer/index.js
var M0 = E((yv, O9) => {
  var N0 = require("buffer"), Pn = N0.Buffer;
  function I9(e, t) {
    for (var r in e)
      t[r] = e[r];
  }
  n(I9, "copyProps");
  Pn.from && Pn.alloc && Pn.allocUnsafe && Pn.allocUnsafeSlow ? O9.exports = N0 : (I9(N0, yv), yv.Buffer = yl);
  function yl(e, t, r) {
    return Pn(e, t, r);
  }
  n(yl, "SafeBuffer");
  I9(Pn, yl);
  yl.from = function(e, t, r) {
    if (typeof e == "number")
      throw new TypeError("Argument must not be a number");
    return Pn(e, t, r);
  };
  yl.alloc = function(e, t, r) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    var i = Pn(e);
    return t !== void 0 ? typeof r == "string" ? i.fill(t, r) : i.fill(t) : i.fill(0), i;
  };
  yl.allocUnsafe = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return Pn(e);
  };
  yl.allocUnsafeSlow = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return N0.SlowBuffer(e);
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/internal/streams/BufferList.js
var B9 = E((Nst, gv) => {
  "use strict";
  function Mne(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  n(Mne, "_classCallCheck");
  var k9 = M0().Buffer, qf = require("util");
  function Rne(e, t, r) {
    e.copy(t, r);
  }
  n(Rne, "copyBuffer");
  gv.exports = function() {
    function e() {
      Mne(this, e), this.head = null, this.tail = null, this.length = 0;
    }
    return n(e, "BufferList"), e.prototype.push = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: null };
      this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
    }, "push"), e.prototype.unshift = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: this.head };
      this.length === 0 && (this.tail = i), this.head = i, ++this.length;
    }, "unshift"), e.prototype.shift = /* @__PURE__ */ n(function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    }, "shift"), e.prototype.clear = /* @__PURE__ */ n(function() {
      this.head = this.tail = null, this.length = 0;
    }, "clear"), e.prototype.join = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return "";
      for (var i = this.head, s = "" + i.data; i = i.next; )
        s += r + i.data;
      return s;
    }, "join"), e.prototype.concat = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return k9.alloc(0);
      for (var i = k9.allocUnsafe(r >>> 0), s = this.head, a = 0; s; )
        Rne(s.data, i, a), a += s.data.length, s = s.next;
      return i;
    }, "concat"), e;
  }();
  qf && qf.inspect && qf.inspect.custom && (gv.exports.prototype[qf.inspect.custom] = function() {
    var e = qf.inspect({ length: this.length });
    return this.constructor.name + " " + e;
  });
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/internal/streams/destroy.js
var bv = E((Rst, N9) => {
  "use strict";
  var R0 = Ei();
  function Lne(e, t) {
    var r = this, i = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return i || s ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, R0.nextTick(
    L0, this, e)) : R0.nextTick(L0, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this.
    _writableState.destroyed = !0), this._destroy(e || null, function(a) {
      !t && a ? r._writableState ? r._writableState.errorEmitted || (r._writableState.errorEmitted = !0, R0.nextTick(L0, r, a)) : R0.nextTick(
      L0, r, a) : t && t(a);
    }), this);
  }
  n(Lne, "destroy");
  function jne() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.
    endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending =
    !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted =
    !1);
  }
  n(jne, "undestroy");
  function L0(e, t) {
    e.emit("error", t);
  }
  n(L0, "emitErrorNT");
  N9.exports = {
    destroy: Lne,
    undestroy: jne
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/_stream_writable.js
var vv = E((jst, V9) => {
  "use strict";
  var To = Ei();
  V9.exports = or;
  function R9(e) {
    var t = this;
    this.next = null, this.entry = null, this.finish = function() {
      iae(t, e);
    };
  }
  n(R9, "CorkedRequest");
  var qne = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : To.nextTick, gl;
  or.WritableState = $f;
  var L9 = Object.create(dr());
  L9.inherits = St();
  var Une = {
    deprecate: df()
  }, j9 = mv(), q0 = M0().Buffer, $ne = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array ||
  function() {
  };
  function Vne(e) {
    return q0.from(e);
  }
  n(Vne, "_uint8ArrayToBuffer");
  function Wne(e) {
    return q0.isBuffer(e) || e instanceof $ne;
  }
  n(Wne, "_isUint8Array");
  var q9 = bv();
  L9.inherits(or, j9);
  function Hne() {
  }
  n(Hne, "nop");
  function $f(e, t) {
    gl = gl || Co(), e = e || {};
    var r = t instanceof gl;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode);
    var i = e.highWaterMark, s = e.writableHighWaterMark, a = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = a, this.highWaterMark = Math.
    floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed =
    !1;
    var o = e.decodeStrings === !1;
    this.decodeStrings = !o, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync =
    !0, this.bufferProcessing = !1, this.onwrite = function(u) {
      Zne(t, u);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished =
    !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new R9(this);
  }
  n($f, "WritableState");
  $f.prototype.getBuffer = /* @__PURE__ */ n(function() {
    for (var t = this.bufferedRequest, r = []; t; )
      r.push(t), t = t.next;
    return r;
  }, "getBuffer");
  (function() {
    try {
      Object.defineProperty($f.prototype, "buffer", {
        get: Une.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var j0;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (j0 = Function.prototype[Symbol.
  hasInstance], Object.defineProperty(or, Symbol.hasInstance, {
    value: /* @__PURE__ */ n(function(e) {
      return j0.call(this, e) ? !0 : this !== or ? !1 : e && e._writableState instanceof $f;
    }, "value")
  })) : j0 = /* @__PURE__ */ n(function(e) {
    return e instanceof this;
  }, "realHasInstance");
  function or(e) {
    if (gl = gl || Co(), !j0.call(or, this) && !(this instanceof gl))
      return new or(e);
    this._writableState = new $f(e, this), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev ==
    "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this.
    _final = e.final)), j9.call(this);
  }
  n(or, "Writable");
  or.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Kne(e, t) {
    var r = new Error("write after end");
    e.emit("error", r), To.nextTick(t, r);
  }
  n(Kne, "writeAfterEnd");
  function zne(e, t, r, i) {
    var s = !0, a = !1;
    return r === null ? a = new TypeError("May not write null values to stream") : typeof r != "string" && r !== void 0 && !t.objectMode && (a =
    new TypeError("Invalid non-string/buffer chunk")), a && (e.emit("error", a), To.nextTick(i, a), s = !1), s;
  }
  n(zne, "validChunk");
  or.prototype.write = function(e, t, r) {
    var i = this._writableState, s = !1, a = !i.objectMode && Wne(e);
    return a && !q0.isBuffer(e) && (e = Vne(e)), typeof t == "function" && (r = t, t = null), a ? t = "buffer" : t || (t = i.defaultEncoding),
    typeof r != "function" && (r = Hne), i.ended ? Kne(this, r) : (a || zne(this, i, e, r)) && (i.pendingcb++, s = Xne(this, i, a, e, t, r)),
    s;
  };
  or.prototype.cork = function() {
    var e = this._writableState;
    e.corked++;
  };
  or.prototype.uncork = function() {
    var e = this._writableState;
    e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && U9(this, e));
  };
  or.prototype.setDefaultEncoding = /* @__PURE__ */ n(function(t) {
    if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "\
utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + t);
    return this._writableState.defaultEncoding = t, this;
  }, "setDefaultEncoding");
  function Jne(e, t, r) {
    return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = q0.from(t, r)), t;
  }
  n(Jne, "decodeChunk");
  Object.defineProperty(or.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function Xne(e, t, r, i, s, a) {
    if (!r) {
      var o = Jne(t, i, s);
      i !== o && (r = !0, s = "buffer", i = o);
    }
    var u = t.objectMode ? 1 : i.length;
    t.length += u;
    var l = t.length < t.highWaterMark;
    if (l || (t.needDrain = !0), t.writing || t.corked) {
      var c = t.lastBufferedRequest;
      t.lastBufferedRequest = {
        chunk: i,
        encoding: s,
        isBuf: r,
        callback: a,
        next: null
      }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
    } else
      Dv(e, t, !1, u, i, s, a);
    return l;
  }
  n(Xne, "writeOrBuffer");
  function Dv(e, t, r, i, s, a, o) {
    t.writelen = i, t.writecb = o, t.writing = !0, t.sync = !0, r ? e._writev(s, t.onwrite) : e._write(s, a, t.onwrite), t.sync = !1;
  }
  n(Dv, "doWrite");
  function Yne(e, t, r, i, s) {
    --t.pendingcb, r ? (To.nextTick(s, i), To.nextTick(Uf, e, t), e._writableState.errorEmitted = !0, e.emit("error", i)) : (s(i), e._writableState.
    errorEmitted = !0, e.emit("error", i), Uf(e, t));
  }
  n(Yne, "onwriteError");
  function Gne(e) {
    e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
  }
  n(Gne, "onwriteStateUpdate");
  function Zne(e, t) {
    var r = e._writableState, i = r.sync, s = r.writecb;
    if (Gne(r), t) Yne(e, r, i, t, s);
    else {
      var a = $9(r);
      !a && !r.corked && !r.bufferProcessing && r.bufferedRequest && U9(e, r), i ? qne(M9, e, r, a, s) : M9(e, r, a, s);
    }
  }
  n(Zne, "onwrite");
  function M9(e, t, r, i) {
    r || Qne(e, t), t.pendingcb--, i(), Uf(e, t);
  }
  n(M9, "afterWrite");
  function Qne(e, t) {
    t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
  }
  n(Qne, "onwriteDrain");
  function U9(e, t) {
    t.bufferProcessing = !0;
    var r = t.bufferedRequest;
    if (e._writev && r && r.next) {
      var i = t.bufferedRequestCount, s = new Array(i), a = t.corkedRequestsFree;
      a.entry = r;
      for (var o = 0, u = !0; r; )
        s[o] = r, r.isBuf || (u = !1), r = r.next, o += 1;
      s.allBuffers = u, Dv(e, t, !0, t.length, s, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree =
      a.next, a.next = null) : t.corkedRequestsFree = new R9(t), t.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var l = r.chunk, c = r.encoding, f = r.callback, m = t.objectMode ? 1 : l.length;
        if (Dv(e, t, !1, m, l, c, f), r = r.next, t.bufferedRequestCount--, t.writing)
          break;
      }
      r === null && (t.lastBufferedRequest = null);
    }
    t.bufferedRequest = r, t.bufferProcessing = !1;
  }
  n(U9, "clearBuffer");
  or.prototype._write = function(e, t, r) {
    r(new Error("_write() is not implemented"));
  };
  or.prototype._writev = null;
  or.prototype.end = function(e, t, r) {
    var i = this._writableState;
    typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked &&
    (i.corked = 1, this.uncork()), i.ending || rae(this, i, r);
  };
  function $9(e) {
    return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
  }
  n($9, "needFinish");
  function eae(e, t) {
    e._final(function(r) {
      t.pendingcb--, r && e.emit("error", r), t.prefinished = !0, e.emit("prefinish"), Uf(e, t);
    });
  }
  n(eae, "callFinal");
  function tae(e, t) {
    !t.prefinished && !t.finalCalled && (typeof e._final == "function" ? (t.pendingcb++, t.finalCalled = !0, To.nextTick(eae, e, t)) : (t.prefinished =
    !0, e.emit("prefinish")));
  }
  n(tae, "prefinish");
  function Uf(e, t) {
    var r = $9(t);
    return r && (tae(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"))), r;
  }
  n(Uf, "finishMaybe");
  function rae(e, t, r) {
    t.ending = !0, Uf(e, t), r && (t.finished ? To.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
  }
  n(rae, "endWritable");
  function iae(e, t, r) {
    var i = e.entry;
    for (e.entry = null; i; ) {
      var s = i.callback;
      t.pendingcb--, s(r), i = i.next;
    }
    t.corkedRequestsFree.next = e;
  }
  n(iae, "onCorkedFinish");
  Object.defineProperty(or.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._writableState && (this._writableState.destroyed = e);
    }, "set")
  });
  or.prototype.destroy = q9.destroy;
  or.prototype._undestroy = q9.undestroy;
  or.prototype._destroy = function(e, t) {
    this.end(), t(e);
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/_stream_duplex.js
var Co = E((Ust, z9) => {
  "use strict";
  var W9 = Ei(), sae = Object.keys || function(e) {
    var t = [];
    for (var r in e)
      t.push(r);
    return t;
  };
  z9.exports = Fn;
  var H9 = Object.create(dr());
  H9.inherits = St();
  var K9 = Sv(), Ev = vv();
  H9.inherits(Fn, K9);
  for (xv = sae(Ev.prototype), U0 = 0; U0 < xv.length; U0++)
    $0 = xv[U0], Fn.prototype[$0] || (Fn.prototype[$0] = Ev.prototype[$0]);
  var xv, $0, U0;
  function Fn(e) {
    if (!(this instanceof Fn)) return new Fn(e);
    K9.call(this, e), Ev.call(this, e), e && e.readable === !1 && (this.readable = !1), e && e.writable === !1 && (this.writable = !1), this.
    allowHalfOpen = !0, e && e.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", nae);
  }
  n(Fn, "Duplex");
  Object.defineProperty(Fn.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function nae() {
    this.allowHalfOpen || this._writableState.ended || W9.nextTick(aae, this);
  }
  n(nae, "onend");
  function aae(e) {
    e.end();
  }
  n(aae, "onEndNT");
  Object.defineProperty(Fn.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed =
      e);
    }, "set")
  });
  Fn.prototype._destroy = function(e, t) {
    this.push(null), this.end(), W9.nextTick(t, e);
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/_stream_readable.js
var Sv = E((Wst, nO) => {
  "use strict";
  var Dl = Ei();
  nO.exports = It;
  var oae = P9(), Vf;
  It.ReadableState = eO;
  var Vst = require("events").EventEmitter, G9 = /* @__PURE__ */ n(function(e, t) {
    return e.listeners(t).length;
  }, "EElistenerCount"), _v = mv(), Wf = M0().Buffer, uae = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ?
  self : {}).Uint8Array || function() {
  };
  function lae(e) {
    return Wf.from(e);
  }
  n(lae, "_uint8ArrayToBuffer");
  function cae(e) {
    return Wf.isBuffer(e) || e instanceof uae;
  }
  n(cae, "_isUint8Array");
  var Z9 = Object.create(dr());
  Z9.inherits = St();
  var Tv = require("util"), dt = void 0;
  Tv && Tv.debuglog ? dt = Tv.debuglog("stream") : dt = /* @__PURE__ */ n(function() {
  }, "debug");
  var fae = B9(), Q9 = bv(), bl;
  Z9.inherits(It, _v);
  var Cv = ["error", "close", "destroy", "pause", "resume"];
  function dae(e, t, r) {
    if (typeof e.prependListener == "function") return e.prependListener(t, r);
    !e._events || !e._events[t] ? e.on(t, r) : oae(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
  }
  n(dae, "prependListener");
  function eO(e, t) {
    Vf = Vf || Co(), e = e || {};
    var r = t instanceof Vf;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode);
    var i = e.highWaterMark, s = e.readableHighWaterMark, a = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = a, this.highWaterMark = Math.
    floor(this.highWaterMark), this.buffer = new fae(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended =
    !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening =
    !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore =
    !1, this.decoder = null, this.encoding = null, e.encoding && (bl || (bl = require("string_decoder/").StringDecoder), this.decoder = new bl(
    e.encoding), this.encoding = e.encoding);
  }
  n(eO, "ReadableState");
  function It(e) {
    if (Vf = Vf || Co(), !(this instanceof It)) return new It(e);
    this._readableState = new eO(e, this), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy ==
    "function" && (this._destroy = e.destroy)), _v.call(this);
  }
  n(It, "Readable");
  Object.defineProperty(It.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState && (this._readableState.destroyed = e);
    }, "set")
  });
  It.prototype.destroy = Q9.destroy;
  It.prototype._undestroy = Q9.undestroy;
  It.prototype._destroy = function(e, t) {
    this.push(null), t(e);
  };
  It.prototype.push = function(e, t) {
    var r = this._readableState, i;
    return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = Wf.from(e, t), t = ""), i =
    !0), tO(this, e, t, !1, i);
  };
  It.prototype.unshift = function(e) {
    return tO(this, e, null, !0, !1);
  };
  function tO(e, t, r, i, s) {
    var a = e._readableState;
    if (t === null)
      a.reading = !1, yae(e, a);
    else {
      var o;
      s || (o = pae(a, t)), o ? e.emit("error", o) : a.objectMode || t && t.length > 0 ? (typeof t != "string" && !a.objectMode && Object.getPrototypeOf(
      t) !== Wf.prototype && (t = lae(t)), i ? a.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : wv(e, a, t, !0) :
      a.ended ? e.emit("error", new Error("stream.push() after EOF")) : (a.reading = !1, a.decoder && !r ? (t = a.decoder.write(t), a.objectMode ||
      t.length !== 0 ? wv(e, a, t, !1) : rO(e, a)) : wv(e, a, t, !1))) : i || (a.reading = !1);
    }
    return hae(a);
  }
  n(tO, "readableAddChunk");
  function wv(e, t, r, i) {
    t.flowing && t.length === 0 && !t.sync ? (e.emit("data", r), e.read(0)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(
    r) : t.buffer.push(r), t.needReadable && V0(e)), rO(e, t);
  }
  n(wv, "addChunk");
  function pae(e, t) {
    var r;
    return !cae(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new TypeError("Invalid non-string/buffer chunk")), r;
  }
  n(pae, "chunkInvalid");
  function hae(e) {
    return !e.ended && (e.needReadable || e.length < e.highWaterMark || e.length === 0);
  }
  n(hae, "needMoreData");
  It.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  };
  It.prototype.setEncoding = function(e) {
    return bl || (bl = require("string_decoder/").StringDecoder), this._readableState.decoder = new bl(e), this._readableState.encoding = e,
    this;
  };
  var J9 = 8388608;
  function mae(e) {
    return e >= J9 ? e = J9 : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
  }
  n(mae, "computeNewHighWaterMark");
  function X9(e, t) {
    return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length :
    (e > t.highWaterMark && (t.highWaterMark = mae(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
  }
  n(X9, "howMuchToRead");
  It.prototype.read = function(e) {
    dt("read", e), e = parseInt(e, 10);
    var t = this._readableState, r = e;
    if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && (t.length >= t.highWaterMark || t.ended))
      return dt("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? Av(this) : V0(this), null;
    if (e = X9(e, t), e === 0 && t.ended)
      return t.length === 0 && Av(this), null;
    var i = t.needReadable;
    dt("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, dt("length less than watermark", i)), t.ended || t.
    reading ? (i = !1, dt("reading or ended", i)) : i && (dt("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0),
    this._read(t.highWaterMark), t.sync = !1, t.reading || (e = X9(r, t)));
    var s;
    return e > 0 ? s = iO(e, t) : s = null, s === null ? (t.needReadable = !0, e = 0) : t.length -= e, t.length === 0 && (t.ended || (t.needReadable =
    !0), r !== e && t.ended && Av(this)), s !== null && this.emit("data", s), s;
  };
  function yae(e, t) {
    if (!t.ended) {
      if (t.decoder) {
        var r = t.decoder.end();
        r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
      }
      t.ended = !0, V0(e);
    }
  }
  n(yae, "onEofChunk");
  function V0(e) {
    var t = e._readableState;
    t.needReadable = !1, t.emittedReadable || (dt("emitReadable", t.flowing), t.emittedReadable = !0, t.sync ? Dl.nextTick(Y9, e) : Y9(e));
  }
  n(V0, "emitReadable");
  function Y9(e) {
    dt("emit readable"), e.emit("readable"), Pv(e);
  }
  n(Y9, "emitReadable_");
  function rO(e, t) {
    t.readingMore || (t.readingMore = !0, Dl.nextTick(gae, e, t));
  }
  n(rO, "maybeReadMore");
  function gae(e, t) {
    for (var r = t.length; !t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark && (dt("maybeReadMore read 0"), e.read(0), r !==
    t.length); )
      r = t.length;
    t.readingMore = !1;
  }
  n(gae, "maybeReadMore_");
  It.prototype._read = function(e) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  It.prototype.pipe = function(e, t) {
    var r = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = e;
        break;
      case 1:
        i.pipes = [i.pipes, e];
        break;
      default:
        i.pipes.push(e);
        break;
    }
    i.pipesCount += 1, dt("pipe count=%d opts=%j", i.pipesCount, t);
    var s = (!t || t.end !== !1) && e !== process.stdout && e !== process.stderr, a = s ? u : g;
    i.endEmitted ? Dl.nextTick(a) : r.once("end", a), e.on("unpipe", o);
    function o(b, D) {
      dt("onunpipe"), b === r && D && D.hasUnpiped === !1 && (D.hasUnpiped = !0, f());
    }
    n(o, "onunpipe");
    function u() {
      dt("onend"), e.end();
    }
    n(u, "onend");
    var l = bae(r);
    e.on("drain", l);
    var c = !1;
    function f() {
      dt("cleanup"), e.removeListener("close", y), e.removeListener("finish", p), e.removeListener("drain", l), e.removeListener("error", d),
      e.removeListener("unpipe", o), r.removeListener("end", u), r.removeListener("end", g), r.removeListener("data", h), c = !0, i.awaitDrain &&
      (!e._writableState || e._writableState.needDrain) && l();
    }
    n(f, "cleanup");
    var m = !1;
    r.on("data", h);
    function h(b) {
      dt("ondata"), m = !1;
      var D = e.write(b);
      D === !1 && !m && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && sO(i.pipes, e) !== -1) && !c && (dt("false write respon\
se, pause", i.awaitDrain), i.awaitDrain++, m = !0), r.pause());
    }
    n(h, "ondata");
    function d(b) {
      dt("onerror", b), g(), e.removeListener("error", d), G9(e, "error") === 0 && e.emit("error", b);
    }
    n(d, "onerror"), dae(e, "error", d);
    function y() {
      e.removeListener("finish", p), g();
    }
    n(y, "onclose"), e.once("close", y);
    function p() {
      dt("onfinish"), e.removeListener("close", y), g();
    }
    n(p, "onfinish"), e.once("finish", p);
    function g() {
      dt("unpipe"), r.unpipe(e);
    }
    return n(g, "unpipe"), e.emit("pipe", r), i.flowing || (dt("pipe resume"), r.resume()), e;
  };
  function bae(e) {
    return function() {
      var t = e._readableState;
      dt("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, t.awaitDrain === 0 && G9(e, "data") && (t.flowing = !0, Pv(e));
    };
  }
  n(bae, "pipeOnDrain");
  It.prototype.unpipe = function(e) {
    var t = this._readableState, r = { hasUnpiped: !1 };
    if (t.pipesCount === 0) return this;
    if (t.pipesCount === 1)
      return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r),
      this);
    if (!e) {
      var i = t.pipes, s = t.pipesCount;
      t.pipes = null, t.pipesCount = 0, t.flowing = !1;
      for (var a = 0; a < s; a++)
        i[a].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var o = sO(t.pipes, e);
    return o === -1 ? this : (t.pipes.splice(o, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r),
    this);
  };
  It.prototype.on = function(e, t) {
    var r = _v.prototype.on.call(this, e, t);
    if (e === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (e === "readable") {
      var i = this._readableState;
      !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.emittedReadable = !1, i.reading ? i.length && V0(
      this) : Dl.nextTick(Dae, this));
    }
    return r;
  };
  It.prototype.addListener = It.prototype.on;
  function Dae(e) {
    dt("readable nexttick read 0"), e.read(0);
  }
  n(Dae, "nReadingNextTick");
  It.prototype.resume = function() {
    var e = this._readableState;
    return e.flowing || (dt("resume"), e.flowing = !0, vae(this, e)), this;
  };
  function vae(e, t) {
    t.resumeScheduled || (t.resumeScheduled = !0, Dl.nextTick(xae, e, t));
  }
  n(vae, "resume");
  function xae(e, t) {
    t.reading || (dt("resume read 0"), e.read(0)), t.resumeScheduled = !1, t.awaitDrain = 0, e.emit("resume"), Pv(e), t.flowing && !t.reading &&
    e.read(0);
  }
  n(xae, "resume_");
  It.prototype.pause = function() {
    return dt("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (dt("pause"), this._readableState.
    flowing = !1, this.emit("pause")), this;
  };
  function Pv(e) {
    var t = e._readableState;
    for (dt("flow", t.flowing); t.flowing && e.read() !== null; )
      ;
  }
  n(Pv, "flow");
  It.prototype.wrap = function(e) {
    var t = this, r = this._readableState, i = !1;
    e.on("end", function() {
      if (dt("wrapped end"), r.decoder && !r.ended) {
        var o = r.decoder.end();
        o && o.length && t.push(o);
      }
      t.push(null);
    }), e.on("data", function(o) {
      if (dt("wrapped data"), r.decoder && (o = r.decoder.write(o)), !(r.objectMode && o == null) && !(!r.objectMode && (!o || !o.length))) {
        var u = t.push(o);
        u || (i = !0, e.pause());
      }
    });
    for (var s in e)
      this[s] === void 0 && typeof e[s] == "function" && (this[s] = /* @__PURE__ */ function(o) {
        return function() {
          return e[o].apply(e, arguments);
        };
      }(s));
    for (var a = 0; a < Cv.length; a++)
      e.on(Cv[a], this.emit.bind(this, Cv[a]));
    return this._read = function(o) {
      dt("wrapped _read", o), i && (i = !1, e.resume());
    }, this;
  };
  Object.defineProperty(It.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.highWaterMark;
    }, "get")
  });
  It._fromList = iO;
  function iO(e, t) {
    if (t.length === 0) return null;
    var r;
    return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.
    head.data : r = t.buffer.concat(t.length), t.buffer.clear()) : r = Eae(e, t.buffer, t.decoder), r;
  }
  n(iO, "fromList");
  function Eae(e, t, r) {
    var i;
    return e < t.head.data.length ? (i = t.head.data.slice(0, e), t.head.data = t.head.data.slice(e)) : e === t.head.data.length ? i = t.shift() :
    i = r ? Sae(e, t) : Tae(e, t), i;
  }
  n(Eae, "fromListPartial");
  function Sae(e, t) {
    var r = t.head, i = 1, s = r.data;
    for (e -= s.length; r = r.next; ) {
      var a = r.data, o = e > a.length ? a.length : e;
      if (o === a.length ? s += a : s += a.slice(0, e), e -= o, e === 0) {
        o === a.length ? (++i, r.next ? t.head = r.next : t.head = t.tail = null) : (t.head = r, r.data = a.slice(o));
        break;
      }
      ++i;
    }
    return t.length -= i, s;
  }
  n(Sae, "copyFromBufferString");
  function Tae(e, t) {
    var r = Wf.allocUnsafe(e), i = t.head, s = 1;
    for (i.data.copy(r), e -= i.data.length; i = i.next; ) {
      var a = i.data, o = e > a.length ? a.length : e;
      if (a.copy(r, r.length - e, 0, o), e -= o, e === 0) {
        o === a.length ? (++s, i.next ? t.head = i.next : t.head = t.tail = null) : (t.head = i, i.data = a.slice(o));
        break;
      }
      ++s;
    }
    return t.length -= s, r;
  }
  n(Tae, "copyFromBuffer");
  function Av(e) {
    var t = e._readableState;
    if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    t.endEmitted || (t.ended = !0, Dl.nextTick(Cae, t, e));
  }
  n(Av, "endReadable");
  function Cae(e, t) {
    !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"));
  }
  n(Cae, "endReadableNT");
  function sO(e, t) {
    for (var r = 0, i = e.length; r < i; r++)
      if (e[r] === t) return r;
    return -1;
  }
  n(sO, "indexOf");
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/_stream_transform.js
var Fv = E((Kst, uO) => {
  "use strict";
  uO.exports = In;
  var W0 = Co(), oO = Object.create(dr());
  oO.inherits = St();
  oO.inherits(In, W0);
  function wae(e, t) {
    var r = this._transformState;
    r.transforming = !1;
    var i = r.writecb;
    if (!i)
      return this.emit("error", new Error("write callback called multiple times"));
    r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
    var s = this._readableState;
    s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
  n(wae, "afterTransform");
  function In(e) {
    if (!(this instanceof In)) return new In(e);
    W0.call(this, e), this._transformState = {
      afterTransform: wae.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.
    transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Aae);
  }
  n(In, "Transform");
  function Aae() {
    var e = this;
    typeof this._flush == "function" ? this._flush(function(t, r) {
      aO(e, t, r);
    }) : aO(this, null, null);
  }
  n(Aae, "prefinish");
  In.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, W0.prototype.push.call(this, e, t);
  };
  In.prototype._transform = function(e, t, r) {
    throw new Error("_transform() is not implemented");
  };
  In.prototype._write = function(e, t, r) {
    var i = this._transformState;
    if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
      var s = this._readableState;
      (i.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
    }
  };
  In.prototype._read = function(e) {
    var t = this._transformState;
    t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) :
    t.needTransform = !0;
  };
  In.prototype._destroy = function(e, t) {
    var r = this;
    W0.prototype._destroy.call(this, e, function(i) {
      t(i), r.emit("close");
    });
  };
  function aO(e, t, r) {
    if (t) return e.emit("error", t);
    if (r != null && e.push(r), e._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (e._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return e.push(null);
  }
  n(aO, "done");
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/_stream_passthrough.js
var dO = E((Jst, fO) => {
  "use strict";
  fO.exports = Hf;
  var lO = Fv(), cO = Object.create(dr());
  cO.inherits = St();
  cO.inherits(Hf, lO);
  function Hf(e) {
    if (!(this instanceof Hf)) return new Hf(e);
    lO.call(this, e);
  }
  n(Hf, "PassThrough");
  Hf.prototype._transform = function(e, t, r) {
    r(null, e);
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/readable.js
var pO = E((Fr, H0) => {
  var Hs = require("stream");
  process.env.READABLE_STREAM === "disable" && Hs ? (H0.exports = Hs, Fr = H0.exports = Hs.Readable, Fr.Readable = Hs.Readable, Fr.Writable =
  Hs.Writable, Fr.Duplex = Hs.Duplex, Fr.Transform = Hs.Transform, Fr.PassThrough = Hs.PassThrough, Fr.Stream = Hs) : (Fr = H0.exports = Sv(),
  Fr.Stream = Hs || Fr, Fr.Readable = Fr, Fr.Writable = vv(), Fr.Duplex = Co(), Fr.Transform = Fv(), Fr.PassThrough = dO());
});

// ../node_modules/pumpify/node_modules/duplexify/index.js
var bO = E((Yst, gO) => {
  var K0 = pO(), hO = Yu(), _ae = St(), Pae = zD(), mO = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]),
  Iv = /* @__PURE__ */ n(function(e, t) {
    e._corked ? e.once("uncork", t) : t();
  }, "onuncork"), Fae = /* @__PURE__ */ n(function(e, t) {
    e._autoDestroy && e.destroy(t);
  }, "autoDestroy"), yO = /* @__PURE__ */ n(function(e, t) {
    return function(r) {
      r ? Fae(e, r.message === "premature close" ? null : r) : t && !e._ended && e.end();
    };
  }, "destroyer"), Iae = /* @__PURE__ */ n(function(e, t) {
    if (!e || e._writableState && e._writableState.finished) return t();
    if (e._writableState) return e.end(t);
    e.end(), t();
  }, "end"), Oae = /* @__PURE__ */ n(function(e) {
    return new K0.Readable({ objectMode: !0, highWaterMark: 16 }).wrap(e);
  }, "toStreams2"), Ir = /* @__PURE__ */ n(function(e, t, r) {
    if (!(this instanceof Ir)) return new Ir(e, t, r);
    K0.Duplex.call(this, r), this._writable = null, this._readable = null, this._readable2 = null, this._autoDestroy = !r || r.autoDestroy !==
    !1, this._forwardDestroy = !r || r.destroy !== !1, this._forwardEnd = !r || r.end !== !1, this._corked = 1, this._ondrain = null, this._drained =
    !1, this._forwarding = !1, this._unwrite = null, this._unread = null, this._ended = !1, this.destroyed = !1, e && this.setWritable(e), t &&
    this.setReadable(t);
  }, "Duplexify");
  _ae(Ir, K0.Duplex);
  Ir.obj = function(e, t, r) {
    return r || (r = {}), r.objectMode = !0, r.highWaterMark = 16, new Ir(e, t, r);
  };
  Ir.prototype.cork = function() {
    ++this._corked === 1 && this.emit("cork");
  };
  Ir.prototype.uncork = function() {
    this._corked && --this._corked === 0 && this.emit("uncork");
  };
  Ir.prototype.setWritable = function(e) {
    if (this._unwrite && this._unwrite(), this.destroyed) {
      e && e.destroy && e.destroy();
      return;
    }
    if (e === null || e === !1) {
      this.end();
      return;
    }
    var t = this, r = hO(e, { writable: !0, readable: !1 }, yO(this, this._forwardEnd)), i = /* @__PURE__ */ n(function() {
      var a = t._ondrain;
      t._ondrain = null, a && a();
    }, "ondrain"), s = /* @__PURE__ */ n(function() {
      t._writable.removeListener("drain", i), r();
    }, "clear");
    this._unwrite && process.nextTick(i), this._writable = e, this._writable.on("drain", i), this._unwrite = s, this.uncork();
  };
  Ir.prototype.setReadable = function(e) {
    if (this._unread && this._unread(), this.destroyed) {
      e && e.destroy && e.destroy();
      return;
    }
    if (e === null || e === !1) {
      this.push(null), this.resume();
      return;
    }
    var t = this, r = hO(e, { writable: !1, readable: !0 }, yO(this)), i = /* @__PURE__ */ n(function() {
      t._forward();
    }, "onreadable"), s = /* @__PURE__ */ n(function() {
      t.push(null);
    }, "onend"), a = /* @__PURE__ */ n(function() {
      t._readable2.removeListener("readable", i), t._readable2.removeListener("end", s), r();
    }, "clear");
    this._drained = !0, this._readable = e, this._readable2 = e._readableState ? e : Oae(e), this._readable2.on("readable", i), this._readable2.
    on("end", s), this._unread = a, this._forward();
  };
  Ir.prototype._read = function() {
    this._drained = !0, this._forward();
  };
  Ir.prototype._forward = function() {
    if (!(this._forwarding || !this._readable2 || !this._drained)) {
      this._forwarding = !0;
      for (var e; this._drained && (e = Pae(this._readable2)) !== null; )
        this.destroyed || (this._drained = this.push(e));
      this._forwarding = !1;
    }
  };
  Ir.prototype.destroy = function(e) {
    if (!this.destroyed) {
      this.destroyed = !0;
      var t = this;
      process.nextTick(function() {
        t._destroy(e);
      });
    }
  };
  Ir.prototype._destroy = function(e) {
    if (e) {
      var t = this._ondrain;
      this._ondrain = null, t ? t(e) : this.emit("error", e);
    }
    this._forwardDestroy && (this._readable && this._readable.destroy && this._readable.destroy(), this._writable && this._writable.destroy &&
    this._writable.destroy()), this.emit("close");
  };
  Ir.prototype._write = function(e, t, r) {
    if (this.destroyed) return r();
    if (this._corked) return Iv(this, this._write.bind(this, e, t, r));
    if (e === mO) return this._finish(r);
    if (!this._writable) return r();
    this._writable.write(e) === !1 ? this._ondrain = r : r();
  };
  Ir.prototype._finish = function(e) {
    var t = this;
    this.emit("preend"), Iv(this, function() {
      Iae(t._forwardEnd && t._writable, function() {
        t._writableState.prefinished === !1 && (t._writableState.prefinished = !0), t.emit("prefinish"), Iv(t, e);
      });
    });
  };
  Ir.prototype.end = function(e, t, r) {
    return typeof e == "function" ? this.end(null, null, e) : typeof t == "function" ? this.end(e, null, t) : (this._ended = !0, e && this.write(
    e), this._writableState.ending || this.write(mO), K0.Writable.prototype.end.call(this, r));
  };
  gO.exports = Ir;
});

// ../node_modules/pumpify/index.js
var xO = E((Zst, z0) => {
  var kae = A9(), Bae = St(), DO = bO(), vO = /* @__PURE__ */ n(function(e) {
    return e.length ? Array.isArray(e[0]) ? e[0] : Array.prototype.slice.call(e) : [];
  }, "toArray"), Ov = /* @__PURE__ */ n(function(e) {
    var t = /* @__PURE__ */ n(function() {
      var r = vO(arguments);
      if (!(this instanceof t)) return new t(r);
      DO.call(this, null, null, e), r.length && this.setPipeline(r);
    }, "Pumpify");
    return Bae(t, DO), t.prototype.setPipeline = function() {
      var r = vO(arguments), i = this, s = !1, a = r[0], o = r[r.length - 1];
      o = o.readable ? o : null, a = a.writable ? a : null;
      var u = /* @__PURE__ */ n(function() {
        r[0].emit("error", new Error("stream was destroyed"));
      }, "onclose");
      if (this.on("close", u), this.on("prefinish", function() {
        s || i.cork();
      }), kae(r, function(l) {
        if (i.removeListener("close", u), l) return i.destroy(l.message === "premature close" ? null : l);
        s = !0, i._autoDestroy === !1 && (i._autoDestroy = !0), i.uncork();
      }), this.destroyed) return u();
      this.setWritable(a), this.setReadable(o);
    }, t;
  }, "define");
  z0.exports = Ov({ autoDestroy: !1, destroy: !1 });
  z0.exports.obj = Ov({ autoDestroy: !1, destroy: !1, objectMode: !0, highWaterMark: 16 });
  z0.exports.ctor = Ov;
});

// ../node_modules/is-gzip/index.js
var SO = E((ent, EO) => {
  "use strict";
  EO.exports = function(e) {
    return !e || e.length < 3 ? !1 : e[0] === 31 && e[1] === 139 && e[2] === 8;
  };
});

// ../node_modules/is-deflate/index.js
var CO = E((tnt, TO) => {
  "use strict";
  TO.exports = function(e) {
    return !e || e.length < 2 ? !1 : e[0] === 120 && (e[1] === 1 || e[1] === 156 || e[1] === 218);
  };
});

// ../node_modules/gunzip-maybe/index.js
var PO = E((rnt, _O) => {
  var wO = require("zlib"), Nae = T9(), Mae = dv(), AO = xO(), Rae = SO(), Lae = CO(), jae = /* @__PURE__ */ n(function(e) {
    return Rae(e) ? 1 : Lae(e) ? 2 : 0;
  }, "isCompressed"), kv = /* @__PURE__ */ n(function(e) {
    return e === void 0 && (e = 3), Nae({ newline: !1, maxBuffer: 10 }, function(t, r) {
      if (e < 0) return r(new Error("Maximum recursion reached"));
      switch (jae(t)) {
        case 1:
          r(null, AO(wO.createGunzip(), kv(e - 1)));
          break;
        case 2:
          r(null, AO(wO.createInflate(), kv(e - 1)));
          break;
        default:
          r(null, Mae());
      }
    });
  }, "gunzip");
  _O.exports = kv;
});

// ../node_modules/@ndelangen/get-tarball/dist/index.js
var Tk = E((ant, Sk) => {
  "use strict";
  var qae = Object.create, sm = Object.defineProperty, Uae = Object.getOwnPropertyDescriptor, ek = Object.getOwnPropertyNames, $ae = Object.
  getPrototypeOf, Vae = Object.prototype.hasOwnProperty, nt = /* @__PURE__ */ n((e, t) => /* @__PURE__ */ n(function() {
    return t || (0, e[ek(e)[0]])((t = { exports: {} }).exports, t), t.exports;
  }, "__require"), "__commonJS"), Wae = /* @__PURE__ */ n((e, t) => {
    for (var r in t)
      sm(e, r, { get: t[r], enumerable: !0 });
  }, "__export"), tk = /* @__PURE__ */ n((e, t, r, i) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let s of ek(t))
        !Vae.call(e, s) && s !== r && sm(e, s, { get: /* @__PURE__ */ n(() => t[s], "get"), enumerable: !(i = Uae(t, s)) || i.enumerable });
    return e;
  }, "__copyProps"), ur = /* @__PURE__ */ n((e, t, r) => (r = e != null ? qae($ae(e)) : {}, tk(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    t || !e || !e.__esModule ? sm(r, "default", { value: e, enumerable: !0 }) : r,
    e
  )), "__toESM"), Hae = /* @__PURE__ */ n((e) => tk(sm({}, "__esModule", { value: !0 }), e), "__toCommonJS"), Kae = nt({
    "node_modules/.pnpm/defer-to-connect@2.0.1/node_modules/defer-to-connect/dist/source/index.js"(e, t) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 });
      function r(s) {
        return s.encrypted;
      }
      n(r, "isTLSSocket");
      var i = /* @__PURE__ */ n((s, a) => {
        let o;
        typeof a == "function" ? o = { connect: a } : o = a;
        let u = typeof o.connect == "function", l = typeof o.secureConnect == "function", c = typeof o.close == "function", f = /* @__PURE__ */ n(
        () => {
          u && o.connect(), r(s) && l && (s.authorized ? o.secureConnect() : s.authorizationError || s.once("secureConnect", o.secureConnect)),
          c && s.once("close", o.close);
        }, "onConnect");
        s.writable && !s.connecting ? f() : s.connecting ? s.once("connect", f) : s.destroyed && c && o.close(s._hadError);
      }, "deferToConnect2");
      e.default = i, t.exports = i, t.exports.default = i;
    }
  }), zae = nt({
    "node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js"(e, t) {
      "use strict";
      var { PassThrough: r } = require("stream");
      t.exports = (i) => {
        i = { ...i };
        let { array: s } = i, { encoding: a } = i, o = a === "buffer", u = !1;
        s ? u = !(a || o) : a = a || "utf8", o && (a = null);
        let l = new r({ objectMode: u });
        a && l.setEncoding(a);
        let c = 0, f = [];
        return l.on("data", (m) => {
          f.push(m), u ? c = f.length : c += m.length;
        }), l.getBufferedValue = () => s ? f : o ? Buffer.concat(f, c) : f.join(""), l.getBufferedLength = () => c, l;
      };
    }
  }), rk = nt({
    "node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js"(e, t) {
      "use strict";
      var { constants: r } = require("buffer"), i = require("stream"), { promisify: s } = require("util"), a = zae(), o = s(i.pipeline), u = class extends Error {
        static {
          n(this, "MaxBufferError");
        }
        constructor() {
          super("maxBuffer exceeded"), this.name = "MaxBufferError";
        }
      };
      async function l(c, f) {
        if (!c)
          throw new Error("Expected a stream");
        f = {
          maxBuffer: 1 / 0,
          ...f
        };
        let { maxBuffer: m } = f, h = a(f);
        return await new Promise((d, y) => {
          let p = /* @__PURE__ */ n((g) => {
            g && h.getBufferedLength() <= r.MAX_LENGTH && (g.bufferedData = h.getBufferedValue()), y(g);
          }, "rejectPromise");
          (async () => {
            try {
              await o(c, h), d();
            } catch (g) {
              p(g);
            }
          })(), h.on("data", () => {
            h.getBufferedLength() > m && p(new u());
          });
        }), h.getBufferedValue();
      }
      n(l, "getStream2"), t.exports = l, t.exports.buffer = (c, f) => l(c, { ...f, encoding: "buffer" }), t.exports.array = (c, f) => l(c, {
      ...f, array: !0 }), t.exports.MaxBufferError = u;
    }
  }), Jae = nt({
    "node_modules/.pnpm/http-cache-semantics@4.1.1/node_modules/http-cache-semantics/index.js"(e, t) {
      "use strict";
      var r = /* @__PURE__ */ new Set([
        200,
        203,
        204,
        206,
        300,
        301,
        308,
        404,
        405,
        410,
        414,
        501
      ]), i = /* @__PURE__ */ new Set([
        200,
        203,
        204,
        300,
        301,
        302,
        303,
        307,
        308,
        404,
        405,
        410,
        414,
        501
      ]), s = /* @__PURE__ */ new Set([
        500,
        502,
        503,
        504
      ]), a = {
        date: !0,
        // included, because we add Age update Date
        connection: !0,
        "keep-alive": !0,
        "proxy-authenticate": !0,
        "proxy-authorization": !0,
        te: !0,
        trailer: !0,
        "transfer-encoding": !0,
        upgrade: !0
      }, o = {
        // Since the old body is reused, it doesn't make sense to change properties of the body
        "content-length": !0,
        "content-encoding": !0,
        "transfer-encoding": !0,
        "content-range": !0
      };
      function u(m) {
        let h = parseInt(m, 10);
        return isFinite(h) ? h : 0;
      }
      n(u, "toNumberOrZero");
      function l(m) {
        return m ? s.has(m.status) : !0;
      }
      n(l, "isErrorResponse");
      function c(m) {
        let h = {};
        if (!m)
          return h;
        let d = m.trim().split(/,/);
        for (let y of d) {
          let [p, g] = y.split(/=/, 2);
          h[p.trim()] = g === void 0 ? !0 : g.trim().replace(/^"|"$/g, "");
        }
        return h;
      }
      n(c, "parseCacheControl");
      function f(m) {
        let h = [];
        for (let d in m) {
          let y = m[d];
          h.push(y === !0 ? d : d + "=" + y);
        }
        if (h.length)
          return h.join(", ");
      }
      n(f, "formatCacheControl"), t.exports = class {
        static {
          n(this, "CachePolicy");
        }
        constructor(h, d, {
          shared: y,
          cacheHeuristic: p,
          immutableMinTimeToLive: g,
          ignoreCargoCult: b,
          _fromObject: D
        } = {}) {
          if (D) {
            this._fromObject(D);
            return;
          }
          if (!d || !d.headers)
            throw Error("Response headers missing");
          this._assertRequestHasHeaders(h), this._responseTime = this.now(), this._isShared = y !== !1, this._cacheHeuristic = p !== void 0 ?
          p : 0.1, this._immutableMinTtl = g !== void 0 ? g : 24 * 3600 * 1e3, this._status = "status" in d ? d.status : 200, this._resHeaders =
          d.headers, this._rescc = c(d.headers["cache-control"]), this._method = "method" in h ? h.method : "GET", this._url = h.url, this._host =
          h.headers.host, this._noAuthorization = !h.headers.authorization, this._reqHeaders = d.headers.vary ? h.headers : null, this._reqcc =
          c(h.headers["cache-control"]), b && "pre-check" in this._rescc && "post-check" in this._rescc && (delete this._rescc["pre-check"],
          delete this._rescc["post-check"], delete this._rescc["no-cache"], delete this._rescc["no-store"], delete this._rescc["must-revalid\
ate"], this._resHeaders = Object.assign({}, this._resHeaders, {
            "cache-control": f(this._rescc)
          }), delete this._resHeaders.expires, delete this._resHeaders.pragma), d.headers["cache-control"] == null && /no-cache/.test(d.headers.
          pragma) && (this._rescc["no-cache"] = !0);
        }
        now() {
          return Date.now();
        }
        storable() {
          return !!(!this._reqcc["no-store"] && // A cache MUST NOT store a response to any request, unless:
          // The request method is understood by the cache and defined as being cacheable, and
          (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and
          i.has(this._status) && // the "no-store" cache directive does not appear in request or response header fields, and
          !this._rescc["no-store"] && // the "private" response directive does not appear in the response, if the cache is shared, and
          (!this._isShared || !this._rescc.private) && // the Authorization header field does not appear in the request, if the cache is shared,
          (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && // the response either:
          // contains an Expires header field, or
          (this._resHeaders.expires || // contains a max-age response directive, or
          // contains a s-maxage response directive and the cache is shared, or
          // contains a public response directive.
          this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || // has a status code that is defined as cacheable by default
          r.has(this._status)));
        }
        _hasExplicitExpiration() {
          return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
        }
        _assertRequestHasHeaders(h) {
          if (!h || !h.headers)
            throw Error("Request headers missing");
        }
        satisfiesWithoutRevalidation(h) {
          this._assertRequestHasHeaders(h);
          let d = c(h.headers["cache-control"]);
          return d["no-cache"] || /no-cache/.test(h.headers.pragma) || d["max-age"] && this.age() > d["max-age"] || d["min-fresh"] && this.timeToLive() <
          1e3 * d["min-fresh"] || this.stale() && !(d["max-stale"] && !this._rescc["must-revalidate"] && (d["max-stale"] === !0 || d["max-st\
ale"] > this.age() - this.maxAge())) ? !1 : this._requestMatches(h, !1);
        }
        _requestMatches(h, d) {
          return (!this._url || this._url === h.url) && this._host === h.headers.host && // the request method associated with the stored response allows it to be used for the presented request, and
          (!h.method || this._method === h.method || d && h.method === "HEAD") && // selecting header fields nominated by the stored response (if any) match those presented, and
          this._varyMatches(h);
        }
        _allowsStoringAuthenticated() {
          return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
        }
        _varyMatches(h) {
          if (!this._resHeaders.vary)
            return !0;
          if (this._resHeaders.vary === "*")
            return !1;
          let d = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
          for (let y of d)
            if (h.headers[y] !== this._reqHeaders[y])
              return !1;
          return !0;
        }
        _copyWithoutHopByHopHeaders(h) {
          let d = {};
          for (let y in h)
            a[y] || (d[y] = h[y]);
          if (h.connection) {
            let y = h.connection.trim().split(/\s*,\s*/);
            for (let p of y)
              delete d[p];
          }
          if (d.warning) {
            let y = d.warning.split(/,/).filter((p) => !/^\s*1[0-9][0-9]/.test(p));
            y.length ? d.warning = y.join(",").trim() : delete d.warning;
          }
          return d;
        }
        responseHeaders() {
          let h = this._copyWithoutHopByHopHeaders(this._resHeaders), d = this.age();
          return d > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24 && (h.warning = (h.warning ? `${h.warning}, ` :
          "") + '113 - "rfc7234 5.5.4"'), h.age = `${Math.round(d)}`, h.date = new Date(this.now()).toUTCString(), h;
        }
        /**
         * Value of the Date response header or current time if Date was invalid
         * @return timestamp
         */
        date() {
          let h = Date.parse(this._resHeaders.date);
          return isFinite(h) ? h : this._responseTime;
        }
        /**
         * Value of the Age header, in seconds, updated for the current time.
         * May be fractional.
         *
         * @return Number
         */
        age() {
          let h = this._ageValue(), d = (this.now() - this._responseTime) / 1e3;
          return h + d;
        }
        _ageValue() {
          return u(this._resHeaders.age);
        }
        /**
         * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
         *
         * For an up-to-date value, see `timeToLive()`.
         *
         * @return Number
         */
        maxAge() {
          if (!this.storable() || this._rescc["no-cache"] || this._isShared && this._resHeaders["set-cookie"] && !this._rescc.public && !this.
          _rescc.immutable || this._resHeaders.vary === "*")
            return 0;
          if (this._isShared) {
            if (this._rescc["proxy-revalidate"])
              return 0;
            if (this._rescc["s-maxage"])
              return u(this._rescc["s-maxage"]);
          }
          if (this._rescc["max-age"])
            return u(this._rescc["max-age"]);
          let h = this._rescc.immutable ? this._immutableMinTtl : 0, d = this.date();
          if (this._resHeaders.expires) {
            let y = Date.parse(this._resHeaders.expires);
            return Number.isNaN(y) || y < d ? 0 : Math.max(h, (y - d) / 1e3);
          }
          if (this._resHeaders["last-modified"]) {
            let y = Date.parse(this._resHeaders["last-modified"]);
            if (isFinite(y) && d > y)
              return Math.max(
                h,
                (d - y) / 1e3 * this._cacheHeuristic
              );
          }
          return h;
        }
        timeToLive() {
          let h = this.maxAge() - this.age(), d = h + u(this._rescc["stale-if-error"]), y = h + u(this._rescc["stale-while-revalidate"]);
          return Math.max(0, h, d, y) * 1e3;
        }
        stale() {
          return this.maxAge() <= this.age();
        }
        _useStaleIfError() {
          return this.maxAge() + u(this._rescc["stale-if-error"]) > this.age();
        }
        useStaleWhileRevalidate() {
          return this.maxAge() + u(this._rescc["stale-while-revalidate"]) > this.age();
        }
        static fromObject(h) {
          return new this(void 0, void 0, { _fromObject: h });
        }
        _fromObject(h) {
          if (this._responseTime)
            throw Error("Reinitialized");
          if (!h || h.v !== 1)
            throw Error("Invalid serialization");
          this._responseTime = h.t, this._isShared = h.sh, this._cacheHeuristic = h.ch, this._immutableMinTtl = h.imm !== void 0 ? h.imm : 24 *
          3600 * 1e3, this._status = h.st, this._resHeaders = h.resh, this._rescc = h.rescc, this._method = h.m, this._url = h.u, this._host =
          h.h, this._noAuthorization = h.a, this._reqHeaders = h.reqh, this._reqcc = h.reqcc;
        }
        toObject() {
          return {
            v: 1,
            t: this._responseTime,
            sh: this._isShared,
            ch: this._cacheHeuristic,
            imm: this._immutableMinTtl,
            st: this._status,
            resh: this._resHeaders,
            rescc: this._rescc,
            m: this._method,
            u: this._url,
            h: this._host,
            a: this._noAuthorization,
            reqh: this._reqHeaders,
            reqcc: this._reqcc
          };
        }
        /**
         * Headers for sending to the origin server to revalidate stale response.
         * Allows server to return 304 to allow reuse of the previous response.
         *
         * Hop by hop headers are always stripped.
         * Revalidation headers may be added or removed, depending on request.
         */
        revalidationHeaders(h) {
          this._assertRequestHasHeaders(h);
          let d = this._copyWithoutHopByHopHeaders(h.headers);
          if (delete d["if-range"], !this._requestMatches(h, !0) || !this.storable())
            return delete d["if-none-match"], delete d["if-modified-since"], d;
          if (this._resHeaders.etag && (d["if-none-match"] = d["if-none-match"] ? `${d["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.
          etag), d["accept-ranges"] || d["if-match"] || d["if-unmodified-since"] || this._method && this._method != "GET") {
            if (delete d["if-modified-since"], d["if-none-match"]) {
              let p = d["if-none-match"].split(/,/).filter((g) => !/^\s*W\//.test(g));
              p.length ? d["if-none-match"] = p.join(",").trim() : delete d["if-none-match"];
            }
          } else this._resHeaders["last-modified"] && !d["if-modified-since"] && (d["if-modified-since"] = this._resHeaders["last-modified"]);
          return d;
        }
        /**
         * Creates new CachePolicy with information combined from the previews response,
         * and the new revalidation response.
         *
         * Returns {policy, modified} where modified is a boolean indicating
         * whether the response body has been modified, and old cached body can't be used.
         *
         * @return {Object} {policy: CachePolicy, modified: Boolean}
         */
        revalidatedPolicy(h, d) {
          if (this._assertRequestHasHeaders(h), this._useStaleIfError() && l(d))
            return {
              modified: !1,
              matches: !1,
              policy: this
            };
          if (!d || !d.headers)
            throw Error("Response headers missing");
          let y = !1;
          if (d.status !== void 0 && d.status != 304 ? y = !1 : d.headers.etag && !/^\s*W\//.test(d.headers.etag) ? y = this._resHeaders.etag &&
          this._resHeaders.etag.replace(/^\s*W\//, "") === d.headers.etag : this._resHeaders.etag && d.headers.etag ? y = this._resHeaders.etag.
          replace(/^\s*W\//, "") === d.headers.etag.replace(/^\s*W\//, "") : this._resHeaders["last-modified"] ? y = this._resHeaders["last-\
modified"] === d.headers["last-modified"] : !this._resHeaders.etag && !this._resHeaders["last-modified"] && !d.headers.etag && !d.headers["l\
ast-modified"] && (y = !0), !y)
            return {
              policy: new this.constructor(h, d),
              // Client receiving 304 without body, even if it's invalid/mismatched has no option
              // but to reuse a cached body. We don't have a good way to tell clients to do
              // error recovery in such case.
              modified: d.status != 304,
              matches: !1
            };
          let p = {};
          for (let b in this._resHeaders)
            p[b] = b in d.headers && !o[b] ? d.headers[b] : this._resHeaders[b];
          let g = Object.assign({}, d, {
            status: this._status,
            method: this._method,
            headers: p
          });
          return {
            policy: new this.constructor(h, g, {
              shared: this._isShared,
              cacheHeuristic: this._cacheHeuristic,
              immutableMinTimeToLive: this._immutableMinTtl
            }),
            modified: !1,
            matches: !0
          };
        }
      };
    }
  }), Xae = nt({
    "node_modules/.pnpm/json-buffer@3.0.1/node_modules/json-buffer/index.js"(e) {
      e.stringify = /* @__PURE__ */ n(function t(r) {
        if (typeof r > "u")
          return r;
        if (r && Buffer.isBuffer(r))
          return JSON.stringify(":base64:" + r.toString("base64"));
        if (r && r.toJSON && (r = r.toJSON()), r && typeof r == "object") {
          var i = "", s = Array.isArray(r);
          i = s ? "[" : "{";
          var a = !0;
          for (var o in r) {
            var u = typeof r[o] == "function" || !s && typeof r[o] > "u";
            Object.hasOwnProperty.call(r, o) && !u && (a || (i += ","), a = !1, s ? r[o] == null ? i += "null" : i += t(r[o]) : r[o] !== void 0 &&
            (i += t(o) + ":" + t(r[o])));
          }
          return i += s ? "]" : "}", i;
        } else return typeof r == "string" ? JSON.stringify(/^:/.test(r) ? ":" + r : r) : typeof r > "u" ? "null" : JSON.stringify(r);
      }, "stringify"), e.parse = function(t) {
        return JSON.parse(t, function(r, i) {
          return typeof i == "string" ? /^:base64:/.test(i) ? Buffer.from(i.substring(8), "base64") : /^:/.test(i) ? i.substring(1) : i : i;
        });
      };
    }
  }), Yae = nt({
    "node_modules/.pnpm/keyv@4.5.2/node_modules/keyv/src/index.js"(e, t) {
      "use strict";
      var r = require("events"), i = Xae(), s = /* @__PURE__ */ n((u) => {
        let l = {
          redis: "@keyv/redis",
          rediss: "@keyv/redis",
          mongodb: "@keyv/mongo",
          mongo: "@keyv/mongo",
          sqlite: "@keyv/sqlite",
          postgresql: "@keyv/postgres",
          postgres: "@keyv/postgres",
          mysql: "@keyv/mysql",
          etcd: "@keyv/etcd",
          offline: "@keyv/offline",
          tiered: "@keyv/tiered"
        };
        if (u.adapter || u.uri) {
          let c = u.adapter || /^[^:+]*/.exec(u.uri)[0];
          return new (require(l[c]))(u);
        }
        return /* @__PURE__ */ new Map();
      }, "loadStore"), a = [
        "sqlite",
        "postgres",
        "mysql",
        "mongo",
        "redis",
        "tiered"
      ], o = class extends r {
        static {
          n(this, "Keyv2");
        }
        constructor(u, { emitErrors: l = !0, ...c } = {}) {
          if (super(), this.opts = {
            namespace: "keyv",
            serialize: i.stringify,
            deserialize: i.parse,
            ...typeof u == "string" ? { uri: u } : u,
            ...c
          }, !this.opts.store) {
            let m = { ...this.opts };
            this.opts.store = s(m);
          }
          if (this.opts.compression) {
            let m = this.opts.compression;
            this.opts.serialize = m.serialize.bind(m), this.opts.deserialize = m.deserialize.bind(m);
          }
          typeof this.opts.store.on == "function" && l && this.opts.store.on("error", (m) => this.emit("error", m)), this.opts.store.namespace =
          this.opts.namespace;
          let f = /* @__PURE__ */ n((m) => async function* () {
            for await (let [h, d] of typeof m == "function" ? m(this.opts.store.namespace) : m) {
              let y = this.opts.deserialize(d);
              if (!(this.opts.store.namespace && !h.includes(this.opts.store.namespace))) {
                if (typeof y.expires == "number" && Date.now() > y.expires) {
                  this.delete(h);
                  continue;
                }
                yield [this._getKeyUnprefix(h), y.value];
              }
            }
          }, "generateIterator");
          typeof this.opts.store[Symbol.iterator] == "function" && this.opts.store instanceof Map ? this.iterator = f(this.opts.store) : typeof this.
          opts.store.iterator == "function" && this.opts.store.opts && this._checkIterableAdaptar() && (this.iterator = f(this.opts.store.iterator.
          bind(this.opts.store)));
        }
        _checkIterableAdaptar() {
          return a.includes(this.opts.store.opts.dialect) || a.findIndex((u) => this.opts.store.opts.url.includes(u)) >= 0;
        }
        _getKeyPrefix(u) {
          return `${this.opts.namespace}:${u}`;
        }
        _getKeyPrefixArray(u) {
          return u.map((l) => `${this.opts.namespace}:${l}`);
        }
        _getKeyUnprefix(u) {
          return u.split(":").splice(1).join(":");
        }
        get(u, l) {
          let { store: c } = this.opts, f = Array.isArray(u), m = f ? this._getKeyPrefixArray(u) : this._getKeyPrefix(u);
          if (f && c.getMany === void 0) {
            let h = [];
            for (let d of m)
              h.push(
                Promise.resolve().then(() => c.get(d)).then((y) => typeof y == "string" ? this.opts.deserialize(y) : this.opts.compression ?
                this.opts.deserialize(y) : y).then((y) => {
                  if (y != null)
                    return typeof y.expires == "number" && Date.now() > y.expires ? this.delete(d).then(() => {
                    }) : l && l.raw ? y : y.value;
                })
              );
            return Promise.allSettled(h).then((d) => {
              let y = [];
              for (let p of d)
                y.push(p.value);
              return y;
            });
          }
          return Promise.resolve().then(() => f ? c.getMany(m) : c.get(m)).then((h) => typeof h == "string" ? this.opts.deserialize(h) : this.
          opts.compression ? this.opts.deserialize(h) : h).then((h) => {
            if (h != null) {
              if (f) {
                let d = [];
                for (let y of h) {
                  if (typeof y == "string" && (y = this.opts.deserialize(y)), y == null) {
                    d.push(void 0);
                    continue;
                  }
                  typeof y.expires == "number" && Date.now() > y.expires ? (this.delete(u).then(() => {
                  }), d.push(void 0)) : d.push(l && l.raw ? y : y.value);
                }
                return d;
              }
              return typeof h.expires == "number" && Date.now() > h.expires ? this.delete(u).then(() => {
              }) : l && l.raw ? h : h.value;
            }
          });
        }
        set(u, l, c) {
          let f = this._getKeyPrefix(u);
          typeof c > "u" && (c = this.opts.ttl), c === 0 && (c = void 0);
          let { store: m } = this.opts;
          return Promise.resolve().then(() => {
            let h = typeof c == "number" ? Date.now() + c : null;
            return typeof l == "symbol" && this.emit("error", "symbol cannot be serialized"), l = { value: l, expires: h }, this.opts.serialize(
            l);
          }).then((h) => m.set(f, h, c)).then(() => !0);
        }
        delete(u) {
          let { store: l } = this.opts;
          if (Array.isArray(u)) {
            let f = this._getKeyPrefixArray(u);
            if (l.deleteMany === void 0) {
              let m = [];
              for (let h of f)
                m.push(l.delete(h));
              return Promise.allSettled(m).then((h) => h.every((d) => d.value === !0));
            }
            return Promise.resolve().then(() => l.deleteMany(f));
          }
          let c = this._getKeyPrefix(u);
          return Promise.resolve().then(() => l.delete(c));
        }
        clear() {
          let { store: u } = this.opts;
          return Promise.resolve().then(() => u.clear());
        }
        has(u) {
          let l = this._getKeyPrefix(u), { store: c } = this.opts;
          return Promise.resolve().then(async () => typeof c.has == "function" ? c.has(l) : await c.get(l) !== void 0);
        }
        disconnect() {
          let { store: u } = this.opts;
          if (typeof u.disconnect == "function")
            return u.disconnect();
        }
      };
      t.exports = o;
    }
  }), Gae = nt({
    "node_modules/.pnpm/mimic-response@3.1.0/node_modules/mimic-response/index.js"(e, t) {
      "use strict";
      var r = [
        "aborted",
        "complete",
        "headers",
        "httpVersion",
        "httpVersionMinor",
        "httpVersionMajor",
        "method",
        "rawHeaders",
        "rawTrailers",
        "setTimeout",
        "socket",
        "statusCode",
        "statusMessage",
        "trailers",
        "url"
      ];
      t.exports = (i, s) => {
        if (s._readableState.autoDestroy)
          throw new Error("The second stream must have the `autoDestroy` option set to `false`");
        let a = new Set(Object.keys(i).concat(r)), o = {};
        for (let u of a)
          u in s || (o[u] = {
            get() {
              let l = i[u];
              return typeof l == "function" ? l.bind(i) : l;
            },
            set(l) {
              i[u] = l;
            },
            enumerable: !0,
            configurable: !1
          });
        return Object.defineProperties(s, o), i.once("aborted", () => {
          s.destroy(), s.emit("aborted");
        }), i.once("close", () => {
          i.complete && s.readable ? s.once("end", () => {
            s.emit("close");
          }) : s.emit("close");
        }), s;
      };
    }
  }), Zae = nt({
    "node_modules/.pnpm/decompress-response@6.0.0/node_modules/decompress-response/index.js"(e, t) {
      "use strict";
      var { Transform: r, PassThrough: i } = require("stream"), s = require("zlib"), a = Gae();
      t.exports = (o) => {
        let u = (o.headers["content-encoding"] || "").toLowerCase();
        if (!["gzip", "deflate", "br"].includes(u))
          return o;
        let l = u === "br";
        if (l && typeof s.createBrotliDecompress != "function")
          return o.destroy(new Error("Brotli is not supported on Node.js < 12")), o;
        let c = !0, f = new r({
          transform(d, y, p) {
            c = !1, p(null, d);
          },
          flush(d) {
            d();
          }
        }), m = new i({
          autoDestroy: !1,
          destroy(d, y) {
            o.destroy(), y(d);
          }
        }), h = l ? s.createBrotliDecompress() : s.createUnzip();
        return h.once("error", (d) => {
          if (c && !o.readable) {
            m.end();
            return;
          }
          m.destroy(d);
        }), a(o, m), o.pipe(f).pipe(h).pipe(m), m;
      };
    }
  }), ik = nt({
    "node_modules/.pnpm/quick-lru@5.1.1/node_modules/quick-lru/index.js"(e, t) {
      "use strict";
      var r = class {
        static {
          n(this, "QuickLRU");
        }
        constructor(i = {}) {
          if (!(i.maxSize && i.maxSize > 0))
            throw new TypeError("`maxSize` must be a number greater than 0");
          this.maxSize = i.maxSize, this.onEviction = i.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(),
          this._size = 0;
        }
        _set(i, s) {
          if (this.cache.set(i, s), this._size++, this._size >= this.maxSize) {
            if (this._size = 0, typeof this.onEviction == "function")
              for (let [a, o] of this.oldCache.entries())
                this.onEviction(a, o);
            this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map();
          }
        }
        get(i) {
          if (this.cache.has(i))
            return this.cache.get(i);
          if (this.oldCache.has(i)) {
            let s = this.oldCache.get(i);
            return this.oldCache.delete(i), this._set(i, s), s;
          }
        }
        set(i, s) {
          return this.cache.has(i) ? this.cache.set(i, s) : this._set(i, s), this;
        }
        has(i) {
          return this.cache.has(i) || this.oldCache.has(i);
        }
        peek(i) {
          if (this.cache.has(i))
            return this.cache.get(i);
          if (this.oldCache.has(i))
            return this.oldCache.get(i);
        }
        delete(i) {
          let s = this.cache.delete(i);
          return s && this._size--, this.oldCache.delete(i) || s;
        }
        clear() {
          this.cache.clear(), this.oldCache.clear(), this._size = 0;
        }
        *keys() {
          for (let [i] of this)
            yield i;
        }
        *values() {
          for (let [, i] of this)
            yield i;
        }
        *[Symbol.iterator]() {
          for (let i of this.cache)
            yield i;
          for (let i of this.oldCache) {
            let [s] = i;
            this.cache.has(s) || (yield i);
          }
        }
        get size() {
          let i = 0;
          for (let s of this.oldCache.keys())
            this.cache.has(s) || i++;
          return Math.min(this._size + i, this.maxSize);
        }
      };
      t.exports = r;
    }
  }), sk = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/delay-async-destroy.js"(e, t) {
      "use strict";
      t.exports = (r) => {
        if (r.listenerCount("error") !== 0)
          return r;
        r.__destroy = r._destroy, r._destroy = (...s) => {
          let a = s.pop();
          r.__destroy(...s, async (o) => {
            await Promise.resolve(), a(o);
          });
        };
        let i = /* @__PURE__ */ n((s) => {
          Promise.resolve().then(() => {
            r.emit("error", s);
          });
        }, "onError");
        return r.once("error", i), Promise.resolve().then(() => {
          r.off("error", i);
        }), r;
      };
    }
  }), El = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/agent.js"(e, t) {
      "use strict";
      var { URL: r } = require("url"), i = require("events"), s = require("tls"), a = require("http2"), o = ik(), u = sk(), l = Symbol("curr\
entStreamCount"), c = Symbol("request"), f = Symbol("cachedOriginSet"), m = Symbol("gracefullyClosing"), h = Symbol("length"), d = [
        // Not an Agent option actually
        "createConnection",
        // `http2.connect()` options
        "maxDeflateDynamicTableSize",
        "maxSettings",
        "maxSessionMemory",
        "maxHeaderListPairs",
        "maxOutstandingPings",
        "maxReservedRemoteStreams",
        "maxSendHeaderBlockLength",
        "paddingStrategy",
        "peerMaxConcurrentStreams",
        "settings",
        // `tls.connect()` source options
        "family",
        "localAddress",
        "rejectUnauthorized",
        // `tls.connect()` secure context options
        "pskCallback",
        "minDHSize",
        // `tls.connect()` destination options
        // - `servername` is automatically validated, skip it
        // - `host` and `port` just describe the destination server,
        "path",
        "socket",
        // `tls.createSecureContext()` options
        "ca",
        "cert",
        "sigalgs",
        "ciphers",
        "clientCertEngine",
        "crl",
        "dhparam",
        "ecdhCurve",
        "honorCipherOrder",
        "key",
        "privateKeyEngine",
        "privateKeyIdentifier",
        "maxVersion",
        "minVersion",
        "pfx",
        "secureOptions",
        "secureProtocol",
        "sessionIdContext",
        "ticketKeys"
      ], y = /* @__PURE__ */ n((T, w, B) => {
        let k = 0, q = T.length;
        for (; k < q; ) {
          let V = k + q >>> 1;
          B(T[V], w) ? k = V + 1 : q = V;
        }
        return k;
      }, "getSortedIndex"), p = /* @__PURE__ */ n((T, w) => T.remoteSettings.maxConcurrentStreams > w.remoteSettings.maxConcurrentStreams, "\
compareSessions"), g = /* @__PURE__ */ n((T, w) => {
        for (let B = 0; B < T.length; B++) {
          let k = T[B];
          // Unfortunately `.every()` returns true for an empty array
          k[f].length > 0 && k[f].length < w[f].length && k[f].every((q) => w[f].includes(q)) && k[l] + w[l] <= w.remoteSettings.maxConcurrentStreams &&
          D(k);
        }
      }, "closeCoveredSessions"), b = /* @__PURE__ */ n((T, w) => {
        for (let B = 0; B < T.length; B++) {
          let k = T[B];
          if (w[f].length > 0 && w[f].length < k[f].length && w[f].every((q) => k[f].includes(q)) && w[l] + k[l] <= k.remoteSettings.maxConcurrentStreams)
            return D(w), !0;
        }
        return !1;
      }, "closeSessionIfCovered"), D = /* @__PURE__ */ n((T) => {
        T[m] = !0, T[l] === 0 && T.close();
      }, "gracefullyClose"), x = class extends i {
        static {
          n(this, "Agent");
        }
        constructor({ timeout: T = 0, maxSessions: w = Number.POSITIVE_INFINITY, maxEmptySessions: B = 10, maxCachedTlsSessions: k = 100 } = {}) {
          super(), this.sessions = {}, this.queue = {}, this.timeout = T, this.maxSessions = w, this.maxEmptySessions = B, this._emptySessionCount =
          0, this._sessionCount = 0, this.settings = {
            enablePush: !1,
            initialWindowSize: 1024 * 1024 * 32
            // 32MB, see https://github.com/nodejs/node/issues/38426
          }, this.tlsSessionCache = new o({ maxSize: k });
        }
        get protocol() {
          return "https:";
        }
        normalizeOptions(T) {
          let w = "";
          for (let B = 0; B < d.length; B++) {
            let k = d[B];
            w += ":", T && T[k] !== void 0 && (w += T[k]);
          }
          return w;
        }
        _processQueue() {
          if (this._sessionCount >= this.maxSessions) {
            this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);
            return;
          }
          for (let T in this.queue)
            for (let w in this.queue[T]) {
              let B = this.queue[T][w];
              B.completed || (B.completed = !0, B());
            }
        }
        _isBetterSession(T, w) {
          return T > w;
        }
        _accept(T, w, B, k) {
          let q = 0;
          for (; q < w.length && T[l] < T.remoteSettings.maxConcurrentStreams; )
            w[q].resolve(T), q++;
          w.splice(0, q), w.length > 0 && (this.getSession(B, k, w), w.length = 0);
        }
        getSession(T, w, B) {
          return new Promise((k, q) => {
            Array.isArray(B) && B.length > 0 ? (B = [...B], k()) : B = [{ resolve: k, reject: q }];
            try {
              if (typeof T == "string")
                T = new r(T);
              else if (!(T instanceof r))
                throw new TypeError("The `origin` argument needs to be a string or an URL object");
              if (w) {
                let { servername: te } = w, { hostname: re } = T;
                if (te && re !== te)
                  throw new Error(`Origin ${re} differs from servername ${te}`);
              }
            } catch (te) {
              for (let re = 0; re < B.length; re++)
                B[re].reject(te);
              return;
            }
            let V = this.normalizeOptions(w), Y = T.origin;
            if (V in this.sessions) {
              let te = this.sessions[V], re = -1, ve = -1, je;
              for (let Be = 0; Be < te.length; Be++) {
                let se = te[Be], Ne = se.remoteSettings.maxConcurrentStreams;
                if (Ne < re)
                  break;
                if (!se[f].includes(Y))
                  continue;
                let ke = se[l];
                ke >= Ne || se[m] || se.destroyed || (je || (re = Ne), this._isBetterSession(ke, ve) && (je = se, ve = ke));
              }
              if (je) {
                this._accept(je, B, Y, w);
                return;
              }
            }
            if (V in this.queue) {
              if (Y in this.queue[V]) {
                this.queue[V][Y].listeners.push(...B);
                return;
              }
            } else
              this.queue[V] = {
                [h]: 0
              };
            let G = /* @__PURE__ */ n(() => {
              V in this.queue && this.queue[V][Y] === ye && (delete this.queue[V][Y], --this.queue[V][h] === 0 && delete this.queue[V]);
            }, "removeFromQueue"), ye = /* @__PURE__ */ n(async () => {
              this._sessionCount++;
              let te = `${Y}:${V}`, re = !1, ve;
              try {
                let je = { ...w };
                je.settings === void 0 && (je.settings = this.settings), je.session === void 0 && (je.session = this.tlsSessionCache.get(te)),
                ve = await (je.createConnection || this.createConnection).call(this, T, je), je.createConnection = () => ve;
                let se = a.connect(T, je);
                se[l] = 0, se[m] = !1;
                let Ne = /* @__PURE__ */ n(() => {
                  let { socket: Ae } = se, _e;
                  return Ae.servername === !1 ? (Ae.servername = Ae.remoteAddress, _e = se.originSet, Ae.servername = !1) : _e = se.originSet,
                  _e;
                }, "getOriginSet"), ke = /* @__PURE__ */ n(() => se[l] < se.remoteSettings.maxConcurrentStreams, "isFree");
                se.socket.once("session", (Ae) => {
                  this.tlsSessionCache.set(te, Ae);
                }), se.once("error", (Ae) => {
                  for (let _e = 0; _e < B.length; _e++)
                    B[_e].reject(Ae);
                  this.tlsSessionCache.delete(te);
                }), se.setTimeout(this.timeout, () => {
                  se.destroy();
                }), se.once("close", () => {
                  if (this._sessionCount--, re) {
                    this._emptySessionCount--;
                    let Ae = this.sessions[V];
                    Ae.length === 1 ? delete this.sessions[V] : Ae.splice(Ae.indexOf(se), 1);
                  } else {
                    G();
                    let Ae = new Error("Session closed without receiving a SETTINGS frame");
                    Ae.code = "HTTP2WRAPPER_NOSETTINGS";
                    for (let _e = 0; _e < B.length; _e++)
                      B[_e].reject(Ae);
                  }
                  this._processQueue();
                });
                let Cr = /* @__PURE__ */ n(() => {
                  let Ae = this.queue[V];
                  if (!Ae)
                    return;
                  let _e = se[f];
                  for (let Me = 0; Me < _e.length; Me++) {
                    let Nt = _e[Me];
                    if (Nt in Ae) {
                      let { listeners: tr, completed: Yr } = Ae[Nt], Ni = 0;
                      for (; Ni < tr.length && ke(); )
                        tr[Ni].resolve(se), Ni++;
                      if (Ae[Nt].listeners.splice(0, Ni), Ae[Nt].listeners.length === 0 && !Yr && (delete Ae[Nt], --Ae[h] === 0)) {
                        delete this.queue[V];
                        break;
                      }
                      if (!ke())
                        break;
                    }
                  }
                }, "processListeners");
                se.on("origin", () => {
                  se[f] = Ne() || [], se[m] = !1, b(this.sessions[V], se), !(se[m] || !ke()) && (Cr(), ke() && g(this.sessions[V], se));
                }), se.once("remoteSettings", () => {
                  if (ye.destroyed) {
                    let Ae = new Error("Agent has been destroyed");
                    for (let _e = 0; _e < B.length; _e++)
                      B[_e].reject(Ae);
                    se.destroy();
                    return;
                  }
                  if (se.setLocalWindowSize && se.setLocalWindowSize(1024 * 1024 * 4), se[f] = Ne() || [], se.socket.encrypted) {
                    let Ae = se[f][0];
                    if (Ae !== Y) {
                      let _e = new Error(`Requested origin ${Y} does not match server ${Ae}`);
                      for (let Me = 0; Me < B.length; Me++)
                        B[Me].reject(_e);
                      se.destroy();
                      return;
                    }
                  }
                  G();
                  {
                    let Ae = this.sessions;
                    if (V in Ae) {
                      let _e = Ae[V];
                      _e.splice(y(_e, se, p), 0, se);
                    } else
                      Ae[V] = [se];
                  }
                  re = !0, this._emptySessionCount++, this.emit("session", se), this._accept(se, B, Y, w), se[l] === 0 && this._emptySessionCount >
                  this.maxEmptySessions && this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions), se.on("remoteSettings",
                  () => {
                    ke() && (Cr(), ke() && g(this.sessions[V], se));
                  });
                }), se[c] = se.request, se.request = (Ae, _e) => {
                  if (se[m])
                    throw new Error("The session is gracefully closing. No new streams are allowed.");
                  let Me = se[c](Ae, _e);
                  return se.ref(), se[l]++ === 0 && this._emptySessionCount--, Me.once("close", () => {
                    if (--se[l] === 0 && (this._emptySessionCount++, se.unref(), this._emptySessionCount > this.maxEmptySessions || se[m])) {
                      se.close();
                      return;
                    }
                    se.destroyed || se.closed || ke() && !b(this.sessions[V], se) && (g(this.sessions[V], se), Cr(), se[l] === 0 && this._processQueue());
                  }), Me;
                };
              } catch (je) {
                G(), this._sessionCount--;
                for (let Be = 0; Be < B.length; Be++)
                  B[Be].reject(je);
              }
            }, "entry");
            ye.listeners = B, ye.completed = !1, ye.destroyed = !1, this.queue[V][Y] = ye, this.queue[V][h]++, this._processQueue();
          });
        }
        request(T, w, B, k) {
          return new Promise((q, V) => {
            this.getSession(T, w, [{
              reject: V,
              resolve: /* @__PURE__ */ n((Y) => {
                try {
                  let G = Y.request(B, k);
                  u(G), q(G);
                } catch (G) {
                  V(G);
                }
              }, "resolve")
            }]);
          });
        }
        async createConnection(T, w) {
          return x.connect(T, w);
        }
        static connect(T, w) {
          w.ALPNProtocols = ["h2"];
          let B = T.port || 443, k = T.hostname;
          typeof w.servername > "u" && (w.servername = k);
          let q = s.connect(B, k, w);
          return w.socket && (q._peername = {
            family: void 0,
            address: void 0,
            port: B
          }), q;
        }
        closeEmptySessions(T = Number.POSITIVE_INFINITY) {
          let w = 0, { sessions: B } = this;
          for (let k in B) {
            let q = B[k];
            for (let V = 0; V < q.length; V++) {
              let Y = q[V];
              if (Y[l] === 0 && (w++, Y.close(), w >= T))
                return w;
            }
          }
          return w;
        }
        destroy(T) {
          let { sessions: w, queue: B } = this;
          for (let k in w) {
            let q = w[k];
            for (let V = 0; V < q.length; V++)
              q[V].destroy(T);
          }
          for (let k in B) {
            let q = B[k];
            for (let V in q)
              q[V].destroyed = !0;
          }
          this.queue = {}, this.tlsSessionCache.clear();
        }
        get emptySessionCount() {
          return this._emptySessionCount;
        }
        get pendingSessionCount() {
          return this._sessionCount - this._emptySessionCount;
        }
        get sessionCount() {
          return this._sessionCount;
        }
      };
      x.kCurrentStreamCount = l, x.kGracefullyClosing = m, t.exports = {
        Agent: x,
        globalAgent: new x()
      };
    }
  }), nk = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/incoming-message.js"(e, t) {
      "use strict";
      var { Readable: r } = require("stream"), i = class extends r {
        static {
          n(this, "IncomingMessage");
        }
        constructor(s, a) {
          super({
            emitClose: !1,
            autoDestroy: !0,
            highWaterMark: a
          }), this.statusCode = null, this.statusMessage = "", this.httpVersion = "2.0", this.httpVersionMajor = 2, this.httpVersionMinor = 0,
          this.headers = {}, this.trailers = {}, this.req = null, this.aborted = !1, this.complete = !1, this.upgrade = null, this.rawHeaders =
          [], this.rawTrailers = [], this.socket = s, this._dumped = !1;
        }
        get connection() {
          return this.socket;
        }
        set connection(s) {
          this.socket = s;
        }
        _destroy(s, a) {
          this.readableEnded || (this.aborted = !0), a(), this.req._request.destroy(s);
        }
        setTimeout(s, a) {
          return this.req.setTimeout(s, a), this;
        }
        _dump() {
          this._dumped || (this._dumped = !0, this.removeAllListeners("data"), this.resume());
        }
        _read() {
          this.req && this.req._request.resume();
        }
      };
      t.exports = i;
    }
  }), Qae = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/proxy-events.js"(e, t) {
      "use strict";
      t.exports = (r, i, s) => {
        for (let a of s)
          r.on(a, (...o) => i.emit(a, ...o));
      };
    }
  }), nm = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/errors.js"(e, t) {
      "use strict";
      var r = /* @__PURE__ */ n((i, s, a) => {
        t.exports[s] = class extends i {
          static {
            n(this, "NodeError");
          }
          constructor(...u) {
            super(typeof a == "string" ? a : a(u)), this.name = `${super.name} [${s}]`, this.code = s;
          }
        };
      }, "makeError");
      r(TypeError, "ERR_INVALID_ARG_TYPE", (i) => {
        let s = i[0].includes(".") ? "property" : "argument", a = i[1], o = Array.isArray(a);
        return o && (a = `${a.slice(0, -1).join(", ")} or ${a.slice(-1)}`), `The "${i[0]}" ${s} must be ${o ? "one of" : "of"} type ${a}. Re\
ceived ${typeof i[2]}`;
      }), r(
        TypeError,
        "ERR_INVALID_PROTOCOL",
        (i) => `Protocol "${i[0]}" not supported. Expected "${i[1]}"`
      ), r(
        Error,
        "ERR_HTTP_HEADERS_SENT",
        (i) => `Cannot ${i[0]} headers after they are sent to the client`
      ), r(
        TypeError,
        "ERR_INVALID_HTTP_TOKEN",
        (i) => `${i[0]} must be a valid HTTP token [${i[1]}]`
      ), r(
        TypeError,
        "ERR_HTTP_INVALID_HEADER_VALUE",
        (i) => `Invalid value "${i[0]} for header "${i[1]}"`
      ), r(
        TypeError,
        "ERR_INVALID_CHAR",
        (i) => `Invalid character in ${i[0]} [${i[1]}]`
      ), r(
        Error,
        "ERR_HTTP2_NO_SOCKET_MANIPULATION",
        "HTTP/2 sockets should not be directly manipulated (e.g. read and written)"
      );
    }
  }), eoe = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js"(e, t) {
      "use strict";
      t.exports = (r) => {
        switch (r) {
          case ":method":
          case ":scheme":
          case ":authority":
          case ":path":
            return !0;
          default:
            return !1;
        }
      };
    }
  }), ak = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/validate-header-name.js"(e, t) {
      "use strict";
      var { ERR_INVALID_HTTP_TOKEN: r } = nm(), i = eoe(), s = /^[\^`\-\w!#$%&*+.|~]+$/;
      t.exports = (a) => {
        if (typeof a != "string" || !s.test(a) && !i(a))
          throw new r("Header name", a);
      };
    }
  }), ok = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/validate-header-value.js"(e, t) {
      "use strict";
      var {
        ERR_HTTP_INVALID_HEADER_VALUE: r,
        ERR_INVALID_CHAR: i
      } = nm(), s = /[^\t\u0020-\u007E\u0080-\u00FF]/;
      t.exports = (a, o) => {
        if (typeof o > "u")
          throw new r(o, a);
        if (s.test(o))
          throw new i("header content", a);
      };
    }
  }), toe = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/proxy-socket-handler.js"(e, t) {
      "use strict";
      var { ERR_HTTP2_NO_SOCKET_MANIPULATION: r } = nm(), i = {
        has(s, a) {
          let o = s.session === void 0 ? s : s.session.socket;
          return a in s || a in o;
        },
        get(s, a) {
          switch (a) {
            case "on":
            case "once":
            case "end":
            case "emit":
            case "destroy":
              return s[a].bind(s);
            case "writable":
            case "destroyed":
              return s[a];
            case "readable":
              return s.destroyed ? !1 : s.readable;
            case "setTimeout": {
              let { session: o } = s;
              return o !== void 0 ? o.setTimeout.bind(o) : s.setTimeout.bind(s);
            }
            case "write":
            case "read":
            case "pause":
            case "resume":
              throw new r();
            default: {
              let o = s.session === void 0 ? s : s.session.socket, u = o[a];
              return typeof u == "function" ? u.bind(o) : u;
            }
          }
        },
        getPrototypeOf(s) {
          return s.session !== void 0 ? Reflect.getPrototypeOf(s.session.socket) : Reflect.getPrototypeOf(s);
        },
        set(s, a, o) {
          switch (a) {
            case "writable":
            case "readable":
            case "destroyed":
            case "on":
            case "once":
            case "end":
            case "emit":
            case "destroy":
              return s[a] = o, !0;
            case "setTimeout": {
              let { session: u } = s;
              return u === void 0 ? s.setTimeout = o : u.setTimeout = o, !0;
            }
            case "write":
            case "read":
            case "pause":
            case "resume":
              throw new r();
            default: {
              let u = s.session === void 0 ? s : s.session.socket;
              return u[a] = o, !0;
            }
          }
        }
      };
      t.exports = i;
    }
  }), uk = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/client-request.js"(e, t) {
      "use strict";
      var { URL: r, urlToHttpOptions: i } = require("url"), s = require("http2"), { Writable: a } = require("stream"), { Agent: o, globalAgent: u } = El(),
      l = nk(), c = Qae(), {
        ERR_INVALID_ARG_TYPE: f,
        ERR_INVALID_PROTOCOL: m,
        ERR_HTTP_HEADERS_SENT: h
      } = nm(), d = ak(), y = ok(), p = toe(), {
        HTTP2_HEADER_STATUS: g,
        HTTP2_HEADER_METHOD: b,
        HTTP2_HEADER_PATH: D,
        HTTP2_HEADER_AUTHORITY: x,
        HTTP2_METHOD_CONNECT: T
      } = s.constants, w = Symbol("headers"), B = Symbol("origin"), k = Symbol("session"), q = Symbol("options"), V = Symbol("flushedHeaders"),
      Y = Symbol("jobs"), G = Symbol("pendingAgentPromise"), ye = class extends a {
        static {
          n(this, "ClientRequest");
        }
        constructor(te, re, ve) {
          if (super({
            autoDestroy: !1,
            emitClose: !1
          }), typeof te == "string" ? te = i(new r(te)) : te instanceof r ? te = i(te) : te = { ...te }, typeof re == "function" || re === void 0 ?
          (ve = re, re = te) : re = Object.assign(te, re), re.h2session) {
            if (this[k] = re.h2session, this[k].destroyed)
              throw new Error("The session has been closed already");
            this.protocol = this[k].socket.encrypted ? "https:" : "http:";
          } else if (re.agent === !1)
            this.agent = new o({ maxEmptySessions: 0 });
          else if (typeof re.agent > "u" || re.agent === null)
            this.agent = u;
          else if (typeof re.agent.request == "function")
            this.agent = re.agent;
          else
            throw new f("options.agent", ["http2wrapper.Agent-like Object", "undefined", "false"], re.agent);
          if (this.agent && (this.protocol = this.agent.protocol), re.protocol && re.protocol !== this.protocol)
            throw new m(re.protocol, this.protocol);
          re.port || (re.port = re.defaultPort || this.agent && this.agent.defaultPort || 443), re.host = re.hostname || re.host || "localho\
st", delete re.hostname;
          let { timeout: je } = re;
          re.timeout = void 0, this[w] = /* @__PURE__ */ Object.create(null), this[Y] = [], this[G] = void 0, this.socket = null, this.connection =
          null, this.method = re.method || "GET", this.method === "CONNECT" && (re.path === "/" || re.path === void 0) || (this.path = re.path),
          this.res = null, this.aborted = !1, this.reusedSocket = !1;
          let { headers: Be } = re;
          if (Be)
            for (let Ne in Be)
              this.setHeader(Ne, Be[Ne]);
          re.auth && !("authorization" in this[w]) && (this[w].authorization = "Basic " + Buffer.from(re.auth).toString("base64")), re.session =
          re.tlsSession, re.path = re.socketPath, this[q] = re, this[B] = new r(`${this.protocol}//${re.servername || re.host}:${re.port}`);
          let se = re._reuseSocket;
          se && (re.createConnection = (...Ne) => se.destroyed ? this.agent.createConnection(...Ne) : se, this.agent.getSession(this[B], this[q]).
          catch(() => {
          })), je && this.setTimeout(je), ve && this.once("response", ve), this[V] = !1;
        }
        get method() {
          return this[w][b];
        }
        set method(te) {
          te && (this[w][b] = te.toUpperCase());
        }
        get path() {
          let te = this.method === "CONNECT" ? x : D;
          return this[w][te];
        }
        set path(te) {
          if (te) {
            let re = this.method === "CONNECT" ? x : D;
            this[w][re] = te;
          }
        }
        get host() {
          return this[B].hostname;
        }
        set host(te) {
        }
        get _mustNotHaveABody() {
          return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
        }
        _write(te, re, ve) {
          if (this._mustNotHaveABody) {
            ve(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
            return;
          }
          this.flushHeaders();
          let je = /* @__PURE__ */ n(() => this._request.write(te, re, ve), "callWrite");
          this._request ? je() : this[Y].push(je);
        }
        _final(te) {
          this.flushHeaders();
          let re = /* @__PURE__ */ n(() => {
            if (this._mustNotHaveABody || this.method === "CONNECT") {
              te();
              return;
            }
            this._request.end(te);
          }, "callEnd");
          this._request ? re() : this[Y].push(re);
        }
        abort() {
          this.res && this.res.complete || (this.aborted || process.nextTick(() => this.emit("abort")), this.aborted = !0, this.destroy());
        }
        async _destroy(te, re) {
          this.res && this.res._dump(), this._request ? this._request.destroy() : process.nextTick(() => {
            this.emit("close");
          });
          try {
            await this[G];
          } catch (ve) {
            this.aborted && (te = ve);
          }
          re(te);
        }
        async flushHeaders() {
          if (this[V] || this.destroyed)
            return;
          this[V] = !0;
          let te = this.method === T, re = /* @__PURE__ */ n((ve) => {
            if (this._request = ve, this.destroyed) {
              ve.destroy();
              return;
            }
            te || c(ve, this, ["timeout", "continue"]), ve.once("error", (Be) => {
              this.destroy(Be);
            }), ve.once("aborted", () => {
              let { res: Be } = this;
              Be ? (Be.aborted = !0, Be.emit("aborted"), Be.destroy()) : this.destroy(new Error("The server aborted the HTTP/2 stream"));
            });
            let je = /* @__PURE__ */ n((Be, se, Ne) => {
              let ke = new l(this.socket, ve.readableHighWaterMark);
              this.res = ke, ke.url = `${this[B].origin}${this.path}`, ke.req = this, ke.statusCode = Be[g], ke.headers = Be, ke.rawHeaders =
              Ne, ke.once("end", () => {
                ke.complete = !0, ke.socket = null, ke.connection = null;
              }), te ? (ke.upgrade = !0, this.emit("connect", ke, ve, Buffer.alloc(0)) ? this.emit("close") : ve.destroy()) : (ve.on("data",
              (Cr) => {
                !ke._dumped && !ke.push(Cr) && ve.pause();
              }), ve.once("end", () => {
                this.aborted || ke.push(null);
              }), this.emit("response", ke) || ke._dump());
            }, "onResponse");
            ve.once("response", je), ve.once("headers", (Be) => this.emit("information", { statusCode: Be[g] })), ve.once("trailers", (Be, se, Ne) => {
              let { res: ke } = this;
              if (ke === null) {
                je(Be, se, Ne);
                return;
              }
              ke.trailers = Be, ke.rawTrailers = Ne;
            }), ve.once("close", () => {
              let { aborted: Be, res: se } = this;
              if (se) {
                Be && (se.aborted = !0, se.emit("aborted"), se.destroy());
                let Ne = /* @__PURE__ */ n(() => {
                  se.emit("close"), this.destroy(), this.emit("close");
                }, "finish");
                se.readable ? se.once("end", Ne) : Ne();
                return;
              }
              if (!this.destroyed) {
                this.destroy(new Error("The HTTP/2 stream has been early terminated")), this.emit("close");
                return;
              }
              this.destroy(), this.emit("close");
            }), this.socket = new Proxy(ve, p);
            for (let Be of this[Y])
              Be();
            this[Y].length = 0, this.emit("socket", this.socket);
          }, "onStream");
          if (!(x in this[w]) && !te && (this[w][x] = this[B].host), this[k])
            try {
              re(this[k].request(this[w]));
            } catch (ve) {
              this.destroy(ve);
            }
          else {
            this.reusedSocket = !0;
            try {
              let ve = this.agent.request(this[B], this[q], this[w]);
              this[G] = ve, re(await ve), this[G] = !1;
            } catch (ve) {
              this[G] = !1, this.destroy(ve);
            }
          }
        }
        get connection() {
          return this.socket;
        }
        set connection(te) {
          this.socket = te;
        }
        getHeaderNames() {
          return Object.keys(this[w]);
        }
        hasHeader(te) {
          if (typeof te != "string")
            throw new f("name", "string", te);
          return !!this[w][te.toLowerCase()];
        }
        getHeader(te) {
          if (typeof te != "string")
            throw new f("name", "string", te);
          return this[w][te.toLowerCase()];
        }
        get headersSent() {
          return this[V];
        }
        removeHeader(te) {
          if (typeof te != "string")
            throw new f("name", "string", te);
          if (this.headersSent)
            throw new h("remove");
          delete this[w][te.toLowerCase()];
        }
        setHeader(te, re) {
          if (this.headersSent)
            throw new h("set");
          d(te), y(te, re);
          let ve = te.toLowerCase();
          if (ve === "connection") {
            if (re.toLowerCase() === "keep-alive")
              return;
            throw new Error(`Invalid 'connection' header: ${re}`);
          }
          ve === "host" && this.method === "CONNECT" ? this[w][x] = re : this[w][ve] = re;
        }
        setNoDelay() {
        }
        setSocketKeepAlive() {
        }
        setTimeout(te, re) {
          let ve = /* @__PURE__ */ n(() => this._request.setTimeout(te, re), "applyTimeout");
          return this._request ? ve() : this[Y].push(ve), this;
        }
        get maxHeadersCount() {
          if (!this.destroyed && this._request)
            return this._request.session.localSettings.maxHeaderListSize;
        }
        set maxHeadersCount(te) {
        }
      };
      t.exports = ye;
    }
  }), roe = nt({
    "node_modules/.pnpm/resolve-alpn@1.2.1/node_modules/resolve-alpn/index.js"(e, t) {
      "use strict";
      var r = require("tls");
      t.exports = (i = {}, s = r.connect) => new Promise((a, o) => {
        let u = !1, l, c = /* @__PURE__ */ n(async () => {
          await m, l.off("timeout", f), l.off("error", o), i.resolveSocket ? (a({ alpnProtocol: l.alpnProtocol, socket: l, timeout: u }), u &&
          (await Promise.resolve(), l.emit("timeout"))) : (l.destroy(), a({ alpnProtocol: l.alpnProtocol, timeout: u }));
        }, "callback"), f = /* @__PURE__ */ n(async () => {
          u = !0, c();
        }, "onTimeout"), m = (async () => {
          try {
            l = await s(i, c), l.on("error", o), l.once("timeout", f);
          } catch (h) {
            o(h);
          }
        })();
      });
    }
  }), ioe = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/calculate-server-name.js"(e, t) {
      "use strict";
      var { isIP: r } = require("net"), i = require("assert"), s = /* @__PURE__ */ n((a) => {
        if (a[0] === "[") {
          let u = a.indexOf("]");
          return i(u !== -1), a.slice(1, u);
        }
        let o = a.indexOf(":");
        return o === -1 ? a : a.slice(0, o);
      }, "getHost");
      t.exports = (a) => {
        let o = s(a);
        return r(o) ? "" : o;
      };
    }
  }), soe = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/auto.js"(e, t) {
      "use strict";
      var { URL: r, urlToHttpOptions: i } = require("url"), s = require("http"), a = require("https"), o = roe(), u = ik(), { Agent: l, globalAgent: c } = El(),
      f = uk(), m = ioe(), h = sk(), d = new u({ maxSize: 100 }), y = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ n((D, x, T) => {
        x._httpMessage = { shouldKeepAlive: !0 };
        let w = /* @__PURE__ */ n(() => {
          D.emit("free", x, T);
        }, "onFree");
        x.on("free", w);
        let B = /* @__PURE__ */ n(() => {
          D.removeSocket(x, T);
        }, "onClose");
        x.on("close", B);
        let k = /* @__PURE__ */ n(() => {
          let { freeSockets: V } = D;
          for (let Y of Object.values(V))
            if (Y.includes(x)) {
              x.destroy();
              return;
            }
        }, "onTimeout");
        x.on("timeout", k);
        let q = /* @__PURE__ */ n(() => {
          D.removeSocket(x, T), x.off("close", B), x.off("free", w), x.off("timeout", k), x.off("agentRemove", q);
        }, "onRemove");
        x.on("agentRemove", q), D.emit("free", x, T);
      }, "installSocket"), g = /* @__PURE__ */ n((D, x = /* @__PURE__ */ new Map(), T = void 0) => async (w) => {
        let B = `${w.host}:${w.port}:${w.ALPNProtocols.sort()}`;
        if (!D.has(B)) {
          if (x.has(B))
            return { alpnProtocol: (await x.get(B)).alpnProtocol };
          let { path: k } = w;
          w.path = w.socketPath;
          let q = o(w, T);
          x.set(B, q);
          try {
            let V = await q;
            return D.set(B, V.alpnProtocol), x.delete(B), w.path = k, V;
          } catch (V) {
            throw x.delete(B), w.path = k, V;
          }
        }
        return { alpnProtocol: D.get(B) };
      }, "createResolveProtocol"), b = g(d, y);
      t.exports = async (D, x, T) => {
        if (typeof D == "string" ? D = i(new r(D)) : D instanceof r ? D = i(D) : D = { ...D }, typeof x == "function" || x === void 0 ? (T =
        x, x = D) : x = Object.assign(D, x), x.ALPNProtocols = x.ALPNProtocols || ["h2", "http/1.1"], !Array.isArray(x.ALPNProtocols) || x.ALPNProtocols.
        length === 0)
          throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
        x.protocol = x.protocol || "https:";
        let w = x.protocol === "https:";
        x.host = x.hostname || x.host || "localhost", x.session = x.tlsSession, x.servername = x.servername || m(x.headers && x.headers.host ||
        x.host), x.port = x.port || (w ? 443 : 80), x._defaultAgent = w ? a.globalAgent : s.globalAgent;
        let B = x.resolveProtocol || b, { agent: k } = x;
        if (k !== void 0 && k !== !1 && k.constructor.name !== "Object")
          throw new Error("The `options.agent` can be only an object `http`, `https` or `http2` properties");
        if (w) {
          x.resolveSocket = !0;
          let { socket: q, alpnProtocol: V, timeout: Y } = await B(x);
          if (Y) {
            q && q.destroy();
            let ye = new Error(`Timed out resolving ALPN: ${x.timeout} ms`);
            throw ye.code = "ETIMEDOUT", ye.ms = x.timeout, ye;
          }
          q && x.createConnection && (q.destroy(), q = void 0), delete x.resolveSocket;
          let G = V === "h2";
          if (k && (k = G ? k.http2 : k.https, x.agent = k), k === void 0 && (k = G ? c : a.globalAgent), q)
            if (k === !1)
              q.destroy();
            else {
              let ye = (G ? l : a.Agent).prototype.createConnection;
              k.createConnection === ye ? G ? x._reuseSocket = q : p(k, q, x) : q.destroy();
            }
          if (G)
            return h(new f(x, T));
        } else k && (x.agent = k.http);
        return h(s.request(x, T));
      }, t.exports.protocolCache = d, t.exports.resolveProtocol = b, t.exports.createResolveProtocol = g;
    }
  }), lk = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/js-stream-socket.js"(e, t) {
      "use strict";
      var r = require("stream"), i = require("tls"), s = new i.TLSSocket(new r.PassThrough())._handle._parentWrap.constructor;
      t.exports = s;
    }
  }), ck = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js"(e, t) {
      "use strict";
      var r = class extends Error {
        static {
          n(this, "UnexpectedStatusCodeError");
        }
        constructor(i, s = "") {
          super(`The proxy server rejected the request with status code ${i} (${s || "empty status message"})`), this.statusCode = i, this.statusMessage =
          s;
        }
      };
      t.exports = r;
    }
  }), noe = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/check-type.js"(e, t) {
      "use strict";
      var r = /* @__PURE__ */ n((i, s, a) => {
        if (!a.some((u) => typeof u === "string" ? typeof s === u : s instanceof u)) {
          let u = a.map((l) => typeof l == "string" ? l : l.name);
          throw new TypeError(`Expected '${i}' to be a type of ${u.join(" or ")}, got ${typeof s}`);
        }
      }, "checkType");
      t.exports = r;
    }
  }), fk = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/initialize.js"(e, t) {
      "use strict";
      var { URL: r } = require("url"), i = noe();
      t.exports = (s, a) => {
        i("proxyOptions", a, ["object"]), i("proxyOptions.headers", a.headers, ["object", "undefined"]), i("proxyOptions.raw", a.raw, ["bool\
ean", "undefined"]), i("proxyOptions.url", a.url, [r, "string"]);
        let o = new r(a.url);
        s.proxyOptions = {
          raw: !0,
          ...a,
          headers: { ...a.headers },
          url: o
        };
      };
    }
  }), Hv = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/get-auth-headers.js"(e, t) {
      "use strict";
      t.exports = (r) => {
        let { username: i, password: s } = r.proxyOptions.url;
        if (i || s) {
          let a = `${i}:${s}`, o = `Basic ${Buffer.from(a).toString("base64")}`;
          return {
            "proxy-authorization": o,
            authorization: o
          };
        }
        return {};
      };
    }
  }), aoe = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/h1-over-h2.js"(e, t) {
      "use strict";
      var r = require("tls"), i = require("http"), s = require("https"), a = lk(), { globalAgent: o } = El(), u = ck(), l = fk(), c = Hv(), f = /* @__PURE__ */ n(
      (d, y, p) => {
        (async () => {
          try {
            let { proxyOptions: g } = d, { url: b, headers: D, raw: x } = g, T = await o.request(b, g, {
              ...c(d),
              ...D,
              ":method": "CONNECT",
              ":authority": `${y.host}:${y.port}`
            });
            T.once("error", p), T.once("response", (w) => {
              let B = w[":status"];
              if (B !== 200) {
                p(new u(B, ""));
                return;
              }
              let k = d instanceof s.Agent;
              if (x && k) {
                y.socket = T;
                let V = r.connect(y);
                V.once("close", () => {
                  T.destroy();
                }), p(null, V);
                return;
              }
              let q = new a(T);
              q.encrypted = !1, q._handle.getpeername = (V) => {
                V.family = void 0, V.address = void 0, V.port = void 0;
              }, p(null, q);
            });
          } catch (g) {
            p(g);
          }
        })();
      }, "createConnection"), m = class extends i.Agent {
        static {
          n(this, "HttpOverHttp2");
        }
        constructor(d) {
          super(d), l(this, d.proxyOptions);
        }
        createConnection(d, y) {
          f(this, d, y);
        }
      }, h = class extends s.Agent {
        static {
          n(this, "HttpsOverHttp2");
        }
        constructor(d) {
          super(d), l(this, d.proxyOptions);
        }
        createConnection(d, y) {
          f(this, d, y);
        }
      };
      t.exports = {
        HttpOverHttp2: m,
        HttpsOverHttp2: h
      };
    }
  }), dk = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/h2-over-hx.js"(e, t) {
      "use strict";
      var { Agent: r } = El(), i = lk(), s = ck(), a = fk(), o = class extends r {
        static {
          n(this, "Http2OverHttpX");
        }
        constructor(u) {
          super(u), a(this, u.proxyOptions);
        }
        async createConnection(u, l) {
          let c = `${u.hostname}:${u.port || 443}`, [f, m, h] = await this._getProxyStream(c);
          if (m !== 200)
            throw new s(m, h);
          if (this.proxyOptions.raw)
            l.socket = f;
          else {
            let d = new i(f);
            return d.encrypted = !1, d._handle.getpeername = (y) => {
              y.family = void 0, y.address = void 0, y.port = void 0;
            }, d;
          }
          return super.createConnection(u, l);
        }
      };
      t.exports = o;
    }
  }), ooe = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/h2-over-h2.js"(e, t) {
      "use strict";
      var { globalAgent: r } = El(), i = dk(), s = Hv(), a = /* @__PURE__ */ n((u) => new Promise((l, c) => {
        u.once("error", c), u.once("response", (f) => {
          u.off("error", c), l(f[":status"]);
        });
      }), "getStatusCode"), o = class extends i {
        static {
          n(this, "Http2OverHttp2");
        }
        async _getProxyStream(u) {
          let { proxyOptions: l } = this, c = {
            ...s(this),
            ...l.headers,
            ":method": "CONNECT",
            ":authority": u
          }, f = await r.request(l.url, l, c), m = await a(f);
          return [f, m, ""];
        }
      };
      t.exports = o;
    }
  }), uoe = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/h2-over-h1.js"(e, t) {
      "use strict";
      var r = require("http"), i = require("https"), s = dk(), a = Hv(), o = /* @__PURE__ */ n((l) => new Promise((c, f) => {
        let m = /* @__PURE__ */ n((h, d, y) => {
          d.unshift(y), l.off("error", f), c([d, h.statusCode, h.statusMessage]);
        }, "onConnect");
        l.once("error", f), l.once("connect", m);
      }), "getStream2"), u = class extends s {
        static {
          n(this, "Http2OverHttp");
        }
        async _getProxyStream(l) {
          let { proxyOptions: c } = this, { url: f, headers: m } = this.proxyOptions, d = (f.protocol === "https:" ? i : r).request({
            ...c,
            hostname: f.hostname,
            port: f.port,
            path: l,
            headers: {
              ...a(this),
              ...m,
              host: l
            },
            method: "CONNECT"
          }).end();
          return o(d);
        }
      };
      t.exports = {
        Http2OverHttp: u,
        Http2OverHttps: u
      };
    }
  }), loe = nt({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/index.js"(e, t) {
      "use strict";
      var r = require("http2"), {
        Agent: i,
        globalAgent: s
      } = El(), a = uk(), o = nk(), u = soe(), {
        HttpOverHttp2: l,
        HttpsOverHttp2: c
      } = aoe(), f = ooe(), {
        Http2OverHttp: m,
        Http2OverHttps: h
      } = uoe(), d = ak(), y = ok(), p = /* @__PURE__ */ n((b, D, x) => new a(b, D, x), "request"), g = /* @__PURE__ */ n((b, D, x) => {
        let T = new a(b, D, x);
        return T.end(), T;
      }, "get");
      t.exports = {
        ...r,
        ClientRequest: a,
        IncomingMessage: o,
        Agent: i,
        globalAgent: s,
        request: p,
        get: g,
        auto: u,
        proxies: {
          HttpOverHttp2: l,
          HttpsOverHttp2: c,
          Http2OverHttp2: f,
          Http2OverHttp: m,
          Http2OverHttps: h
        },
        validateHeaderName: d,
        validateHeaderValue: y
      };
    }
  }), pk = {};
  Wae(pk, {
    default: /* @__PURE__ */ n(() => cle, "default")
  });
  Sk.exports = Hae(pk);
  var coe = require("http"), foe = require("https"), hk = [
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  function doe(e) {
    return hk.includes(e);
  }
  n(doe, "isTypedArrayName");
  var poe = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Blob",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "WeakRef",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "FormData",
    "URLSearchParams",
    "HTMLElement",
    "NaN",
    ...hk
  ];
  function hoe(e) {
    return poe.includes(e);
  }
  n(hoe, "isObjectTypeName");
  var moe = [
    "null",
    "undefined",
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol"
  ];
  function yoe(e) {
    return moe.includes(e);
  }
  n(yoe, "isPrimitiveTypeName");
  function Sl(e) {
    return (t) => typeof t === e;
  }
  n(Sl, "isOfType");
  var { toString: goe } = Object.prototype, Qf = /* @__PURE__ */ n((e) => {
    let t = goe.call(e).slice(8, -1);
    if (/HTML\w+Element/.test(t) && M.domElement(e))
      return "HTMLElement";
    if (hoe(t))
      return t;
  }, "getObjectType"), Dt = /* @__PURE__ */ n((e) => (t) => Qf(t) === e, "isObjectOfType");
  function M(e) {
    if (e === null)
      return "null";
    switch (typeof e) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return Number.isNaN(e) ? "NaN" : "number";
      case "boolean":
        return "boolean";
      case "function":
        return "Function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
      default:
    }
    if (M.observable(e))
      return "Observable";
    if (M.array(e))
      return "Array";
    if (M.buffer(e))
      return "Buffer";
    let t = Qf(e);
    if (t)
      return t;
    if (e instanceof String || e instanceof Boolean || e instanceof Number)
      throw new TypeError("Please don't use object wrappers for primitive types");
    return "Object";
  }
  n(M, "is");
  M.undefined = Sl("undefined");
  M.string = Sl("string");
  var boe = Sl("number");
  M.number = (e) => boe(e) && !M.nan(e);
  M.bigint = Sl("bigint");
  M.function_ = Sl("function");
  M.null_ = (e) => e === null;
  M.class_ = (e) => M.function_(e) && e.toString().startsWith("class ");
  M.boolean = (e) => e === !0 || e === !1;
  M.symbol = Sl("symbol");
  M.numericString = (e) => M.string(e) && !M.emptyStringOrWhitespace(e) && !Number.isNaN(Number(e));
  M.array = (e, t) => Array.isArray(e) ? M.function_(t) ? e.every((r) => t(r)) : !0 : !1;
  M.buffer = (e) => {
    var t, r;
    return ((r = (t = e?.constructor) == null ? void 0 : t.isBuffer) == null ? void 0 : r.call(t, e)) ?? !1;
  };
  M.blob = (e) => Dt("Blob")(e);
  M.nullOrUndefined = (e) => M.null_(e) || M.undefined(e);
  M.object = (e) => !M.null_(e) && (typeof e == "object" || M.function_(e));
  M.iterable = (e) => M.function_(e?.[Symbol.iterator]);
  M.asyncIterable = (e) => M.function_(e?.[Symbol.asyncIterator]);
  M.generator = (e) => M.iterable(e) && M.function_(e?.next) && M.function_(e?.throw);
  M.asyncGenerator = (e) => M.asyncIterable(e) && M.function_(e.next) && M.function_(e.throw);
  M.nativePromise = (e) => Dt("Promise")(e);
  var Doe = /* @__PURE__ */ n((e) => M.function_(e?.then) && M.function_(e?.catch), "hasPromiseApi");
  M.promise = (e) => M.nativePromise(e) || Doe(e);
  M.generatorFunction = Dt("GeneratorFunction");
  M.asyncGeneratorFunction = (e) => Qf(e) === "AsyncGeneratorFunction";
  M.asyncFunction = (e) => Qf(e) === "AsyncFunction";
  M.boundFunction = (e) => M.function_(e) && !e.hasOwnProperty("prototype");
  M.regExp = Dt("RegExp");
  M.date = Dt("Date");
  M.error = Dt("Error");
  M.map = (e) => Dt("Map")(e);
  M.set = (e) => Dt("Set")(e);
  M.weakMap = (e) => Dt("WeakMap")(e);
  M.weakSet = (e) => Dt("WeakSet")(e);
  M.weakRef = (e) => Dt("WeakRef")(e);
  M.int8Array = Dt("Int8Array");
  M.uint8Array = Dt("Uint8Array");
  M.uint8ClampedArray = Dt("Uint8ClampedArray");
  M.int16Array = Dt("Int16Array");
  M.uint16Array = Dt("Uint16Array");
  M.int32Array = Dt("Int32Array");
  M.uint32Array = Dt("Uint32Array");
  M.float32Array = Dt("Float32Array");
  M.float64Array = Dt("Float64Array");
  M.bigInt64Array = Dt("BigInt64Array");
  M.bigUint64Array = Dt("BigUint64Array");
  M.arrayBuffer = Dt("ArrayBuffer");
  M.sharedArrayBuffer = Dt("SharedArrayBuffer");
  M.dataView = Dt("DataView");
  M.enumCase = (e, t) => Object.values(t).includes(e);
  M.directInstanceOf = (e, t) => Object.getPrototypeOf(e) === t.prototype;
  M.urlInstance = (e) => Dt("URL")(e);
  M.urlString = (e) => {
    if (!M.string(e))
      return !1;
    try {
      return new URL(e), !0;
    } catch {
      return !1;
    }
  };
  M.truthy = (e) => !!e;
  M.falsy = (e) => !e;
  M.nan = (e) => Number.isNaN(e);
  M.primitive = (e) => M.null_(e) || yoe(typeof e);
  M.integer = (e) => Number.isInteger(e);
  M.safeInteger = (e) => Number.isSafeInteger(e);
  M.plainObject = (e) => {
    if (typeof e != "object" || e === null)
      return !1;
    let t = Object.getPrototypeOf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in
    e);
  };
  M.typedArray = (e) => doe(Qf(e));
  var voe = /* @__PURE__ */ n((e) => M.safeInteger(e) && e >= 0, "isValidLength");
  M.arrayLike = (e) => !M.nullOrUndefined(e) && !M.function_(e) && voe(e.length);
  M.inRange = (e, t) => {
    if (M.number(t))
      return e >= Math.min(0, t) && e <= Math.max(t, 0);
    if (M.array(t) && t.length === 2)
      return e >= Math.min(...t) && e <= Math.max(...t);
    throw new TypeError(`Invalid range: ${JSON.stringify(t)}`);
  };
  var xoe = 1, Eoe = [
    "innerHTML",
    "ownerDocument",
    "style",
    "attributes",
    "nodeValue"
  ];
  M.domElement = (e) => M.object(e) && e.nodeType === xoe && M.string(e.nodeName) && !M.plainObject(e) && Eoe.every((t) => t in e);
  M.observable = (e) => {
    var t, r;
    return e ? e === ((t = e[Symbol.observable]) == null ? void 0 : t.call(e)) || e === ((r = e["@@observable"]) == null ? void 0 : r.call(e)) :
    !1;
  };
  M.nodeStream = (e) => M.object(e) && M.function_(e.pipe) && !M.observable(e);
  M.infinite = (e) => e === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY;
  var mk = /* @__PURE__ */ n((e) => (t) => M.integer(t) && Math.abs(t % 2) === e, "isAbsoluteMod2");
  M.evenInteger = mk(0);
  M.oddInteger = mk(1);
  M.emptyArray = (e) => M.array(e) && e.length === 0;
  M.nonEmptyArray = (e) => M.array(e) && e.length > 0;
  M.emptyString = (e) => M.string(e) && e.length === 0;
  var Soe = /* @__PURE__ */ n((e) => M.string(e) && !/\S/.test(e), "isWhiteSpaceString");
  M.emptyStringOrWhitespace = (e) => M.emptyString(e) || Soe(e);
  M.nonEmptyString = (e) => M.string(e) && e.length > 0;
  M.nonEmptyStringAndNotWhitespace = (e) => M.string(e) && !M.emptyStringOrWhitespace(e);
  M.emptyObject = (e) => M.object(e) && !M.map(e) && !M.set(e) && Object.keys(e).length === 0;
  M.nonEmptyObject = (e) => M.object(e) && !M.map(e) && !M.set(e) && Object.keys(e).length > 0;
  M.emptySet = (e) => M.set(e) && e.size === 0;
  M.nonEmptySet = (e) => M.set(e) && e.size > 0;
  M.emptyMap = (e) => M.map(e) && e.size === 0;
  M.nonEmptyMap = (e) => M.map(e) && e.size > 0;
  M.propertyKey = (e) => M.any([M.string, M.number, M.symbol], e);
  M.formData = (e) => Dt("FormData")(e);
  M.urlSearchParams = (e) => Dt("URLSearchParams")(e);
  var yk = /* @__PURE__ */ n((e, t, r) => {
    if (!M.function_(t))
      throw new TypeError(`Invalid predicate: ${JSON.stringify(t)}`);
    if (r.length === 0)
      throw new TypeError("Invalid number of values");
    return e.call(r, t);
  }, "predicateOnArray");
  M.any = (e, ...t) => (M.array(e) ? e : [e]).some((i) => yk(Array.prototype.some, i, t));
  M.all = (e, ...t) => yk(Array.prototype.every, e, t);
  var le = /* @__PURE__ */ n((e, t, r, i = {}) => {
    if (!e) {
      let { multipleValues: s } = i, a = s ? `received values of types ${[
        ...new Set(r.map((o) => `\`${M(o)}\``))
      ].join(", ")}` : `received value of type \`${M(r)}\``;
      throw new TypeError(`Expected value which is \`${t}\`, ${a}.`);
    }
  }, "assertType"), ee = {
    // Unknowns.
    undefined: /* @__PURE__ */ n((e) => le(M.undefined(e), "undefined", e), "undefined"),
    string: /* @__PURE__ */ n((e) => le(M.string(e), "string", e), "string"),
    number: /* @__PURE__ */ n((e) => le(M.number(e), "number", e), "number"),
    bigint: /* @__PURE__ */ n((e) => le(M.bigint(e), "bigint", e), "bigint"),
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: /* @__PURE__ */ n((e) => le(M.function_(e), "Function", e), "function_"),
    null_: /* @__PURE__ */ n((e) => le(M.null_(e), "null", e), "null_"),
    class_: /* @__PURE__ */ n((e) => le(M.class_(e), "Class", e), "class_"),
    boolean: /* @__PURE__ */ n((e) => le(M.boolean(e), "boolean", e), "boolean"),
    symbol: /* @__PURE__ */ n((e) => le(M.symbol(e), "symbol", e), "symbol"),
    numericString: /* @__PURE__ */ n((e) => le(M.numericString(e), "string with a number", e), "numericString"),
    array: /* @__PURE__ */ n((e, t) => {
      le(M.array(e), "Array", e), t && e.forEach(t);
    }, "array"),
    buffer: /* @__PURE__ */ n((e) => le(M.buffer(e), "Buffer", e), "buffer"),
    blob: /* @__PURE__ */ n((e) => le(M.blob(e), "Blob", e), "blob"),
    nullOrUndefined: /* @__PURE__ */ n((e) => le(M.nullOrUndefined(e), "null or undefined", e), "nullOrUndefined"),
    object: /* @__PURE__ */ n((e) => le(M.object(e), "Object", e), "object"),
    iterable: /* @__PURE__ */ n((e) => le(M.iterable(e), "Iterable", e), "iterable"),
    asyncIterable: /* @__PURE__ */ n((e) => le(M.asyncIterable(e), "AsyncIterable", e), "asyncIterable"),
    generator: /* @__PURE__ */ n((e) => le(M.generator(e), "Generator", e), "generator"),
    asyncGenerator: /* @__PURE__ */ n((e) => le(M.asyncGenerator(e), "AsyncGenerator", e), "asyncGenerator"),
    nativePromise: /* @__PURE__ */ n((e) => le(M.nativePromise(e), "native Promise", e), "nativePromise"),
    promise: /* @__PURE__ */ n((e) => le(M.promise(e), "Promise", e), "promise"),
    generatorFunction: /* @__PURE__ */ n((e) => le(M.generatorFunction(e), "GeneratorFunction", e), "generatorFunction"),
    asyncGeneratorFunction: /* @__PURE__ */ n((e) => le(M.asyncGeneratorFunction(e), "AsyncGeneratorFunction", e), "asyncGeneratorFunction"),
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: /* @__PURE__ */ n((e) => le(M.asyncFunction(e), "AsyncFunction", e), "asyncFunction"),
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: /* @__PURE__ */ n((e) => le(M.boundFunction(e), "Function", e), "boundFunction"),
    regExp: /* @__PURE__ */ n((e) => le(M.regExp(e), "RegExp", e), "regExp"),
    date: /* @__PURE__ */ n((e) => le(M.date(e), "Date", e), "date"),
    error: /* @__PURE__ */ n((e) => le(M.error(e), "Error", e), "error"),
    map: /* @__PURE__ */ n((e) => le(M.map(e), "Map", e), "map"),
    set: /* @__PURE__ */ n((e) => le(M.set(e), "Set", e), "set"),
    weakMap: /* @__PURE__ */ n((e) => le(M.weakMap(e), "WeakMap", e), "weakMap"),
    weakSet: /* @__PURE__ */ n((e) => le(M.weakSet(e), "WeakSet", e), "weakSet"),
    weakRef: /* @__PURE__ */ n((e) => le(M.weakRef(e), "WeakRef", e), "weakRef"),
    int8Array: /* @__PURE__ */ n((e) => le(M.int8Array(e), "Int8Array", e), "int8Array"),
    uint8Array: /* @__PURE__ */ n((e) => le(M.uint8Array(e), "Uint8Array", e), "uint8Array"),
    uint8ClampedArray: /* @__PURE__ */ n((e) => le(M.uint8ClampedArray(e), "Uint8ClampedArray", e), "uint8ClampedArray"),
    int16Array: /* @__PURE__ */ n((e) => le(M.int16Array(e), "Int16Array", e), "int16Array"),
    uint16Array: /* @__PURE__ */ n((e) => le(M.uint16Array(e), "Uint16Array", e), "uint16Array"),
    int32Array: /* @__PURE__ */ n((e) => le(M.int32Array(e), "Int32Array", e), "int32Array"),
    uint32Array: /* @__PURE__ */ n((e) => le(M.uint32Array(e), "Uint32Array", e), "uint32Array"),
    float32Array: /* @__PURE__ */ n((e) => le(M.float32Array(e), "Float32Array", e), "float32Array"),
    float64Array: /* @__PURE__ */ n((e) => le(M.float64Array(e), "Float64Array", e), "float64Array"),
    bigInt64Array: /* @__PURE__ */ n((e) => le(M.bigInt64Array(e), "BigInt64Array", e), "bigInt64Array"),
    bigUint64Array: /* @__PURE__ */ n((e) => le(M.bigUint64Array(e), "BigUint64Array", e), "bigUint64Array"),
    arrayBuffer: /* @__PURE__ */ n((e) => le(M.arrayBuffer(e), "ArrayBuffer", e), "arrayBuffer"),
    sharedArrayBuffer: /* @__PURE__ */ n((e) => le(M.sharedArrayBuffer(e), "SharedArrayBuffer", e), "sharedArrayBuffer"),
    dataView: /* @__PURE__ */ n((e) => le(M.dataView(e), "DataView", e), "dataView"),
    enumCase: /* @__PURE__ */ n((e, t) => le(M.enumCase(e, t), "EnumCase", e), "enumCase"),
    urlInstance: /* @__PURE__ */ n((e) => le(M.urlInstance(e), "URL", e), "urlInstance"),
    urlString: /* @__PURE__ */ n((e) => le(M.urlString(e), "string with a URL", e), "urlString"),
    truthy: /* @__PURE__ */ n((e) => le(M.truthy(e), "truthy", e), "truthy"),
    falsy: /* @__PURE__ */ n((e) => le(M.falsy(e), "falsy", e), "falsy"),
    nan: /* @__PURE__ */ n((e) => le(M.nan(e), "NaN", e), "nan"),
    primitive: /* @__PURE__ */ n((e) => le(M.primitive(e), "primitive", e), "primitive"),
    integer: /* @__PURE__ */ n((e) => le(M.integer(e), "integer", e), "integer"),
    safeInteger: /* @__PURE__ */ n((e) => le(M.safeInteger(e), "integer", e), "safeInteger"),
    plainObject: /* @__PURE__ */ n((e) => le(M.plainObject(e), "plain object", e), "plainObject"),
    typedArray: /* @__PURE__ */ n((e) => le(M.typedArray(e), "TypedArray", e), "typedArray"),
    arrayLike: /* @__PURE__ */ n((e) => le(M.arrayLike(e), "array-like", e), "arrayLike"),
    domElement: /* @__PURE__ */ n((e) => le(M.domElement(e), "HTMLElement", e), "domElement"),
    observable: /* @__PURE__ */ n((e) => le(M.observable(e), "Observable", e), "observable"),
    nodeStream: /* @__PURE__ */ n((e) => le(M.nodeStream(e), "Node.js Stream", e), "nodeStream"),
    infinite: /* @__PURE__ */ n((e) => le(M.infinite(e), "infinite number", e), "infinite"),
    emptyArray: /* @__PURE__ */ n((e) => le(M.emptyArray(e), "empty array", e), "emptyArray"),
    nonEmptyArray: /* @__PURE__ */ n((e) => le(M.nonEmptyArray(e), "non-empty array", e), "nonEmptyArray"),
    emptyString: /* @__PURE__ */ n((e) => le(M.emptyString(e), "empty string", e), "emptyString"),
    emptyStringOrWhitespace: /* @__PURE__ */ n((e) => le(M.emptyStringOrWhitespace(e), "empty string or whitespace", e), "emptyStringOrWhite\
space"),
    nonEmptyString: /* @__PURE__ */ n((e) => le(M.nonEmptyString(e), "non-empty string", e), "nonEmptyString"),
    nonEmptyStringAndNotWhitespace: /* @__PURE__ */ n((e) => le(M.nonEmptyStringAndNotWhitespace(e), "non-empty string and not whitespace", e),
    "nonEmptyStringAndNotWhitespace"),
    emptyObject: /* @__PURE__ */ n((e) => le(M.emptyObject(e), "empty object", e), "emptyObject"),
    nonEmptyObject: /* @__PURE__ */ n((e) => le(M.nonEmptyObject(e), "non-empty object", e), "nonEmptyObject"),
    emptySet: /* @__PURE__ */ n((e) => le(M.emptySet(e), "empty set", e), "emptySet"),
    nonEmptySet: /* @__PURE__ */ n((e) => le(M.nonEmptySet(e), "non-empty set", e), "nonEmptySet"),
    emptyMap: /* @__PURE__ */ n((e) => le(M.emptyMap(e), "empty map", e), "emptyMap"),
    nonEmptyMap: /* @__PURE__ */ n((e) => le(M.nonEmptyMap(e), "non-empty map", e), "nonEmptyMap"),
    propertyKey: /* @__PURE__ */ n((e) => le(M.propertyKey(e), "PropertyKey", e), "propertyKey"),
    formData: /* @__PURE__ */ n((e) => le(M.formData(e), "FormData", e), "formData"),
    urlSearchParams: /* @__PURE__ */ n((e) => le(M.urlSearchParams(e), "URLSearchParams", e), "urlSearchParams"),
    // Numbers.
    evenInteger: /* @__PURE__ */ n((e) => le(M.evenInteger(e), "even integer", e), "evenInteger"),
    oddInteger: /* @__PURE__ */ n((e) => le(M.oddInteger(e), "odd integer", e), "oddInteger"),
    // Two arguments.
    directInstanceOf: /* @__PURE__ */ n((e, t) => le(M.directInstanceOf(e, t), "T", e), "directInstanceOf"),
    inRange: /* @__PURE__ */ n((e, t) => le(M.inRange(e, t), "in range", e), "inRange"),
    // Variadic functions.
    any: /* @__PURE__ */ n((e, ...t) => le(M.any(e, ...t), "predicate returns truthy for any value", t, { multipleValues: !0 }), "any"),
    all: /* @__PURE__ */ n((e, ...t) => le(M.all(e, ...t), "predicate returns truthy for all values", t, { multipleValues: !0 }), "all")
  };
  Object.defineProperties(M, {
    class: {
      value: M.class_
    },
    function: {
      value: M.function_
    },
    null: {
      value: M.null_
    }
  });
  Object.defineProperties(ee, {
    class: {
      value: ee.class_
    },
    function: {
      value: ee.function_
    },
    null: {
      value: ee.null_
    }
  });
  var U = M, Toe = require("events"), Coe = class extends Error {
    static {
      n(this, "CancelError");
    }
    constructor(e) {
      super(e || "Promise was canceled"), this.name = "CancelError";
    }
    get isCanceled() {
      return !0;
    }
  }, Kv = class {
    static {
      n(this, "PCancelable");
    }
    static fn(e) {
      return (...t) => new Kv((r, i, s) => {
        t.push(s), e(...t).then(r, i);
      });
    }
    constructor(e) {
      this._cancelHandlers = [], this._isPending = !0, this._isCanceled = !1, this._rejectOnCancel = !0, this._promise = new Promise((t, r) => {
        this._reject = r;
        let i = /* @__PURE__ */ n((o) => {
          (!this._isCanceled || !a.shouldReject) && (this._isPending = !1, t(o));
        }, "onResolve"), s = /* @__PURE__ */ n((o) => {
          this._isPending = !1, r(o);
        }, "onReject"), a = /* @__PURE__ */ n((o) => {
          if (!this._isPending)
            throw new Error("The `onCancel` handler was attached after the promise settled.");
          this._cancelHandlers.push(o);
        }, "onCancel");
        Object.defineProperties(a, {
          shouldReject: {
            get: /* @__PURE__ */ n(() => this._rejectOnCancel, "get"),
            set: /* @__PURE__ */ n((o) => {
              this._rejectOnCancel = o;
            }, "set")
          }
        }), e(i, s, a);
      });
    }
    then(e, t) {
      return this._promise.then(e, t);
    }
    catch(e) {
      return this._promise.catch(e);
    }
    finally(e) {
      return this._promise.finally(e);
    }
    cancel(e) {
      if (!(!this._isPending || this._isCanceled)) {
        if (this._isCanceled = !0, this._cancelHandlers.length > 0)
          try {
            for (let t of this._cancelHandlers)
              t();
          } catch (t) {
            this._reject(t);
            return;
          }
        this._rejectOnCancel && this._reject(new Coe(e));
      }
    }
    get isCanceled() {
      return this._isCanceled;
    }
  };
  Object.setPrototypeOf(Kv.prototype, Promise.prototype);
  function woe(e) {
    return U.object(e) && "_onResponse" in e;
  }
  n(woe, "isRequest");
  var pr = class extends Error {
    static {
      n(this, "RequestError");
    }
    constructor(e, t, r) {
      var i;
      if (super(e), Object.defineProperty(this, "input", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "stack", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "response", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "request", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "timings", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Error.captureStackTrace(this, this.constructor), this.name = "RequestError", this.code = t.code ?? "ERR_GOT_REQUEST_ERROR", this.input =
      t.input, woe(r) ? (Object.defineProperty(this, "request", {
        enumerable: !1,
        value: r
      }), Object.defineProperty(this, "response", {
        enumerable: !1,
        value: r.response
      }), this.options = r.options) : this.options = r, this.timings = (i = this.request) == null ? void 0 : i.timings, U.string(t.stack) &&
      U.string(this.stack)) {
        let s = this.stack.indexOf(this.message) + this.message.length, a = this.stack.slice(s).split(`
`).reverse(), o = t.stack.slice(t.stack.indexOf(t.message) + t.message.length).split(`
`).reverse();
        for (; o.length > 0 && o[0] === a[0]; )
          a.shift();
        this.stack = `${this.stack.slice(0, s)}${a.reverse().join(`
`)}${o.reverse().join(`
`)}`;
      }
    }
  }, Aoe = class extends pr {
    static {
      n(this, "MaxRedirectsError");
    }
    constructor(e) {
      super(`Redirected ${e.options.maxRedirects} times. Aborting.`, {}, e), this.name = "MaxRedirectsError", this.code = "ERR_TOO_MANY_REDI\
RECTS";
    }
  }, rm = class extends pr {
    static {
      n(this, "HTTPError");
    }
    constructor(e) {
      super(`Response code ${e.statusCode} (${e.statusMessage})`, {}, e.request), this.name = "HTTPError", this.code = "ERR_NON_2XX_3XX_RESP\
ONSE";
    }
  }, _oe = class extends pr {
    static {
      n(this, "CacheError");
    }
    constructor(e, t) {
      super(e.message, e, t), this.name = "CacheError", this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
    }
  }, FO = class extends pr {
    static {
      n(this, "UploadError");
    }
    constructor(e, t) {
      super(e.message, e, t), this.name = "UploadError", this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
    }
  }, Poe = class extends pr {
    static {
      n(this, "TimeoutError");
    }
    constructor(e, t, r) {
      super(e.message, e, r), Object.defineProperty(this, "timings", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "event", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.name = "TimeoutError", this.event = e.event, this.timings = t;
    }
  }, IO = class extends pr {
    static {
      n(this, "ReadError");
    }
    constructor(e, t) {
      super(e.message, e, t), this.name = "ReadError", this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.
      code;
    }
  }, Foe = class extends pr {
    static {
      n(this, "RetryError");
    }
    constructor(e) {
      super("Retrying", {}, e), this.name = "RetryError", this.code = "ERR_RETRYING";
    }
  }, Ioe = class extends pr {
    static {
      n(this, "AbortError");
    }
    constructor(e) {
      super("This operation was aborted.", {}, e), this.code = "ERR_ABORTED", this.name = "AbortError";
    }
  }, gk = ur(require("process"), 1), Bv = require("buffer"), Ooe = require("stream"), OO = require("url"), Nv = ur(require("http"), 1), koe = require("events"),
  Boe = require("util"), Noe = ur(Kae(), 1), Moe = /* @__PURE__ */ n((e) => {
    if (e.timings)
      return e.timings;
    let t = {
      start: Date.now(),
      socket: void 0,
      lookup: void 0,
      connect: void 0,
      secureConnect: void 0,
      upload: void 0,
      response: void 0,
      end: void 0,
      error: void 0,
      abort: void 0,
      phases: {
        wait: void 0,
        dns: void 0,
        tcp: void 0,
        tls: void 0,
        request: void 0,
        firstByte: void 0,
        download: void 0,
        total: void 0
      }
    };
    e.timings = t;
    let r = /* @__PURE__ */ n((o) => {
      o.once(koe.errorMonitor, () => {
        t.error = Date.now(), t.phases.total = t.error - t.start;
      });
    }, "handleError");
    r(e);
    let i = /* @__PURE__ */ n(() => {
      t.abort = Date.now(), t.phases.total = t.abort - t.start;
    }, "onAbort");
    e.prependOnceListener("abort", i);
    let s = /* @__PURE__ */ n((o) => {
      if (t.socket = Date.now(), t.phases.wait = t.socket - t.start, Boe.types.isProxy(o))
        return;
      let u = /* @__PURE__ */ n(() => {
        t.lookup = Date.now(), t.phases.dns = t.lookup - t.socket;
      }, "lookupListener");
      o.prependOnceListener("lookup", u), (0, Noe.default)(o, {
        connect: /* @__PURE__ */ n(() => {
          t.connect = Date.now(), t.lookup === void 0 && (o.removeListener("lookup", u), t.lookup = t.connect, t.phases.dns = t.lookup - t.socket),
          t.phases.tcp = t.connect - t.lookup;
        }, "connect"),
        secureConnect: /* @__PURE__ */ n(() => {
          t.secureConnect = Date.now(), t.phases.tls = t.secureConnect - t.connect;
        }, "secureConnect")
      });
    }, "onSocket");
    e.socket ? s(e.socket) : e.prependOnceListener("socket", s);
    let a = /* @__PURE__ */ n(() => {
      t.upload = Date.now(), t.phases.request = t.upload - (t.secureConnect ?? t.connect);
    }, "onUpload");
    return e.writableFinished ? a() : e.prependOnceListener("finish", a), e.prependOnceListener("response", (o) => {
      t.response = Date.now(), t.phases.firstByte = t.response - t.upload, o.timings = t, r(o), o.prependOnceListener("end", () => {
        e.off("abort", i), o.off("aborted", i), !t.phases.total && (t.end = Date.now(), t.phases.download = t.end - t.response, t.phases.total =
        t.end - t.start);
      }), o.prependOnceListener("aborted", i);
    }), t;
  }, "timer"), Roe = Moe, Loe = ur(require("events"), 1), J0 = ur(require("url"), 1), joe = ur(require("crypto"), 1), bk = ur(require("stream"),
  1), qoe = "text/plain", Uoe = "us-ascii", Mv = /* @__PURE__ */ n((e, t) => t.some((r) => r instanceof RegExp ? r.test(e) : r === e), "test\
Parameter"), $oe = /* @__PURE__ */ new Set([
    "https:",
    "http:",
    "file:"
  ]), Voe = /* @__PURE__ */ n((e) => {
    try {
      let { protocol: t } = new URL(e);
      return t.endsWith(":") && !$oe.has(t);
    } catch {
      return !1;
    }
  }, "hasCustomProtocol"), Woe = /* @__PURE__ */ n((e, { stripHash: t }) => {
    var r;
    let i = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(e);
    if (!i)
      throw new Error(`Invalid URL: ${e}`);
    let { type: s, data: a, hash: o } = i.groups, u = s.split(";");
    o = t ? "" : o;
    let l = !1;
    u[u.length - 1] === "base64" && (u.pop(), l = !0);
    let c = ((r = u.shift()) == null ? void 0 : r.toLowerCase()) ?? "", m = [
      ...u.map((h) => {
        let [d, y = ""] = h.split("=").map((p) => p.trim());
        return d === "charset" && (y = y.toLowerCase(), y === Uoe) ? "" : `${d}${y ? `=${y}` : ""}`;
      }).filter(Boolean)
    ];
    return l && m.push("base64"), (m.length > 0 || c && c !== qoe) && m.unshift(c), `data:${m.join(";")},${l ? a.trim() : a}${o ? `#${o}` : ""}`;
  }, "normalizeDataURL");
  function Hoe(e, t) {
    if (t = {
      defaultProtocol: "http",
      normalizeProtocol: !0,
      forceHttp: !1,
      forceHttps: !1,
      stripAuthentication: !0,
      stripHash: !1,
      stripTextFragment: !0,
      stripWWW: !0,
      removeQueryParameters: [/^utm_\w+/i],
      removeTrailingSlash: !0,
      removeSingleSlash: !0,
      removeDirectoryIndex: !1,
      removeExplicitPort: !1,
      sortQueryParameters: !0,
      ...t
    }, typeof t.defaultProtocol == "string" && !t.defaultProtocol.endsWith(":") && (t.defaultProtocol = `${t.defaultProtocol}:`), e = e.trim(),
    /^data:/i.test(e))
      return Woe(e, t);
    if (Voe(e))
      return e;
    let r = e.startsWith("//");
    !r && /^\.*\//.test(e) || (e = e.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, t.defaultProtocol));
    let s = new URL(e);
    if (t.forceHttp && t.forceHttps)
      throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
    if (t.forceHttp && s.protocol === "https:" && (s.protocol = "http:"), t.forceHttps && s.protocol === "http:" && (s.protocol = "https:"),
    t.stripAuthentication && (s.username = "", s.password = ""), t.stripHash ? s.hash = "" : t.stripTextFragment && (s.hash = s.hash.replace(
    /#?:~:text.*?$/i, "")), s.pathname) {
      let o = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g, u = 0, l = "";
      for (; ; ) {
        let f = o.exec(s.pathname);
        if (!f)
          break;
        let m = f[0], h = f.index, d = s.pathname.slice(u, h);
        l += d.replace(/\/{2,}/g, "/"), l += m, u = h + m.length;
      }
      let c = s.pathname.slice(u, s.pathname.length);
      l += c.replace(/\/{2,}/g, "/"), s.pathname = l;
    }
    if (s.pathname)
      try {
        s.pathname = decodeURI(s.pathname);
      } catch {
      }
    if (t.removeDirectoryIndex === !0 && (t.removeDirectoryIndex = [/^index\.[a-z]+$/]), Array.isArray(t.removeDirectoryIndex) && t.removeDirectoryIndex.
    length > 0) {
      let o = s.pathname.split("/"), u = o[o.length - 1];
      Mv(u, t.removeDirectoryIndex) && (o = o.slice(0, -1), s.pathname = o.slice(1).join("/") + "/");
    }
    if (s.hostname && (s.hostname = s.hostname.replace(/\.$/, ""), t.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(s.
    hostname) && (s.hostname = s.hostname.replace(/^www\./, ""))), Array.isArray(t.removeQueryParameters))
      for (let o of [...s.searchParams.keys()])
        Mv(o, t.removeQueryParameters) && s.searchParams.delete(o);
    if (!Array.isArray(t.keepQueryParameters) && t.removeQueryParameters === !0 && (s.search = ""), Array.isArray(t.keepQueryParameters) && t.
    keepQueryParameters.length > 0)
      for (let o of [...s.searchParams.keys()])
        Mv(o, t.keepQueryParameters) || s.searchParams.delete(o);
    if (t.sortQueryParameters) {
      s.searchParams.sort();
      try {
        s.search = decodeURIComponent(s.search);
      } catch {
      }
    }
    t.removeTrailingSlash && (s.pathname = s.pathname.replace(/\/$/, "")), t.removeExplicitPort && s.port && (s.port = "");
    let a = e;
    return e = s.toString(), !t.removeSingleSlash && s.pathname === "/" && !a.endsWith("/") && s.hash === "" && (e = e.replace(/\/$/, "")), (t.
    removeTrailingSlash || s.pathname === "/") && s.hash === "" && t.removeSingleSlash && (e = e.replace(/\/$/, "")), r && !t.normalizeProtocol &&
    (e = e.replace(/^http:\/\//, "//")), t.stripProtocol && (e = e.replace(/^(?:https?:)?\/\//, "")), e;
  }
  n(Hoe, "normalizeUrl");
  var Koe = ur(rk(), 1), Rv = ur(Jae(), 1), zoe = require("stream");
  function Wv(e) {
    return Object.fromEntries(Object.entries(e).map(([t, r]) => [t.toLowerCase(), r]));
  }
  n(Wv, "lowercaseKeys");
  var kO = class extends zoe.Readable {
    static {
      n(this, "Response");
    }
    statusCode;
    headers;
    body;
    url;
    constructor({ statusCode: e, headers: t, body: r, url: i }) {
      if (typeof e != "number")
        throw new TypeError("Argument `statusCode` should be a number");
      if (typeof t != "object")
        throw new TypeError("Argument `headers` should be an object");
      if (!(r instanceof Uint8Array))
        throw new TypeError("Argument `body` should be a buffer");
      if (typeof i != "string")
        throw new TypeError("Argument `url` should be a string");
      super({
        read() {
          this.push(r), this.push(null);
        }
      }), this.statusCode = e, this.headers = Wv(t), this.body = r, this.url = i;
    }
  }, X0 = ur(Yae(), 1), Joe = [
    "aborted",
    "complete",
    "headers",
    "httpVersion",
    "httpVersionMinor",
    "httpVersionMajor",
    "method",
    "rawHeaders",
    "rawTrailers",
    "setTimeout",
    "socket",
    "statusCode",
    "statusMessage",
    "trailers",
    "url"
  ];
  function Xoe(e, t) {
    if (t._readableState.autoDestroy)
      throw new Error("The second stream must have the `autoDestroy` option set to `false`");
    let r = /* @__PURE__ */ new Set([...Object.keys(e), ...Joe]), i = {};
    for (let s of r)
      s in t || (i[s] = {
        get() {
          let a = e[s];
          return typeof a == "function" ? a.bind(e) : a;
        },
        set(a) {
          e[s] = a;
        },
        enumerable: !0,
        configurable: !1
      });
    return Object.defineProperties(t, i), e.once("aborted", () => {
      t.destroy(), t.emit("aborted");
    }), e.once("close", () => {
      e.complete && t.readable ? t.once("end", () => {
        t.emit("close");
      }) : t.emit("close");
    }), t;
  }
  n(Xoe, "mimicResponse");
  var Yoe = class extends Error {
    static {
      n(this, "RequestError2");
    }
    constructor(e) {
      super(e.message), Object.assign(this, e);
    }
  }, Zf = class extends Error {
    static {
      n(this, "CacheError2");
    }
    constructor(e) {
      super(e.message), Object.assign(this, e);
    }
  }, Goe = class {
    static {
      n(this, "CacheableRequest");
    }
    constructor(e, t) {
      this.hooks = /* @__PURE__ */ new Map(), this.request = () => (r, i) => {
        let s;
        if (typeof r == "string")
          s = Lv(J0.default.parse(r)), r = {};
        else if (r instanceof J0.default.URL)
          s = Lv(J0.default.parse(r.toString())), r = {};
        else {
          let [m, ...h] = (r.path ?? "").split("?"), d = h.length > 0 ? `?${h.join("?")}` : "";
          s = Lv({ ...r, pathname: m, search: d });
        }
        r = {
          headers: {},
          method: "GET",
          cache: !0,
          strictTtl: !1,
          automaticFailover: !1,
          ...r,
          ...eue(s)
        }, r.headers = Object.fromEntries(Zoe(r.headers).map(([m, h]) => [m.toLowerCase(), h]));
        let a = new Loe.default(), o = Hoe(J0.default.format(s), {
          stripWWW: !1,
          removeTrailingSlash: !1,
          stripAuthentication: !1
        }), u = `${r.method}:${o}`;
        r.body && r.method !== void 0 && ["POST", "PATCH", "PUT"].includes(r.method) && (r.body instanceof bk.default.Readable ? r.cache = !1 :
        u += `:${joe.default.createHash("md5").update(r.body).digest("hex")}`);
        let l = !1, c = !1, f = /* @__PURE__ */ n((m) => {
          c = !0;
          let h = !1, d = /* @__PURE__ */ n(() => {
          }, "requestErrorCallback"), y = new Promise((g) => {
            d = /* @__PURE__ */ n(() => {
              h || (h = !0, g());
            }, "requestErrorCallback");
          }), p = /* @__PURE__ */ n(async (g) => {
            if (l) {
              g.status = g.statusCode;
              let D = Rv.default.fromObject(l.cachePolicy).revalidatedPolicy(m, g);
              if (!D.modified) {
                g.resume(), await new Promise((T) => {
                  g.once("end", T);
                });
                let x = BO(D.policy.responseHeaders());
                g = new kO({ statusCode: l.statusCode, headers: x, body: l.body, url: l.url }), g.cachePolicy = D.policy, g.fromCache = !0;
              }
            }
            g.fromCache || (g.cachePolicy = new Rv.default(m, g, m), g.fromCache = !1);
            let b;
            m.cache && g.cachePolicy.storable() ? (b = Qoe(g), (async () => {
              try {
                let D = Koe.default.buffer(g);
                await Promise.race([
                  y,
                  new Promise((B) => g.once("end", B)),
                  new Promise((B) => g.once("close", B))
                  // eslint-disable-line no-promise-executor-return
                ]);
                let x = await D, T = {
                  url: g.url,
                  statusCode: g.fromCache ? l.statusCode : g.statusCode,
                  body: x,
                  cachePolicy: g.cachePolicy.toObject()
                }, w = m.strictTtl ? g.cachePolicy.timeToLive() : void 0;
                if (m.maxTtl && (w = w ? Math.min(w, m.maxTtl) : m.maxTtl), this.hooks.size > 0)
                  for (let B of this.hooks.keys())
                    T = await this.runHook(B, T, g);
                await this.cache.set(u, T, w);
              } catch (D) {
                a.emit("error", new Zf(D));
              }
            })()) : m.cache && l && (async () => {
              try {
                await this.cache.delete(u);
              } catch (D) {
                a.emit("error", new Zf(D));
              }
            })(), a.emit("response", b ?? g), typeof i == "function" && i(b ?? g);
          }, "handler");
          try {
            let g = this.cacheRequest(m, p);
            g.once("error", d), g.once("abort", d), g.once("destroy", d), a.emit("request", g);
          } catch (g) {
            a.emit("error", new Yoe(g));
          }
        }, "makeRequest");
        return (async () => {
          let m = /* @__PURE__ */ n(async (d) => {
            await Promise.resolve();
            let y = d.cache ? await this.cache.get(u) : void 0;
            if (typeof y > "u" && !d.forceRefresh) {
              f(d);
              return;
            }
            let p = Rv.default.fromObject(y.cachePolicy);
            if (p.satisfiesWithoutRevalidation(d) && !d.forceRefresh) {
              let g = BO(p.responseHeaders()), b = new kO({ statusCode: y.statusCode, headers: g, body: y.body, url: y.url });
              b.cachePolicy = p, b.fromCache = !0, a.emit("response", b), typeof i == "function" && i(b);
            } else p.satisfiesWithoutRevalidation(d) && Date.now() >= p.timeToLive() && d.forceRefresh ? (await this.cache.delete(u), d.headers =
            p.revalidationHeaders(d), f(d)) : (l = y, d.headers = p.revalidationHeaders(d), f(d));
          }, "get"), h = /* @__PURE__ */ n((d) => a.emit("error", new Zf(d)), "errorHandler");
          if (this.cache instanceof X0.default) {
            let d = this.cache;
            d.once("error", h), a.on("error", () => d.removeListener("error", h)), a.on("response", () => d.removeListener("error", h));
          }
          try {
            await m(r);
          } catch (d) {
            r.automaticFailover && !c && f(r), a.emit("error", new Zf(d));
          }
        })(), a;
      }, this.addHook = (r, i) => {
        this.hooks.has(r) || this.hooks.set(r, i);
      }, this.removeHook = (r) => this.hooks.delete(r), this.getHook = (r) => this.hooks.get(r), this.runHook = async (r, ...i) => {
        var s;
        return (s = this.hooks.get(r)) == null ? void 0 : s(...i);
      }, t instanceof X0.default ? this.cache = t : typeof t == "string" ? this.cache = new X0.default({
        uri: t,
        namespace: "cacheable-request"
      }) : this.cache = new X0.default({
        store: t,
        namespace: "cacheable-request"
      }), this.request = this.request.bind(this), this.cacheRequest = e;
    }
  }, Zoe = Object.entries, Qoe = /* @__PURE__ */ n((e) => {
    let t = new bk.PassThrough({ autoDestroy: !1 });
    return Xoe(e, t), e.pipe(t);
  }, "cloneResponse"), eue = /* @__PURE__ */ n((e) => {
    let t = { ...e };
    return t.path = `${e.pathname || "/"}${e.search || ""}`, delete t.pathname, delete t.search, t;
  }, "urlObjectToRequestOptions"), Lv = /* @__PURE__ */ n((e) => (
    // If url was parsed by url.parse or new URL:
    // - hostname will be set
    // - host will be hostname[:port]
    // - port will be set if it was explicit in the parsed string
    // Otherwise, url was from request options:
    // - hostname or host may be set
    // - host shall not have port encoded
    {
      protocol: e.protocol,
      auth: e.auth,
      hostname: e.hostname || e.host || "localhost",
      port: e.port,
      pathname: e.pathname,
      search: e.search
    }
  ), "normalizeUrlObject"), BO = /* @__PURE__ */ n((e) => {
    let t = [];
    for (let r of Object.keys(e))
      t[r.toLowerCase()] = e[r];
    return t;
  }, "convertHeaders"), tue = Goe, rue = ur(Zae(), 1), iue = ur(rk(), 1), On = /* @__PURE__ */ n((e) => typeof e == "function", "isFunction"),
  sue = /* @__PURE__ */ n((e) => On(e[Symbol.asyncIterator]), "isAsyncIterable");
  async function* nue(e) {
    let t = e.getReader();
    for (; ; ) {
      let { done: r, value: i } = await t.read();
      if (r)
        break;
      yield i;
    }
  }
  n(nue, "readStream");
  var aue = /* @__PURE__ */ n((e) => {
    if (sue(e))
      return e;
    if (On(e.getReader))
      return nue(e);
    throw new TypeError("Unsupported data source: Expected either ReadableStream or async iterable.");
  }, "getStreamIterator"), NO = "abcdefghijklmnopqrstuvwxyz0123456789";
  function oue() {
    let e = 16, t = "";
    for (; e--; )
      t += NO[Math.random() * NO.length << 0];
    return t;
  }
  n(oue, "createBoundary");
  var MO = /* @__PURE__ */ n((e) => String(e).replace(/\r|\n/g, (t, r, i) => t === "\r" && i[r + 1] !== `
` || t === `
` && i[r - 1] !== "\r" ? `\r
` : t), "normalizeValue"), uue = /* @__PURE__ */ n((e) => Object.prototype.toString.call(e).slice(8, -1).toLowerCase(), "getType");
  function RO(e) {
    if (uue(e) !== "object")
      return !1;
    let t = Object.getPrototypeOf(e);
    return t == null ? !0 : (t.constructor && t.constructor.toString()) === Object.toString();
  }
  n(RO, "isPlainObject");
  function LO(e, t) {
    if (typeof t == "string") {
      for (let [r, i] of Object.entries(e))
        if (t.toLowerCase() === r.toLowerCase())
          return i;
    }
  }
  n(LO, "getProperty");
  var lue = /* @__PURE__ */ n((e) => new Proxy(e, {
    get: /* @__PURE__ */ n((t, r) => LO(t, r), "get"),
    has: /* @__PURE__ */ n((t, r) => LO(t, r) !== void 0, "has")
  }), "proxyHeaders"), zv = /* @__PURE__ */ n((e) => !!(e && On(e.constructor) && e[Symbol.toStringTag] === "FormData" && On(e.append) && On(
  e.getAll) && On(e.entries) && On(e[Symbol.iterator])), "isFormData"), jO = /* @__PURE__ */ n((e) => String(e).replace(/\r/g, "%0D").replace(
  /\n/g, "%0A").replace(/"/g, "%22"), "escapeName"), wo = /* @__PURE__ */ n((e) => !!(e && typeof e == "object" && On(e.constructor) && e[Symbol.
  toStringTag] === "File" && On(e.stream) && e.name != null), "isFile"), Kf = /* @__PURE__ */ n(function(e, t, r, i, s) {
    if (i === "m")
      throw new TypeError("Private method is not writable");
    if (i === "a" && !s)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !s : !t.has(e))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return i === "a" ? s.call(e, r) : s ? s.value = r : t.set(e, r), r;
  }, "__classPrivateFieldSet"), Ot = /* @__PURE__ */ n(function(e, t, r, i) {
    if (r === "a" && !i)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? i : r === "a" ? i.call(e) : i ? i.value : t.get(e);
  }, "__classPrivateFieldGet"), zf, Ea, Jf, Y0, Xf, Ao, Yf, Gf, G0, jv, qO, cue = {
    enableAdditionalHeaders: !1
  }, Z0 = { writable: !1, configurable: !1 }, fue = class {
    static {
      n(this, "FormDataEncoder");
    }
    constructor(e, t, r) {
      if (zf.add(this), Ea.set(this, `\r
`), Jf.set(this, void 0), Y0.set(this, void 0), Xf.set(this, "-".repeat(2)), Ao.set(this, new TextEncoder()), Yf.set(this, void 0), Gf.set(this,
      void 0), G0.set(this, void 0), !zv(e))
        throw new TypeError("Expected first argument to be a FormData instance.");
      let i;
      if (RO(t) ? r = t : i = t, i || (i = oue()), typeof i != "string")
        throw new TypeError("Expected boundary argument to be a string.");
      if (r && !RO(r))
        throw new TypeError("Expected options argument to be an object.");
      Kf(this, Gf, Array.from(e.entries()), "f"), Kf(this, G0, { ...cue, ...r }, "f"), Kf(this, Jf, Ot(this, Ao, "f").encode(Ot(this, Ea, "f")),
      "f"), Kf(this, Y0, Ot(this, Jf, "f").byteLength, "f"), this.boundary = `form-data-boundary-${i}`, this.contentType = `multipart/form-d\
ata; boundary=${this.boundary}`, Kf(this, Yf, Ot(this, Ao, "f").encode(`${Ot(this, Xf, "f")}${this.boundary}${Ot(this, Xf, "f")}${Ot(this, Ea,
      "f").repeat(2)}`), "f");
      let s = {
        "Content-Type": this.contentType
      }, a = Ot(this, zf, "m", qO).call(this);
      a && (this.contentLength = a, s["Content-Length"] = a), this.headers = lue(Object.freeze(s)), Object.defineProperties(this, {
        boundary: Z0,
        contentType: Z0,
        contentLength: Z0,
        headers: Z0
      });
    }
    getContentLength() {
      return this.contentLength == null ? void 0 : Number(this.contentLength);
    }
    *values() {
      for (let [e, t] of Ot(this, Gf, "f")) {
        let r = wo(t) ? t : Ot(this, Ao, "f").encode(MO(t));
        yield Ot(this, zf, "m", jv).call(this, e, r), yield r, yield Ot(this, Jf, "f");
      }
      yield Ot(this, Yf, "f");
    }
    async *encode() {
      for (let e of this.values())
        wo(e) ? yield* aue(e.stream()) : yield e;
    }
    [(Ea = /* @__PURE__ */ new WeakMap(), Jf = /* @__PURE__ */ new WeakMap(), Y0 = /* @__PURE__ */ new WeakMap(), Xf = /* @__PURE__ */ new WeakMap(),
    Ao = /* @__PURE__ */ new WeakMap(), Yf = /* @__PURE__ */ new WeakMap(), Gf = /* @__PURE__ */ new WeakMap(), G0 = /* @__PURE__ */ new WeakMap(),
    zf = /* @__PURE__ */ new WeakSet(), jv = /* @__PURE__ */ n(function(t, r) {
      let i = "";
      i += `${Ot(this, Xf, "f")}${this.boundary}${Ot(this, Ea, "f")}`, i += `Content-Disposition: form-data; name="${jO(t)}"`, wo(r) && (i +=
      `; filename="${jO(r.name)}"${Ot(this, Ea, "f")}`, i += `Content-Type: ${r.type || "application/octet-stream"}`);
      let s = wo(r) ? r.size : r.byteLength;
      return Ot(this, G0, "f").enableAdditionalHeaders === !0 && s != null && !isNaN(s) && (i += `${Ot(this, Ea, "f")}Content-Length: ${wo(r) ?
      r.size : r.byteLength}`), Ot(this, Ao, "f").encode(`${i}${Ot(this, Ea, "f").repeat(2)}`);
    }, "_FormDataEncoder_getFieldHeader2"), qO = /* @__PURE__ */ n(function() {
      let t = 0;
      for (let [r, i] of Ot(this, Gf, "f")) {
        let s = wo(i) ? i : Ot(this, Ao, "f").encode(MO(i)), a = wo(s) ? s.size : s.byteLength;
        if (a == null || isNaN(a))
          return;
        t += Ot(this, zf, "m", jv).call(this, r, s).byteLength, t += a, t += Ot(this, Y0, "f");
      }
      return String(t + Ot(this, Yf, "f").byteLength);
    }, "_FormDataEncoder_getContentLength2"), Symbol.iterator)]() {
      return this.values();
    }
    [Symbol.asyncIterator]() {
      return this.encode();
    }
  }, due = require("buffer"), pue = require("util");
  function Dk(e) {
    return U.nodeStream(e) && U.function_(e.getBoundary);
  }
  n(Dk, "isFormData2");
  async function hue(e, t) {
    if (t && "content-length" in t)
      return Number(t["content-length"]);
    if (!e)
      return 0;
    if (U.string(e))
      return due.Buffer.byteLength(e);
    if (U.buffer(e))
      return e.length;
    if (Dk(e))
      return (0, pue.promisify)(e.getLength.bind(e))();
  }
  n(hue, "getBodySize");
  function vk(e, t, r) {
    let i = {};
    for (let s of r) {
      let a = /* @__PURE__ */ n((...o) => {
        t.emit(s, ...o);
      }, "eventFunction");
      i[s] = a, e.on(s, a);
    }
    return () => {
      for (let [s, a] of Object.entries(i))
        e.off(s, a);
    };
  }
  n(vk, "proxyEvents");
  var mue = ur(require("net"), 1);
  function yue() {
    let e = [];
    return {
      once(t, r, i) {
        t.once(r, i), e.push({ origin: t, event: r, fn: i });
      },
      unhandleAll() {
        for (let t of e) {
          let { origin: r, event: i, fn: s } = t;
          r.removeListener(i, s);
        }
        e.length = 0;
      }
    };
  }
  n(yue, "unhandle");
  var UO = Symbol("reentry"), gue = /* @__PURE__ */ n(() => {
  }, "noop"), xk = class extends Error {
    static {
      n(this, "TimeoutError2");
    }
    constructor(e, t) {
      super(`Timeout awaiting '${t}' for ${e}ms`), Object.defineProperty(this, "event", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
      }), Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.name = "TimeoutError", this.code = "ETIMEDOUT";
    }
  };
  function bue(e, t, r) {
    if (UO in e)
      return gue;
    e[UO] = !0;
    let i = [], { once: s, unhandleAll: a } = yue(), o = /* @__PURE__ */ n((p, g, b) => {
      var D;
      let x = setTimeout(g, p, p, b);
      (D = x.unref) == null || D.call(x);
      let T = /* @__PURE__ */ n(() => {
        clearTimeout(x);
      }, "cancel");
      return i.push(T), T;
    }, "addTimeout"), { host: u, hostname: l } = r, c = /* @__PURE__ */ n((p, g) => {
      e.destroy(new xk(p, g));
    }, "timeoutHandler"), f = /* @__PURE__ */ n(() => {
      for (let p of i)
        p();
      a();
    }, "cancelTimeouts");
    if (e.once("error", (p) => {
      if (f(), e.listenerCount("error") === 0)
        throw p;
    }), typeof t.request < "u") {
      let p = o(t.request, c, "request");
      s(e, "response", (g) => {
        s(g, "end", p);
      });
    }
    if (typeof t.socket < "u") {
      let { socket: p } = t, g = /* @__PURE__ */ n(() => {
        c(p, "socket");
      }, "socketTimeoutHandler");
      e.setTimeout(p, g), i.push(() => {
        e.removeListener("timeout", g);
      });
    }
    let m = typeof t.lookup < "u", h = typeof t.connect < "u", d = typeof t.secureConnect < "u", y = typeof t.send < "u";
    return (m || h || d || y) && s(e, "socket", (p) => {
      let { socketPath: g } = e;
      if (p.connecting) {
        let b = !!(g ?? mue.default.isIP(l ?? u ?? "") !== 0);
        if (m && !b && typeof p.address().address > "u") {
          let D = o(t.lookup, c, "lookup");
          s(p, "lookup", D);
        }
        if (h) {
          let D = /* @__PURE__ */ n(() => o(t.connect, c, "connect"), "timeConnect");
          b ? s(p, "connect", D()) : s(p, "lookup", (x) => {
            x === null && s(p, "connect", D());
          });
        }
        d && r.protocol === "https:" && s(p, "connect", () => {
          let D = o(t.secureConnect, c, "secureConnect");
          s(p, "secureConnect", D);
        });
      }
      if (y) {
        let b = /* @__PURE__ */ n(() => o(t.send, c, "send"), "timeRequest");
        p.connecting ? s(p, "connect", () => {
          s(e, "upload-complete", b());
        }) : s(e, "upload-complete", b());
      }
    }), typeof t.response < "u" && s(e, "upload-complete", () => {
      let p = o(t.response, c, "response");
      s(e, "response", p);
    }), typeof t.read < "u" && s(e, "response", (p) => {
      let g = o(t.read, c, "read");
      s(p, "end", g);
    }), f;
  }
  n(bue, "timedOut");
  function Due(e) {
    e = e;
    let t = {
      protocol: e.protocol,
      hostname: U.string(e.hostname) && e.hostname.startsWith("[") ? e.hostname.slice(1, -1) : e.hostname,
      host: e.host,
      hash: e.hash,
      search: e.search,
      pathname: e.pathname,
      href: e.href,
      path: `${e.pathname || ""}${e.search || ""}`
    };
    return U.string(e.port) && e.port.length > 0 && (t.port = Number(e.port)), (e.username || e.password) && (t.auth = `${e.username || ""}:${e.
    password || ""}`), t;
  }
  n(Due, "urlToOptions");
  var vue = class {
    static {
      n(this, "WeakableMap");
    }
    constructor() {
      Object.defineProperty(this, "weakMap", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "map", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.weakMap = /* @__PURE__ */ new WeakMap(), this.map = /* @__PURE__ */ new Map();
    }
    set(e, t) {
      typeof e == "object" ? this.weakMap.set(e, t) : this.map.set(e, t);
    }
    get(e) {
      return typeof e == "object" ? this.weakMap.get(e) : this.map.get(e);
    }
    has(e) {
      return typeof e == "object" ? this.weakMap.has(e) : this.map.has(e);
    }
  }, xue = /* @__PURE__ */ n(({ attemptCount: e, retryOptions: t, error: r, retryAfter: i, computedValue: s }) => {
    if (r.name === "RetryError")
      return 1;
    if (e > t.limit)
      return 0;
    let a = t.methods.includes(r.options.method), o = t.errorCodes.includes(r.code), u = r.response && t.statusCodes.includes(r.response.statusCode);
    if (!a || !o && !u)
      return 0;
    if (r.response) {
      if (i)
        return i > s ? 0 : i;
      if (r.response.statusCode === 413)
        return 0;
    }
    let l = Math.random() * t.noise;
    return Math.min(2 ** (e - 1) * 1e3, t.backoffLimit) + l;
  }, "calculateRetryDelay"), Eue = xue, Sue = ur(require("process"), 1), qv = require("util"), _o = require("url"), Tue = require("tls"), Cue = ur(
  require("http"), 1), wue = ur(require("https"), 1), xl = require("dns"), Uv = require("util"), Aue = ur(require("os"), 1), { Resolver: $O } = xl.
  promises, vl = Symbol("cacheableLookupCreateConnection"), $v = Symbol("cacheableLookupInstance"), VO = Symbol("expires"), _ue = typeof xl.
  ALL == "number", WO = /* @__PURE__ */ n((e) => {
    if (!(e && typeof e.createConnection == "function"))
      throw new Error("Expected an Agent instance as the first argument");
  }, "verifyAgent"), Pue = /* @__PURE__ */ n((e) => {
    for (let t of e)
      t.family !== 6 && (t.address = `::ffff:${t.address}`, t.family = 6);
  }, "map4to6"), HO = /* @__PURE__ */ n(() => {
    let e = !1, t = !1;
    for (let r of Object.values(Aue.default.networkInterfaces()))
      for (let i of r)
        if (!i.internal && (i.family === "IPv6" ? t = !0 : e = !0, e && t))
          return { has4: e, has6: t };
    return { has4: e, has6: t };
  }, "getIfaceInfo"), Fue = /* @__PURE__ */ n((e) => Symbol.iterator in e, "isIterable"), Q0 = /* @__PURE__ */ n((e) => e.catch((t) => {
    if (t.code === "ENODATA" || t.code === "ENOTFOUND" || t.code === "ENOENT")
      return [];
    throw t;
  }), "ignoreNoResultErrors"), KO = { ttl: !0 }, Iue = { all: !0 }, Oue = { all: !0, family: 4 }, kue = { all: !0, family: 6 }, Bue = class {
    static {
      n(this, "CacheableLookup");
    }
    constructor({
      cache: e = /* @__PURE__ */ new Map(),
      maxTtl: t = 1 / 0,
      fallbackDuration: r = 3600,
      errorTtl: i = 0.15,
      resolver: s = new $O(),
      lookup: a = xl.lookup
    } = {}) {
      if (this.maxTtl = t, this.errorTtl = i, this._cache = e, this._resolver = s, this._dnsLookup = a && (0, Uv.promisify)(a), this.stats =
      {
        cache: 0,
        query: 0
      }, this._resolver instanceof $O ? (this._resolve4 = this._resolver.resolve4.bind(this._resolver), this._resolve6 = this._resolver.resolve6.
      bind(this._resolver)) : (this._resolve4 = (0, Uv.promisify)(this._resolver.resolve4.bind(this._resolver)), this._resolve6 = (0, Uv.promisify)(
      this._resolver.resolve6.bind(this._resolver))), this._iface = HO(), this._pending = {}, this._nextRemovalTime = !1, this._hostnamesToFallback =
      /* @__PURE__ */ new Set(), this.fallbackDuration = r, r > 0) {
        let o = setInterval(() => {
          this._hostnamesToFallback.clear();
        }, r * 1e3);
        o.unref && o.unref(), this._fallbackInterval = o;
      }
      this.lookup = this.lookup.bind(this), this.lookupAsync = this.lookupAsync.bind(this);
    }
    set servers(e) {
      this.clear(), this._resolver.setServers(e);
    }
    get servers() {
      return this._resolver.getServers();
    }
    lookup(e, t, r) {
      if (typeof t == "function" ? (r = t, t = {}) : typeof t == "number" && (t = {
        family: t
      }), !r)
        throw new Error("Callback must be a function.");
      this.lookupAsync(e, t).then((i) => {
        t.all ? r(null, i) : r(null, i.address, i.family, i.expires, i.ttl, i.source);
      }, r);
    }
    async lookupAsync(e, t = {}) {
      typeof t == "number" && (t = {
        family: t
      });
      let r = await this.query(e);
      if (t.family === 6) {
        let i = r.filter((s) => s.family === 6);
        t.hints & xl.V4MAPPED && (_ue && t.hints & xl.ALL || i.length === 0) ? Pue(r) : r = i;
      } else t.family === 4 && (r = r.filter((i) => i.family === 4));
      if (t.hints & xl.ADDRCONFIG) {
        let { _iface: i } = this;
        r = r.filter((s) => s.family === 6 ? i.has6 : i.has4);
      }
      if (r.length === 0) {
        let i = new Error(`cacheableLookup ENOTFOUND ${e}`);
        throw i.code = "ENOTFOUND", i.hostname = e, i;
      }
      return t.all ? r : r[0];
    }
    async query(e) {
      let t = "cache", r = await this._cache.get(e);
      if (r && this.stats.cache++, !r) {
        let i = this._pending[e];
        if (i)
          this.stats.cache++, r = await i;
        else {
          t = "query";
          let s = this.queryAndCache(e);
          this._pending[e] = s, this.stats.query++;
          try {
            r = await s;
          } finally {
            delete this._pending[e];
          }
        }
      }
      return r = r.map((i) => ({ ...i, source: t })), r;
    }
    async _resolve(e) {
      let [t, r] = await Promise.all([
        Q0(this._resolve4(e, KO)),
        Q0(this._resolve6(e, KO))
      ]), i = 0, s = 0, a = 0, o = Date.now();
      for (let u of t)
        u.family = 4, u.expires = o + u.ttl * 1e3, i = Math.max(i, u.ttl);
      for (let u of r)
        u.family = 6, u.expires = o + u.ttl * 1e3, s = Math.max(s, u.ttl);
      return t.length > 0 ? r.length > 0 ? a = Math.min(i, s) : a = i : a = s, {
        entries: [
          ...t,
          ...r
        ],
        cacheTtl: a
      };
    }
    async _lookup(e) {
      try {
        let [t, r] = await Promise.all([
          // Passing {all: true} doesn't return all IPv4 and IPv6 entries.
          // See https://github.com/szmarczak/cacheable-lookup/issues/42
          Q0(this._dnsLookup(e, Oue)),
          Q0(this._dnsLookup(e, kue))
        ]);
        return {
          entries: [
            ...t,
            ...r
          ],
          cacheTtl: 0
        };
      } catch {
        return {
          entries: [],
          cacheTtl: 0
        };
      }
    }
    async _set(e, t, r) {
      if (this.maxTtl > 0 && r > 0) {
        r = Math.min(r, this.maxTtl) * 1e3, t[VO] = Date.now() + r;
        try {
          await this._cache.set(e, t, r);
        } catch (i) {
          this.lookupAsync = async () => {
            let s = new Error("Cache Error. Please recreate the CacheableLookup instance.");
            throw s.cause = i, s;
          };
        }
        Fue(this._cache) && this._tick(r);
      }
    }
    async queryAndCache(e) {
      if (this._hostnamesToFallback.has(e))
        return this._dnsLookup(e, Iue);
      let t = await this._resolve(e);
      t.entries.length === 0 && this._dnsLookup && (t = await this._lookup(e), t.entries.length !== 0 && this.fallbackDuration > 0 && this._hostnamesToFallback.
      add(e));
      let r = t.entries.length === 0 ? this.errorTtl : t.cacheTtl;
      return await this._set(e, t.entries, r), t.entries;
    }
    _tick(e) {
      let t = this._nextRemovalTime;
      (!t || e < t) && (clearTimeout(this._removalTimeout), this._nextRemovalTime = e, this._removalTimeout = setTimeout(() => {
        this._nextRemovalTime = !1;
        let r = 1 / 0, i = Date.now();
        for (let [s, a] of this._cache) {
          let o = a[VO];
          i >= o ? this._cache.delete(s) : o < r && (r = o);
        }
        r !== 1 / 0 && this._tick(r - i);
      }, e), this._removalTimeout.unref && this._removalTimeout.unref());
    }
    install(e) {
      if (WO(e), vl in e)
        throw new Error("CacheableLookup has been already installed");
      e[vl] = e.createConnection, e[$v] = this, e.createConnection = (t, r) => ("lookup" in t || (t.lookup = this.lookup), e[vl](t, r));
    }
    uninstall(e) {
      if (WO(e), e[vl]) {
        if (e[$v] !== this)
          throw new Error("The agent is not owned by this CacheableLookup instance");
        e.createConnection = e[vl], delete e[vl], delete e[$v];
      }
    }
    updateInterfaceInfo() {
      let { _iface: e } = this;
      this._iface = HO(), (e.has4 && !this._iface.has4 || e.has6 && !this._iface.has6) && this._cache.clear();
    }
    clear(e) {
      if (e) {
        this._cache.delete(e);
        return;
      }
      this._cache.clear();
    }
  }, Nue = ur(loe(), 1);
  function Mue(e) {
    let t = [], r = e.split(",");
    for (let i of r) {
      let [s, ...a] = i.split(";"), o = s.trim();
      if (o[0] !== "<" || o[o.length - 1] !== ">")
        throw new Error(`Invalid format of the Link header reference: ${o}`);
      let u = o.slice(1, -1), l = {};
      if (a.length === 0)
        throw new Error(`Unexpected end of Link header parameters: ${a.join(";")}`);
      for (let c of a) {
        let f = c.trim(), m = f.indexOf("=");
        if (m === -1)
          throw new Error(`Failed to parse Link header: ${e}`);
        let h = f.slice(0, m).trim(), d = f.slice(m + 1).trim();
        l[h] = d;
      }
      t.push({
        reference: u,
        parameters: l
      });
    }
    return t;
  }
  n(Mue, "parseLinkHeader");
  var [zO, Rue] = Sue.default.versions.node.split(".").map(Number);
  function Lue(e) {
    for (let t in e) {
      let r = e[t];
      ee.any([U.string, U.number, U.boolean, U.null_, U.undefined], r);
    }
  }
  n(Lue, "validateSearchParameters");
  var jue = /* @__PURE__ */ new Map(), em, que = /* @__PURE__ */ n(() => em || (em = new Bue(), em), "getGlobalDnsCache"), Uue = {
    request: void 0,
    agent: {
      http: void 0,
      https: void 0,
      http2: void 0
    },
    h2session: void 0,
    decompress: !0,
    timeout: {
      connect: void 0,
      lookup: void 0,
      read: void 0,
      request: void 0,
      response: void 0,
      secureConnect: void 0,
      send: void 0,
      socket: void 0
    },
    prefixUrl: "",
    body: void 0,
    form: void 0,
    json: void 0,
    cookieJar: void 0,
    ignoreInvalidCookies: !1,
    searchParams: void 0,
    dnsLookup: void 0,
    dnsCache: void 0,
    context: {},
    hooks: {
      init: [],
      beforeRequest: [],
      beforeError: [],
      beforeRedirect: [],
      beforeRetry: [],
      afterResponse: []
    },
    followRedirect: !0,
    maxRedirects: 10,
    cache: void 0,
    throwHttpErrors: !0,
    username: "",
    password: "",
    http2: !1,
    allowGetBody: !1,
    headers: {
      "user-agent": "got (https://github.com/sindresorhus/got)"
    },
    methodRewriting: !1,
    dnsLookupIpVersion: void 0,
    parseJson: JSON.parse,
    stringifyJson: JSON.stringify,
    retry: {
      limit: 2,
      methods: [
        "GET",
        "PUT",
        "HEAD",
        "DELETE",
        "OPTIONS",
        "TRACE"
      ],
      statusCodes: [
        408,
        413,
        429,
        500,
        502,
        503,
        504,
        521,
        522,
        524
      ],
      errorCodes: [
        "ETIMEDOUT",
        "ECONNRESET",
        "EADDRINUSE",
        "ECONNREFUSED",
        "EPIPE",
        "ENOTFOUND",
        "ENETUNREACH",
        "EAI_AGAIN"
      ],
      maxRetryAfter: void 0,
      calculateDelay: /* @__PURE__ */ n(({ computedValue: e }) => e, "calculateDelay"),
      backoffLimit: Number.POSITIVE_INFINITY,
      noise: 100
    },
    localAddress: void 0,
    method: "GET",
    createConnection: void 0,
    cacheOptions: {
      shared: void 0,
      cacheHeuristic: void 0,
      immutableMinTimeToLive: void 0,
      ignoreCargoCult: void 0
    },
    https: {
      alpnProtocols: void 0,
      rejectUnauthorized: void 0,
      checkServerIdentity: void 0,
      certificateAuthority: void 0,
      key: void 0,
      certificate: void 0,
      passphrase: void 0,
      pfx: void 0,
      ciphers: void 0,
      honorCipherOrder: void 0,
      minVersion: void 0,
      maxVersion: void 0,
      signatureAlgorithms: void 0,
      tlsSessionLifetime: void 0,
      dhparam: void 0,
      ecdhCurve: void 0,
      certificateRevocationLists: void 0
    },
    encoding: void 0,
    resolveBodyOnly: !1,
    isStream: !1,
    responseType: "text",
    url: void 0,
    pagination: {
      transform(e) {
        return e.request.options.responseType === "json" ? e.body : JSON.parse(e.body);
      },
      paginate({ response: e }) {
        let t = e.headers.link;
        if (typeof t != "string" || t.trim() === "")
          return !1;
        let i = Mue(t).find((s) => s.parameters.rel === "next" || s.parameters.rel === '"next"');
        return i ? {
          url: new _o.URL(i.reference, e.url)
        } : !1;
      },
      filter: /* @__PURE__ */ n(() => !0, "filter"),
      shouldContinue: /* @__PURE__ */ n(() => !0, "shouldContinue"),
      countLimit: Number.POSITIVE_INFINITY,
      backoff: 0,
      requestLimit: 1e4,
      stackAllItems: !1
    },
    setHost: !0,
    maxHeaderSize: void 0,
    signal: void 0,
    enableUnixSockets: !0
  }, $ue = /* @__PURE__ */ n((e) => {
    let { hooks: t, retry: r } = e, i = {
      ...e,
      context: { ...e.context },
      cacheOptions: { ...e.cacheOptions },
      https: { ...e.https },
      agent: { ...e.agent },
      headers: { ...e.headers },
      retry: {
        ...r,
        errorCodes: [...r.errorCodes],
        methods: [...r.methods],
        statusCodes: [...r.statusCodes]
      },
      timeout: { ...e.timeout },
      hooks: {
        init: [...t.init],
        beforeRequest: [...t.beforeRequest],
        beforeError: [...t.beforeError],
        beforeRedirect: [...t.beforeRedirect],
        beforeRetry: [...t.beforeRetry],
        afterResponse: [...t.afterResponse]
      },
      searchParams: e.searchParams ? new _o.URLSearchParams(e.searchParams) : void 0,
      pagination: { ...e.pagination }
    };
    return i.url !== void 0 && (i.prefixUrl = ""), i;
  }, "cloneInternals"), Vue = /* @__PURE__ */ n((e) => {
    let { hooks: t, retry: r } = e, i = { ...e };
    return U.object(e.context) && (i.context = { ...e.context }), U.object(e.cacheOptions) && (i.cacheOptions = { ...e.cacheOptions }), U.object(
    e.https) && (i.https = { ...e.https }), U.object(e.cacheOptions) && (i.cacheOptions = { ...i.cacheOptions }), U.object(e.agent) && (i.agent =
    { ...e.agent }), U.object(e.headers) && (i.headers = { ...e.headers }), U.object(r) && (i.retry = { ...r }, U.array(r.errorCodes) && (i.
    retry.errorCodes = [...r.errorCodes]), U.array(r.methods) && (i.retry.methods = [...r.methods]), U.array(r.statusCodes) && (i.retry.statusCodes =
    [...r.statusCodes])), U.object(e.timeout) && (i.timeout = { ...e.timeout }), U.object(t) && (i.hooks = {
      ...t
    }, U.array(t.init) && (i.hooks.init = [...t.init]), U.array(t.beforeRequest) && (i.hooks.beforeRequest = [...t.beforeRequest]), U.array(
    t.beforeError) && (i.hooks.beforeError = [...t.beforeError]), U.array(t.beforeRedirect) && (i.hooks.beforeRedirect = [...t.beforeRedirect]),
    U.array(t.beforeRetry) && (i.hooks.beforeRetry = [...t.beforeRetry]), U.array(t.afterResponse) && (i.hooks.afterResponse = [...t.afterResponse])),
    U.object(e.pagination) && (i.pagination = { ...e.pagination }), i;
  }, "cloneRaw"), Wue = /* @__PURE__ */ n((e) => {
    let t = [e.timeout.socket, e.timeout.connect, e.timeout.lookup, e.timeout.request, e.timeout.secureConnect].filter((r) => typeof r == "n\
umber");
    if (t.length > 0)
      return Math.min(...t);
  }, "getHttp2TimeoutOption"), JO = /* @__PURE__ */ n((e, t, r) => {
    var i;
    let s = (i = e.hooks) == null ? void 0 : i.init;
    if (s)
      for (let a of s)
        a(t, r);
  }, "init"), kn = class {
    static {
      n(this, "Options");
    }
    constructor(e, t, r) {
      if (Object.defineProperty(this, "_unixOptions", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_internals", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_merging", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_init", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), ee.any([U.string, U.urlInstance, U.object, U.undefined], e), ee.any([U.object, U.undefined], t), ee.any([U.object, U.undefined], r),
      e instanceof kn || t instanceof kn)
        throw new TypeError("The defaults must be passed as the third argument");
      this._internals = $ue(r?._internals ?? r ?? Uue), this._init = [...r?._init ?? []], this._merging = !1, this._unixOptions = void 0;
      try {
        if (U.plainObject(e))
          try {
            this.merge(e), this.merge(t);
          } finally {
            this.url = e.url;
          }
        else
          try {
            this.merge(t);
          } finally {
            if (t?.url !== void 0)
              if (e === void 0)
                this.url = t.url;
              else
                throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
            else e !== void 0 && (this.url = e);
          }
      } catch (i) {
        throw i.options = this, i;
      }
    }
    merge(e) {
      if (e) {
        if (e instanceof kn) {
          for (let t of e._init)
            this.merge(t);
          return;
        }
        e = Vue(e), JO(this, e, this), JO(e, e, this), this._merging = !0, "isStream" in e && (this.isStream = e.isStream);
        try {
          let t = !1;
          for (let r in e)
            if (!(r === "mutableDefaults" || r === "handlers") && r !== "url") {
              if (!(r in this))
                throw new Error(`Unexpected option: ${r}`);
              this[r] = e[r], t = !0;
            }
          t && this._init.push(e);
        } finally {
          this._merging = !1;
        }
      }
    }
    /**
        Custom request function.
        The main purpose of this is to [support HTTP2 using a wrapper](https://github.com/szmarczak/http2-wrapper).
    
        @default http.request | https.request
        */
    get request() {
      return this._internals.request;
    }
    set request(e) {
      ee.any([U.function_, U.undefined], e), this._internals.request = e;
    }
    /**
        An object representing `http`, `https` and `http2` keys for [`http.Agent`](https://nodejs.org/api/http.html#http_class_http_agent), [`https.Agent`](https://nodejs.org/api/https.html#https_class_https_agent) and [`http2wrapper.Agent`](https://github.com/szmarczak/http2-wrapper#new-http2agentoptions) instance.
        This is necessary because a request to one protocol might redirect to another.
        In such a scenario, Got will switch over to the right protocol agent for you.
    
        If a key is not present, it will default to a global agent.
    
        @example
        ```
        import got from 'got';
        import HttpAgent from 'agentkeepalive';
    
        const {HttpsAgent} = HttpAgent;
    
        await got('https://sindresorhus.com', {
            agent: {
                http: new HttpAgent(),
                https: new HttpsAgent()
            }
        });
        ```
        */
    get agent() {
      return this._internals.agent;
    }
    set agent(e) {
      ee.plainObject(e);
      for (let t in e) {
        if (!(t in this._internals.agent))
          throw new TypeError(`Unexpected agent option: ${t}`);
        ee.any([U.object, U.undefined], e[t]);
      }
      this._merging ? Object.assign(this._internals.agent, e) : this._internals.agent = { ...e };
    }
    get h2session() {
      return this._internals.h2session;
    }
    set h2session(e) {
      this._internals.h2session = e;
    }
    /**
        Decompress the response automatically.
    
        This will set the `accept-encoding` header to `gzip, deflate, br` unless you set it yourself.
    
        If this is disabled, a compressed response is returned as a `Buffer`.
        This may be useful if you want to handle decompression yourself or stream the raw compressed data.
    
        @default true
        */
    get decompress() {
      return this._internals.decompress;
    }
    set decompress(e) {
      ee.boolean(e), this._internals.decompress = e;
    }
    /**
        Milliseconds to wait for the server to end the response before aborting the request with `got.TimeoutError` error (a.k.a. `request` property).
        By default, there's no timeout.
    
        This also accepts an `object` with the following fields to constrain the duration of each phase of the request lifecycle:
    
        - `lookup` starts when a socket is assigned and ends when the hostname has been resolved.
            Does not apply when using a Unix domain socket.
        - `connect` starts when `lookup` completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.
        - `secureConnect` starts when `connect` completes and ends when the handshaking process completes (HTTPS only).
        - `socket` starts when the socket is connected. See [request.setTimeout](https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback).
        - `response` starts when the request has been written to the socket and ends when the response headers are received.
        - `send` starts when the socket is connected and ends with the request has been written to the socket.
        - `request` starts when the request is initiated and ends when the response's end event fires.
        */
    get timeout() {
      return this._internals.timeout;
    }
    set timeout(e) {
      ee.plainObject(e);
      for (let t in e) {
        if (!(t in this._internals.timeout))
          throw new Error(`Unexpected timeout option: ${t}`);
        ee.any([U.number, U.undefined], e[t]);
      }
      this._merging ? Object.assign(this._internals.timeout, e) : this._internals.timeout = { ...e };
    }
    /**
        When specified, `prefixUrl` will be prepended to `url`.
        The prefix can be any valid URL, either relative or absolute.
        A trailing slash `/` is optional - one will be added automatically.
    
        __Note__: `prefixUrl` will be ignored if the `url` argument is a URL instance.
    
        __Note__: Leading slashes in `input` are disallowed when using this option to enforce consistency and avoid confusion.
        For example, when the prefix URL is `https://example.com/foo` and the input is `/bar`, there's ambiguity whether the resulting URL would become `https://example.com/foo/bar` or `https://example.com/bar`.
        The latter is used by browsers.
    
        __Tip__: Useful when used with `got.extend()` to create niche-specific Got instances.
    
        __Tip__: You can change `prefixUrl` using hooks as long as the URL still includes the `prefixUrl`.
        If the URL doesn't include it anymore, it will throw.
    
        @example
        ```
        import got from 'got';
    
        await got('unicorn', {prefixUrl: 'https://cats.com'});
        //=> 'https://cats.com/unicorn'
    
        const instance = got.extend({
            prefixUrl: 'https://google.com'
        });
    
        await instance('unicorn', {
            hooks: {
                beforeRequest: [
                    options => {
                        options.prefixUrl = 'https://cats.com';
                    }
                ]
            }
        });
        //=> 'https://cats.com/unicorn'
        ```
        */
    get prefixUrl() {
      return this._internals.prefixUrl;
    }
    set prefixUrl(e) {
      if (ee.any([U.string, U.urlInstance], e), e === "") {
        this._internals.prefixUrl = "";
        return;
      }
      if (e = e.toString(), e.endsWith("/") || (e += "/"), this._internals.prefixUrl && this._internals.url) {
        let { href: t } = this._internals.url;
        this._internals.url.href = e + t.slice(this._internals.prefixUrl.length);
      }
      this._internals.prefixUrl = e;
    }
    /**
        __Note #1__: The `body` option cannot be used with the `json` or `form` option.
    
        __Note #2__: If you provide this option, `got.stream()` will be read-only.
    
        __Note #3__: If you provide a payload with the `GET` or `HEAD` method, it will throw a `TypeError` unless the method is `GET` and the `allowGetBody` option is set to `true`.
    
        __Note #4__: This option is not enumerable and will not be merged with the instance defaults.
    
        The `content-length` header will be automatically set if `body` is a `string` / `Buffer` / [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) / [`form-data` instance](https://github.com/form-data/form-data), and `content-length` and `transfer-encoding` are not manually set in `options.headers`.
    
        Since Got 12, the `content-length` is not automatically set when `body` is a `fs.createReadStream`.
        */
    get body() {
      return this._internals.body;
    }
    set body(e) {
      ee.any([U.string, U.buffer, U.nodeStream, U.generator, U.asyncGenerator, zv, U.undefined], e), U.nodeStream(e) && ee.truthy(e.readable),
      e !== void 0 && (ee.undefined(this._internals.form), ee.undefined(this._internals.json)), this._internals.body = e;
    }
    /**
        The form body is converted to a query string using [`(new URLSearchParams(object)).toString()`](https://nodejs.org/api/url.html#url_constructor_new_urlsearchparams_obj).
    
        If the `Content-Type` header is not present, it will be set to `application/x-www-form-urlencoded`.
    
        __Note #1__: If you provide this option, `got.stream()` will be read-only.
    
        __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
        */
    get form() {
      return this._internals.form;
    }
    set form(e) {
      ee.any([U.plainObject, U.undefined], e), e !== void 0 && (ee.undefined(this._internals.body), ee.undefined(this._internals.json)), this.
      _internals.form = e;
    }
    /**
        JSON body. If the `Content-Type` header is not set, it will be set to `application/json`.
    
        __Note #1__: If you provide this option, `got.stream()` will be read-only.
    
        __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
        */
    get json() {
      return this._internals.json;
    }
    set json(e) {
      e !== void 0 && (ee.undefined(this._internals.body), ee.undefined(this._internals.form)), this._internals.json = e;
    }
    /**
        The URL to request, as a string, a [`https.request` options object](https://nodejs.org/api/https.html#https_https_request_options_callback), or a [WHATWG `URL`](https://nodejs.org/api/url.html#url_class_url).
    
        Properties from `options` will override properties in the parsed `url`.
    
        If no protocol is specified, it will throw a `TypeError`.
    
        __Note__: The query string is **not** parsed as search params.
    
        @example
        ```
        await got('https://example.com/?query=a b'); //=> https://example.com/?query=a%20b
        await got('https://example.com/', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
    
        // The query string is overridden by `searchParams`
        await got('https://example.com/?query=a b', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
        ```
        */
    get url() {
      return this._internals.url;
    }
    set url(e) {
      if (ee.any([U.string, U.urlInstance, U.undefined], e), e === void 0) {
        this._internals.url = void 0;
        return;
      }
      if (U.string(e) && e.startsWith("/"))
        throw new Error("`url` must not start with a slash");
      let t = `${this.prefixUrl}${e.toString()}`, r = new _o.URL(t);
      if (this._internals.url = r, decodeURI(t), r.protocol === "unix:" && (r.href = `http://unix${r.pathname}${r.search}`), r.protocol !== "\
http:" && r.protocol !== "https:") {
        let i = new Error(`Unsupported protocol: ${r.protocol}`);
        throw i.code = "ERR_UNSUPPORTED_PROTOCOL", i;
      }
      if (this._internals.username && (r.username = this._internals.username, this._internals.username = ""), this._internals.password && (r.
      password = this._internals.password, this._internals.password = ""), this._internals.searchParams && (r.search = this._internals.searchParams.
      toString(), this._internals.searchParams = void 0), r.hostname === "unix") {
        if (!this._internals.enableUnixSockets)
          throw new Error("Using UNIX domain sockets but option `enableUnixSockets` is not enabled");
        let i = /(?<socketPath>.+?):(?<path>.+)/.exec(`${r.pathname}${r.search}`);
        if (i?.groups) {
          let { socketPath: s, path: a } = i.groups;
          this._unixOptions = {
            socketPath: s,
            path: a,
            host: ""
          };
        } else
          this._unixOptions = void 0;
        return;
      }
      this._unixOptions = void 0;
    }
    /**
        Cookie support. You don't have to care about parsing or how to store them.
    
        __Note__: If you provide this option, `options.headers.cookie` will be overridden.
        */
    get cookieJar() {
      return this._internals.cookieJar;
    }
    set cookieJar(e) {
      if (ee.any([U.object, U.undefined], e), e === void 0) {
        this._internals.cookieJar = void 0;
        return;
      }
      let { setCookie: t, getCookieString: r } = e;
      ee.function_(t), ee.function_(r), t.length === 4 && r.length === 0 ? (t = (0, qv.promisify)(t.bind(e)), r = (0, qv.promisify)(r.bind(e)),
      this._internals.cookieJar = {
        setCookie: t,
        getCookieString: r
      }) : this._internals.cookieJar = e;
    }
    /**
        You can abort the `request` using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).
    
        *Requires Node.js 16 or later.*
    
        @example
        ```
        import got from 'got';
    
        const abortController = new AbortController();
    
        const request = got('https://httpbin.org/anything', {
            signal: abortController.signal
        });
    
        setTimeout(() => {
            abortController.abort();
        }, 100);
        ```
        */
    // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
    get signal() {
      return this._internals.signal;
    }
    // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
    set signal(e) {
      ee.object(e), this._internals.signal = e;
    }
    /**
        Ignore invalid cookies instead of throwing an error.
        Only useful when the `cookieJar` option has been set. Not recommended.
    
        @default false
        */
    get ignoreInvalidCookies() {
      return this._internals.ignoreInvalidCookies;
    }
    set ignoreInvalidCookies(e) {
      ee.boolean(e), this._internals.ignoreInvalidCookies = e;
    }
    /**
        Query string that will be added to the request URL.
        This will override the query string in `url`.
    
        If you need to pass in an array, you can do it using a `URLSearchParams` instance.
    
        @example
        ```
        import got from 'got';
    
        const searchParams = new URLSearchParams([['key', 'a'], ['key', 'b']]);
    
        await got('https://example.com', {searchParams});
    
        console.log(searchParams.toString());
        //=> 'key=a&key=b'
        ```
        */
    get searchParams() {
      return this._internals.url ? this._internals.url.searchParams : (this._internals.searchParams === void 0 && (this._internals.searchParams =
      new _o.URLSearchParams()), this._internals.searchParams);
    }
    set searchParams(e) {
      ee.any([U.string, U.object, U.undefined], e);
      let t = this._internals.url;
      if (e === void 0) {
        this._internals.searchParams = void 0, t && (t.search = "");
        return;
      }
      let r = this.searchParams, i;
      if (U.string(e))
        i = new _o.URLSearchParams(e);
      else if (e instanceof _o.URLSearchParams)
        i = e;
      else {
        Lue(e), i = new _o.URLSearchParams();
        for (let s in e) {
          let a = e[s];
          a === null ? i.append(s, "") : a === void 0 ? r.delete(s) : i.append(s, a);
        }
      }
      if (this._merging) {
        for (let s of i.keys())
          r.delete(s);
        for (let [s, a] of i)
          r.append(s, a);
      } else t ? t.search = r.toString() : this._internals.searchParams = r;
    }
    get searchParameters() {
      throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
    }
    set searchParameters(e) {
      throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
    }
    get dnsLookup() {
      return this._internals.dnsLookup;
    }
    set dnsLookup(e) {
      ee.any([U.function_, U.undefined], e), this._internals.dnsLookup = e;
    }
    /**
        An instance of [`CacheableLookup`](https://github.com/szmarczak/cacheable-lookup) used for making DNS lookups.
        Useful when making lots of requests to different *public* hostnames.
    
        `CacheableLookup` uses `dns.resolver4(..)` and `dns.resolver6(...)` under the hood and fall backs to `dns.lookup(...)` when the first two fail, which may lead to additional delay.
    
        __Note__: This should stay disabled when making requests to internal hostnames such as `localhost`, `database.local` etc.
    
        @default false
        */
    get dnsCache() {
      return this._internals.dnsCache;
    }
    set dnsCache(e) {
      ee.any([U.object, U.boolean, U.undefined], e), e === !0 ? this._internals.dnsCache = que() : e === !1 ? this._internals.dnsCache = void 0 :
      this._internals.dnsCache = e;
    }
    /**
        User data. `context` is shallow merged and enumerable. If it contains non-enumerable properties they will NOT be merged.
    
        @example
        ```
        import got from 'got';
    
        const instance = got.extend({
            hooks: {
                beforeRequest: [
                    options => {
                        if (!options.context || !options.context.token) {
                            throw new Error('Token required');
                        }
    
                        options.headers.token = options.context.token;
                    }
                ]
            }
        });
    
        const context = {
            token: 'secret'
        };
    
        const response = await instance('https://httpbin.org/headers', {context});
    
        // Let's see the headers
        console.log(response.body);
        ```
        */
    get context() {
      return this._internals.context;
    }
    set context(e) {
      ee.object(e), this._merging ? Object.assign(this._internals.context, e) : this._internals.context = { ...e };
    }
    /**
    Hooks allow modifications during the request lifecycle.
    Hook functions may be async and are run serially.
    */
    get hooks() {
      return this._internals.hooks;
    }
    set hooks(e) {
      ee.object(e);
      for (let t in e) {
        if (!(t in this._internals.hooks))
          throw new Error(`Unexpected hook event: ${t}`);
        let r = t, i = e[r];
        if (ee.any([U.array, U.undefined], i), i)
          for (let s of i)
            ee.function_(s);
        if (this._merging)
          i && this._internals.hooks[r].push(...i);
        else {
          if (!i)
            throw new Error(`Missing hook event: ${t}`);
          this._internals.hooks[t] = [...i];
        }
      }
    }
    /**
        Defines if redirect responses should be followed automatically.
    
        Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
        This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.
    
        @default true
        */
    get followRedirect() {
      return this._internals.followRedirect;
    }
    set followRedirect(e) {
      ee.boolean(e), this._internals.followRedirect = e;
    }
    get followRedirects() {
      throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
    }
    set followRedirects(e) {
      throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
    }
    /**
        If exceeded, the request will be aborted and a `MaxRedirectsError` will be thrown.
    
        @default 10
        */
    get maxRedirects() {
      return this._internals.maxRedirects;
    }
    set maxRedirects(e) {
      ee.number(e), this._internals.maxRedirects = e;
    }
    /**
        A cache adapter instance for storing cached response data.
    
        @default false
        */
    get cache() {
      return this._internals.cache;
    }
    set cache(e) {
      ee.any([U.object, U.string, U.boolean, U.undefined], e), e === !0 ? this._internals.cache = jue : e === !1 ? this._internals.cache = void 0 :
      this._internals.cache = e;
    }
    /**
        Determines if a `got.HTTPError` is thrown for unsuccessful responses.
    
        If this is disabled, requests that encounter an error status code will be resolved with the `response` instead of throwing.
        This may be useful if you are checking for resource availability and are expecting error responses.
    
        @default true
        */
    get throwHttpErrors() {
      return this._internals.throwHttpErrors;
    }
    set throwHttpErrors(e) {
      ee.boolean(e), this._internals.throwHttpErrors = e;
    }
    get username() {
      let e = this._internals.url, t = e ? e.username : this._internals.username;
      return decodeURIComponent(t);
    }
    set username(e) {
      ee.string(e);
      let t = this._internals.url, r = encodeURIComponent(e);
      t ? t.username = r : this._internals.username = r;
    }
    get password() {
      let e = this._internals.url, t = e ? e.password : this._internals.password;
      return decodeURIComponent(t);
    }
    set password(e) {
      ee.string(e);
      let t = this._internals.url, r = encodeURIComponent(e);
      t ? t.password = r : this._internals.password = r;
    }
    /**
        If set to `true`, Got will additionally accept HTTP2 requests.
    
        It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.
    
        __Note__: This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy.
    
        __Note__: Overriding `options.request` will disable HTTP2 support.
    
        @default false
    
        @example
        ```
        import got from 'got';
    
        const {headers} = await got('https://nghttp2.org/httpbin/anything', {http2: true});
    
        console.log(headers.via);
        //=> '2 nghttpx'
        ```
        */
    get http2() {
      return this._internals.http2;
    }
    set http2(e) {
      ee.boolean(e), this._internals.http2 = e;
    }
    /**
        Set this to `true` to allow sending body for the `GET` method.
        However, the [HTTP/2 specification](https://tools.ietf.org/html/rfc7540#section-8.1.3) says that `An HTTP GET request includes request header fields and no payload body`, therefore when using the HTTP/2 protocol this option will have no effect.
        This option is only meant to interact with non-compliant servers when you have no other choice.
    
        __Note__: The [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) doesn't specify any particular behavior for the GET method having a payload, therefore __it's considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern)__.
    
        @default false
        */
    get allowGetBody() {
      return this._internals.allowGetBody;
    }
    set allowGetBody(e) {
      ee.boolean(e), this._internals.allowGetBody = e;
    }
    /**
        Request headers.
    
        Existing headers will be overwritten. Headers set to `undefined` will be omitted.
    
        @default {}
        */
    get headers() {
      return this._internals.headers;
    }
    set headers(e) {
      ee.plainObject(e), this._merging ? Object.assign(this._internals.headers, Wv(e)) : this._internals.headers = Wv(e);
    }
    /**
        Specifies if the HTTP request method should be [rewritten as `GET`](https://tools.ietf.org/html/rfc7231#section-6.4) on redirects.
    
        As the [specification](https://tools.ietf.org/html/rfc7231#section-6.4) prefers to rewrite the HTTP method only on `303` responses, this is Got's default behavior.
        Setting `methodRewriting` to `true` will also rewrite `301` and `302` responses, as allowed by the spec. This is the behavior followed by `curl` and browsers.
    
        __Note__: Got never performs method rewriting on `307` and `308` responses, as this is [explicitly prohibited by the specification](https://www.rfc-editor.org/rfc/rfc7231#section-6.4.7).
    
        @default false
        */
    get methodRewriting() {
      return this._internals.methodRewriting;
    }
    set methodRewriting(e) {
      ee.boolean(e), this._internals.methodRewriting = e;
    }
    /**
        Indicates which DNS record family to use.
    
        Values:
        - `undefined`: IPv4 (if present) or IPv6
        - `4`: Only IPv4
        - `6`: Only IPv6
    
        @default undefined
        */
    get dnsLookupIpVersion() {
      return this._internals.dnsLookupIpVersion;
    }
    set dnsLookupIpVersion(e) {
      if (e !== void 0 && e !== 4 && e !== 6)
        throw new TypeError(`Invalid DNS lookup IP version: ${e}`);
      this._internals.dnsLookupIpVersion = e;
    }
    /**
        A function used to parse JSON responses.
    
        @example
        ```
        import got from 'got';
        import Bourne from '@hapi/bourne';
    
        const parsed = await got('https://example.com', {
            parseJson: text => Bourne.parse(text)
        }).json();
    
        console.log(parsed);
        ```
        */
    get parseJson() {
      return this._internals.parseJson;
    }
    set parseJson(e) {
      ee.function_(e), this._internals.parseJson = e;
    }
    /**
        A function used to stringify the body of JSON requests.
    
        @example
        ```
        import got from 'got';
    
        await got.post('https://example.com', {
            stringifyJson: object => JSON.stringify(object, (key, value) => {
                if (key.startsWith('_')) {
                    return;
                }
    
                return value;
            }),
            json: {
                some: 'payload',
                _ignoreMe: 1234
            }
        });
        ```
    
        @example
        ```
        import got from 'got';
    
        await got.post('https://example.com', {
            stringifyJson: object => JSON.stringify(object, (key, value) => {
                if (typeof value === 'number') {
                    return value.toString();
                }
    
                return value;
            }),
            json: {
                some: 'payload',
                number: 1
            }
        });
        ```
        */
    get stringifyJson() {
      return this._internals.stringifyJson;
    }
    set stringifyJson(e) {
      ee.function_(e), this._internals.stringifyJson = e;
    }
    /**
        An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.
    
        Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).
    
        The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
        The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).
    
        By default, it retries *only* on the specified methods, status codes, and on these network errors:
    
        - `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
        - `ECONNRESET`: Connection was forcibly closed by a peer.
        - `EADDRINUSE`: Could not bind to any free port.
        - `ECONNREFUSED`: Connection was refused by the server.
        - `EPIPE`: The remote side of the stream being written has been closed.
        - `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
        - `ENETUNREACH`: No internet connection.
        - `EAI_AGAIN`: DNS lookup timed out.
    
        __Note__: If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
        __Note__: If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
        */
    get retry() {
      return this._internals.retry;
    }
    set retry(e) {
      if (ee.plainObject(e), ee.any([U.function_, U.undefined], e.calculateDelay), ee.any([U.number, U.undefined], e.maxRetryAfter), ee.any(
      [U.number, U.undefined], e.limit), ee.any([U.array, U.undefined], e.methods), ee.any([U.array, U.undefined], e.statusCodes), ee.any([U.
      array, U.undefined], e.errorCodes), ee.any([U.number, U.undefined], e.noise), e.noise && Math.abs(e.noise) > 100)
        throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${e.noise}`);
      for (let r in e)
        if (!(r in this._internals.retry))
          throw new Error(`Unexpected retry option: ${r}`);
      this._merging ? Object.assign(this._internals.retry, e) : this._internals.retry = { ...e };
      let { retry: t } = this._internals;
      t.methods = [...new Set(t.methods.map((r) => r.toUpperCase()))], t.statusCodes = [...new Set(t.statusCodes)], t.errorCodes = [...new Set(
      t.errorCodes)];
    }
    /**
        From `http.RequestOptions`.
    
        The IP address used to send the request from.
        */
    get localAddress() {
      return this._internals.localAddress;
    }
    set localAddress(e) {
      ee.any([U.string, U.undefined], e), this._internals.localAddress = e;
    }
    /**
        The HTTP method used to make the request.
    
        @default 'GET'
        */
    get method() {
      return this._internals.method;
    }
    set method(e) {
      ee.string(e), this._internals.method = e.toUpperCase();
    }
    get createConnection() {
      return this._internals.createConnection;
    }
    set createConnection(e) {
      ee.any([U.function_, U.undefined], e), this._internals.createConnection = e;
    }
    /**
        From `http-cache-semantics`
    
        @default {}
        */
    get cacheOptions() {
      return this._internals.cacheOptions;
    }
    set cacheOptions(e) {
      ee.plainObject(e), ee.any([U.boolean, U.undefined], e.shared), ee.any([U.number, U.undefined], e.cacheHeuristic), ee.any([U.number, U.
      undefined], e.immutableMinTimeToLive), ee.any([U.boolean, U.undefined], e.ignoreCargoCult);
      for (let t in e)
        if (!(t in this._internals.cacheOptions))
          throw new Error(`Cache option \`${t}\` does not exist`);
      this._merging ? Object.assign(this._internals.cacheOptions, e) : this._internals.cacheOptions = { ...e };
    }
    /**
    Options for the advanced HTTPS API.
    */
    get https() {
      return this._internals.https;
    }
    set https(e) {
      ee.plainObject(e), ee.any([U.boolean, U.undefined], e.rejectUnauthorized), ee.any([U.function_, U.undefined], e.checkServerIdentity), ee.
      any([U.string, U.object, U.array, U.undefined], e.certificateAuthority), ee.any([U.string, U.object, U.array, U.undefined], e.key), ee.
      any([U.string, U.object, U.array, U.undefined], e.certificate), ee.any([U.string, U.undefined], e.passphrase), ee.any([U.string, U.buffer,
      U.array, U.undefined], e.pfx), ee.any([U.array, U.undefined], e.alpnProtocols), ee.any([U.string, U.undefined], e.ciphers), ee.any([U.
      string, U.buffer, U.undefined], e.dhparam), ee.any([U.string, U.undefined], e.signatureAlgorithms), ee.any([U.string, U.undefined], e.
      minVersion), ee.any([U.string, U.undefined], e.maxVersion), ee.any([U.boolean, U.undefined], e.honorCipherOrder), ee.any([U.number, U.
      undefined], e.tlsSessionLifetime), ee.any([U.string, U.undefined], e.ecdhCurve), ee.any([U.string, U.buffer, U.array, U.undefined], e.
      certificateRevocationLists);
      for (let t in e)
        if (!(t in this._internals.https))
          throw new Error(`HTTPS option \`${t}\` does not exist`);
      this._merging ? Object.assign(this._internals.https, e) : this._internals.https = { ...e };
    }
    /**
        [Encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) to be used on `setEncoding` of the response data.
    
        To get a [`Buffer`](https://nodejs.org/api/buffer.html), you need to set `responseType` to `buffer` instead.
        Don't set this option to `null`.
    
        __Note__: This doesn't affect streams! Instead, you need to do `got.stream(...).setEncoding(encoding)`.
    
        @default 'utf-8'
        */
    get encoding() {
      return this._internals.encoding;
    }
    set encoding(e) {
      if (e === null)
        throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
      ee.any([U.string, U.undefined], e), this._internals.encoding = e;
    }
    /**
        When set to `true` the promise will return the Response body instead of the Response object.
    
        @default false
        */
    get resolveBodyOnly() {
      return this._internals.resolveBodyOnly;
    }
    set resolveBodyOnly(e) {
      ee.boolean(e), this._internals.resolveBodyOnly = e;
    }
    /**
        Returns a `Stream` instead of a `Promise`.
        This is equivalent to calling `got.stream(url, options?)`.
    
        @default false
        */
    get isStream() {
      return this._internals.isStream;
    }
    set isStream(e) {
      ee.boolean(e), this._internals.isStream = e;
    }
    /**
        The parsing method.
    
        The promise also has `.text()`, `.json()` and `.buffer()` methods which return another Got promise for the parsed body.
    
        It's like setting the options to `{responseType: 'json', resolveBodyOnly: true}` but without affecting the main Got promise.
    
        __Note__: When using streams, this option is ignored.
    
        @example
        ```
        const responsePromise = got(url);
        const bufferPromise = responsePromise.buffer();
        const jsonPromise = responsePromise.json();
    
        const [response, buffer, json] = Promise.all([responsePromise, bufferPromise, jsonPromise]);
        // `response` is an instance of Got Response
        // `buffer` is an instance of Buffer
        // `json` is an object
        ```
    
        @example
        ```
        // This
        const body = await got(url).json();
    
        // is semantically the same as this
        const body = await got(url, {responseType: 'json', resolveBodyOnly: true});
        ```
        */
    get responseType() {
      return this._internals.responseType;
    }
    set responseType(e) {
      if (e === void 0) {
        this._internals.responseType = "text";
        return;
      }
      if (e !== "text" && e !== "buffer" && e !== "json")
        throw new Error(`Invalid \`responseType\` option: ${e}`);
      this._internals.responseType = e;
    }
    get pagination() {
      return this._internals.pagination;
    }
    set pagination(e) {
      ee.object(e), this._merging ? Object.assign(this._internals.pagination, e) : this._internals.pagination = e;
    }
    get auth() {
      throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
    }
    set auth(e) {
      throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
    }
    get setHost() {
      return this._internals.setHost;
    }
    set setHost(e) {
      ee.boolean(e), this._internals.setHost = e;
    }
    get maxHeaderSize() {
      return this._internals.maxHeaderSize;
    }
    set maxHeaderSize(e) {
      ee.any([U.number, U.undefined], e), this._internals.maxHeaderSize = e;
    }
    get enableUnixSockets() {
      return this._internals.enableUnixSockets;
    }
    set enableUnixSockets(e) {
      ee.boolean(e), this._internals.enableUnixSockets = e;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    toJSON() {
      return { ...this._internals };
    }
    [Symbol.for("nodejs.util.inspect.custom")](e, t) {
      return (0, qv.inspect)(this._internals, t);
    }
    createNativeRequestOptions() {
      var e;
      let t = this._internals, r = t.url, i;
      r.protocol === "https:" ? i = t.http2 ? t.agent : t.agent.https : i = t.agent.http;
      let { https: s } = t, { pfx: a } = s;
      return U.array(a) && U.plainObject(a[0]) && (a = a.map((o) => ({
        buf: o.buffer,
        passphrase: o.passphrase
      }))), {
        ...t.cacheOptions,
        ...this._unixOptions,
        // HTTPS options
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ALPNProtocols: s.alpnProtocols,
        ca: s.certificateAuthority,
        cert: s.certificate,
        key: s.key,
        passphrase: s.passphrase,
        pfx: s.pfx,
        rejectUnauthorized: s.rejectUnauthorized,
        checkServerIdentity: s.checkServerIdentity ?? Tue.checkServerIdentity,
        ciphers: s.ciphers,
        honorCipherOrder: s.honorCipherOrder,
        minVersion: s.minVersion,
        maxVersion: s.maxVersion,
        sigalgs: s.signatureAlgorithms,
        sessionTimeout: s.tlsSessionLifetime,
        dhparam: s.dhparam,
        ecdhCurve: s.ecdhCurve,
        crl: s.certificateRevocationLists,
        // HTTP options
        lookup: t.dnsLookup ?? ((e = t.dnsCache) == null ? void 0 : e.lookup),
        family: t.dnsLookupIpVersion,
        agent: i,
        setHost: t.setHost,
        method: t.method,
        maxHeaderSize: t.maxHeaderSize,
        localAddress: t.localAddress,
        headers: t.headers,
        createConnection: t.createConnection,
        timeout: t.http2 ? Wue(t) : void 0,
        // HTTP/2 options
        h2session: t.h2session
      };
    }
    getRequestFunction() {
      let e = this._internals.url, { request: t } = this._internals;
      return !t && e ? this.getFallbackRequestFunction() : t;
    }
    getFallbackRequestFunction() {
      let e = this._internals.url;
      if (e) {
        if (e.protocol === "https:") {
          if (this._internals.http2) {
            if (zO < 15 || zO === 15 && Rue < 10) {
              let t = new Error("To use the `http2` option, install Node.js 15.10.0 or above");
              throw t.code = "EUNSUPPORTED", t;
            }
            return Nue.default.auto;
          }
          return wue.default.request;
        }
        return Cue.default.request;
      }
    }
    freeze() {
      let e = this._internals;
      Object.freeze(e), Object.freeze(e.hooks), Object.freeze(e.hooks.afterResponse), Object.freeze(e.hooks.beforeError), Object.freeze(e.hooks.
      beforeRedirect), Object.freeze(e.hooks.beforeRequest), Object.freeze(e.hooks.beforeRetry), Object.freeze(e.hooks.init), Object.freeze(
      e.https), Object.freeze(e.cacheOptions), Object.freeze(e.agent), Object.freeze(e.headers), Object.freeze(e.timeout), Object.freeze(e.retry),
      Object.freeze(e.retry.errorCodes), Object.freeze(e.retry.methods), Object.freeze(e.retry.statusCodes);
    }
  }, im = /* @__PURE__ */ n((e) => {
    let { statusCode: t } = e, r = e.request.options.followRedirect ? 299 : 399;
    return t >= 200 && t <= r || t === 304;
  }, "isResponseOk"), XO = class extends pr {
    static {
      n(this, "ParseError");
    }
    constructor(e, t) {
      let { options: r } = t.request;
      super(`${e.message} in "${r.url.toString()}"`, e, t.request), this.name = "ParseError", this.code = "ERR_BODY_PARSE_FAILURE";
    }
  }, YO = /* @__PURE__ */ n((e, t, r, i) => {
    let { rawBody: s } = e;
    try {
      if (t === "text")
        return s.toString(i);
      if (t === "json")
        return s.length === 0 ? "" : r(s.toString(i));
      if (t === "buffer")
        return s;
    } catch (a) {
      throw new XO(a, e);
    }
    throw new XO({
      message: `Unknown body type '${t}'`,
      name: "Error"
    }, e);
  }, "parseBody");
  function Hue(e) {
    return e.writable && !e.writableEnded;
  }
  n(Hue, "isClientRequest");
  var Kue = Hue;
  function GO(e) {
    return e.protocol === "unix:" || e.hostname === "unix";
  }
  n(GO, "isUnixSocketURL");
  var zue = U.string(gk.default.versions.brotli), Jue = /* @__PURE__ */ new Set(["GET", "HEAD"]), Vv = new vue(), Xue = /* @__PURE__ */ new Set(
  [300, 301, 302, 303, 304, 307, 308]), Yue = [
    "socket",
    "connect",
    "continue",
    "information",
    "upgrade"
  ], tm = /* @__PURE__ */ n(() => {
  }, "noop2"), Jv = class extends Ooe.Duplex {
    static {
      n(this, "Request");
    }
    constructor(e, t, r) {
      super({
        // Don't destroy immediately, as the error may be emitted on unsuccessful retry
        autoDestroy: !1,
        // It needs to be zero because we're just proxying the data to another stream
        highWaterMark: 0
      }), Object.defineProperty(this, "constructor", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_noPipe", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "options", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "response", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "requestUrl", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "redirectUrls", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "retryCount", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_stopRetry", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_downloadedSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_uploadedSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_stopReading", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_pipedServerResponses", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_request", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_responseSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_bodySize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_unproxyEvents", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_isFromCache", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_cannotHaveBody", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_triggerRead", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_cancelTimeouts", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_removeListeners", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_nativeResponse", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_flushed", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_aborted", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_requestInitialized", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this._downloadedSize = 0, this._uploadedSize = 0, this._stopReading = !1, this._pipedServerResponses = /* @__PURE__ */ new Set(), this.
      _cannotHaveBody = !1, this._unproxyEvents = tm, this._triggerRead = !1, this._cancelTimeouts = tm, this._removeListeners = tm, this._jobs =
      [], this._flushed = !1, this._requestInitialized = !1, this._aborted = !1, this.redirectUrls = [], this.retryCount = 0, this._stopRetry =
      tm, this.on("pipe", (s) => {
        s.headers && Object.assign(this.options.headers, s.headers);
      }), this.on("newListener", (s) => {
        if (s === "retry" && this.listenerCount("retry") > 0)
          throw new Error("A retry listener has been attached already.");
      });
      try {
        if (this.options = new kn(e, t, r), !this.options.url) {
          if (this.options.prefixUrl === "")
            throw new TypeError("Missing `url` property");
          this.options.url = "";
        }
        this.requestUrl = this.options.url;
      } catch (s) {
        let { options: a } = s;
        a && (this.options = a), this.flush = async () => {
          this.flush = async () => {
          }, this.destroy(s);
        };
        return;
      }
      let { body: i } = this.options;
      if (U.nodeStream(i) && i.once("error", (s) => {
        this._flushed ? this._beforeError(new FO(s, this)) : this.flush = async () => {
          this.flush = async () => {
          }, this._beforeError(new FO(s, this));
        };
      }), this.options.signal) {
        let s = /* @__PURE__ */ n(() => {
          this.destroy(new Ioe(this));
        }, "abort");
        this.options.signal.aborted ? s() : (this.options.signal.addEventListener("abort", s), this._removeListeners = () => {
          this.options.signal.removeEventListener("abort", s);
        });
      }
    }
    async flush() {
      var e;
      if (!this._flushed) {
        this._flushed = !0;
        try {
          if (await this._finalizeBody(), this.destroyed)
            return;
          if (await this._makeRequest(), this.destroyed) {
            (e = this._request) == null || e.destroy();
            return;
          }
          for (let t of this._jobs)
            t();
          this._jobs.length = 0, this._requestInitialized = !0;
        } catch (t) {
          this._beforeError(t);
        }
      }
    }
    _beforeError(e) {
      if (this._stopReading)
        return;
      let { response: t, options: r } = this, i = this.retryCount + (e.name === "RetryError" ? 0 : 1);
      this._stopReading = !0, e instanceof pr || (e = new pr(e.message, e, this));
      let s = e;
      (async () => {
        var a, o;
        if (t?.readable && !t.rawBody && !((o = (a = this._request) == null ? void 0 : a.socket) != null && o.destroyed) && (t.setEncoding(this.
        readableEncoding), await this._setRawBody(t) && (t.body = t.rawBody.toString())), this.listenerCount("retry") !== 0) {
          let u;
          try {
            let l;
            t && "retry-after" in t.headers && (l = Number(t.headers["retry-after"]), Number.isNaN(l) ? (l = Date.parse(t.headers["retry-aft\
er"]) - Date.now(), l <= 0 && (l = 1)) : l *= 1e3);
            let c = r.retry;
            u = await c.calculateDelay({
              attemptCount: i,
              retryOptions: c,
              error: s,
              retryAfter: l,
              computedValue: Eue({
                attemptCount: i,
                retryOptions: c,
                error: s,
                retryAfter: l,
                computedValue: c.maxRetryAfter ?? r.timeout.request ?? Number.POSITIVE_INFINITY
              })
            });
          } catch (l) {
            this._error(new pr(l.message, l, this));
            return;
          }
          if (u) {
            if (await new Promise((l) => {
              let c = setTimeout(l, u);
              this._stopRetry = () => {
                clearTimeout(c), l();
              };
            }), this.destroyed)
              return;
            try {
              for (let l of this.options.hooks.beforeRetry)
                await l(s, this.retryCount + 1);
            } catch (l) {
              this._error(new pr(l.message, e, this));
              return;
            }
            if (this.destroyed)
              return;
            this.destroy(), this.emit("retry", this.retryCount + 1, e, (l) => {
              let c = new Jv(r.url, l, r);
              return c.retryCount = this.retryCount + 1, gk.default.nextTick(() => {
                c.flush();
              }), c;
            });
            return;
          }
        }
        this._error(s);
      })();
    }
    _read() {
      this._triggerRead = !0;
      let { response: e } = this;
      if (e && !this._stopReading) {
        e.readableLength && (this._triggerRead = !1);
        let t;
        for (; (t = e.read()) !== null; ) {
          this._downloadedSize += t.length;
          let r = this.downloadProgress;
          r.percent < 1 && this.emit("downloadProgress", r), this.push(t);
        }
      }
    }
    _write(e, t, r) {
      let i = /* @__PURE__ */ n(() => {
        this._writeRequest(e, t, r);
      }, "write");
      this._requestInitialized ? i() : this._jobs.push(i);
    }
    _final(e) {
      let t = /* @__PURE__ */ n(() => {
        if (!this._request || this._request.destroyed) {
          e();
          return;
        }
        this._request.end((r) => {
          var i;
          (i = this._request._writableState) != null && i.errored || (r || (this._bodySize = this._uploadedSize, this.emit("uploadProgress",
          this.uploadProgress), this._request.emit("upload-complete")), e(r));
        });
      }, "endRequest");
      this._requestInitialized ? t() : this._jobs.push(t);
    }
    _destroy(e, t) {
      if (this._stopReading = !0, this.flush = async () => {
      }, this._stopRetry(), this._cancelTimeouts(), this._removeListeners(), this.options) {
        let { body: r } = this.options;
        U.nodeStream(r) && r.destroy();
      }
      this._request && this._request.destroy(), e !== null && !U.undefined(e) && !(e instanceof pr) && (e = new pr(e.message, e, this)), t(e);
    }
    pipe(e, t) {
      return e instanceof Nv.ServerResponse && this._pipedServerResponses.add(e), super.pipe(e, t);
    }
    unpipe(e) {
      return e instanceof Nv.ServerResponse && this._pipedServerResponses.delete(e), super.unpipe(e), this;
    }
    async _finalizeBody() {
      let { options: e } = this, { headers: t } = e, r = !U.undefined(e.form), i = !U.undefined(e.json), s = !U.undefined(e.body), a = Jue.has(
      e.method) && !(e.method === "GET" && e.allowGetBody);
      if (this._cannotHaveBody = a, r || i || s) {
        if (a)
          throw new TypeError(`The \`${e.method}\` method cannot be used with a body`);
        let o = !U.string(t["content-type"]);
        if (s) {
          if (zv(e.body)) {
            let l = new fue(e.body);
            o && (t["content-type"] = l.headers["Content-Type"]), "Content-Length" in l.headers && (t["content-length"] = l.headers["Content\
-Length"]), e.body = l.encode();
          }
          Dk(e.body) && o && (t["content-type"] = `multipart/form-data; boundary=${e.body.getBoundary()}`);
        } else if (r) {
          o && (t["content-type"] = "application/x-www-form-urlencoded");
          let { form: l } = e;
          e.form = void 0, e.body = new OO.URLSearchParams(l).toString();
        } else {
          o && (t["content-type"] = "application/json");
          let { json: l } = e;
          e.json = void 0, e.body = e.stringifyJson(l);
        }
        let u = await hue(e.body, e.headers);
        U.undefined(t["content-length"]) && U.undefined(t["transfer-encoding"]) && !a && !U.undefined(u) && (t["content-length"] = String(u));
      }
      e.responseType === "json" && !("accept" in e.headers) && (e.headers.accept = "application/json"), this._bodySize = Number(t["content-l\
ength"]) || void 0;
    }
    async _onResponseBase(e) {
      if (this.isAborted)
        return;
      let { options: t } = this, { url: r } = t;
      this._nativeResponse = e, t.decompress && (e = (0, rue.default)(e));
      let i = e.statusCode, s = e;
      s.statusMessage = s.statusMessage ? s.statusMessage : Nv.default.STATUS_CODES[i], s.url = t.url.toString(), s.requestUrl = this.requestUrl,
      s.redirectUrls = this.redirectUrls, s.request = this, s.isFromCache = this._nativeResponse.fromCache ?? !1, s.ip = this.ip, s.retryCount =
      this.retryCount, s.ok = im(s), this._isFromCache = s.isFromCache, this._responseSize = Number(e.headers["content-length"]) || void 0, this.
      response = s, e.once("end", () => {
        this._responseSize = this._downloadedSize, this.emit("downloadProgress", this.downloadProgress);
      }), e.once("error", (o) => {
        this._aborted = !0, e.destroy(), this._beforeError(new IO(o, this));
      }), e.once("aborted", () => {
        this._aborted = !0, this._beforeError(new IO({
          name: "Error",
          message: "The server aborted pending request",
          code: "ECONNRESET"
        }, this));
      }), this.emit("downloadProgress", this.downloadProgress);
      let a = e.headers["set-cookie"];
      if (U.object(t.cookieJar) && a) {
        let o = a.map(async (u) => t.cookieJar.setCookie(u, r.toString()));
        t.ignoreInvalidCookies && (o = o.map(async (u) => {
          try {
            await u;
          } catch {
          }
        }));
        try {
          await Promise.all(o);
        } catch (u) {
          this._beforeError(u);
          return;
        }
      }
      if (!this.isAborted) {
        if (t.followRedirect && e.headers.location && Xue.has(i)) {
          if (e.resume(), this._cancelTimeouts(), this._unproxyEvents(), this.redirectUrls.length >= t.maxRedirects) {
            this._beforeError(new Aoe(this));
            return;
          }
          this._request = void 0;
          let o = new kn(void 0, void 0, this.options), u = i === 303 && o.method !== "GET" && o.method !== "HEAD", l = i !== 307 && i !== 308,
          c = o.methodRewriting && l;
          (u || c) && (o.method = "GET", o.body = void 0, o.json = void 0, o.form = void 0, delete o.headers["content-length"]);
          try {
            let f = Bv.Buffer.from(e.headers.location, "binary").toString(), m = new OO.URL(f, r);
            if (!GO(r) && GO(m)) {
              this._beforeError(new pr("Cannot redirect to UNIX socket", {}, this));
              return;
            }
            m.hostname !== r.hostname || m.port !== r.port ? ("host" in o.headers && delete o.headers.host, "cookie" in o.headers && delete o.
            headers.cookie, "authorization" in o.headers && delete o.headers.authorization, (o.username || o.password) && (o.username = "", o.
            password = "")) : (m.username = o.username, m.password = o.password), this.redirectUrls.push(m), o.prefixUrl = "", o.url = m;
            for (let h of o.hooks.beforeRedirect)
              await h(o, s);
            this.emit("redirect", o, s), this.options = o, await this._makeRequest();
          } catch (f) {
            this._beforeError(f);
            return;
          }
          return;
        }
        if (t.isStream && t.throwHttpErrors && !im(s)) {
          this._beforeError(new rm(s));
          return;
        }
        if (e.on("readable", () => {
          this._triggerRead && this._read();
        }), this.on("resume", () => {
          e.resume();
        }), this.on("pause", () => {
          e.pause();
        }), e.once("end", () => {
          this.push(null);
        }), this._noPipe) {
          await this._setRawBody() && this.emit("response", e);
          return;
        }
        this.emit("response", e);
        for (let o of this._pipedServerResponses)
          if (!o.headersSent) {
            for (let u in e.headers) {
              let l = t.decompress ? u !== "content-encoding" : !0, c = e.headers[u];
              l && o.setHeader(u, c);
            }
            o.statusCode = i;
          }
      }
    }
    async _setRawBody(e = this) {
      if (e.readableEnded)
        return !1;
      try {
        let t = await (0, iue.buffer)(e);
        if (!this.isAborted)
          return this.response.rawBody = t, !0;
      } catch {
      }
      return !1;
    }
    async _onResponse(e) {
      try {
        await this._onResponseBase(e);
      } catch (t) {
        this._beforeError(t);
      }
    }
    _onRequest(e) {
      let { options: t } = this, { timeout: r, url: i } = t;
      Roe(e), this.options.http2 && e.setTimeout(0), this._cancelTimeouts = bue(e, r, i);
      let s = t.cache ? "cacheableResponse" : "response";
      e.once(s, (a) => {
        this._onResponse(a);
      }), e.once("error", (a) => {
        this._aborted = !0, e.destroy(), a = a instanceof xk ? new Poe(a, this.timings, this) : new pr(a.message, a, this), this._beforeError(
        a);
      }), this._unproxyEvents = vk(e, this, Yue), this._request = e, this.emit("uploadProgress", this.uploadProgress), this._sendBody(), this.
      emit("request", e);
    }
    async _asyncWrite(e) {
      return new Promise((t, r) => {
        super.write(e, (i) => {
          if (i) {
            r(i);
            return;
          }
          t();
        });
      });
    }
    _sendBody() {
      let { body: e } = this.options, t = this.redirectUrls.length === 0 ? this : this._request ?? this;
      U.nodeStream(e) ? e.pipe(t) : U.generator(e) || U.asyncGenerator(e) ? (async () => {
        try {
          for await (let r of e)
            await this._asyncWrite(r);
          super.end();
        } catch (r) {
          this._beforeError(r);
        }
      })() : U.undefined(e) ? (this._cannotHaveBody || this._noPipe) && t.end() : (this._writeRequest(e, void 0, () => {
      }), t.end());
    }
    _prepareCache(e) {
      if (!Vv.has(e)) {
        let t = new tue((r, i) => {
          let s = r._request(r, i);
          return U.promise(s) && (s.once = (a, o) => {
            if (a === "error")
              (async () => {
                try {
                  await s;
                } catch (u) {
                  o(u);
                }
              })();
            else if (a === "abort")
              (async () => {
                try {
                  (await s).once("abort", o);
                } catch {
                }
              })();
            else
              throw new Error(`Unknown HTTP2 promise event: ${a}`);
            return s;
          }), s;
        }, e);
        Vv.set(e, t.request());
      }
    }
    async _createCacheableRequest(e, t) {
      return new Promise((r, i) => {
        Object.assign(t, Due(e));
        let s, a = Vv.get(t.cache)(t, async (o) => {
          if (o._readableState.autoDestroy = !1, s) {
            let u = /* @__PURE__ */ n(() => {
              o.req && (o.complete = o.req.res.complete);
            }, "fix");
            o.prependOnceListener("end", u), u(), (await s).emit("cacheableResponse", o);
          }
          r(o);
        });
        a.once("error", i), a.once("request", async (o) => {
          s = o, r(s);
        });
      });
    }
    async _makeRequest() {
      let { options: e } = this, { headers: t, username: r, password: i } = e, s = e.cookieJar;
      for (let l in t)
        if (U.undefined(t[l]))
          delete t[l];
        else if (U.null_(t[l]))
          throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${l}\` header`);
      if (e.decompress && U.undefined(t["accept-encoding"]) && (t["accept-encoding"] = zue ? "gzip, deflate, br" : "gzip, deflate"), r || i) {
        let l = Bv.Buffer.from(`${r}:${i}`).toString("base64");
        t.authorization = `Basic ${l}`;
      }
      if (s) {
        let l = await s.getCookieString(e.url.toString());
        U.nonEmptyString(l) && (t.cookie = l);
      }
      e.prefixUrl = "";
      let a;
      for (let l of e.hooks.beforeRequest) {
        let c = await l(e);
        if (!U.undefined(c)) {
          a = /* @__PURE__ */ n(() => c, "request");
          break;
        }
      }
      a || (a = e.getRequestFunction());
      let o = e.url;
      this._requestOptions = e.createNativeRequestOptions(), e.cache && (this._requestOptions._request = a, this._requestOptions.cache = e.cache,
      this._requestOptions.body = e.body, this._prepareCache(e.cache));
      let u = e.cache ? this._createCacheableRequest : a;
      try {
        let l = u(o, this._requestOptions);
        U.promise(l) && (l = await l), U.undefined(l) && (l = e.getFallbackRequestFunction()(o, this._requestOptions), U.promise(l) && (l = await l)),
        Kue(l) ? this._onRequest(l) : this.writable ? (this.once("finish", () => {
          this._onResponse(l);
        }), this._sendBody()) : this._onResponse(l);
      } catch (l) {
        throw l instanceof Zf ? new _oe(l, this) : l;
      }
    }
    async _error(e) {
      try {
        if (!(e instanceof rm && !this.options.throwHttpErrors))
          for (let t of this.options.hooks.beforeError)
            e = await t(e);
      } catch (t) {
        e = new pr(t.message, t, this);
      }
      this.destroy(e);
    }
    _writeRequest(e, t, r) {
      !this._request || this._request.destroyed || this._request.write(e, t, (i) => {
        if (!i && !this._request.destroyed) {
          this._uploadedSize += Bv.Buffer.byteLength(e, t);
          let s = this.uploadProgress;
          s.percent < 1 && this.emit("uploadProgress", s);
        }
        r(i);
      });
    }
    /**
    The remote IP address.
    */
    get ip() {
      var e;
      return (e = this.socket) == null ? void 0 : e.remoteAddress;
    }
    /**
    Indicates whether the request has been aborted or not.
    */
    get isAborted() {
      return this._aborted;
    }
    get socket() {
      var e;
      return ((e = this._request) == null ? void 0 : e.socket) ?? void 0;
    }
    /**
    Progress event for downloading (receiving a response).
    */
    get downloadProgress() {
      let e;
      return this._responseSize ? e = this._downloadedSize / this._responseSize : this._responseSize === this._downloadedSize ? e = 1 : e = 0,
      {
        percent: e,
        transferred: this._downloadedSize,
        total: this._responseSize
      };
    }
    /**
    Progress event for uploading (sending a request).
    */
    get uploadProgress() {
      let e;
      return this._bodySize ? e = this._uploadedSize / this._bodySize : this._bodySize === this._uploadedSize ? e = 1 : e = 0, {
        percent: e,
        transferred: this._uploadedSize,
        total: this._bodySize
      };
    }
    /**
        The object contains the following properties:
    
        - `start` - Time when the request started.
        - `socket` - Time when a socket was assigned to the request.
        - `lookup` - Time when the DNS lookup finished.
        - `connect` - Time when the socket successfully connected.
        - `secureConnect` - Time when the socket securely connected.
        - `upload` - Time when the request finished uploading.
        - `response` - Time when the request fired `response` event.
        - `end` - Time when the response fired `end` event.
        - `error` - Time when the request fired `error` event.
        - `abort` - Time when the request fired `abort` event.
        - `phases`
            - `wait` - `timings.socket - timings.start`
            - `dns` - `timings.lookup - timings.socket`
            - `tcp` - `timings.connect - timings.lookup`
            - `tls` - `timings.secureConnect - timings.connect`
            - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
            - `firstByte` - `timings.response - timings.upload`
            - `download` - `timings.end - timings.response`
            - `total` - `(timings.end || timings.error || timings.abort) - timings.start`
    
        If something has not been measured yet, it will be `undefined`.
    
        __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
        */
    get timings() {
      var e;
      return (e = this._request) == null ? void 0 : e.timings;
    }
    /**
    Whether the response was retrieved from the cache.
    */
    get isFromCache() {
      return this._isFromCache;
    }
    get reusedSocket() {
      var e;
      return (e = this._request) == null ? void 0 : e.reusedSocket;
    }
  }, Gue = class extends pr {
    static {
      n(this, "CancelError2");
    }
    constructor(e) {
      super("Promise was canceled", {}, e), this.name = "CancelError", this.code = "ERR_CANCELED";
    }
    /**
    Whether the promise is canceled.
    */
    get isCanceled() {
      return !0;
    }
  }, Zue = [
    "request",
    "response",
    "redirect",
    "uploadProgress",
    "downloadProgress"
  ];
  function ZO(e) {
    let t, r, i, s = new Toe.EventEmitter(), a = new Kv((u, l, c) => {
      c(() => {
        t.destroy();
      }), c.shouldReject = !1, c(() => {
        l(new Gue(t));
      });
      let f = /* @__PURE__ */ n((m) => {
        var h;
        c(() => {
        });
        let d = e ?? new Jv(void 0, void 0, i);
        d.retryCount = m, d._noPipe = !0, t = d, d.once("response", async (g) => {
          let b = (g.headers["content-encoding"] ?? "").toLowerCase(), D = b === "gzip" || b === "deflate" || b === "br", { options: x } = d;
          if (D && !x.decompress)
            g.body = g.rawBody;
          else
            try {
              g.body = YO(g, x.responseType, x.parseJson, x.encoding);
            } catch (T) {
              if (g.body = g.rawBody.toString(), im(g)) {
                d._beforeError(T);
                return;
              }
            }
          try {
            let T = x.hooks.afterResponse;
            for (let [w, B] of T.entries())
              if (g = await B(g, async (k) => {
                throw x.merge(k), x.prefixUrl = "", k.url && (x.url = k.url), x.hooks.afterResponse = x.hooks.afterResponse.slice(0, w), new Foe(
                d);
              }), !(U.object(g) && U.number(g.statusCode) && !U.nullOrUndefined(g.body)))
                throw new TypeError("The `afterResponse` hook returned an invalid value");
          } catch (T) {
            d._beforeError(T);
            return;
          }
          if (r = g, !im(g)) {
            d._beforeError(new rm(g));
            return;
          }
          d.destroy(), u(d.options.resolveBodyOnly ? g.body : g);
        });
        let y = /* @__PURE__ */ n((g) => {
          if (a.isCanceled)
            return;
          let { options: b } = d;
          if (g instanceof rm && !b.throwHttpErrors) {
            let { response: D } = g;
            d.destroy(), u(d.options.resolveBodyOnly ? D.body : D);
            return;
          }
          l(g);
        }, "onError");
        d.once("error", y);
        let p = (h = d.options) == null ? void 0 : h.body;
        d.once("retry", (g, b) => {
          e = void 0;
          let D = d.options.body;
          if (p === D && U.nodeStream(D)) {
            b.message = "Cannot retry with consumed body stream", y(b);
            return;
          }
          i = d.options, f(g);
        }), vk(d, s, Zue), U.undefined(e) && d.flush();
      }, "makeRequest");
      f(0);
    });
    a.on = (u, l) => (s.on(u, l), a), a.off = (u, l) => (s.off(u, l), a);
    let o = /* @__PURE__ */ n((u) => {
      let l = (async () => {
        await a;
        let { options: c } = r.request;
        return YO(r, u, c.parseJson, c.encoding);
      })();
      return Object.defineProperties(l, Object.getOwnPropertyDescriptors(a)), l;
    }, "shortcut");
    return a.json = () => {
      if (t.options) {
        let { headers: u } = t.options;
        !t.writableFinished && !("accept" in u) && (u.accept = "application/json");
      }
      return o("json");
    }, a.buffer = () => o("buffer"), a.text = () => o("text"), a;
  }
  n(ZO, "asPromise");
  var Que = /* @__PURE__ */ n(async (e) => new Promise((t) => {
    setTimeout(t, e);
  }), "delay"), ele = /* @__PURE__ */ n((e) => U.function_(e), "isGotInstance"), tle = [
    "get",
    "post",
    "put",
    "patch",
    "head",
    "delete"
  ], Ek = /* @__PURE__ */ n((e) => {
    e = {
      options: new kn(void 0, void 0, e.options),
      handlers: [...e.handlers],
      mutableDefaults: e.mutableDefaults
    }, Object.defineProperty(e, "mutableDefaults", {
      enumerable: !0,
      configurable: !1,
      writable: !1
    });
    let t = /* @__PURE__ */ n((i, s, a = e.options) => {
      let o = new Jv(i, s, a), u, l = /* @__PURE__ */ n((m) => (o.options = m, o._noPipe = !m.isStream, o.flush(), m.isStream ? o : (u || (u =
      ZO(o)), u)), "lastHandler"), c = 0, f = /* @__PURE__ */ n((m) => {
        let d = (e.handlers[c++] ?? l)(m, f);
        if (U.promise(d) && !o.options.isStream && (u || (u = ZO(o)), d !== u)) {
          let y = Object.getOwnPropertyDescriptors(u);
          for (let p in y)
            p in d && delete y[p];
          Object.defineProperties(d, y), d.cancel = u.cancel;
        }
        return d;
      }, "iterateHandlers");
      return f(o.options);
    }, "got2");
    t.extend = (...i) => {
      let s = new kn(void 0, void 0, e.options), a = [...e.handlers], o;
      for (let u of i)
        ele(u) ? (s.merge(u.defaults.options), a.push(...u.defaults.handlers), o = u.defaults.mutableDefaults) : (s.merge(u), u.handlers && a.
        push(...u.handlers), o = u.mutableDefaults);
      return Ek({
        options: s,
        handlers: a,
        mutableDefaults: !!o
      });
    };
    let r = /* @__PURE__ */ n(async function* (i, s) {
      let a = new kn(i, s, e.options);
      a.resolveBodyOnly = !1;
      let { pagination: o } = a;
      ee.function_(o.transform), ee.function_(o.shouldContinue), ee.function_(o.filter), ee.function_(o.paginate), ee.number(o.countLimit), ee.
      number(o.requestLimit), ee.number(o.backoff);
      let u = [], { countLimit: l } = o, c = 0;
      for (; c < o.requestLimit; ) {
        c !== 0 && await Que(o.backoff);
        let f = await t(void 0, void 0, a), m = await o.transform(f), h = [];
        ee.array(m);
        for (let y of m)
          if (o.filter({ item: y, currentItems: h, allItems: u }) && (!o.shouldContinue({ item: y, currentItems: h, allItems: u }) || (yield y,
          o.stackAllItems && u.push(y), h.push(y), --l <= 0)))
            return;
        let d = o.paginate({
          response: f,
          currentItems: h,
          allItems: u
        });
        if (d === !1)
          return;
        d === f.request.options ? a = f.request.options : (a.merge(d), ee.any([U.urlInstance, U.undefined], d.url), d.url !== void 0 && (a.prefixUrl =
        "", a.url = d.url)), c++;
      }
    }, "paginateEach");
    t.paginate = r, t.paginate.all = async (i, s) => {
      let a = [];
      for await (let o of r(i, s))
        a.push(o);
      return a;
    }, t.paginate.each = r, t.stream = (i, s) => t(i, { ...s, isStream: !0 });
    for (let i of tle)
      t[i] = (s, a) => t(s, { ...a, method: i }), t.stream[i] = (s, a) => t(s, { ...a, method: i, isStream: !0 });
    return e.mutableDefaults || (Object.freeze(e.handlers), e.options.freeze()), Object.defineProperty(t, "defaults", {
      value: e,
      writable: !1,
      configurable: !1,
      enumerable: !0
    }), t;
  }, "create"), rle = Ek, ile = {
    options: new kn(),
    handlers: [],
    mutableDefaults: !1
  }, sle = rle(ile), nle = sle, ale = ur(H2()), ole = M5(), ule = ur(PO()), QO = {
    keepAlive: !0,
    maxSockets: 20
  }, lle = {
    http: new coe.Agent(QO),
    https: new foe.Agent(QO)
  };
  async function cle({ url: e, gotOpts: t, extractOpts: r, dir: i }) {
    return new Promise((s, a) => {
      let o = /* @__PURE__ */ n((u) => {
        u ? a(u) : s();
      }, "callback");
      (0, ale.default)(
        nle.stream(e, Object.assign({ agent: lle }, t)),
        (0, ule.default)(),
        (0, ole.extract)(i, r),
        o
      );
    });
  }
  n(cle, "download");
});

// ../node_modules/get-npm-tarball-url/lib/index.js
var Ak = E((Vnt, wk) => {
  var Xv = Object.defineProperty, fle = Object.getOwnPropertyDescriptor, dle = Object.getOwnPropertyNames, ple = Object.prototype.hasOwnProperty,
  hle = /* @__PURE__ */ n((e, t) => {
    for (var r in t)
      Xv(e, r, { get: t[r], enumerable: !0 });
  }, "__export"), mle = /* @__PURE__ */ n((e, t, r, i) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let s of dle(t))
        !ple.call(e, s) && s !== r && Xv(e, s, { get: /* @__PURE__ */ n(() => t[s], "get"), enumerable: !(i = fle(t, s)) || i.enumerable });
    return e;
  }, "__copyProps"), yle = /* @__PURE__ */ n((e) => mle(Xv({}, "__esModule", { value: !0 }), e), "__toCommonJS"), Ck = {};
  hle(Ck, {
    default: /* @__PURE__ */ n(() => gle, "default")
  });
  wk.exports = yle(Ck);
  function gle(e, t, r) {
    let i;
    r?.registry ? i = r.registry.endsWith("/") ? r.registry : `${r.registry}/` : i = "https://registry.npmjs.org/";
    let s = Dle(e);
    return `${i}${e}/-/${s}-${ble(t)}.tgz`;
  }
  n(gle, "src_default");
  function ble(e) {
    let t = e.indexOf("+");
    return t === -1 ? e : e.substring(0, t);
  }
  n(ble, "removeBuildMetadataFromVersion");
  function Dle(e) {
    return e[0] !== "@" ? e : e.split("/")[1];
  }
  n(Dle, "getScopelessName");
});

// ../node_modules/eastasianwidth/eastasianwidth.js
var ox = E((pat, ax) => {
  var Ta = {};
  typeof ax > "u" ? window.eastasianwidth = Ta : ax.exports = Ta;
  Ta.eastAsianWidth = function(e) {
    var t = e.charCodeAt(0), r = e.length == 2 ? e.charCodeAt(1) : 0, i = t;
    return 55296 <= t && t <= 56319 && 56320 <= r && r <= 57343 && (t &= 1023, r &= 1023, i = t << 10 | r, i += 65536), i == 12288 || 65281 <=
    i && i <= 65376 || 65504 <= i && i <= 65510 ? "F" : i == 8361 || 65377 <= i && i <= 65470 || 65474 <= i && i <= 65479 || 65482 <= i && i <=
    65487 || 65490 <= i && i <= 65495 || 65498 <= i && i <= 65500 || 65512 <= i && i <= 65518 ? "H" : 4352 <= i && i <= 4447 || 4515 <= i &&
    i <= 4519 || 4602 <= i && i <= 4607 || 9001 <= i && i <= 9002 || 11904 <= i && i <= 11929 || 11931 <= i && i <= 12019 || 12032 <= i && i <=
    12245 || 12272 <= i && i <= 12283 || 12289 <= i && i <= 12350 || 12353 <= i && i <= 12438 || 12441 <= i && i <= 12543 || 12549 <= i && i <=
    12589 || 12593 <= i && i <= 12686 || 12688 <= i && i <= 12730 || 12736 <= i && i <= 12771 || 12784 <= i && i <= 12830 || 12832 <= i && i <=
    12871 || 12880 <= i && i <= 13054 || 13056 <= i && i <= 19903 || 19968 <= i && i <= 42124 || 42128 <= i && i <= 42182 || 43360 <= i && i <=
    43388 || 44032 <= i && i <= 55203 || 55216 <= i && i <= 55238 || 55243 <= i && i <= 55291 || 63744 <= i && i <= 64255 || 65040 <= i && i <=
    65049 || 65072 <= i && i <= 65106 || 65108 <= i && i <= 65126 || 65128 <= i && i <= 65131 || 110592 <= i && i <= 110593 || 127488 <= i &&
    i <= 127490 || 127504 <= i && i <= 127546 || 127552 <= i && i <= 127560 || 127568 <= i && i <= 127569 || 131072 <= i && i <= 194367 || 177984 <=
    i && i <= 196605 || 196608 <= i && i <= 262141 ? "W" : 32 <= i && i <= 126 || 162 <= i && i <= 163 || 165 <= i && i <= 166 || i == 172 ||
    i == 175 || 10214 <= i && i <= 10221 || 10629 <= i && i <= 10630 ? "Na" : i == 161 || i == 164 || 167 <= i && i <= 168 || i == 170 || 173 <=
    i && i <= 174 || 176 <= i && i <= 180 || 182 <= i && i <= 186 || 188 <= i && i <= 191 || i == 198 || i == 208 || 215 <= i && i <= 216 ||
    222 <= i && i <= 225 || i == 230 || 232 <= i && i <= 234 || 236 <= i && i <= 237 || i == 240 || 242 <= i && i <= 243 || 247 <= i && i <=
    250 || i == 252 || i == 254 || i == 257 || i == 273 || i == 275 || i == 283 || 294 <= i && i <= 295 || i == 299 || 305 <= i && i <= 307 ||
    i == 312 || 319 <= i && i <= 322 || i == 324 || 328 <= i && i <= 331 || i == 333 || 338 <= i && i <= 339 || 358 <= i && i <= 359 || i ==
    363 || i == 462 || i == 464 || i == 466 || i == 468 || i == 470 || i == 472 || i == 474 || i == 476 || i == 593 || i == 609 || i == 708 ||
    i == 711 || 713 <= i && i <= 715 || i == 717 || i == 720 || 728 <= i && i <= 731 || i == 733 || i == 735 || 768 <= i && i <= 879 || 913 <=
    i && i <= 929 || 931 <= i && i <= 937 || 945 <= i && i <= 961 || 963 <= i && i <= 969 || i == 1025 || 1040 <= i && i <= 1103 || i == 1105 ||
    i == 8208 || 8211 <= i && i <= 8214 || 8216 <= i && i <= 8217 || 8220 <= i && i <= 8221 || 8224 <= i && i <= 8226 || 8228 <= i && i <= 8231 ||
    i == 8240 || 8242 <= i && i <= 8243 || i == 8245 || i == 8251 || i == 8254 || i == 8308 || i == 8319 || 8321 <= i && i <= 8324 || i == 8364 ||
    i == 8451 || i == 8453 || i == 8457 || i == 8467 || i == 8470 || 8481 <= i && i <= 8482 || i == 8486 || i == 8491 || 8531 <= i && i <= 8532 ||
    8539 <= i && i <= 8542 || 8544 <= i && i <= 8555 || 8560 <= i && i <= 8569 || i == 8585 || 8592 <= i && i <= 8601 || 8632 <= i && i <= 8633 ||
    i == 8658 || i == 8660 || i == 8679 || i == 8704 || 8706 <= i && i <= 8707 || 8711 <= i && i <= 8712 || i == 8715 || i == 8719 || i == 8721 ||
    i == 8725 || i == 8730 || 8733 <= i && i <= 8736 || i == 8739 || i == 8741 || 8743 <= i && i <= 8748 || i == 8750 || 8756 <= i && i <= 8759 ||
    8764 <= i && i <= 8765 || i == 8776 || i == 8780 || i == 8786 || 8800 <= i && i <= 8801 || 8804 <= i && i <= 8807 || 8810 <= i && i <= 8811 ||
    8814 <= i && i <= 8815 || 8834 <= i && i <= 8835 || 8838 <= i && i <= 8839 || i == 8853 || i == 8857 || i == 8869 || i == 8895 || i == 8978 ||
    9312 <= i && i <= 9449 || 9451 <= i && i <= 9547 || 9552 <= i && i <= 9587 || 9600 <= i && i <= 9615 || 9618 <= i && i <= 9621 || 9632 <=
    i && i <= 9633 || 9635 <= i && i <= 9641 || 9650 <= i && i <= 9651 || 9654 <= i && i <= 9655 || 9660 <= i && i <= 9661 || 9664 <= i && i <=
    9665 || 9670 <= i && i <= 9672 || i == 9675 || 9678 <= i && i <= 9681 || 9698 <= i && i <= 9701 || i == 9711 || 9733 <= i && i <= 9734 ||
    i == 9737 || 9742 <= i && i <= 9743 || 9748 <= i && i <= 9749 || i == 9756 || i == 9758 || i == 9792 || i == 9794 || 9824 <= i && i <= 9825 ||
    9827 <= i && i <= 9829 || 9831 <= i && i <= 9834 || 9836 <= i && i <= 9837 || i == 9839 || 9886 <= i && i <= 9887 || 9918 <= i && i <= 9919 ||
    9924 <= i && i <= 9933 || 9935 <= i && i <= 9953 || i == 9955 || 9960 <= i && i <= 9983 || i == 10045 || i == 10071 || 10102 <= i && i <=
    10111 || 11093 <= i && i <= 11097 || 12872 <= i && i <= 12879 || 57344 <= i && i <= 63743 || 65024 <= i && i <= 65039 || i == 65533 || 127232 <=
    i && i <= 127242 || 127248 <= i && i <= 127277 || 127280 <= i && i <= 127337 || 127344 <= i && i <= 127386 || 917760 <= i && i <= 917999 ||
    983040 <= i && i <= 1048573 || 1048576 <= i && i <= 1114109 ? "A" : "N";
  };
  Ta.characterLength = function(e) {
    var t = this.eastAsianWidth(e);
    return t == "F" || t == "W" || t == "A" ? 2 : 1;
  };
  function Lk(e) {
    return e.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
  }
  n(Lk, "stringToArray");
  Ta.length = function(e) {
    for (var t = Lk(e), r = 0, i = 0; i < t.length; i++)
      r = r + this.characterLength(t[i]);
    return r;
  };
  Ta.slice = function(e, t, r) {
    textLen = Ta.length(e), t = t || 0, r = r || 1, t < 0 && (t = textLen + t), r < 0 && (r = textLen + r);
    for (var i = "", s = 0, a = Lk(e), o = 0; o < a.length; o++) {
      var u = a[o], l = Ta.length(u);
      if (s >= t - (l == 2 ? 1 : 0))
        if (s + l <= r)
          i += u;
        else
          break;
      s += l;
    }
    return i;
  };
});

// ../node_modules/emoji-regex/index.js
var ux = E((mat, jk) => {
  "use strict";
  jk.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// ../node_modules/cli-boxes/boxes.json
var Qk = E((Mat, uce) => {
  uce.exports = {
    single: {
      topLeft: "\u250C",
      top: "\u2500",
      topRight: "\u2510",
      right: "\u2502",
      bottomRight: "\u2518",
      bottom: "\u2500",
      bottomLeft: "\u2514",
      left: "\u2502"
    },
    double: {
      topLeft: "\u2554",
      top: "\u2550",
      topRight: "\u2557",
      right: "\u2551",
      bottomRight: "\u255D",
      bottom: "\u2550",
      bottomLeft: "\u255A",
      left: "\u2551"
    },
    round: {
      topLeft: "\u256D",
      top: "\u2500",
      topRight: "\u256E",
      right: "\u2502",
      bottomRight: "\u256F",
      bottom: "\u2500",
      bottomLeft: "\u2570",
      left: "\u2502"
    },
    bold: {
      topLeft: "\u250F",
      top: "\u2501",
      topRight: "\u2513",
      right: "\u2503",
      bottomRight: "\u251B",
      bottom: "\u2501",
      bottomLeft: "\u2517",
      left: "\u2503"
    },
    singleDouble: {
      topLeft: "\u2553",
      top: "\u2500",
      topRight: "\u2556",
      right: "\u2551",
      bottomRight: "\u255C",
      bottom: "\u2500",
      bottomLeft: "\u2559",
      left: "\u2551"
    },
    doubleSingle: {
      topLeft: "\u2552",
      top: "\u2550",
      topRight: "\u2555",
      right: "\u2502",
      bottomRight: "\u255B",
      bottom: "\u2550",
      bottomLeft: "\u2558",
      left: "\u2502"
    },
    classic: {
      topLeft: "+",
      top: "-",
      topRight: "+",
      right: "|",
      bottomRight: "+",
      bottom: "-",
      bottomLeft: "+",
      left: "|"
    },
    arrow: {
      topLeft: "\u2198",
      top: "\u2193",
      topRight: "\u2199",
      right: "\u2190",
      bottomRight: "\u2196",
      bottom: "\u2191",
      bottomLeft: "\u2197",
      left: "\u2192"
    }
  };
});

// ../node_modules/cli-boxes/index.js
var hx = E((Rat, px) => {
  "use strict";
  var eB = Qk();
  px.exports = eB;
  px.exports.default = eB;
});

// ../node_modules/string-width/node_modules/ansi-regex/index.js
var aB = E((qat, nB) => {
  "use strict";
  nB.exports = ({ onlyFirst: e = !1 } = {}) => {
    let t = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(t, e ? void 0 : "g");
  };
});

// ../node_modules/string-width/node_modules/strip-ansi/index.js
var uB = E((Uat, oB) => {
  "use strict";
  var mce = aB();
  oB.exports = (e) => typeof e == "string" ? e.replace(mce(), "") : e;
});

// ../node_modules/is-fullwidth-code-point/index.js
var cB = E(($at, gx) => {
  "use strict";
  var lB = /* @__PURE__ */ n((e) => Number.isNaN(e) ? !1 : e >= 4352 && (e <= 4447 || // Hangul Jamo
  e === 9001 || // LEFT-POINTING ANGLE BRACKET
  e === 9002 || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  11904 <= e && e <= 12871 && e !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  12880 <= e && e <= 19903 || // CJK Unified Ideographs .. Yi Radicals
  19968 <= e && e <= 42182 || // Hangul Jamo Extended-A
  43360 <= e && e <= 43388 || // Hangul Syllables
  44032 <= e && e <= 55203 || // CJK Compatibility Ideographs
  63744 <= e && e <= 64255 || // Vertical Forms
  65040 <= e && e <= 65049 || // CJK Compatibility Forms .. Small Form Variants
  65072 <= e && e <= 65131 || // Halfwidth and Fullwidth Forms
  65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || // Kana Supplement
  110592 <= e && e <= 110593 || // Enclosed Ideographic Supplement
  127488 <= e && e <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  131072 <= e && e <= 262141), "isFullwidthCodePoint");
  gx.exports = lB;
  gx.exports.default = lB;
});

// ../node_modules/string-width/node_modules/emoji-regex/index.js
var dB = E((Wat, fB) => {
  "use strict";
  fB.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// ../node_modules/string-width/index.js
var hB = E((Hat, bx) => {
  "use strict";
  var yce = uB(), gce = cB(), bce = dB(), pB = /* @__PURE__ */ n((e) => {
    if (typeof e != "string" || e.length === 0 || (e = yce(e), e.length === 0))
      return 0;
    e = e.replace(bce(), "  ");
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      let i = e.codePointAt(r);
      i <= 31 || i >= 127 && i <= 159 || i >= 768 && i <= 879 || (i > 65535 && r++, t += gce(i) ? 2 : 1);
    }
    return t;
  }, "stringWidth");
  bx.exports = pB;
  bx.exports.default = pB;
});

// ../node_modules/ansi-align/index.js
var yB = E((zat, mB) => {
  "use strict";
  var Dce = hB();
  function Oo(e, t) {
    if (!e) return e;
    t = t || {};
    let r = t.align || "center";
    if (r === "left") return e;
    let i = t.split || `
`, s = t.pad || " ", a = r !== "right" ? vce : xce, o = !1;
    Array.isArray(e) || (o = !0, e = String(e).split(i));
    let u, l = 0;
    return e = e.map(function(c) {
      return c = String(c), u = Dce(c), l = Math.max(u, l), {
        str: c,
        width: u
      };
    }).map(function(c) {
      return new Array(a(l, c.width) + 1).join(s) + c.str;
    }), o ? e.join(i) : e;
  }
  n(Oo, "ansiAlign");
  Oo.left = /* @__PURE__ */ n(function(t) {
    return Oo(t, { align: "left" });
  }, "left");
  Oo.center = /* @__PURE__ */ n(function(t) {
    return Oo(t, { align: "center" });
  }, "center");
  Oo.right = /* @__PURE__ */ n(function(t) {
    return Oo(t, { align: "right" });
  }, "right");
  mB.exports = Oo;
  function vce(e, t) {
    return Math.floor((e - t) / 2);
  }
  n(vce, "halfDiff");
  function xce(e, t) {
    return e - t;
  }
  n(xce, "fullDiff");
});

// ../node_modules/ts-dedent/dist/index.js
var ym = E((ud) => {
  "use strict";
  Object.defineProperty(ud, "__esModule", { value: !0 });
  ud.dedent = void 0;
  function OB(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
    var i = Array.from(typeof e == "string" ? [e] : e);
    i[i.length - 1] = i[i.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var s = i.reduce(function(u, l) {
      var c = l.match(/\n([\t ]+|(?!\s).)/g);
      return c ? u.concat(c.map(function(f) {
        var m, h;
        return (h = (m = f.match(/[\t ]/g)) === null || m === void 0 ? void 0 : m.length) !== null && h !== void 0 ? h : 0;
      })) : u;
    }, []);
    if (s.length) {
      var a = new RegExp(`
[	 ]{` + Math.min.apply(Math, s) + "}", "g");
      i = i.map(function(u) {
        return u.replace(a, `
`);
      });
    }
    i[0] = i[0].replace(/^\r?\n/, "");
    var o = i[0];
    return t.forEach(function(u, l) {
      var c = o.match(/(?:^|\n)( *)$/), f = c ? c[1] : "", m = u;
      typeof u == "string" && u.includes(`
`) && (m = String(u).split(`
`).map(function(h, d) {
        return d === 0 ? h : "" + f + h;
      }).join(`
`)), o += m + i[l + 1];
    }), o;
  }
  n(OB, "dedent");
  ud.dedent = OB;
  ud.default = OB;
});

// ../node_modules/esprima/dist/esprima.js
var MB = E((cd, _x) => {
  (/* @__PURE__ */ n(function(t, r) {
    typeof cd == "object" && typeof _x == "object" ? _x.exports = r() : typeof define == "function" && define.amd ? define([], r) : typeof cd ==
    "object" ? cd.esprima = r() : t.esprima = r();
  }, "webpackUniversalModuleDefinition"))(cd, function() {
    return (
      /******/
      function(e) {
        var t = {};
        function r(i) {
          if (t[i])
            return t[i].exports;
          var s = t[i] = {
            /******/
            exports: {},
            /******/
            id: i,
            /******/
            loaded: !1
            /******/
          };
          return e[i].call(s.exports, s, s.exports, r), s.loaded = !0, s.exports;
        }
        return n(r, "__webpack_require__"), r.m = e, r.c = t, r.p = "", r(0);
      }([
        /* 0 */
        /***/
        function(e, t, r) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 });
          var i = r(1), s = r(3), a = r(8), o = r(15);
          function u(h, d, y) {
            var p = null, g = /* @__PURE__ */ n(function(q, V) {
              y && y(q, V), p && p.visit(q, V);
            }, "proxyDelegate"), b = typeof y == "function" ? g : null, D = !1;
            if (d) {
              D = typeof d.comment == "boolean" && d.comment;
              var x = typeof d.attachComment == "boolean" && d.attachComment;
              (D || x) && (p = new i.CommentHandler(), p.attach = x, d.comment = !0, b = g);
            }
            var T = !1;
            d && typeof d.sourceType == "string" && (T = d.sourceType === "module");
            var w;
            d && typeof d.jsx == "boolean" && d.jsx ? w = new s.JSXParser(h, d, b) : w = new a.Parser(h, d, b);
            var B = T ? w.parseModule() : w.parseScript(), k = B;
            return D && p && (k.comments = p.comments), w.config.tokens && (k.tokens = w.tokens), w.config.tolerant && (k.errors = w.errorHandler.
            errors), k;
          }
          n(u, "parse"), t.parse = u;
          function l(h, d, y) {
            var p = d || {};
            return p.sourceType = "module", u(h, p, y);
          }
          n(l, "parseModule"), t.parseModule = l;
          function c(h, d, y) {
            var p = d || {};
            return p.sourceType = "script", u(h, p, y);
          }
          n(c, "parseScript"), t.parseScript = c;
          function f(h, d, y) {
            var p = new o.Tokenizer(h, d), g;
            g = [];
            try {
              for (; ; ) {
                var b = p.getNextToken();
                if (!b)
                  break;
                y && (b = y(b)), g.push(b);
              }
            } catch (D) {
              p.errorHandler.tolerate(D);
            }
            return p.errorHandler.tolerant && (g.errors = p.errors()), g;
          }
          n(f, "tokenize"), t.tokenize = f;
          var m = r(2);
          t.Syntax = m.Syntax, t.version = "4.0.1";
        },
        /* 1 */
        /***/
        function(e, t, r) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 });
          var i = r(2), s = function() {
            function a() {
              this.attach = !1, this.comments = [], this.stack = [], this.leading = [], this.trailing = [];
            }
            return n(a, "CommentHandler"), a.prototype.insertInnerComments = function(o, u) {
              if (o.type === i.Syntax.BlockStatement && o.body.length === 0) {
                for (var l = [], c = this.leading.length - 1; c >= 0; --c) {
                  var f = this.leading[c];
                  u.end.offset >= f.start && (l.unshift(f.comment), this.leading.splice(c, 1), this.trailing.splice(c, 1));
                }
                l.length && (o.innerComments = l);
              }
            }, a.prototype.findTrailingComments = function(o) {
              var u = [];
              if (this.trailing.length > 0) {
                for (var l = this.trailing.length - 1; l >= 0; --l) {
                  var c = this.trailing[l];
                  c.start >= o.end.offset && u.unshift(c.comment);
                }
                return this.trailing.length = 0, u;
              }
              var f = this.stack[this.stack.length - 1];
              if (f && f.node.trailingComments) {
                var m = f.node.trailingComments[0];
                m && m.range[0] >= o.end.offset && (u = f.node.trailingComments, delete f.node.trailingComments);
              }
              return u;
            }, a.prototype.findLeadingComments = function(o) {
              for (var u = [], l; this.stack.length > 0; ) {
                var c = this.stack[this.stack.length - 1];
                if (c && c.start >= o.start.offset)
                  l = c.node, this.stack.pop();
                else
                  break;
              }
              if (l) {
                for (var f = l.leadingComments ? l.leadingComments.length : 0, m = f - 1; m >= 0; --m) {
                  var h = l.leadingComments[m];
                  h.range[1] <= o.start.offset && (u.unshift(h), l.leadingComments.splice(m, 1));
                }
                return l.leadingComments && l.leadingComments.length === 0 && delete l.leadingComments, u;
              }
              for (var m = this.leading.length - 1; m >= 0; --m) {
                var c = this.leading[m];
                c.start <= o.start.offset && (u.unshift(c.comment), this.leading.splice(m, 1));
              }
              return u;
            }, a.prototype.visitNode = function(o, u) {
              if (!(o.type === i.Syntax.Program && o.body.length > 0)) {
                this.insertInnerComments(o, u);
                var l = this.findTrailingComments(u), c = this.findLeadingComments(u);
                c.length > 0 && (o.leadingComments = c), l.length > 0 && (o.trailingComments = l), this.stack.push({
                  node: o,
                  start: u.start.offset
                });
              }
            }, a.prototype.visitComment = function(o, u) {
              var l = o.type[0] === "L" ? "Line" : "Block", c = {
                type: l,
                value: o.value
              };
              if (o.range && (c.range = o.range), o.loc && (c.loc = o.loc), this.comments.push(c), this.attach) {
                var f = {
                  comment: {
                    type: l,
                    value: o.value,
                    range: [u.start.offset, u.end.offset]
                  },
                  start: u.start.offset
                };
                o.loc && (f.comment.loc = o.loc), o.type = l, this.leading.push(f), this.trailing.push(f);
              }
            }, a.prototype.visit = function(o, u) {
              o.type === "LineComment" ? this.visitComment(o, u) : o.type === "BlockComment" ? this.visitComment(o, u) : this.attach && this.
              visitNode(o, u);
            }, a;
          }();
          t.CommentHandler = s;
        },
        /* 2 */
        /***/
        function(e, t) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 }), t.Syntax = {
            AssignmentExpression: "AssignmentExpression",
            AssignmentPattern: "AssignmentPattern",
            ArrayExpression: "ArrayExpression",
            ArrayPattern: "ArrayPattern",
            ArrowFunctionExpression: "ArrowFunctionExpression",
            AwaitExpression: "AwaitExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ClassBody: "ClassBody",
            ClassDeclaration: "ClassDeclaration",
            ClassExpression: "ClassExpression",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExportAllDeclaration: "ExportAllDeclaration",
            ExportDefaultDeclaration: "ExportDefaultDeclaration",
            ExportNamedDeclaration: "ExportNamedDeclaration",
            ExportSpecifier: "ExportSpecifier",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForOfStatement: "ForOfStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            ImportDeclaration: "ImportDeclaration",
            ImportDefaultSpecifier: "ImportDefaultSpecifier",
            ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
            ImportSpecifier: "ImportSpecifier",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            MetaProperty: "MetaProperty",
            MethodDefinition: "MethodDefinition",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            ObjectPattern: "ObjectPattern",
            Program: "Program",
            Property: "Property",
            RestElement: "RestElement",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SpreadElement: "SpreadElement",
            Super: "Super",
            SwitchCase: "SwitchCase",
            SwitchStatement: "SwitchStatement",
            TaggedTemplateExpression: "TaggedTemplateExpression",
            TemplateElement: "TemplateElement",
            TemplateLiteral: "TemplateLiteral",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement",
            YieldExpression: "YieldExpression"
          };
        },
        /* 3 */
        /***/
        function(e, t, r) {
          "use strict";
          var i = this && this.__extends || function() {
            var d = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(y, p) {
              y.__proto__ = p;
            } || function(y, p) {
              for (var g in p) p.hasOwnProperty(g) && (y[g] = p[g]);
            };
            return function(y, p) {
              d(y, p);
              function g() {
                this.constructor = y;
              }
              n(g, "__"), y.prototype = p === null ? Object.create(p) : (g.prototype = p.prototype, new g());
            };
          }();
          Object.defineProperty(t, "__esModule", { value: !0 });
          var s = r(4), a = r(5), o = r(6), u = r(7), l = r(8), c = r(13), f = r(14);
          c.TokenName[
            100
            /* Identifier */
          ] = "JSXIdentifier", c.TokenName[
            101
            /* Text */
          ] = "JSXText";
          function m(d) {
            var y;
            switch (d.type) {
              case o.JSXSyntax.JSXIdentifier:
                var p = d;
                y = p.name;
                break;
              case o.JSXSyntax.JSXNamespacedName:
                var g = d;
                y = m(g.namespace) + ":" + m(g.name);
                break;
              case o.JSXSyntax.JSXMemberExpression:
                var b = d;
                y = m(b.object) + "." + m(b.property);
                break;
              /* istanbul ignore next */
              default:
                break;
            }
            return y;
          }
          n(m, "getQualifiedElementName");
          var h = function(d) {
            i(y, d);
            function y(p, g, b) {
              return d.call(this, p, g, b) || this;
            }
            return n(y, "JSXParser"), y.prototype.parsePrimaryExpression = function() {
              return this.match("<") ? this.parseJSXRoot() : d.prototype.parsePrimaryExpression.call(this);
            }, y.prototype.startJSX = function() {
              this.scanner.index = this.startMarker.index, this.scanner.lineNumber = this.startMarker.line, this.scanner.lineStart = this.startMarker.
              index - this.startMarker.column;
            }, y.prototype.finishJSX = function() {
              this.nextToken();
            }, y.prototype.reenterJSX = function() {
              this.startJSX(), this.expectJSX("}"), this.config.tokens && this.tokens.pop();
            }, y.prototype.createJSXNode = function() {
              return this.collectComments(), {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            }, y.prototype.createJSXChildNode = function() {
              return {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            }, y.prototype.scanXHTMLEntity = function(p) {
              for (var g = "&", b = !0, D = !1, x = !1, T = !1; !this.scanner.eof() && b && !D; ) {
                var w = this.scanner.source[this.scanner.index];
                if (w === p)
                  break;
                if (D = w === ";", g += w, ++this.scanner.index, !D)
                  switch (g.length) {
                    case 2:
                      x = w === "#";
                      break;
                    case 3:
                      x && (T = w === "x", b = T || s.Character.isDecimalDigit(w.charCodeAt(0)), x = x && !T);
                      break;
                    default:
                      b = b && !(x && !s.Character.isDecimalDigit(w.charCodeAt(0))), b = b && !(T && !s.Character.isHexDigit(w.charCodeAt(0)));
                      break;
                  }
              }
              if (b && D && g.length > 2) {
                var B = g.substr(1, g.length - 2);
                x && B.length > 1 ? g = String.fromCharCode(parseInt(B.substr(1), 10)) : T && B.length > 2 ? g = String.fromCharCode(parseInt(
                "0" + B.substr(1), 16)) : !x && !T && f.XHTMLEntities[B] && (g = f.XHTMLEntities[B]);
              }
              return g;
            }, y.prototype.lexJSX = function() {
              var p = this.scanner.source.charCodeAt(this.scanner.index);
              if (p === 60 || p === 62 || p === 47 || p === 58 || p === 61 || p === 123 || p === 125) {
                var g = this.scanner.source[this.scanner.index++];
                return {
                  type: 7,
                  value: g,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index - 1,
                  end: this.scanner.index
                };
              }
              if (p === 34 || p === 39) {
                for (var b = this.scanner.index, D = this.scanner.source[this.scanner.index++], x = ""; !this.scanner.eof(); ) {
                  var T = this.scanner.source[this.scanner.index++];
                  if (T === D)
                    break;
                  T === "&" ? x += this.scanXHTMLEntity(D) : x += T;
                }
                return {
                  type: 8,
                  value: x,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: b,
                  end: this.scanner.index
                };
              }
              if (p === 46) {
                var w = this.scanner.source.charCodeAt(this.scanner.index + 1), B = this.scanner.source.charCodeAt(this.scanner.index + 2), g = w ===
                46 && B === 46 ? "..." : ".", b = this.scanner.index;
                return this.scanner.index += g.length, {
                  type: 7,
                  value: g,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: b,
                  end: this.scanner.index
                };
              }
              if (p === 96)
                return {
                  type: 10,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index,
                  end: this.scanner.index
                };
              if (s.Character.isIdentifierStart(p) && p !== 92) {
                var b = this.scanner.index;
                for (++this.scanner.index; !this.scanner.eof(); ) {
                  var T = this.scanner.source.charCodeAt(this.scanner.index);
                  if (s.Character.isIdentifierPart(T) && T !== 92)
                    ++this.scanner.index;
                  else if (T === 45)
                    ++this.scanner.index;
                  else
                    break;
                }
                var k = this.scanner.source.slice(b, this.scanner.index);
                return {
                  type: 100,
                  value: k,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: b,
                  end: this.scanner.index
                };
              }
              return this.scanner.lex();
            }, y.prototype.nextJSXToken = function() {
              this.collectComments(), this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.
              column = this.scanner.index - this.scanner.lineStart;
              var p = this.lexJSX();
              return this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.
              scanner.index - this.scanner.lineStart, this.config.tokens && this.tokens.push(this.convertToken(p)), p;
            }, y.prototype.nextJSXText = function() {
              this.startMarker.index = this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.
              index - this.scanner.lineStart;
              for (var p = this.scanner.index, g = ""; !this.scanner.eof(); ) {
                var b = this.scanner.source[this.scanner.index];
                if (b === "{" || b === "<")
                  break;
                ++this.scanner.index, g += b, s.Character.isLineTerminator(b.charCodeAt(0)) && (++this.scanner.lineNumber, b === "\r" && this.
                scanner.source[this.scanner.index] === `
` && ++this.scanner.index, this.scanner.lineStart = this.scanner.index);
              }
              this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.
              index - this.scanner.lineStart;
              var D = {
                type: 101,
                value: g,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start: p,
                end: this.scanner.index
              };
              return g.length > 0 && this.config.tokens && this.tokens.push(this.convertToken(D)), D;
            }, y.prototype.peekJSXToken = function() {
              var p = this.scanner.saveState();
              this.scanner.scanComments();
              var g = this.lexJSX();
              return this.scanner.restoreState(p), g;
            }, y.prototype.expectJSX = function(p) {
              var g = this.nextJSXToken();
              (g.type !== 7 || g.value !== p) && this.throwUnexpectedToken(g);
            }, y.prototype.matchJSX = function(p) {
              var g = this.peekJSXToken();
              return g.type === 7 && g.value === p;
            }, y.prototype.parseJSXIdentifier = function() {
              var p = this.createJSXNode(), g = this.nextJSXToken();
              return g.type !== 100 && this.throwUnexpectedToken(g), this.finalize(p, new a.JSXIdentifier(g.value));
            }, y.prototype.parseJSXElementName = function() {
              var p = this.createJSXNode(), g = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var b = g;
                this.expectJSX(":");
                var D = this.parseJSXIdentifier();
                g = this.finalize(p, new a.JSXNamespacedName(b, D));
              } else if (this.matchJSX("."))
                for (; this.matchJSX("."); ) {
                  var x = g;
                  this.expectJSX(".");
                  var T = this.parseJSXIdentifier();
                  g = this.finalize(p, new a.JSXMemberExpression(x, T));
                }
              return g;
            }, y.prototype.parseJSXAttributeName = function() {
              var p = this.createJSXNode(), g, b = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var D = b;
                this.expectJSX(":");
                var x = this.parseJSXIdentifier();
                g = this.finalize(p, new a.JSXNamespacedName(D, x));
              } else
                g = b;
              return g;
            }, y.prototype.parseJSXStringLiteralAttribute = function() {
              var p = this.createJSXNode(), g = this.nextJSXToken();
              g.type !== 8 && this.throwUnexpectedToken(g);
              var b = this.getTokenRaw(g);
              return this.finalize(p, new u.Literal(g.value, b));
            }, y.prototype.parseJSXExpressionAttribute = function() {
              var p = this.createJSXNode();
              this.expectJSX("{"), this.finishJSX(), this.match("}") && this.tolerateError("JSX attributes must only be assigned a non-empty\
 expression");
              var g = this.parseAssignmentExpression();
              return this.reenterJSX(), this.finalize(p, new a.JSXExpressionContainer(g));
            }, y.prototype.parseJSXAttributeValue = function() {
              return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
            }, y.prototype.parseJSXNameValueAttribute = function() {
              var p = this.createJSXNode(), g = this.parseJSXAttributeName(), b = null;
              return this.matchJSX("=") && (this.expectJSX("="), b = this.parseJSXAttributeValue()), this.finalize(p, new a.JSXAttribute(g, b));
            }, y.prototype.parseJSXSpreadAttribute = function() {
              var p = this.createJSXNode();
              this.expectJSX("{"), this.expectJSX("..."), this.finishJSX();
              var g = this.parseAssignmentExpression();
              return this.reenterJSX(), this.finalize(p, new a.JSXSpreadAttribute(g));
            }, y.prototype.parseJSXAttributes = function() {
              for (var p = []; !this.matchJSX("/") && !this.matchJSX(">"); ) {
                var g = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                p.push(g);
              }
              return p;
            }, y.prototype.parseJSXOpeningElement = function() {
              var p = this.createJSXNode();
              this.expectJSX("<");
              var g = this.parseJSXElementName(), b = this.parseJSXAttributes(), D = this.matchJSX("/");
              return D && this.expectJSX("/"), this.expectJSX(">"), this.finalize(p, new a.JSXOpeningElement(g, D, b));
            }, y.prototype.parseJSXBoundaryElement = function() {
              var p = this.createJSXNode();
              if (this.expectJSX("<"), this.matchJSX("/")) {
                this.expectJSX("/");
                var g = this.parseJSXElementName();
                return this.expectJSX(">"), this.finalize(p, new a.JSXClosingElement(g));
              }
              var b = this.parseJSXElementName(), D = this.parseJSXAttributes(), x = this.matchJSX("/");
              return x && this.expectJSX("/"), this.expectJSX(">"), this.finalize(p, new a.JSXOpeningElement(b, x, D));
            }, y.prototype.parseJSXEmptyExpression = function() {
              var p = this.createJSXChildNode();
              return this.collectComments(), this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.
              lastMarker.column = this.scanner.index - this.scanner.lineStart, this.finalize(p, new a.JSXEmptyExpression());
            }, y.prototype.parseJSXExpressionContainer = function() {
              var p = this.createJSXNode();
              this.expectJSX("{");
              var g;
              return this.matchJSX("}") ? (g = this.parseJSXEmptyExpression(), this.expectJSX("}")) : (this.finishJSX(), g = this.parseAssignmentExpression(),
              this.reenterJSX()), this.finalize(p, new a.JSXExpressionContainer(g));
            }, y.prototype.parseJSXChildren = function() {
              for (var p = []; !this.scanner.eof(); ) {
                var g = this.createJSXChildNode(), b = this.nextJSXText();
                if (b.start < b.end) {
                  var D = this.getTokenRaw(b), x = this.finalize(g, new a.JSXText(b.value, D));
                  p.push(x);
                }
                if (this.scanner.source[this.scanner.index] === "{") {
                  var T = this.parseJSXExpressionContainer();
                  p.push(T);
                } else
                  break;
              }
              return p;
            }, y.prototype.parseComplexJSXElement = function(p) {
              for (var g = []; !this.scanner.eof(); ) {
                p.children = p.children.concat(this.parseJSXChildren());
                var b = this.createJSXChildNode(), D = this.parseJSXBoundaryElement();
                if (D.type === o.JSXSyntax.JSXOpeningElement) {
                  var x = D;
                  if (x.selfClosing) {
                    var T = this.finalize(b, new a.JSXElement(x, [], null));
                    p.children.push(T);
                  } else
                    g.push(p), p = { node: b, opening: x, closing: null, children: [] };
                }
                if (D.type === o.JSXSyntax.JSXClosingElement) {
                  p.closing = D;
                  var w = m(p.opening.name), B = m(p.closing.name);
                  if (w !== B && this.tolerateError("Expected corresponding JSX closing tag for %0", w), g.length > 0) {
                    var T = this.finalize(p.node, new a.JSXElement(p.opening, p.children, p.closing));
                    p = g[g.length - 1], p.children.push(T), g.pop();
                  } else
                    break;
                }
              }
              return p;
            }, y.prototype.parseJSXElement = function() {
              var p = this.createJSXNode(), g = this.parseJSXOpeningElement(), b = [], D = null;
              if (!g.selfClosing) {
                var x = this.parseComplexJSXElement({ node: p, opening: g, closing: D, children: b });
                b = x.children, D = x.closing;
              }
              return this.finalize(p, new a.JSXElement(g, b, D));
            }, y.prototype.parseJSXRoot = function() {
              this.config.tokens && this.tokens.pop(), this.startJSX();
              var p = this.parseJSXElement();
              return this.finishJSX(), p;
            }, y.prototype.isStartOfExpression = function() {
              return d.prototype.isStartOfExpression.call(this) || this.match("<");
            }, y;
          }(l.Parser);
          t.JSXParser = h;
        },
        /* 4 */
        /***/
        function(e, t) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 });
          var r = {
            // Unicode v8.0.0 NonAsciiIdentifierStart:
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            // Unicode v8.0.0 NonAsciiIdentifierPart:
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
          };
          t.Character = {
            /* tslint:disable:no-bitwise */
            fromCodePoint: /* @__PURE__ */ n(function(i) {
              return i < 65536 ? String.fromCharCode(i) : String.fromCharCode(55296 + (i - 65536 >> 10)) + String.fromCharCode(56320 + (i - 65536 &
              1023));
            }, "fromCodePoint"),
            // https://tc39.github.io/ecma262/#sec-white-space
            isWhiteSpace: /* @__PURE__ */ n(function(i) {
              return i === 32 || i === 9 || i === 11 || i === 12 || i === 160 || i >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198,
              8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(i) >= 0;
            }, "isWhiteSpace"),
            // https://tc39.github.io/ecma262/#sec-line-terminators
            isLineTerminator: /* @__PURE__ */ n(function(i) {
              return i === 10 || i === 13 || i === 8232 || i === 8233;
            }, "isLineTerminator"),
            // https://tc39.github.io/ecma262/#sec-names-and-keywords
            isIdentifierStart: /* @__PURE__ */ n(function(i) {
              return i === 36 || i === 95 || i >= 65 && i <= 90 || i >= 97 && i <= 122 || i === 92 || i >= 128 && r.NonAsciiIdentifierStart.
              test(t.Character.fromCodePoint(i));
            }, "isIdentifierStart"),
            isIdentifierPart: /* @__PURE__ */ n(function(i) {
              return i === 36 || i === 95 || i >= 65 && i <= 90 || i >= 97 && i <= 122 || i >= 48 && i <= 57 || i === 92 || i >= 128 && r.NonAsciiIdentifierPart.
              test(t.Character.fromCodePoint(i));
            }, "isIdentifierPart"),
            // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
            isDecimalDigit: /* @__PURE__ */ n(function(i) {
              return i >= 48 && i <= 57;
            }, "isDecimalDigit"),
            isHexDigit: /* @__PURE__ */ n(function(i) {
              return i >= 48 && i <= 57 || i >= 65 && i <= 70 || i >= 97 && i <= 102;
            }, "isHexDigit"),
            isOctalDigit: /* @__PURE__ */ n(function(i) {
              return i >= 48 && i <= 55;
            }, "isOctalDigit")
          };
        },
        /* 5 */
        /***/
        function(e, t, r) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 });
          var i = r(6), s = function() {
            function p(g) {
              this.type = i.JSXSyntax.JSXClosingElement, this.name = g;
            }
            return n(p, "JSXClosingElement"), p;
          }();
          t.JSXClosingElement = s;
          var a = function() {
            function p(g, b, D) {
              this.type = i.JSXSyntax.JSXElement, this.openingElement = g, this.children = b, this.closingElement = D;
            }
            return n(p, "JSXElement"), p;
          }();
          t.JSXElement = a;
          var o = function() {
            function p() {
              this.type = i.JSXSyntax.JSXEmptyExpression;
            }
            return n(p, "JSXEmptyExpression"), p;
          }();
          t.JSXEmptyExpression = o;
          var u = function() {
            function p(g) {
              this.type = i.JSXSyntax.JSXExpressionContainer, this.expression = g;
            }
            return n(p, "JSXExpressionContainer"), p;
          }();
          t.JSXExpressionContainer = u;
          var l = function() {
            function p(g) {
              this.type = i.JSXSyntax.JSXIdentifier, this.name = g;
            }
            return n(p, "JSXIdentifier"), p;
          }();
          t.JSXIdentifier = l;
          var c = function() {
            function p(g, b) {
              this.type = i.JSXSyntax.JSXMemberExpression, this.object = g, this.property = b;
            }
            return n(p, "JSXMemberExpression"), p;
          }();
          t.JSXMemberExpression = c;
          var f = function() {
            function p(g, b) {
              this.type = i.JSXSyntax.JSXAttribute, this.name = g, this.value = b;
            }
            return n(p, "JSXAttribute"), p;
          }();
          t.JSXAttribute = f;
          var m = function() {
            function p(g, b) {
              this.type = i.JSXSyntax.JSXNamespacedName, this.namespace = g, this.name = b;
            }
            return n(p, "JSXNamespacedName"), p;
          }();
          t.JSXNamespacedName = m;
          var h = function() {
            function p(g, b, D) {
              this.type = i.JSXSyntax.JSXOpeningElement, this.name = g, this.selfClosing = b, this.attributes = D;
            }
            return n(p, "JSXOpeningElement"), p;
          }();
          t.JSXOpeningElement = h;
          var d = function() {
            function p(g) {
              this.type = i.JSXSyntax.JSXSpreadAttribute, this.argument = g;
            }
            return n(p, "JSXSpreadAttribute"), p;
          }();
          t.JSXSpreadAttribute = d;
          var y = function() {
            function p(g, b) {
              this.type = i.JSXSyntax.JSXText, this.value = g, this.raw = b;
            }
            return n(p, "JSXText"), p;
          }();
          t.JSXText = y;
        },
        /* 6 */
        /***/
        function(e, t) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 }), t.JSXSyntax = {
            JSXAttribute: "JSXAttribute",
            JSXClosingElement: "JSXClosingElement",
            JSXElement: "JSXElement",
            JSXEmptyExpression: "JSXEmptyExpression",
            JSXExpressionContainer: "JSXExpressionContainer",
            JSXIdentifier: "JSXIdentifier",
            JSXMemberExpression: "JSXMemberExpression",
            JSXNamespacedName: "JSXNamespacedName",
            JSXOpeningElement: "JSXOpeningElement",
            JSXSpreadAttribute: "JSXSpreadAttribute",
            JSXText: "JSXText"
          };
        },
        /* 7 */
        /***/
        function(e, t, r) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 });
          var i = r(2), s = function() {
            function K(z) {
              this.type = i.Syntax.ArrayExpression, this.elements = z;
            }
            return n(K, "ArrayExpression"), K;
          }();
          t.ArrayExpression = s;
          var a = function() {
            function K(z) {
              this.type = i.Syntax.ArrayPattern, this.elements = z;
            }
            return n(K, "ArrayPattern"), K;
          }();
          t.ArrayPattern = a;
          var o = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.ArrowFunctionExpression, this.id = null, this.params = z, this.body = ie, this.generator = !1, this.expression =
              $e, this.async = !1;
            }
            return n(K, "ArrowFunctionExpression"), K;
          }();
          t.ArrowFunctionExpression = o;
          var u = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.AssignmentExpression, this.operator = z, this.left = ie, this.right = $e;
            }
            return n(K, "AssignmentExpression"), K;
          }();
          t.AssignmentExpression = u;
          var l = function() {
            function K(z, ie) {
              this.type = i.Syntax.AssignmentPattern, this.left = z, this.right = ie;
            }
            return n(K, "AssignmentPattern"), K;
          }();
          t.AssignmentPattern = l;
          var c = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.ArrowFunctionExpression, this.id = null, this.params = z, this.body = ie, this.generator = !1, this.expression =
              $e, this.async = !0;
            }
            return n(K, "AsyncArrowFunctionExpression"), K;
          }();
          t.AsyncArrowFunctionExpression = c;
          var f = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.FunctionDeclaration, this.id = z, this.params = ie, this.body = $e, this.generator = !1, this.expression =
              !1, this.async = !0;
            }
            return n(K, "AsyncFunctionDeclaration"), K;
          }();
          t.AsyncFunctionDeclaration = f;
          var m = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.FunctionExpression, this.id = z, this.params = ie, this.body = $e, this.generator = !1, this.expression =
              !1, this.async = !0;
            }
            return n(K, "AsyncFunctionExpression"), K;
          }();
          t.AsyncFunctionExpression = m;
          var h = function() {
            function K(z) {
              this.type = i.Syntax.AwaitExpression, this.argument = z;
            }
            return n(K, "AwaitExpression"), K;
          }();
          t.AwaitExpression = h;
          var d = function() {
            function K(z, ie, $e) {
              var xi = z === "||" || z === "&&";
              this.type = xi ? i.Syntax.LogicalExpression : i.Syntax.BinaryExpression, this.operator = z, this.left = ie, this.right = $e;
            }
            return n(K, "BinaryExpression"), K;
          }();
          t.BinaryExpression = d;
          var y = function() {
            function K(z) {
              this.type = i.Syntax.BlockStatement, this.body = z;
            }
            return n(K, "BlockStatement"), K;
          }();
          t.BlockStatement = y;
          var p = function() {
            function K(z) {
              this.type = i.Syntax.BreakStatement, this.label = z;
            }
            return n(K, "BreakStatement"), K;
          }();
          t.BreakStatement = p;
          var g = function() {
            function K(z, ie) {
              this.type = i.Syntax.CallExpression, this.callee = z, this.arguments = ie;
            }
            return n(K, "CallExpression"), K;
          }();
          t.CallExpression = g;
          var b = function() {
            function K(z, ie) {
              this.type = i.Syntax.CatchClause, this.param = z, this.body = ie;
            }
            return n(K, "CatchClause"), K;
          }();
          t.CatchClause = b;
          var D = function() {
            function K(z) {
              this.type = i.Syntax.ClassBody, this.body = z;
            }
            return n(K, "ClassBody"), K;
          }();
          t.ClassBody = D;
          var x = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.ClassDeclaration, this.id = z, this.superClass = ie, this.body = $e;
            }
            return n(K, "ClassDeclaration"), K;
          }();
          t.ClassDeclaration = x;
          var T = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.ClassExpression, this.id = z, this.superClass = ie, this.body = $e;
            }
            return n(K, "ClassExpression"), K;
          }();
          t.ClassExpression = T;
          var w = function() {
            function K(z, ie) {
              this.type = i.Syntax.MemberExpression, this.computed = !0, this.object = z, this.property = ie;
            }
            return n(K, "ComputedMemberExpression"), K;
          }();
          t.ComputedMemberExpression = w;
          var B = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.ConditionalExpression, this.test = z, this.consequent = ie, this.alternate = $e;
            }
            return n(K, "ConditionalExpression"), K;
          }();
          t.ConditionalExpression = B;
          var k = function() {
            function K(z) {
              this.type = i.Syntax.ContinueStatement, this.label = z;
            }
            return n(K, "ContinueStatement"), K;
          }();
          t.ContinueStatement = k;
          var q = function() {
            function K() {
              this.type = i.Syntax.DebuggerStatement;
            }
            return n(K, "DebuggerStatement"), K;
          }();
          t.DebuggerStatement = q;
          var V = function() {
            function K(z, ie) {
              this.type = i.Syntax.ExpressionStatement, this.expression = z, this.directive = ie;
            }
            return n(K, "Directive"), K;
          }();
          t.Directive = V;
          var Y = function() {
            function K(z, ie) {
              this.type = i.Syntax.DoWhileStatement, this.body = z, this.test = ie;
            }
            return n(K, "DoWhileStatement"), K;
          }();
          t.DoWhileStatement = Y;
          var G = function() {
            function K() {
              this.type = i.Syntax.EmptyStatement;
            }
            return n(K, "EmptyStatement"), K;
          }();
          t.EmptyStatement = G;
          var ye = function() {
            function K(z) {
              this.type = i.Syntax.ExportAllDeclaration, this.source = z;
            }
            return n(K, "ExportAllDeclaration"), K;
          }();
          t.ExportAllDeclaration = ye;
          var te = function() {
            function K(z) {
              this.type = i.Syntax.ExportDefaultDeclaration, this.declaration = z;
            }
            return n(K, "ExportDefaultDeclaration"), K;
          }();
          t.ExportDefaultDeclaration = te;
          var re = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.ExportNamedDeclaration, this.declaration = z, this.specifiers = ie, this.source = $e;
            }
            return n(K, "ExportNamedDeclaration"), K;
          }();
          t.ExportNamedDeclaration = re;
          var ve = function() {
            function K(z, ie) {
              this.type = i.Syntax.ExportSpecifier, this.exported = ie, this.local = z;
            }
            return n(K, "ExportSpecifier"), K;
          }();
          t.ExportSpecifier = ve;
          var je = function() {
            function K(z) {
              this.type = i.Syntax.ExpressionStatement, this.expression = z;
            }
            return n(K, "ExpressionStatement"), K;
          }();
          t.ExpressionStatement = je;
          var Be = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.ForInStatement, this.left = z, this.right = ie, this.body = $e, this.each = !1;
            }
            return n(K, "ForInStatement"), K;
          }();
          t.ForInStatement = Be;
          var se = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.ForOfStatement, this.left = z, this.right = ie, this.body = $e;
            }
            return n(K, "ForOfStatement"), K;
          }();
          t.ForOfStatement = se;
          var Ne = function() {
            function K(z, ie, $e, xi) {
              this.type = i.Syntax.ForStatement, this.init = z, this.test = ie, this.update = $e, this.body = xi;
            }
            return n(K, "ForStatement"), K;
          }();
          t.ForStatement = Ne;
          var ke = function() {
            function K(z, ie, $e, xi) {
              this.type = i.Syntax.FunctionDeclaration, this.id = z, this.params = ie, this.body = $e, this.generator = xi, this.expression =
              !1, this.async = !1;
            }
            return n(K, "FunctionDeclaration"), K;
          }();
          t.FunctionDeclaration = ke;
          var Cr = function() {
            function K(z, ie, $e, xi) {
              this.type = i.Syntax.FunctionExpression, this.id = z, this.params = ie, this.body = $e, this.generator = xi, this.expression =
              !1, this.async = !1;
            }
            return n(K, "FunctionExpression"), K;
          }();
          t.FunctionExpression = Cr;
          var Ae = function() {
            function K(z) {
              this.type = i.Syntax.Identifier, this.name = z;
            }
            return n(K, "Identifier"), K;
          }();
          t.Identifier = Ae;
          var _e = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.IfStatement, this.test = z, this.consequent = ie, this.alternate = $e;
            }
            return n(K, "IfStatement"), K;
          }();
          t.IfStatement = _e;
          var Me = function() {
            function K(z, ie) {
              this.type = i.Syntax.ImportDeclaration, this.specifiers = z, this.source = ie;
            }
            return n(K, "ImportDeclaration"), K;
          }();
          t.ImportDeclaration = Me;
          var Nt = function() {
            function K(z) {
              this.type = i.Syntax.ImportDefaultSpecifier, this.local = z;
            }
            return n(K, "ImportDefaultSpecifier"), K;
          }();
          t.ImportDefaultSpecifier = Nt;
          var tr = function() {
            function K(z) {
              this.type = i.Syntax.ImportNamespaceSpecifier, this.local = z;
            }
            return n(K, "ImportNamespaceSpecifier"), K;
          }();
          t.ImportNamespaceSpecifier = tr;
          var Yr = function() {
            function K(z, ie) {
              this.type = i.Syntax.ImportSpecifier, this.local = z, this.imported = ie;
            }
            return n(K, "ImportSpecifier"), K;
          }();
          t.ImportSpecifier = Yr;
          var Ni = function() {
            function K(z, ie) {
              this.type = i.Syntax.LabeledStatement, this.label = z, this.body = ie;
            }
            return n(K, "LabeledStatement"), K;
          }();
          t.LabeledStatement = Ni;
          var pn = function() {
            function K(z, ie) {
              this.type = i.Syntax.Literal, this.value = z, this.raw = ie;
            }
            return n(K, "Literal"), K;
          }();
          t.Literal = pn;
          var co = function() {
            function K(z, ie) {
              this.type = i.Syntax.MetaProperty, this.meta = z, this.property = ie;
            }
            return n(K, "MetaProperty"), K;
          }();
          t.MetaProperty = co;
          var Os = function() {
            function K(z, ie, $e, xi, vb) {
              this.type = i.Syntax.MethodDefinition, this.key = z, this.computed = ie, this.value = $e, this.kind = xi, this.static = vb;
            }
            return n(K, "MethodDefinition"), K;
          }();
          t.MethodDefinition = Os;
          var ks = function() {
            function K(z) {
              this.type = i.Syntax.Program, this.body = z, this.sourceType = "module";
            }
            return n(K, "Module"), K;
          }();
          t.Module = ks;
          var Bs = function() {
            function K(z, ie) {
              this.type = i.Syntax.NewExpression, this.callee = z, this.arguments = ie;
            }
            return n(K, "NewExpression"), K;
          }();
          t.NewExpression = Bs;
          var fo = function() {
            function K(z) {
              this.type = i.Syntax.ObjectExpression, this.properties = z;
            }
            return n(K, "ObjectExpression"), K;
          }();
          t.ObjectExpression = fo;
          var Vu = function() {
            function K(z) {
              this.type = i.Syntax.ObjectPattern, this.properties = z;
            }
            return n(K, "ObjectPattern"), K;
          }();
          t.ObjectPattern = Vu;
          var pe = function() {
            function K(z, ie, $e, xi, vb, iG) {
              this.type = i.Syntax.Property, this.key = ie, this.computed = $e, this.value = xi, this.kind = z, this.method = vb, this.shorthand =
              iG;
            }
            return n(K, "Property"), K;
          }();
          t.Property = pe;
          var oe = function() {
            function K(z, ie, $e, xi) {
              this.type = i.Syntax.Literal, this.value = z, this.raw = ie, this.regex = { pattern: $e, flags: xi };
            }
            return n(K, "RegexLiteral"), K;
          }();
          t.RegexLiteral = oe;
          var Re = function() {
            function K(z) {
              this.type = i.Syntax.RestElement, this.argument = z;
            }
            return n(K, "RestElement"), K;
          }();
          t.RestElement = Re;
          var bt = function() {
            function K(z) {
              this.type = i.Syntax.ReturnStatement, this.argument = z;
            }
            return n(K, "ReturnStatement"), K;
          }();
          t.ReturnStatement = bt;
          var Kt = function() {
            function K(z) {
              this.type = i.Syntax.Program, this.body = z, this.sourceType = "script";
            }
            return n(K, "Script"), K;
          }();
          t.Script = Kt;
          var xt = function() {
            function K(z) {
              this.type = i.Syntax.SequenceExpression, this.expressions = z;
            }
            return n(K, "SequenceExpression"), K;
          }();
          t.SequenceExpression = xt;
          var fr = function() {
            function K(z) {
              this.type = i.Syntax.SpreadElement, this.argument = z;
            }
            return n(K, "SpreadElement"), K;
          }();
          t.SpreadElement = fr;
          var os = function() {
            function K(z, ie) {
              this.type = i.Syntax.MemberExpression, this.computed = !1, this.object = z, this.property = ie;
            }
            return n(K, "StaticMemberExpression"), K;
          }();
          t.StaticMemberExpression = os;
          var rr = function() {
            function K() {
              this.type = i.Syntax.Super;
            }
            return n(K, "Super"), K;
          }();
          t.Super = rr;
          var mr = function() {
            function K(z, ie) {
              this.type = i.Syntax.SwitchCase, this.test = z, this.consequent = ie;
            }
            return n(K, "SwitchCase"), K;
          }();
          t.SwitchCase = mr;
          var Gr = function() {
            function K(z, ie) {
              this.type = i.Syntax.SwitchStatement, this.discriminant = z, this.cases = ie;
            }
            return n(K, "SwitchStatement"), K;
          }();
          t.SwitchStatement = Gr;
          var yr = function() {
            function K(z, ie) {
              this.type = i.Syntax.TaggedTemplateExpression, this.tag = z, this.quasi = ie;
            }
            return n(K, "TaggedTemplateExpression"), K;
          }();
          t.TaggedTemplateExpression = yr;
          var ca = function() {
            function K(z, ie) {
              this.type = i.Syntax.TemplateElement, this.value = z, this.tail = ie;
            }
            return n(K, "TemplateElement"), K;
          }();
          t.TemplateElement = ca;
          var ci = function() {
            function K(z, ie) {
              this.type = i.Syntax.TemplateLiteral, this.quasis = z, this.expressions = ie;
            }
            return n(K, "TemplateLiteral"), K;
          }();
          t.TemplateLiteral = ci;
          var wr = function() {
            function K() {
              this.type = i.Syntax.ThisExpression;
            }
            return n(K, "ThisExpression"), K;
          }();
          t.ThisExpression = wr;
          var Di = function() {
            function K(z) {
              this.type = i.Syntax.ThrowStatement, this.argument = z;
            }
            return n(K, "ThrowStatement"), K;
          }();
          t.ThrowStatement = Di;
          var vi = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.TryStatement, this.block = z, this.handler = ie, this.finalizer = $e;
            }
            return n(K, "TryStatement"), K;
          }();
          t.TryStatement = vi;
          var Mi = function() {
            function K(z, ie) {
              this.type = i.Syntax.UnaryExpression, this.operator = z, this.argument = ie, this.prefix = !0;
            }
            return n(K, "UnaryExpression"), K;
          }();
          t.UnaryExpression = Mi;
          var Jc = function() {
            function K(z, ie, $e) {
              this.type = i.Syntax.UpdateExpression, this.operator = z, this.argument = ie, this.prefix = $e;
            }
            return n(K, "UpdateExpression"), K;
          }();
          t.UpdateExpression = Jc;
          var bb = function() {
            function K(z, ie) {
              this.type = i.Syntax.VariableDeclaration, this.declarations = z, this.kind = ie;
            }
            return n(K, "VariableDeclaration"), K;
          }();
          t.VariableDeclaration = bb;
          var Db = function() {
            function K(z, ie) {
              this.type = i.Syntax.VariableDeclarator, this.id = z, this.init = ie;
            }
            return n(K, "VariableDeclarator"), K;
          }();
          t.VariableDeclarator = Db;
          var ch = function() {
            function K(z, ie) {
              this.type = i.Syntax.WhileStatement, this.test = z, this.body = ie;
            }
            return n(K, "WhileStatement"), K;
          }();
          t.WhileStatement = ch;
          var fh = function() {
            function K(z, ie) {
              this.type = i.Syntax.WithStatement, this.object = z, this.body = ie;
            }
            return n(K, "WithStatement"), K;
          }();
          t.WithStatement = fh;
          var dh = function() {
            function K(z, ie) {
              this.type = i.Syntax.YieldExpression, this.argument = z, this.delegate = ie;
            }
            return n(K, "YieldExpression"), K;
          }();
          t.YieldExpression = dh;
        },
        /* 8 */
        /***/
        function(e, t, r) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 });
          var i = r(9), s = r(10), a = r(11), o = r(7), u = r(12), l = r(2), c = r(13), f = "ArrowParameterPlaceHolder", m = function() {
            function h(d, y, p) {
              y === void 0 && (y = {}), this.config = {
                range: typeof y.range == "boolean" && y.range,
                loc: typeof y.loc == "boolean" && y.loc,
                source: null,
                tokens: typeof y.tokens == "boolean" && y.tokens,
                comment: typeof y.comment == "boolean" && y.comment,
                tolerant: typeof y.tolerant == "boolean" && y.tolerant
              }, this.config.loc && y.source && y.source !== null && (this.config.source = String(y.source)), this.delegate = p, this.errorHandler =
              new s.ErrorHandler(), this.errorHandler.tolerant = this.config.tolerant, this.scanner = new u.Scanner(d, this.errorHandler), this.
              scanner.trackComment = this.config.comment, this.operatorPrecedence = {
                ")": 0,
                ";": 0,
                ",": 0,
                "=": 0,
                "]": 0,
                "||": 1,
                "&&": 2,
                "|": 3,
                "^": 4,
                "&": 5,
                "==": 6,
                "!=": 6,
                "===": 6,
                "!==": 6,
                "<": 7,
                ">": 7,
                "<=": 7,
                ">=": 7,
                "<<": 8,
                ">>": 8,
                ">>>": 8,
                "+": 9,
                "-": 9,
                "*": 11,
                "/": 11,
                "%": 11
              }, this.lookahead = {
                type: 2,
                value: "",
                lineNumber: this.scanner.lineNumber,
                lineStart: 0,
                start: 0,
                end: 0
              }, this.hasLineTerminator = !1, this.context = {
                isModule: !1,
                await: !1,
                allowIn: !0,
                allowStrictDirective: !0,
                allowYield: !0,
                firstCoverInitializedNameError: null,
                isAssignmentTarget: !1,
                isBindingElement: !1,
                inFunctionBody: !1,
                inIteration: !1,
                inSwitch: !1,
                labelSet: {},
                strict: !1
              }, this.tokens = [], this.startMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              }, this.lastMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              }, this.nextToken(), this.lastMarker = {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            }
            return n(h, "Parser"), h.prototype.throwError = function(d) {
              for (var y = [], p = 1; p < arguments.length; p++)
                y[p - 1] = arguments[p];
              var g = Array.prototype.slice.call(arguments, 1), b = d.replace(/%(\d)/g, function(w, B) {
                return i.assert(B < g.length, "Message reference must be in range"), g[B];
              }), D = this.lastMarker.index, x = this.lastMarker.line, T = this.lastMarker.column + 1;
              throw this.errorHandler.createError(D, x, T, b);
            }, h.prototype.tolerateError = function(d) {
              for (var y = [], p = 1; p < arguments.length; p++)
                y[p - 1] = arguments[p];
              var g = Array.prototype.slice.call(arguments, 1), b = d.replace(/%(\d)/g, function(w, B) {
                return i.assert(B < g.length, "Message reference must be in range"), g[B];
              }), D = this.lastMarker.index, x = this.scanner.lineNumber, T = this.lastMarker.column + 1;
              this.errorHandler.tolerateError(D, x, T, b);
            }, h.prototype.unexpectedTokenError = function(d, y) {
              var p = y || a.Messages.UnexpectedToken, g;
              if (d ? (y || (p = d.type === 2 ? a.Messages.UnexpectedEOS : d.type === 3 ? a.Messages.UnexpectedIdentifier : d.type === 6 ? a.
              Messages.UnexpectedNumber : d.type === 8 ? a.Messages.UnexpectedString : d.type === 10 ? a.Messages.UnexpectedTemplate : a.Messages.
              UnexpectedToken, d.type === 4 && (this.scanner.isFutureReservedWord(d.value) ? p = a.Messages.UnexpectedReserved : this.context.
              strict && this.scanner.isStrictModeReservedWord(d.value) && (p = a.Messages.StrictReservedWord))), g = d.value) : g = "ILLEGAL",
              p = p.replace("%0", g), d && typeof d.lineNumber == "number") {
                var b = d.start, D = d.lineNumber, x = this.lastMarker.index - this.lastMarker.column, T = d.start - x + 1;
                return this.errorHandler.createError(b, D, T, p);
              } else {
                var b = this.lastMarker.index, D = this.lastMarker.line, T = this.lastMarker.column + 1;
                return this.errorHandler.createError(b, D, T, p);
              }
            }, h.prototype.throwUnexpectedToken = function(d, y) {
              throw this.unexpectedTokenError(d, y);
            }, h.prototype.tolerateUnexpectedToken = function(d, y) {
              this.errorHandler.tolerate(this.unexpectedTokenError(d, y));
            }, h.prototype.collectComments = function() {
              if (!this.config.comment)
                this.scanner.scanComments();
              else {
                var d = this.scanner.scanComments();
                if (d.length > 0 && this.delegate)
                  for (var y = 0; y < d.length; ++y) {
                    var p = d[y], g = void 0;
                    g = {
                      type: p.multiLine ? "BlockComment" : "LineComment",
                      value: this.scanner.source.slice(p.slice[0], p.slice[1])
                    }, this.config.range && (g.range = p.range), this.config.loc && (g.loc = p.loc);
                    var b = {
                      start: {
                        line: p.loc.start.line,
                        column: p.loc.start.column,
                        offset: p.range[0]
                      },
                      end: {
                        line: p.loc.end.line,
                        column: p.loc.end.column,
                        offset: p.range[1]
                      }
                    };
                    this.delegate(g, b);
                  }
              }
            }, h.prototype.getTokenRaw = function(d) {
              return this.scanner.source.slice(d.start, d.end);
            }, h.prototype.convertToken = function(d) {
              var y = {
                type: c.TokenName[d.type],
                value: this.getTokenRaw(d)
              };
              if (this.config.range && (y.range = [d.start, d.end]), this.config.loc && (y.loc = {
                start: {
                  line: this.startMarker.line,
                  column: this.startMarker.column
                },
                end: {
                  line: this.scanner.lineNumber,
                  column: this.scanner.index - this.scanner.lineStart
                }
              }), d.type === 9) {
                var p = d.pattern, g = d.flags;
                y.regex = { pattern: p, flags: g };
              }
              return y;
            }, h.prototype.nextToken = function() {
              var d = this.lookahead;
              this.lastMarker.index = this.scanner.index, this.lastMarker.line = this.scanner.lineNumber, this.lastMarker.column = this.scanner.
              index - this.scanner.lineStart, this.collectComments(), this.scanner.index !== this.startMarker.index && (this.startMarker.index =
              this.scanner.index, this.startMarker.line = this.scanner.lineNumber, this.startMarker.column = this.scanner.index - this.scanner.
              lineStart);
              var y = this.scanner.lex();
              return this.hasLineTerminator = d.lineNumber !== y.lineNumber, y && this.context.strict && y.type === 3 && this.scanner.isStrictModeReservedWord(
              y.value) && (y.type = 4), this.lookahead = y, this.config.tokens && y.type !== 2 && this.tokens.push(this.convertToken(y)), d;
            }, h.prototype.nextRegexToken = function() {
              this.collectComments();
              var d = this.scanner.scanRegExp();
              return this.config.tokens && (this.tokens.pop(), this.tokens.push(this.convertToken(d))), this.lookahead = d, this.nextToken(),
              d;
            }, h.prototype.createNode = function() {
              return {
                index: this.startMarker.index,
                line: this.startMarker.line,
                column: this.startMarker.column
              };
            }, h.prototype.startNode = function(d, y) {
              y === void 0 && (y = 0);
              var p = d.start - d.lineStart, g = d.lineNumber;
              return p < 0 && (p += y, g--), {
                index: d.start,
                line: g,
                column: p
              };
            }, h.prototype.finalize = function(d, y) {
              if (this.config.range && (y.range = [d.index, this.lastMarker.index]), this.config.loc && (y.loc = {
                start: {
                  line: d.line,
                  column: d.column
                },
                end: {
                  line: this.lastMarker.line,
                  column: this.lastMarker.column
                }
              }, this.config.source && (y.loc.source = this.config.source)), this.delegate) {
                var p = {
                  start: {
                    line: d.line,
                    column: d.column,
                    offset: d.index
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column,
                    offset: this.lastMarker.index
                  }
                };
                this.delegate(y, p);
              }
              return y;
            }, h.prototype.expect = function(d) {
              var y = this.nextToken();
              (y.type !== 7 || y.value !== d) && this.throwUnexpectedToken(y);
            }, h.prototype.expectCommaSeparator = function() {
              if (this.config.tolerant) {
                var d = this.lookahead;
                d.type === 7 && d.value === "," ? this.nextToken() : d.type === 7 && d.value === ";" ? (this.nextToken(), this.tolerateUnexpectedToken(
                d)) : this.tolerateUnexpectedToken(d, a.Messages.UnexpectedToken);
              } else
                this.expect(",");
            }, h.prototype.expectKeyword = function(d) {
              var y = this.nextToken();
              (y.type !== 4 || y.value !== d) && this.throwUnexpectedToken(y);
            }, h.prototype.match = function(d) {
              return this.lookahead.type === 7 && this.lookahead.value === d;
            }, h.prototype.matchKeyword = function(d) {
              return this.lookahead.type === 4 && this.lookahead.value === d;
            }, h.prototype.matchContextualKeyword = function(d) {
              return this.lookahead.type === 3 && this.lookahead.value === d;
            }, h.prototype.matchAssign = function() {
              if (this.lookahead.type !== 7)
                return !1;
              var d = this.lookahead.value;
              return d === "=" || d === "*=" || d === "**=" || d === "/=" || d === "%=" || d === "+=" || d === "-=" || d === "<<=" || d === "\
>>=" || d === ">>>=" || d === "&=" || d === "^=" || d === "|=";
            }, h.prototype.isolateCoverGrammar = function(d) {
              var y = this.context.isBindingElement, p = this.context.isAssignmentTarget, g = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null;
              var b = d.call(this);
              return this.context.firstCoverInitializedNameError !== null && this.throwUnexpectedToken(this.context.firstCoverInitializedNameError),
              this.context.isBindingElement = y, this.context.isAssignmentTarget = p, this.context.firstCoverInitializedNameError = g, b;
            }, h.prototype.inheritCoverGrammar = function(d) {
              var y = this.context.isBindingElement, p = this.context.isAssignmentTarget, g = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = !0, this.context.isAssignmentTarget = !0, this.context.firstCoverInitializedNameError = null;
              var b = d.call(this);
              return this.context.isBindingElement = this.context.isBindingElement && y, this.context.isAssignmentTarget = this.context.isAssignmentTarget &&
              p, this.context.firstCoverInitializedNameError = g || this.context.firstCoverInitializedNameError, b;
            }, h.prototype.consumeSemicolon = function() {
              this.match(";") ? this.nextToken() : this.hasLineTerminator || (this.lookahead.type !== 2 && !this.match("}") && this.throwUnexpectedToken(
              this.lookahead), this.lastMarker.index = this.startMarker.index, this.lastMarker.line = this.startMarker.line, this.lastMarker.
              column = this.startMarker.column);
            }, h.prototype.parsePrimaryExpression = function() {
              var d = this.createNode(), y, p, g;
              switch (this.lookahead.type) {
                case 3:
                  (this.context.isModule || this.context.await) && this.lookahead.value === "await" && this.tolerateUnexpectedToken(this.lookahead),
                  y = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(d, new o.Identifier(this.nextToken().value));
                  break;
                case 6:
                case 8:
                  this.context.strict && this.lookahead.octal && this.tolerateUnexpectedToken(this.lookahead, a.Messages.StrictOctalLiteral),
                  this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, p = this.nextToken(), g = this.getTokenRaw(p), y =
                  this.finalize(d, new o.Literal(p.value, g));
                  break;
                case 1:
                  this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, p = this.nextToken(), g = this.getTokenRaw(p), y =
                  this.finalize(d, new o.Literal(p.value === "true", g));
                  break;
                case 5:
                  this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, p = this.nextToken(), g = this.getTokenRaw(p), y =
                  this.finalize(d, new o.Literal(null, g));
                  break;
                case 10:
                  y = this.parseTemplateLiteral();
                  break;
                case 7:
                  switch (this.lookahead.value) {
                    case "(":
                      this.context.isBindingElement = !1, y = this.inheritCoverGrammar(this.parseGroupExpression);
                      break;
                    case "[":
                      y = this.inheritCoverGrammar(this.parseArrayInitializer);
                      break;
                    case "{":
                      y = this.inheritCoverGrammar(this.parseObjectInitializer);
                      break;
                    case "/":
                    case "/=":
                      this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.scanner.index = this.startMarker.index,
                      p = this.nextRegexToken(), g = this.getTokenRaw(p), y = this.finalize(d, new o.RegexLiteral(p.regex, g, p.pattern, p.flags));
                      break;
                    default:
                      y = this.throwUnexpectedToken(this.nextToken());
                  }
                  break;
                case 4:
                  !this.context.strict && this.context.allowYield && this.matchKeyword("yield") ? y = this.parseIdentifierName() : !this.context.
                  strict && this.matchKeyword("let") ? y = this.finalize(d, new o.Identifier(this.nextToken().value)) : (this.context.isAssignmentTarget =
                  !1, this.context.isBindingElement = !1, this.matchKeyword("function") ? y = this.parseFunctionExpression() : this.matchKeyword(
                  "this") ? (this.nextToken(), y = this.finalize(d, new o.ThisExpression())) : this.matchKeyword("class") ? y = this.parseClassExpression() :
                  y = this.throwUnexpectedToken(this.nextToken()));
                  break;
                default:
                  y = this.throwUnexpectedToken(this.nextToken());
              }
              return y;
            }, h.prototype.parseSpreadElement = function() {
              var d = this.createNode();
              this.expect("...");
              var y = this.inheritCoverGrammar(this.parseAssignmentExpression);
              return this.finalize(d, new o.SpreadElement(y));
            }, h.prototype.parseArrayInitializer = function() {
              var d = this.createNode(), y = [];
              for (this.expect("["); !this.match("]"); )
                if (this.match(","))
                  this.nextToken(), y.push(null);
                else if (this.match("...")) {
                  var p = this.parseSpreadElement();
                  this.match("]") || (this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1, this.expect(",")), y.push(p);
                } else
                  y.push(this.inheritCoverGrammar(this.parseAssignmentExpression)), this.match("]") || this.expect(",");
              return this.expect("]"), this.finalize(d, new o.ArrayExpression(y));
            }, h.prototype.parsePropertyMethod = function(d) {
              this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
              var y = this.context.strict, p = this.context.allowStrictDirective;
              this.context.allowStrictDirective = d.simple;
              var g = this.isolateCoverGrammar(this.parseFunctionSourceElements);
              return this.context.strict && d.firstRestricted && this.tolerateUnexpectedToken(d.firstRestricted, d.message), this.context.strict &&
              d.stricted && this.tolerateUnexpectedToken(d.stricted, d.message), this.context.strict = y, this.context.allowStrictDirective =
              p, g;
            }, h.prototype.parsePropertyMethodFunction = function() {
              var d = !1, y = this.createNode(), p = this.context.allowYield;
              this.context.allowYield = !0;
              var g = this.parseFormalParameters(), b = this.parsePropertyMethod(g);
              return this.context.allowYield = p, this.finalize(y, new o.FunctionExpression(null, g.params, b, d));
            }, h.prototype.parsePropertyMethodAsyncFunction = function() {
              var d = this.createNode(), y = this.context.allowYield, p = this.context.await;
              this.context.allowYield = !1, this.context.await = !0;
              var g = this.parseFormalParameters(), b = this.parsePropertyMethod(g);
              return this.context.allowYield = y, this.context.await = p, this.finalize(d, new o.AsyncFunctionExpression(null, g.params, b));
            }, h.prototype.parseObjectPropertyKey = function() {
              var d = this.createNode(), y = this.nextToken(), p;
              switch (y.type) {
                case 8:
                case 6:
                  this.context.strict && y.octal && this.tolerateUnexpectedToken(y, a.Messages.StrictOctalLiteral);
                  var g = this.getTokenRaw(y);
                  p = this.finalize(d, new o.Literal(y.value, g));
                  break;
                case 3:
                case 1:
                case 5:
                case 4:
                  p = this.finalize(d, new o.Identifier(y.value));
                  break;
                case 7:
                  y.value === "[" ? (p = this.isolateCoverGrammar(this.parseAssignmentExpression), this.expect("]")) : p = this.throwUnexpectedToken(
                  y);
                  break;
                default:
                  p = this.throwUnexpectedToken(y);
              }
              return p;
            }, h.prototype.isPropertyKey = function(d, y) {
              return d.type === l.Syntax.Identifier && d.name === y || d.type === l.Syntax.Literal && d.value === y;
            }, h.prototype.parseObjectProperty = function(d) {
              var y = this.createNode(), p = this.lookahead, g, b = null, D = null, x = !1, T = !1, w = !1, B = !1;
              if (p.type === 3) {
                var k = p.value;
                this.nextToken(), x = this.match("["), B = !this.hasLineTerminator && k === "async" && !this.match(":") && !this.match("(") &&
                !this.match("*") && !this.match(","), b = B ? this.parseObjectPropertyKey() : this.finalize(y, new o.Identifier(k));
              } else this.match("*") ? this.nextToken() : (x = this.match("["), b = this.parseObjectPropertyKey());
              var q = this.qualifiedPropertyName(this.lookahead);
              if (p.type === 3 && !B && p.value === "get" && q)
                g = "get", x = this.match("["), b = this.parseObjectPropertyKey(), this.context.allowYield = !1, D = this.parseGetterMethod();
              else if (p.type === 3 && !B && p.value === "set" && q)
                g = "set", x = this.match("["), b = this.parseObjectPropertyKey(), D = this.parseSetterMethod();
              else if (p.type === 7 && p.value === "*" && q)
                g = "init", x = this.match("["), b = this.parseObjectPropertyKey(), D = this.parseGeneratorMethod(), T = !0;
              else if (b || this.throwUnexpectedToken(this.lookahead), g = "init", this.match(":") && !B)
                !x && this.isPropertyKey(b, "__proto__") && (d.value && this.tolerateError(a.Messages.DuplicateProtoProperty), d.value = !0),
                this.nextToken(), D = this.inheritCoverGrammar(this.parseAssignmentExpression);
              else if (this.match("("))
                D = B ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction(), T = !0;
              else if (p.type === 3) {
                var k = this.finalize(y, new o.Identifier(p.value));
                if (this.match("=")) {
                  this.context.firstCoverInitializedNameError = this.lookahead, this.nextToken(), w = !0;
                  var V = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  D = this.finalize(y, new o.AssignmentPattern(k, V));
                } else
                  w = !0, D = k;
              } else
                this.throwUnexpectedToken(this.nextToken());
              return this.finalize(y, new o.Property(g, b, x, D, T, w));
            }, h.prototype.parseObjectInitializer = function() {
              var d = this.createNode();
              this.expect("{");
              for (var y = [], p = { value: !1 }; !this.match("}"); )
                y.push(this.parseObjectProperty(p)), this.match("}") || this.expectCommaSeparator();
              return this.expect("}"), this.finalize(d, new o.ObjectExpression(y));
            }, h.prototype.parseTemplateHead = function() {
              i.assert(this.lookahead.head, "Template literal must start with a template head");
              var d = this.createNode(), y = this.nextToken(), p = y.value, g = y.cooked;
              return this.finalize(d, new o.TemplateElement({ raw: p, cooked: g }, y.tail));
            }, h.prototype.parseTemplateElement = function() {
              this.lookahead.type !== 10 && this.throwUnexpectedToken();
              var d = this.createNode(), y = this.nextToken(), p = y.value, g = y.cooked;
              return this.finalize(d, new o.TemplateElement({ raw: p, cooked: g }, y.tail));
            }, h.prototype.parseTemplateLiteral = function() {
              var d = this.createNode(), y = [], p = [], g = this.parseTemplateHead();
              for (p.push(g); !g.tail; )
                y.push(this.parseExpression()), g = this.parseTemplateElement(), p.push(g);
              return this.finalize(d, new o.TemplateLiteral(p, y));
            }, h.prototype.reinterpretExpressionAsPattern = function(d) {
              switch (d.type) {
                case l.Syntax.Identifier:
                case l.Syntax.MemberExpression:
                case l.Syntax.RestElement:
                case l.Syntax.AssignmentPattern:
                  break;
                case l.Syntax.SpreadElement:
                  d.type = l.Syntax.RestElement, this.reinterpretExpressionAsPattern(d.argument);
                  break;
                case l.Syntax.ArrayExpression:
                  d.type = l.Syntax.ArrayPattern;
                  for (var y = 0; y < d.elements.length; y++)
                    d.elements[y] !== null && this.reinterpretExpressionAsPattern(d.elements[y]);
                  break;
                case l.Syntax.ObjectExpression:
                  d.type = l.Syntax.ObjectPattern;
                  for (var y = 0; y < d.properties.length; y++)
                    this.reinterpretExpressionAsPattern(d.properties[y].value);
                  break;
                case l.Syntax.AssignmentExpression:
                  d.type = l.Syntax.AssignmentPattern, delete d.operator, this.reinterpretExpressionAsPattern(d.left);
                  break;
                default:
                  break;
              }
            }, h.prototype.parseGroupExpression = function() {
              var d;
              if (this.expect("("), this.match(")"))
                this.nextToken(), this.match("=>") || this.expect("=>"), d = {
                  type: f,
                  params: [],
                  async: !1
                };
              else {
                var y = this.lookahead, p = [];
                if (this.match("..."))
                  d = this.parseRestElement(p), this.expect(")"), this.match("=>") || this.expect("=>"), d = {
                    type: f,
                    params: [d],
                    async: !1
                  };
                else {
                  var g = !1;
                  if (this.context.isBindingElement = !0, d = this.inheritCoverGrammar(this.parseAssignmentExpression), this.match(",")) {
                    var b = [];
                    for (this.context.isAssignmentTarget = !1, b.push(d); this.lookahead.type !== 2 && this.match(","); ) {
                      if (this.nextToken(), this.match(")")) {
                        this.nextToken();
                        for (var D = 0; D < b.length; D++)
                          this.reinterpretExpressionAsPattern(b[D]);
                        g = !0, d = {
                          type: f,
                          params: b,
                          async: !1
                        };
                      } else if (this.match("...")) {
                        this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), b.push(this.parseRestElement(p)), this.expect(
                        ")"), this.match("=>") || this.expect("=>"), this.context.isBindingElement = !1;
                        for (var D = 0; D < b.length; D++)
                          this.reinterpretExpressionAsPattern(b[D]);
                        g = !0, d = {
                          type: f,
                          params: b,
                          async: !1
                        };
                      } else
                        b.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                      if (g)
                        break;
                    }
                    g || (d = this.finalize(this.startNode(y), new o.SequenceExpression(b)));
                  }
                  if (!g) {
                    if (this.expect(")"), this.match("=>") && (d.type === l.Syntax.Identifier && d.name === "yield" && (g = !0, d = {
                      type: f,
                      params: [d],
                      async: !1
                    }), !g)) {
                      if (this.context.isBindingElement || this.throwUnexpectedToken(this.lookahead), d.type === l.Syntax.SequenceExpression)
                        for (var D = 0; D < d.expressions.length; D++)
                          this.reinterpretExpressionAsPattern(d.expressions[D]);
                      else
                        this.reinterpretExpressionAsPattern(d);
                      var x = d.type === l.Syntax.SequenceExpression ? d.expressions : [d];
                      d = {
                        type: f,
                        params: x,
                        async: !1
                      };
                    }
                    this.context.isBindingElement = !1;
                  }
                }
              }
              return d;
            }, h.prototype.parseArguments = function() {
              this.expect("(");
              var d = [];
              if (!this.match(")"))
                for (; ; ) {
                  var y = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                  if (d.push(y), this.match(")") || (this.expectCommaSeparator(), this.match(")")))
                    break;
                }
              return this.expect(")"), d;
            }, h.prototype.isIdentifierName = function(d) {
              return d.type === 3 || d.type === 4 || d.type === 1 || d.type === 5;
            }, h.prototype.parseIdentifierName = function() {
              var d = this.createNode(), y = this.nextToken();
              return this.isIdentifierName(y) || this.throwUnexpectedToken(y), this.finalize(d, new o.Identifier(y.value));
            }, h.prototype.parseNewExpression = function() {
              var d = this.createNode(), y = this.parseIdentifierName();
              i.assert(y.name === "new", "New expression must start with `new`");
              var p;
              if (this.match("."))
                if (this.nextToken(), this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                  var g = this.parseIdentifierName();
                  p = new o.MetaProperty(y, g);
                } else
                  this.throwUnexpectedToken(this.lookahead);
              else {
                var b = this.isolateCoverGrammar(this.parseLeftHandSideExpression), D = this.match("(") ? this.parseArguments() : [];
                p = new o.NewExpression(b, D), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
              }
              return this.finalize(d, p);
            }, h.prototype.parseAsyncArgument = function() {
              var d = this.parseAssignmentExpression();
              return this.context.firstCoverInitializedNameError = null, d;
            }, h.prototype.parseAsyncArguments = function() {
              this.expect("(");
              var d = [];
              if (!this.match(")"))
                for (; ; ) {
                  var y = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                  if (d.push(y), this.match(")") || (this.expectCommaSeparator(), this.match(")")))
                    break;
                }
              return this.expect(")"), d;
            }, h.prototype.parseLeftHandSideExpressionAllowCall = function() {
              var d = this.lookahead, y = this.matchContextualKeyword("async"), p = this.context.allowIn;
              this.context.allowIn = !0;
              var g;
              for (this.matchKeyword("super") && this.context.inFunctionBody ? (g = this.createNode(), this.nextToken(), g = this.finalize(g,
              new o.Super()), !this.match("(") && !this.match(".") && !this.match("[") && this.throwUnexpectedToken(this.lookahead)) : g = this.
              inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; )
                if (this.match(".")) {
                  this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect(".");
                  var b = this.parseIdentifierName();
                  g = this.finalize(this.startNode(d), new o.StaticMemberExpression(g, b));
                } else if (this.match("(")) {
                  var D = y && d.lineNumber === this.lookahead.lineNumber;
                  this.context.isBindingElement = !1, this.context.isAssignmentTarget = !1;
                  var x = D ? this.parseAsyncArguments() : this.parseArguments();
                  if (g = this.finalize(this.startNode(d), new o.CallExpression(g, x)), D && this.match("=>")) {
                    for (var T = 0; T < x.length; ++T)
                      this.reinterpretExpressionAsPattern(x[T]);
                    g = {
                      type: f,
                      params: x,
                      async: !0
                    };
                  }
                } else if (this.match("[")) {
                  this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("[");
                  var b = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]"), g = this.finalize(this.startNode(d), new o.ComputedMemberExpression(g, b));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var w = this.parseTemplateLiteral();
                  g = this.finalize(this.startNode(d), new o.TaggedTemplateExpression(g, w));
                } else
                  break;
              return this.context.allowIn = p, g;
            }, h.prototype.parseSuper = function() {
              var d = this.createNode();
              return this.expectKeyword("super"), !this.match("[") && !this.match(".") && this.throwUnexpectedToken(this.lookahead), this.finalize(
              d, new o.Super());
            }, h.prototype.parseLeftHandSideExpression = function() {
              i.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
              for (var d = this.startNode(this.lookahead), y = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() :
              this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression); ; )
                if (this.match("[")) {
                  this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect("[");
                  var p = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]"), y = this.finalize(d, new o.ComputedMemberExpression(y, p));
                } else if (this.match(".")) {
                  this.context.isBindingElement = !1, this.context.isAssignmentTarget = !0, this.expect(".");
                  var p = this.parseIdentifierName();
                  y = this.finalize(d, new o.StaticMemberExpression(y, p));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var g = this.parseTemplateLiteral();
                  y = this.finalize(d, new o.TaggedTemplateExpression(y, g));
                } else
                  break;
              return y;
            }, h.prototype.parseUpdateExpression = function() {
              var d, y = this.lookahead;
              if (this.match("++") || this.match("--")) {
                var p = this.startNode(y), g = this.nextToken();
                d = this.inheritCoverGrammar(this.parseUnaryExpression), this.context.strict && d.type === l.Syntax.Identifier && this.scanner.
                isRestrictedWord(d.name) && this.tolerateError(a.Messages.StrictLHSPrefix), this.context.isAssignmentTarget || this.tolerateError(
                a.Messages.InvalidLHSInAssignment);
                var b = !0;
                d = this.finalize(p, new o.UpdateExpression(g.value, d, b)), this.context.isAssignmentTarget = !1, this.context.isBindingElement =
                !1;
              } else if (d = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall), !this.hasLineTerminator && this.lookahead.
              type === 7 && (this.match("++") || this.match("--"))) {
                this.context.strict && d.type === l.Syntax.Identifier && this.scanner.isRestrictedWord(d.name) && this.tolerateError(a.Messages.
                StrictLHSPostfix), this.context.isAssignmentTarget || this.tolerateError(a.Messages.InvalidLHSInAssignment), this.context.isAssignmentTarget =
                !1, this.context.isBindingElement = !1;
                var D = this.nextToken().value, b = !1;
                d = this.finalize(this.startNode(y), new o.UpdateExpression(D, d, b));
              }
              return d;
            }, h.prototype.parseAwaitExpression = function() {
              var d = this.createNode();
              this.nextToken();
              var y = this.parseUnaryExpression();
              return this.finalize(d, new o.AwaitExpression(y));
            }, h.prototype.parseUnaryExpression = function() {
              var d;
              if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword(
              "void") || this.matchKeyword("typeof")) {
                var y = this.startNode(this.lookahead), p = this.nextToken();
                d = this.inheritCoverGrammar(this.parseUnaryExpression), d = this.finalize(y, new o.UnaryExpression(p.value, d)), this.context.
                strict && d.operator === "delete" && d.argument.type === l.Syntax.Identifier && this.tolerateError(a.Messages.StrictDelete),
                this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
              } else this.context.await && this.matchContextualKeyword("await") ? d = this.parseAwaitExpression() : d = this.parseUpdateExpression();
              return d;
            }, h.prototype.parseExponentiationExpression = function() {
              var d = this.lookahead, y = this.inheritCoverGrammar(this.parseUnaryExpression);
              if (y.type !== l.Syntax.UnaryExpression && this.match("**")) {
                this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                var p = y, g = this.isolateCoverGrammar(this.parseExponentiationExpression);
                y = this.finalize(this.startNode(d), new o.BinaryExpression("**", p, g));
              }
              return y;
            }, h.prototype.binaryPrecedence = function(d) {
              var y = d.value, p;
              return d.type === 7 ? p = this.operatorPrecedence[y] || 0 : d.type === 4 ? p = y === "instanceof" || this.context.allowIn && y ===
              "in" ? 7 : 0 : p = 0, p;
            }, h.prototype.parseBinaryExpression = function() {
              var d = this.lookahead, y = this.inheritCoverGrammar(this.parseExponentiationExpression), p = this.lookahead, g = this.binaryPrecedence(
              p);
              if (g > 0) {
                this.nextToken(), this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                for (var b = [d, this.lookahead], D = y, x = this.isolateCoverGrammar(this.parseExponentiationExpression), T = [D, p.value, x],
                w = [g]; g = this.binaryPrecedence(this.lookahead), !(g <= 0); ) {
                  for (; T.length > 2 && g <= w[w.length - 1]; ) {
                    x = T.pop();
                    var B = T.pop();
                    w.pop(), D = T.pop(), b.pop();
                    var k = this.startNode(b[b.length - 1]);
                    T.push(this.finalize(k, new o.BinaryExpression(B, D, x)));
                  }
                  T.push(this.nextToken().value), w.push(g), b.push(this.lookahead), T.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                }
                var q = T.length - 1;
                y = T[q];
                for (var V = b.pop(); q > 1; ) {
                  var Y = b.pop(), G = V && V.lineStart, k = this.startNode(Y, G), B = T[q - 1];
                  y = this.finalize(k, new o.BinaryExpression(B, T[q - 2], y)), q -= 2, V = Y;
                }
              }
              return y;
            }, h.prototype.parseConditionalExpression = function() {
              var d = this.lookahead, y = this.inheritCoverGrammar(this.parseBinaryExpression);
              if (this.match("?")) {
                this.nextToken();
                var p = this.context.allowIn;
                this.context.allowIn = !0;
                var g = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowIn = p, this.expect(":");
                var b = this.isolateCoverGrammar(this.parseAssignmentExpression);
                y = this.finalize(this.startNode(d), new o.ConditionalExpression(y, g, b)), this.context.isAssignmentTarget = !1, this.context.
                isBindingElement = !1;
              }
              return y;
            }, h.prototype.checkPatternParam = function(d, y) {
              switch (y.type) {
                case l.Syntax.Identifier:
                  this.validateParam(d, y, y.name);
                  break;
                case l.Syntax.RestElement:
                  this.checkPatternParam(d, y.argument);
                  break;
                case l.Syntax.AssignmentPattern:
                  this.checkPatternParam(d, y.left);
                  break;
                case l.Syntax.ArrayPattern:
                  for (var p = 0; p < y.elements.length; p++)
                    y.elements[p] !== null && this.checkPatternParam(d, y.elements[p]);
                  break;
                case l.Syntax.ObjectPattern:
                  for (var p = 0; p < y.properties.length; p++)
                    this.checkPatternParam(d, y.properties[p].value);
                  break;
                default:
                  break;
              }
              d.simple = d.simple && y instanceof o.Identifier;
            }, h.prototype.reinterpretAsCoverFormalsList = function(d) {
              var y = [d], p, g = !1;
              switch (d.type) {
                case l.Syntax.Identifier:
                  break;
                case f:
                  y = d.params, g = d.async;
                  break;
                default:
                  return null;
              }
              p = {
                simple: !0,
                paramSet: {}
              };
              for (var b = 0; b < y.length; ++b) {
                var D = y[b];
                D.type === l.Syntax.AssignmentPattern ? D.right.type === l.Syntax.YieldExpression && (D.right.argument && this.throwUnexpectedToken(
                this.lookahead), D.right.type = l.Syntax.Identifier, D.right.name = "yield", delete D.right.argument, delete D.right.delegate) :
                g && D.type === l.Syntax.Identifier && D.name === "await" && this.throwUnexpectedToken(this.lookahead), this.checkPatternParam(
                p, D), y[b] = D;
              }
              if (this.context.strict || !this.context.allowYield)
                for (var b = 0; b < y.length; ++b) {
                  var D = y[b];
                  D.type === l.Syntax.YieldExpression && this.throwUnexpectedToken(this.lookahead);
                }
              if (p.message === a.Messages.StrictParamDupe) {
                var x = this.context.strict ? p.stricted : p.firstRestricted;
                this.throwUnexpectedToken(x, p.message);
              }
              return {
                simple: p.simple,
                params: y,
                stricted: p.stricted,
                firstRestricted: p.firstRestricted,
                message: p.message
              };
            }, h.prototype.parseAssignmentExpression = function() {
              var d;
              if (!this.context.allowYield && this.matchKeyword("yield"))
                d = this.parseYieldExpression();
              else {
                var y = this.lookahead, p = y;
                if (d = this.parseConditionalExpression(), p.type === 3 && p.lineNumber === this.lookahead.lineNumber && p.value === "async" &&
                (this.lookahead.type === 3 || this.matchKeyword("yield"))) {
                  var g = this.parsePrimaryExpression();
                  this.reinterpretExpressionAsPattern(g), d = {
                    type: f,
                    params: [g],
                    async: !0
                  };
                }
                if (d.type === f || this.match("=>")) {
                  this.context.isAssignmentTarget = !1, this.context.isBindingElement = !1;
                  var b = d.async, D = this.reinterpretAsCoverFormalsList(d);
                  if (D) {
                    this.hasLineTerminator && this.tolerateUnexpectedToken(this.lookahead), this.context.firstCoverInitializedNameError = null;
                    var x = this.context.strict, T = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = D.simple;
                    var w = this.context.allowYield, B = this.context.await;
                    this.context.allowYield = !0, this.context.await = b;
                    var k = this.startNode(y);
                    this.expect("=>");
                    var q = void 0;
                    if (this.match("{")) {
                      var V = this.context.allowIn;
                      this.context.allowIn = !0, q = this.parseFunctionSourceElements(), this.context.allowIn = V;
                    } else
                      q = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    var Y = q.type !== l.Syntax.BlockStatement;
                    this.context.strict && D.firstRestricted && this.throwUnexpectedToken(D.firstRestricted, D.message), this.context.strict &&
                    D.stricted && this.tolerateUnexpectedToken(D.stricted, D.message), d = b ? this.finalize(k, new o.AsyncArrowFunctionExpression(
                    D.params, q, Y)) : this.finalize(k, new o.ArrowFunctionExpression(D.params, q, Y)), this.context.strict = x, this.context.
                    allowStrictDirective = T, this.context.allowYield = w, this.context.await = B;
                  }
                } else if (this.matchAssign()) {
                  if (this.context.isAssignmentTarget || this.tolerateError(a.Messages.InvalidLHSInAssignment), this.context.strict && d.type ===
                  l.Syntax.Identifier) {
                    var G = d;
                    this.scanner.isRestrictedWord(G.name) && this.tolerateUnexpectedToken(p, a.Messages.StrictLHSAssignment), this.scanner.isStrictModeReservedWord(
                    G.name) && this.tolerateUnexpectedToken(p, a.Messages.StrictReservedWord);
                  }
                  this.match("=") ? this.reinterpretExpressionAsPattern(d) : (this.context.isAssignmentTarget = !1, this.context.isBindingElement =
                  !1), p = this.nextToken();
                  var ye = p.value, te = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  d = this.finalize(this.startNode(y), new o.AssignmentExpression(ye, d, te)), this.context.firstCoverInitializedNameError =
                  null;
                }
              }
              return d;
            }, h.prototype.parseExpression = function() {
              var d = this.lookahead, y = this.isolateCoverGrammar(this.parseAssignmentExpression);
              if (this.match(",")) {
                var p = [];
                for (p.push(y); this.lookahead.type !== 2 && this.match(","); )
                  this.nextToken(), p.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                y = this.finalize(this.startNode(d), new o.SequenceExpression(p));
              }
              return y;
            }, h.prototype.parseStatementListItem = function() {
              var d;
              if (this.context.isAssignmentTarget = !0, this.context.isBindingElement = !0, this.lookahead.type === 4)
                switch (this.lookahead.value) {
                  case "export":
                    this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, a.Messages.IllegalExportDeclaration), d = this.parseExportDeclaration();
                    break;
                  case "import":
                    this.context.isModule || this.tolerateUnexpectedToken(this.lookahead, a.Messages.IllegalImportDeclaration), d = this.parseImportDeclaration();
                    break;
                  case "const":
                    d = this.parseLexicalDeclaration({ inFor: !1 });
                    break;
                  case "function":
                    d = this.parseFunctionDeclaration();
                    break;
                  case "class":
                    d = this.parseClassDeclaration();
                    break;
                  case "let":
                    d = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: !1 }) : this.parseStatement();
                    break;
                  default:
                    d = this.parseStatement();
                    break;
                }
              else
                d = this.parseStatement();
              return d;
            }, h.prototype.parseBlock = function() {
              var d = this.createNode();
              this.expect("{");
              for (var y = []; !this.match("}"); )
                y.push(this.parseStatementListItem());
              return this.expect("}"), this.finalize(d, new o.BlockStatement(y));
            }, h.prototype.parseLexicalBinding = function(d, y) {
              var p = this.createNode(), g = [], b = this.parsePattern(g, d);
              this.context.strict && b.type === l.Syntax.Identifier && this.scanner.isRestrictedWord(b.name) && this.tolerateError(a.Messages.
              StrictVarName);
              var D = null;
              return d === "const" ? !this.matchKeyword("in") && !this.matchContextualKeyword("of") && (this.match("=") ? (this.nextToken(),
              D = this.isolateCoverGrammar(this.parseAssignmentExpression)) : this.throwError(a.Messages.DeclarationMissingInitializer, "con\
st")) : (!y.inFor && b.type !== l.Syntax.Identifier || this.match("=")) && (this.expect("="), D = this.isolateCoverGrammar(this.parseAssignmentExpression)),
              this.finalize(p, new o.VariableDeclarator(b, D));
            }, h.prototype.parseBindingList = function(d, y) {
              for (var p = [this.parseLexicalBinding(d, y)]; this.match(","); )
                this.nextToken(), p.push(this.parseLexicalBinding(d, y));
              return p;
            }, h.prototype.isLexicalDeclaration = function() {
              var d = this.scanner.saveState();
              this.scanner.scanComments();
              var y = this.scanner.lex();
              return this.scanner.restoreState(d), y.type === 3 || y.type === 7 && y.value === "[" || y.type === 7 && y.value === "{" || y.type ===
              4 && y.value === "let" || y.type === 4 && y.value === "yield";
            }, h.prototype.parseLexicalDeclaration = function(d) {
              var y = this.createNode(), p = this.nextToken().value;
              i.assert(p === "let" || p === "const", "Lexical declaration must be either let or const");
              var g = this.parseBindingList(p, d);
              return this.consumeSemicolon(), this.finalize(y, new o.VariableDeclaration(g, p));
            }, h.prototype.parseBindingRestElement = function(d, y) {
              var p = this.createNode();
              this.expect("...");
              var g = this.parsePattern(d, y);
              return this.finalize(p, new o.RestElement(g));
            }, h.prototype.parseArrayPattern = function(d, y) {
              var p = this.createNode();
              this.expect("[");
              for (var g = []; !this.match("]"); )
                if (this.match(","))
                  this.nextToken(), g.push(null);
                else {
                  if (this.match("...")) {
                    g.push(this.parseBindingRestElement(d, y));
                    break;
                  } else
                    g.push(this.parsePatternWithDefault(d, y));
                  this.match("]") || this.expect(",");
                }
              return this.expect("]"), this.finalize(p, new o.ArrayPattern(g));
            }, h.prototype.parsePropertyPattern = function(d, y) {
              var p = this.createNode(), g = !1, b = !1, D = !1, x, T;
              if (this.lookahead.type === 3) {
                var w = this.lookahead;
                x = this.parseVariableIdentifier();
                var B = this.finalize(p, new o.Identifier(w.value));
                if (this.match("=")) {
                  d.push(w), b = !0, this.nextToken();
                  var k = this.parseAssignmentExpression();
                  T = this.finalize(this.startNode(w), new o.AssignmentPattern(B, k));
                } else this.match(":") ? (this.expect(":"), T = this.parsePatternWithDefault(d, y)) : (d.push(w), b = !0, T = B);
              } else
                g = this.match("["), x = this.parseObjectPropertyKey(), this.expect(":"), T = this.parsePatternWithDefault(d, y);
              return this.finalize(p, new o.Property("init", x, g, T, D, b));
            }, h.prototype.parseObjectPattern = function(d, y) {
              var p = this.createNode(), g = [];
              for (this.expect("{"); !this.match("}"); )
                g.push(this.parsePropertyPattern(d, y)), this.match("}") || this.expect(",");
              return this.expect("}"), this.finalize(p, new o.ObjectPattern(g));
            }, h.prototype.parsePattern = function(d, y) {
              var p;
              return this.match("[") ? p = this.parseArrayPattern(d, y) : this.match("{") ? p = this.parseObjectPattern(d, y) : (this.matchKeyword(
              "let") && (y === "const" || y === "let") && this.tolerateUnexpectedToken(this.lookahead, a.Messages.LetInLexicalBinding), d.push(
              this.lookahead), p = this.parseVariableIdentifier(y)), p;
            }, h.prototype.parsePatternWithDefault = function(d, y) {
              var p = this.lookahead, g = this.parsePattern(d, y);
              if (this.match("=")) {
                this.nextToken();
                var b = this.context.allowYield;
                this.context.allowYield = !0;
                var D = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowYield = b, g = this.finalize(this.startNode(p), new o.AssignmentPattern(g, D));
              }
              return g;
            }, h.prototype.parseVariableIdentifier = function(d) {
              var y = this.createNode(), p = this.nextToken();
              return p.type === 4 && p.value === "yield" ? this.context.strict ? this.tolerateUnexpectedToken(p, a.Messages.StrictReservedWord) :
              this.context.allowYield || this.throwUnexpectedToken(p) : p.type !== 3 ? this.context.strict && p.type === 4 && this.scanner.isStrictModeReservedWord(
              p.value) ? this.tolerateUnexpectedToken(p, a.Messages.StrictReservedWord) : (this.context.strict || p.value !== "let" || d !==
              "var") && this.throwUnexpectedToken(p) : (this.context.isModule || this.context.await) && p.type === 3 && p.value === "await" &&
              this.tolerateUnexpectedToken(p), this.finalize(y, new o.Identifier(p.value));
            }, h.prototype.parseVariableDeclaration = function(d) {
              var y = this.createNode(), p = [], g = this.parsePattern(p, "var");
              this.context.strict && g.type === l.Syntax.Identifier && this.scanner.isRestrictedWord(g.name) && this.tolerateError(a.Messages.
              StrictVarName);
              var b = null;
              return this.match("=") ? (this.nextToken(), b = this.isolateCoverGrammar(this.parseAssignmentExpression)) : g.type !== l.Syntax.
              Identifier && !d.inFor && this.expect("="), this.finalize(y, new o.VariableDeclarator(g, b));
            }, h.prototype.parseVariableDeclarationList = function(d) {
              var y = { inFor: d.inFor }, p = [];
              for (p.push(this.parseVariableDeclaration(y)); this.match(","); )
                this.nextToken(), p.push(this.parseVariableDeclaration(y));
              return p;
            }, h.prototype.parseVariableStatement = function() {
              var d = this.createNode();
              this.expectKeyword("var");
              var y = this.parseVariableDeclarationList({ inFor: !1 });
              return this.consumeSemicolon(), this.finalize(d, new o.VariableDeclaration(y, "var"));
            }, h.prototype.parseEmptyStatement = function() {
              var d = this.createNode();
              return this.expect(";"), this.finalize(d, new o.EmptyStatement());
            }, h.prototype.parseExpressionStatement = function() {
              var d = this.createNode(), y = this.parseExpression();
              return this.consumeSemicolon(), this.finalize(d, new o.ExpressionStatement(y));
            }, h.prototype.parseIfClause = function() {
              return this.context.strict && this.matchKeyword("function") && this.tolerateError(a.Messages.StrictFunction), this.parseStatement();
            }, h.prototype.parseIfStatement = function() {
              var d = this.createNode(), y, p = null;
              this.expectKeyword("if"), this.expect("(");
              var g = this.parseExpression();
              return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), y = this.finalize(this.createNode(),
              new o.EmptyStatement())) : (this.expect(")"), y = this.parseIfClause(), this.matchKeyword("else") && (this.nextToken(), p = this.
              parseIfClause())), this.finalize(d, new o.IfStatement(g, y, p));
            }, h.prototype.parseDoWhileStatement = function() {
              var d = this.createNode();
              this.expectKeyword("do");
              var y = this.context.inIteration;
              this.context.inIteration = !0;
              var p = this.parseStatement();
              this.context.inIteration = y, this.expectKeyword("while"), this.expect("(");
              var g = this.parseExpression();
              return !this.match(")") && this.config.tolerant ? this.tolerateUnexpectedToken(this.nextToken()) : (this.expect(")"), this.match(
              ";") && this.nextToken()), this.finalize(d, new o.DoWhileStatement(p, g));
            }, h.prototype.parseWhileStatement = function() {
              var d = this.createNode(), y;
              this.expectKeyword("while"), this.expect("(");
              var p = this.parseExpression();
              if (!this.match(")") && this.config.tolerant)
                this.tolerateUnexpectedToken(this.nextToken()), y = this.finalize(this.createNode(), new o.EmptyStatement());
              else {
                this.expect(")");
                var g = this.context.inIteration;
                this.context.inIteration = !0, y = this.parseStatement(), this.context.inIteration = g;
              }
              return this.finalize(d, new o.WhileStatement(p, y));
            }, h.prototype.parseForStatement = function() {
              var d = null, y = null, p = null, g = !0, b, D, x = this.createNode();
              if (this.expectKeyword("for"), this.expect("("), this.match(";"))
                this.nextToken();
              else if (this.matchKeyword("var")) {
                d = this.createNode(), this.nextToken();
                var T = this.context.allowIn;
                this.context.allowIn = !1;
                var w = this.parseVariableDeclarationList({ inFor: !0 });
                if (this.context.allowIn = T, w.length === 1 && this.matchKeyword("in")) {
                  var B = w[0];
                  B.init && (B.id.type === l.Syntax.ArrayPattern || B.id.type === l.Syntax.ObjectPattern || this.context.strict) && this.tolerateError(
                  a.Messages.ForInOfLoopInitializer, "for-in"), d = this.finalize(d, new o.VariableDeclaration(w, "var")), this.nextToken(),
                  b = d, D = this.parseExpression(), d = null;
                } else w.length === 1 && w[0].init === null && this.matchContextualKeyword("of") ? (d = this.finalize(d, new o.VariableDeclaration(
                w, "var")), this.nextToken(), b = d, D = this.parseAssignmentExpression(), d = null, g = !1) : (d = this.finalize(d, new o.VariableDeclaration(
                w, "var")), this.expect(";"));
              } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                d = this.createNode();
                var k = this.nextToken().value;
                if (!this.context.strict && this.lookahead.value === "in")
                  d = this.finalize(d, new o.Identifier(k)), this.nextToken(), b = d, D = this.parseExpression(), d = null;
                else {
                  var T = this.context.allowIn;
                  this.context.allowIn = !1;
                  var w = this.parseBindingList(k, { inFor: !0 });
                  this.context.allowIn = T, w.length === 1 && w[0].init === null && this.matchKeyword("in") ? (d = this.finalize(d, new o.VariableDeclaration(
                  w, k)), this.nextToken(), b = d, D = this.parseExpression(), d = null) : w.length === 1 && w[0].init === null && this.matchContextualKeyword(
                  "of") ? (d = this.finalize(d, new o.VariableDeclaration(w, k)), this.nextToken(), b = d, D = this.parseAssignmentExpression(),
                  d = null, g = !1) : (this.consumeSemicolon(), d = this.finalize(d, new o.VariableDeclaration(w, k)));
                }
              } else {
                var q = this.lookahead, T = this.context.allowIn;
                if (this.context.allowIn = !1, d = this.inheritCoverGrammar(this.parseAssignmentExpression), this.context.allowIn = T, this.
                matchKeyword("in"))
                  (!this.context.isAssignmentTarget || d.type === l.Syntax.AssignmentExpression) && this.tolerateError(a.Messages.InvalidLHSInForIn),
                  this.nextToken(), this.reinterpretExpressionAsPattern(d), b = d, D = this.parseExpression(), d = null;
                else if (this.matchContextualKeyword("of"))
                  (!this.context.isAssignmentTarget || d.type === l.Syntax.AssignmentExpression) && this.tolerateError(a.Messages.InvalidLHSInForLoop),
                  this.nextToken(), this.reinterpretExpressionAsPattern(d), b = d, D = this.parseAssignmentExpression(), d = null, g = !1;
                else {
                  if (this.match(",")) {
                    for (var V = [d]; this.match(","); )
                      this.nextToken(), V.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                    d = this.finalize(this.startNode(q), new o.SequenceExpression(V));
                  }
                  this.expect(";");
                }
              }
              typeof b > "u" && (this.match(";") || (y = this.parseExpression()), this.expect(";"), this.match(")") || (p = this.parseExpression()));
              var Y;
              if (!this.match(")") && this.config.tolerant)
                this.tolerateUnexpectedToken(this.nextToken()), Y = this.finalize(this.createNode(), new o.EmptyStatement());
              else {
                this.expect(")");
                var G = this.context.inIteration;
                this.context.inIteration = !0, Y = this.isolateCoverGrammar(this.parseStatement), this.context.inIteration = G;
              }
              return typeof b > "u" ? this.finalize(x, new o.ForStatement(d, y, p, Y)) : g ? this.finalize(x, new o.ForInStatement(b, D, Y)) :
              this.finalize(x, new o.ForOfStatement(b, D, Y));
            }, h.prototype.parseContinueStatement = function() {
              var d = this.createNode();
              this.expectKeyword("continue");
              var y = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var p = this.parseVariableIdentifier();
                y = p;
                var g = "$" + p.name;
                Object.prototype.hasOwnProperty.call(this.context.labelSet, g) || this.throwError(a.Messages.UnknownLabel, p.name);
              }
              return this.consumeSemicolon(), y === null && !this.context.inIteration && this.throwError(a.Messages.IllegalContinue), this.finalize(
              d, new o.ContinueStatement(y));
            }, h.prototype.parseBreakStatement = function() {
              var d = this.createNode();
              this.expectKeyword("break");
              var y = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var p = this.parseVariableIdentifier(), g = "$" + p.name;
                Object.prototype.hasOwnProperty.call(this.context.labelSet, g) || this.throwError(a.Messages.UnknownLabel, p.name), y = p;
              }
              return this.consumeSemicolon(), y === null && !this.context.inIteration && !this.context.inSwitch && this.throwError(a.Messages.
              IllegalBreak), this.finalize(d, new o.BreakStatement(y));
            }, h.prototype.parseReturnStatement = function() {
              this.context.inFunctionBody || this.tolerateError(a.Messages.IllegalReturn);
              var d = this.createNode();
              this.expectKeyword("return");
              var y = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type ===
              8 || this.lookahead.type === 10, p = y ? this.parseExpression() : null;
              return this.consumeSemicolon(), this.finalize(d, new o.ReturnStatement(p));
            }, h.prototype.parseWithStatement = function() {
              this.context.strict && this.tolerateError(a.Messages.StrictModeWith);
              var d = this.createNode(), y;
              this.expectKeyword("with"), this.expect("(");
              var p = this.parseExpression();
              return !this.match(")") && this.config.tolerant ? (this.tolerateUnexpectedToken(this.nextToken()), y = this.finalize(this.createNode(),
              new o.EmptyStatement())) : (this.expect(")"), y = this.parseStatement()), this.finalize(d, new o.WithStatement(p, y));
            }, h.prototype.parseSwitchCase = function() {
              var d = this.createNode(), y;
              this.matchKeyword("default") ? (this.nextToken(), y = null) : (this.expectKeyword("case"), y = this.parseExpression()), this.expect(
              ":");
              for (var p = []; !(this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")); )
                p.push(this.parseStatementListItem());
              return this.finalize(d, new o.SwitchCase(y, p));
            }, h.prototype.parseSwitchStatement = function() {
              var d = this.createNode();
              this.expectKeyword("switch"), this.expect("(");
              var y = this.parseExpression();
              this.expect(")");
              var p = this.context.inSwitch;
              this.context.inSwitch = !0;
              var g = [], b = !1;
              for (this.expect("{"); !this.match("}"); ) {
                var D = this.parseSwitchCase();
                D.test === null && (b && this.throwError(a.Messages.MultipleDefaultsInSwitch), b = !0), g.push(D);
              }
              return this.expect("}"), this.context.inSwitch = p, this.finalize(d, new o.SwitchStatement(y, g));
            }, h.prototype.parseLabelledStatement = function() {
              var d = this.createNode(), y = this.parseExpression(), p;
              if (y.type === l.Syntax.Identifier && this.match(":")) {
                this.nextToken();
                var g = y, b = "$" + g.name;
                Object.prototype.hasOwnProperty.call(this.context.labelSet, b) && this.throwError(a.Messages.Redeclaration, "Label", g.name),
                this.context.labelSet[b] = !0;
                var D = void 0;
                if (this.matchKeyword("class"))
                  this.tolerateUnexpectedToken(this.lookahead), D = this.parseClassDeclaration();
                else if (this.matchKeyword("function")) {
                  var x = this.lookahead, T = this.parseFunctionDeclaration();
                  this.context.strict ? this.tolerateUnexpectedToken(x, a.Messages.StrictFunction) : T.generator && this.tolerateUnexpectedToken(
                  x, a.Messages.GeneratorInLegacyContext), D = T;
                } else
                  D = this.parseStatement();
                delete this.context.labelSet[b], p = new o.LabeledStatement(g, D);
              } else
                this.consumeSemicolon(), p = new o.ExpressionStatement(y);
              return this.finalize(d, p);
            }, h.prototype.parseThrowStatement = function() {
              var d = this.createNode();
              this.expectKeyword("throw"), this.hasLineTerminator && this.throwError(a.Messages.NewlineAfterThrow);
              var y = this.parseExpression();
              return this.consumeSemicolon(), this.finalize(d, new o.ThrowStatement(y));
            }, h.prototype.parseCatchClause = function() {
              var d = this.createNode();
              this.expectKeyword("catch"), this.expect("("), this.match(")") && this.throwUnexpectedToken(this.lookahead);
              for (var y = [], p = this.parsePattern(y), g = {}, b = 0; b < y.length; b++) {
                var D = "$" + y[b].value;
                Object.prototype.hasOwnProperty.call(g, D) && this.tolerateError(a.Messages.DuplicateBinding, y[b].value), g[D] = !0;
              }
              this.context.strict && p.type === l.Syntax.Identifier && this.scanner.isRestrictedWord(p.name) && this.tolerateError(a.Messages.
              StrictCatchVariable), this.expect(")");
              var x = this.parseBlock();
              return this.finalize(d, new o.CatchClause(p, x));
            }, h.prototype.parseFinallyClause = function() {
              return this.expectKeyword("finally"), this.parseBlock();
            }, h.prototype.parseTryStatement = function() {
              var d = this.createNode();
              this.expectKeyword("try");
              var y = this.parseBlock(), p = this.matchKeyword("catch") ? this.parseCatchClause() : null, g = this.matchKeyword("finally") ?
              this.parseFinallyClause() : null;
              return !p && !g && this.throwError(a.Messages.NoCatchOrFinally), this.finalize(d, new o.TryStatement(y, p, g));
            }, h.prototype.parseDebuggerStatement = function() {
              var d = this.createNode();
              return this.expectKeyword("debugger"), this.consumeSemicolon(), this.finalize(d, new o.DebuggerStatement());
            }, h.prototype.parseStatement = function() {
              var d;
              switch (this.lookahead.type) {
                case 1:
                case 5:
                case 6:
                case 8:
                case 10:
                case 9:
                  d = this.parseExpressionStatement();
                  break;
                case 7:
                  var y = this.lookahead.value;
                  y === "{" ? d = this.parseBlock() : y === "(" ? d = this.parseExpressionStatement() : y === ";" ? d = this.parseEmptyStatement() :
                  d = this.parseExpressionStatement();
                  break;
                case 3:
                  d = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                  break;
                case 4:
                  switch (this.lookahead.value) {
                    case "break":
                      d = this.parseBreakStatement();
                      break;
                    case "continue":
                      d = this.parseContinueStatement();
                      break;
                    case "debugger":
                      d = this.parseDebuggerStatement();
                      break;
                    case "do":
                      d = this.parseDoWhileStatement();
                      break;
                    case "for":
                      d = this.parseForStatement();
                      break;
                    case "function":
                      d = this.parseFunctionDeclaration();
                      break;
                    case "if":
                      d = this.parseIfStatement();
                      break;
                    case "return":
                      d = this.parseReturnStatement();
                      break;
                    case "switch":
                      d = this.parseSwitchStatement();
                      break;
                    case "throw":
                      d = this.parseThrowStatement();
                      break;
                    case "try":
                      d = this.parseTryStatement();
                      break;
                    case "var":
                      d = this.parseVariableStatement();
                      break;
                    case "while":
                      d = this.parseWhileStatement();
                      break;
                    case "with":
                      d = this.parseWithStatement();
                      break;
                    default:
                      d = this.parseExpressionStatement();
                      break;
                  }
                  break;
                default:
                  d = this.throwUnexpectedToken(this.lookahead);
              }
              return d;
            }, h.prototype.parseFunctionSourceElements = function() {
              var d = this.createNode();
              this.expect("{");
              var y = this.parseDirectivePrologues(), p = this.context.labelSet, g = this.context.inIteration, b = this.context.inSwitch, D = this.
              context.inFunctionBody;
              for (this.context.labelSet = {}, this.context.inIteration = !1, this.context.inSwitch = !1, this.context.inFunctionBody = !0; this.
              lookahead.type !== 2 && !this.match("}"); )
                y.push(this.parseStatementListItem());
              return this.expect("}"), this.context.labelSet = p, this.context.inIteration = g, this.context.inSwitch = b, this.context.inFunctionBody =
              D, this.finalize(d, new o.BlockStatement(y));
            }, h.prototype.validateParam = function(d, y, p) {
              var g = "$" + p;
              this.context.strict ? (this.scanner.isRestrictedWord(p) && (d.stricted = y, d.message = a.Messages.StrictParamName), Object.prototype.
              hasOwnProperty.call(d.paramSet, g) && (d.stricted = y, d.message = a.Messages.StrictParamDupe)) : d.firstRestricted || (this.scanner.
              isRestrictedWord(p) ? (d.firstRestricted = y, d.message = a.Messages.StrictParamName) : this.scanner.isStrictModeReservedWord(
              p) ? (d.firstRestricted = y, d.message = a.Messages.StrictReservedWord) : Object.prototype.hasOwnProperty.call(d.paramSet, g) &&
              (d.stricted = y, d.message = a.Messages.StrictParamDupe)), typeof Object.defineProperty == "function" ? Object.defineProperty(
              d.paramSet, g, { value: !0, enumerable: !0, writable: !0, configurable: !0 }) : d.paramSet[g] = !0;
            }, h.prototype.parseRestElement = function(d) {
              var y = this.createNode();
              this.expect("...");
              var p = this.parsePattern(d);
              return this.match("=") && this.throwError(a.Messages.DefaultRestParameter), this.match(")") || this.throwError(a.Messages.ParameterAfterRestParameter),
              this.finalize(y, new o.RestElement(p));
            }, h.prototype.parseFormalParameter = function(d) {
              for (var y = [], p = this.match("...") ? this.parseRestElement(y) : this.parsePatternWithDefault(y), g = 0; g < y.length; g++)
                this.validateParam(d, y[g], y[g].value);
              d.simple = d.simple && p instanceof o.Identifier, d.params.push(p);
            }, h.prototype.parseFormalParameters = function(d) {
              var y;
              if (y = {
                simple: !0,
                params: [],
                firstRestricted: d
              }, this.expect("("), !this.match(")"))
                for (y.paramSet = {}; this.lookahead.type !== 2 && (this.parseFormalParameter(y), !(this.match(")") || (this.expect(","), this.
                match(")")))); )
                  ;
              return this.expect(")"), {
                simple: y.simple,
                params: y.params,
                stricted: y.stricted,
                firstRestricted: y.firstRestricted,
                message: y.message
              };
            }, h.prototype.matchAsyncFunction = function() {
              var d = this.matchContextualKeyword("async");
              if (d) {
                var y = this.scanner.saveState();
                this.scanner.scanComments();
                var p = this.scanner.lex();
                this.scanner.restoreState(y), d = y.lineNumber === p.lineNumber && p.type === 4 && p.value === "function";
              }
              return d;
            }, h.prototype.parseFunctionDeclaration = function(d) {
              var y = this.createNode(), p = this.matchContextualKeyword("async");
              p && this.nextToken(), this.expectKeyword("function");
              var g = p ? !1 : this.match("*");
              g && this.nextToken();
              var b, D = null, x = null;
              if (!d || !this.match("(")) {
                var T = this.lookahead;
                D = this.parseVariableIdentifier(), this.context.strict ? this.scanner.isRestrictedWord(T.value) && this.tolerateUnexpectedToken(
                T, a.Messages.StrictFunctionName) : this.scanner.isRestrictedWord(T.value) ? (x = T, b = a.Messages.StrictFunctionName) : this.
                scanner.isStrictModeReservedWord(T.value) && (x = T, b = a.Messages.StrictReservedWord);
              }
              var w = this.context.await, B = this.context.allowYield;
              this.context.await = p, this.context.allowYield = !g;
              var k = this.parseFormalParameters(x), q = k.params, V = k.stricted;
              x = k.firstRestricted, k.message && (b = k.message);
              var Y = this.context.strict, G = this.context.allowStrictDirective;
              this.context.allowStrictDirective = k.simple;
              var ye = this.parseFunctionSourceElements();
              return this.context.strict && x && this.throwUnexpectedToken(x, b), this.context.strict && V && this.tolerateUnexpectedToken(V,
              b), this.context.strict = Y, this.context.allowStrictDirective = G, this.context.await = w, this.context.allowYield = B, p ? this.
              finalize(y, new o.AsyncFunctionDeclaration(D, q, ye)) : this.finalize(y, new o.FunctionDeclaration(D, q, ye, g));
            }, h.prototype.parseFunctionExpression = function() {
              var d = this.createNode(), y = this.matchContextualKeyword("async");
              y && this.nextToken(), this.expectKeyword("function");
              var p = y ? !1 : this.match("*");
              p && this.nextToken();
              var g, b = null, D, x = this.context.await, T = this.context.allowYield;
              if (this.context.await = y, this.context.allowYield = !p, !this.match("(")) {
                var w = this.lookahead;
                b = !this.context.strict && !p && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier(), this.
                context.strict ? this.scanner.isRestrictedWord(w.value) && this.tolerateUnexpectedToken(w, a.Messages.StrictFunctionName) : this.
                scanner.isRestrictedWord(w.value) ? (D = w, g = a.Messages.StrictFunctionName) : this.scanner.isStrictModeReservedWord(w.value) &&
                (D = w, g = a.Messages.StrictReservedWord);
              }
              var B = this.parseFormalParameters(D), k = B.params, q = B.stricted;
              D = B.firstRestricted, B.message && (g = B.message);
              var V = this.context.strict, Y = this.context.allowStrictDirective;
              this.context.allowStrictDirective = B.simple;
              var G = this.parseFunctionSourceElements();
              return this.context.strict && D && this.throwUnexpectedToken(D, g), this.context.strict && q && this.tolerateUnexpectedToken(q,
              g), this.context.strict = V, this.context.allowStrictDirective = Y, this.context.await = x, this.context.allowYield = T, y ? this.
              finalize(d, new o.AsyncFunctionExpression(b, k, G)) : this.finalize(d, new o.FunctionExpression(b, k, G, p));
            }, h.prototype.parseDirective = function() {
              var d = this.lookahead, y = this.createNode(), p = this.parseExpression(), g = p.type === l.Syntax.Literal ? this.getTokenRaw(
              d).slice(1, -1) : null;
              return this.consumeSemicolon(), this.finalize(y, g ? new o.Directive(p, g) : new o.ExpressionStatement(p));
            }, h.prototype.parseDirectivePrologues = function() {
              for (var d = null, y = []; ; ) {
                var p = this.lookahead;
                if (p.type !== 8)
                  break;
                var g = this.parseDirective();
                y.push(g);
                var b = g.directive;
                if (typeof b != "string")
                  break;
                b === "use strict" ? (this.context.strict = !0, d && this.tolerateUnexpectedToken(d, a.Messages.StrictOctalLiteral), this.context.
                allowStrictDirective || this.tolerateUnexpectedToken(p, a.Messages.IllegalLanguageModeDirective)) : !d && p.octal && (d = p);
              }
              return y;
            }, h.prototype.qualifiedPropertyName = function(d) {
              switch (d.type) {
                case 3:
                case 8:
                case 1:
                case 5:
                case 6:
                case 4:
                  return !0;
                case 7:
                  return d.value === "[";
                default:
                  break;
              }
              return !1;
            }, h.prototype.parseGetterMethod = function() {
              var d = this.createNode(), y = !1, p = this.context.allowYield;
              this.context.allowYield = !y;
              var g = this.parseFormalParameters();
              g.params.length > 0 && this.tolerateError(a.Messages.BadGetterArity);
              var b = this.parsePropertyMethod(g);
              return this.context.allowYield = p, this.finalize(d, new o.FunctionExpression(null, g.params, b, y));
            }, h.prototype.parseSetterMethod = function() {
              var d = this.createNode(), y = !1, p = this.context.allowYield;
              this.context.allowYield = !y;
              var g = this.parseFormalParameters();
              g.params.length !== 1 ? this.tolerateError(a.Messages.BadSetterArity) : g.params[0] instanceof o.RestElement && this.tolerateError(
              a.Messages.BadSetterRestParameter);
              var b = this.parsePropertyMethod(g);
              return this.context.allowYield = p, this.finalize(d, new o.FunctionExpression(null, g.params, b, y));
            }, h.prototype.parseGeneratorMethod = function() {
              var d = this.createNode(), y = !0, p = this.context.allowYield;
              this.context.allowYield = !0;
              var g = this.parseFormalParameters();
              this.context.allowYield = !1;
              var b = this.parsePropertyMethod(g);
              return this.context.allowYield = p, this.finalize(d, new o.FunctionExpression(null, g.params, b, y));
            }, h.prototype.isStartOfExpression = function() {
              var d = !0, y = this.lookahead.value;
              switch (this.lookahead.type) {
                case 7:
                  d = y === "[" || y === "(" || y === "{" || y === "+" || y === "-" || y === "!" || y === "~" || y === "++" || y === "--" ||
                  y === "/" || y === "/=";
                  break;
                case 4:
                  d = y === "class" || y === "delete" || y === "function" || y === "let" || y === "new" || y === "super" || y === "this" || y ===
                  "typeof" || y === "void" || y === "yield";
                  break;
                default:
                  break;
              }
              return d;
            }, h.prototype.parseYieldExpression = function() {
              var d = this.createNode();
              this.expectKeyword("yield");
              var y = null, p = !1;
              if (!this.hasLineTerminator) {
                var g = this.context.allowYield;
                this.context.allowYield = !1, p = this.match("*"), p ? (this.nextToken(), y = this.parseAssignmentExpression()) : this.isStartOfExpression() &&
                (y = this.parseAssignmentExpression()), this.context.allowYield = g;
              }
              return this.finalize(d, new o.YieldExpression(y, p));
            }, h.prototype.parseClassElement = function(d) {
              var y = this.lookahead, p = this.createNode(), g = "", b = null, D = null, x = !1, T = !1, w = !1, B = !1;
              if (this.match("*"))
                this.nextToken();
              else {
                x = this.match("["), b = this.parseObjectPropertyKey();
                var k = b;
                if (k.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*")) && (y = this.lookahead, w = !0, x =
                this.match("["), this.match("*") ? this.nextToken() : b = this.parseObjectPropertyKey()), y.type === 3 && !this.hasLineTerminator &&
                y.value === "async") {
                  var q = this.lookahead.value;
                  q !== ":" && q !== "(" && q !== "*" && (B = !0, y = this.lookahead, b = this.parseObjectPropertyKey(), y.type === 3 && y.value ===
                  "constructor" && this.tolerateUnexpectedToken(y, a.Messages.ConstructorIsAsync));
                }
              }
              var V = this.qualifiedPropertyName(this.lookahead);
              return y.type === 3 ? y.value === "get" && V ? (g = "get", x = this.match("["), b = this.parseObjectPropertyKey(), this.context.
              allowYield = !1, D = this.parseGetterMethod()) : y.value === "set" && V && (g = "set", x = this.match("["), b = this.parseObjectPropertyKey(),
              D = this.parseSetterMethod()) : y.type === 7 && y.value === "*" && V && (g = "init", x = this.match("["), b = this.parseObjectPropertyKey(),
              D = this.parseGeneratorMethod(), T = !0), !g && b && this.match("(") && (g = "init", D = B ? this.parsePropertyMethodAsyncFunction() :
              this.parsePropertyMethodFunction(), T = !0), g || this.throwUnexpectedToken(this.lookahead), g === "init" && (g = "method"), x ||
              (w && this.isPropertyKey(b, "prototype") && this.throwUnexpectedToken(y, a.Messages.StaticPrototype), !w && this.isPropertyKey(
              b, "constructor") && ((g !== "method" || !T || D && D.generator) && this.throwUnexpectedToken(y, a.Messages.ConstructorSpecialMethod),
              d.value ? this.throwUnexpectedToken(y, a.Messages.DuplicateConstructor) : d.value = !0, g = "constructor")), this.finalize(p, new o.
              MethodDefinition(b, x, D, g, w));
            }, h.prototype.parseClassElementList = function() {
              var d = [], y = { value: !1 };
              for (this.expect("{"); !this.match("}"); )
                this.match(";") ? this.nextToken() : d.push(this.parseClassElement(y));
              return this.expect("}"), d;
            }, h.prototype.parseClassBody = function() {
              var d = this.createNode(), y = this.parseClassElementList();
              return this.finalize(d, new o.ClassBody(y));
            }, h.prototype.parseClassDeclaration = function(d) {
              var y = this.createNode(), p = this.context.strict;
              this.context.strict = !0, this.expectKeyword("class");
              var g = d && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier(), b = null;
              this.matchKeyword("extends") && (this.nextToken(), b = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
              var D = this.parseClassBody();
              return this.context.strict = p, this.finalize(y, new o.ClassDeclaration(g, b, D));
            }, h.prototype.parseClassExpression = function() {
              var d = this.createNode(), y = this.context.strict;
              this.context.strict = !0, this.expectKeyword("class");
              var p = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null, g = null;
              this.matchKeyword("extends") && (this.nextToken(), g = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall));
              var b = this.parseClassBody();
              return this.context.strict = y, this.finalize(d, new o.ClassExpression(p, g, b));
            }, h.prototype.parseModule = function() {
              this.context.strict = !0, this.context.isModule = !0, this.scanner.isModule = !0;
              for (var d = this.createNode(), y = this.parseDirectivePrologues(); this.lookahead.type !== 2; )
                y.push(this.parseStatementListItem());
              return this.finalize(d, new o.Module(y));
            }, h.prototype.parseScript = function() {
              for (var d = this.createNode(), y = this.parseDirectivePrologues(); this.lookahead.type !== 2; )
                y.push(this.parseStatementListItem());
              return this.finalize(d, new o.Script(y));
            }, h.prototype.parseModuleSpecifier = function() {
              var d = this.createNode();
              this.lookahead.type !== 8 && this.throwError(a.Messages.InvalidModuleSpecifier);
              var y = this.nextToken(), p = this.getTokenRaw(y);
              return this.finalize(d, new o.Literal(y.value, p));
            }, h.prototype.parseImportSpecifier = function() {
              var d = this.createNode(), y, p;
              return this.lookahead.type === 3 ? (y = this.parseVariableIdentifier(), p = y, this.matchContextualKeyword("as") && (this.nextToken(),
              p = this.parseVariableIdentifier())) : (y = this.parseIdentifierName(), p = y, this.matchContextualKeyword("as") ? (this.nextToken(),
              p = this.parseVariableIdentifier()) : this.throwUnexpectedToken(this.nextToken())), this.finalize(d, new o.ImportSpecifier(p, y));
            }, h.prototype.parseNamedImports = function() {
              this.expect("{");
              for (var d = []; !this.match("}"); )
                d.push(this.parseImportSpecifier()), this.match("}") || this.expect(",");
              return this.expect("}"), d;
            }, h.prototype.parseImportDefaultSpecifier = function() {
              var d = this.createNode(), y = this.parseIdentifierName();
              return this.finalize(d, new o.ImportDefaultSpecifier(y));
            }, h.prototype.parseImportNamespaceSpecifier = function() {
              var d = this.createNode();
              this.expect("*"), this.matchContextualKeyword("as") || this.throwError(a.Messages.NoAsAfterImportNamespace), this.nextToken();
              var y = this.parseIdentifierName();
              return this.finalize(d, new o.ImportNamespaceSpecifier(y));
            }, h.prototype.parseImportDeclaration = function() {
              this.context.inFunctionBody && this.throwError(a.Messages.IllegalImportDeclaration);
              var d = this.createNode();
              this.expectKeyword("import");
              var y, p = [];
              if (this.lookahead.type === 8)
                y = this.parseModuleSpecifier();
              else {
                if (this.match("{") ? p = p.concat(this.parseNamedImports()) : this.match("*") ? p.push(this.parseImportNamespaceSpecifier()) :
                this.isIdentifierName(this.lookahead) && !this.matchKeyword("default") ? (p.push(this.parseImportDefaultSpecifier()), this.match(
                ",") && (this.nextToken(), this.match("*") ? p.push(this.parseImportNamespaceSpecifier()) : this.match("{") ? p = p.concat(this.
                parseNamedImports()) : this.throwUnexpectedToken(this.lookahead))) : this.throwUnexpectedToken(this.nextToken()), !this.matchContextualKeyword(
                "from")) {
                  var g = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause;
                  this.throwError(g, this.lookahead.value);
                }
                this.nextToken(), y = this.parseModuleSpecifier();
              }
              return this.consumeSemicolon(), this.finalize(d, new o.ImportDeclaration(p, y));
            }, h.prototype.parseExportSpecifier = function() {
              var d = this.createNode(), y = this.parseIdentifierName(), p = y;
              return this.matchContextualKeyword("as") && (this.nextToken(), p = this.parseIdentifierName()), this.finalize(d, new o.ExportSpecifier(
              y, p));
            }, h.prototype.parseExportDeclaration = function() {
              this.context.inFunctionBody && this.throwError(a.Messages.IllegalExportDeclaration);
              var d = this.createNode();
              this.expectKeyword("export");
              var y;
              if (this.matchKeyword("default"))
                if (this.nextToken(), this.matchKeyword("function")) {
                  var p = this.parseFunctionDeclaration(!0);
                  y = this.finalize(d, new o.ExportDefaultDeclaration(p));
                } else if (this.matchKeyword("class")) {
                  var p = this.parseClassDeclaration(!0);
                  y = this.finalize(d, new o.ExportDefaultDeclaration(p));
                } else if (this.matchContextualKeyword("async")) {
                  var p = this.matchAsyncFunction() ? this.parseFunctionDeclaration(!0) : this.parseAssignmentExpression();
                  y = this.finalize(d, new o.ExportDefaultDeclaration(p));
                } else {
                  this.matchContextualKeyword("from") && this.throwError(a.Messages.UnexpectedToken, this.lookahead.value);
                  var p = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                  this.consumeSemicolon(), y = this.finalize(d, new o.ExportDefaultDeclaration(p));
                }
              else if (this.match("*")) {
                if (this.nextToken(), !this.matchContextualKeyword("from")) {
                  var g = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause;
                  this.throwError(g, this.lookahead.value);
                }
                this.nextToken();
                var b = this.parseModuleSpecifier();
                this.consumeSemicolon(), y = this.finalize(d, new o.ExportAllDeclaration(b));
              } else if (this.lookahead.type === 4) {
                var p = void 0;
                switch (this.lookahead.value) {
                  case "let":
                  case "const":
                    p = this.parseLexicalDeclaration({ inFor: !1 });
                    break;
                  case "var":
                  case "class":
                  case "function":
                    p = this.parseStatementListItem();
                    break;
                  default:
                    this.throwUnexpectedToken(this.lookahead);
                }
                y = this.finalize(d, new o.ExportNamedDeclaration(p, [], null));
              } else if (this.matchAsyncFunction()) {
                var p = this.parseFunctionDeclaration();
                y = this.finalize(d, new o.ExportNamedDeclaration(p, [], null));
              } else {
                var D = [], x = null, T = !1;
                for (this.expect("{"); !this.match("}"); )
                  T = T || this.matchKeyword("default"), D.push(this.parseExportSpecifier()), this.match("}") || this.expect(",");
                if (this.expect("}"), this.matchContextualKeyword("from"))
                  this.nextToken(), x = this.parseModuleSpecifier(), this.consumeSemicolon();
                else if (T) {
                  var g = this.lookahead.value ? a.Messages.UnexpectedToken : a.Messages.MissingFromClause;
                  this.throwError(g, this.lookahead.value);
                } else
                  this.consumeSemicolon();
                y = this.finalize(d, new o.ExportNamedDeclaration(null, D, x));
              }
              return y;
            }, h;
          }();
          t.Parser = m;
        },
        /* 9 */
        /***/
        function(e, t) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 });
          function r(i, s) {
            if (!i)
              throw new Error("ASSERT: " + s);
          }
          n(r, "assert"), t.assert = r;
        },
        /* 10 */
        /***/
        function(e, t) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 });
          var r = function() {
            function i() {
              this.errors = [], this.tolerant = !1;
            }
            return n(i, "ErrorHandler"), i.prototype.recordError = function(s) {
              this.errors.push(s);
            }, i.prototype.tolerate = function(s) {
              if (this.tolerant)
                this.recordError(s);
              else
                throw s;
            }, i.prototype.constructError = function(s, a) {
              var o = new Error(s);
              try {
                throw o;
              } catch (u) {
                Object.create && Object.defineProperty && (o = Object.create(u), Object.defineProperty(o, "column", { value: a }));
              }
              return o;
            }, i.prototype.createError = function(s, a, o, u) {
              var l = "Line " + a + ": " + u, c = this.constructError(l, o);
              return c.index = s, c.lineNumber = a, c.description = u, c;
            }, i.prototype.throwError = function(s, a, o, u) {
              throw this.createError(s, a, o, u);
            }, i.prototype.tolerateError = function(s, a, o, u) {
              var l = this.createError(s, a, o, u);
              if (this.tolerant)
                this.recordError(l);
              else
                throw l;
            }, i;
          }();
          t.ErrorHandler = r;
        },
        /* 11 */
        /***/
        function(e, t) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 }), t.Messages = {
            BadGetterArity: "Getter must not have any formal parameters",
            BadSetterArity: "Setter must have exactly one formal parameter",
            BadSetterRestParameter: "Setter function argument must not be a rest parameter",
            ConstructorIsAsync: "Class constructor may not be an async method",
            ConstructorSpecialMethod: "Class constructor may not be an accessor",
            DeclarationMissingInitializer: "Missing initializer in %0 declaration",
            DefaultRestParameter: "Unexpected token =",
            DuplicateBinding: "Duplicate binding %0",
            DuplicateConstructor: "A class may only have one constructor",
            DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
            ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
            GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
            IllegalBreak: "Illegal break statement",
            IllegalContinue: "Illegal continue statement",
            IllegalExportDeclaration: "Unexpected token",
            IllegalImportDeclaration: "Unexpected token",
            IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
            IllegalReturn: "Illegal return statement",
            InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
            InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
            InvalidModuleSpecifier: "Unexpected token",
            InvalidRegExp: "Invalid regular expression",
            LetInLexicalBinding: "let is disallowed as a lexically bound name",
            MissingFromClause: "Unexpected token",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NewlineAfterThrow: "Illegal newline after throw",
            NoAsAfterImportNamespace: "Unexpected token",
            NoCatchOrFinally: "Missing catch or finally after try",
            ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
            Redeclaration: "%0 '%1' has already been declared",
            StaticPrototype: "Classes may not have static property named prototype",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
            UnexpectedEOS: "Unexpected end of input",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedNumber: "Unexpected number",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedString: "Unexpected string",
            UnexpectedTemplate: "Unexpected quasi %0",
            UnexpectedToken: "Unexpected token %0",
            UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
            UnknownLabel: "Undefined label '%0'",
            UnterminatedRegExp: "Invalid regular expression: missing /"
          };
        },
        /* 12 */
        /***/
        function(e, t, r) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 });
          var i = r(9), s = r(4), a = r(11);
          function o(c) {
            return "0123456789abcdef".indexOf(c.toLowerCase());
          }
          n(o, "hexValue");
          function u(c) {
            return "01234567".indexOf(c);
          }
          n(u, "octalValue");
          var l = function() {
            function c(f, m) {
              this.source = f, this.errorHandler = m, this.trackComment = !1, this.isModule = !1, this.length = f.length, this.index = 0, this.
              lineNumber = f.length > 0 ? 1 : 0, this.lineStart = 0, this.curlyStack = [];
            }
            return n(c, "Scanner"), c.prototype.saveState = function() {
              return {
                index: this.index,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart
              };
            }, c.prototype.restoreState = function(f) {
              this.index = f.index, this.lineNumber = f.lineNumber, this.lineStart = f.lineStart;
            }, c.prototype.eof = function() {
              return this.index >= this.length;
            }, c.prototype.throwUnexpectedToken = function(f) {
              return f === void 0 && (f = a.Messages.UnexpectedTokenIllegal), this.errorHandler.throwError(this.index, this.lineNumber, this.
              index - this.lineStart + 1, f);
            }, c.prototype.tolerateUnexpectedToken = function(f) {
              f === void 0 && (f = a.Messages.UnexpectedTokenIllegal), this.errorHandler.tolerateError(this.index, this.lineNumber, this.index -
              this.lineStart + 1, f);
            }, c.prototype.skipSingleLineComment = function(f) {
              var m = [], h, d;
              for (this.trackComment && (m = [], h = this.index - f, d = {
                start: {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - f
                },
                end: {}
              }); !this.eof(); ) {
                var y = this.source.charCodeAt(this.index);
                if (++this.index, s.Character.isLineTerminator(y)) {
                  if (this.trackComment) {
                    d.end = {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - 1
                    };
                    var p = {
                      multiLine: !1,
                      slice: [h + f, this.index - 1],
                      range: [h, this.index - 1],
                      loc: d
                    };
                    m.push(p);
                  }
                  return y === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.index,
                  m;
                }
              }
              if (this.trackComment) {
                d.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var p = {
                  multiLine: !1,
                  slice: [h + f, this.index],
                  range: [h, this.index],
                  loc: d
                };
                m.push(p);
              }
              return m;
            }, c.prototype.skipMultiLineComment = function() {
              var f = [], m, h;
              for (this.trackComment && (f = [], m = this.index - 2, h = {
                start: {
                  line: this.lineNumber,
                  column: this.index - this.lineStart - 2
                },
                end: {}
              }); !this.eof(); ) {
                var d = this.source.charCodeAt(this.index);
                if (s.Character.isLineTerminator(d))
                  d === 13 && this.source.charCodeAt(this.index + 1) === 10 && ++this.index, ++this.lineNumber, ++this.index, this.lineStart =
                  this.index;
                else if (d === 42) {
                  if (this.source.charCodeAt(this.index + 1) === 47) {
                    if (this.index += 2, this.trackComment) {
                      h.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart
                      };
                      var y = {
                        multiLine: !0,
                        slice: [m + 2, this.index - 2],
                        range: [m, this.index],
                        loc: h
                      };
                      f.push(y);
                    }
                    return f;
                  }
                  ++this.index;
                } else
                  ++this.index;
              }
              if (this.trackComment) {
                h.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var y = {
                  multiLine: !0,
                  slice: [m + 2, this.index],
                  range: [m, this.index],
                  loc: h
                };
                f.push(y);
              }
              return this.tolerateUnexpectedToken(), f;
            }, c.prototype.scanComments = function() {
              var f;
              this.trackComment && (f = []);
              for (var m = this.index === 0; !this.eof(); ) {
                var h = this.source.charCodeAt(this.index);
                if (s.Character.isWhiteSpace(h))
                  ++this.index;
                else if (s.Character.isLineTerminator(h))
                  ++this.index, h === 13 && this.source.charCodeAt(this.index) === 10 && ++this.index, ++this.lineNumber, this.lineStart = this.
                  index, m = !0;
                else if (h === 47)
                  if (h = this.source.charCodeAt(this.index + 1), h === 47) {
                    this.index += 2;
                    var d = this.skipSingleLineComment(2);
                    this.trackComment && (f = f.concat(d)), m = !0;
                  } else if (h === 42) {
                    this.index += 2;
                    var d = this.skipMultiLineComment();
                    this.trackComment && (f = f.concat(d));
                  } else
                    break;
                else if (m && h === 45)
                  if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                    this.index += 3;
                    var d = this.skipSingleLineComment(3);
                    this.trackComment && (f = f.concat(d));
                  } else
                    break;
                else if (h === 60 && !this.isModule)
                  if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                    this.index += 4;
                    var d = this.skipSingleLineComment(4);
                    this.trackComment && (f = f.concat(d));
                  } else
                    break;
                else
                  break;
              }
              return f;
            }, c.prototype.isFutureReservedWord = function(f) {
              switch (f) {
                case "enum":
                case "export":
                case "import":
                case "super":
                  return !0;
                default:
                  return !1;
              }
            }, c.prototype.isStrictModeReservedWord = function(f) {
              switch (f) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "yield":
                case "let":
                  return !0;
                default:
                  return !1;
              }
            }, c.prototype.isRestrictedWord = function(f) {
              return f === "eval" || f === "arguments";
            }, c.prototype.isKeyword = function(f) {
              switch (f.length) {
                case 2:
                  return f === "if" || f === "in" || f === "do";
                case 3:
                  return f === "var" || f === "for" || f === "new" || f === "try" || f === "let";
                case 4:
                  return f === "this" || f === "else" || f === "case" || f === "void" || f === "with" || f === "enum";
                case 5:
                  return f === "while" || f === "break" || f === "catch" || f === "throw" || f === "const" || f === "yield" || f === "class" ||
                  f === "super";
                case 6:
                  return f === "return" || f === "typeof" || f === "delete" || f === "switch" || f === "export" || f === "import";
                case 7:
                  return f === "default" || f === "finally" || f === "extends";
                case 8:
                  return f === "function" || f === "continue" || f === "debugger";
                case 10:
                  return f === "instanceof";
                default:
                  return !1;
              }
            }, c.prototype.codePointAt = function(f) {
              var m = this.source.charCodeAt(f);
              if (m >= 55296 && m <= 56319) {
                var h = this.source.charCodeAt(f + 1);
                if (h >= 56320 && h <= 57343) {
                  var d = m;
                  m = (d - 55296) * 1024 + h - 56320 + 65536;
                }
              }
              return m;
            }, c.prototype.scanHexEscape = function(f) {
              for (var m = f === "u" ? 4 : 2, h = 0, d = 0; d < m; ++d)
                if (!this.eof() && s.Character.isHexDigit(this.source.charCodeAt(this.index)))
                  h = h * 16 + o(this.source[this.index++]);
                else
                  return null;
              return String.fromCharCode(h);
            }, c.prototype.scanUnicodeCodePointEscape = function() {
              var f = this.source[this.index], m = 0;
              for (f === "}" && this.throwUnexpectedToken(); !this.eof() && (f = this.source[this.index++], !!s.Character.isHexDigit(f.charCodeAt(
              0))); )
                m = m * 16 + o(f);
              return (m > 1114111 || f !== "}") && this.throwUnexpectedToken(), s.Character.fromCodePoint(m);
            }, c.prototype.getIdentifier = function() {
              for (var f = this.index++; !this.eof(); ) {
                var m = this.source.charCodeAt(this.index);
                if (m === 92)
                  return this.index = f, this.getComplexIdentifier();
                if (m >= 55296 && m < 57343)
                  return this.index = f, this.getComplexIdentifier();
                if (s.Character.isIdentifierPart(m))
                  ++this.index;
                else
                  break;
              }
              return this.source.slice(f, this.index);
            }, c.prototype.getComplexIdentifier = function() {
              var f = this.codePointAt(this.index), m = s.Character.fromCodePoint(f);
              this.index += m.length;
              var h;
              for (f === 92 && (this.source.charCodeAt(this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] ===
              "{" ? (++this.index, h = this.scanUnicodeCodePointEscape()) : (h = this.scanHexEscape("u"), (h === null || h === "\\" || !s.Character.
              isIdentifierStart(h.charCodeAt(0))) && this.throwUnexpectedToken()), m = h); !this.eof() && (f = this.codePointAt(this.index),
              !!s.Character.isIdentifierPart(f)); )
                h = s.Character.fromCodePoint(f), m += h, this.index += h.length, f === 92 && (m = m.substr(0, m.length - 1), this.source.charCodeAt(
                this.index) !== 117 && this.throwUnexpectedToken(), ++this.index, this.source[this.index] === "{" ? (++this.index, h = this.
                scanUnicodeCodePointEscape()) : (h = this.scanHexEscape("u"), (h === null || h === "\\" || !s.Character.isIdentifierPart(h.charCodeAt(
                0))) && this.throwUnexpectedToken()), m += h);
              return m;
            }, c.prototype.octalToDecimal = function(f) {
              var m = f !== "0", h = u(f);
              return !this.eof() && s.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (m = !0, h = h * 8 + u(this.source[this.
              index++]), "0123".indexOf(f) >= 0 && !this.eof() && s.Character.isOctalDigit(this.source.charCodeAt(this.index)) && (h = h * 8 +
              u(this.source[this.index++]))), {
                code: h,
                octal: m
              };
            }, c.prototype.scanIdentifier = function() {
              var f, m = this.index, h = this.source.charCodeAt(m) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
              if (h.length === 1 ? f = 3 : this.isKeyword(h) ? f = 4 : h === "null" ? f = 5 : h === "true" || h === "false" ? f = 1 : f = 3,
              f !== 3 && m + h.length !== this.index) {
                var d = this.index;
                this.index = m, this.tolerateUnexpectedToken(a.Messages.InvalidEscapedReservedWord), this.index = d;
              }
              return {
                type: f,
                value: h,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: m,
                end: this.index
              };
            }, c.prototype.scanPunctuator = function() {
              var f = this.index, m = this.source[this.index];
              switch (m) {
                case "(":
                case "{":
                  m === "{" && this.curlyStack.push("{"), ++this.index;
                  break;
                case ".":
                  ++this.index, this.source[this.index] === "." && this.source[this.index + 1] === "." && (this.index += 2, m = "...");
                  break;
                case "}":
                  ++this.index, this.curlyStack.pop();
                  break;
                case ")":
                case ";":
                case ",":
                case "[":
                case "]":
                case ":":
                case "?":
                case "~":
                  ++this.index;
                  break;
                default:
                  m = this.source.substr(this.index, 4), m === ">>>=" ? this.index += 4 : (m = m.substr(0, 3), m === "===" || m === "!==" ||
                  m === ">>>" || m === "<<=" || m === ">>=" || m === "**=" ? this.index += 3 : (m = m.substr(0, 2), m === "&&" || m === "||" ||
                  m === "==" || m === "!=" || m === "+=" || m === "-=" || m === "*=" || m === "/=" || m === "++" || m === "--" || m === "<<" ||
                  m === ">>" || m === "&=" || m === "|=" || m === "^=" || m === "%=" || m === "<=" || m === ">=" || m === "=>" || m === "**" ?
                  this.index += 2 : (m = this.source[this.index], "<>=!+-*%&|^/".indexOf(m) >= 0 && ++this.index)));
              }
              return this.index === f && this.throwUnexpectedToken(), {
                type: 7,
                value: m,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: f,
                end: this.index
              };
            }, c.prototype.scanHexLiteral = function(f) {
              for (var m = ""; !this.eof() && s.Character.isHexDigit(this.source.charCodeAt(this.index)); )
                m += this.source[this.index++];
              return m.length === 0 && this.throwUnexpectedToken(), s.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.
              throwUnexpectedToken(), {
                type: 6,
                value: parseInt("0x" + m, 16),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: f,
                end: this.index
              };
            }, c.prototype.scanBinaryLiteral = function(f) {
              for (var m = "", h; !this.eof() && (h = this.source[this.index], !(h !== "0" && h !== "1")); )
                m += this.source[this.index++];
              return m.length === 0 && this.throwUnexpectedToken(), this.eof() || (h = this.source.charCodeAt(this.index), (s.Character.isIdentifierStart(
              h) || s.Character.isDecimalDigit(h)) && this.throwUnexpectedToken()), {
                type: 6,
                value: parseInt(m, 2),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: f,
                end: this.index
              };
            }, c.prototype.scanOctalLiteral = function(f, m) {
              var h = "", d = !1;
              for (s.Character.isOctalDigit(f.charCodeAt(0)) ? (d = !0, h = "0" + this.source[this.index++]) : ++this.index; !this.eof() && s.
              Character.isOctalDigit(this.source.charCodeAt(this.index)); )
                h += this.source[this.index++];
              return !d && h.length === 0 && this.throwUnexpectedToken(), (s.Character.isIdentifierStart(this.source.charCodeAt(this.index)) ||
              s.Character.isDecimalDigit(this.source.charCodeAt(this.index))) && this.throwUnexpectedToken(), {
                type: 6,
                value: parseInt(h, 8),
                octal: d,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: m,
                end: this.index
              };
            }, c.prototype.isImplicitOctalLiteral = function() {
              for (var f = this.index + 1; f < this.length; ++f) {
                var m = this.source[f];
                if (m === "8" || m === "9")
                  return !1;
                if (!s.Character.isOctalDigit(m.charCodeAt(0)))
                  return !0;
              }
              return !0;
            }, c.prototype.scanNumericLiteral = function() {
              var f = this.index, m = this.source[f];
              i.assert(s.Character.isDecimalDigit(m.charCodeAt(0)) || m === ".", "Numeric literal must start with a decimal digit or a decim\
al point");
              var h = "";
              if (m !== ".") {
                if (h = this.source[this.index++], m = this.source[this.index], h === "0") {
                  if (m === "x" || m === "X")
                    return ++this.index, this.scanHexLiteral(f);
                  if (m === "b" || m === "B")
                    return ++this.index, this.scanBinaryLiteral(f);
                  if (m === "o" || m === "O")
                    return this.scanOctalLiteral(m, f);
                  if (m && s.Character.isOctalDigit(m.charCodeAt(0)) && this.isImplicitOctalLiteral())
                    return this.scanOctalLiteral(m, f);
                }
                for (; s.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                  h += this.source[this.index++];
                m = this.source[this.index];
              }
              if (m === ".") {
                for (h += this.source[this.index++]; s.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                  h += this.source[this.index++];
                m = this.source[this.index];
              }
              if (m === "e" || m === "E")
                if (h += this.source[this.index++], m = this.source[this.index], (m === "+" || m === "-") && (h += this.source[this.index++]),
                s.Character.isDecimalDigit(this.source.charCodeAt(this.index)))
                  for (; s.Character.isDecimalDigit(this.source.charCodeAt(this.index)); )
                    h += this.source[this.index++];
                else
                  this.throwUnexpectedToken();
              return s.Character.isIdentifierStart(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(), {
                type: 6,
                value: parseFloat(h),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: f,
                end: this.index
              };
            }, c.prototype.scanStringLiteral = function() {
              var f = this.index, m = this.source[f];
              i.assert(m === "'" || m === '"', "String literal must starts with a quote"), ++this.index;
              for (var h = !1, d = ""; !this.eof(); ) {
                var y = this.source[this.index++];
                if (y === m) {
                  m = "";
                  break;
                } else if (y === "\\")
                  if (y = this.source[this.index++], !y || !s.Character.isLineTerminator(y.charCodeAt(0)))
                    switch (y) {
                      case "u":
                        if (this.source[this.index] === "{")
                          ++this.index, d += this.scanUnicodeCodePointEscape();
                        else {
                          var p = this.scanHexEscape(y);
                          p === null && this.throwUnexpectedToken(), d += p;
                        }
                        break;
                      case "x":
                        var g = this.scanHexEscape(y);
                        g === null && this.throwUnexpectedToken(a.Messages.InvalidHexEscapeSequence), d += g;
                        break;
                      case "n":
                        d += `
`;
                        break;
                      case "r":
                        d += "\r";
                        break;
                      case "t":
                        d += "	";
                        break;
                      case "b":
                        d += "\b";
                        break;
                      case "f":
                        d += "\f";
                        break;
                      case "v":
                        d += "\v";
                        break;
                      case "8":
                      case "9":
                        d += y, this.tolerateUnexpectedToken();
                        break;
                      default:
                        if (y && s.Character.isOctalDigit(y.charCodeAt(0))) {
                          var b = this.octalToDecimal(y);
                          h = b.octal || h, d += String.fromCharCode(b.code);
                        } else
                          d += y;
                        break;
                    }
                  else
                    ++this.lineNumber, y === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index;
                else {
                  if (s.Character.isLineTerminator(y.charCodeAt(0)))
                    break;
                  d += y;
                }
              }
              return m !== "" && (this.index = f, this.throwUnexpectedToken()), {
                type: 8,
                value: d,
                octal: h,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: f,
                end: this.index
              };
            }, c.prototype.scanTemplate = function() {
              var f = "", m = !1, h = this.index, d = this.source[h] === "`", y = !1, p = 2;
              for (++this.index; !this.eof(); ) {
                var g = this.source[this.index++];
                if (g === "`") {
                  p = 1, y = !0, m = !0;
                  break;
                } else if (g === "$") {
                  if (this.source[this.index] === "{") {
                    this.curlyStack.push("${"), ++this.index, m = !0;
                    break;
                  }
                  f += g;
                } else if (g === "\\")
                  if (g = this.source[this.index++], s.Character.isLineTerminator(g.charCodeAt(0)))
                    ++this.lineNumber, g === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index;
                  else
                    switch (g) {
                      case "n":
                        f += `
`;
                        break;
                      case "r":
                        f += "\r";
                        break;
                      case "t":
                        f += "	";
                        break;
                      case "u":
                        if (this.source[this.index] === "{")
                          ++this.index, f += this.scanUnicodeCodePointEscape();
                        else {
                          var b = this.index, D = this.scanHexEscape(g);
                          D !== null ? f += D : (this.index = b, f += g);
                        }
                        break;
                      case "x":
                        var x = this.scanHexEscape(g);
                        x === null && this.throwUnexpectedToken(a.Messages.InvalidHexEscapeSequence), f += x;
                        break;
                      case "b":
                        f += "\b";
                        break;
                      case "f":
                        f += "\f";
                        break;
                      case "v":
                        f += "\v";
                        break;
                      default:
                        g === "0" ? (s.Character.isDecimalDigit(this.source.charCodeAt(this.index)) && this.throwUnexpectedToken(a.Messages.
                        TemplateOctalLiteral), f += "\0") : s.Character.isOctalDigit(g.charCodeAt(0)) ? this.throwUnexpectedToken(a.Messages.
                        TemplateOctalLiteral) : f += g;
                        break;
                    }
                else s.Character.isLineTerminator(g.charCodeAt(0)) ? (++this.lineNumber, g === "\r" && this.source[this.index] === `
` && ++this.index, this.lineStart = this.index, f += `
`) : f += g;
              }
              return m || this.throwUnexpectedToken(), d || this.curlyStack.pop(), {
                type: 10,
                value: this.source.slice(h + 1, this.index - p),
                cooked: f,
                head: d,
                tail: y,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: h,
                end: this.index
              };
            }, c.prototype.testRegExp = function(f, m) {
              var h = "\uFFFF", d = f, y = this;
              m.indexOf("u") >= 0 && (d = d.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function(p, g, b) {
                var D = parseInt(g || b, 16);
                return D > 1114111 && y.throwUnexpectedToken(a.Messages.InvalidRegExp), D <= 65535 ? String.fromCharCode(D) : h;
              }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, h));
              try {
                RegExp(d);
              } catch {
                this.throwUnexpectedToken(a.Messages.InvalidRegExp);
              }
              try {
                return new RegExp(f, m);
              } catch {
                return null;
              }
            }, c.prototype.scanRegExpBody = function() {
              var f = this.source[this.index];
              i.assert(f === "/", "Regular expression literal must start with a slash");
              for (var m = this.source[this.index++], h = !1, d = !1; !this.eof(); )
                if (f = this.source[this.index++], m += f, f === "\\")
                  f = this.source[this.index++], s.Character.isLineTerminator(f.charCodeAt(0)) && this.throwUnexpectedToken(a.Messages.UnterminatedRegExp),
                  m += f;
                else if (s.Character.isLineTerminator(f.charCodeAt(0)))
                  this.throwUnexpectedToken(a.Messages.UnterminatedRegExp);
                else if (h)
                  f === "]" && (h = !1);
                else if (f === "/") {
                  d = !0;
                  break;
                } else f === "[" && (h = !0);
              return d || this.throwUnexpectedToken(a.Messages.UnterminatedRegExp), m.substr(1, m.length - 2);
            }, c.prototype.scanRegExpFlags = function() {
              for (var f = "", m = ""; !this.eof(); ) {
                var h = this.source[this.index];
                if (!s.Character.isIdentifierPart(h.charCodeAt(0)))
                  break;
                if (++this.index, h === "\\" && !this.eof())
                  if (h = this.source[this.index], h === "u") {
                    ++this.index;
                    var d = this.index, y = this.scanHexEscape("u");
                    if (y !== null)
                      for (m += y, f += "\\u"; d < this.index; ++d)
                        f += this.source[d];
                    else
                      this.index = d, m += "u", f += "\\u";
                    this.tolerateUnexpectedToken();
                  } else
                    f += "\\", this.tolerateUnexpectedToken();
                else
                  m += h, f += h;
              }
              return m;
            }, c.prototype.scanRegExp = function() {
              var f = this.index, m = this.scanRegExpBody(), h = this.scanRegExpFlags(), d = this.testRegExp(m, h);
              return {
                type: 9,
                value: "",
                pattern: m,
                flags: h,
                regex: d,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start: f,
                end: this.index
              };
            }, c.prototype.lex = function() {
              if (this.eof())
                return {
                  type: 2,
                  value: "",
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: this.index,
                  end: this.index
                };
              var f = this.source.charCodeAt(this.index);
              return s.Character.isIdentifierStart(f) ? this.scanIdentifier() : f === 40 || f === 41 || f === 59 ? this.scanPunctuator() : f ===
              39 || f === 34 ? this.scanStringLiteral() : f === 46 ? s.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1)) ? this.
              scanNumericLiteral() : this.scanPunctuator() : s.Character.isDecimalDigit(f) ? this.scanNumericLiteral() : f === 96 || f === 125 &&
              this.curlyStack[this.curlyStack.length - 1] === "${" ? this.scanTemplate() : f >= 55296 && f < 57343 && s.Character.isIdentifierStart(
              this.codePointAt(this.index)) ? this.scanIdentifier() : this.scanPunctuator();
            }, c;
          }();
          t.Scanner = l;
        },
        /* 13 */
        /***/
        function(e, t) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 }), t.TokenName = {}, t.TokenName[
            1
            /* BooleanLiteral */
          ] = "Boolean", t.TokenName[
            2
            /* EOF */
          ] = "<end>", t.TokenName[
            3
            /* Identifier */
          ] = "Identifier", t.TokenName[
            4
            /* Keyword */
          ] = "Keyword", t.TokenName[
            5
            /* NullLiteral */
          ] = "Null", t.TokenName[
            6
            /* NumericLiteral */
          ] = "Numeric", t.TokenName[
            7
            /* Punctuator */
          ] = "Punctuator", t.TokenName[
            8
            /* StringLiteral */
          ] = "String", t.TokenName[
            9
            /* RegularExpression */
          ] = "RegularExpression", t.TokenName[
            10
            /* Template */
          ] = "Template";
        },
        /* 14 */
        /***/
        function(e, t) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 }), t.XHTMLEntities = {
            quot: '"',
            amp: "&",
            apos: "'",
            gt: ">",
            nbsp: "\xA0",
            iexcl: "\xA1",
            cent: "\xA2",
            pound: "\xA3",
            curren: "\xA4",
            yen: "\xA5",
            brvbar: "\xA6",
            sect: "\xA7",
            uml: "\xA8",
            copy: "\xA9",
            ordf: "\xAA",
            laquo: "\xAB",
            not: "\xAC",
            shy: "\xAD",
            reg: "\xAE",
            macr: "\xAF",
            deg: "\xB0",
            plusmn: "\xB1",
            sup2: "\xB2",
            sup3: "\xB3",
            acute: "\xB4",
            micro: "\xB5",
            para: "\xB6",
            middot: "\xB7",
            cedil: "\xB8",
            sup1: "\xB9",
            ordm: "\xBA",
            raquo: "\xBB",
            frac14: "\xBC",
            frac12: "\xBD",
            frac34: "\xBE",
            iquest: "\xBF",
            Agrave: "\xC0",
            Aacute: "\xC1",
            Acirc: "\xC2",
            Atilde: "\xC3",
            Auml: "\xC4",
            Aring: "\xC5",
            AElig: "\xC6",
            Ccedil: "\xC7",
            Egrave: "\xC8",
            Eacute: "\xC9",
            Ecirc: "\xCA",
            Euml: "\xCB",
            Igrave: "\xCC",
            Iacute: "\xCD",
            Icirc: "\xCE",
            Iuml: "\xCF",
            ETH: "\xD0",
            Ntilde: "\xD1",
            Ograve: "\xD2",
            Oacute: "\xD3",
            Ocirc: "\xD4",
            Otilde: "\xD5",
            Ouml: "\xD6",
            times: "\xD7",
            Oslash: "\xD8",
            Ugrave: "\xD9",
            Uacute: "\xDA",
            Ucirc: "\xDB",
            Uuml: "\xDC",
            Yacute: "\xDD",
            THORN: "\xDE",
            szlig: "\xDF",
            agrave: "\xE0",
            aacute: "\xE1",
            acirc: "\xE2",
            atilde: "\xE3",
            auml: "\xE4",
            aring: "\xE5",
            aelig: "\xE6",
            ccedil: "\xE7",
            egrave: "\xE8",
            eacute: "\xE9",
            ecirc: "\xEA",
            euml: "\xEB",
            igrave: "\xEC",
            iacute: "\xED",
            icirc: "\xEE",
            iuml: "\xEF",
            eth: "\xF0",
            ntilde: "\xF1",
            ograve: "\xF2",
            oacute: "\xF3",
            ocirc: "\xF4",
            otilde: "\xF5",
            ouml: "\xF6",
            divide: "\xF7",
            oslash: "\xF8",
            ugrave: "\xF9",
            uacute: "\xFA",
            ucirc: "\xFB",
            uuml: "\xFC",
            yacute: "\xFD",
            thorn: "\xFE",
            yuml: "\xFF",
            OElig: "\u0152",
            oelig: "\u0153",
            Scaron: "\u0160",
            scaron: "\u0161",
            Yuml: "\u0178",
            fnof: "\u0192",
            circ: "\u02C6",
            tilde: "\u02DC",
            Alpha: "\u0391",
            Beta: "\u0392",
            Gamma: "\u0393",
            Delta: "\u0394",
            Epsilon: "\u0395",
            Zeta: "\u0396",
            Eta: "\u0397",
            Theta: "\u0398",
            Iota: "\u0399",
            Kappa: "\u039A",
            Lambda: "\u039B",
            Mu: "\u039C",
            Nu: "\u039D",
            Xi: "\u039E",
            Omicron: "\u039F",
            Pi: "\u03A0",
            Rho: "\u03A1",
            Sigma: "\u03A3",
            Tau: "\u03A4",
            Upsilon: "\u03A5",
            Phi: "\u03A6",
            Chi: "\u03A7",
            Psi: "\u03A8",
            Omega: "\u03A9",
            alpha: "\u03B1",
            beta: "\u03B2",
            gamma: "\u03B3",
            delta: "\u03B4",
            epsilon: "\u03B5",
            zeta: "\u03B6",
            eta: "\u03B7",
            theta: "\u03B8",
            iota: "\u03B9",
            kappa: "\u03BA",
            lambda: "\u03BB",
            mu: "\u03BC",
            nu: "\u03BD",
            xi: "\u03BE",
            omicron: "\u03BF",
            pi: "\u03C0",
            rho: "\u03C1",
            sigmaf: "\u03C2",
            sigma: "\u03C3",
            tau: "\u03C4",
            upsilon: "\u03C5",
            phi: "\u03C6",
            chi: "\u03C7",
            psi: "\u03C8",
            omega: "\u03C9",
            thetasym: "\u03D1",
            upsih: "\u03D2",
            piv: "\u03D6",
            ensp: "\u2002",
            emsp: "\u2003",
            thinsp: "\u2009",
            zwnj: "\u200C",
            zwj: "\u200D",
            lrm: "\u200E",
            rlm: "\u200F",
            ndash: "\u2013",
            mdash: "\u2014",
            lsquo: "\u2018",
            rsquo: "\u2019",
            sbquo: "\u201A",
            ldquo: "\u201C",
            rdquo: "\u201D",
            bdquo: "\u201E",
            dagger: "\u2020",
            Dagger: "\u2021",
            bull: "\u2022",
            hellip: "\u2026",
            permil: "\u2030",
            prime: "\u2032",
            Prime: "\u2033",
            lsaquo: "\u2039",
            rsaquo: "\u203A",
            oline: "\u203E",
            frasl: "\u2044",
            euro: "\u20AC",
            image: "\u2111",
            weierp: "\u2118",
            real: "\u211C",
            trade: "\u2122",
            alefsym: "\u2135",
            larr: "\u2190",
            uarr: "\u2191",
            rarr: "\u2192",
            darr: "\u2193",
            harr: "\u2194",
            crarr: "\u21B5",
            lArr: "\u21D0",
            uArr: "\u21D1",
            rArr: "\u21D2",
            dArr: "\u21D3",
            hArr: "\u21D4",
            forall: "\u2200",
            part: "\u2202",
            exist: "\u2203",
            empty: "\u2205",
            nabla: "\u2207",
            isin: "\u2208",
            notin: "\u2209",
            ni: "\u220B",
            prod: "\u220F",
            sum: "\u2211",
            minus: "\u2212",
            lowast: "\u2217",
            radic: "\u221A",
            prop: "\u221D",
            infin: "\u221E",
            ang: "\u2220",
            and: "\u2227",
            or: "\u2228",
            cap: "\u2229",
            cup: "\u222A",
            int: "\u222B",
            there4: "\u2234",
            sim: "\u223C",
            cong: "\u2245",
            asymp: "\u2248",
            ne: "\u2260",
            equiv: "\u2261",
            le: "\u2264",
            ge: "\u2265",
            sub: "\u2282",
            sup: "\u2283",
            nsub: "\u2284",
            sube: "\u2286",
            supe: "\u2287",
            oplus: "\u2295",
            otimes: "\u2297",
            perp: "\u22A5",
            sdot: "\u22C5",
            lceil: "\u2308",
            rceil: "\u2309",
            lfloor: "\u230A",
            rfloor: "\u230B",
            loz: "\u25CA",
            spades: "\u2660",
            clubs: "\u2663",
            hearts: "\u2665",
            diams: "\u2666",
            lang: "\u27E8",
            rang: "\u27E9"
          };
        },
        /* 15 */
        /***/
        function(e, t, r) {
          "use strict";
          Object.defineProperty(t, "__esModule", { value: !0 });
          var i = r(10), s = r(12), a = r(13), o = function() {
            function l() {
              this.values = [], this.curly = this.paren = -1;
            }
            return n(l, "Reader"), l.prototype.beforeFunctionExpression = function(c) {
              return [
                "(",
                "{",
                "[",
                "in",
                "typeof",
                "instanceof",
                "new",
                "return",
                "case",
                "delete",
                "throw",
                "void",
                // assignment operators
                "=",
                "+=",
                "-=",
                "*=",
                "**=",
                "/=",
                "%=",
                "<<=",
                ">>=",
                ">>>=",
                "&=",
                "|=",
                "^=",
                ",",
                // binary/unary operators
                "+",
                "-",
                "*",
                "**",
                "/",
                "%",
                "++",
                "--",
                "<<",
                ">>",
                ">>>",
                "&",
                "|",
                "^",
                "!",
                "~",
                "&&",
                "||",
                "?",
                ":",
                "===",
                "==",
                ">=",
                "<=",
                "<",
                ">",
                "!=",
                "!=="
              ].indexOf(c) >= 0;
            }, l.prototype.isRegexStart = function() {
              var c = this.values[this.values.length - 1], f = c !== null;
              switch (c) {
                case "this":
                case "]":
                  f = !1;
                  break;
                case ")":
                  var m = this.values[this.paren - 1];
                  f = m === "if" || m === "while" || m === "for" || m === "with";
                  break;
                case "}":
                  if (f = !1, this.values[this.curly - 3] === "function") {
                    var h = this.values[this.curly - 4];
                    f = h ? !this.beforeFunctionExpression(h) : !1;
                  } else if (this.values[this.curly - 4] === "function") {
                    var h = this.values[this.curly - 5];
                    f = h ? !this.beforeFunctionExpression(h) : !0;
                  }
                  break;
                default:
                  break;
              }
              return f;
            }, l.prototype.push = function(c) {
              c.type === 7 || c.type === 4 ? (c.value === "{" ? this.curly = this.values.length : c.value === "(" && (this.paren = this.values.
              length), this.values.push(c.value)) : this.values.push(null);
            }, l;
          }(), u = function() {
            function l(c, f) {
              this.errorHandler = new i.ErrorHandler(), this.errorHandler.tolerant = f ? typeof f.tolerant == "boolean" && f.tolerant : !1, this.
              scanner = new s.Scanner(c, this.errorHandler), this.scanner.trackComment = f ? typeof f.comment == "boolean" && f.comment : !1,
              this.trackRange = f ? typeof f.range == "boolean" && f.range : !1, this.trackLoc = f ? typeof f.loc == "boolean" && f.loc : !1,
              this.buffer = [], this.reader = new o();
            }
            return n(l, "Tokenizer"), l.prototype.errors = function() {
              return this.errorHandler.errors;
            }, l.prototype.getNextToken = function() {
              if (this.buffer.length === 0) {
                var c = this.scanner.scanComments();
                if (this.scanner.trackComment)
                  for (var f = 0; f < c.length; ++f) {
                    var m = c[f], h = this.scanner.source.slice(m.slice[0], m.slice[1]), d = {
                      type: m.multiLine ? "BlockComment" : "LineComment",
                      value: h
                    };
                    this.trackRange && (d.range = m.range), this.trackLoc && (d.loc = m.loc), this.buffer.push(d);
                  }
                if (!this.scanner.eof()) {
                  var y = void 0;
                  this.trackLoc && (y = {
                    start: {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    },
                    end: {}
                  });
                  var p = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart(), g = p ? this.scanner.scanRegExp() :
                  this.scanner.lex();
                  this.reader.push(g);
                  var b = {
                    type: a.TokenName[g.type],
                    value: this.scanner.source.slice(g.start, g.end)
                  };
                  if (this.trackRange && (b.range = [g.start, g.end]), this.trackLoc && (y.end = {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  }, b.loc = y), g.type === 9) {
                    var D = g.pattern, x = g.flags;
                    b.regex = { pattern: D, flags: x };
                  }
                  this.buffer.push(b);
                }
              }
              return this.buffer.shift();
            }, l;
          }();
          t.Tokenizer = u;
        }
        /******/
      ])
    );
  });
});

// ../node_modules/array-timsort/src/index.js
var WB = E((vot, VB) => {
  var RB = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9], Te, LB = /* @__PURE__ */ n((e) => e < 1e5 ? e < 100 ? e < 10 ? 0 : 1 : e < 1e4 ?
  e < 1e3 ? 2 : 3 : 4 : e < 1e7 ? e < 1e6 ? 5 : 6 : e < 1e9 ? e < 1e8 ? 7 : 8 : 9, "log10");
  function jB(e, t) {
    if (e === t)
      return 0;
    if (~~e === e && ~~t === t) {
      if (e === 0 || t === 0)
        return e < t ? -1 : 1;
      if (e < 0 || t < 0) {
        if (t >= 0)
          return -1;
        if (e >= 0)
          return 1;
        e = -e, t = -t;
      }
      let s = LB(e), a = LB(t), o = 0;
      return s < a ? (e *= RB[a - s - 1], t /= 10, o = -1) : s > a && (t *= RB[s - a - 1], e /= 10, o = 1), e === t ? o : e < t ? -1 : 1;
    }
    let r = String(e), i = String(t);
    return r === i ? 0 : r < i ? -1 : 1;
  }
  n(jB, "alphabeticalCompare");
  function $ce(e) {
    let t = 0;
    for (; e >= 32; )
      t |= e & 1, e >>= 1;
    return e + t;
  }
  n($ce, "minRunLength");
  function qB(e, t, r, i) {
    let s = t + 1;
    if (s === r)
      return 1;
    if (i(e[s++], e[t]) < 0) {
      for (; s < r && i(e[s], e[s - 1]) < 0; )
        s++;
      UB(e, t, s), UB(Te, t, s);
    } else
      for (; s < r && i(e[s], e[s - 1]) >= 0; )
        s++;
    return s - t;
  }
  n(qB, "makeAscendingRun");
  function UB(e, t, r) {
    for (r--; t < r; ) {
      let i = e[t];
      e[t++] = e[r], e[r--] = i;
    }
  }
  n(UB, "reverseRun");
  function $B(e, t, r, i, s) {
    for (i === t && i++; i < r; i++) {
      let a = e[i], o = Te[i], u = t, l = i;
      for (; u < l; ) {
        let f = u + l >>> 1;
        s(a, e[f]) < 0 ? l = f : u = f + 1;
      }
      let c = i - u;
      switch (c) {
        case 3:
          e[u + 3] = e[u + 2], Te[u + 3] = Te[u + 2];
        /* falls through */
        case 2:
          e[u + 2] = e[u + 1], Te[u + 2] = Te[u + 1];
        /* falls through */
        case 1:
          e[u + 1] = e[u], Te[u + 1] = Te[u];
          break;
        default:
          for (; c > 0; )
            e[u + c] = e[u + c - 1], Te[u + c] = Te[u + c - 1], c--;
      }
      e[u] = a, Te[u] = o;
    }
  }
  n($B, "binaryInsertionSort");
  function Px(e, t, r, i, s, a) {
    let o = 0, u = 0, l = 1;
    if (a(e, t[r + s]) > 0) {
      for (u = i - s; l < u && a(e, t[r + s + l]) > 0; )
        o = l, l = (l << 1) + 1, l <= 0 && (l = u);
      l > u && (l = u), o += s, l += s;
    } else {
      for (u = s + 1; l < u && a(e, t[r + s - l]) <= 0; )
        o = l, l = (l << 1) + 1, l <= 0 && (l = u);
      l > u && (l = u);
      let c = o;
      o = s - l, l = s - c;
    }
    for (o++; o < l; ) {
      let c = o + (l - o >>> 1);
      a(e, t[r + c]) > 0 ? o = c + 1 : l = c;
    }
    return l;
  }
  n(Px, "gallopLeft");
  function Fx(e, t, r, i, s, a) {
    let o = 0, u = 0, l = 1;
    if (a(e, t[r + s]) < 0) {
      for (u = s + 1; l < u && a(e, t[r + s - l]) < 0; )
        o = l, l = (l << 1) + 1, l <= 0 && (l = u);
      l > u && (l = u);
      let c = o;
      o = s - l, l = s - c;
    } else {
      for (u = i - s; l < u && a(e, t[r + s + l]) >= 0; )
        o = l, l = (l << 1) + 1, l <= 0 && (l = u);
      l > u && (l = u), o += s, l += s;
    }
    for (o++; o < l; ) {
      let c = o + (l - o >>> 1);
      a(e, t[r + c]) < 0 ? l = c : o = c + 1;
    }
    return l;
  }
  n(Fx, "gallopRight");
  var Ix = class {
    static {
      n(this, "TimSort");
    }
    constructor(t, r) {
      this.array = t, this.compare = r;
      let { length: i } = t;
      this.length = i, this.minGallop = 7, this.tmpStorageLength = i < 2 * 256 ? i >>> 1 : 256, this.tmp = new Array(this.tmpStorageLength),
      this.tmpIndex = new Array(this.tmpStorageLength), this.stackLength = i < 120 ? 5 : i < 1542 ? 10 : i < 119151 ? 19 : 40, this.runStart =
      new Array(this.stackLength), this.runLength = new Array(this.stackLength), this.stackSize = 0;
    }
    /**
     * Push a new run on TimSort's stack.
     *
     * @param {number} runStart - Start index of the run in the original array.
     * @param {number} runLength - Length of the run;
     */
    pushRun(t, r) {
      this.runStart[this.stackSize] = t, this.runLength[this.stackSize] = r, this.stackSize += 1;
    }
    /**
     * Merge runs on TimSort's stack so that the following holds for all i:
     * 1) runLength[i - 3] > runLength[i - 2] + runLength[i - 1]
     * 2) runLength[i - 2] > runLength[i - 1]
     */
    mergeRuns() {
      for (; this.stackSize > 1; ) {
        let t = this.stackSize - 2;
        if (t >= 1 && this.runLength[t - 1] <= this.runLength[t] + this.runLength[t + 1] || t >= 2 && this.runLength[t - 2] <= this.runLength[t] +
        this.runLength[t - 1])
          this.runLength[t - 1] < this.runLength[t + 1] && t--;
        else if (this.runLength[t] > this.runLength[t + 1])
          break;
        this.mergeAt(t);
      }
    }
    /**
     * Merge all runs on TimSort's stack until only one remains.
     */
    forceMergeRuns() {
      for (; this.stackSize > 1; ) {
        let t = this.stackSize - 2;
        t > 0 && this.runLength[t - 1] < this.runLength[t + 1] && t--, this.mergeAt(t);
      }
    }
    /**
     * Merge the runs on the stack at positions i and i+1. Must be always be called
     * with i=stackSize-2 or i=stackSize-3 (that is, we merge on top of the stack).
     *
     * @param {number} i - Index of the run to merge in TimSort's stack.
     */
    mergeAt(t) {
      let { compare: r } = this, { array: i } = this, s = this.runStart[t], a = this.runLength[t], o = this.runStart[t + 1], u = this.runLength[t +
      1];
      this.runLength[t] = a + u, t === this.stackSize - 3 && (this.runStart[t + 1] = this.runStart[t + 2], this.runLength[t + 1] = this.runLength[t +
      2]), this.stackSize--;
      let l = Fx(i[o], i, s, a, 0, r);
      s += l, a -= l, a !== 0 && (u = Px(
        i[s + a - 1],
        i,
        o,
        u,
        u - 1,
        r
      ), u !== 0 && (a <= u ? this.mergeLow(s, a, o, u) : this.mergeHigh(s, a, o, u)));
    }
    /**
     * Merge two adjacent runs in a stable way. The runs must be such that the
     * first element of run1 is bigger than the first element in run2 and the
     * last element of run1 is greater than all the elements in run2.
     * The method should be called when run1.length <= run2.length as it uses
     * TimSort temporary array to store run1. Use mergeHigh if run1.length >
     * run2.length.
     *
     * @param {number} start1 - First element in run1.
     * @param {number} length1 - Length of run1.
     * @param {number} start2 - First element in run2.
     * @param {number} length2 - Length of run2.
     */
    mergeLow(t, r, i, s) {
      let { compare: a } = this, { array: o } = this, { tmp: u } = this, { tmpIndex: l } = this, c = 0;
      for (c = 0; c < r; c++)
        u[c] = o[t + c], l[c] = Te[t + c];
      let f = 0, m = i, h = t;
      if (o[h] = o[m], Te[h] = Te[m], h++, m++, --s === 0) {
        for (c = 0; c < r; c++)
          o[h + c] = u[f + c], Te[h + c] = l[f + c];
        return;
      }
      if (r === 1) {
        for (c = 0; c < s; c++)
          o[h + c] = o[m + c], Te[h + c] = Te[m + c];
        o[h + s] = u[f], Te[h + s] = l[f];
        return;
      }
      let { minGallop: d } = this;
      for (; ; ) {
        let y = 0, p = 0, g = !1;
        do
          if (a(o[m], u[f]) < 0) {
            if (o[h] = o[m], Te[h] = Te[m], h++, m++, p++, y = 0, --s === 0) {
              g = !0;
              break;
            }
          } else if (o[h] = u[f], Te[h] = l[f], h++, f++, y++, p = 0, --r === 1) {
            g = !0;
            break;
          }
        while ((y | p) < d);
        if (g)
          break;
        do {
          if (y = Fx(o[m], u, f, r, 0, a), y !== 0) {
            for (c = 0; c < y; c++)
              o[h + c] = u[f + c], Te[h + c] = l[f + c];
            if (h += y, f += y, r -= y, r <= 1) {
              g = !0;
              break;
            }
          }
          if (o[h] = o[m], Te[h] = Te[m], h++, m++, --s === 0) {
            g = !0;
            break;
          }
          if (p = Px(u[f], o, m, s, 0, a), p !== 0) {
            for (c = 0; c < p; c++)
              o[h + c] = o[m + c], Te[h + c] = Te[m + c];
            if (h += p, m += p, s -= p, s === 0) {
              g = !0;
              break;
            }
          }
          if (o[h] = u[f], Te[h] = l[f], h++, f++, --r === 1) {
            g = !0;
            break;
          }
          d--;
        } while (y >= 7 || p >= 7);
        if (g)
          break;
        d < 0 && (d = 0), d += 2;
      }
      if (this.minGallop = d, d < 1 && (this.minGallop = 1), r === 1) {
        for (c = 0; c < s; c++)
          o[h + c] = o[m + c], Te[h + c] = Te[m + c];
        o[h + s] = u[f], Te[h + s] = l[f];
      } else {
        if (r === 0)
          throw new Error("mergeLow preconditions were not respected");
        for (c = 0; c < r; c++)
          o[h + c] = u[f + c], Te[h + c] = l[f + c];
      }
    }
    /**
     * Merge two adjacent runs in a stable way. The runs must be such that the
     * first element of run1 is bigger than the first element in run2 and the
     * last element of run1 is greater than all the elements in run2.
     * The method should be called when run1.length > run2.length as it uses
     * TimSort temporary array to store run2. Use mergeLow if run1.length <=
     * run2.length.
     *
     * @param {number} start1 - First element in run1.
     * @param {number} length1 - Length of run1.
     * @param {number} start2 - First element in run2.
     * @param {number} length2 - Length of run2.
     */
    mergeHigh(t, r, i, s) {
      let { compare: a } = this, { array: o } = this, { tmp: u } = this, { tmpIndex: l } = this, c = 0;
      for (c = 0; c < s; c++)
        u[c] = o[i + c], l[c] = Te[i + c];
      let f = t + r - 1, m = s - 1, h = i + s - 1, d = 0, y = 0;
      if (o[h] = o[f], Te[h] = Te[f], h--, f--, --r === 0) {
        for (d = h - (s - 1), c = 0; c < s; c++)
          o[d + c] = u[c], Te[d + c] = l[c];
        return;
      }
      if (s === 1) {
        for (h -= r, f -= r, y = h + 1, d = f + 1, c = r - 1; c >= 0; c--)
          o[y + c] = o[d + c], Te[y + c] = Te[d + c];
        o[h] = u[m], Te[h] = l[m];
        return;
      }
      let { minGallop: p } = this;
      for (; ; ) {
        let g = 0, b = 0, D = !1;
        do
          if (a(u[m], o[f]) < 0) {
            if (o[h] = o[f], Te[h] = Te[f], h--, f--, g++, b = 0, --r === 0) {
              D = !0;
              break;
            }
          } else if (o[h] = u[m], Te[h] = l[m], h--, m--, b++, g = 0, --s === 1) {
            D = !0;
            break;
          }
        while ((g | b) < p);
        if (D)
          break;
        do {
          if (g = r - Fx(
            u[m],
            o,
            t,
            r,
            r - 1,
            a
          ), g !== 0) {
            for (h -= g, f -= g, r -= g, y = h + 1, d = f + 1, c = g - 1; c >= 0; c--)
              o[y + c] = o[d + c], Te[y + c] = Te[d + c];
            if (r === 0) {
              D = !0;
              break;
            }
          }
          if (o[h] = u[m], Te[h] = l[m], h--, m--, --s === 1) {
            D = !0;
            break;
          }
          if (b = s - Px(
            o[f],
            u,
            0,
            s,
            s - 1,
            a
          ), b !== 0) {
            for (h -= b, m -= b, s -= b, y = h + 1, d = m + 1, c = 0; c < b; c++)
              o[y + c] = u[d + c], Te[y + c] = l[d + c];
            if (s <= 1) {
              D = !0;
              break;
            }
          }
          if (o[h] = o[f], Te[h] = Te[f], h--, f--, --r === 0) {
            D = !0;
            break;
          }
          p--;
        } while (g >= 7 || b >= 7);
        if (D)
          break;
        p < 0 && (p = 0), p += 2;
      }
      if (this.minGallop = p, p < 1 && (this.minGallop = 1), s === 1) {
        for (h -= r, f -= r, y = h + 1, d = f + 1, c = r - 1; c >= 0; c--)
          o[y + c] = o[d + c], Te[y + c] = Te[d + c];
        o[h] = u[m], Te[h] = l[m];
      } else {
        if (s === 0)
          throw new Error("mergeHigh preconditions were not respected");
        for (d = h - (s - 1), c = 0; c < s; c++)
          o[d + c] = u[c], Te[d + c] = l[c];
      }
    }
  };
  function Vce(e, t, r, i) {
    if (!Array.isArray(e))
      throw new TypeError(
        `The "array" argument must be an array. Received ${e}`
      );
    Te = [];
    let { length: s } = e, a = 0;
    for (; a < s; )
      Te[a] = a++;
    t ? typeof t != "function" && (i = r, r = t, t = jB) : t = jB, r || (r = 0), i || (i = s);
    let o = i - r;
    if (o < 2)
      return Te;
    let u = 0;
    if (o < 32)
      return u = qB(e, r, i, t), $B(e, r, i, r + u, t), Te;
    let l = new Ix(e, t), c = $ce(o);
    do {
      if (u = qB(e, r, i, t), u < c) {
        let f = o;
        f > c && (f = c), $B(e, r, r + f, r + u, t), u = f;
      }
      l.pushRun(r, u), l.mergeRuns(), o -= u, r += u;
    } while (o !== 0);
    return l.forceMergeRuns(), Te;
  }
  n(Vce, "sort");
  VB.exports = {
    sort: Vce
  };
});

// ../node_modules/has-own-prop/index.js
var KB = E((Eot, HB) => {
  "use strict";
  var Wce = Object.prototype.hasOwnProperty;
  HB.exports = (e, t) => Wce.call(e, t);
});

// ../node_modules/comment-json/src/common.js
var dd = E((Sot, iN) => {
  var Bx = KB(), {
    isObject: zB,
    isArray: Hce,
    isString: Kce,
    isNumber: zce
  } = dr(), Nx = "before", XB = "after-prop", YB = "after-colon", GB = "after-value", ZB = "after", QB = "before-all", eN = "after-all", Jce = "\
[", Xce = "]", Yce = "{", Gce = "}", Zce = ",", Qce = "", efe = "-", Mx = [
    Nx,
    XB,
    YB,
    GB,
    ZB
  ], tfe = [
    Nx,
    QB,
    eN
  ].map(Symbol.for), tN = ":", JB = void 0, fd = /* @__PURE__ */ n((e, t) => Symbol.for(e + tN + t), "symbol"), gm = /* @__PURE__ */ n((e, t, r) => Object.
  defineProperty(e, t, {
    value: r,
    writable: !0,
    configurable: !0
  }), "define"), kx = /* @__PURE__ */ n((e, t, r, i, s, a) => {
    let o = fd(s, i);
    if (!Bx(t, o))
      return;
    let u = r === i ? o : fd(s, r);
    gm(e, u, t[o]), a && delete t[o];
  }, "copy_comments_by_kind"), rN = /* @__PURE__ */ n((e, t, r, i, s) => {
    Mx.forEach((a) => {
      kx(
        e,
        t,
        r,
        i,
        a,
        s
      );
    });
  }, "copy_comments"), rfe = /* @__PURE__ */ n((e, t, r) => {
    t !== r && Mx.forEach((i) => {
      let s = fd(i, r);
      if (!Bx(e, s)) {
        kx(e, e, r, t, i, !0);
        return;
      }
      let a = e[s];
      delete e[s], kx(e, e, r, t, i, !0), gm(e, fd(i, t), a);
    });
  }, "swap_comments"), Ox = /* @__PURE__ */ n((e, t) => {
    tfe.forEach((r) => {
      let i = t[r];
      i && gm(e, r, i);
    });
  }, "assign_non_prop_comments"), ife = /* @__PURE__ */ n((e, t, r) => (r.forEach((i) => {
    !Kce(i) && !zce(i) || Bx(t, i) && (e[i] = t[i], rN(e, t, i, i));
  }), e), "assign");
  iN.exports = {
    SYMBOL_PREFIXES: Mx,
    PREFIX_BEFORE: Nx,
    PREFIX_AFTER_PROP: XB,
    PREFIX_AFTER_COLON: YB,
    PREFIX_AFTER_VALUE: GB,
    PREFIX_AFTER: ZB,
    PREFIX_BEFORE_ALL: QB,
    PREFIX_AFTER_ALL: eN,
    BRACKET_OPEN: Jce,
    BRACKET_CLOSE: Xce,
    CURLY_BRACKET_OPEN: Yce,
    CURLY_BRACKET_CLOSE: Gce,
    COLON: tN,
    COMMA: Zce,
    MINUS: efe,
    EMPTY: Qce,
    UNDEFINED: JB,
    symbol: fd,
    define: gm,
    copy_comments: rN,
    swap_comments: rfe,
    assign_non_prop_comments: Ox,
    assign(e, t, r) {
      if (!zB(e))
        throw new TypeError("Cannot convert undefined or null to object");
      if (!zB(t))
        return e;
      if (r === JB)
        r = Object.keys(t), Ox(e, t);
      else if (Hce(r))
        r.length === 0 && Ox(e, t);
      else throw new TypeError("keys must be array or undefined");
      return ife(e, t, r);
    }
  };
});

// ../node_modules/comment-json/src/array.js
var Lx = E((Cot, uN) => {
  var { isArray: sfe } = dr(), { sort: nfe } = WB(), {
    SYMBOL_PREFIXES: afe,
    UNDEFINED: sN,
    symbol: ofe,
    copy_comments: ufe,
    swap_comments: oN
  } = dd(), lfe = /* @__PURE__ */ n((e) => {
    let { length: t } = e, r = 0, i = t / 2;
    for (; r < i; r++)
      oN(e, r, t - r - 1);
  }, "reverse_comments"), nN = /* @__PURE__ */ n((e, t, r, i, s) => {
    ufe(e, t, r + i, r, s);
  }, "move_comment"), _l = /* @__PURE__ */ n((e, t, r, i, s, a) => {
    if (s > 0) {
      let u = i;
      for (; u-- > 0; )
        nN(e, t, r + u, s, a);
      return;
    }
    let o = 0;
    for (; o < i; ) {
      let u = o++;
      nN(e, t, r + u, s, a);
    }
  }, "move_comments"), aN = /* @__PURE__ */ n((e, t) => {
    afe.forEach((r) => {
      let i = ofe(r, t);
      delete e[i];
    });
  }, "remove_comments"), cfe = /* @__PURE__ */ n((e, t) => {
    let r = t;
    for (; r in e; )
      r = e[r];
    return r;
  }, "get_mapped"), Rx = class e extends Array {
    static {
      n(this, "CommentArray");
    }
    // - deleteCount + items.length
    // We should avoid `splice(begin, deleteCount, ...items)`,
    // because `splice(0, undefined)` is not equivalent to `splice(0)`,
    // as well as:
    // - slice
    splice(...t) {
      let { length: r } = this, i = super.splice(...t), [s, a, ...o] = t;
      s < 0 && (s += r), arguments.length === 1 ? a = r - s : a = Math.min(r - s, a);
      let {
        length: u
      } = o, l = u - a, c = s + a, f = r - c;
      return _l(this, this, c, f, l, !0), i;
    }
    slice(...t) {
      let { length: r } = this, i = super.slice(...t);
      if (!i.length)
        return new e();
      let [s, a] = t;
      return a === sN ? a = r : a < 0 && (a += r), s < 0 ? s += r : s === sN && (s = 0), _l(i, this, s, a - s, -s), i;
    }
    unshift(...t) {
      let { length: r } = this, i = super.unshift(...t), {
        length: s
      } = t;
      return s > 0 && _l(this, this, 0, r, s, !0), i;
    }
    shift() {
      let t = super.shift(), { length: r } = this;
      return aN(this, 0), _l(this, this, 1, r, -1, !0), t;
    }
    reverse() {
      return super.reverse(), lfe(this), this;
    }
    pop() {
      let t = super.pop();
      return aN(this, this.length), t;
    }
    concat(...t) {
      let { length: r } = this, i = super.concat(...t);
      return t.length && (_l(i, this, 0, this.length, 0), t.forEach((s) => {
        let a = r;
        r += sfe(s) ? s.length : 1, s instanceof e && _l(i, s, 0, s.length, a);
      })), i;
    }
    sort(...t) {
      let r = nfe(
        this,
        ...t.slice(0, 1)
      ), i = /* @__PURE__ */ Object.create(null);
      return r.forEach((s, a) => {
        if (s === a)
          return;
        let o = cfe(i, s);
        o !== a && (i[a] = o, oN(this, a, o));
      }), this;
    }
  };
  uN.exports = {
    CommentArray: Rx
  };
});

// ../node_modules/comment-json/src/parse.js
var CN = E((Aot, TN) => {
  var ffe = MB(), {
    CommentArray: dfe
  } = Lx(), {
    PREFIX_BEFORE: Dm,
    PREFIX_AFTER_PROP: pfe,
    PREFIX_AFTER_COLON: hfe,
    PREFIX_AFTER_VALUE: dN,
    PREFIX_AFTER: qx,
    PREFIX_BEFORE_ALL: mfe,
    PREFIX_AFTER_ALL: yfe,
    BRACKET_OPEN: gfe,
    BRACKET_CLOSE: lN,
    CURLY_BRACKET_OPEN: bfe,
    CURLY_BRACKET_CLOSE: cN,
    COLON: pN,
    COMMA: hN,
    MINUS: fN,
    EMPTY: Dfe,
    UNDEFINED: Em,
    define: Ux,
    assign_non_prop_comments: vfe
  } = dd(), mN = /* @__PURE__ */ n((e) => ffe.tokenize(e, {
    comment: !0,
    loc: !0
  }), "tokenize"), $x = [], Aa = null, zs = null, Vx = [], _a, yN = !1, gN = !1, pd = null, hd = null, Ur = null, bN, vm = null, DN = /* @__PURE__ */ n(
  () => {
    Vx.length = $x.length = 0, hd = null, _a = Em;
  }, "clean"), xfe = /* @__PURE__ */ n(() => {
    DN(), pd.length = 0, zs = Aa = pd = hd = Ur = vm = null;
  }, "free"), Wx = /* @__PURE__ */ n((e) => Symbol.for(
    _a !== Em ? e + pN + _a : e
  ), "symbolFor"), Hx = /* @__PURE__ */ n((e, t) => vm ? vm(e, t) : t, "transform"), vN = /* @__PURE__ */ n(() => {
    let e = new SyntaxError(`Unexpected token ${Ur.value.slice(0, 1)}`);
    throw Object.assign(e, Ur.loc.start), e;
  }, "unexpected"), xN = /* @__PURE__ */ n(() => {
    let e = new SyntaxError("Unexpected end of JSON input");
    throw Object.assign(e, hd ? hd.loc.end : {
      line: 1,
      column: 0
    }), e;
  }, "unexpected_end"), $i = /* @__PURE__ */ n(() => {
    let e = pd[++bN];
    gN = Ur && e && Ur.loc.end.line === e.loc.start.line || !1, hd = Ur, Ur = e;
  }, "next"), jx = /* @__PURE__ */ n(() => (Ur || xN(), Ur.type === "Punctuator" ? Ur.value : Ur.type), "type"), Bo = /* @__PURE__ */ n((e) => jx() ===
  e, "is"), bm = /* @__PURE__ */ n((e) => {
    Bo(e) || vN();
  }, "expect"), Kx = /* @__PURE__ */ n((e) => {
    $x.push(Aa), Aa = e;
  }, "set_comments_host"), zx = /* @__PURE__ */ n(() => {
    Aa = $x.pop();
  }, "restore_comments_host"), EN = /* @__PURE__ */ n(() => {
    if (!zs)
      return;
    let e = [];
    for (let r of zs)
      if (r.inline)
        e.push(r);
      else
        break;
    let { length: t } = e;
    t && (t === zs.length ? zs = null : zs.splice(0, t), Ux(Aa, Wx(qx), e));
  }, "assign_after_comments"), wa = /* @__PURE__ */ n((e) => {
    zs && (Ux(Aa, Wx(e), zs), zs = null);
  }, "assign_comments"), Js = /* @__PURE__ */ n((e) => {
    let t = [];
    for (; Ur && (Bo("LineComment") || Bo("BlockComment")); ) {
      let r = {
        ...Ur,
        inline: gN
      };
      t.push(r), $i();
    }
    if (!yN && t.length) {
      if (e) {
        Ux(Aa, Wx(e), t);
        return;
      }
      zs = t;
    }
  }, "parse_comments"), xm = /* @__PURE__ */ n((e, t) => {
    t && Vx.push(_a), _a = e;
  }, "set_prop"), SN = /* @__PURE__ */ n(() => {
    _a = Vx.pop();
  }, "restore_prop"), Efe = /* @__PURE__ */ n(() => {
    let e = {};
    Kx(e), xm(Em, !0);
    let t = !1, r;
    for (Js(); !Bo(cN) && !(t && (wa(dN), bm(hN), $i(), Js(), EN(), Bo(cN))); )
      t = !0, bm("String"), r = JSON.parse(Ur.value), xm(r), wa(Dm), $i(), Js(pfe), bm(pN), $i(), Js(hfe), e[r] = Hx(r, Jx()), Js();
    return t && wa(qx), $i(), _a = void 0, t || wa(Dm), zx(), SN(), e;
  }, "parse_object"), Sfe = /* @__PURE__ */ n(() => {
    let e = new dfe();
    Kx(e), xm(Em, !0);
    let t = !1, r = 0;
    for (Js(); !Bo(lN) && !(t && (wa(dN), bm(hN), $i(), Js(), EN(), Bo(lN))); )
      t = !0, xm(r), wa(Dm), e[r] = Hx(r, Jx()), r++, Js();
    return t && wa(qx), $i(), _a = void 0, t || wa(Dm), zx(), SN(), e;
  }, "parse_array");
  function Jx() {
    let e = jx();
    if (e === bfe)
      return $i(), Efe();
    if (e === gfe)
      return $i(), Sfe();
    let t = Dfe;
    e === fN && ($i(), e = jx(), t = fN);
    let r;
    switch (e) {
      case "String":
      case "Boolean":
      case "Null":
      case "Numeric":
        return r = Ur.value, $i(), JSON.parse(t + r);
      default:
    }
  }
  n(Jx, "walk");
  var Tfe = /* @__PURE__ */ n((e) => Object(e) === e, "isObject"), Cfe = /* @__PURE__ */ n((e, t, r) => {
    DN(), pd = mN(e), vm = t, yN = r, pd.length || xN(), bN = -1, $i(), Kx({}), Js(mfe);
    let i = Jx();
    return Js(yfe), Ur && vN(), !r && i !== null && (Tfe(i) || (i = new Object(i)), vfe(i, Aa)), zx(), i = Hx("", i), xfe(), i;
  }, "parse");
  TN.exports = {
    parse: Cfe,
    tokenize: mN
  };
});

// ../node_modules/repeat-string/index.js
var AN = E((Pot, wN) => {
  "use strict";
  var Bn = "", Xx;
  wN.exports = wfe;
  function wfe(e, t) {
    if (typeof e != "string")
      throw new TypeError("expected a string");
    if (t === 1) return e;
    if (t === 2) return e + e;
    var r = e.length * t;
    if (Xx !== e || typeof Xx > "u")
      Xx = e, Bn = "";
    else if (Bn.length >= r)
      return Bn.substr(0, r);
    for (; r > Bn.length && t > 1; )
      t & 1 && (Bn += e), t >>= 1, e += e;
    return Bn += e, Bn = Bn.substr(0, r), Bn;
  }
  n(wfe, "repeat");
});

// ../node_modules/comment-json/src/stringify.js
var LN = E((Iot, RN) => {
  var {
    isArray: Zx,
    isObject: _N,
    isFunction: Gx,
    isNumber: Afe,
    isString: _fe
  } = dr(), Pfe = AN(), {
    PREFIX_BEFORE_ALL: Ffe,
    PREFIX_BEFORE: PN,
    PREFIX_AFTER_PROP: Ife,
    PREFIX_AFTER_COLON: Ofe,
    PREFIX_AFTER_VALUE: kfe,
    PREFIX_AFTER: Qx,
    PREFIX_AFTER_ALL: Bfe,
    BRACKET_OPEN: Nfe,
    BRACKET_CLOSE: Mfe,
    CURLY_BRACKET_OPEN: Rfe,
    CURLY_BRACKET_CLOSE: Lfe,
    COLON: jfe,
    COMMA: FN,
    EMPTY: Ti,
    UNDEFINED: qfe
  } = dd(), Yx = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, eE = "\
 ", No = `
`, IN = "null", ON = /* @__PURE__ */ n((e) => `${PN}:${e}`, "BEFORE"), Ufe = /* @__PURE__ */ n((e) => `${Ife}:${e}`, "AFTER_PROP"), $fe = /* @__PURE__ */ n(
  (e) => `${Ofe}:${e}`, "AFTER_COLON"), kN = /* @__PURE__ */ n((e) => `${kfe}:${e}`, "AFTER_VALUE"), BN = /* @__PURE__ */ n((e) => `${Qx}:${e}`,
  "AFTER"), Vfe = {
    "\b": "\\b",
    "	": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': '\\"',
    "\\": "\\\\"
  }, Wfe = /* @__PURE__ */ n((e) => (Yx.lastIndex = 0, Yx.test(e) ? e.replace(Yx, (t) => {
    let r = Vfe[t];
    return typeof r == "string" ? r : t;
  }) : e), "escape"), NN = /* @__PURE__ */ n((e) => `"${Wfe(e)}"`, "quote"), Hfe = /* @__PURE__ */ n((e, t) => t ? `//${e}` : `/*${e}*/`, "c\
omment_stringify"), Si = /* @__PURE__ */ n((e, t, r, i) => {
    let s = e[Symbol.for(t)];
    if (!s || !s.length)
      return Ti;
    let a = !1, o = s.reduce((u, {
      inline: l,
      type: c,
      value: f
    }) => {
      let m = l ? eE : No + r;
      return a = c === "LineComment", u + m + Hfe(f, a);
    }, Ti);
    return i || a ? o + No + r : o;
  }, "process_comments"), Pl = null, yd = Ti, Kfe = /* @__PURE__ */ n(() => {
    Pl = null, yd = Ti;
  }, "clean"), md = /* @__PURE__ */ n((e, t, r) => e ? t ? e + t.trim() + No + r : e.trimRight() + No + r : t ? t.trimRight() + No + r : Ti,
  "join"), MN = /* @__PURE__ */ n((e, t, r) => {
    let i = Si(t, PN, r + yd, !0);
    return md(i, e, r);
  }, "join_content"), zfe = /* @__PURE__ */ n((e, t) => {
    let r = t + yd, { length: i } = e, s = Ti, a = Ti;
    for (let o = 0; o < i; o++) {
      o !== 0 && (s += FN);
      let u = md(
        a,
        Si(e, ON(o), r),
        r
      );
      s += u || No + r, s += tE(o, e, r) || IN, s += Si(e, kN(o), r), a = Si(e, BN(o), r);
    }
    return s += md(
      a,
      Si(e, Qx, r),
      r
    ), Nfe + MN(s, e, t) + Mfe;
  }, "array_stringify"), Jfe = /* @__PURE__ */ n((e, t) => {
    if (!e)
      return "null";
    let r = t + yd, i = Ti, s = Ti, a = !0, o = Zx(Pl) ? Pl : Object.keys(e), u = /* @__PURE__ */ n((l) => {
      let c = tE(l, e, r);
      if (c === qfe)
        return;
      a || (i += FN), a = !1;
      let f = md(
        s,
        Si(e, ON(l), r),
        r
      );
      i += f || No + r, i += NN(l) + Si(e, Ufe(l), r) + jfe + Si(e, $fe(l), r) + eE + c + Si(e, kN(l), r), s = Si(e, BN(l), r);
    }, "iteratee");
    return o.forEach(u), i += md(
      s,
      Si(e, Qx, r),
      r
    ), Rfe + MN(i, e, t) + Lfe;
  }, "object_stringify");
  function tE(e, t, r) {
    let i = t[e];
    switch (_N(i) && Gx(i.toJSON) && (i = i.toJSON(e)), Gx(Pl) && (i = Pl.call(t, e, i)), typeof i) {
      case "string":
        return NN(i);
      case "number":
        return Number.isFinite(i) ? String(i) : IN;
      case "boolean":
      case "null":
        return String(i);
      // If the type is 'object', we might be dealing with an object or an array or
      // null.
      case "object":
        return Zx(i) ? zfe(i, r) : Jfe(i, r);
      // undefined
      default:
    }
  }
  n(tE, "stringify");
  var Xfe = /* @__PURE__ */ n((e) => _fe(e) ? e : Afe(e) ? Pfe(eE, e) : Ti, "get_indent"), { toString: Yfe } = Object.prototype, Gfe = [
    "[object Number]",
    "[object String]",
    "[object Boolean]"
  ], Zfe = /* @__PURE__ */ n((e) => {
    if (typeof e != "object")
      return !1;
    let t = Yfe.call(e);
    return Gfe.includes(t);
  }, "is_primitive_object");
  RN.exports = (e, t, r) => {
    let i = Xfe(r);
    if (!i)
      return JSON.stringify(e, t);
    !Gx(t) && !Zx(t) && (t = null), Pl = t, yd = i;
    let s = Zfe(e) ? JSON.stringify(e) : tE("", { "": e }, Ti);
    return Kfe(), _N(e) ? Si(e, Ffe, Ti).trimLeft() + s + Si(e, Bfe, Ti).trimRight() : s;
  };
});

// ../node_modules/comment-json/src/index.js
var qN = E((kot, jN) => {
  var { parse: Qfe, tokenize: ede } = CN(), tde = LN(), { CommentArray: rde } = Lx(), { assign: ide } = dd();
  jN.exports = {
    parse: Qfe,
    stringify: tde,
    tokenize: ede,
    CommentArray: rde,
    assign: ide
  };
});

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var Sm = E((iE) => {
  "use strict";
  Object.defineProperty(iE, "__esModule", {
    value: !0
  });
  iE.default = lde;
  function lde(e, t) {
    let r = Object.keys(t);
    for (let i of r)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  n(lde, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var Fl = E((sE) => {
  "use strict";
  Object.defineProperty(sE, "__esModule", {
    value: !0
  });
  sE.default = cde;
  var VN = /* @__PURE__ */ new Set();
  function cde(e, t, r = "", i = e) {
    if (VN.has(i)) return;
    VN.add(i);
    let {
      internal: s,
      trace: a
    } = fde(1, 2);
    s || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${a}`);
  }
  n(cde, "deprecationWarning");
  function fde(e, t) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: i
    } = Error, s;
    if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(o, u) {
      s = u;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = i, !s) return {
      internal: !1,
      trace: ""
    };
    let a = s.slice(1 + e, 1 + e + t);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  n(fde, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var Jt = E((A) => {
  "use strict";
  Object.defineProperty(A, "__esModule", {
    value: !0
  });
  A.isAccessor = Pye;
  A.isAnyTypeAnnotation = zpe;
  A.isArgumentPlaceholder = E0e;
  A.isArrayExpression = dde;
  A.isArrayPattern = cpe;
  A.isArrayTypeAnnotation = Jpe;
  A.isArrowFunctionExpression = fpe;
  A.isAssignmentExpression = pde;
  A.isAssignmentPattern = lpe;
  A.isAwaitExpression = Bpe;
  A.isBigIntLiteral = Mpe;
  A.isBinary = Gme;
  A.isBinaryExpression = hde;
  A.isBindExpression = S0e;
  A.isBlock = eye;
  A.isBlockParent = Qme;
  A.isBlockStatement = bde;
  A.isBooleanLiteral = jde;
  A.isBooleanLiteralTypeAnnotation = Ype;
  A.isBooleanTypeAnnotation = Xpe;
  A.isBreakStatement = Dde;
  A.isCallExpression = vde;
  A.isCatchClause = xde;
  A.isClass = wye;
  A.isClassAccessorProperty = Upe;
  A.isClassBody = dpe;
  A.isClassDeclaration = hpe;
  A.isClassExpression = ppe;
  A.isClassImplements = Zpe;
  A.isClassMethod = wpe;
  A.isClassPrivateMethod = Vpe;
  A.isClassPrivateProperty = $pe;
  A.isClassProperty = qpe;
  A.isCompletionStatement = iye;
  A.isConditional = sye;
  A.isConditionalExpression = Ede;
  A.isContinueStatement = Sde;
  A.isDebuggerStatement = Tde;
  A.isDecimalLiteral = P0e;
  A.isDeclaration = pye;
  A.isDeclareClass = Qpe;
  A.isDeclareExportAllDeclaration = uhe;
  A.isDeclareExportDeclaration = ohe;
  A.isDeclareFunction = ehe;
  A.isDeclareInterface = the;
  A.isDeclareModule = rhe;
  A.isDeclareModuleExports = ihe;
  A.isDeclareOpaqueType = nhe;
  A.isDeclareTypeAlias = she;
  A.isDeclareVariable = ahe;
  A.isDeclaredPredicate = lhe;
  A.isDecorator = T0e;
  A.isDirective = yde;
  A.isDirectiveLiteral = gde;
  A.isDoExpression = C0e;
  A.isDoWhileStatement = Cde;
  A.isEmptyStatement = wde;
  A.isEmptyTypeAnnotation = vhe;
  A.isEnumBody = Mye;
  A.isEnumBooleanBody = Jhe;
  A.isEnumBooleanMember = Zhe;
  A.isEnumDeclaration = zhe;
  A.isEnumDefaultedMember = t0e;
  A.isEnumMember = Rye;
  A.isEnumNumberBody = Xhe;
  A.isEnumNumberMember = Qhe;
  A.isEnumStringBody = Yhe;
  A.isEnumStringMember = e0e;
  A.isEnumSymbolBody = Ghe;
  A.isExistsTypeAnnotation = che;
  A.isExportAllDeclaration = mpe;
  A.isExportDeclaration = Aye;
  A.isExportDefaultDeclaration = ype;
  A.isExportDefaultSpecifier = w0e;
  A.isExportNamedDeclaration = gpe;
  A.isExportNamespaceSpecifier = Rpe;
  A.isExportSpecifier = bpe;
  A.isExpression = Yme;
  A.isExpressionStatement = Ade;
  A.isExpressionWrapper = oye;
  A.isFile = _de;
  A.isFlow = Iye;
  A.isFlowBaseAnnotation = kye;
  A.isFlowDeclaration = Bye;
  A.isFlowPredicate = Nye;
  A.isFlowType = Oye;
  A.isFor = uye;
  A.isForInStatement = Pde;
  A.isForOfStatement = Dpe;
  A.isForStatement = Fde;
  A.isForXStatement = lye;
  A.isFunction = cye;
  A.isFunctionDeclaration = Ide;
  A.isFunctionExpression = Ode;
  A.isFunctionParameter = hye;
  A.isFunctionParent = fye;
  A.isFunctionTypeAnnotation = fhe;
  A.isFunctionTypeParam = dhe;
  A.isGenericTypeAnnotation = phe;
  A.isIdentifier = kde;
  A.isIfStatement = Bde;
  A.isImmutable = Dye;
  A.isImport = Npe;
  A.isImportAttribute = Kpe;
  A.isImportDeclaration = vpe;
  A.isImportDefaultSpecifier = xpe;
  A.isImportExpression = Tpe;
  A.isImportNamespaceSpecifier = Epe;
  A.isImportOrExportDeclaration = WN;
  A.isImportSpecifier = Spe;
  A.isIndexedAccessType = r0e;
  A.isInferredPredicate = hhe;
  A.isInterfaceDeclaration = yhe;
  A.isInterfaceExtends = mhe;
  A.isInterfaceTypeAnnotation = ghe;
  A.isInterpreterDirective = mde;
  A.isIntersectionTypeAnnotation = bhe;
  A.isJSX = Lye;
  A.isJSXAttribute = s0e;
  A.isJSXClosingElement = n0e;
  A.isJSXClosingFragment = b0e;
  A.isJSXElement = a0e;
  A.isJSXEmptyExpression = o0e;
  A.isJSXExpressionContainer = u0e;
  A.isJSXFragment = y0e;
  A.isJSXIdentifier = c0e;
  A.isJSXMemberExpression = f0e;
  A.isJSXNamespacedName = d0e;
  A.isJSXOpeningElement = p0e;
  A.isJSXOpeningFragment = g0e;
  A.isJSXSpreadAttribute = h0e;
  A.isJSXSpreadChild = l0e;
  A.isJSXText = m0e;
  A.isLVal = yye;
  A.isLabeledStatement = Nde;
  A.isLiteral = bye;
  A.isLogicalExpression = Ude;
  A.isLoop = nye;
  A.isMemberExpression = $de;
  A.isMetaProperty = Cpe;
  A.isMethod = xye;
  A.isMiscellaneous = jye;
  A.isMixedTypeAnnotation = Dhe;
  A.isModuleDeclaration = Jye;
  A.isModuleExpression = F0e;
  A.isModuleSpecifier = _ye;
  A.isNewExpression = Vde;
  A.isNoop = D0e;
  A.isNullLiteral = Lde;
  A.isNullLiteralTypeAnnotation = Gpe;
  A.isNullableTypeAnnotation = xhe;
  A.isNumberLiteral = Wye;
  A.isNumberLiteralTypeAnnotation = Ehe;
  A.isNumberTypeAnnotation = She;
  A.isNumericLiteral = Rde;
  A.isObjectExpression = Hde;
  A.isObjectMember = Eye;
  A.isObjectMethod = Kde;
  A.isObjectPattern = Ape;
  A.isObjectProperty = zde;
  A.isObjectTypeAnnotation = The;
  A.isObjectTypeCallProperty = whe;
  A.isObjectTypeIndexer = Ahe;
  A.isObjectTypeInternalSlot = Che;
  A.isObjectTypeProperty = _he;
  A.isObjectTypeSpreadProperty = Phe;
  A.isOpaqueType = Fhe;
  A.isOptionalCallExpression = jpe;
  A.isOptionalIndexedAccessType = i0e;
  A.isOptionalMemberExpression = Lpe;
  A.isParenthesizedExpression = Gde;
  A.isPattern = Cye;
  A.isPatternLike = mye;
  A.isPipelineBareFunction = k0e;
  A.isPipelinePrimaryTopicReference = B0e;
  A.isPipelineTopicExpression = O0e;
  A.isPlaceholder = v0e;
  A.isPrivate = Fye;
  A.isPrivateName = Wpe;
  A.isProgram = Wde;
  A.isProperty = Sye;
  A.isPureish = dye;
  A.isQualifiedTypeIdentifier = Ihe;
  A.isRecordExpression = A0e;
  A.isRegExpLiteral = qde;
  A.isRegexLiteral = Hye;
  A.isRestElement = Jde;
  A.isRestProperty = Kye;
  A.isReturnStatement = Xde;
  A.isScopable = Zme;
  A.isSequenceExpression = Yde;
  A.isSpreadElement = _pe;
  A.isSpreadProperty = zye;
  A.isStandardized = Xme;
  A.isStatement = tye;
  A.isStaticBlock = Hpe;
  A.isStringLiteral = Mde;
  A.isStringLiteralTypeAnnotation = Ohe;
  A.isStringTypeAnnotation = khe;
  A.isSuper = Ppe;
  A.isSwitchCase = Zde;
  A.isSwitchStatement = Qde;
  A.isSymbolTypeAnnotation = Bhe;
  A.isTSAnyKeyword = H0e;
  A.isTSArrayType = fme;
  A.isTSAsExpression = Ime;
  A.isTSBaseType = Vye;
  A.isTSBigIntKeyword = z0e;
  A.isTSBooleanKeyword = K0e;
  A.isTSCallSignatureDeclaration = q0e;
  A.isTSConditionalType = bme;
  A.isTSConstructSignatureDeclaration = U0e;
  A.isTSConstructorType = ame;
  A.isTSDeclareFunction = R0e;
  A.isTSDeclareMethod = L0e;
  A.isTSEntityName = gye;
  A.isTSEnumBody = Bme;
  A.isTSEnumDeclaration = Nme;
  A.isTSEnumMember = Mme;
  A.isTSExportAssignment = Vme;
  A.isTSExpressionWithTypeArguments = wme;
  A.isTSExternalModuleReference = Ume;
  A.isTSFunctionType = nme;
  A.isTSImportEqualsDeclaration = qme;
  A.isTSImportType = jme;
  A.isTSIndexSignature = W0e;
  A.isTSIndexedAccessType = Eme;
  A.isTSInferType = Dme;
  A.isTSInstantiationExpression = Fme;
  A.isTSInterfaceBody = _me;
  A.isTSInterfaceDeclaration = Ame;
  A.isTSIntersectionType = gme;
  A.isTSIntrinsicKeyword = J0e;
  A.isTSLiteralType = Cme;
  A.isTSMappedType = Sme;
  A.isTSMethodSignature = V0e;
  A.isTSModuleBlock = Lme;
  A.isTSModuleDeclaration = Rme;
  A.isTSNamedTupleMember = mme;
  A.isTSNamespaceExportDeclaration = Wme;
  A.isTSNeverKeyword = X0e;
  A.isTSNonNullExpression = $me;
  A.isTSNullKeyword = Y0e;
  A.isTSNumberKeyword = G0e;
  A.isTSObjectKeyword = Z0e;
  A.isTSOptionalType = pme;
  A.isTSParameterProperty = M0e;
  A.isTSParenthesizedType = vme;
  A.isTSPropertySignature = $0e;
  A.isTSQualifiedName = j0e;
  A.isTSRestType = hme;
  A.isTSSatisfiesExpression = Ome;
  A.isTSStringKeyword = Q0e;
  A.isTSSymbolKeyword = eme;
  A.isTSTemplateLiteralType = Tme;
  A.isTSThisType = sme;
  A.isTSTupleType = dme;
  A.isTSType = $ye;
  A.isTSTypeAliasDeclaration = Pme;
  A.isTSTypeAnnotation = Hme;
  A.isTSTypeAssertion = kme;
  A.isTSTypeElement = Uye;
  A.isTSTypeLiteral = cme;
  A.isTSTypeOperator = xme;
  A.isTSTypeParameter = Jme;
  A.isTSTypeParameterDeclaration = zme;
  A.isTSTypeParameterInstantiation = Kme;
  A.isTSTypePredicate = ume;
  A.isTSTypeQuery = lme;
  A.isTSTypeReference = ome;
  A.isTSUndefinedKeyword = tme;
  A.isTSUnionType = yme;
  A.isTSUnknownKeyword = rme;
  A.isTSVoidKeyword = ime;
  A.isTaggedTemplateExpression = Fpe;
  A.isTemplateElement = Ipe;
  A.isTemplateLiteral = Ope;
  A.isTerminatorless = rye;
  A.isThisExpression = epe;
  A.isThisTypeAnnotation = Nhe;
  A.isThrowStatement = tpe;
  A.isTopicReference = I0e;
  A.isTryStatement = rpe;
  A.isTupleExpression = _0e;
  A.isTupleTypeAnnotation = Mhe;
  A.isTypeAlias = Lhe;
  A.isTypeAnnotation = jhe;
  A.isTypeCastExpression = qhe;
  A.isTypeParameter = Uhe;
  A.isTypeParameterDeclaration = $he;
  A.isTypeParameterInstantiation = Vhe;
  A.isTypeScript = qye;
  A.isTypeofTypeAnnotation = Rhe;
  A.isUnaryExpression = ipe;
  A.isUnaryLike = Tye;
  A.isUnionTypeAnnotation = Whe;
  A.isUpdateExpression = spe;
  A.isUserWhitespacable = vye;
  A.isV8IntrinsicIdentifier = x0e;
  A.isVariableDeclaration = npe;
  A.isVariableDeclarator = ape;
  A.isVariance = Hhe;
  A.isVoidPattern = N0e;
  A.isVoidTypeAnnotation = Khe;
  A.isWhile = aye;
  A.isWhileStatement = ope;
  A.isWithStatement = upe;
  A.isYieldExpression = kpe;
  var F = Sm(), bd = Fl();
  function dde(e, t) {
    return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(dde, "isArrayExpression");
  function pde(e, t) {
    return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(pde, "isAssignmentExpression");
  function hde(e, t) {
    return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(hde, "isBinaryExpression");
  function mde(e, t) {
    return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(mde, "isInterpreterDirective");
  function yde(e, t) {
    return !e || e.type !== "Directive" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(yde, "isDirective");
  function gde(e, t) {
    return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(gde, "isDirectiveLiteral");
  function bde(e, t) {
    return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(bde, "isBlockStatement");
  function Dde(e, t) {
    return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Dde, "isBreakStatement");
  function vde(e, t) {
    return !e || e.type !== "CallExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(vde, "isCallExpression");
  function xde(e, t) {
    return !e || e.type !== "CatchClause" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(xde, "isCatchClause");
  function Ede(e, t) {
    return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ede, "isConditionalExpression");
  function Sde(e, t) {
    return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Sde, "isContinueStatement");
  function Tde(e, t) {
    return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Tde, "isDebuggerStatement");
  function Cde(e, t) {
    return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Cde, "isDoWhileStatement");
  function wde(e, t) {
    return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(wde, "isEmptyStatement");
  function Ade(e, t) {
    return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ade, "isExpressionStatement");
  function _de(e, t) {
    return !e || e.type !== "File" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(_de, "isFile");
  function Pde(e, t) {
    return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Pde, "isForInStatement");
  function Fde(e, t) {
    return !e || e.type !== "ForStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Fde, "isForStatement");
  function Ide(e, t) {
    return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ide, "isFunctionDeclaration");
  function Ode(e, t) {
    return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ode, "isFunctionExpression");
  function kde(e, t) {
    return !e || e.type !== "Identifier" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(kde, "isIdentifier");
  function Bde(e, t) {
    return !e || e.type !== "IfStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Bde, "isIfStatement");
  function Nde(e, t) {
    return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Nde, "isLabeledStatement");
  function Mde(e, t) {
    return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Mde, "isStringLiteral");
  function Rde(e, t) {
    return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Rde, "isNumericLiteral");
  function Lde(e, t) {
    return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Lde, "isNullLiteral");
  function jde(e, t) {
    return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(jde, "isBooleanLiteral");
  function qde(e, t) {
    return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(qde, "isRegExpLiteral");
  function Ude(e, t) {
    return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ude, "isLogicalExpression");
  function $de(e, t) {
    return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n($de, "isMemberExpression");
  function Vde(e, t) {
    return !e || e.type !== "NewExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Vde, "isNewExpression");
  function Wde(e, t) {
    return !e || e.type !== "Program" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Wde, "isProgram");
  function Hde(e, t) {
    return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Hde, "isObjectExpression");
  function Kde(e, t) {
    return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Kde, "isObjectMethod");
  function zde(e, t) {
    return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(zde, "isObjectProperty");
  function Jde(e, t) {
    return !e || e.type !== "RestElement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Jde, "isRestElement");
  function Xde(e, t) {
    return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Xde, "isReturnStatement");
  function Yde(e, t) {
    return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Yde, "isSequenceExpression");
  function Gde(e, t) {
    return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Gde, "isParenthesizedExpression");
  function Zde(e, t) {
    return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Zde, "isSwitchCase");
  function Qde(e, t) {
    return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Qde, "isSwitchStatement");
  function epe(e, t) {
    return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(epe, "isThisExpression");
  function tpe(e, t) {
    return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(tpe, "isThrowStatement");
  function rpe(e, t) {
    return !e || e.type !== "TryStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(rpe, "isTryStatement");
  function ipe(e, t) {
    return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ipe, "isUnaryExpression");
  function spe(e, t) {
    return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(spe, "isUpdateExpression");
  function npe(e, t) {
    return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(npe, "isVariableDeclaration");
  function ape(e, t) {
    return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ape, "isVariableDeclarator");
  function ope(e, t) {
    return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ope, "isWhileStatement");
  function upe(e, t) {
    return !e || e.type !== "WithStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(upe, "isWithStatement");
  function lpe(e, t) {
    return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(lpe, "isAssignmentPattern");
  function cpe(e, t) {
    return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(cpe, "isArrayPattern");
  function fpe(e, t) {
    return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(fpe, "isArrowFunctionExpression");
  function dpe(e, t) {
    return !e || e.type !== "ClassBody" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(dpe, "isClassBody");
  function ppe(e, t) {
    return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ppe, "isClassExpression");
  function hpe(e, t) {
    return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(hpe, "isClassDeclaration");
  function mpe(e, t) {
    return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(mpe, "isExportAllDeclaration");
  function ype(e, t) {
    return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ype, "isExportDefaultDeclaration");
  function gpe(e, t) {
    return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(gpe, "isExportNamedDeclaration");
  function bpe(e, t) {
    return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(bpe, "isExportSpecifier");
  function Dpe(e, t) {
    return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Dpe, "isForOfStatement");
  function vpe(e, t) {
    return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(vpe, "isImportDeclaration");
  function xpe(e, t) {
    return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(xpe, "isImportDefaultSpecifier");
  function Epe(e, t) {
    return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Epe, "isImportNamespaceSpecifier");
  function Spe(e, t) {
    return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Spe, "isImportSpecifier");
  function Tpe(e, t) {
    return !e || e.type !== "ImportExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Tpe, "isImportExpression");
  function Cpe(e, t) {
    return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Cpe, "isMetaProperty");
  function wpe(e, t) {
    return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(wpe, "isClassMethod");
  function Ape(e, t) {
    return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ape, "isObjectPattern");
  function _pe(e, t) {
    return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(_pe, "isSpreadElement");
  function Ppe(e, t) {
    return !e || e.type !== "Super" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ppe, "isSuper");
  function Fpe(e, t) {
    return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Fpe, "isTaggedTemplateExpression");
  function Ipe(e, t) {
    return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ipe, "isTemplateElement");
  function Ope(e, t) {
    return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ope, "isTemplateLiteral");
  function kpe(e, t) {
    return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(kpe, "isYieldExpression");
  function Bpe(e, t) {
    return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Bpe, "isAwaitExpression");
  function Npe(e, t) {
    return !e || e.type !== "Import" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Npe, "isImport");
  function Mpe(e, t) {
    return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Mpe, "isBigIntLiteral");
  function Rpe(e, t) {
    return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Rpe, "isExportNamespaceSpecifier");
  function Lpe(e, t) {
    return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Lpe, "isOptionalMemberExpression");
  function jpe(e, t) {
    return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(jpe, "isOptionalCallExpression");
  function qpe(e, t) {
    return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(qpe, "isClassProperty");
  function Upe(e, t) {
    return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Upe, "isClassAccessorProperty");
  function $pe(e, t) {
    return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, F.default)(e, t);
  }
  n($pe, "isClassPrivateProperty");
  function Vpe(e, t) {
    return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Vpe, "isClassPrivateMethod");
  function Wpe(e, t) {
    return !e || e.type !== "PrivateName" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Wpe, "isPrivateName");
  function Hpe(e, t) {
    return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Hpe, "isStaticBlock");
  function Kpe(e, t) {
    return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Kpe, "isImportAttribute");
  function zpe(e, t) {
    return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(zpe, "isAnyTypeAnnotation");
  function Jpe(e, t) {
    return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Jpe, "isArrayTypeAnnotation");
  function Xpe(e, t) {
    return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Xpe, "isBooleanTypeAnnotation");
  function Ype(e, t) {
    return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ype, "isBooleanLiteralTypeAnnotation");
  function Gpe(e, t) {
    return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Gpe, "isNullLiteralTypeAnnotation");
  function Zpe(e, t) {
    return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Zpe, "isClassImplements");
  function Qpe(e, t) {
    return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Qpe, "isDeclareClass");
  function ehe(e, t) {
    return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ehe, "isDeclareFunction");
  function the(e, t) {
    return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(the, "isDeclareInterface");
  function rhe(e, t) {
    return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(rhe, "isDeclareModule");
  function ihe(e, t) {
    return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ihe, "isDeclareModuleExports");
  function she(e, t) {
    return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(she, "isDeclareTypeAlias");
  function nhe(e, t) {
    return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(nhe, "isDeclareOpaqueType");
  function ahe(e, t) {
    return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ahe, "isDeclareVariable");
  function ohe(e, t) {
    return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ohe, "isDeclareExportDeclaration");
  function uhe(e, t) {
    return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(uhe, "isDeclareExportAllDeclaration");
  function lhe(e, t) {
    return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(lhe, "isDeclaredPredicate");
  function che(e, t) {
    return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(che, "isExistsTypeAnnotation");
  function fhe(e, t) {
    return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(fhe, "isFunctionTypeAnnotation");
  function dhe(e, t) {
    return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(dhe, "isFunctionTypeParam");
  function phe(e, t) {
    return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(phe, "isGenericTypeAnnotation");
  function hhe(e, t) {
    return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(hhe, "isInferredPredicate");
  function mhe(e, t) {
    return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(mhe, "isInterfaceExtends");
  function yhe(e, t) {
    return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(yhe, "isInterfaceDeclaration");
  function ghe(e, t) {
    return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ghe, "isInterfaceTypeAnnotation");
  function bhe(e, t) {
    return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(bhe, "isIntersectionTypeAnnotation");
  function Dhe(e, t) {
    return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Dhe, "isMixedTypeAnnotation");
  function vhe(e, t) {
    return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(vhe, "isEmptyTypeAnnotation");
  function xhe(e, t) {
    return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(xhe, "isNullableTypeAnnotation");
  function Ehe(e, t) {
    return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ehe, "isNumberLiteralTypeAnnotation");
  function She(e, t) {
    return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(She, "isNumberTypeAnnotation");
  function The(e, t) {
    return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(The, "isObjectTypeAnnotation");
  function Che(e, t) {
    return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Che, "isObjectTypeInternalSlot");
  function whe(e, t) {
    return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(whe, "isObjectTypeCallProperty");
  function Ahe(e, t) {
    return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ahe, "isObjectTypeIndexer");
  function _he(e, t) {
    return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(_he, "isObjectTypeProperty");
  function Phe(e, t) {
    return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Phe, "isObjectTypeSpreadProperty");
  function Fhe(e, t) {
    return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Fhe, "isOpaqueType");
  function Ihe(e, t) {
    return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ihe, "isQualifiedTypeIdentifier");
  function Ohe(e, t) {
    return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ohe, "isStringLiteralTypeAnnotation");
  function khe(e, t) {
    return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(khe, "isStringTypeAnnotation");
  function Bhe(e, t) {
    return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Bhe, "isSymbolTypeAnnotation");
  function Nhe(e, t) {
    return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Nhe, "isThisTypeAnnotation");
  function Mhe(e, t) {
    return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Mhe, "isTupleTypeAnnotation");
  function Rhe(e, t) {
    return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Rhe, "isTypeofTypeAnnotation");
  function Lhe(e, t) {
    return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Lhe, "isTypeAlias");
  function jhe(e, t) {
    return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(jhe, "isTypeAnnotation");
  function qhe(e, t) {
    return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(qhe, "isTypeCastExpression");
  function Uhe(e, t) {
    return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Uhe, "isTypeParameter");
  function $he(e, t) {
    return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n($he, "isTypeParameterDeclaration");
  function Vhe(e, t) {
    return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Vhe, "isTypeParameterInstantiation");
  function Whe(e, t) {
    return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Whe, "isUnionTypeAnnotation");
  function Hhe(e, t) {
    return !e || e.type !== "Variance" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Hhe, "isVariance");
  function Khe(e, t) {
    return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Khe, "isVoidTypeAnnotation");
  function zhe(e, t) {
    return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(zhe, "isEnumDeclaration");
  function Jhe(e, t) {
    return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Jhe, "isEnumBooleanBody");
  function Xhe(e, t) {
    return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Xhe, "isEnumNumberBody");
  function Yhe(e, t) {
    return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Yhe, "isEnumStringBody");
  function Ghe(e, t) {
    return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ghe, "isEnumSymbolBody");
  function Zhe(e, t) {
    return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Zhe, "isEnumBooleanMember");
  function Qhe(e, t) {
    return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Qhe, "isEnumNumberMember");
  function e0e(e, t) {
    return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(e0e, "isEnumStringMember");
  function t0e(e, t) {
    return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(t0e, "isEnumDefaultedMember");
  function r0e(e, t) {
    return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(r0e, "isIndexedAccessType");
  function i0e(e, t) {
    return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(i0e, "isOptionalIndexedAccessType");
  function s0e(e, t) {
    return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(s0e, "isJSXAttribute");
  function n0e(e, t) {
    return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(n0e, "isJSXClosingElement");
  function a0e(e, t) {
    return !e || e.type !== "JSXElement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(a0e, "isJSXElement");
  function o0e(e, t) {
    return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(o0e, "isJSXEmptyExpression");
  function u0e(e, t) {
    return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(u0e, "isJSXExpressionContainer");
  function l0e(e, t) {
    return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(l0e, "isJSXSpreadChild");
  function c0e(e, t) {
    return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(c0e, "isJSXIdentifier");
  function f0e(e, t) {
    return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(f0e, "isJSXMemberExpression");
  function d0e(e, t) {
    return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(d0e, "isJSXNamespacedName");
  function p0e(e, t) {
    return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(p0e, "isJSXOpeningElement");
  function h0e(e, t) {
    return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(h0e, "isJSXSpreadAttribute");
  function m0e(e, t) {
    return !e || e.type !== "JSXText" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(m0e, "isJSXText");
  function y0e(e, t) {
    return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(y0e, "isJSXFragment");
  function g0e(e, t) {
    return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(g0e, "isJSXOpeningFragment");
  function b0e(e, t) {
    return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(b0e, "isJSXClosingFragment");
  function D0e(e, t) {
    return !e || e.type !== "Noop" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(D0e, "isNoop");
  function v0e(e, t) {
    return !e || e.type !== "Placeholder" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(v0e, "isPlaceholder");
  function x0e(e, t) {
    return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(x0e, "isV8IntrinsicIdentifier");
  function E0e(e, t) {
    return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(E0e, "isArgumentPlaceholder");
  function S0e(e, t) {
    return !e || e.type !== "BindExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(S0e, "isBindExpression");
  function T0e(e, t) {
    return !e || e.type !== "Decorator" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(T0e, "isDecorator");
  function C0e(e, t) {
    return !e || e.type !== "DoExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(C0e, "isDoExpression");
  function w0e(e, t) {
    return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(w0e, "isExportDefaultSpecifier");
  function A0e(e, t) {
    return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(A0e, "isRecordExpression");
  function _0e(e, t) {
    return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(_0e, "isTupleExpression");
  function P0e(e, t) {
    return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(P0e, "isDecimalLiteral");
  function F0e(e, t) {
    return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(F0e, "isModuleExpression");
  function I0e(e, t) {
    return !e || e.type !== "TopicReference" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(I0e, "isTopicReference");
  function O0e(e, t) {
    return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(O0e, "isPipelineTopicExpression");
  function k0e(e, t) {
    return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(k0e, "isPipelineBareFunction");
  function B0e(e, t) {
    return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(B0e, "isPipelinePrimaryTopicReference");
  function N0e(e, t) {
    return !e || e.type !== "VoidPattern" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(N0e, "isVoidPattern");
  function M0e(e, t) {
    return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(M0e, "isTSParameterProperty");
  function R0e(e, t) {
    return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(R0e, "isTSDeclareFunction");
  function L0e(e, t) {
    return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(L0e, "isTSDeclareMethod");
  function j0e(e, t) {
    return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(j0e, "isTSQualifiedName");
  function q0e(e, t) {
    return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(q0e, "isTSCallSignatureDeclaration");
  function U0e(e, t) {
    return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(U0e, "isTSConstructSignatureDeclaration");
  function $0e(e, t) {
    return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, F.default)(e, t);
  }
  n($0e, "isTSPropertySignature");
  function V0e(e, t) {
    return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(V0e, "isTSMethodSignature");
  function W0e(e, t) {
    return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(W0e, "isTSIndexSignature");
  function H0e(e, t) {
    return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(H0e, "isTSAnyKeyword");
  function K0e(e, t) {
    return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(K0e, "isTSBooleanKeyword");
  function z0e(e, t) {
    return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(z0e, "isTSBigIntKeyword");
  function J0e(e, t) {
    return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(J0e, "isTSIntrinsicKeyword");
  function X0e(e, t) {
    return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(X0e, "isTSNeverKeyword");
  function Y0e(e, t) {
    return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Y0e, "isTSNullKeyword");
  function G0e(e, t) {
    return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(G0e, "isTSNumberKeyword");
  function Z0e(e, t) {
    return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Z0e, "isTSObjectKeyword");
  function Q0e(e, t) {
    return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Q0e, "isTSStringKeyword");
  function eme(e, t) {
    return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(eme, "isTSSymbolKeyword");
  function tme(e, t) {
    return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(tme, "isTSUndefinedKeyword");
  function rme(e, t) {
    return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(rme, "isTSUnknownKeyword");
  function ime(e, t) {
    return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ime, "isTSVoidKeyword");
  function sme(e, t) {
    return !e || e.type !== "TSThisType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(sme, "isTSThisType");
  function nme(e, t) {
    return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(nme, "isTSFunctionType");
  function ame(e, t) {
    return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ame, "isTSConstructorType");
  function ome(e, t) {
    return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ome, "isTSTypeReference");
  function ume(e, t) {
    return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(ume, "isTSTypePredicate");
  function lme(e, t) {
    return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(lme, "isTSTypeQuery");
  function cme(e, t) {
    return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(cme, "isTSTypeLiteral");
  function fme(e, t) {
    return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(fme, "isTSArrayType");
  function dme(e, t) {
    return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(dme, "isTSTupleType");
  function pme(e, t) {
    return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(pme, "isTSOptionalType");
  function hme(e, t) {
    return !e || e.type !== "TSRestType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(hme, "isTSRestType");
  function mme(e, t) {
    return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(mme, "isTSNamedTupleMember");
  function yme(e, t) {
    return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(yme, "isTSUnionType");
  function gme(e, t) {
    return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(gme, "isTSIntersectionType");
  function bme(e, t) {
    return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(bme, "isTSConditionalType");
  function Dme(e, t) {
    return !e || e.type !== "TSInferType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Dme, "isTSInferType");
  function vme(e, t) {
    return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(vme, "isTSParenthesizedType");
  function xme(e, t) {
    return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(xme, "isTSTypeOperator");
  function Eme(e, t) {
    return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Eme, "isTSIndexedAccessType");
  function Sme(e, t) {
    return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Sme, "isTSMappedType");
  function Tme(e, t) {
    return !e || e.type !== "TSTemplateLiteralType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Tme, "isTSTemplateLiteralType");
  function Cme(e, t) {
    return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Cme, "isTSLiteralType");
  function wme(e, t) {
    return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(wme, "isTSExpressionWithTypeArguments");
  function Ame(e, t) {
    return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ame, "isTSInterfaceDeclaration");
  function _me(e, t) {
    return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(_me, "isTSInterfaceBody");
  function Pme(e, t) {
    return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Pme, "isTSTypeAliasDeclaration");
  function Fme(e, t) {
    return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Fme, "isTSInstantiationExpression");
  function Ime(e, t) {
    return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ime, "isTSAsExpression");
  function Ome(e, t) {
    return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ome, "isTSSatisfiesExpression");
  function kme(e, t) {
    return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(kme, "isTSTypeAssertion");
  function Bme(e, t) {
    return !e || e.type !== "TSEnumBody" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Bme, "isTSEnumBody");
  function Nme(e, t) {
    return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Nme, "isTSEnumDeclaration");
  function Mme(e, t) {
    return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Mme, "isTSEnumMember");
  function Rme(e, t) {
    return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Rme, "isTSModuleDeclaration");
  function Lme(e, t) {
    return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Lme, "isTSModuleBlock");
  function jme(e, t) {
    return !e || e.type !== "TSImportType" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(jme, "isTSImportType");
  function qme(e, t) {
    return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(qme, "isTSImportEqualsDeclaration");
  function Ume(e, t) {
    return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Ume, "isTSExternalModuleReference");
  function $me(e, t) {
    return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, F.default)(e, t);
  }
  n($me, "isTSNonNullExpression");
  function Vme(e, t) {
    return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Vme, "isTSExportAssignment");
  function Wme(e, t) {
    return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Wme, "isTSNamespaceExportDeclaration");
  function Hme(e, t) {
    return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Hme, "isTSTypeAnnotation");
  function Kme(e, t) {
    return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Kme, "isTSTypeParameterInstantiation");
  function zme(e, t) {
    return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(zme, "isTSTypeParameterDeclaration");
  function Jme(e, t) {
    return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Jme, "isTSTypeParameter");
  function Xme(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
      case "ImportAttribute":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Xme, "isStandardized");
  function Yme(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Yme, "isExpression");
  function Gme(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Gme, "isBinary");
  function Zme(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Zme, "isScopable");
  function Qme(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Qme, "isBlockParent");
  function eye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(eye, "isBlock");
  function tye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(tye, "isStatement");
  function rye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(rye, "isTerminatorless");
  function iye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(iye, "isCompletionStatement");
  function sye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(sye, "isConditional");
  function nye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(nye, "isLoop");
  function aye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(aye, "isWhile");
  function oye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(oye, "isExpressionWrapper");
  function uye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(uye, "isFor");
  function lye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(lye, "isForXStatement");
  function cye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(cye, "isFunction");
  function fye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(fye, "isFunctionParent");
  function dye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(dye, "isPureish");
  function pye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (e.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(pye, "isDeclaration");
  function hye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (e.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(hye, "isFunctionParameter");
  function mye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(mye, "isPatternLike");
  function yye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(yye, "isLVal");
  function gye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (e.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(gye, "isTSEntityName");
  function bye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(bye, "isLiteral");
  function Dye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Dye, "isImmutable");
  function vye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(vye, "isUserWhitespacable");
  function xye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(xye, "isMethod");
  function Eye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Eye, "isObjectMember");
  function Sye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Sye, "isProperty");
  function Tye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Tye, "isUnaryLike");
  function Cye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (e.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Cye, "isPattern");
  function wye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(wye, "isClass");
  function WN(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(WN, "isImportOrExportDeclaration");
  function Aye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Aye, "isExportDeclaration");
  function _ye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(_ye, "isModuleSpecifier");
  function Pye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Pye, "isAccessor");
  function Fye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Fye, "isPrivate");
  function Iye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Iye, "isFlow");
  function Oye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Oye, "isFlowType");
  function kye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(kye, "isFlowBaseAnnotation");
  function Bye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Bye, "isFlowDeclaration");
  function Nye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Nye, "isFlowPredicate");
  function Mye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Mye, "isEnumBody");
  function Rye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Rye, "isEnumMember");
  function Lye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Lye, "isJSX");
  function jye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(jye, "isMiscellaneous");
  function qye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(qye, "isTypeScript");
  function Uye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Uye, "isTSTypeElement");
  function $ye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n($ye, "isTSType");
  function Vye(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return t == null || (0, F.default)(e, t);
  }
  n(Vye, "isTSBaseType");
  function Wye(e, t) {
    return (0, bd.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Wye, "isNumberLiteral");
  function Hye(e, t) {
    return (0, bd.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Hye, "isRegexLiteral");
  function Kye(e, t) {
    return (0, bd.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(Kye, "isRestProperty");
  function zye(e, t) {
    return (0, bd.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, F.default)(e, t);
  }
  n(zye, "isSpreadProperty");
  function Jye(e, t) {
    return (0, bd.default)("isModuleDeclaration", "isImportOrExportDeclaration"), WN(e, t);
  }
  n(Jye, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var aE = E((nE) => {
  "use strict";
  Object.defineProperty(nE, "__esModule", {
    value: !0
  });
  nE.default = Xye;
  var Mo = Jt();
  function HN(e) {
    return (0, Mo.isMemberExpression)(e) || (0, Mo.isMetaProperty)(e);
  }
  n(HN, "isMemberExpressionLike");
  function Xye(e, t, r) {
    if (!HN(e)) return !1;
    let i = Array.isArray(t) ? t : t.split("."), s = [], a;
    for (a = e; HN(a); a = (o = a.object) != null ? o : a.meta) {
      var o;
      s.push(a.property);
    }
    if (s.push(a), s.length < i.length || !r && s.length > i.length) return !1;
    for (let u = 0, l = s.length - 1; u < i.length; u++, l--) {
      let c = s[l], f;
      if ((0, Mo.isIdentifier)(c))
        f = c.name;
      else if ((0, Mo.isStringLiteral)(c))
        f = c.value;
      else if ((0, Mo.isThisExpression)(c))
        f = "this";
      else if ((0, Mo.isSuper)(c))
        f = "super";
      else if ((0, Mo.isPrivateName)(c))
        f = "#" + c.id.name;
      else
        return !1;
      if (i[u] !== f) return !1;
    }
    return !0;
  }
  n(Xye, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var uE = E((oE) => {
  "use strict";
  Object.defineProperty(oE, "__esModule", {
    value: !0
  });
  oE.default = Gye;
  var Yye = aE();
  function Gye(e, t) {
    let r = e.split(".");
    return (i) => (0, Yye.default)(i, r, t);
  }
  n(Gye, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var KN = E((Tm) => {
  "use strict";
  Object.defineProperty(Tm, "__esModule", {
    value: !0
  });
  Tm.default = void 0;
  var Zye = uE(), Qye = (0, Zye.default)("React.Component"), Kot = Tm.default = Qye;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var zN = E((lE) => {
  "use strict";
  Object.defineProperty(lE, "__esModule", {
    value: !0
  });
  lE.default = e1e;
  function e1e(e) {
    return !!e && /^[a-z]/.test(e);
  }
  n(e1e, "isCompatTag");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var Cm = E((cE) => {
  "use strict";
  Object.defineProperty(cE, "__esModule", {
    value: !0
  });
  cE.default = t1e;
  var JN = Vi();
  function t1e(e, t) {
    if (e === t) return !0;
    if (e == null || JN.ALIAS_KEYS[t]) return !1;
    let r = JN.FLIPPED_ALIAS_KEYS[t];
    return !!(r != null && r.includes(e));
  }
  n(t1e, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var dE = E((fE) => {
  "use strict";
  Object.defineProperty(fE, "__esModule", {
    value: !0
  });
  fE.default = i1e;
  var r1e = Vi();
  function i1e(e, t) {
    if (e === t) return !0;
    let r = r1e.PLACEHOLDERS_ALIAS[e];
    return !!(r != null && r.includes(t));
  }
  n(i1e, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var Il = E((pE) => {
  "use strict";
  Object.defineProperty(pE, "__esModule", {
    value: !0
  });
  pE.default = u1e;
  var s1e = Sm(), n1e = Cm(), a1e = dE(), o1e = Vi();
  function u1e(e, t, r) {
    return t ? (0, n1e.default)(t.type, e) ? r === void 0 ? !0 : (0, s1e.default)(t, r) : !r && t.type === "Placeholder" && e in o1e.FLIPPED_ALIAS_KEYS ?
    (0, a1e.default)(t.expectedNode, e) : !1 : !1;
  }
  n(u1e, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var QN = E((Dd) => {
  "use strict";
  Object.defineProperty(Dd, "__esModule", {
    value: !0
  });
  Dd.isIdentifierChar = ZN;
  Dd.isIdentifierName = d1e;
  Dd.isIdentifierStart = GN;
  var mE = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088F\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5C\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92\
-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDC-\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\
\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00\
-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\
\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7DC\uA7F1-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\
\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  XN = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ADD\u1AE0-\u1AEB\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0\
-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00\
-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", l1e = new RegExp("[" + mE + "]"), c1e = new RegExp("[" + mE + XN + "\
]");
  mE = XN = null;
  var YN = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28,
  36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21,
  43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20,
  1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0,
  2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0,
  3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0,
  50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637,
  96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24,
  3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395,
  2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0,
  4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322,
  29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26,
  2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2,
  3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489], f1e = [509,
  0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14,
  32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7,
  3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214,
  6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0,
  29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2,
  1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470,
  0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15,
  0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0,
  475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function hE(e, t) {
    let r = 65536;
    for (let i = 0, s = t.length; i < s; i += 2) {
      if (r += t[i], r > e) return !1;
      if (r += t[i + 1], r >= e) return !0;
    }
    return !1;
  }
  n(hE, "isInAstralSet");
  function GN(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && l1e.test(String.fromCharCode(e)) :
    hE(e, YN);
  }
  n(GN, "isIdentifierStart");
  function ZN(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && c1e.test(
    String.fromCharCode(e)) : hE(e, YN) || hE(e, f1e);
  }
  n(ZN, "isIdentifierChar");
  function d1e(e) {
    let t = !0;
    for (let r = 0; r < e.length; r++) {
      let i = e.charCodeAt(r);
      if ((i & 64512) === 55296 && r + 1 < e.length) {
        let s = e.charCodeAt(++r);
        (s & 64512) === 56320 && (i = 65536 + ((i & 1023) << 10) + (s & 1023));
      }
      if (t) {
        if (t = !1, !GN(i))
          return !1;
      } else if (!ZN(i))
        return !1;
    }
    return !t;
  }
  n(d1e, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var iM = E((Ro) => {
  "use strict";
  Object.defineProperty(Ro, "__esModule", {
    value: !0
  });
  Ro.isKeyword = g1e;
  Ro.isReservedWord = eM;
  Ro.isStrictBindOnlyReservedWord = rM;
  Ro.isStrictBindReservedWord = y1e;
  Ro.isStrictReservedWord = tM;
  var yE = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, p1e = new Set(yE.keyword), h1e = new Set(yE.strict), m1e = new Set(yE.strictBind);
  function eM(e, t) {
    return t && e === "await" || e === "enum";
  }
  n(eM, "isReservedWord");
  function tM(e, t) {
    return eM(e, t) || h1e.has(e);
  }
  n(tM, "isStrictReservedWord");
  function rM(e) {
    return m1e.has(e);
  }
  n(rM, "isStrictBindOnlyReservedWord");
  function y1e(e, t) {
    return tM(e, t) || rM(e);
  }
  n(y1e, "isStrictBindReservedWord");
  function g1e(e) {
    return p1e.has(e);
  }
  n(g1e, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var Ol = E((Xs) => {
  "use strict";
  Object.defineProperty(Xs, "__esModule", {
    value: !0
  });
  Object.defineProperty(Xs, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gE.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(Xs, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gE.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(Xs, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gE.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(Xs, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vd.isKeyword;
    }, "get")
  });
  Object.defineProperty(Xs, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vd.isReservedWord;
    }, "get")
  });
  Object.defineProperty(Xs, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vd.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(Xs, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vd.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(Xs, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vd.isStrictReservedWord;
    }, "get")
  });
  var gE = QN(), vd = iM();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var kl = E((DE) => {
  "use strict";
  Object.defineProperty(DE, "__esModule", {
    value: !0
  });
  DE.default = b1e;
  var bE = Ol();
  function b1e(e, t = !0) {
    return typeof e != "string" || t && ((0, bE.isKeyword)(e) || (0, bE.isStrictReservedWord)(e, !0)) ? !1 : (0, bE.isIdentifierName)(e);
  }
  n(b1e, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var oM = E((xd) => {
  "use strict";
  Object.defineProperty(xd, "__esModule", {
    value: !0
  });
  xd.readCodePoint = aM;
  xd.readInt = nM;
  xd.readStringContents = v1e;
  var D1e = /* @__PURE__ */ n(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), sM = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, wm = {
    bin: /* @__PURE__ */ n((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ n((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ n((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ n((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function v1e(e, t, r, i, s, a) {
    let o = r, u = i, l = s, c = "", f = null, m = r, {
      length: h
    } = t;
    for (; ; ) {
      if (r >= h) {
        a.unterminated(o, u, l), c += t.slice(m, r);
        break;
      }
      let d = t.charCodeAt(r);
      if (x1e(e, d, t, r)) {
        c += t.slice(m, r);
        break;
      }
      if (d === 92) {
        c += t.slice(m, r);
        let y = E1e(t, r, i, s, e === "template", a);
        y.ch === null && !f ? f = {
          pos: r,
          lineStart: i,
          curLine: s
        } : c += y.ch, {
          pos: r,
          lineStart: i,
          curLine: s
        } = y, m = r;
      } else d === 8232 || d === 8233 ? (++r, ++s, i = r) : d === 10 || d === 13 ? e === "template" ? (c += t.slice(m, r) + `
`, ++r, d === 13 && t.charCodeAt(r) === 10 && ++r, ++s, m = i = r) : a.unterminated(o, u, l) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: f,
      lineStart: i,
      curLine: s,
      containsInvalid: !!f
    };
  }
  n(v1e, "readStringContents");
  function x1e(e, t, r, i) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  n(x1e, "isStringEnd");
  function E1e(e, t, r, i, s, a) {
    let o = !s;
    t++;
    let u = /* @__PURE__ */ n((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: i
    }), "res"), l = e.charCodeAt(t++);
    switch (l) {
      case 110:
        return u(`
`);
      case 114:
        return u("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = vE(e, t, r, i, 2, !1, o, a), u(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = aM(e, t, r, i, o, a), u(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return u("	");
      case 98:
        return u("\b");
      case 118:
        return u("\v");
      case 102:
        return u("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++i;
      case 8232:
      case 8233:
        return u("");
      case 56:
      case 57:
        if (s)
          return u(null);
        a.strictNumericEscape(t - 1, r, i);
      default:
        if (l >= 48 && l <= 55) {
          let c = t - 1, m = /^[0-7]+/.exec(e.slice(c, t + 2))[0], h = parseInt(m, 8);
          h > 255 && (m = m.slice(0, -1), h = parseInt(m, 8)), t += m.length - 1;
          let d = e.charCodeAt(t);
          if (m !== "0" || d === 56 || d === 57) {
            if (s)
              return u(null);
            a.strictNumericEscape(c, r, i);
          }
          return u(String.fromCharCode(h));
        }
        return u(String.fromCharCode(l));
    }
  }
  n(E1e, "readEscapedChar");
  function vE(e, t, r, i, s, a, o, u) {
    let l = t, c;
    return {
      n: c,
      pos: t
    } = nM(e, t, r, i, 16, s, a, !1, u, !o), c === null && (o ? u.invalidEscapeSequence(l, r, i) : t = l - 1), {
      code: c,
      pos: t
    };
  }
  n(vE, "readHexChar");
  function nM(e, t, r, i, s, a, o, u, l, c) {
    let f = t, m = s === 16 ? sM.hex : sM.decBinOct, h = s === 16 ? wm.hex : s === 10 ? wm.dec : s === 8 ? wm.oct : wm.bin, d = !1, y = 0;
    for (let p = 0, g = a ?? 1 / 0; p < g; ++p) {
      let b = e.charCodeAt(t), D;
      if (b === 95 && u !== "bail") {
        let x = e.charCodeAt(t - 1), T = e.charCodeAt(t + 1);
        if (u) {
          if (Number.isNaN(T) || !h(T) || m.has(x) || m.has(T)) {
            if (c) return {
              n: null,
              pos: t
            };
            l.unexpectedNumericSeparator(t, r, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          l.numericSeparatorInEscapeSequence(t, r, i);
        }
        ++t;
        continue;
      }
      if (b >= 97 ? D = b - 97 + 10 : b >= 65 ? D = b - 65 + 10 : D1e(b) ? D = b - 48 : D = 1 / 0, D >= s) {
        if (D <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (D <= 9 && l.invalidDigit(t, r, i, s))
          D = 0;
        else if (o)
          D = 0, d = !0;
        else
          break;
      }
      ++t, y = y * s + D;
    }
    return t === f || a != null && t - f !== a || d ? {
      n: null,
      pos: t
    } : {
      n: y,
      pos: t
    };
  }
  n(nM, "readInt");
  function aM(e, t, r, i, s, a) {
    let o = e.charCodeAt(t), u;
    if (o === 123) {
      if (++t, {
        code: u,
        pos: t
      } = vE(e, t, r, i, e.indexOf("}", t) - t, !0, s, a), ++t, u !== null && u > 1114111)
        if (s)
          a.invalidCodePoint(t, r, i);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: u,
        pos: t
      } = vE(e, t, r, i, 4, !1, s, a));
    return {
      code: u,
      pos: t
    };
  }
  n(aM, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var Bl = E((He) => {
  "use strict";
  Object.defineProperty(He, "__esModule", {
    value: !0
  });
  He.UPDATE_OPERATORS = He.UNARY_OPERATORS = He.STRING_UNARY_OPERATORS = He.STATEMENT_OR_BLOCK_KEYS = He.NUMBER_UNARY_OPERATORS = He.NUMBER_BINARY_OPERATORS =
  He.LOGICAL_OPERATORS = He.INHERIT_KEYS = He.FOR_INIT_KEYS = He.FLATTENABLE_KEYS = He.EQUALITY_BINARY_OPERATORS = He.COMPARISON_BINARY_OPERATORS =
  He.COMMENT_KEYS = He.BOOLEAN_UNARY_OPERATORS = He.BOOLEAN_NUMBER_BINARY_OPERATORS = He.BOOLEAN_BINARY_OPERATORS = He.BINARY_OPERATORS = He.
  ASSIGNMENT_OPERATORS = void 0;
  var dut = He.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], put = He.FLATTENABLE_KEYS = ["body", "expressions"], hut = He.
  FOR_INIT_KEYS = ["left", "init"], mut = He.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], S1e = He.LOGICAL_OPERATORS =
  ["||", "&&", "??"], yut = He.UPDATE_OPERATORS = ["++", "--"], T1e = He.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], C1e = He.
  EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="], w1e = He.COMPARISON_BINARY_OPERATORS = [...C1e, "in", "instanceof"], A1e = He.BOOLEAN_BINARY_OPERATORS =
  [...w1e, ...T1e], uM = He.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], gut = He.BINARY_OPERATORS =
  ["+", ...uM, ...A1e, "|>"], but = He.ASSIGNMENT_OPERATORS = ["=", "+=", ...uM.map((e) => e + "="), ...S1e.map((e) => e + "=")], _1e = He.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], P1e = He.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], F1e = He.STRING_UNARY_OPERATORS = ["typeof"], Dut = He.UNARY_OPERATORS =
  ["void", "throw", ..._1e, ...P1e, ...F1e], vut = He.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  He.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), He.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local bi\
nding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var Ys = E((Ge) => {
  "use strict";
  Object.defineProperty(Ge, "__esModule", {
    value: !0
  });
  Ge.allExpandedTypes = Ge.VISITOR_KEYS = Ge.NODE_UNION_SHAPES__PRIVATE = Ge.NODE_PARENT_VALIDATIONS = Ge.NODE_FIELDS = Ge.FLIPPED_ALIAS_KEYS =
  Ge.DEPRECATED_KEYS = Ge.BUILDER_KEYS = Ge.ALIAS_KEYS = void 0;
  Ge.arrayOf = cM;
  Ge.arrayOfType = fM;
  Ge.assertEach = dM;
  Ge.assertNodeOrValueType = W1e;
  Ge.assertNodeType = _m;
  Ge.assertOneOf = $1e;
  Ge.assertOptionalChainStart = K1e;
  Ge.assertShape = H1e;
  Ge.assertValueType = TE;
  Ge.chain = pM;
  Ge.default = hM;
  Ge.defineAliasedType = X1e;
  Ge.validate = SE;
  Ge.validateArrayOfType = U1e;
  Ge.validateOptional = j1e;
  Ge.validateOptionalType = q1e;
  Ge.validateType = L1e;
  var lM = Il(), Ed = Pm(), I1e = Ge.VISITOR_KEYS = {}, O1e = Ge.ALIAS_KEYS = {}, xE = Ge.FLIPPED_ALIAS_KEYS = {}, k1e = Ge.NODE_FIELDS = {},
  B1e = Ge.BUILDER_KEYS = {}, N1e = Ge.DEPRECATED_KEYS = {}, M1e = Ge.NODE_PARENT_VALIDATIONS = {}, R1e = Ge.NODE_UNION_SHAPES__PRIVATE = {};
  function Am(e) {
    return Array.isArray(e) ? "array" : e === null ? "null" : typeof e;
  }
  n(Am, "getType");
  function SE(e) {
    return {
      validate: e
    };
  }
  n(SE, "validate");
  function L1e(...e) {
    return SE(_m(...e));
  }
  n(L1e, "validateType");
  function j1e(e) {
    return {
      validate: e,
      optional: !0
    };
  }
  n(j1e, "validateOptional");
  function q1e(...e) {
    return {
      validate: _m(...e),
      optional: !0
    };
  }
  n(q1e, "validateOptionalType");
  function cM(e) {
    return pM(TE("array"), dM(e));
  }
  n(cM, "arrayOf");
  function fM(...e) {
    return cM(_m(...e));
  }
  n(fM, "arrayOfType");
  function U1e(...e) {
    return SE(fM(...e));
  }
  n(U1e, "validateArrayOfType");
  function dM(e) {
    let t = process.env.BABEL_TYPES_8_BREAKING ? Ed.validateChild : () => {
    };
    function r(i, s, a) {
      if (!Array.isArray(a)) return;
      let o = 0, u = {
        toString() {
          return `${s}[${o}]`;
        }
      };
      for (; o < a.length; o++) {
        let l = a[o];
        e(i, u, l), t(i, u, l);
      }
    }
    return n(r, "validator"), r.each = e, r;
  }
  n(dM, "assertEach");
  function $1e(...e) {
    function t(r, i, s) {
      if (!e.includes(s))
        throw new TypeError(`Property ${i} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(s)}`);
    }
    return n(t, "validate"), t.oneOf = e, t;
  }
  n($1e, "assertOneOf");
  var V1e = Ge.allExpandedTypes = [];
  function _m(...e) {
    let t = /* @__PURE__ */ new Set();
    V1e.push({
      types: e,
      set: t
    });
    function r(i, s, a) {
      let o = a?.type;
      if (o != null) {
        if (t.has(o)) {
          (0, Ed.validateChild)(i, s, a);
          return;
        }
        if (o === "Placeholder") {
          for (let u of e)
            if ((0, lM.default)(u, a)) {
              (0, Ed.validateChild)(i, s, a);
              return;
            }
        }
      }
      throw new TypeError(`Property ${s} of ${i.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(o)}`);
    }
    return n(r, "validate"), r.oneOfNodeTypes = e, r;
  }
  n(_m, "assertNodeType");
  function W1e(...e) {
    function t(r, i, s) {
      let a = Am(s);
      for (let o of e)
        if (a === o || (0, lM.default)(o, s)) {
          (0, Ed.validateChild)(r, i, s);
          return;
        }
      throw new TypeError(`Property ${i} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(s?.
      type)}`);
    }
    return n(t, "validate"), t.oneOfNodeOrValueTypes = e, t;
  }
  n(W1e, "assertNodeOrValueType");
  function TE(e) {
    function t(r, i, s) {
      if (Am(s) !== e)
        throw new TypeError(`Property ${i} expected type of ${e} but got ${Am(s)}`);
    }
    return n(t, "validate"), t.type = e, t;
  }
  n(TE, "assertValueType");
  function H1e(e) {
    let t = Object.keys(e);
    function r(i, s, a) {
      let o = [];
      for (let u of t)
        try {
          (0, Ed.validateField)(i, u, a[u], e[u]);
        } catch (l) {
          if (l instanceof TypeError) {
            o.push(l.message);
            continue;
          }
          throw l;
        }
      if (o.length)
        throw new TypeError(`Property ${s} of ${i.type} expected to have the following:
${o.join(`
`)}`);
    }
    return n(r, "validate"), r.shapeOf = e, r;
  }
  n(H1e, "assertShape");
  function K1e() {
    function e(t) {
      var r;
      let i = t;
      for (; t; ) {
        let {
          type: s
        } = i;
        if (s === "OptionalCallExpression") {
          if (i.optional) return;
          i = i.callee;
          continue;
        }
        if (s === "OptionalMemberExpression") {
          if (i.optional) return;
          i = i.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${t.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = i) == null ? void 0 : r.type}`);
    }
    return n(e, "validate"), e;
  }
  n(K1e, "assertOptionalChainStart");
  function pM(...e) {
    function t(...r) {
      for (let i of e)
        i(...r);
    }
    if (n(t, "validate"), t.chainOf = e, e.length >= 2 && "type" in e[0] && e[0].type === "array" && !("each" in e[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return t;
  }
  n(pM, "chain");
  var z1e = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate", "unionShape"]), J1e = /* @__PURE__ */ new Set(
  ["default", "optional", "deprecated", "validate"]), EE = {};
  function X1e(...e) {
    return (t, r = {}) => {
      let i = r.aliases;
      if (!i) {
        var s;
        r.inherits && (i = (s = EE[r.inherits].aliases) == null ? void 0 : s.slice()), i ?? (i = []), r.aliases = i;
      }
      let a = e.filter((o) => !i.includes(o));
      i.unshift(...a), hM(t, r);
    };
  }
  n(X1e, "defineAliasedType");
  function hM(e, t = {}) {
    let r = t.inherits && EE[t.inherits] || {}, i = t.fields;
    if (!i && (i = {}, r.fields)) {
      let u = Object.getOwnPropertyNames(r.fields);
      for (let l of u) {
        let c = r.fields[l], f = c.default;
        if (Array.isArray(f) ? f.length > 0 : f && typeof f == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        i[l] = {
          default: Array.isArray(f) ? [] : f,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let s = t.visitor || r.visitor || [], a = t.aliases || r.aliases || [], o = t.builder || r.builder || t.visitor || [];
    for (let u of Object.keys(t))
      if (!z1e.has(u))
        throw new Error(`Unknown type option "${u}" on ${e}`);
    t.deprecatedAlias && (N1e[t.deprecatedAlias] = e);
    for (let u of s.concat(o))
      i[u] = i[u] || {};
    for (let u of Object.keys(i)) {
      let l = i[u];
      l.default !== void 0 && !o.includes(u) && (l.optional = !0), l.default === void 0 ? l.default = null : !l.validate && l.default != null &&
      (l.validate = TE(Am(l.default)));
      for (let c of Object.keys(l))
        if (!J1e.has(c))
          throw new Error(`Unknown field key "${c}" on ${e}.${u}`);
    }
    I1e[e] = t.visitor = s, B1e[e] = t.builder = o, k1e[e] = t.fields = i, O1e[e] = t.aliases = a, a.forEach((u) => {
      xE[u] = xE[u] || [], xE[u].push(e);
    }), t.validate && (M1e[e] = t.validate), t.unionShape && (R1e[e] = t.unionShape), EE[e] = t;
  }
  n(hM, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var Td = E((gr) => {
  "use strict";
  Object.defineProperty(gr, "__esModule", {
    value: !0
  });
  gr.patternLikeCommon = gr.importAttributes = gr.functionTypeAnnotationCommon = gr.functionDeclarationCommon = gr.functionCommon = gr.classMethodOrPropertyUnionShapeCommon =
  gr.classMethodOrPropertyCommon = gr.classMethodOrDeclareMethodCommon = void 0;
  var ei = Il(), Y1e = kl(), mM = Ol(), G1e = oM(), Nl = Bl(), I = Ys(), Sd = /* @__PURE__ */ n((e = !1) => ({
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [!0],
        properties: {
          key: {
            validate: (0, I.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [!1],
        properties: {
          key: {
            validate: e ? (0, I.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName") : (0, I.assertNodeType)(
            "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral")
          }
        }
      }]
    }
  }), "classMethodOrPropertyUnionShapeCommon");
  gr.classMethodOrPropertyUnionShapeCommon = Sd;
  var ne = (0, I.defineAliasedType)("Standardized");
  ne("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, I.arrayOf)((0, I.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  ne("AssignmentExpression", {
    fields: {
      operator: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function() {
          let e = (0, I.assertOneOf)(...Nl.ASSIGNMENT_OPERATORS), t = (0, I.assertOneOf)("=");
          return function(r, i, s) {
            ((0, ei.default)("Pattern", r.left) ? t : e)(r, i, s);
          };
        }(), {
          oneOf: Nl.ASSIGNMENT_OPERATORS
        }) : (0, I.assertValueType)("string")
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, I.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, I.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  ne("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, I.assertOneOf)(...Nl.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let e = (0, I.assertNodeType)("Expression"), t = (0, I.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(i, s, a) {
            (i.operator === "in" ? t : e)(i, s, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, I.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  ne("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, I.assertValueType)("string")
      }
    }
  });
  ne("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, I.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  ne("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, I.assertValueType)("string")
      }
    }
  });
  ne("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, I.arrayOfType)("Directive"),
        default: []
      },
      body: (0, I.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  ne("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, I.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  ne("CallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, I.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: (0, I.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: (0, I.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      typeParameters: {
        validate: (0, I.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  ne("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, I.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, I.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  ne("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, I.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, I.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, I.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  ne("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, I.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  ne("DebuggerStatement", {
    aliases: ["Statement"]
  });
  ne("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: (0, I.assertNodeType)("Expression")
      },
      body: {
        validate: (0, I.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  ne("EmptyStatement", {
    aliases: ["Statement"]
  });
  ne("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, I.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  ne("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, I.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.assertEach)((0, I.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, I.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  ne("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, I.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, I.assertNodeType)("Expression")
      },
      body: {
        validate: (0, I.assertNodeType)("Statement")
      }
    }
  });
  ne("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, I.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, I.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, I.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, I.assertNodeType)("Statement")
      }
    }
  });
  var Ml = /* @__PURE__ */ n(() => ({
    params: (0, I.validateArrayOfType)("FunctionParameter"),
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  gr.functionCommon = Ml;
  var Lo = /* @__PURE__ */ n(() => ({
    returnType: {
      validate: (0, I.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, I.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  gr.functionTypeAnnotationCommon = Lo;
  var yM = /* @__PURE__ */ n(() => Object.assign({}, Ml(), {
    declare: {
      validate: (0, I.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, I.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  gr.functionDeclarationCommon = yM;
  ne("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, yM(), Lo(), {
      body: {
        validate: (0, I.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, I.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let e = (0, I.assertNodeType)("Identifier");
      return function(t, r, i) {
        (0, ei.default)("ExportDefaultDeclaration", t) || e(i, "id", i.id);
      };
    }() : void 0
  });
  ne("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Ml(), Lo(), {
      id: {
        validate: (0, I.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, I.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, I.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var Rl = /* @__PURE__ */ n(() => ({
    typeAnnotation: {
      validate: (0, I.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, I.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, I.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "patternLikeCommon");
  gr.patternLikeCommon = Rl;
  ne("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "FunctionParameter", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, Rl(), {
      name: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.chain)((0, I.assertValueType)("string"), Object.assign(function(e, t, r) {
          if (!(0, Y1e.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        })) : (0, I.assertValueType)("string")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(e, t, r) {
      let i = /\.(\w+)$/.exec(t.toString());
      if (!i) return;
      let [, s] = i, a = {
        computed: !1
      };
      if (s === "property") {
        if ((0, ei.default)("MemberExpression", e, a) || (0, ei.default)("OptionalMemberExpression", e, a)) return;
      } else if (s === "key") {
        if ((0, ei.default)("Property", e, a) || (0, ei.default)("Method", e, a)) return;
      } else if (s === "exported") {
        if ((0, ei.default)("ExportSpecifier", e)) return;
      } else if (s === "imported") {
        if ((0, ei.default)("ImportSpecifier", e, {
          imported: r
        })) return;
      } else if (s === "meta" && (0, ei.default)("MetaProperty", e, {
        meta: r
      }))
        return;
      if (((0, mM.isKeyword)(r.name) || (0, mM.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    } : void 0
  });
  ne("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, I.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, I.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, I.assertNodeType)("Statement")
      }
    }
  });
  ne("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, I.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, I.assertNodeType)("Statement")
      }
    }
  });
  ne("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, I.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ne("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, I.chain)((0, I.assertValueType)("number"), Object.assign(function(e, t, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let i = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ne("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ne("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, I.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ne("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, I.assertValueType)("string")
      },
      flags: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.chain)((0, I.assertValueType)("string"), Object.assign(function(e, t, r) {
          let i = /[^dgimsuvy]/.exec(r);
          if (i)
            throw new TypeError(`"${i[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })) : (0, I.assertValueType)("string"),
        default: ""
      }
    }
  });
  ne("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, I.assertOneOf)(...Nl.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, I.assertNodeType)("Expression")
      },
      right: {
        validate: (0, I.assertNodeType)("Expression")
      }
    }
  });
  ne("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal", "PatternLike"],
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [!0],
        properties: {
          property: {
            validate: (0, I.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [!1],
        properties: {
          property: {
            validate: (0, I.assertNodeType)("Identifier", "PrivateName")
          }
        }
      }]
    },
    fields: Object.assign({
      object: {
        validate: (0, I.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let e = (0, I.assertNodeType)("Identifier", "PrivateName"), t = (0, I.assertNodeType)("Expression"), r = /* @__PURE__ */ n(function(i, s, a) {
            (i.computed ? t : e)(i, s, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  ne("NewExpression", {
    inherits: "CallExpression"
  });
  ne("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, I.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, I.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, I.arrayOfType)("Directive"),
        default: []
      },
      body: (0, I.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  ne("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, I.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  });
  ne("ObjectMethod", Object.assign({
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
  }, Sd(), {
    fields: Object.assign({}, Ml(), Lo(), {
      kind: Object.assign({
        validate: (0, I.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, I.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, I.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ n(function(i, s, a) {
            (i.computed ? t : e)(i, s, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, I.arrayOfType)("Decorator"),
        optional: !0
      },
      body: {
        validate: (0, I.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  }));
  ne("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [!0],
        properties: {
          key: {
            validate: (0, I.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [!1],
        properties: {
          key: {
            validate: (0, I.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName")
          }
        }
      }]
    },
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, I.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t = (0, I.
          assertNodeType)("Expression");
          return Object.assign(function(i, s, a) {
            (i.computed ? t : e)(i, s, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, I.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.chain)((0, I.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (r) {
            if (e.computed)
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            if (!(0, ei.default)("Identifier", e.key))
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : (0, I.assertValueType)("boolean"),
        default: !1
      },
      decorators: {
        validate: (0, I.arrayOfType)("Decorator"),
        optional: !0
      }
    },
    visitor: ["decorators", "key", "value"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let e = (0, I.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), t = (0, I.assertNodeType)("Expression");
      return function(r, i, s) {
        ((0, ei.default)("ObjectPattern", r) ? e : t)(s, "value", s.value);
      };
    }() : void 0
  });
  ne("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["FunctionParameter", "PatternLike", "LVal"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, Rl(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, I.assertNodeType)("Identifier", "ArrayPattern",
        "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression", "RestEleme\
nt", "AssignmentPattern")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(e, t) {
      let r = /(\w+)\[(\d+)\]/.exec(t.toString());
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, i, s] = r;
      if (e[i].length > +s + 1)
        throw new TypeError(`RestElement must be last element of ${i}`);
    } : void 0
  });
  ne("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, I.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  ne("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: (0, I.validateArrayOfType)("Expression")
    },
    aliases: ["Expression"]
  });
  ne("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, I.assertNodeType)("Expression")
      }
    }
  });
  ne("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, I.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: (0, I.validateArrayOfType)("Statement")
    }
  });
  ne("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, I.assertNodeType)("Expression")
      },
      cases: (0, I.validateArrayOfType)("SwitchCase")
    }
  });
  ne("ThisExpression", {
    aliases: ["Expression"]
  });
  ne("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, I.assertNodeType)("Expression")
      }
    }
  });
  ne("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.chain)((0, I.assertNodeType)("BlockStatement"), Object.assign(function(e) {
          if (!e.handler && !e.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : (0, I.assertNodeType)("BlockStatement")
      },
      handler: {
        optional: !0,
        validate: (0, I.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, I.assertNodeType)("BlockStatement")
      }
    }
  });
  ne("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, I.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, I.assertOneOf)(...Nl.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  ne("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.assertNodeType)("Identifier", "MemberExpression") : (0, I.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, I.assertOneOf)(...Nl.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  ne("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, I.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: (0, I.validateArrayOfType)("VariableDeclarator")
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
      let e = (0, I.assertNodeType)("Identifier", "Placeholder"), t = (0, I.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "\
Placeholder"), r = (0, I.assertNodeType)("Identifier", "VoidPattern", "Placeholder");
      return function(i, s, a) {
        let {
          kind: o,
          declarations: u
        } = a, l = (0, ei.default)("ForXStatement", i, {
          left: a
        });
        if (l && u.length !== 1)
          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${i.type}`);
        for (let c of u)
          o === "const" || o === "let" || o === "var" ? !l && !c.init ? e(c, "id", c.id) : t(c, "id", c.id) : r(c, "id", c.id);
      };
    })() : void 0
  });
  ne("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "VoidPattern") :
        (0, I.assertNodeType)("LVal", "VoidPattern")
      },
      definite: {
        optional: !0,
        validate: (0, I.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, I.assertNodeType)("Expression")
      }
    }
  });
  ne("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, I.assertNodeType)("Expression")
      },
      body: {
        validate: (0, I.assertNodeType)("Statement")
      }
    }
  });
  ne("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, I.assertNodeType)("Expression")
      },
      body: {
        validate: (0, I.assertNodeType)("Statement")
      }
    }
  });
  ne("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, Rl(), {
      left: {
        validate: (0, I.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, I.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, I.arrayOfType)("Decorator"),
        optional: !0
      }
    })
  });
  ne("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, Rl(), {
      elements: {
        validate: (0, I.chain)((0, I.assertValueType)("array"), (0, I.assertEach)((0, I.assertNodeOrValueType)("null", "PatternLike")))
      }
    })
  });
  ne("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Ml(), Lo(), {
      expression: {
        validate: (0, I.assertValueType)("boolean")
      },
      body: {
        validate: (0, I.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, I.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  ne("ClassBody", {
    visitor: ["body"],
    fields: {
      body: (0, I.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty",
      "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  });
  ne("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, I.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, I.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, I.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, I.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, I.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, I.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, I.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, I.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  ne("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, I.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, I.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, I.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, I.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, I.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, I.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, I.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, I.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let e = (0, I.assertNodeType)("Identifier");
      return function(t, r, i) {
        (0, ei.default)("ExportDefaultDeclaration", t) || e(i, "id", i.id);
      };
    }() : void 0
  });
  var CE = gr.importAttributes = {
    attributes: {
      optional: !0,
      validate: (0, I.arrayOfType)("ImportAttribute")
    },
    assertions: {
      deprecated: !0,
      optional: !0,
      validate: (0, I.arrayOfType)("ImportAttribute")
    }
  };
  ne("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: (0, I.assertNodeType)("StringLiteral")
      },
      exportKind: (0, I.validateOptional)((0, I.assertOneOf)("type", "value"))
    }, CE)
  });
  ne("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: (0, I.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: (0, I.validateOptional)((0, I.assertOneOf)("value"))
    }
  });
  ne("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: !0,
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.chain)((0, I.assertNodeType)("Declaration"), Object.assign(function(e, t, r) {
          if (r && e.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          if (r && e.source)
            throw new TypeError("Cannot export a declaration from a source");
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : (0, I.assertNodeType)("Declaration")
      }
    }, CE, {
      specifiers: {
        default: [],
        validate: (0, I.arrayOf)(function() {
          let e = (0, I.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), t = (0, I.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function(r, i, s) {
            (r.source ? e : t)(r, i, s);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          }) : e;
        }())
      },
      source: {
        validate: (0, I.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, I.validateOptional)((0, I.assertOneOf)("type", "value"))
    })
  });
  ne("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, I.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, I.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, I.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  ne("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, I.assertNodeType)("VariableDeclaration", "LVal");
          let e = (0, I.assertNodeType)("VariableDeclaration"), t = (0, I.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(r, i, s) {
            (0, ei.default)("VariableDeclaration", s) ? e(r, i, s) : t(r, i, s);
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TS\
SatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        }()
      },
      right: {
        validate: (0, I.assertNodeType)("Expression")
      },
      body: {
        validate: (0, I.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  ne("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, CE, {
      module: {
        optional: !0,
        validate: (0, I.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, I.assertOneOf)("source", "defer")
      },
      specifiers: (0, I.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: (0, I.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, I.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    })
  });
  ne("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, I.assertNodeType)("Identifier")
      }
    }
  });
  ne("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, I.assertNodeType)("Identifier")
      }
    }
  });
  ne("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, I.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, I.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, I.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  ne("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, I.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, I.assertNodeType)("Expression")
      },
      options: {
        validate: (0, I.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  ne("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.chain)((0, I.assertNodeType)("Identifier"), Object.assign(function(e, t, r) {
          let i;
          switch (r.name) {
            case "function":
              i = "sent";
              break;
            case "new":
              i = "target";
              break;
            case "import":
              i = "meta";
              break;
          }
          if (!(0, ei.default)("Identifier", e.property, {
            name: i
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : (0, I.assertNodeType)("Identifier")
      },
      property: {
        validate: (0, I.assertNodeType)("Identifier")
      }
    }
  });
  var Fm = /* @__PURE__ */ n(() => ({
    abstract: {
      validate: (0, I.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, I.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, I.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, I.chain)(function() {
        let e = (0, I.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, I.assertNodeType)("Expressi\
on");
        return function(r, i, s) {
          (r.computed ? t : e)(r, i, s);
        };
      }(), (0, I.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  gr.classMethodOrPropertyCommon = Fm;
  var wE = /* @__PURE__ */ n(() => Object.assign({}, Ml(), Fm(), {
    params: (0, I.validateArrayOfType)("FunctionParameter", "TSParameterProperty"),
    kind: {
      validate: (0, I.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, I.chain)((0, I.assertValueType)("string"), (0, I.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, I.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  gr.classMethodOrDeclareMethodCommon = wE;
  ne("ClassMethod", Object.assign({
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
  }, Sd(), {
    fields: Object.assign({}, wE(), Lo(), {
      body: {
        validate: (0, I.assertNodeType)("BlockStatement")
      }
    })
  }));
  ne("ObjectPattern", {
    visitor: ["decorators", "properties", "typeAnnotation"],
    builder: ["properties"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, Rl(), {
      properties: (0, I.validateArrayOfType)("RestElement", "ObjectProperty")
    })
  });
  ne("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, I.assertNodeType)("Expression")
      }
    }
  });
  ne("Super", {
    aliases: ["Expression"]
  });
  ne("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, I.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, I.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, I.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  ne("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, I.chain)((0, I.assertShape)({
          raw: {
            validate: (0, I.assertValueType)("string")
          },
          cooked: {
            validate: (0, I.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ n(function(t) {
          let r = t.value.raw, i = !1, s = /* @__PURE__ */ n(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, G1e.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              i = !0;
            },
            strictNumericEscape: s,
            invalidEscapeSequence: s,
            numericSeparatorInEscapeSequence: s,
            unexpectedNumericSeparator: s,
            invalidDigit: s,
            invalidCodePoint: s
          });
          if (!i) throw new Error("Invalid raw");
          t.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  ne("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: (0, I.validateArrayOfType)("TemplateElement"),
      expressions: {
        validate: (0, I.chain)((0, I.assertValueType)("array"), (0, I.assertEach)((0, I.assertNodeType)("Expression", "TSType")), function(e, t, r) {
          if (e.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
        })
      }
    }
  });
  ne("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.chain)((0, I.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (r && !e.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })) : (0, I.assertValueType)("boolean"),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, I.assertNodeType)("Expression")
      }
    }
  });
  ne("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, I.assertNodeType)("Expression")
      }
    }
  });
  ne("Import", {
    aliases: ["Expression"]
  });
  ne("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, I.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  ne("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, I.assertNodeType)("Identifier")
      }
    }
  });
  ne("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, I.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let e = (0, I.assertNodeType)("Identifier"), t = (0, I.assertNodeType)("Expression");
          return Object.assign(function(i, s, a) {
            (i.computed ? t : e)(i, s, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.chain)((0, I.assertValueType)("boolean"), (0, I.assertOptionalChainStart)()) : (0, I.
        assertValueType)("boolean")
      }
    }
  });
  ne("OptionalCallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, I.assertNodeType)("Expression")
      },
      arguments: (0, I.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, I.chain)((0, I.assertValueType)("boolean"), (0, I.assertOptionalChainStart)()) : (0, I.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, I.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, I.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  ne("ClassProperty", Object.assign({
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"]
  }, Sd(), {
    fields: Object.assign({}, Fm(), {
      value: {
        validate: (0, I.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, I.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, I.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, I.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }));
  ne("ClassAccessorProperty", Object.assign({
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"]
  }, Sd(!0), {
    fields: Object.assign({}, Fm(), {
      key: {
        validate: (0, I.chain)(function() {
          let e = (0, I.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t = (0, I.assertNodeType)(
          "Expression");
          return function(r, i, s) {
            (r.computed ? t : e)(r, i, s);
          };
        }(), (0, I.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, I.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, I.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, I.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, I.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }));
  ne("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, I.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, I.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, I.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, I.arrayOfType)("Decorator"),
        optional: !0
      },
      static: {
        validate: (0, I.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      optional: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, I.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, I.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  ne("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, wE(), Lo(), {
      kind: {
        validate: (0, I.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, I.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, I.assertNodeType)("BlockStatement")
      }
    })
  });
  ne("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, I.assertNodeType)("Identifier")
      }
    }
  });
  ne("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: (0, I.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
  ne("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, I.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, I.assertNodeType)("StringLiteral")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var bM = E(() => {
  "use strict";
  var gM = Td(), H = Ys(), ge = (0, H.defineAliasedType)("Flow"), AE = /* @__PURE__ */ n((e) => {
    let t = e === "DeclareClass";
    ge(e, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...t ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, H.validateType)("Identifier"),
        typeParameters: (0, H.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, H.validateOptional)((0, H.arrayOfType)("InterfaceExtends"))
      }, t ? {
        mixins: (0, H.validateOptional)((0, H.arrayOfType)("InterfaceExtends")),
        implements: (0, H.validateOptional)((0, H.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, H.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  ge("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ge("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, H.validateType)("FlowType")
    }
  });
  ge("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ge("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, H.validate)((0, H.assertValueType)("boolean"))
    }
  });
  ge("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ge("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      typeParameters: (0, H.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  AE("DeclareClass");
  ge("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      predicate: (0, H.validateOptionalType)("DeclaredPredicate")
    }
  });
  AE("DeclareInterface");
  ge("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, H.validateType)("Identifier", "StringLiteral"),
      body: (0, H.validateType)("BlockStatement"),
      kind: (0, H.validateOptional)((0, H.assertOneOf)("CommonJS", "ES"))
    }
  });
  ge("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, H.validateType)("TypeAnnotation")
    }
  });
  ge("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      typeParameters: (0, H.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, H.validateType)("FlowType")
    }
  });
  ge("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      typeParameters: (0, H.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, H.validateOptionalType)("FlowType"),
      impltype: (0, H.validateOptionalType)("FlowType")
    }
  });
  ge("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, H.validateType)("Identifier")
    }
  });
  ge("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: (0, H.validateOptionalType)("Flow"),
      specifiers: (0, H.validateOptional)((0, H.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: (0, H.validateOptionalType)("StringLiteral"),
      default: (0, H.validateOptional)((0, H.assertValueType)("boolean"))
    }, gM.importAttributes)
  });
  ge("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: (0, H.validateType)("StringLiteral"),
      exportKind: (0, H.validateOptional)((0, H.assertOneOf)("type", "value"))
    }, gM.importAttributes)
  });
  ge("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, H.validateType)("Flow")
    }
  });
  ge("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  ge("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, H.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, H.validateArrayOfType)("FunctionTypeParam"),
      rest: (0, H.validateOptionalType)("FunctionTypeParam"),
      this: (0, H.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, H.validateType)("FlowType")
    }
  });
  ge("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, H.validateOptionalType)("Identifier"),
      typeAnnotation: (0, H.validateType)("FlowType"),
      optional: (0, H.validateOptional)((0, H.assertValueType)("boolean"))
    }
  });
  ge("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, H.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, H.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  ge("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  ge("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, H.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, H.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  AE("InterfaceDeclaration");
  ge("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, H.validateOptional)((0, H.arrayOfType)("InterfaceExtends")),
      body: (0, H.validateType)("ObjectTypeAnnotation")
    }
  });
  ge("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, H.validate)((0, H.arrayOfType)("FlowType"))
    }
  });
  ge("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ge("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ge("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, H.validateType)("FlowType")
    }
  });
  ge("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, H.validate)((0, H.assertValueType)("number"))
    }
  });
  ge("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ge("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, H.validate)((0, H.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: (0, H.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, H.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, H.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, H.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, H.validateOptional)((0, H.assertValueType)("boolean"))
    }
  });
  ge("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      value: (0, H.validateType)("FlowType"),
      optional: (0, H.validate)((0, H.assertValueType)("boolean")),
      static: (0, H.validate)((0, H.assertValueType)("boolean")),
      method: (0, H.validate)((0, H.assertValueType)("boolean"))
    }
  });
  ge("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, H.validateType)("FlowType"),
      static: (0, H.validate)((0, H.assertValueType)("boolean"))
    }
  });
  ge("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, H.validateOptionalType)("Identifier"),
      key: (0, H.validateType)("FlowType"),
      value: (0, H.validateType)("FlowType"),
      static: (0, H.validate)((0, H.assertValueType)("boolean")),
      variance: (0, H.validateOptionalType)("Variance")
    }
  });
  ge("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, H.validateType)("Identifier", "StringLiteral"),
      value: (0, H.validateType)("FlowType"),
      kind: (0, H.validate)((0, H.assertOneOf)("init", "get", "set")),
      static: (0, H.validate)((0, H.assertValueType)("boolean")),
      proto: (0, H.validate)((0, H.assertValueType)("boolean")),
      optional: (0, H.validate)((0, H.assertValueType)("boolean")),
      variance: (0, H.validateOptionalType)("Variance"),
      method: (0, H.validate)((0, H.assertValueType)("boolean"))
    }
  });
  ge("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, H.validateType)("FlowType")
    }
  });
  ge("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      typeParameters: (0, H.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, H.validateOptionalType)("FlowType"),
      impltype: (0, H.validateType)("FlowType")
    }
  });
  ge("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      qualification: (0, H.validateType)("Identifier", "QualifiedTypeIdentifier")
    }
  });
  ge("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, H.validate)((0, H.assertValueType)("string"))
    }
  });
  ge("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ge("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ge("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ge("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, H.validate)((0, H.arrayOfType)("FlowType"))
    }
  });
  ge("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, H.validateType)("FlowType")
    }
  });
  ge("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      typeParameters: (0, H.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, H.validateType)("FlowType")
    }
  });
  ge("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, H.validateType)("FlowType")
    }
  });
  ge("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, H.validateType)("Expression"),
      typeAnnotation: (0, H.validateType)("TypeAnnotation")
    }
  });
  ge("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, H.validate)((0, H.assertValueType)("string")),
      bound: (0, H.validateOptionalType)("TypeAnnotation"),
      default: (0, H.validateOptionalType)("FlowType"),
      variance: (0, H.validateOptionalType)("Variance")
    }
  });
  ge("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, H.validate)((0, H.arrayOfType)("TypeParameter"))
    }
  });
  ge("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, H.validate)((0, H.arrayOfType)("FlowType"))
    }
  });
  ge("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, H.validate)((0, H.arrayOfType)("FlowType"))
    }
  });
  ge("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, H.validate)((0, H.assertOneOf)("minus", "plus"))
    }
  });
  ge("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  ge("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      body: (0, H.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  });
  ge("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, H.validate)((0, H.assertValueType)("boolean")),
      members: (0, H.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, H.validate)((0, H.assertValueType)("boolean"))
    }
  });
  ge("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, H.validate)((0, H.assertValueType)("boolean")),
      members: (0, H.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, H.validate)((0, H.assertValueType)("boolean"))
    }
  });
  ge("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, H.validate)((0, H.assertValueType)("boolean")),
      members: (0, H.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: (0, H.validate)((0, H.assertValueType)("boolean"))
    }
  });
  ge("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, H.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, H.validate)((0, H.assertValueType)("boolean"))
    }
  });
  ge("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      init: (0, H.validateType)("BooleanLiteral")
    }
  });
  ge("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      init: (0, H.validateType)("NumericLiteral")
    }
  });
  ge("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, H.validateType)("Identifier"),
      init: (0, H.validateType)("StringLiteral")
    }
  });
  ge("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, H.validateType)("Identifier")
    }
  });
  ge("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, H.validateType)("FlowType"),
      indexType: (0, H.validateType)("FlowType")
    }
  });
  ge("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, H.validateType)("FlowType"),
      indexType: (0, H.validateType)("FlowType"),
      optional: (0, H.validate)((0, H.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var DM = E(() => {
  "use strict";
  var jt = Ys(), ti = (0, jt.defineAliasedType)("JSX");
  ti("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, jt.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, jt.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  ti("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, jt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  ti("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, jt.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, jt.assertNodeType)("JSXClosingElement")
      },
      children: (0, jt.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: (0, jt.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  ti("JSXEmptyExpression", {});
  ti("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, jt.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  ti("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, jt.assertNodeType)("Expression")
      }
    }
  });
  ti("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, jt.assertValueType)("string")
      }
    }
  });
  ti("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, jt.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, jt.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ti("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, jt.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, jt.assertNodeType)("JSXIdentifier")
      }
    }
  });
  ti("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: (0, jt.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: (0, jt.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: (0, jt.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, jt.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  ti("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, jt.assertNodeType)("Expression")
      }
    }
  });
  ti("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, jt.assertValueType)("string")
      }
    }
  });
  ti("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, jt.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, jt.assertNodeType)("JSXClosingFragment")
      },
      children: (0, jt.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  });
  ti("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  ti("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var FE = E((Pa) => {
  "use strict";
  Object.defineProperty(Pa, "__esModule", {
    value: !0
  });
  Pa.PLACEHOLDERS_FLIPPED_ALIAS = Pa.PLACEHOLDERS_ALIAS = Pa.PLACEHOLDERS = void 0;
  var Z1e = Ys(), Q1e = Pa.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "Class\
Body", "Pattern"], PE = Pa.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let e of Q1e) {
    let t = Z1e.ALIAS_KEYS[e];
    t != null && t.length && (PE[e] = t);
  }
  var _E = Pa.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(PE).forEach((e) => {
    PE[e].forEach((t) => {
      hasOwnProperty.call(_E, t) || (_E[t] = []), _E[t].push(e);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var vM = E(() => {
  "use strict";
  var Im = Ys(), ege = FE(), tge = Td(), IE = (0, Im.defineAliasedType)("Miscellaneous");
  IE("Noop", {
    visitor: []
  });
  IE("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: (0, Im.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, Im.assertOneOf)(...ege.PLACEHOLDERS)
      }
    }, (0, tge.patternLikeCommon)())
  });
  IE("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, Im.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var xM = E(() => {
  "use strict";
  var Ct = Ys();
  (0, Ct.default)("ArgumentPlaceholder", {});
  (0, Ct.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, Ct.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, Ct.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, Ct.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, Ct.assertNodeType)("Expression")
      }
    }
  });
  (0, Ct.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, Ct.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, Ct.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, Ct.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, Ct.assertNodeType)("Identifier")
      }
    }
  });
  (0, Ct.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, Ct.validateArrayOfType)("ObjectProperty", "SpreadElement")
    }
  });
  (0, Ct.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, Ct.arrayOfType)("Expression", "SpreadElement"),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, Ct.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, Ct.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, Ct.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, Ct.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, Ct.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, Ct.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, Ct.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, Ct.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, Ct.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, Ct.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
  (0, Ct.default)("VoidPattern", {
    aliases: ["Pattern", "PatternLike", "FunctionParameter"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var _M = E(() => {
  "use strict";
  var X = Ys(), OE = Td(), rge = Il(), Ce = (0, X.defineAliasedType)("TypeScript"), pi = (0, X.assertValueType)("boolean"), EM = /* @__PURE__ */ n(
  () => ({
    returnType: {
      validate: (0, X.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, X.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  Ce("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, X.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, X.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, X.arrayOfType)("Decorator"),
        optional: !0
      }
    }
  });
  Ce("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, OE.functionDeclarationCommon)(), EM())
  });
  Ce("TSDeclareMethod", Object.assign({
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"]
  }, (0, OE.classMethodOrPropertyUnionShapeCommon)(), {
    fields: Object.assign({}, (0, OE.classMethodOrDeclareMethodCommon)(), EM())
  }));
  Ce("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, X.validateType)("TSEntityName"),
      right: (0, X.validateType)("Identifier")
    }
  });
  var Om = /* @__PURE__ */ n(() => ({
    typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, X.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
    typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), SM = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: Om()
  };
  Ce("TSCallSignatureDeclaration", SM);
  Ce("TSConstructSignatureDeclaration", SM);
  var TM = /* @__PURE__ */ n(() => ({
    key: (0, X.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, X.validateOptional)(pi)
  }), "namedTypeElementCommon");
  Ce("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, TM(), {
      readonly: (0, X.validateOptional)(pi),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        optional: !0,
        validate: (0, X.assertOneOf)("get", "set")
      }
    })
  });
  Ce("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, Om(), TM(), {
      kind: {
        validate: (0, X.assertOneOf)("method", "get", "set")
      }
    })
  });
  Ce("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, X.validateOptional)(pi),
      static: (0, X.validateOptional)(pi),
      parameters: (0, X.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var ige = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeywor\
d", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let e of ige)
    Ce(e, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  Ce("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var CM = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  Ce("TSFunctionType", Object.assign({}, CM, {
    fields: Om()
  }));
  Ce("TSConstructorType", Object.assign({}, CM, {
    fields: Object.assign({}, Om(), {
      abstract: (0, X.validateOptional)(pi)
    })
  }));
  Ce("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, X.validateType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Ce("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, X.validateType)("Identifier", "TSThisType"),
      typeAnnotation: (0, X.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, X.validateOptional)(pi)
    }
  });
  Ce("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, X.validateType)("TSEntityName", "TSImportType"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Ce("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, X.validateArrayOfType)("TSTypeElement")
    }
  });
  Ce("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, X.validateType)("TSType")
    }
  });
  Ce("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, X.validateArrayOfType)("TSType", "TSNamedTupleMember")
    }
  });
  Ce("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  Ce("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  Ce("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, X.validateType)("Identifier"),
      optional: {
        validate: pi,
        default: !1
      },
      elementType: (0, X.validateType)("TSType")
    }
  });
  var wM = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, X.validateArrayOfType)("TSType")
    }
  };
  Ce("TSUnionType", wM);
  Ce("TSIntersectionType", wM);
  Ce("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, X.validateType)("TSType"),
      extendsType: (0, X.validateType)("TSType"),
      trueType: (0, X.validateType)("TSType"),
      falseType: (0, X.validateType)("TSType")
    }
  });
  Ce("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, X.validateType)("TSTypeParameter")
    }
  });
  Ce("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  Ce("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    builder: ["typeAnnotation", "operator"],
    fields: {
      operator: {
        validate: (0, X.assertValueType)("string"),
        default: "keyof"
      },
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  Ce("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, X.validateType)("TSType"),
      indexType: (0, X.validateType)("TSType")
    }
  });
  Ce("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: (0, X.validateType)("TSTypeParameter")
    }, {
      readonly: (0, X.validateOptional)((0, X.assertOneOf)(!0, !1, "+", "-")),
      optional: (0, X.validateOptional)((0, X.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, X.validateOptionalType)("TSType"),
      nameType: (0, X.validateOptionalType)("TSType")
    })
  });
  Ce("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: (0, X.validateArrayOfType)("TemplateElement"),
      types: {
        validate: (0, X.chain)((0, X.assertValueType)("array"), (0, X.assertEach)((0, X.assertNodeType)("TSType")), function(e, t, r) {
          if (e.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of types.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
        })
      }
    }
  });
  Ce("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let e = (0, X.assertNodeType)("NumericLiteral", "BigIntLiteral"), t = (0, X.assertOneOf)("-"), r = (0, X.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral"), i = /* @__PURE__ */ n(function(a, o, u) {
            (0, rge.default)("UnaryExpression", u) ? (t(u, "operator", u.operator), e(u, "argument", u.argument)) : r(a, o, u);
          }, "validator");
          return i.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpressi\
on"], i;
        }()
      }
    }
  });
  Ce("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, X.validateType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  Ce("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, X.validateOptional)(pi),
      id: (0, X.validateType)("Identifier"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, X.validateOptional)((0, X.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, X.validateType)("TSInterfaceBody")
    }
  });
  Ce("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, X.validateArrayOfType)("TSTypeElement")
    }
  });
  Ce("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, X.validateOptional)(pi),
      id: (0, X.validateType)("Identifier"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, X.validateType)("TSType")
    }
  });
  Ce("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, X.validateType)("Expression"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var AM = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, X.validateType)("Expression"),
      typeAnnotation: (0, X.validateType)("TSType")
    }
  };
  Ce("TSAsExpression", AM);
  Ce("TSSatisfiesExpression", AM);
  Ce("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, X.validateType)("TSType"),
      expression: (0, X.validateType)("Expression")
    }
  });
  Ce("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: (0, X.validateArrayOfType)("TSEnumMember")
    }
  });
  Ce("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, X.validateOptional)(pi),
      const: (0, X.validateOptional)(pi),
      id: (0, X.validateType)("Identifier"),
      members: (0, X.validateArrayOfType)("TSEnumMember"),
      initializer: (0, X.validateOptionalType)("Expression"),
      body: (0, X.validateOptionalType)("TSEnumBody")
    }
  });
  Ce("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, X.validateType)("Identifier", "StringLiteral"),
      initializer: (0, X.validateOptionalType)("Expression")
    }
  });
  Ce("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: (0, X.assertOneOf)("global", "module", "namespace")
      },
      declare: (0, X.validateOptional)(pi)
    }, {
      global: (0, X.validateOptional)(pi)
    }, {
      id: (0, X.validateType)("Identifier", "StringLiteral"),
      body: (0, X.validateType)("TSModuleBlock", "TSModuleDeclaration")
    })
  });
  Ce("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, X.validateArrayOfType)("Statement")
    }
  });
  Ce("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: {
      argument: (0, X.validateType)("StringLiteral"),
      qualifier: (0, X.validateOptionalType)("TSEntityName"),
      typeParameters: (0, X.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, X.assertNodeType)("ObjectExpression"),
        optional: !0
      }
    }
  });
  Ce("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: (0, X.validate)(pi)
    }, {
      id: (0, X.validateType)("Identifier"),
      moduleReference: (0, X.validateType)("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: (0, X.assertOneOf)("type", "value"),
        optional: !0
      }
    })
  });
  Ce("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("StringLiteral")
    }
  });
  Ce("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("Expression")
    }
  });
  Ce("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, X.validateType)("Expression")
    }
  });
  Ce("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, X.validateType)("Identifier")
    }
  });
  Ce("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, X.assertNodeType)("TSType")
      }
    }
  });
  Ce("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, X.validateArrayOfType)("TSType")
    }
  });
  Ce("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, X.validateArrayOfType)("TSTypeParameter")
    }
  });
  Ce("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, X.assertValueType)("string")
      },
      in: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, X.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, X.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, X.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var PM = E((km) => {
  "use strict";
  Object.defineProperty(km, "__esModule", {
    value: !0
  });
  km.DEPRECATED_ALIASES = void 0;
  var jut = km.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var Vi = E(($r) => {
  "use strict";
  Object.defineProperty($r, "__esModule", {
    value: !0
  });
  Object.defineProperty($r, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ri.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty($r, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ri.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty($r, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return kE.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty($r, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ri.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty($r, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ri.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty($r, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ri.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty($r, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ri.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty($r, "NODE_UNION_SHAPES__PRIVATE", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ri.NODE_UNION_SHAPES__PRIVATE;
    }, "get")
  });
  Object.defineProperty($r, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return BE.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty($r, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return BE.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty($r, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return BE.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  $r.TYPES = void 0;
  Object.defineProperty($r, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ri.VISITOR_KEYS;
    }, "get")
  });
  Td();
  bM();
  DM();
  vM();
  xM();
  _M();
  var ri = Ys(), BE = FE(), kE = PM();
  Object.keys(kE.DEPRECATED_ALIASES).forEach((e) => {
    ri.FLIPPED_ALIAS_KEYS[e] = ri.FLIPPED_ALIAS_KEYS[kE.DEPRECATED_ALIASES[e]];
  });
  for (let {
    types: e,
    set: t
  } of ri.allExpandedTypes)
    for (let r of e) {
      let i = ri.FLIPPED_ALIAS_KEYS[r];
      i ? i.forEach(t.add, t) : t.add(r);
    }
  var Uut = $r.TYPES = [].concat(Object.keys(ri.VISITOR_KEYS), Object.keys(ri.FLIPPED_ALIAS_KEYS), Object.keys(ri.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var Pm = E((Ll) => {
  "use strict";
  Object.defineProperty(Ll, "__esModule", {
    value: !0
  });
  Ll.default = sge;
  Ll.validateChild = IM;
  Ll.validateField = FM;
  Ll.validateInternal = nge;
  var Cd = Vi();
  function sge(e, t, r) {
    if (!e) return;
    let i = Cd.NODE_FIELDS[e.type];
    if (!i) return;
    let s = i[t];
    FM(e, t, r, s), IM(e, t, r);
  }
  n(sge, "validate");
  function nge(e, t, r, i, s) {
    if (e != null && e.validate && !(e.optional && i == null) && (e.validate(t, r, i), s)) {
      var a;
      let o = i.type;
      if (o == null) return;
      (a = Cd.NODE_PARENT_VALIDATIONS[o]) == null || a.call(Cd.NODE_PARENT_VALIDATIONS, t, r, i);
    }
  }
  n(nge, "validateInternal");
  function FM(e, t, r, i) {
    i != null && i.validate && (i.optional && r == null || i.validate(e, t, r));
  }
  n(FM, "validateField");
  function IM(e, t, r) {
    var i;
    let s = r?.type;
    s != null && ((i = Cd.NODE_PARENT_VALIDATIONS[s]) == null || i.call(Cd.NODE_PARENT_VALIDATIONS, e, t, r));
  }
  n(IM, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/generated/lowercase.js
var NE = E((C) => {
  "use strict";
  Object.defineProperty(C, "__esModule", {
    value: !0
  });
  C.anyTypeAnnotation = jbe;
  C.argumentPlaceholder = hDe;
  C.arrayExpression = lge;
  C.arrayPattern = sbe;
  C.arrayTypeAnnotation = qbe;
  C.arrowFunctionExpression = nbe;
  C.assignmentExpression = cge;
  C.assignmentPattern = ibe;
  C.awaitExpression = Abe;
  C.bigIntLiteral = uge;
  C.binaryExpression = fge;
  C.bindExpression = mDe;
  C.blockStatement = mge;
  C.booleanLiteral = Nge;
  C.booleanLiteralTypeAnnotation = $be;
  C.booleanTypeAnnotation = Ube;
  C.breakStatement = yge;
  C.callExpression = gge;
  C.catchClause = bge;
  C.classAccessorProperty = kbe;
  C.classBody = abe;
  C.classDeclaration = ube;
  C.classExpression = obe;
  C.classImplements = Wbe;
  C.classMethod = vbe;
  C.classPrivateMethod = Nbe;
  C.classPrivateProperty = Bbe;
  C.classProperty = Obe;
  C.conditionalExpression = Dge;
  C.continueStatement = vge;
  C.debuggerStatement = xge;
  C.decimalLiteral = xDe;
  C.declareClass = Hbe;
  C.declareExportAllDeclaration = e2e;
  C.declareExportDeclaration = Qbe;
  C.declareFunction = Kbe;
  C.declareInterface = zbe;
  C.declareModule = Jbe;
  C.declareModuleExports = Xbe;
  C.declareOpaqueType = Gbe;
  C.declareTypeAlias = Ybe;
  C.declareVariable = Zbe;
  C.declaredPredicate = t2e;
  C.decorator = yDe;
  C.directive = pge;
  C.directiveLiteral = hge;
  C.doExpression = gDe;
  C.doWhileStatement = Ege;
  C.emptyStatement = Sge;
  C.emptyTypeAnnotation = d2e;
  C.enumBooleanBody = q2e;
  C.enumBooleanMember = W2e;
  C.enumDeclaration = j2e;
  C.enumDefaultedMember = z2e;
  C.enumNumberBody = U2e;
  C.enumNumberMember = H2e;
  C.enumStringBody = $2e;
  C.enumStringMember = K2e;
  C.enumSymbolBody = V2e;
  C.existsTypeAnnotation = r2e;
  C.exportAllDeclaration = lbe;
  C.exportDefaultDeclaration = cbe;
  C.exportDefaultSpecifier = bDe;
  C.exportNamedDeclaration = fbe;
  C.exportNamespaceSpecifier = Pbe;
  C.exportSpecifier = dbe;
  C.expressionStatement = Tge;
  C.file = Cge;
  C.forInStatement = wge;
  C.forOfStatement = pbe;
  C.forStatement = Age;
  C.functionDeclaration = _ge;
  C.functionExpression = Pge;
  C.functionTypeAnnotation = i2e;
  C.functionTypeParam = s2e;
  C.genericTypeAnnotation = n2e;
  C.identifier = Fge;
  C.ifStatement = Ige;
  C.import = _be;
  C.importAttribute = Lbe;
  C.importDeclaration = hbe;
  C.importDefaultSpecifier = mbe;
  C.importExpression = bbe;
  C.importNamespaceSpecifier = ybe;
  C.importSpecifier = gbe;
  C.indexedAccessType = J2e;
  C.inferredPredicate = a2e;
  C.interfaceDeclaration = u2e;
  C.interfaceExtends = o2e;
  C.interfaceTypeAnnotation = l2e;
  C.interpreterDirective = dge;
  C.intersectionTypeAnnotation = c2e;
  C.jSXAttribute = C.jsxAttribute = Y2e;
  C.jSXClosingElement = C.jsxClosingElement = G2e;
  C.jSXClosingFragment = C.jsxClosingFragment = cDe;
  C.jSXElement = C.jsxElement = Z2e;
  C.jSXEmptyExpression = C.jsxEmptyExpression = Q2e;
  C.jSXExpressionContainer = C.jsxExpressionContainer = eDe;
  C.jSXFragment = C.jsxFragment = uDe;
  C.jSXIdentifier = C.jsxIdentifier = rDe;
  C.jSXMemberExpression = C.jsxMemberExpression = iDe;
  C.jSXNamespacedName = C.jsxNamespacedName = sDe;
  C.jSXOpeningElement = C.jsxOpeningElement = nDe;
  C.jSXOpeningFragment = C.jsxOpeningFragment = lDe;
  C.jSXSpreadAttribute = C.jsxSpreadAttribute = aDe;
  C.jSXSpreadChild = C.jsxSpreadChild = tDe;
  C.jSXText = C.jsxText = oDe;
  C.labeledStatement = Oge;
  C.logicalExpression = Mge;
  C.memberExpression = Rge;
  C.metaProperty = Dbe;
  C.mixedTypeAnnotation = f2e;
  C.moduleExpression = EDe;
  C.newExpression = Lge;
  C.noop = fDe;
  C.nullLiteral = Bge;
  C.nullLiteralTypeAnnotation = Vbe;
  C.nullableTypeAnnotation = p2e;
  C.numberLiteral = Uve;
  C.numberLiteralTypeAnnotation = h2e;
  C.numberTypeAnnotation = m2e;
  C.numericLiteral = OM;
  C.objectExpression = qge;
  C.objectMethod = Uge;
  C.objectPattern = xbe;
  C.objectProperty = $ge;
  C.objectTypeAnnotation = y2e;
  C.objectTypeCallProperty = b2e;
  C.objectTypeIndexer = D2e;
  C.objectTypeInternalSlot = g2e;
  C.objectTypeProperty = v2e;
  C.objectTypeSpreadProperty = x2e;
  C.opaqueType = E2e;
  C.optionalCallExpression = Ibe;
  C.optionalIndexedAccessType = X2e;
  C.optionalMemberExpression = Fbe;
  C.parenthesizedExpression = Hge;
  C.pipelineBareFunction = CDe;
  C.pipelinePrimaryTopicReference = wDe;
  C.pipelineTopicExpression = TDe;
  C.placeholder = dDe;
  C.privateName = Mbe;
  C.program = jge;
  C.qualifiedTypeIdentifier = S2e;
  C.recordExpression = DDe;
  C.regExpLiteral = kM;
  C.regexLiteral = $ve;
  C.restElement = BM;
  C.restProperty = Vve;
  C.returnStatement = Vge;
  C.sequenceExpression = Wge;
  C.spreadElement = NM;
  C.spreadProperty = Wve;
  C.staticBlock = Rbe;
  C.stringLiteral = kge;
  C.stringLiteralTypeAnnotation = T2e;
  C.stringTypeAnnotation = C2e;
  C.super = Ebe;
  C.switchCase = Kge;
  C.switchStatement = zge;
  C.symbolTypeAnnotation = w2e;
  C.taggedTemplateExpression = Sbe;
  C.templateElement = Tbe;
  C.templateLiteral = Cbe;
  C.thisExpression = Jge;
  C.thisTypeAnnotation = A2e;
  C.throwStatement = Xge;
  C.topicReference = SDe;
  C.tryStatement = Yge;
  C.tSAnyKeyword = C.tsAnyKeyword = RDe;
  C.tSArrayType = C.tsArrayType = ive;
  C.tSAsExpression = C.tsAsExpression = Sve;
  C.tSBigIntKeyword = C.tsBigIntKeyword = jDe;
  C.tSBooleanKeyword = C.tsBooleanKeyword = LDe;
  C.tSCallSignatureDeclaration = C.tsCallSignatureDeclaration = ODe;
  C.tSConditionalType = C.tsConditionalType = cve;
  C.tSConstructSignatureDeclaration = C.tsConstructSignatureDeclaration = kDe;
  C.tSConstructorType = C.tsConstructorType = ZDe;
  C.tSDeclareFunction = C.tsDeclareFunction = PDe;
  C.tSDeclareMethod = C.tsDeclareMethod = FDe;
  C.tSEnumBody = C.tsEnumBody = wve;
  C.tSEnumDeclaration = C.tsEnumDeclaration = Ave;
  C.tSEnumMember = C.tsEnumMember = _ve;
  C.tSExportAssignment = C.tsExportAssignment = Nve;
  C.tSExpressionWithTypeArguments = C.tsExpressionWithTypeArguments = bve;
  C.tSExternalModuleReference = C.tsExternalModuleReference = kve;
  C.tSFunctionType = C.tsFunctionType = GDe;
  C.tSImportEqualsDeclaration = C.tsImportEqualsDeclaration = Ove;
  C.tSImportType = C.tsImportType = Ive;
  C.tSIndexSignature = C.tsIndexSignature = MDe;
  C.tSIndexedAccessType = C.tsIndexedAccessType = hve;
  C.tSInferType = C.tsInferType = fve;
  C.tSInstantiationExpression = C.tsInstantiationExpression = Eve;
  C.tSInterfaceBody = C.tsInterfaceBody = vve;
  C.tSInterfaceDeclaration = C.tsInterfaceDeclaration = Dve;
  C.tSIntersectionType = C.tsIntersectionType = lve;
  C.tSIntrinsicKeyword = C.tsIntrinsicKeyword = qDe;
  C.tSLiteralType = C.tsLiteralType = gve;
  C.tSMappedType = C.tsMappedType = mve;
  C.tSMethodSignature = C.tsMethodSignature = NDe;
  C.tSModuleBlock = C.tsModuleBlock = Fve;
  C.tSModuleDeclaration = C.tsModuleDeclaration = Pve;
  C.tSNamedTupleMember = C.tsNamedTupleMember = ove;
  C.tSNamespaceExportDeclaration = C.tsNamespaceExportDeclaration = Mve;
  C.tSNeverKeyword = C.tsNeverKeyword = UDe;
  C.tSNonNullExpression = C.tsNonNullExpression = Bve;
  C.tSNullKeyword = C.tsNullKeyword = $De;
  C.tSNumberKeyword = C.tsNumberKeyword = VDe;
  C.tSObjectKeyword = C.tsObjectKeyword = WDe;
  C.tSOptionalType = C.tsOptionalType = nve;
  C.tSParameterProperty = C.tsParameterProperty = _De;
  C.tSParenthesizedType = C.tsParenthesizedType = dve;
  C.tSPropertySignature = C.tsPropertySignature = BDe;
  C.tSQualifiedName = C.tsQualifiedName = IDe;
  C.tSRestType = C.tsRestType = ave;
  C.tSSatisfiesExpression = C.tsSatisfiesExpression = Tve;
  C.tSStringKeyword = C.tsStringKeyword = HDe;
  C.tSSymbolKeyword = C.tsSymbolKeyword = KDe;
  C.tSTemplateLiteralType = C.tsTemplateLiteralType = yve;
  C.tSThisType = C.tsThisType = YDe;
  C.tSTupleType = C.tsTupleType = sve;
  C.tSTypeAliasDeclaration = C.tsTypeAliasDeclaration = xve;
  C.tSTypeAnnotation = C.tsTypeAnnotation = Rve;
  C.tSTypeAssertion = C.tsTypeAssertion = Cve;
  C.tSTypeLiteral = C.tsTypeLiteral = rve;
  C.tSTypeOperator = C.tsTypeOperator = pve;
  C.tSTypeParameter = C.tsTypeParameter = qve;
  C.tSTypeParameterDeclaration = C.tsTypeParameterDeclaration = jve;
  C.tSTypeParameterInstantiation = C.tsTypeParameterInstantiation = Lve;
  C.tSTypePredicate = C.tsTypePredicate = eve;
  C.tSTypeQuery = C.tsTypeQuery = tve;
  C.tSTypeReference = C.tsTypeReference = QDe;
  C.tSUndefinedKeyword = C.tsUndefinedKeyword = zDe;
  C.tSUnionType = C.tsUnionType = uve;
  C.tSUnknownKeyword = C.tsUnknownKeyword = JDe;
  C.tSVoidKeyword = C.tsVoidKeyword = XDe;
  C.tupleExpression = vDe;
  C.tupleTypeAnnotation = _2e;
  C.typeAlias = F2e;
  C.typeAnnotation = I2e;
  C.typeCastExpression = O2e;
  C.typeParameter = k2e;
  C.typeParameterDeclaration = B2e;
  C.typeParameterInstantiation = N2e;
  C.typeofTypeAnnotation = P2e;
  C.unaryExpression = Gge;
  C.unionTypeAnnotation = M2e;
  C.updateExpression = Zge;
  C.v8IntrinsicIdentifier = pDe;
  C.variableDeclaration = Qge;
  C.variableDeclarator = ebe;
  C.variance = R2e;
  C.voidPattern = ADe;
  C.voidTypeAnnotation = L2e;
  C.whileStatement = tbe;
  C.withStatement = rbe;
  C.yieldExpression = wbe;
  var age = Pm(), Bm = Fl(), oge = Ys(), {
    validateInternal: S
  } = age, {
    NODE_FIELDS: L
  } = oge;
  function uge(e) {
    typeof e == "bigint" && (e = e.toString());
    let t = {
      type: "BigIntLiteral",
      value: e
    }, r = L.BigIntLiteral;
    return S(r.value, t, "value", e), t;
  }
  n(uge, "bigIntLiteral");
  function lge(e = []) {
    let t = {
      type: "ArrayExpression",
      elements: e
    }, r = L.ArrayExpression;
    return S(r.elements, t, "elements", e, 1), t;
  }
  n(lge, "arrayExpression");
  function cge(e, t, r) {
    let i = {
      type: "AssignmentExpression",
      operator: e,
      left: t,
      right: r
    }, s = L.AssignmentExpression;
    return S(s.operator, i, "operator", e), S(s.left, i, "left", t, 1), S(s.right, i, "right", r, 1), i;
  }
  n(cge, "assignmentExpression");
  function fge(e, t, r) {
    let i = {
      type: "BinaryExpression",
      operator: e,
      left: t,
      right: r
    }, s = L.BinaryExpression;
    return S(s.operator, i, "operator", e), S(s.left, i, "left", t, 1), S(s.right, i, "right", r, 1), i;
  }
  n(fge, "binaryExpression");
  function dge(e) {
    let t = {
      type: "InterpreterDirective",
      value: e
    }, r = L.InterpreterDirective;
    return S(r.value, t, "value", e), t;
  }
  n(dge, "interpreterDirective");
  function pge(e) {
    let t = {
      type: "Directive",
      value: e
    }, r = L.Directive;
    return S(r.value, t, "value", e, 1), t;
  }
  n(pge, "directive");
  function hge(e) {
    let t = {
      type: "DirectiveLiteral",
      value: e
    }, r = L.DirectiveLiteral;
    return S(r.value, t, "value", e), t;
  }
  n(hge, "directiveLiteral");
  function mge(e, t = []) {
    let r = {
      type: "BlockStatement",
      body: e,
      directives: t
    }, i = L.BlockStatement;
    return S(i.body, r, "body", e, 1), S(i.directives, r, "directives", t, 1), r;
  }
  n(mge, "blockStatement");
  function yge(e = null) {
    let t = {
      type: "BreakStatement",
      label: e
    }, r = L.BreakStatement;
    return S(r.label, t, "label", e, 1), t;
  }
  n(yge, "breakStatement");
  function gge(e, t) {
    let r = {
      type: "CallExpression",
      callee: e,
      arguments: t
    }, i = L.CallExpression;
    return S(i.callee, r, "callee", e, 1), S(i.arguments, r, "arguments", t, 1), r;
  }
  n(gge, "callExpression");
  function bge(e = null, t) {
    let r = {
      type: "CatchClause",
      param: e,
      body: t
    }, i = L.CatchClause;
    return S(i.param, r, "param", e, 1), S(i.body, r, "body", t, 1), r;
  }
  n(bge, "catchClause");
  function Dge(e, t, r) {
    let i = {
      type: "ConditionalExpression",
      test: e,
      consequent: t,
      alternate: r
    }, s = L.ConditionalExpression;
    return S(s.test, i, "test", e, 1), S(s.consequent, i, "consequent", t, 1), S(s.alternate, i, "alternate", r, 1), i;
  }
  n(Dge, "conditionalExpression");
  function vge(e = null) {
    let t = {
      type: "ContinueStatement",
      label: e
    }, r = L.ContinueStatement;
    return S(r.label, t, "label", e, 1), t;
  }
  n(vge, "continueStatement");
  function xge() {
    return {
      type: "DebuggerStatement"
    };
  }
  n(xge, "debuggerStatement");
  function Ege(e, t) {
    let r = {
      type: "DoWhileStatement",
      test: e,
      body: t
    }, i = L.DoWhileStatement;
    return S(i.test, r, "test", e, 1), S(i.body, r, "body", t, 1), r;
  }
  n(Ege, "doWhileStatement");
  function Sge() {
    return {
      type: "EmptyStatement"
    };
  }
  n(Sge, "emptyStatement");
  function Tge(e) {
    let t = {
      type: "ExpressionStatement",
      expression: e
    }, r = L.ExpressionStatement;
    return S(r.expression, t, "expression", e, 1), t;
  }
  n(Tge, "expressionStatement");
  function Cge(e, t = null, r = null) {
    let i = {
      type: "File",
      program: e,
      comments: t,
      tokens: r
    }, s = L.File;
    return S(s.program, i, "program", e, 1), S(s.comments, i, "comments", t, 1), S(s.tokens, i, "tokens", r), i;
  }
  n(Cge, "file");
  function wge(e, t, r) {
    let i = {
      type: "ForInStatement",
      left: e,
      right: t,
      body: r
    }, s = L.ForInStatement;
    return S(s.left, i, "left", e, 1), S(s.right, i, "right", t, 1), S(s.body, i, "body", r, 1), i;
  }
  n(wge, "forInStatement");
  function Age(e = null, t = null, r = null, i) {
    let s = {
      type: "ForStatement",
      init: e,
      test: t,
      update: r,
      body: i
    }, a = L.ForStatement;
    return S(a.init, s, "init", e, 1), S(a.test, s, "test", t, 1), S(a.update, s, "update", r, 1), S(a.body, s, "body", i, 1), s;
  }
  n(Age, "forStatement");
  function _ge(e = null, t, r, i = !1, s = !1) {
    let a = {
      type: "FunctionDeclaration",
      id: e,
      params: t,
      body: r,
      generator: i,
      async: s
    }, o = L.FunctionDeclaration;
    return S(o.id, a, "id", e, 1), S(o.params, a, "params", t, 1), S(o.body, a, "body", r, 1), S(o.generator, a, "generator", i), S(o.async,
    a, "async", s), a;
  }
  n(_ge, "functionDeclaration");
  function Pge(e = null, t, r, i = !1, s = !1) {
    let a = {
      type: "FunctionExpression",
      id: e,
      params: t,
      body: r,
      generator: i,
      async: s
    }, o = L.FunctionExpression;
    return S(o.id, a, "id", e, 1), S(o.params, a, "params", t, 1), S(o.body, a, "body", r, 1), S(o.generator, a, "generator", i), S(o.async,
    a, "async", s), a;
  }
  n(Pge, "functionExpression");
  function Fge(e) {
    let t = {
      type: "Identifier",
      name: e
    }, r = L.Identifier;
    return S(r.name, t, "name", e), t;
  }
  n(Fge, "identifier");
  function Ige(e, t, r = null) {
    let i = {
      type: "IfStatement",
      test: e,
      consequent: t,
      alternate: r
    }, s = L.IfStatement;
    return S(s.test, i, "test", e, 1), S(s.consequent, i, "consequent", t, 1), S(s.alternate, i, "alternate", r, 1), i;
  }
  n(Ige, "ifStatement");
  function Oge(e, t) {
    let r = {
      type: "LabeledStatement",
      label: e,
      body: t
    }, i = L.LabeledStatement;
    return S(i.label, r, "label", e, 1), S(i.body, r, "body", t, 1), r;
  }
  n(Oge, "labeledStatement");
  function kge(e) {
    let t = {
      type: "StringLiteral",
      value: e
    }, r = L.StringLiteral;
    return S(r.value, t, "value", e), t;
  }
  n(kge, "stringLiteral");
  function OM(e) {
    let t = {
      type: "NumericLiteral",
      value: e
    }, r = L.NumericLiteral;
    return S(r.value, t, "value", e), t;
  }
  n(OM, "numericLiteral");
  function Bge() {
    return {
      type: "NullLiteral"
    };
  }
  n(Bge, "nullLiteral");
  function Nge(e) {
    let t = {
      type: "BooleanLiteral",
      value: e
    }, r = L.BooleanLiteral;
    return S(r.value, t, "value", e), t;
  }
  n(Nge, "booleanLiteral");
  function kM(e, t = "") {
    let r = {
      type: "RegExpLiteral",
      pattern: e,
      flags: t
    }, i = L.RegExpLiteral;
    return S(i.pattern, r, "pattern", e), S(i.flags, r, "flags", t), r;
  }
  n(kM, "regExpLiteral");
  function Mge(e, t, r) {
    let i = {
      type: "LogicalExpression",
      operator: e,
      left: t,
      right: r
    }, s = L.LogicalExpression;
    return S(s.operator, i, "operator", e), S(s.left, i, "left", t, 1), S(s.right, i, "right", r, 1), i;
  }
  n(Mge, "logicalExpression");
  function Rge(e, t, r = !1, i = null) {
    let s = {
      type: "MemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: i
    }, a = L.MemberExpression;
    return S(a.object, s, "object", e, 1), S(a.property, s, "property", t, 1), S(a.computed, s, "computed", r), S(a.optional, s, "optional",
    i), s;
  }
  n(Rge, "memberExpression");
  function Lge(e, t) {
    let r = {
      type: "NewExpression",
      callee: e,
      arguments: t
    }, i = L.NewExpression;
    return S(i.callee, r, "callee", e, 1), S(i.arguments, r, "arguments", t, 1), r;
  }
  n(Lge, "newExpression");
  function jge(e, t = [], r = "script", i = null) {
    let s = {
      type: "Program",
      body: e,
      directives: t,
      sourceType: r,
      interpreter: i
    }, a = L.Program;
    return S(a.body, s, "body", e, 1), S(a.directives, s, "directives", t, 1), S(a.sourceType, s, "sourceType", r), S(a.interpreter, s, "int\
erpreter", i, 1), s;
  }
  n(jge, "program");
  function qge(e) {
    let t = {
      type: "ObjectExpression",
      properties: e
    }, r = L.ObjectExpression;
    return S(r.properties, t, "properties", e, 1), t;
  }
  n(qge, "objectExpression");
  function Uge(e = "method", t, r, i, s = !1, a = !1, o = !1) {
    let u = {
      type: "ObjectMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      computed: s,
      generator: a,
      async: o
    }, l = L.ObjectMethod;
    return S(l.kind, u, "kind", e), S(l.key, u, "key", t, 1), S(l.params, u, "params", r, 1), S(l.body, u, "body", i, 1), S(l.computed, u, "\
computed", s), S(l.generator, u, "generator", a), S(l.async, u, "async", o), u;
  }
  n(Uge, "objectMethod");
  function $ge(e, t, r = !1, i = !1, s = null) {
    let a = {
      type: "ObjectProperty",
      key: e,
      value: t,
      computed: r,
      shorthand: i,
      decorators: s
    }, o = L.ObjectProperty;
    return S(o.key, a, "key", e, 1), S(o.value, a, "value", t, 1), S(o.computed, a, "computed", r), S(o.shorthand, a, "shorthand", i), S(o.decorators,
    a, "decorators", s, 1), a;
  }
  n($ge, "objectProperty");
  function BM(e) {
    let t = {
      type: "RestElement",
      argument: e
    }, r = L.RestElement;
    return S(r.argument, t, "argument", e, 1), t;
  }
  n(BM, "restElement");
  function Vge(e = null) {
    let t = {
      type: "ReturnStatement",
      argument: e
    }, r = L.ReturnStatement;
    return S(r.argument, t, "argument", e, 1), t;
  }
  n(Vge, "returnStatement");
  function Wge(e) {
    let t = {
      type: "SequenceExpression",
      expressions: e
    }, r = L.SequenceExpression;
    return S(r.expressions, t, "expressions", e, 1), t;
  }
  n(Wge, "sequenceExpression");
  function Hge(e) {
    let t = {
      type: "ParenthesizedExpression",
      expression: e
    }, r = L.ParenthesizedExpression;
    return S(r.expression, t, "expression", e, 1), t;
  }
  n(Hge, "parenthesizedExpression");
  function Kge(e = null, t) {
    let r = {
      type: "SwitchCase",
      test: e,
      consequent: t
    }, i = L.SwitchCase;
    return S(i.test, r, "test", e, 1), S(i.consequent, r, "consequent", t, 1), r;
  }
  n(Kge, "switchCase");
  function zge(e, t) {
    let r = {
      type: "SwitchStatement",
      discriminant: e,
      cases: t
    }, i = L.SwitchStatement;
    return S(i.discriminant, r, "discriminant", e, 1), S(i.cases, r, "cases", t, 1), r;
  }
  n(zge, "switchStatement");
  function Jge() {
    return {
      type: "ThisExpression"
    };
  }
  n(Jge, "thisExpression");
  function Xge(e) {
    let t = {
      type: "ThrowStatement",
      argument: e
    }, r = L.ThrowStatement;
    return S(r.argument, t, "argument", e, 1), t;
  }
  n(Xge, "throwStatement");
  function Yge(e, t = null, r = null) {
    let i = {
      type: "TryStatement",
      block: e,
      handler: t,
      finalizer: r
    }, s = L.TryStatement;
    return S(s.block, i, "block", e, 1), S(s.handler, i, "handler", t, 1), S(s.finalizer, i, "finalizer", r, 1), i;
  }
  n(Yge, "tryStatement");
  function Gge(e, t, r = !0) {
    let i = {
      type: "UnaryExpression",
      operator: e,
      argument: t,
      prefix: r
    }, s = L.UnaryExpression;
    return S(s.operator, i, "operator", e), S(s.argument, i, "argument", t, 1), S(s.prefix, i, "prefix", r), i;
  }
  n(Gge, "unaryExpression");
  function Zge(e, t, r = !1) {
    let i = {
      type: "UpdateExpression",
      operator: e,
      argument: t,
      prefix: r
    }, s = L.UpdateExpression;
    return S(s.operator, i, "operator", e), S(s.argument, i, "argument", t, 1), S(s.prefix, i, "prefix", r), i;
  }
  n(Zge, "updateExpression");
  function Qge(e, t) {
    let r = {
      type: "VariableDeclaration",
      kind: e,
      declarations: t
    }, i = L.VariableDeclaration;
    return S(i.kind, r, "kind", e), S(i.declarations, r, "declarations", t, 1), r;
  }
  n(Qge, "variableDeclaration");
  function ebe(e, t = null) {
    let r = {
      type: "VariableDeclarator",
      id: e,
      init: t
    }, i = L.VariableDeclarator;
    return S(i.id, r, "id", e, 1), S(i.init, r, "init", t, 1), r;
  }
  n(ebe, "variableDeclarator");
  function tbe(e, t) {
    let r = {
      type: "WhileStatement",
      test: e,
      body: t
    }, i = L.WhileStatement;
    return S(i.test, r, "test", e, 1), S(i.body, r, "body", t, 1), r;
  }
  n(tbe, "whileStatement");
  function rbe(e, t) {
    let r = {
      type: "WithStatement",
      object: e,
      body: t
    }, i = L.WithStatement;
    return S(i.object, r, "object", e, 1), S(i.body, r, "body", t, 1), r;
  }
  n(rbe, "withStatement");
  function ibe(e, t) {
    let r = {
      type: "AssignmentPattern",
      left: e,
      right: t
    }, i = L.AssignmentPattern;
    return S(i.left, r, "left", e, 1), S(i.right, r, "right", t, 1), r;
  }
  n(ibe, "assignmentPattern");
  function sbe(e) {
    let t = {
      type: "ArrayPattern",
      elements: e
    }, r = L.ArrayPattern;
    return S(r.elements, t, "elements", e, 1), t;
  }
  n(sbe, "arrayPattern");
  function nbe(e, t, r = !1) {
    let i = {
      type: "ArrowFunctionExpression",
      params: e,
      body: t,
      async: r,
      expression: null
    }, s = L.ArrowFunctionExpression;
    return S(s.params, i, "params", e, 1), S(s.body, i, "body", t, 1), S(s.async, i, "async", r), i;
  }
  n(nbe, "arrowFunctionExpression");
  function abe(e) {
    let t = {
      type: "ClassBody",
      body: e
    }, r = L.ClassBody;
    return S(r.body, t, "body", e, 1), t;
  }
  n(abe, "classBody");
  function obe(e = null, t = null, r, i = null) {
    let s = {
      type: "ClassExpression",
      id: e,
      superClass: t,
      body: r,
      decorators: i
    }, a = L.ClassExpression;
    return S(a.id, s, "id", e, 1), S(a.superClass, s, "superClass", t, 1), S(a.body, s, "body", r, 1), S(a.decorators, s, "decorators", i, 1),
    s;
  }
  n(obe, "classExpression");
  function ube(e = null, t = null, r, i = null) {
    let s = {
      type: "ClassDeclaration",
      id: e,
      superClass: t,
      body: r,
      decorators: i
    }, a = L.ClassDeclaration;
    return S(a.id, s, "id", e, 1), S(a.superClass, s, "superClass", t, 1), S(a.body, s, "body", r, 1), S(a.decorators, s, "decorators", i, 1),
    s;
  }
  n(ube, "classDeclaration");
  function lbe(e) {
    let t = {
      type: "ExportAllDeclaration",
      source: e
    }, r = L.ExportAllDeclaration;
    return S(r.source, t, "source", e, 1), t;
  }
  n(lbe, "exportAllDeclaration");
  function cbe(e) {
    let t = {
      type: "ExportDefaultDeclaration",
      declaration: e
    }, r = L.ExportDefaultDeclaration;
    return S(r.declaration, t, "declaration", e, 1), t;
  }
  n(cbe, "exportDefaultDeclaration");
  function fbe(e = null, t = [], r = null) {
    let i = {
      type: "ExportNamedDeclaration",
      declaration: e,
      specifiers: t,
      source: r
    }, s = L.ExportNamedDeclaration;
    return S(s.declaration, i, "declaration", e, 1), S(s.specifiers, i, "specifiers", t, 1), S(s.source, i, "source", r, 1), i;
  }
  n(fbe, "exportNamedDeclaration");
  function dbe(e, t) {
    let r = {
      type: "ExportSpecifier",
      local: e,
      exported: t
    }, i = L.ExportSpecifier;
    return S(i.local, r, "local", e, 1), S(i.exported, r, "exported", t, 1), r;
  }
  n(dbe, "exportSpecifier");
  function pbe(e, t, r, i = !1) {
    let s = {
      type: "ForOfStatement",
      left: e,
      right: t,
      body: r,
      await: i
    }, a = L.ForOfStatement;
    return S(a.left, s, "left", e, 1), S(a.right, s, "right", t, 1), S(a.body, s, "body", r, 1), S(a.await, s, "await", i), s;
  }
  n(pbe, "forOfStatement");
  function hbe(e, t) {
    let r = {
      type: "ImportDeclaration",
      specifiers: e,
      source: t
    }, i = L.ImportDeclaration;
    return S(i.specifiers, r, "specifiers", e, 1), S(i.source, r, "source", t, 1), r;
  }
  n(hbe, "importDeclaration");
  function mbe(e) {
    let t = {
      type: "ImportDefaultSpecifier",
      local: e
    }, r = L.ImportDefaultSpecifier;
    return S(r.local, t, "local", e, 1), t;
  }
  n(mbe, "importDefaultSpecifier");
  function ybe(e) {
    let t = {
      type: "ImportNamespaceSpecifier",
      local: e
    }, r = L.ImportNamespaceSpecifier;
    return S(r.local, t, "local", e, 1), t;
  }
  n(ybe, "importNamespaceSpecifier");
  function gbe(e, t) {
    let r = {
      type: "ImportSpecifier",
      local: e,
      imported: t
    }, i = L.ImportSpecifier;
    return S(i.local, r, "local", e, 1), S(i.imported, r, "imported", t, 1), r;
  }
  n(gbe, "importSpecifier");
  function bbe(e, t = null) {
    let r = {
      type: "ImportExpression",
      source: e,
      options: t
    }, i = L.ImportExpression;
    return S(i.source, r, "source", e, 1), S(i.options, r, "options", t, 1), r;
  }
  n(bbe, "importExpression");
  function Dbe(e, t) {
    let r = {
      type: "MetaProperty",
      meta: e,
      property: t
    }, i = L.MetaProperty;
    return S(i.meta, r, "meta", e, 1), S(i.property, r, "property", t, 1), r;
  }
  n(Dbe, "metaProperty");
  function vbe(e = "method", t, r, i, s = !1, a = !1, o = !1, u = !1) {
    let l = {
      type: "ClassMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      computed: s,
      static: a,
      generator: o,
      async: u
    }, c = L.ClassMethod;
    return S(c.kind, l, "kind", e), S(c.key, l, "key", t, 1), S(c.params, l, "params", r, 1), S(c.body, l, "body", i, 1), S(c.computed, l, "\
computed", s), S(c.static, l, "static", a), S(c.generator, l, "generator", o), S(c.async, l, "async", u), l;
  }
  n(vbe, "classMethod");
  function xbe(e) {
    let t = {
      type: "ObjectPattern",
      properties: e
    }, r = L.ObjectPattern;
    return S(r.properties, t, "properties", e, 1), t;
  }
  n(xbe, "objectPattern");
  function NM(e) {
    let t = {
      type: "SpreadElement",
      argument: e
    }, r = L.SpreadElement;
    return S(r.argument, t, "argument", e, 1), t;
  }
  n(NM, "spreadElement");
  function Ebe() {
    return {
      type: "Super"
    };
  }
  n(Ebe, "_super");
  function Sbe(e, t) {
    let r = {
      type: "TaggedTemplateExpression",
      tag: e,
      quasi: t
    }, i = L.TaggedTemplateExpression;
    return S(i.tag, r, "tag", e, 1), S(i.quasi, r, "quasi", t, 1), r;
  }
  n(Sbe, "taggedTemplateExpression");
  function Tbe(e, t = !1) {
    let r = {
      type: "TemplateElement",
      value: e,
      tail: t
    }, i = L.TemplateElement;
    return S(i.value, r, "value", e), S(i.tail, r, "tail", t), r;
  }
  n(Tbe, "templateElement");
  function Cbe(e, t) {
    let r = {
      type: "TemplateLiteral",
      quasis: e,
      expressions: t
    }, i = L.TemplateLiteral;
    return S(i.quasis, r, "quasis", e, 1), S(i.expressions, r, "expressions", t, 1), r;
  }
  n(Cbe, "templateLiteral");
  function wbe(e = null, t = !1) {
    let r = {
      type: "YieldExpression",
      argument: e,
      delegate: t
    }, i = L.YieldExpression;
    return S(i.argument, r, "argument", e, 1), S(i.delegate, r, "delegate", t), r;
  }
  n(wbe, "yieldExpression");
  function Abe(e) {
    let t = {
      type: "AwaitExpression",
      argument: e
    }, r = L.AwaitExpression;
    return S(r.argument, t, "argument", e, 1), t;
  }
  n(Abe, "awaitExpression");
  function _be() {
    return {
      type: "Import"
    };
  }
  n(_be, "_import");
  function Pbe(e) {
    let t = {
      type: "ExportNamespaceSpecifier",
      exported: e
    }, r = L.ExportNamespaceSpecifier;
    return S(r.exported, t, "exported", e, 1), t;
  }
  n(Pbe, "exportNamespaceSpecifier");
  function Fbe(e, t, r = !1, i) {
    let s = {
      type: "OptionalMemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: i
    }, a = L.OptionalMemberExpression;
    return S(a.object, s, "object", e, 1), S(a.property, s, "property", t, 1), S(a.computed, s, "computed", r), S(a.optional, s, "optional",
    i), s;
  }
  n(Fbe, "optionalMemberExpression");
  function Ibe(e, t, r) {
    let i = {
      type: "OptionalCallExpression",
      callee: e,
      arguments: t,
      optional: r
    }, s = L.OptionalCallExpression;
    return S(s.callee, i, "callee", e, 1), S(s.arguments, i, "arguments", t, 1), S(s.optional, i, "optional", r), i;
  }
  n(Ibe, "optionalCallExpression");
  function Obe(e, t = null, r = null, i = null, s = !1, a = !1) {
    let o = {
      type: "ClassProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: i,
      computed: s,
      static: a
    }, u = L.ClassProperty;
    return S(u.key, o, "key", e, 1), S(u.value, o, "value", t, 1), S(u.typeAnnotation, o, "typeAnnotation", r, 1), S(u.decorators, o, "decor\
ators", i, 1), S(u.computed, o, "computed", s), S(u.static, o, "static", a), o;
  }
  n(Obe, "classProperty");
  function kbe(e, t = null, r = null, i = null, s = !1, a = !1) {
    let o = {
      type: "ClassAccessorProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: i,
      computed: s,
      static: a
    }, u = L.ClassAccessorProperty;
    return S(u.key, o, "key", e, 1), S(u.value, o, "value", t, 1), S(u.typeAnnotation, o, "typeAnnotation", r, 1), S(u.decorators, o, "decor\
ators", i, 1), S(u.computed, o, "computed", s), S(u.static, o, "static", a), o;
  }
  n(kbe, "classAccessorProperty");
  function Bbe(e, t = null, r = null, i = !1) {
    let s = {
      type: "ClassPrivateProperty",
      key: e,
      value: t,
      decorators: r,
      static: i
    }, a = L.ClassPrivateProperty;
    return S(a.key, s, "key", e, 1), S(a.value, s, "value", t, 1), S(a.decorators, s, "decorators", r, 1), S(a.static, s, "static", i), s;
  }
  n(Bbe, "classPrivateProperty");
  function Nbe(e = "method", t, r, i, s = !1) {
    let a = {
      type: "ClassPrivateMethod",
      kind: e,
      key: t,
      params: r,
      body: i,
      static: s
    }, o = L.ClassPrivateMethod;
    return S(o.kind, a, "kind", e), S(o.key, a, "key", t, 1), S(o.params, a, "params", r, 1), S(o.body, a, "body", i, 1), S(o.static, a, "st\
atic", s), a;
  }
  n(Nbe, "classPrivateMethod");
  function Mbe(e) {
    let t = {
      type: "PrivateName",
      id: e
    }, r = L.PrivateName;
    return S(r.id, t, "id", e, 1), t;
  }
  n(Mbe, "privateName");
  function Rbe(e) {
    let t = {
      type: "StaticBlock",
      body: e
    }, r = L.StaticBlock;
    return S(r.body, t, "body", e, 1), t;
  }
  n(Rbe, "staticBlock");
  function Lbe(e, t) {
    let r = {
      type: "ImportAttribute",
      key: e,
      value: t
    }, i = L.ImportAttribute;
    return S(i.key, r, "key", e, 1), S(i.value, r, "value", t, 1), r;
  }
  n(Lbe, "importAttribute");
  function jbe() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  n(jbe, "anyTypeAnnotation");
  function qbe(e) {
    let t = {
      type: "ArrayTypeAnnotation",
      elementType: e
    }, r = L.ArrayTypeAnnotation;
    return S(r.elementType, t, "elementType", e, 1), t;
  }
  n(qbe, "arrayTypeAnnotation");
  function Ube() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  n(Ube, "booleanTypeAnnotation");
  function $be(e) {
    let t = {
      type: "BooleanLiteralTypeAnnotation",
      value: e
    }, r = L.BooleanLiteralTypeAnnotation;
    return S(r.value, t, "value", e), t;
  }
  n($be, "booleanLiteralTypeAnnotation");
  function Vbe() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  n(Vbe, "nullLiteralTypeAnnotation");
  function Wbe(e, t = null) {
    let r = {
      type: "ClassImplements",
      id: e,
      typeParameters: t
    }, i = L.ClassImplements;
    return S(i.id, r, "id", e, 1), S(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  n(Wbe, "classImplements");
  function Hbe(e, t = null, r = null, i) {
    let s = {
      type: "DeclareClass",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    }, a = L.DeclareClass;
    return S(a.id, s, "id", e, 1), S(a.typeParameters, s, "typeParameters", t, 1), S(a.extends, s, "extends", r, 1), S(a.body, s, "body", i,
    1), s;
  }
  n(Hbe, "declareClass");
  function Kbe(e) {
    let t = {
      type: "DeclareFunction",
      id: e
    }, r = L.DeclareFunction;
    return S(r.id, t, "id", e, 1), t;
  }
  n(Kbe, "declareFunction");
  function zbe(e, t = null, r = null, i) {
    let s = {
      type: "DeclareInterface",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    }, a = L.DeclareInterface;
    return S(a.id, s, "id", e, 1), S(a.typeParameters, s, "typeParameters", t, 1), S(a.extends, s, "extends", r, 1), S(a.body, s, "body", i,
    1), s;
  }
  n(zbe, "declareInterface");
  function Jbe(e, t, r = null) {
    let i = {
      type: "DeclareModule",
      id: e,
      body: t,
      kind: r
    }, s = L.DeclareModule;
    return S(s.id, i, "id", e, 1), S(s.body, i, "body", t, 1), S(s.kind, i, "kind", r), i;
  }
  n(Jbe, "declareModule");
  function Xbe(e) {
    let t = {
      type: "DeclareModuleExports",
      typeAnnotation: e
    }, r = L.DeclareModuleExports;
    return S(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  n(Xbe, "declareModuleExports");
  function Ybe(e, t = null, r) {
    let i = {
      type: "DeclareTypeAlias",
      id: e,
      typeParameters: t,
      right: r
    }, s = L.DeclareTypeAlias;
    return S(s.id, i, "id", e, 1), S(s.typeParameters, i, "typeParameters", t, 1), S(s.right, i, "right", r, 1), i;
  }
  n(Ybe, "declareTypeAlias");
  function Gbe(e, t = null, r = null) {
    let i = {
      type: "DeclareOpaqueType",
      id: e,
      typeParameters: t,
      supertype: r
    }, s = L.DeclareOpaqueType;
    return S(s.id, i, "id", e, 1), S(s.typeParameters, i, "typeParameters", t, 1), S(s.supertype, i, "supertype", r, 1), i;
  }
  n(Gbe, "declareOpaqueType");
  function Zbe(e) {
    let t = {
      type: "DeclareVariable",
      id: e
    }, r = L.DeclareVariable;
    return S(r.id, t, "id", e, 1), t;
  }
  n(Zbe, "declareVariable");
  function Qbe(e = null, t = null, r = null, i = null) {
    let s = {
      type: "DeclareExportDeclaration",
      declaration: e,
      specifiers: t,
      source: r,
      attributes: i
    }, a = L.DeclareExportDeclaration;
    return S(a.declaration, s, "declaration", e, 1), S(a.specifiers, s, "specifiers", t, 1), S(a.source, s, "source", r, 1), S(a.attributes,
    s, "attributes", i, 1), s;
  }
  n(Qbe, "declareExportDeclaration");
  function e2e(e, t = null) {
    let r = {
      type: "DeclareExportAllDeclaration",
      source: e,
      attributes: t
    }, i = L.DeclareExportAllDeclaration;
    return S(i.source, r, "source", e, 1), S(i.attributes, r, "attributes", t, 1), r;
  }
  n(e2e, "declareExportAllDeclaration");
  function t2e(e) {
    let t = {
      type: "DeclaredPredicate",
      value: e
    }, r = L.DeclaredPredicate;
    return S(r.value, t, "value", e, 1), t;
  }
  n(t2e, "declaredPredicate");
  function r2e() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  n(r2e, "existsTypeAnnotation");
  function i2e(e = null, t, r = null, i) {
    let s = {
      type: "FunctionTypeAnnotation",
      typeParameters: e,
      params: t,
      rest: r,
      returnType: i
    }, a = L.FunctionTypeAnnotation;
    return S(a.typeParameters, s, "typeParameters", e, 1), S(a.params, s, "params", t, 1), S(a.rest, s, "rest", r, 1), S(a.returnType, s, "r\
eturnType", i, 1), s;
  }
  n(i2e, "functionTypeAnnotation");
  function s2e(e = null, t) {
    let r = {
      type: "FunctionTypeParam",
      name: e,
      typeAnnotation: t
    }, i = L.FunctionTypeParam;
    return S(i.name, r, "name", e, 1), S(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  n(s2e, "functionTypeParam");
  function n2e(e, t = null) {
    let r = {
      type: "GenericTypeAnnotation",
      id: e,
      typeParameters: t
    }, i = L.GenericTypeAnnotation;
    return S(i.id, r, "id", e, 1), S(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  n(n2e, "genericTypeAnnotation");
  function a2e() {
    return {
      type: "InferredPredicate"
    };
  }
  n(a2e, "inferredPredicate");
  function o2e(e, t = null) {
    let r = {
      type: "InterfaceExtends",
      id: e,
      typeParameters: t
    }, i = L.InterfaceExtends;
    return S(i.id, r, "id", e, 1), S(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  n(o2e, "interfaceExtends");
  function u2e(e, t = null, r = null, i) {
    let s = {
      type: "InterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    }, a = L.InterfaceDeclaration;
    return S(a.id, s, "id", e, 1), S(a.typeParameters, s, "typeParameters", t, 1), S(a.extends, s, "extends", r, 1), S(a.body, s, "body", i,
    1), s;
  }
  n(u2e, "interfaceDeclaration");
  function l2e(e = null, t) {
    let r = {
      type: "InterfaceTypeAnnotation",
      extends: e,
      body: t
    }, i = L.InterfaceTypeAnnotation;
    return S(i.extends, r, "extends", e, 1), S(i.body, r, "body", t, 1), r;
  }
  n(l2e, "interfaceTypeAnnotation");
  function c2e(e) {
    let t = {
      type: "IntersectionTypeAnnotation",
      types: e
    }, r = L.IntersectionTypeAnnotation;
    return S(r.types, t, "types", e, 1), t;
  }
  n(c2e, "intersectionTypeAnnotation");
  function f2e() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  n(f2e, "mixedTypeAnnotation");
  function d2e() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  n(d2e, "emptyTypeAnnotation");
  function p2e(e) {
    let t = {
      type: "NullableTypeAnnotation",
      typeAnnotation: e
    }, r = L.NullableTypeAnnotation;
    return S(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  n(p2e, "nullableTypeAnnotation");
  function h2e(e) {
    let t = {
      type: "NumberLiteralTypeAnnotation",
      value: e
    }, r = L.NumberLiteralTypeAnnotation;
    return S(r.value, t, "value", e), t;
  }
  n(h2e, "numberLiteralTypeAnnotation");
  function m2e() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  n(m2e, "numberTypeAnnotation");
  function y2e(e, t = [], r = [], i = [], s = !1) {
    let a = {
      type: "ObjectTypeAnnotation",
      properties: e,
      indexers: t,
      callProperties: r,
      internalSlots: i,
      exact: s
    }, o = L.ObjectTypeAnnotation;
    return S(o.properties, a, "properties", e, 1), S(o.indexers, a, "indexers", t, 1), S(o.callProperties, a, "callProperties", r, 1), S(o.internalSlots,
    a, "internalSlots", i, 1), S(o.exact, a, "exact", s), a;
  }
  n(y2e, "objectTypeAnnotation");
  function g2e(e, t, r, i, s) {
    let a = {
      type: "ObjectTypeInternalSlot",
      id: e,
      value: t,
      optional: r,
      static: i,
      method: s
    }, o = L.ObjectTypeInternalSlot;
    return S(o.id, a, "id", e, 1), S(o.value, a, "value", t, 1), S(o.optional, a, "optional", r), S(o.static, a, "static", i), S(o.method, a,
    "method", s), a;
  }
  n(g2e, "objectTypeInternalSlot");
  function b2e(e) {
    let t = {
      type: "ObjectTypeCallProperty",
      value: e,
      static: null
    }, r = L.ObjectTypeCallProperty;
    return S(r.value, t, "value", e, 1), t;
  }
  n(b2e, "objectTypeCallProperty");
  function D2e(e = null, t, r, i = null) {
    let s = {
      type: "ObjectTypeIndexer",
      id: e,
      key: t,
      value: r,
      variance: i,
      static: null
    }, a = L.ObjectTypeIndexer;
    return S(a.id, s, "id", e, 1), S(a.key, s, "key", t, 1), S(a.value, s, "value", r, 1), S(a.variance, s, "variance", i, 1), s;
  }
  n(D2e, "objectTypeIndexer");
  function v2e(e, t, r = null) {
    let i = {
      type: "ObjectTypeProperty",
      key: e,
      value: t,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    }, s = L.ObjectTypeProperty;
    return S(s.key, i, "key", e, 1), S(s.value, i, "value", t, 1), S(s.variance, i, "variance", r, 1), i;
  }
  n(v2e, "objectTypeProperty");
  function x2e(e) {
    let t = {
      type: "ObjectTypeSpreadProperty",
      argument: e
    }, r = L.ObjectTypeSpreadProperty;
    return S(r.argument, t, "argument", e, 1), t;
  }
  n(x2e, "objectTypeSpreadProperty");
  function E2e(e, t = null, r = null, i) {
    let s = {
      type: "OpaqueType",
      id: e,
      typeParameters: t,
      supertype: r,
      impltype: i
    }, a = L.OpaqueType;
    return S(a.id, s, "id", e, 1), S(a.typeParameters, s, "typeParameters", t, 1), S(a.supertype, s, "supertype", r, 1), S(a.impltype, s, "i\
mpltype", i, 1), s;
  }
  n(E2e, "opaqueType");
  function S2e(e, t) {
    let r = {
      type: "QualifiedTypeIdentifier",
      id: e,
      qualification: t
    }, i = L.QualifiedTypeIdentifier;
    return S(i.id, r, "id", e, 1), S(i.qualification, r, "qualification", t, 1), r;
  }
  n(S2e, "qualifiedTypeIdentifier");
  function T2e(e) {
    let t = {
      type: "StringLiteralTypeAnnotation",
      value: e
    }, r = L.StringLiteralTypeAnnotation;
    return S(r.value, t, "value", e), t;
  }
  n(T2e, "stringLiteralTypeAnnotation");
  function C2e() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  n(C2e, "stringTypeAnnotation");
  function w2e() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  n(w2e, "symbolTypeAnnotation");
  function A2e() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  n(A2e, "thisTypeAnnotation");
  function _2e(e) {
    let t = {
      type: "TupleTypeAnnotation",
      types: e
    }, r = L.TupleTypeAnnotation;
    return S(r.types, t, "types", e, 1), t;
  }
  n(_2e, "tupleTypeAnnotation");
  function P2e(e) {
    let t = {
      type: "TypeofTypeAnnotation",
      argument: e
    }, r = L.TypeofTypeAnnotation;
    return S(r.argument, t, "argument", e, 1), t;
  }
  n(P2e, "typeofTypeAnnotation");
  function F2e(e, t = null, r) {
    let i = {
      type: "TypeAlias",
      id: e,
      typeParameters: t,
      right: r
    }, s = L.TypeAlias;
    return S(s.id, i, "id", e, 1), S(s.typeParameters, i, "typeParameters", t, 1), S(s.right, i, "right", r, 1), i;
  }
  n(F2e, "typeAlias");
  function I2e(e) {
    let t = {
      type: "TypeAnnotation",
      typeAnnotation: e
    }, r = L.TypeAnnotation;
    return S(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  n(I2e, "typeAnnotation");
  function O2e(e, t) {
    let r = {
      type: "TypeCastExpression",
      expression: e,
      typeAnnotation: t
    }, i = L.TypeCastExpression;
    return S(i.expression, r, "expression", e, 1), S(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  n(O2e, "typeCastExpression");
  function k2e(e = null, t = null, r = null) {
    let i = {
      type: "TypeParameter",
      bound: e,
      default: t,
      variance: r,
      name: null
    }, s = L.TypeParameter;
    return S(s.bound, i, "bound", e, 1), S(s.default, i, "default", t, 1), S(s.variance, i, "variance", r, 1), i;
  }
  n(k2e, "typeParameter");
  function B2e(e) {
    let t = {
      type: "TypeParameterDeclaration",
      params: e
    }, r = L.TypeParameterDeclaration;
    return S(r.params, t, "params", e, 1), t;
  }
  n(B2e, "typeParameterDeclaration");
  function N2e(e) {
    let t = {
      type: "TypeParameterInstantiation",
      params: e
    }, r = L.TypeParameterInstantiation;
    return S(r.params, t, "params", e, 1), t;
  }
  n(N2e, "typeParameterInstantiation");
  function M2e(e) {
    let t = {
      type: "UnionTypeAnnotation",
      types: e
    }, r = L.UnionTypeAnnotation;
    return S(r.types, t, "types", e, 1), t;
  }
  n(M2e, "unionTypeAnnotation");
  function R2e(e) {
    let t = {
      type: "Variance",
      kind: e
    }, r = L.Variance;
    return S(r.kind, t, "kind", e), t;
  }
  n(R2e, "variance");
  function L2e() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  n(L2e, "voidTypeAnnotation");
  function j2e(e, t) {
    let r = {
      type: "EnumDeclaration",
      id: e,
      body: t
    }, i = L.EnumDeclaration;
    return S(i.id, r, "id", e, 1), S(i.body, r, "body", t, 1), r;
  }
  n(j2e, "enumDeclaration");
  function q2e(e) {
    let t = {
      type: "EnumBooleanBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    }, r = L.EnumBooleanBody;
    return S(r.members, t, "members", e, 1), t;
  }
  n(q2e, "enumBooleanBody");
  function U2e(e) {
    let t = {
      type: "EnumNumberBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    }, r = L.EnumNumberBody;
    return S(r.members, t, "members", e, 1), t;
  }
  n(U2e, "enumNumberBody");
  function $2e(e) {
    let t = {
      type: "EnumStringBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    }, r = L.EnumStringBody;
    return S(r.members, t, "members", e, 1), t;
  }
  n($2e, "enumStringBody");
  function V2e(e) {
    let t = {
      type: "EnumSymbolBody",
      members: e,
      hasUnknownMembers: null
    }, r = L.EnumSymbolBody;
    return S(r.members, t, "members", e, 1), t;
  }
  n(V2e, "enumSymbolBody");
  function W2e(e) {
    let t = {
      type: "EnumBooleanMember",
      id: e,
      init: null
    }, r = L.EnumBooleanMember;
    return S(r.id, t, "id", e, 1), t;
  }
  n(W2e, "enumBooleanMember");
  function H2e(e, t) {
    let r = {
      type: "EnumNumberMember",
      id: e,
      init: t
    }, i = L.EnumNumberMember;
    return S(i.id, r, "id", e, 1), S(i.init, r, "init", t, 1), r;
  }
  n(H2e, "enumNumberMember");
  function K2e(e, t) {
    let r = {
      type: "EnumStringMember",
      id: e,
      init: t
    }, i = L.EnumStringMember;
    return S(i.id, r, "id", e, 1), S(i.init, r, "init", t, 1), r;
  }
  n(K2e, "enumStringMember");
  function z2e(e) {
    let t = {
      type: "EnumDefaultedMember",
      id: e
    }, r = L.EnumDefaultedMember;
    return S(r.id, t, "id", e, 1), t;
  }
  n(z2e, "enumDefaultedMember");
  function J2e(e, t) {
    let r = {
      type: "IndexedAccessType",
      objectType: e,
      indexType: t
    }, i = L.IndexedAccessType;
    return S(i.objectType, r, "objectType", e, 1), S(i.indexType, r, "indexType", t, 1), r;
  }
  n(J2e, "indexedAccessType");
  function X2e(e, t) {
    let r = {
      type: "OptionalIndexedAccessType",
      objectType: e,
      indexType: t,
      optional: null
    }, i = L.OptionalIndexedAccessType;
    return S(i.objectType, r, "objectType", e, 1), S(i.indexType, r, "indexType", t, 1), r;
  }
  n(X2e, "optionalIndexedAccessType");
  function Y2e(e, t = null) {
    let r = {
      type: "JSXAttribute",
      name: e,
      value: t
    }, i = L.JSXAttribute;
    return S(i.name, r, "name", e, 1), S(i.value, r, "value", t, 1), r;
  }
  n(Y2e, "jsxAttribute");
  function G2e(e) {
    let t = {
      type: "JSXClosingElement",
      name: e
    }, r = L.JSXClosingElement;
    return S(r.name, t, "name", e, 1), t;
  }
  n(G2e, "jsxClosingElement");
  function Z2e(e, t = null, r, i = null) {
    let s = {
      type: "JSXElement",
      openingElement: e,
      closingElement: t,
      children: r,
      selfClosing: i
    }, a = L.JSXElement;
    return S(a.openingElement, s, "openingElement", e, 1), S(a.closingElement, s, "closingElement", t, 1), S(a.children, s, "children", r, 1),
    S(a.selfClosing, s, "selfClosing", i), s;
  }
  n(Z2e, "jsxElement");
  function Q2e() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  n(Q2e, "jsxEmptyExpression");
  function eDe(e) {
    let t = {
      type: "JSXExpressionContainer",
      expression: e
    }, r = L.JSXExpressionContainer;
    return S(r.expression, t, "expression", e, 1), t;
  }
  n(eDe, "jsxExpressionContainer");
  function tDe(e) {
    let t = {
      type: "JSXSpreadChild",
      expression: e
    }, r = L.JSXSpreadChild;
    return S(r.expression, t, "expression", e, 1), t;
  }
  n(tDe, "jsxSpreadChild");
  function rDe(e) {
    let t = {
      type: "JSXIdentifier",
      name: e
    }, r = L.JSXIdentifier;
    return S(r.name, t, "name", e), t;
  }
  n(rDe, "jsxIdentifier");
  function iDe(e, t) {
    let r = {
      type: "JSXMemberExpression",
      object: e,
      property: t
    }, i = L.JSXMemberExpression;
    return S(i.object, r, "object", e, 1), S(i.property, r, "property", t, 1), r;
  }
  n(iDe, "jsxMemberExpression");
  function sDe(e, t) {
    let r = {
      type: "JSXNamespacedName",
      namespace: e,
      name: t
    }, i = L.JSXNamespacedName;
    return S(i.namespace, r, "namespace", e, 1), S(i.name, r, "name", t, 1), r;
  }
  n(sDe, "jsxNamespacedName");
  function nDe(e, t, r = !1) {
    let i = {
      type: "JSXOpeningElement",
      name: e,
      attributes: t,
      selfClosing: r
    }, s = L.JSXOpeningElement;
    return S(s.name, i, "name", e, 1), S(s.attributes, i, "attributes", t, 1), S(s.selfClosing, i, "selfClosing", r), i;
  }
  n(nDe, "jsxOpeningElement");
  function aDe(e) {
    let t = {
      type: "JSXSpreadAttribute",
      argument: e
    }, r = L.JSXSpreadAttribute;
    return S(r.argument, t, "argument", e, 1), t;
  }
  n(aDe, "jsxSpreadAttribute");
  function oDe(e) {
    let t = {
      type: "JSXText",
      value: e
    }, r = L.JSXText;
    return S(r.value, t, "value", e), t;
  }
  n(oDe, "jsxText");
  function uDe(e, t, r) {
    let i = {
      type: "JSXFragment",
      openingFragment: e,
      closingFragment: t,
      children: r
    }, s = L.JSXFragment;
    return S(s.openingFragment, i, "openingFragment", e, 1), S(s.closingFragment, i, "closingFragment", t, 1), S(s.children, i, "children", r,
    1), i;
  }
  n(uDe, "jsxFragment");
  function lDe() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  n(lDe, "jsxOpeningFragment");
  function cDe() {
    return {
      type: "JSXClosingFragment"
    };
  }
  n(cDe, "jsxClosingFragment");
  function fDe() {
    return {
      type: "Noop"
    };
  }
  n(fDe, "noop");
  function dDe(e, t) {
    let r = {
      type: "Placeholder",
      expectedNode: e,
      name: t
    }, i = L.Placeholder;
    return S(i.expectedNode, r, "expectedNode", e), S(i.name, r, "name", t, 1), r;
  }
  n(dDe, "placeholder");
  function pDe(e) {
    let t = {
      type: "V8IntrinsicIdentifier",
      name: e
    }, r = L.V8IntrinsicIdentifier;
    return S(r.name, t, "name", e), t;
  }
  n(pDe, "v8IntrinsicIdentifier");
  function hDe() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  n(hDe, "argumentPlaceholder");
  function mDe(e, t) {
    let r = {
      type: "BindExpression",
      object: e,
      callee: t
    }, i = L.BindExpression;
    return S(i.object, r, "object", e, 1), S(i.callee, r, "callee", t, 1), r;
  }
  n(mDe, "bindExpression");
  function yDe(e) {
    let t = {
      type: "Decorator",
      expression: e
    }, r = L.Decorator;
    return S(r.expression, t, "expression", e, 1), t;
  }
  n(yDe, "decorator");
  function gDe(e, t = !1) {
    let r = {
      type: "DoExpression",
      body: e,
      async: t
    }, i = L.DoExpression;
    return S(i.body, r, "body", e, 1), S(i.async, r, "async", t), r;
  }
  n(gDe, "doExpression");
  function bDe(e) {
    let t = {
      type: "ExportDefaultSpecifier",
      exported: e
    }, r = L.ExportDefaultSpecifier;
    return S(r.exported, t, "exported", e, 1), t;
  }
  n(bDe, "exportDefaultSpecifier");
  function DDe(e) {
    let t = {
      type: "RecordExpression",
      properties: e
    }, r = L.RecordExpression;
    return S(r.properties, t, "properties", e, 1), t;
  }
  n(DDe, "recordExpression");
  function vDe(e = []) {
    let t = {
      type: "TupleExpression",
      elements: e
    }, r = L.TupleExpression;
    return S(r.elements, t, "elements", e, 1), t;
  }
  n(vDe, "tupleExpression");
  function xDe(e) {
    let t = {
      type: "DecimalLiteral",
      value: e
    }, r = L.DecimalLiteral;
    return S(r.value, t, "value", e), t;
  }
  n(xDe, "decimalLiteral");
  function EDe(e) {
    let t = {
      type: "ModuleExpression",
      body: e
    }, r = L.ModuleExpression;
    return S(r.body, t, "body", e, 1), t;
  }
  n(EDe, "moduleExpression");
  function SDe() {
    return {
      type: "TopicReference"
    };
  }
  n(SDe, "topicReference");
  function TDe(e) {
    let t = {
      type: "PipelineTopicExpression",
      expression: e
    }, r = L.PipelineTopicExpression;
    return S(r.expression, t, "expression", e, 1), t;
  }
  n(TDe, "pipelineTopicExpression");
  function CDe(e) {
    let t = {
      type: "PipelineBareFunction",
      callee: e
    }, r = L.PipelineBareFunction;
    return S(r.callee, t, "callee", e, 1), t;
  }
  n(CDe, "pipelineBareFunction");
  function wDe() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  n(wDe, "pipelinePrimaryTopicReference");
  function ADe() {
    return {
      type: "VoidPattern"
    };
  }
  n(ADe, "voidPattern");
  function _De(e) {
    let t = {
      type: "TSParameterProperty",
      parameter: e
    }, r = L.TSParameterProperty;
    return S(r.parameter, t, "parameter", e, 1), t;
  }
  n(_De, "tsParameterProperty");
  function PDe(e = null, t = null, r, i = null) {
    let s = {
      type: "TSDeclareFunction",
      id: e,
      typeParameters: t,
      params: r,
      returnType: i
    }, a = L.TSDeclareFunction;
    return S(a.id, s, "id", e, 1), S(a.typeParameters, s, "typeParameters", t, 1), S(a.params, s, "params", r, 1), S(a.returnType, s, "retur\
nType", i, 1), s;
  }
  n(PDe, "tsDeclareFunction");
  function FDe(e = null, t, r = null, i, s = null) {
    let a = {
      type: "TSDeclareMethod",
      decorators: e,
      key: t,
      typeParameters: r,
      params: i,
      returnType: s
    }, o = L.TSDeclareMethod;
    return S(o.decorators, a, "decorators", e, 1), S(o.key, a, "key", t, 1), S(o.typeParameters, a, "typeParameters", r, 1), S(o.params, a, "\
params", i, 1), S(o.returnType, a, "returnType", s, 1), a;
  }
  n(FDe, "tsDeclareMethod");
  function IDe(e, t) {
    let r = {
      type: "TSQualifiedName",
      left: e,
      right: t
    }, i = L.TSQualifiedName;
    return S(i.left, r, "left", e, 1), S(i.right, r, "right", t, 1), r;
  }
  n(IDe, "tsQualifiedName");
  function ODe(e = null, t, r = null) {
    let i = {
      type: "TSCallSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, s = L.TSCallSignatureDeclaration;
    return S(s.typeParameters, i, "typeParameters", e, 1), S(s.parameters, i, "parameters", t, 1), S(s.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  n(ODe, "tsCallSignatureDeclaration");
  function kDe(e = null, t, r = null) {
    let i = {
      type: "TSConstructSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, s = L.TSConstructSignatureDeclaration;
    return S(s.typeParameters, i, "typeParameters", e, 1), S(s.parameters, i, "parameters", t, 1), S(s.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  n(kDe, "tsConstructSignatureDeclaration");
  function BDe(e, t = null) {
    let r = {
      type: "TSPropertySignature",
      key: e,
      typeAnnotation: t
    }, i = L.TSPropertySignature;
    return S(i.key, r, "key", e, 1), S(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  n(BDe, "tsPropertySignature");
  function NDe(e, t = null, r, i = null) {
    let s = {
      type: "TSMethodSignature",
      key: e,
      typeParameters: t,
      parameters: r,
      typeAnnotation: i,
      kind: null
    }, a = L.TSMethodSignature;
    return S(a.key, s, "key", e, 1), S(a.typeParameters, s, "typeParameters", t, 1), S(a.parameters, s, "parameters", r, 1), S(a.typeAnnotation,
    s, "typeAnnotation", i, 1), s;
  }
  n(NDe, "tsMethodSignature");
  function MDe(e, t = null) {
    let r = {
      type: "TSIndexSignature",
      parameters: e,
      typeAnnotation: t
    }, i = L.TSIndexSignature;
    return S(i.parameters, r, "parameters", e, 1), S(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  n(MDe, "tsIndexSignature");
  function RDe() {
    return {
      type: "TSAnyKeyword"
    };
  }
  n(RDe, "tsAnyKeyword");
  function LDe() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  n(LDe, "tsBooleanKeyword");
  function jDe() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  n(jDe, "tsBigIntKeyword");
  function qDe() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  n(qDe, "tsIntrinsicKeyword");
  function UDe() {
    return {
      type: "TSNeverKeyword"
    };
  }
  n(UDe, "tsNeverKeyword");
  function $De() {
    return {
      type: "TSNullKeyword"
    };
  }
  n($De, "tsNullKeyword");
  function VDe() {
    return {
      type: "TSNumberKeyword"
    };
  }
  n(VDe, "tsNumberKeyword");
  function WDe() {
    return {
      type: "TSObjectKeyword"
    };
  }
  n(WDe, "tsObjectKeyword");
  function HDe() {
    return {
      type: "TSStringKeyword"
    };
  }
  n(HDe, "tsStringKeyword");
  function KDe() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  n(KDe, "tsSymbolKeyword");
  function zDe() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  n(zDe, "tsUndefinedKeyword");
  function JDe() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  n(JDe, "tsUnknownKeyword");
  function XDe() {
    return {
      type: "TSVoidKeyword"
    };
  }
  n(XDe, "tsVoidKeyword");
  function YDe() {
    return {
      type: "TSThisType"
    };
  }
  n(YDe, "tsThisType");
  function GDe(e = null, t, r = null) {
    let i = {
      type: "TSFunctionType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, s = L.TSFunctionType;
    return S(s.typeParameters, i, "typeParameters", e, 1), S(s.parameters, i, "parameters", t, 1), S(s.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  n(GDe, "tsFunctionType");
  function ZDe(e = null, t, r = null) {
    let i = {
      type: "TSConstructorType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, s = L.TSConstructorType;
    return S(s.typeParameters, i, "typeParameters", e, 1), S(s.parameters, i, "parameters", t, 1), S(s.typeAnnotation, i, "typeAnnotation", r,
    1), i;
  }
  n(ZDe, "tsConstructorType");
  function QDe(e, t = null) {
    let r = {
      type: "TSTypeReference",
      typeName: e,
      typeParameters: t
    }, i = L.TSTypeReference;
    return S(i.typeName, r, "typeName", e, 1), S(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  n(QDe, "tsTypeReference");
  function eve(e, t = null, r = null) {
    let i = {
      type: "TSTypePredicate",
      parameterName: e,
      typeAnnotation: t,
      asserts: r
    }, s = L.TSTypePredicate;
    return S(s.parameterName, i, "parameterName", e, 1), S(s.typeAnnotation, i, "typeAnnotation", t, 1), S(s.asserts, i, "asserts", r), i;
  }
  n(eve, "tsTypePredicate");
  function tve(e, t = null) {
    let r = {
      type: "TSTypeQuery",
      exprName: e,
      typeParameters: t
    }, i = L.TSTypeQuery;
    return S(i.exprName, r, "exprName", e, 1), S(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  n(tve, "tsTypeQuery");
  function rve(e) {
    let t = {
      type: "TSTypeLiteral",
      members: e
    }, r = L.TSTypeLiteral;
    return S(r.members, t, "members", e, 1), t;
  }
  n(rve, "tsTypeLiteral");
  function ive(e) {
    let t = {
      type: "TSArrayType",
      elementType: e
    }, r = L.TSArrayType;
    return S(r.elementType, t, "elementType", e, 1), t;
  }
  n(ive, "tsArrayType");
  function sve(e) {
    let t = {
      type: "TSTupleType",
      elementTypes: e
    }, r = L.TSTupleType;
    return S(r.elementTypes, t, "elementTypes", e, 1), t;
  }
  n(sve, "tsTupleType");
  function nve(e) {
    let t = {
      type: "TSOptionalType",
      typeAnnotation: e
    }, r = L.TSOptionalType;
    return S(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  n(nve, "tsOptionalType");
  function ave(e) {
    let t = {
      type: "TSRestType",
      typeAnnotation: e
    }, r = L.TSRestType;
    return S(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  n(ave, "tsRestType");
  function ove(e, t, r = !1) {
    let i = {
      type: "TSNamedTupleMember",
      label: e,
      elementType: t,
      optional: r
    }, s = L.TSNamedTupleMember;
    return S(s.label, i, "label", e, 1), S(s.elementType, i, "elementType", t, 1), S(s.optional, i, "optional", r), i;
  }
  n(ove, "tsNamedTupleMember");
  function uve(e) {
    let t = {
      type: "TSUnionType",
      types: e
    }, r = L.TSUnionType;
    return S(r.types, t, "types", e, 1), t;
  }
  n(uve, "tsUnionType");
  function lve(e) {
    let t = {
      type: "TSIntersectionType",
      types: e
    }, r = L.TSIntersectionType;
    return S(r.types, t, "types", e, 1), t;
  }
  n(lve, "tsIntersectionType");
  function cve(e, t, r, i) {
    let s = {
      type: "TSConditionalType",
      checkType: e,
      extendsType: t,
      trueType: r,
      falseType: i
    }, a = L.TSConditionalType;
    return S(a.checkType, s, "checkType", e, 1), S(a.extendsType, s, "extendsType", t, 1), S(a.trueType, s, "trueType", r, 1), S(a.falseType,
    s, "falseType", i, 1), s;
  }
  n(cve, "tsConditionalType");
  function fve(e) {
    let t = {
      type: "TSInferType",
      typeParameter: e
    }, r = L.TSInferType;
    return S(r.typeParameter, t, "typeParameter", e, 1), t;
  }
  n(fve, "tsInferType");
  function dve(e) {
    let t = {
      type: "TSParenthesizedType",
      typeAnnotation: e
    }, r = L.TSParenthesizedType;
    return S(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  n(dve, "tsParenthesizedType");
  function pve(e, t = "keyof") {
    let r = {
      type: "TSTypeOperator",
      typeAnnotation: e,
      operator: t
    }, i = L.TSTypeOperator;
    return S(i.typeAnnotation, r, "typeAnnotation", e, 1), S(i.operator, r, "operator", t), r;
  }
  n(pve, "tsTypeOperator");
  function hve(e, t) {
    let r = {
      type: "TSIndexedAccessType",
      objectType: e,
      indexType: t
    }, i = L.TSIndexedAccessType;
    return S(i.objectType, r, "objectType", e, 1), S(i.indexType, r, "indexType", t, 1), r;
  }
  n(hve, "tsIndexedAccessType");
  function mve(e, t = null, r = null) {
    let i = {
      type: "TSMappedType",
      typeParameter: e,
      typeAnnotation: t,
      nameType: r
    }, s = L.TSMappedType;
    return S(s.typeParameter, i, "typeParameter", e, 1), S(s.typeAnnotation, i, "typeAnnotation", t, 1), S(s.nameType, i, "nameType", r, 1),
    i;
  }
  n(mve, "tsMappedType");
  function yve(e, t) {
    let r = {
      type: "TSTemplateLiteralType",
      quasis: e,
      types: t
    }, i = L.TSTemplateLiteralType;
    return S(i.quasis, r, "quasis", e, 1), S(i.types, r, "types", t, 1), r;
  }
  n(yve, "tsTemplateLiteralType");
  function gve(e) {
    let t = {
      type: "TSLiteralType",
      literal: e
    }, r = L.TSLiteralType;
    return S(r.literal, t, "literal", e, 1), t;
  }
  n(gve, "tsLiteralType");
  function bve(e, t = null) {
    let r = {
      type: "TSExpressionWithTypeArguments",
      expression: e,
      typeParameters: t
    }, i = L.TSExpressionWithTypeArguments;
    return S(i.expression, r, "expression", e, 1), S(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  n(bve, "tsExpressionWithTypeArguments");
  function Dve(e, t = null, r = null, i) {
    let s = {
      type: "TSInterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: i
    }, a = L.TSInterfaceDeclaration;
    return S(a.id, s, "id", e, 1), S(a.typeParameters, s, "typeParameters", t, 1), S(a.extends, s, "extends", r, 1), S(a.body, s, "body", i,
    1), s;
  }
  n(Dve, "tsInterfaceDeclaration");
  function vve(e) {
    let t = {
      type: "TSInterfaceBody",
      body: e
    }, r = L.TSInterfaceBody;
    return S(r.body, t, "body", e, 1), t;
  }
  n(vve, "tsInterfaceBody");
  function xve(e, t = null, r) {
    let i = {
      type: "TSTypeAliasDeclaration",
      id: e,
      typeParameters: t,
      typeAnnotation: r
    }, s = L.TSTypeAliasDeclaration;
    return S(s.id, i, "id", e, 1), S(s.typeParameters, i, "typeParameters", t, 1), S(s.typeAnnotation, i, "typeAnnotation", r, 1), i;
  }
  n(xve, "tsTypeAliasDeclaration");
  function Eve(e, t = null) {
    let r = {
      type: "TSInstantiationExpression",
      expression: e,
      typeParameters: t
    }, i = L.TSInstantiationExpression;
    return S(i.expression, r, "expression", e, 1), S(i.typeParameters, r, "typeParameters", t, 1), r;
  }
  n(Eve, "tsInstantiationExpression");
  function Sve(e, t) {
    let r = {
      type: "TSAsExpression",
      expression: e,
      typeAnnotation: t
    }, i = L.TSAsExpression;
    return S(i.expression, r, "expression", e, 1), S(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  n(Sve, "tsAsExpression");
  function Tve(e, t) {
    let r = {
      type: "TSSatisfiesExpression",
      expression: e,
      typeAnnotation: t
    }, i = L.TSSatisfiesExpression;
    return S(i.expression, r, "expression", e, 1), S(i.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  n(Tve, "tsSatisfiesExpression");
  function Cve(e, t) {
    let r = {
      type: "TSTypeAssertion",
      typeAnnotation: e,
      expression: t
    }, i = L.TSTypeAssertion;
    return S(i.typeAnnotation, r, "typeAnnotation", e, 1), S(i.expression, r, "expression", t, 1), r;
  }
  n(Cve, "tsTypeAssertion");
  function wve(e) {
    let t = {
      type: "TSEnumBody",
      members: e
    }, r = L.TSEnumBody;
    return S(r.members, t, "members", e, 1), t;
  }
  n(wve, "tsEnumBody");
  function Ave(e, t) {
    let r = {
      type: "TSEnumDeclaration",
      id: e,
      members: t
    }, i = L.TSEnumDeclaration;
    return S(i.id, r, "id", e, 1), S(i.members, r, "members", t, 1), r;
  }
  n(Ave, "tsEnumDeclaration");
  function _ve(e, t = null) {
    let r = {
      type: "TSEnumMember",
      id: e,
      initializer: t
    }, i = L.TSEnumMember;
    return S(i.id, r, "id", e, 1), S(i.initializer, r, "initializer", t, 1), r;
  }
  n(_ve, "tsEnumMember");
  function Pve(e, t) {
    let r = {
      type: "TSModuleDeclaration",
      id: e,
      body: t,
      kind: null
    }, i = L.TSModuleDeclaration;
    return S(i.id, r, "id", e, 1), S(i.body, r, "body", t, 1), r;
  }
  n(Pve, "tsModuleDeclaration");
  function Fve(e) {
    let t = {
      type: "TSModuleBlock",
      body: e
    }, r = L.TSModuleBlock;
    return S(r.body, t, "body", e, 1), t;
  }
  n(Fve, "tsModuleBlock");
  function Ive(e, t = null, r = null) {
    let i = {
      type: "TSImportType",
      argument: e,
      qualifier: t,
      typeParameters: r
    }, s = L.TSImportType;
    return S(s.argument, i, "argument", e, 1), S(s.qualifier, i, "qualifier", t, 1), S(s.typeParameters, i, "typeParameters", r, 1), i;
  }
  n(Ive, "tsImportType");
  function Ove(e, t) {
    let r = {
      type: "TSImportEqualsDeclaration",
      id: e,
      moduleReference: t,
      isExport: null
    }, i = L.TSImportEqualsDeclaration;
    return S(i.id, r, "id", e, 1), S(i.moduleReference, r, "moduleReference", t, 1), r;
  }
  n(Ove, "tsImportEqualsDeclaration");
  function kve(e) {
    let t = {
      type: "TSExternalModuleReference",
      expression: e
    }, r = L.TSExternalModuleReference;
    return S(r.expression, t, "expression", e, 1), t;
  }
  n(kve, "tsExternalModuleReference");
  function Bve(e) {
    let t = {
      type: "TSNonNullExpression",
      expression: e
    }, r = L.TSNonNullExpression;
    return S(r.expression, t, "expression", e, 1), t;
  }
  n(Bve, "tsNonNullExpression");
  function Nve(e) {
    let t = {
      type: "TSExportAssignment",
      expression: e
    }, r = L.TSExportAssignment;
    return S(r.expression, t, "expression", e, 1), t;
  }
  n(Nve, "tsExportAssignment");
  function Mve(e) {
    let t = {
      type: "TSNamespaceExportDeclaration",
      id: e
    }, r = L.TSNamespaceExportDeclaration;
    return S(r.id, t, "id", e, 1), t;
  }
  n(Mve, "tsNamespaceExportDeclaration");
  function Rve(e) {
    let t = {
      type: "TSTypeAnnotation",
      typeAnnotation: e
    }, r = L.TSTypeAnnotation;
    return S(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  n(Rve, "tsTypeAnnotation");
  function Lve(e) {
    let t = {
      type: "TSTypeParameterInstantiation",
      params: e
    }, r = L.TSTypeParameterInstantiation;
    return S(r.params, t, "params", e, 1), t;
  }
  n(Lve, "tsTypeParameterInstantiation");
  function jve(e) {
    let t = {
      type: "TSTypeParameterDeclaration",
      params: e
    }, r = L.TSTypeParameterDeclaration;
    return S(r.params, t, "params", e, 1), t;
  }
  n(jve, "tsTypeParameterDeclaration");
  function qve(e = null, t = null, r) {
    let i = {
      type: "TSTypeParameter",
      constraint: e,
      default: t,
      name: r
    }, s = L.TSTypeParameter;
    return S(s.constraint, i, "constraint", e, 1), S(s.default, i, "default", t, 1), S(s.name, i, "name", r), i;
  }
  n(qve, "tsTypeParameter");
  function Uve(e) {
    return (0, Bm.default)("NumberLiteral", "NumericLiteral", "The node type "), OM(e);
  }
  n(Uve, "NumberLiteral");
  function $ve(e, t = "") {
    return (0, Bm.default)("RegexLiteral", "RegExpLiteral", "The node type "), kM(e, t);
  }
  n($ve, "RegexLiteral");
  function Vve(e) {
    return (0, Bm.default)("RestProperty", "RestElement", "The node type "), BM(e);
  }
  n(Vve, "RestProperty");
  function Wve(e) {
    return (0, Bm.default)("SpreadProperty", "SpreadElement", "The node type "), NM(e);
  }
  n(Wve, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var MM = E((v) => {
  "use strict";
  Object.defineProperty(v, "__esModule", {
    value: !0
  });
  v.JSXIdentifier = v.JSXFragment = v.JSXExpressionContainer = v.JSXEmptyExpression = v.JSXElement = v.JSXClosingFragment = v.JSXClosingElement =
  v.JSXAttribute = v.IntersectionTypeAnnotation = v.InterpreterDirective = v.InterfaceTypeAnnotation = v.InterfaceExtends = v.InterfaceDeclaration =
  v.InferredPredicate = v.IndexedAccessType = v.ImportSpecifier = v.ImportNamespaceSpecifier = v.ImportExpression = v.ImportDefaultSpecifier =
  v.ImportDeclaration = v.ImportAttribute = v.Import = v.IfStatement = v.Identifier = v.GenericTypeAnnotation = v.FunctionTypeParam = v.FunctionTypeAnnotation =
  v.FunctionExpression = v.FunctionDeclaration = v.ForStatement = v.ForOfStatement = v.ForInStatement = v.File = v.ExpressionStatement = v.ExportSpecifier =
  v.ExportNamespaceSpecifier = v.ExportNamedDeclaration = v.ExportDefaultSpecifier = v.ExportDefaultDeclaration = v.ExportAllDeclaration = v.
  ExistsTypeAnnotation = v.EnumSymbolBody = v.EnumStringMember = v.EnumStringBody = v.EnumNumberMember = v.EnumNumberBody = v.EnumDefaultedMember =
  v.EnumDeclaration = v.EnumBooleanMember = v.EnumBooleanBody = v.EmptyTypeAnnotation = v.EmptyStatement = v.DoWhileStatement = v.DoExpression =
  v.DirectiveLiteral = v.Directive = v.Decorator = v.DeclaredPredicate = v.DeclareVariable = v.DeclareTypeAlias = v.DeclareOpaqueType = v.DeclareModuleExports =
  v.DeclareModule = v.DeclareInterface = v.DeclareFunction = v.DeclareExportDeclaration = v.DeclareExportAllDeclaration = v.DeclareClass = v.
  DecimalLiteral = v.DebuggerStatement = v.ContinueStatement = v.ConditionalExpression = v.ClassProperty = v.ClassPrivateProperty = v.ClassPrivateMethod =
  v.ClassMethod = v.ClassImplements = v.ClassExpression = v.ClassDeclaration = v.ClassBody = v.ClassAccessorProperty = v.CatchClause = v.CallExpression =
  v.BreakStatement = v.BooleanTypeAnnotation = v.BooleanLiteralTypeAnnotation = v.BooleanLiteral = v.BlockStatement = v.BindExpression = v.BinaryExpression =
  v.BigIntLiteral = v.AwaitExpression = v.AssignmentPattern = v.AssignmentExpression = v.ArrowFunctionExpression = v.ArrayTypeAnnotation = v.
  ArrayPattern = v.ArrayExpression = v.ArgumentPlaceholder = v.AnyTypeAnnotation = void 0;
  v.TSNumberKeyword = v.TSNullKeyword = v.TSNonNullExpression = v.TSNeverKeyword = v.TSNamespaceExportDeclaration = v.TSNamedTupleMember = v.
  TSModuleDeclaration = v.TSModuleBlock = v.TSMethodSignature = v.TSMappedType = v.TSLiteralType = v.TSIntrinsicKeyword = v.TSIntersectionType =
  v.TSInterfaceDeclaration = v.TSInterfaceBody = v.TSInstantiationExpression = v.TSInferType = v.TSIndexedAccessType = v.TSIndexSignature = v.
  TSImportType = v.TSImportEqualsDeclaration = v.TSFunctionType = v.TSExternalModuleReference = v.TSExpressionWithTypeArguments = v.TSExportAssignment =
  v.TSEnumMember = v.TSEnumDeclaration = v.TSEnumBody = v.TSDeclareMethod = v.TSDeclareFunction = v.TSConstructorType = v.TSConstructSignatureDeclaration =
  v.TSConditionalType = v.TSCallSignatureDeclaration = v.TSBooleanKeyword = v.TSBigIntKeyword = v.TSAsExpression = v.TSArrayType = v.TSAnyKeyword =
  v.SymbolTypeAnnotation = v.SwitchStatement = v.SwitchCase = v.Super = v.StringTypeAnnotation = v.StringLiteralTypeAnnotation = v.StringLiteral =
  v.StaticBlock = v.SpreadProperty = v.SpreadElement = v.SequenceExpression = v.ReturnStatement = v.RestProperty = v.RestElement = v.RegexLiteral =
  v.RegExpLiteral = v.RecordExpression = v.QualifiedTypeIdentifier = v.Program = v.PrivateName = v.Placeholder = v.PipelineTopicExpression =
  v.PipelinePrimaryTopicReference = v.PipelineBareFunction = v.ParenthesizedExpression = v.OptionalMemberExpression = v.OptionalIndexedAccessType =
  v.OptionalCallExpression = v.OpaqueType = v.ObjectTypeSpreadProperty = v.ObjectTypeProperty = v.ObjectTypeInternalSlot = v.ObjectTypeIndexer =
  v.ObjectTypeCallProperty = v.ObjectTypeAnnotation = v.ObjectProperty = v.ObjectPattern = v.ObjectMethod = v.ObjectExpression = v.NumericLiteral =
  v.NumberTypeAnnotation = v.NumberLiteralTypeAnnotation = v.NumberLiteral = v.NullableTypeAnnotation = v.NullLiteralTypeAnnotation = v.NullLiteral =
  v.Noop = v.NewExpression = v.ModuleExpression = v.MixedTypeAnnotation = v.MetaProperty = v.MemberExpression = v.LogicalExpression = v.LabeledStatement =
  v.JSXText = v.JSXSpreadChild = v.JSXSpreadAttribute = v.JSXOpeningFragment = v.JSXOpeningElement = v.JSXNamespacedName = v.JSXMemberExpression =
  void 0;
  v.YieldExpression = v.WithStatement = v.WhileStatement = v.VoidTypeAnnotation = v.VoidPattern = v.Variance = v.VariableDeclarator = v.VariableDeclaration =
  v.V8IntrinsicIdentifier = v.UpdateExpression = v.UnionTypeAnnotation = v.UnaryExpression = v.TypeofTypeAnnotation = v.TypeParameterInstantiation =
  v.TypeParameterDeclaration = v.TypeParameter = v.TypeCastExpression = v.TypeAnnotation = v.TypeAlias = v.TupleTypeAnnotation = v.TupleExpression =
  v.TryStatement = v.TopicReference = v.ThrowStatement = v.ThisTypeAnnotation = v.ThisExpression = v.TemplateLiteral = v.TemplateElement = v.
  TaggedTemplateExpression = v.TSVoidKeyword = v.TSUnknownKeyword = v.TSUnionType = v.TSUndefinedKeyword = v.TSTypeReference = v.TSTypeQuery =
  v.TSTypePredicate = v.TSTypeParameterInstantiation = v.TSTypeParameterDeclaration = v.TSTypeParameter = v.TSTypeOperator = v.TSTypeLiteral =
  v.TSTypeAssertion = v.TSTypeAnnotation = v.TSTypeAliasDeclaration = v.TSTupleType = v.TSThisType = v.TSTemplateLiteralType = v.TSSymbolKeyword =
  v.TSStringKeyword = v.TSSatisfiesExpression = v.TSRestType = v.TSQualifiedName = v.TSPropertySignature = v.TSParenthesizedType = v.TSParameterProperty =
  v.TSOptionalType = v.TSObjectKeyword = void 0;
  var wd = NE(), Jut = Fl();
  function N(e) {
    return wd[e];
  }
  n(N, "alias");
  var Xut = v.ArrayExpression = N("arrayExpression"), Yut = v.AssignmentExpression = N("assignmentExpression"), Gut = v.BinaryExpression = N(
  "binaryExpression"), Zut = v.InterpreterDirective = N("interpreterDirective"), Qut = v.Directive = N("directive"), elt = v.DirectiveLiteral =
  N("directiveLiteral"), tlt = v.BlockStatement = N("blockStatement"), rlt = v.BreakStatement = N("breakStatement"), ilt = v.CallExpression =
  N("callExpression"), slt = v.CatchClause = N("catchClause"), nlt = v.ConditionalExpression = N("conditionalExpression"), alt = v.ContinueStatement =
  N("continueStatement"), olt = v.DebuggerStatement = N("debuggerStatement"), ult = v.DoWhileStatement = N("doWhileStatement"), llt = v.EmptyStatement =
  N("emptyStatement"), clt = v.ExpressionStatement = N("expressionStatement"), flt = v.File = N("file"), dlt = v.ForInStatement = N("forInSt\
atement"), plt = v.ForStatement = N("forStatement"), hlt = v.FunctionDeclaration = N("functionDeclaration"), mlt = v.FunctionExpression = N(
  "functionExpression"), ylt = v.Identifier = N("identifier"), glt = v.IfStatement = N("ifStatement"), blt = v.LabeledStatement = N("labeled\
Statement"), Dlt = v.StringLiteral = N("stringLiteral"), vlt = v.NumericLiteral = N("numericLiteral"), xlt = v.NullLiteral = N("nullLiteral"),
  Elt = v.BooleanLiteral = N("booleanLiteral"), Slt = v.RegExpLiteral = N("regExpLiteral"), Tlt = v.LogicalExpression = N("logicalExpression"),
  Clt = v.MemberExpression = N("memberExpression"), wlt = v.NewExpression = N("newExpression"), Alt = v.Program = N("program"), _lt = v.ObjectExpression =
  N("objectExpression"), Plt = v.ObjectMethod = N("objectMethod"), Flt = v.ObjectProperty = N("objectProperty"), Ilt = v.RestElement = N("re\
stElement"), Olt = v.ReturnStatement = N("returnStatement"), klt = v.SequenceExpression = N("sequenceExpression"), Blt = v.ParenthesizedExpression =
  N("parenthesizedExpression"), Nlt = v.SwitchCase = N("switchCase"), Mlt = v.SwitchStatement = N("switchStatement"), Rlt = v.ThisExpression =
  N("thisExpression"), Llt = v.ThrowStatement = N("throwStatement"), jlt = v.TryStatement = N("tryStatement"), qlt = v.UnaryExpression = N("\
unaryExpression"), Ult = v.UpdateExpression = N("updateExpression"), $lt = v.VariableDeclaration = N("variableDeclaration"), Vlt = v.VariableDeclarator =
  N("variableDeclarator"), Wlt = v.WhileStatement = N("whileStatement"), Hlt = v.WithStatement = N("withStatement"), Klt = v.AssignmentPattern =
  N("assignmentPattern"), zlt = v.ArrayPattern = N("arrayPattern"), Jlt = v.ArrowFunctionExpression = N("arrowFunctionExpression"), Xlt = v.
  ClassBody = N("classBody"), Ylt = v.ClassExpression = N("classExpression"), Glt = v.ClassDeclaration = N("classDeclaration"), Zlt = v.ExportAllDeclaration =
  N("exportAllDeclaration"), Qlt = v.ExportDefaultDeclaration = N("exportDefaultDeclaration"), ect = v.ExportNamedDeclaration = N("exportNam\
edDeclaration"), tct = v.ExportSpecifier = N("exportSpecifier"), rct = v.ForOfStatement = N("forOfStatement"), ict = v.ImportDeclaration = N(
  "importDeclaration"), sct = v.ImportDefaultSpecifier = N("importDefaultSpecifier"), nct = v.ImportNamespaceSpecifier = N("importNamespaceS\
pecifier"), act = v.ImportSpecifier = N("importSpecifier"), oct = v.ImportExpression = N("importExpression"), uct = v.MetaProperty = N("meta\
Property"), lct = v.ClassMethod = N("classMethod"), cct = v.ObjectPattern = N("objectPattern"), fct = v.SpreadElement = N("spreadElement"), dct = v.
  Super = N("super"), pct = v.TaggedTemplateExpression = N("taggedTemplateExpression"), hct = v.TemplateElement = N("templateElement"), mct = v.
  TemplateLiteral = N("templateLiteral"), yct = v.YieldExpression = N("yieldExpression"), gct = v.AwaitExpression = N("awaitExpression"), bct = v.
  Import = N("import"), Dct = v.BigIntLiteral = N("bigIntLiteral"), vct = v.ExportNamespaceSpecifier = N("exportNamespaceSpecifier"), xct = v.
  OptionalMemberExpression = N("optionalMemberExpression"), Ect = v.OptionalCallExpression = N("optionalCallExpression"), Sct = v.ClassProperty =
  N("classProperty"), Tct = v.ClassAccessorProperty = N("classAccessorProperty"), Cct = v.ClassPrivateProperty = N("classPrivateProperty"), wct = v.
  ClassPrivateMethod = N("classPrivateMethod"), Act = v.PrivateName = N("privateName"), _ct = v.StaticBlock = N("staticBlock"), Pct = v.ImportAttribute =
  N("importAttribute"), Fct = v.AnyTypeAnnotation = N("anyTypeAnnotation"), Ict = v.ArrayTypeAnnotation = N("arrayTypeAnnotation"), Oct = v.
  BooleanTypeAnnotation = N("booleanTypeAnnotation"), kct = v.BooleanLiteralTypeAnnotation = N("booleanLiteralTypeAnnotation"), Bct = v.NullLiteralTypeAnnotation =
  N("nullLiteralTypeAnnotation"), Nct = v.ClassImplements = N("classImplements"), Mct = v.DeclareClass = N("declareClass"), Rct = v.DeclareFunction =
  N("declareFunction"), Lct = v.DeclareInterface = N("declareInterface"), jct = v.DeclareModule = N("declareModule"), qct = v.DeclareModuleExports =
  N("declareModuleExports"), Uct = v.DeclareTypeAlias = N("declareTypeAlias"), $ct = v.DeclareOpaqueType = N("declareOpaqueType"), Vct = v.DeclareVariable =
  N("declareVariable"), Wct = v.DeclareExportDeclaration = N("declareExportDeclaration"), Hct = v.DeclareExportAllDeclaration = N("declareEx\
portAllDeclaration"), Kct = v.DeclaredPredicate = N("declaredPredicate"), zct = v.ExistsTypeAnnotation = N("existsTypeAnnotation"), Jct = v.
  FunctionTypeAnnotation = N("functionTypeAnnotation"), Xct = v.FunctionTypeParam = N("functionTypeParam"), Yct = v.GenericTypeAnnotation = N(
  "genericTypeAnnotation"), Gct = v.InferredPredicate = N("inferredPredicate"), Zct = v.InterfaceExtends = N("interfaceExtends"), Qct = v.InterfaceDeclaration =
  N("interfaceDeclaration"), eft = v.InterfaceTypeAnnotation = N("interfaceTypeAnnotation"), tft = v.IntersectionTypeAnnotation = N("interse\
ctionTypeAnnotation"), rft = v.MixedTypeAnnotation = N("mixedTypeAnnotation"), ift = v.EmptyTypeAnnotation = N("emptyTypeAnnotation"), sft = v.
  NullableTypeAnnotation = N("nullableTypeAnnotation"), nft = v.NumberLiteralTypeAnnotation = N("numberLiteralTypeAnnotation"), aft = v.NumberTypeAnnotation =
  N("numberTypeAnnotation"), oft = v.ObjectTypeAnnotation = N("objectTypeAnnotation"), uft = v.ObjectTypeInternalSlot = N("objectTypeInterna\
lSlot"), lft = v.ObjectTypeCallProperty = N("objectTypeCallProperty"), cft = v.ObjectTypeIndexer = N("objectTypeIndexer"), fft = v.ObjectTypeProperty =
  N("objectTypeProperty"), dft = v.ObjectTypeSpreadProperty = N("objectTypeSpreadProperty"), pft = v.OpaqueType = N("opaqueType"), hft = v.QualifiedTypeIdentifier =
  N("qualifiedTypeIdentifier"), mft = v.StringLiteralTypeAnnotation = N("stringLiteralTypeAnnotation"), yft = v.StringTypeAnnotation = N("st\
ringTypeAnnotation"), gft = v.SymbolTypeAnnotation = N("symbolTypeAnnotation"), bft = v.ThisTypeAnnotation = N("thisTypeAnnotation"), Dft = v.
  TupleTypeAnnotation = N("tupleTypeAnnotation"), vft = v.TypeofTypeAnnotation = N("typeofTypeAnnotation"), xft = v.TypeAlias = N("typeAlias"),
  Eft = v.TypeAnnotation = N("typeAnnotation"), Sft = v.TypeCastExpression = N("typeCastExpression"), Tft = v.TypeParameter = N("typeParamet\
er"), Cft = v.TypeParameterDeclaration = N("typeParameterDeclaration"), wft = v.TypeParameterInstantiation = N("typeParameterInstantiation"),
  Aft = v.UnionTypeAnnotation = N("unionTypeAnnotation"), _ft = v.Variance = N("variance"), Pft = v.VoidTypeAnnotation = N("voidTypeAnnotati\
on"), Fft = v.EnumDeclaration = N("enumDeclaration"), Ift = v.EnumBooleanBody = N("enumBooleanBody"), Oft = v.EnumNumberBody = N("enumNumber\
Body"), kft = v.EnumStringBody = N("enumStringBody"), Bft = v.EnumSymbolBody = N("enumSymbolBody"), Nft = v.EnumBooleanMember = N("enumBoole\
anMember"), Mft = v.EnumNumberMember = N("enumNumberMember"), Rft = v.EnumStringMember = N("enumStringMember"), Lft = v.EnumDefaultedMember =
  N("enumDefaultedMember"), jft = v.IndexedAccessType = N("indexedAccessType"), qft = v.OptionalIndexedAccessType = N("optionalIndexedAccess\
Type"), Uft = v.JSXAttribute = N("jsxAttribute"), $ft = v.JSXClosingElement = N("jsxClosingElement"), Vft = v.JSXElement = N("jsxElement"), Wft = v.
  JSXEmptyExpression = N("jsxEmptyExpression"), Hft = v.JSXExpressionContainer = N("jsxExpressionContainer"), Kft = v.JSXSpreadChild = N("js\
xSpreadChild"), zft = v.JSXIdentifier = N("jsxIdentifier"), Jft = v.JSXMemberExpression = N("jsxMemberExpression"), Xft = v.JSXNamespacedName =
  N("jsxNamespacedName"), Yft = v.JSXOpeningElement = N("jsxOpeningElement"), Gft = v.JSXSpreadAttribute = N("jsxSpreadAttribute"), Zft = v.
  JSXText = N("jsxText"), Qft = v.JSXFragment = N("jsxFragment"), edt = v.JSXOpeningFragment = N("jsxOpeningFragment"), tdt = v.JSXClosingFragment =
  N("jsxClosingFragment"), rdt = v.Noop = N("noop"), idt = v.Placeholder = N("placeholder"), sdt = v.V8IntrinsicIdentifier = N("v8IntrinsicI\
dentifier"), ndt = v.ArgumentPlaceholder = N("argumentPlaceholder"), adt = v.BindExpression = N("bindExpression"), odt = v.Decorator = N("de\
corator"), udt = v.DoExpression = N("doExpression"), ldt = v.ExportDefaultSpecifier = N("exportDefaultSpecifier"), cdt = v.RecordExpression =
  N("recordExpression"), fdt = v.TupleExpression = N("tupleExpression"), ddt = v.DecimalLiteral = N("decimalLiteral"), pdt = v.ModuleExpression =
  N("moduleExpression"), hdt = v.TopicReference = N("topicReference"), mdt = v.PipelineTopicExpression = N("pipelineTopicExpression"), ydt = v.
  PipelineBareFunction = N("pipelineBareFunction"), gdt = v.PipelinePrimaryTopicReference = N("pipelinePrimaryTopicReference"), bdt = v.VoidPattern =
  N("voidPattern"), Ddt = v.TSParameterProperty = N("tsParameterProperty"), vdt = v.TSDeclareFunction = N("tsDeclareFunction"), xdt = v.TSDeclareMethod =
  N("tsDeclareMethod"), Edt = v.TSQualifiedName = N("tsQualifiedName"), Sdt = v.TSCallSignatureDeclaration = N("tsCallSignatureDeclaration"),
  Tdt = v.TSConstructSignatureDeclaration = N("tsConstructSignatureDeclaration"), Cdt = v.TSPropertySignature = N("tsPropertySignature"), wdt = v.
  TSMethodSignature = N("tsMethodSignature"), Adt = v.TSIndexSignature = N("tsIndexSignature"), _dt = v.TSAnyKeyword = N("tsAnyKeyword"), Pdt = v.
  TSBooleanKeyword = N("tsBooleanKeyword"), Fdt = v.TSBigIntKeyword = N("tsBigIntKeyword"), Idt = v.TSIntrinsicKeyword = N("tsIntrinsicKeywo\
rd"), Odt = v.TSNeverKeyword = N("tsNeverKeyword"), kdt = v.TSNullKeyword = N("tsNullKeyword"), Bdt = v.TSNumberKeyword = N("tsNumberKeyword"),
  Ndt = v.TSObjectKeyword = N("tsObjectKeyword"), Mdt = v.TSStringKeyword = N("tsStringKeyword"), Rdt = v.TSSymbolKeyword = N("tsSymbolKeywo\
rd"), Ldt = v.TSUndefinedKeyword = N("tsUndefinedKeyword"), jdt = v.TSUnknownKeyword = N("tsUnknownKeyword"), qdt = v.TSVoidKeyword = N("tsV\
oidKeyword"), Udt = v.TSThisType = N("tsThisType"), $dt = v.TSFunctionType = N("tsFunctionType"), Vdt = v.TSConstructorType = N("tsConstruct\
orType"), Wdt = v.TSTypeReference = N("tsTypeReference"), Hdt = v.TSTypePredicate = N("tsTypePredicate"), Kdt = v.TSTypeQuery = N("tsTypeQue\
ry"), zdt = v.TSTypeLiteral = N("tsTypeLiteral"), Jdt = v.TSArrayType = N("tsArrayType"), Xdt = v.TSTupleType = N("tsTupleType"), Ydt = v.TSOptionalType =
  N("tsOptionalType"), Gdt = v.TSRestType = N("tsRestType"), Zdt = v.TSNamedTupleMember = N("tsNamedTupleMember"), Qdt = v.TSUnionType = N("\
tsUnionType"), ept = v.TSIntersectionType = N("tsIntersectionType"), tpt = v.TSConditionalType = N("tsConditionalType"), rpt = v.TSInferType =
  N("tsInferType"), ipt = v.TSParenthesizedType = N("tsParenthesizedType"), spt = v.TSTypeOperator = N("tsTypeOperator"), npt = v.TSIndexedAccessType =
  N("tsIndexedAccessType"), apt = v.TSMappedType = N("tsMappedType"), opt = v.TSTemplateLiteralType = N("tsTemplateLiteralType"), upt = v.TSLiteralType =
  N("tsLiteralType"), lpt = v.TSExpressionWithTypeArguments = N("tsExpressionWithTypeArguments"), cpt = v.TSInterfaceDeclaration = N("tsInte\
rfaceDeclaration"), fpt = v.TSInterfaceBody = N("tsInterfaceBody"), dpt = v.TSTypeAliasDeclaration = N("tsTypeAliasDeclaration"), ppt = v.TSInstantiationExpression =
  N("tsInstantiationExpression"), hpt = v.TSAsExpression = N("tsAsExpression"), mpt = v.TSSatisfiesExpression = N("tsSatisfiesExpression"), ypt = v.
  TSTypeAssertion = N("tsTypeAssertion"), gpt = v.TSEnumBody = N("tsEnumBody"), bpt = v.TSEnumDeclaration = N("tsEnumDeclaration"), Dpt = v.
  TSEnumMember = N("tsEnumMember"), vpt = v.TSModuleDeclaration = N("tsModuleDeclaration"), xpt = v.TSModuleBlock = N("tsModuleBlock"), Ept = v.
  TSImportType = N("tsImportType"), Spt = v.TSImportEqualsDeclaration = N("tsImportEqualsDeclaration"), Tpt = v.TSExternalModuleReference = N(
  "tsExternalModuleReference"), Cpt = v.TSNonNullExpression = N("tsNonNullExpression"), wpt = v.TSExportAssignment = N("tsExportAssignment"),
  Apt = v.TSNamespaceExportDeclaration = N("tsNamespaceExportDeclaration"), _pt = v.TSTypeAnnotation = N("tsTypeAnnotation"), Ppt = v.TSTypeParameterInstantiation =
  N("tsTypeParameterInstantiation"), Fpt = v.TSTypeParameterDeclaration = N("tsTypeParameterDeclaration"), Ipt = v.TSTypeParameter = N("tsTy\
peParameter"), Opt = v.NumberLiteral = wd.numberLiteral, kpt = v.RegexLiteral = wd.regexLiteral, Bpt = v.RestProperty = wd.restProperty, Npt = v.
  SpreadProperty = wd.spreadProperty;
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var hi = E((Fa) => {
  "use strict";
  Object.defineProperty(Fa, "__esModule", {
    value: !0
  });
  var ME = NE();
  Object.keys(ME).forEach(function(e) {
    e === "default" || e === "__esModule" || e in Fa && Fa[e] === ME[e] || Object.defineProperty(Fa, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return ME[e];
      }, "get")
    });
  });
  var RE = MM();
  Object.keys(RE).forEach(function(e) {
    e === "default" || e === "__esModule" || e in Fa && Fa[e] === RE[e] || Object.defineProperty(Fa, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return RE[e];
      }, "get")
    });
  });
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var RM = E((LE) => {
  "use strict";
  Object.defineProperty(LE, "__esModule", {
    value: !0
  });
  LE.default = zve;
  var Hve = hi(), Kve = Pe();
  function zve(e, t) {
    let r = e.value.split(/\r\n|\n|\r/), i = 0;
    for (let a = 0; a < r.length; a++)
      /[^ \t]/.exec(r[a]) && (i = a);
    let s = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], u = a === 0, l = a === r.length - 1, c = a === i, f = o.replace(/\t/g, " ");
      u || (f = f.replace(/^ +/, "")), l || (f = f.replace(/ +$/, "")), f && (c || (f += " "), s += f);
    }
    s && t.push((0, Kve.inherits)((0, Hve.stringLiteral)(s), e));
  }
  n(zve, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var LM = E((qE) => {
  "use strict";
  Object.defineProperty(qE, "__esModule", {
    value: !0
  });
  qE.default = Xve;
  var jE = Jt(), Jve = RM();
  function Xve(e) {
    let t = [];
    for (let r = 0; r < e.children.length; r++) {
      let i = e.children[r];
      if ((0, jE.isJSXText)(i)) {
        (0, Jve.default)(i, t);
        continue;
      }
      (0, jE.isJSXExpressionContainer)(i) && (i = i.expression), !(0, jE.isJSXEmptyExpression)(i) && t.push(i);
    }
    return t;
  }
  n(Xve, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var $E = E((UE) => {
  "use strict";
  Object.defineProperty(UE, "__esModule", {
    value: !0
  });
  UE.default = Gve;
  var Yve = Vi();
  function Gve(e) {
    return !!(e && Yve.VISITOR_KEYS[e.type]);
  }
  n(Gve, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var jM = E((VE) => {
  "use strict";
  Object.defineProperty(VE, "__esModule", {
    value: !0
  });
  VE.default = Qve;
  var Zve = $E();
  function Qve(e) {
    if (!(0, Zve.default)(e)) {
      var t;
      let r = (t = e?.type) != null ? t : JSON.stringify(e);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  n(Qve, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var qM = E((_) => {
  "use strict";
  Object.defineProperty(_, "__esModule", {
    value: !0
  });
  _.assertAccessor = Dwe;
  _.assertAnyTypeAnnotation = MEe;
  _.assertArgumentPlaceholder = fTe;
  _.assertArrayExpression = txe;
  _.assertArrayPattern = Qxe;
  _.assertArrayTypeAnnotation = REe;
  _.assertArrowFunctionExpression = eEe;
  _.assertAssignmentExpression = rxe;
  _.assertAssignmentPattern = Zxe;
  _.assertAwaitExpression = SEe;
  _.assertBigIntLiteral = CEe;
  _.assertBinary = qCe;
  _.assertBinaryExpression = ixe;
  _.assertBindExpression = dTe;
  _.assertBlock = VCe;
  _.assertBlockParent = $Ce;
  _.assertBlockStatement = oxe;
  _.assertBooleanLiteral = _xe;
  _.assertBooleanLiteralTypeAnnotation = jEe;
  _.assertBooleanTypeAnnotation = LEe;
  _.assertBreakStatement = uxe;
  _.assertCallExpression = lxe;
  _.assertCatchClause = cxe;
  _.assertClass = mwe;
  _.assertClassAccessorProperty = FEe;
  _.assertClassBody = tEe;
  _.assertClassDeclaration = iEe;
  _.assertClassExpression = rEe;
  _.assertClassImplements = UEe;
  _.assertClassMethod = mEe;
  _.assertClassPrivateMethod = OEe;
  _.assertClassPrivateProperty = IEe;
  _.assertClassProperty = PEe;
  _.assertCompletionStatement = KCe;
  _.assertConditional = zCe;
  _.assertConditionalExpression = fxe;
  _.assertContinueStatement = dxe;
  _.assertDebuggerStatement = pxe;
  _.assertDecimalLiteral = bTe;
  _.assertDeclaration = rwe;
  _.assertDeclareClass = $Ee;
  _.assertDeclareExportAllDeclaration = GEe;
  _.assertDeclareExportDeclaration = YEe;
  _.assertDeclareFunction = VEe;
  _.assertDeclareInterface = WEe;
  _.assertDeclareModule = HEe;
  _.assertDeclareModuleExports = KEe;
  _.assertDeclareOpaqueType = JEe;
  _.assertDeclareTypeAlias = zEe;
  _.assertDeclareVariable = XEe;
  _.assertDeclaredPredicate = ZEe;
  _.assertDecorator = pTe;
  _.assertDirective = nxe;
  _.assertDirectiveLiteral = axe;
  _.assertDoExpression = hTe;
  _.assertDoWhileStatement = hxe;
  _.assertEmptyStatement = mxe;
  _.assertEmptyTypeAnnotation = lSe;
  _.assertEnumBody = wwe;
  _.assertEnumBooleanBody = RSe;
  _.assertEnumBooleanMember = USe;
  _.assertEnumDeclaration = MSe;
  _.assertEnumDefaultedMember = WSe;
  _.assertEnumMember = Awe;
  _.assertEnumNumberBody = LSe;
  _.assertEnumNumberMember = $Se;
  _.assertEnumStringBody = jSe;
  _.assertEnumStringMember = VSe;
  _.assertEnumSymbolBody = qSe;
  _.assertExistsTypeAnnotation = QEe;
  _.assertExportAllDeclaration = sEe;
  _.assertExportDeclaration = gwe;
  _.assertExportDefaultDeclaration = nEe;
  _.assertExportDefaultSpecifier = mTe;
  _.assertExportNamedDeclaration = aEe;
  _.assertExportNamespaceSpecifier = wEe;
  _.assertExportSpecifier = oEe;
  _.assertExpression = jCe;
  _.assertExpressionStatement = yxe;
  _.assertExpressionWrapper = YCe;
  _.assertFile = gxe;
  _.assertFlow = xwe;
  _.assertFlowBaseAnnotation = Swe;
  _.assertFlowDeclaration = Twe;
  _.assertFlowPredicate = Cwe;
  _.assertFlowType = Ewe;
  _.assertFor = GCe;
  _.assertForInStatement = bxe;
  _.assertForOfStatement = uEe;
  _.assertForStatement = Dxe;
  _.assertForXStatement = ZCe;
  _.assertFunction = QCe;
  _.assertFunctionDeclaration = vxe;
  _.assertFunctionExpression = xxe;
  _.assertFunctionParameter = iwe;
  _.assertFunctionParent = ewe;
  _.assertFunctionTypeAnnotation = eSe;
  _.assertFunctionTypeParam = tSe;
  _.assertGenericTypeAnnotation = rSe;
  _.assertIdentifier = Exe;
  _.assertIfStatement = Sxe;
  _.assertImmutable = uwe;
  _.assertImport = TEe;
  _.assertImportAttribute = NEe;
  _.assertImportDeclaration = lEe;
  _.assertImportDefaultSpecifier = cEe;
  _.assertImportExpression = pEe;
  _.assertImportNamespaceSpecifier = fEe;
  _.assertImportOrExportDeclaration = ywe;
  _.assertImportSpecifier = dEe;
  _.assertIndexedAccessType = HSe;
  _.assertInferredPredicate = iSe;
  _.assertInterfaceDeclaration = nSe;
  _.assertInterfaceExtends = sSe;
  _.assertInterfaceTypeAnnotation = aSe;
  _.assertInterpreterDirective = sxe;
  _.assertIntersectionTypeAnnotation = oSe;
  _.assertJSX = _we;
  _.assertJSXAttribute = zSe;
  _.assertJSXClosingElement = JSe;
  _.assertJSXClosingFragment = oTe;
  _.assertJSXElement = XSe;
  _.assertJSXEmptyExpression = YSe;
  _.assertJSXExpressionContainer = GSe;
  _.assertJSXFragment = nTe;
  _.assertJSXIdentifier = QSe;
  _.assertJSXMemberExpression = eTe;
  _.assertJSXNamespacedName = tTe;
  _.assertJSXOpeningElement = rTe;
  _.assertJSXOpeningFragment = aTe;
  _.assertJSXSpreadAttribute = iTe;
  _.assertJSXSpreadChild = ZSe;
  _.assertJSXText = sTe;
  _.assertLVal = nwe;
  _.assertLabeledStatement = Txe;
  _.assertLiteral = owe;
  _.assertLogicalExpression = Fxe;
  _.assertLoop = JCe;
  _.assertMemberExpression = Ixe;
  _.assertMetaProperty = hEe;
  _.assertMethod = cwe;
  _.assertMiscellaneous = Pwe;
  _.assertMixedTypeAnnotation = uSe;
  _.assertModuleDeclaration = Lwe;
  _.assertModuleExpression = DTe;
  _.assertModuleSpecifier = bwe;
  _.assertNewExpression = Oxe;
  _.assertNoop = uTe;
  _.assertNullLiteral = Axe;
  _.assertNullLiteralTypeAnnotation = qEe;
  _.assertNullableTypeAnnotation = cSe;
  _.assertNumberLiteral = Bwe;
  _.assertNumberLiteralTypeAnnotation = fSe;
  _.assertNumberTypeAnnotation = dSe;
  _.assertNumericLiteral = wxe;
  _.assertObjectExpression = Bxe;
  _.assertObjectMember = fwe;
  _.assertObjectMethod = Nxe;
  _.assertObjectPattern = yEe;
  _.assertObjectProperty = Mxe;
  _.assertObjectTypeAnnotation = pSe;
  _.assertObjectTypeCallProperty = mSe;
  _.assertObjectTypeIndexer = ySe;
  _.assertObjectTypeInternalSlot = hSe;
  _.assertObjectTypeProperty = gSe;
  _.assertObjectTypeSpreadProperty = bSe;
  _.assertOpaqueType = DSe;
  _.assertOptionalCallExpression = _Ee;
  _.assertOptionalIndexedAccessType = KSe;
  _.assertOptionalMemberExpression = AEe;
  _.assertParenthesizedExpression = qxe;
  _.assertPattern = hwe;
  _.assertPatternLike = swe;
  _.assertPipelineBareFunction = ETe;
  _.assertPipelinePrimaryTopicReference = STe;
  _.assertPipelineTopicExpression = xTe;
  _.assertPlaceholder = lTe;
  _.assertPrivate = vwe;
  _.assertPrivateName = kEe;
  _.assertProgram = kxe;
  _.assertProperty = dwe;
  _.assertPureish = twe;
  _.assertQualifiedTypeIdentifier = vSe;
  _.assertRecordExpression = yTe;
  _.assertRegExpLiteral = Pxe;
  _.assertRegexLiteral = Nwe;
  _.assertRestElement = Rxe;
  _.assertRestProperty = Mwe;
  _.assertReturnStatement = Lxe;
  _.assertScopable = UCe;
  _.assertSequenceExpression = jxe;
  _.assertSpreadElement = gEe;
  _.assertSpreadProperty = Rwe;
  _.assertStandardized = LCe;
  _.assertStatement = WCe;
  _.assertStaticBlock = BEe;
  _.assertStringLiteral = Cxe;
  _.assertStringLiteralTypeAnnotation = xSe;
  _.assertStringTypeAnnotation = ESe;
  _.assertSuper = bEe;
  _.assertSwitchCase = Uxe;
  _.assertSwitchStatement = $xe;
  _.assertSymbolTypeAnnotation = SSe;
  _.assertTSAnyKeyword = BTe;
  _.assertTSArrayType = eCe;
  _.assertTSAsExpression = vCe;
  _.assertTSBaseType = kwe;
  _.assertTSBigIntKeyword = MTe;
  _.assertTSBooleanKeyword = NTe;
  _.assertTSCallSignatureDeclaration = PTe;
  _.assertTSConditionalType = oCe;
  _.assertTSConstructSignatureDeclaration = FTe;
  _.assertTSConstructorType = XTe;
  _.assertTSDeclareFunction = wTe;
  _.assertTSDeclareMethod = ATe;
  _.assertTSEntityName = awe;
  _.assertTSEnumBody = SCe;
  _.assertTSEnumDeclaration = TCe;
  _.assertTSEnumMember = CCe;
  _.assertTSExportAssignment = OCe;
  _.assertTSExpressionWithTypeArguments = mCe;
  _.assertTSExternalModuleReference = FCe;
  _.assertTSFunctionType = JTe;
  _.assertTSImportEqualsDeclaration = PCe;
  _.assertTSImportType = _Ce;
  _.assertTSIndexSignature = kTe;
  _.assertTSIndexedAccessType = fCe;
  _.assertTSInferType = uCe;
  _.assertTSInstantiationExpression = DCe;
  _.assertTSInterfaceBody = gCe;
  _.assertTSInterfaceDeclaration = yCe;
  _.assertTSIntersectionType = aCe;
  _.assertTSIntrinsicKeyword = RTe;
  _.assertTSLiteralType = hCe;
  _.assertTSMappedType = dCe;
  _.assertTSMethodSignature = OTe;
  _.assertTSModuleBlock = ACe;
  _.assertTSModuleDeclaration = wCe;
  _.assertTSNamedTupleMember = sCe;
  _.assertTSNamespaceExportDeclaration = kCe;
  _.assertTSNeverKeyword = LTe;
  _.assertTSNonNullExpression = ICe;
  _.assertTSNullKeyword = jTe;
  _.assertTSNumberKeyword = qTe;
  _.assertTSObjectKeyword = UTe;
  _.assertTSOptionalType = rCe;
  _.assertTSParameterProperty = CTe;
  _.assertTSParenthesizedType = lCe;
  _.assertTSPropertySignature = ITe;
  _.assertTSQualifiedName = _Te;
  _.assertTSRestType = iCe;
  _.assertTSSatisfiesExpression = xCe;
  _.assertTSStringKeyword = $Te;
  _.assertTSSymbolKeyword = VTe;
  _.assertTSTemplateLiteralType = pCe;
  _.assertTSThisType = zTe;
  _.assertTSTupleType = tCe;
  _.assertTSType = Owe;
  _.assertTSTypeAliasDeclaration = bCe;
  _.assertTSTypeAnnotation = BCe;
  _.assertTSTypeAssertion = ECe;
  _.assertTSTypeElement = Iwe;
  _.assertTSTypeLiteral = QTe;
  _.assertTSTypeOperator = cCe;
  _.assertTSTypeParameter = RCe;
  _.assertTSTypeParameterDeclaration = MCe;
  _.assertTSTypeParameterInstantiation = NCe;
  _.assertTSTypePredicate = GTe;
  _.assertTSTypeQuery = ZTe;
  _.assertTSTypeReference = YTe;
  _.assertTSUndefinedKeyword = WTe;
  _.assertTSUnionType = nCe;
  _.assertTSUnknownKeyword = HTe;
  _.assertTSVoidKeyword = KTe;
  _.assertTaggedTemplateExpression = DEe;
  _.assertTemplateElement = vEe;
  _.assertTemplateLiteral = xEe;
  _.assertTerminatorless = HCe;
  _.assertThisExpression = Vxe;
  _.assertThisTypeAnnotation = TSe;
  _.assertThrowStatement = Wxe;
  _.assertTopicReference = vTe;
  _.assertTryStatement = Hxe;
  _.assertTupleExpression = gTe;
  _.assertTupleTypeAnnotation = CSe;
  _.assertTypeAlias = ASe;
  _.assertTypeAnnotation = _Se;
  _.assertTypeCastExpression = PSe;
  _.assertTypeParameter = FSe;
  _.assertTypeParameterDeclaration = ISe;
  _.assertTypeParameterInstantiation = OSe;
  _.assertTypeScript = Fwe;
  _.assertTypeofTypeAnnotation = wSe;
  _.assertUnaryExpression = Kxe;
  _.assertUnaryLike = pwe;
  _.assertUnionTypeAnnotation = kSe;
  _.assertUpdateExpression = zxe;
  _.assertUserWhitespacable = lwe;
  _.assertV8IntrinsicIdentifier = cTe;
  _.assertVariableDeclaration = Jxe;
  _.assertVariableDeclarator = Xxe;
  _.assertVariance = BSe;
  _.assertVoidPattern = TTe;
  _.assertVoidTypeAnnotation = NSe;
  _.assertWhile = XCe;
  _.assertWhileStatement = Yxe;
  _.assertWithStatement = Gxe;
  _.assertYieldExpression = EEe;
  var exe = Il(), Ad = Fl();
  function P(e, t, r) {
    if (!(0, exe.default)(e, t, r))
      throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
  }
  n(P, "assert");
  function txe(e, t) {
    P("ArrayExpression", e, t);
  }
  n(txe, "assertArrayExpression");
  function rxe(e, t) {
    P("AssignmentExpression", e, t);
  }
  n(rxe, "assertAssignmentExpression");
  function ixe(e, t) {
    P("BinaryExpression", e, t);
  }
  n(ixe, "assertBinaryExpression");
  function sxe(e, t) {
    P("InterpreterDirective", e, t);
  }
  n(sxe, "assertInterpreterDirective");
  function nxe(e, t) {
    P("Directive", e, t);
  }
  n(nxe, "assertDirective");
  function axe(e, t) {
    P("DirectiveLiteral", e, t);
  }
  n(axe, "assertDirectiveLiteral");
  function oxe(e, t) {
    P("BlockStatement", e, t);
  }
  n(oxe, "assertBlockStatement");
  function uxe(e, t) {
    P("BreakStatement", e, t);
  }
  n(uxe, "assertBreakStatement");
  function lxe(e, t) {
    P("CallExpression", e, t);
  }
  n(lxe, "assertCallExpression");
  function cxe(e, t) {
    P("CatchClause", e, t);
  }
  n(cxe, "assertCatchClause");
  function fxe(e, t) {
    P("ConditionalExpression", e, t);
  }
  n(fxe, "assertConditionalExpression");
  function dxe(e, t) {
    P("ContinueStatement", e, t);
  }
  n(dxe, "assertContinueStatement");
  function pxe(e, t) {
    P("DebuggerStatement", e, t);
  }
  n(pxe, "assertDebuggerStatement");
  function hxe(e, t) {
    P("DoWhileStatement", e, t);
  }
  n(hxe, "assertDoWhileStatement");
  function mxe(e, t) {
    P("EmptyStatement", e, t);
  }
  n(mxe, "assertEmptyStatement");
  function yxe(e, t) {
    P("ExpressionStatement", e, t);
  }
  n(yxe, "assertExpressionStatement");
  function gxe(e, t) {
    P("File", e, t);
  }
  n(gxe, "assertFile");
  function bxe(e, t) {
    P("ForInStatement", e, t);
  }
  n(bxe, "assertForInStatement");
  function Dxe(e, t) {
    P("ForStatement", e, t);
  }
  n(Dxe, "assertForStatement");
  function vxe(e, t) {
    P("FunctionDeclaration", e, t);
  }
  n(vxe, "assertFunctionDeclaration");
  function xxe(e, t) {
    P("FunctionExpression", e, t);
  }
  n(xxe, "assertFunctionExpression");
  function Exe(e, t) {
    P("Identifier", e, t);
  }
  n(Exe, "assertIdentifier");
  function Sxe(e, t) {
    P("IfStatement", e, t);
  }
  n(Sxe, "assertIfStatement");
  function Txe(e, t) {
    P("LabeledStatement", e, t);
  }
  n(Txe, "assertLabeledStatement");
  function Cxe(e, t) {
    P("StringLiteral", e, t);
  }
  n(Cxe, "assertStringLiteral");
  function wxe(e, t) {
    P("NumericLiteral", e, t);
  }
  n(wxe, "assertNumericLiteral");
  function Axe(e, t) {
    P("NullLiteral", e, t);
  }
  n(Axe, "assertNullLiteral");
  function _xe(e, t) {
    P("BooleanLiteral", e, t);
  }
  n(_xe, "assertBooleanLiteral");
  function Pxe(e, t) {
    P("RegExpLiteral", e, t);
  }
  n(Pxe, "assertRegExpLiteral");
  function Fxe(e, t) {
    P("LogicalExpression", e, t);
  }
  n(Fxe, "assertLogicalExpression");
  function Ixe(e, t) {
    P("MemberExpression", e, t);
  }
  n(Ixe, "assertMemberExpression");
  function Oxe(e, t) {
    P("NewExpression", e, t);
  }
  n(Oxe, "assertNewExpression");
  function kxe(e, t) {
    P("Program", e, t);
  }
  n(kxe, "assertProgram");
  function Bxe(e, t) {
    P("ObjectExpression", e, t);
  }
  n(Bxe, "assertObjectExpression");
  function Nxe(e, t) {
    P("ObjectMethod", e, t);
  }
  n(Nxe, "assertObjectMethod");
  function Mxe(e, t) {
    P("ObjectProperty", e, t);
  }
  n(Mxe, "assertObjectProperty");
  function Rxe(e, t) {
    P("RestElement", e, t);
  }
  n(Rxe, "assertRestElement");
  function Lxe(e, t) {
    P("ReturnStatement", e, t);
  }
  n(Lxe, "assertReturnStatement");
  function jxe(e, t) {
    P("SequenceExpression", e, t);
  }
  n(jxe, "assertSequenceExpression");
  function qxe(e, t) {
    P("ParenthesizedExpression", e, t);
  }
  n(qxe, "assertParenthesizedExpression");
  function Uxe(e, t) {
    P("SwitchCase", e, t);
  }
  n(Uxe, "assertSwitchCase");
  function $xe(e, t) {
    P("SwitchStatement", e, t);
  }
  n($xe, "assertSwitchStatement");
  function Vxe(e, t) {
    P("ThisExpression", e, t);
  }
  n(Vxe, "assertThisExpression");
  function Wxe(e, t) {
    P("ThrowStatement", e, t);
  }
  n(Wxe, "assertThrowStatement");
  function Hxe(e, t) {
    P("TryStatement", e, t);
  }
  n(Hxe, "assertTryStatement");
  function Kxe(e, t) {
    P("UnaryExpression", e, t);
  }
  n(Kxe, "assertUnaryExpression");
  function zxe(e, t) {
    P("UpdateExpression", e, t);
  }
  n(zxe, "assertUpdateExpression");
  function Jxe(e, t) {
    P("VariableDeclaration", e, t);
  }
  n(Jxe, "assertVariableDeclaration");
  function Xxe(e, t) {
    P("VariableDeclarator", e, t);
  }
  n(Xxe, "assertVariableDeclarator");
  function Yxe(e, t) {
    P("WhileStatement", e, t);
  }
  n(Yxe, "assertWhileStatement");
  function Gxe(e, t) {
    P("WithStatement", e, t);
  }
  n(Gxe, "assertWithStatement");
  function Zxe(e, t) {
    P("AssignmentPattern", e, t);
  }
  n(Zxe, "assertAssignmentPattern");
  function Qxe(e, t) {
    P("ArrayPattern", e, t);
  }
  n(Qxe, "assertArrayPattern");
  function eEe(e, t) {
    P("ArrowFunctionExpression", e, t);
  }
  n(eEe, "assertArrowFunctionExpression");
  function tEe(e, t) {
    P("ClassBody", e, t);
  }
  n(tEe, "assertClassBody");
  function rEe(e, t) {
    P("ClassExpression", e, t);
  }
  n(rEe, "assertClassExpression");
  function iEe(e, t) {
    P("ClassDeclaration", e, t);
  }
  n(iEe, "assertClassDeclaration");
  function sEe(e, t) {
    P("ExportAllDeclaration", e, t);
  }
  n(sEe, "assertExportAllDeclaration");
  function nEe(e, t) {
    P("ExportDefaultDeclaration", e, t);
  }
  n(nEe, "assertExportDefaultDeclaration");
  function aEe(e, t) {
    P("ExportNamedDeclaration", e, t);
  }
  n(aEe, "assertExportNamedDeclaration");
  function oEe(e, t) {
    P("ExportSpecifier", e, t);
  }
  n(oEe, "assertExportSpecifier");
  function uEe(e, t) {
    P("ForOfStatement", e, t);
  }
  n(uEe, "assertForOfStatement");
  function lEe(e, t) {
    P("ImportDeclaration", e, t);
  }
  n(lEe, "assertImportDeclaration");
  function cEe(e, t) {
    P("ImportDefaultSpecifier", e, t);
  }
  n(cEe, "assertImportDefaultSpecifier");
  function fEe(e, t) {
    P("ImportNamespaceSpecifier", e, t);
  }
  n(fEe, "assertImportNamespaceSpecifier");
  function dEe(e, t) {
    P("ImportSpecifier", e, t);
  }
  n(dEe, "assertImportSpecifier");
  function pEe(e, t) {
    P("ImportExpression", e, t);
  }
  n(pEe, "assertImportExpression");
  function hEe(e, t) {
    P("MetaProperty", e, t);
  }
  n(hEe, "assertMetaProperty");
  function mEe(e, t) {
    P("ClassMethod", e, t);
  }
  n(mEe, "assertClassMethod");
  function yEe(e, t) {
    P("ObjectPattern", e, t);
  }
  n(yEe, "assertObjectPattern");
  function gEe(e, t) {
    P("SpreadElement", e, t);
  }
  n(gEe, "assertSpreadElement");
  function bEe(e, t) {
    P("Super", e, t);
  }
  n(bEe, "assertSuper");
  function DEe(e, t) {
    P("TaggedTemplateExpression", e, t);
  }
  n(DEe, "assertTaggedTemplateExpression");
  function vEe(e, t) {
    P("TemplateElement", e, t);
  }
  n(vEe, "assertTemplateElement");
  function xEe(e, t) {
    P("TemplateLiteral", e, t);
  }
  n(xEe, "assertTemplateLiteral");
  function EEe(e, t) {
    P("YieldExpression", e, t);
  }
  n(EEe, "assertYieldExpression");
  function SEe(e, t) {
    P("AwaitExpression", e, t);
  }
  n(SEe, "assertAwaitExpression");
  function TEe(e, t) {
    P("Import", e, t);
  }
  n(TEe, "assertImport");
  function CEe(e, t) {
    P("BigIntLiteral", e, t);
  }
  n(CEe, "assertBigIntLiteral");
  function wEe(e, t) {
    P("ExportNamespaceSpecifier", e, t);
  }
  n(wEe, "assertExportNamespaceSpecifier");
  function AEe(e, t) {
    P("OptionalMemberExpression", e, t);
  }
  n(AEe, "assertOptionalMemberExpression");
  function _Ee(e, t) {
    P("OptionalCallExpression", e, t);
  }
  n(_Ee, "assertOptionalCallExpression");
  function PEe(e, t) {
    P("ClassProperty", e, t);
  }
  n(PEe, "assertClassProperty");
  function FEe(e, t) {
    P("ClassAccessorProperty", e, t);
  }
  n(FEe, "assertClassAccessorProperty");
  function IEe(e, t) {
    P("ClassPrivateProperty", e, t);
  }
  n(IEe, "assertClassPrivateProperty");
  function OEe(e, t) {
    P("ClassPrivateMethod", e, t);
  }
  n(OEe, "assertClassPrivateMethod");
  function kEe(e, t) {
    P("PrivateName", e, t);
  }
  n(kEe, "assertPrivateName");
  function BEe(e, t) {
    P("StaticBlock", e, t);
  }
  n(BEe, "assertStaticBlock");
  function NEe(e, t) {
    P("ImportAttribute", e, t);
  }
  n(NEe, "assertImportAttribute");
  function MEe(e, t) {
    P("AnyTypeAnnotation", e, t);
  }
  n(MEe, "assertAnyTypeAnnotation");
  function REe(e, t) {
    P("ArrayTypeAnnotation", e, t);
  }
  n(REe, "assertArrayTypeAnnotation");
  function LEe(e, t) {
    P("BooleanTypeAnnotation", e, t);
  }
  n(LEe, "assertBooleanTypeAnnotation");
  function jEe(e, t) {
    P("BooleanLiteralTypeAnnotation", e, t);
  }
  n(jEe, "assertBooleanLiteralTypeAnnotation");
  function qEe(e, t) {
    P("NullLiteralTypeAnnotation", e, t);
  }
  n(qEe, "assertNullLiteralTypeAnnotation");
  function UEe(e, t) {
    P("ClassImplements", e, t);
  }
  n(UEe, "assertClassImplements");
  function $Ee(e, t) {
    P("DeclareClass", e, t);
  }
  n($Ee, "assertDeclareClass");
  function VEe(e, t) {
    P("DeclareFunction", e, t);
  }
  n(VEe, "assertDeclareFunction");
  function WEe(e, t) {
    P("DeclareInterface", e, t);
  }
  n(WEe, "assertDeclareInterface");
  function HEe(e, t) {
    P("DeclareModule", e, t);
  }
  n(HEe, "assertDeclareModule");
  function KEe(e, t) {
    P("DeclareModuleExports", e, t);
  }
  n(KEe, "assertDeclareModuleExports");
  function zEe(e, t) {
    P("DeclareTypeAlias", e, t);
  }
  n(zEe, "assertDeclareTypeAlias");
  function JEe(e, t) {
    P("DeclareOpaqueType", e, t);
  }
  n(JEe, "assertDeclareOpaqueType");
  function XEe(e, t) {
    P("DeclareVariable", e, t);
  }
  n(XEe, "assertDeclareVariable");
  function YEe(e, t) {
    P("DeclareExportDeclaration", e, t);
  }
  n(YEe, "assertDeclareExportDeclaration");
  function GEe(e, t) {
    P("DeclareExportAllDeclaration", e, t);
  }
  n(GEe, "assertDeclareExportAllDeclaration");
  function ZEe(e, t) {
    P("DeclaredPredicate", e, t);
  }
  n(ZEe, "assertDeclaredPredicate");
  function QEe(e, t) {
    P("ExistsTypeAnnotation", e, t);
  }
  n(QEe, "assertExistsTypeAnnotation");
  function eSe(e, t) {
    P("FunctionTypeAnnotation", e, t);
  }
  n(eSe, "assertFunctionTypeAnnotation");
  function tSe(e, t) {
    P("FunctionTypeParam", e, t);
  }
  n(tSe, "assertFunctionTypeParam");
  function rSe(e, t) {
    P("GenericTypeAnnotation", e, t);
  }
  n(rSe, "assertGenericTypeAnnotation");
  function iSe(e, t) {
    P("InferredPredicate", e, t);
  }
  n(iSe, "assertInferredPredicate");
  function sSe(e, t) {
    P("InterfaceExtends", e, t);
  }
  n(sSe, "assertInterfaceExtends");
  function nSe(e, t) {
    P("InterfaceDeclaration", e, t);
  }
  n(nSe, "assertInterfaceDeclaration");
  function aSe(e, t) {
    P("InterfaceTypeAnnotation", e, t);
  }
  n(aSe, "assertInterfaceTypeAnnotation");
  function oSe(e, t) {
    P("IntersectionTypeAnnotation", e, t);
  }
  n(oSe, "assertIntersectionTypeAnnotation");
  function uSe(e, t) {
    P("MixedTypeAnnotation", e, t);
  }
  n(uSe, "assertMixedTypeAnnotation");
  function lSe(e, t) {
    P("EmptyTypeAnnotation", e, t);
  }
  n(lSe, "assertEmptyTypeAnnotation");
  function cSe(e, t) {
    P("NullableTypeAnnotation", e, t);
  }
  n(cSe, "assertNullableTypeAnnotation");
  function fSe(e, t) {
    P("NumberLiteralTypeAnnotation", e, t);
  }
  n(fSe, "assertNumberLiteralTypeAnnotation");
  function dSe(e, t) {
    P("NumberTypeAnnotation", e, t);
  }
  n(dSe, "assertNumberTypeAnnotation");
  function pSe(e, t) {
    P("ObjectTypeAnnotation", e, t);
  }
  n(pSe, "assertObjectTypeAnnotation");
  function hSe(e, t) {
    P("ObjectTypeInternalSlot", e, t);
  }
  n(hSe, "assertObjectTypeInternalSlot");
  function mSe(e, t) {
    P("ObjectTypeCallProperty", e, t);
  }
  n(mSe, "assertObjectTypeCallProperty");
  function ySe(e, t) {
    P("ObjectTypeIndexer", e, t);
  }
  n(ySe, "assertObjectTypeIndexer");
  function gSe(e, t) {
    P("ObjectTypeProperty", e, t);
  }
  n(gSe, "assertObjectTypeProperty");
  function bSe(e, t) {
    P("ObjectTypeSpreadProperty", e, t);
  }
  n(bSe, "assertObjectTypeSpreadProperty");
  function DSe(e, t) {
    P("OpaqueType", e, t);
  }
  n(DSe, "assertOpaqueType");
  function vSe(e, t) {
    P("QualifiedTypeIdentifier", e, t);
  }
  n(vSe, "assertQualifiedTypeIdentifier");
  function xSe(e, t) {
    P("StringLiteralTypeAnnotation", e, t);
  }
  n(xSe, "assertStringLiteralTypeAnnotation");
  function ESe(e, t) {
    P("StringTypeAnnotation", e, t);
  }
  n(ESe, "assertStringTypeAnnotation");
  function SSe(e, t) {
    P("SymbolTypeAnnotation", e, t);
  }
  n(SSe, "assertSymbolTypeAnnotation");
  function TSe(e, t) {
    P("ThisTypeAnnotation", e, t);
  }
  n(TSe, "assertThisTypeAnnotation");
  function CSe(e, t) {
    P("TupleTypeAnnotation", e, t);
  }
  n(CSe, "assertTupleTypeAnnotation");
  function wSe(e, t) {
    P("TypeofTypeAnnotation", e, t);
  }
  n(wSe, "assertTypeofTypeAnnotation");
  function ASe(e, t) {
    P("TypeAlias", e, t);
  }
  n(ASe, "assertTypeAlias");
  function _Se(e, t) {
    P("TypeAnnotation", e, t);
  }
  n(_Se, "assertTypeAnnotation");
  function PSe(e, t) {
    P("TypeCastExpression", e, t);
  }
  n(PSe, "assertTypeCastExpression");
  function FSe(e, t) {
    P("TypeParameter", e, t);
  }
  n(FSe, "assertTypeParameter");
  function ISe(e, t) {
    P("TypeParameterDeclaration", e, t);
  }
  n(ISe, "assertTypeParameterDeclaration");
  function OSe(e, t) {
    P("TypeParameterInstantiation", e, t);
  }
  n(OSe, "assertTypeParameterInstantiation");
  function kSe(e, t) {
    P("UnionTypeAnnotation", e, t);
  }
  n(kSe, "assertUnionTypeAnnotation");
  function BSe(e, t) {
    P("Variance", e, t);
  }
  n(BSe, "assertVariance");
  function NSe(e, t) {
    P("VoidTypeAnnotation", e, t);
  }
  n(NSe, "assertVoidTypeAnnotation");
  function MSe(e, t) {
    P("EnumDeclaration", e, t);
  }
  n(MSe, "assertEnumDeclaration");
  function RSe(e, t) {
    P("EnumBooleanBody", e, t);
  }
  n(RSe, "assertEnumBooleanBody");
  function LSe(e, t) {
    P("EnumNumberBody", e, t);
  }
  n(LSe, "assertEnumNumberBody");
  function jSe(e, t) {
    P("EnumStringBody", e, t);
  }
  n(jSe, "assertEnumStringBody");
  function qSe(e, t) {
    P("EnumSymbolBody", e, t);
  }
  n(qSe, "assertEnumSymbolBody");
  function USe(e, t) {
    P("EnumBooleanMember", e, t);
  }
  n(USe, "assertEnumBooleanMember");
  function $Se(e, t) {
    P("EnumNumberMember", e, t);
  }
  n($Se, "assertEnumNumberMember");
  function VSe(e, t) {
    P("EnumStringMember", e, t);
  }
  n(VSe, "assertEnumStringMember");
  function WSe(e, t) {
    P("EnumDefaultedMember", e, t);
  }
  n(WSe, "assertEnumDefaultedMember");
  function HSe(e, t) {
    P("IndexedAccessType", e, t);
  }
  n(HSe, "assertIndexedAccessType");
  function KSe(e, t) {
    P("OptionalIndexedAccessType", e, t);
  }
  n(KSe, "assertOptionalIndexedAccessType");
  function zSe(e, t) {
    P("JSXAttribute", e, t);
  }
  n(zSe, "assertJSXAttribute");
  function JSe(e, t) {
    P("JSXClosingElement", e, t);
  }
  n(JSe, "assertJSXClosingElement");
  function XSe(e, t) {
    P("JSXElement", e, t);
  }
  n(XSe, "assertJSXElement");
  function YSe(e, t) {
    P("JSXEmptyExpression", e, t);
  }
  n(YSe, "assertJSXEmptyExpression");
  function GSe(e, t) {
    P("JSXExpressionContainer", e, t);
  }
  n(GSe, "assertJSXExpressionContainer");
  function ZSe(e, t) {
    P("JSXSpreadChild", e, t);
  }
  n(ZSe, "assertJSXSpreadChild");
  function QSe(e, t) {
    P("JSXIdentifier", e, t);
  }
  n(QSe, "assertJSXIdentifier");
  function eTe(e, t) {
    P("JSXMemberExpression", e, t);
  }
  n(eTe, "assertJSXMemberExpression");
  function tTe(e, t) {
    P("JSXNamespacedName", e, t);
  }
  n(tTe, "assertJSXNamespacedName");
  function rTe(e, t) {
    P("JSXOpeningElement", e, t);
  }
  n(rTe, "assertJSXOpeningElement");
  function iTe(e, t) {
    P("JSXSpreadAttribute", e, t);
  }
  n(iTe, "assertJSXSpreadAttribute");
  function sTe(e, t) {
    P("JSXText", e, t);
  }
  n(sTe, "assertJSXText");
  function nTe(e, t) {
    P("JSXFragment", e, t);
  }
  n(nTe, "assertJSXFragment");
  function aTe(e, t) {
    P("JSXOpeningFragment", e, t);
  }
  n(aTe, "assertJSXOpeningFragment");
  function oTe(e, t) {
    P("JSXClosingFragment", e, t);
  }
  n(oTe, "assertJSXClosingFragment");
  function uTe(e, t) {
    P("Noop", e, t);
  }
  n(uTe, "assertNoop");
  function lTe(e, t) {
    P("Placeholder", e, t);
  }
  n(lTe, "assertPlaceholder");
  function cTe(e, t) {
    P("V8IntrinsicIdentifier", e, t);
  }
  n(cTe, "assertV8IntrinsicIdentifier");
  function fTe(e, t) {
    P("ArgumentPlaceholder", e, t);
  }
  n(fTe, "assertArgumentPlaceholder");
  function dTe(e, t) {
    P("BindExpression", e, t);
  }
  n(dTe, "assertBindExpression");
  function pTe(e, t) {
    P("Decorator", e, t);
  }
  n(pTe, "assertDecorator");
  function hTe(e, t) {
    P("DoExpression", e, t);
  }
  n(hTe, "assertDoExpression");
  function mTe(e, t) {
    P("ExportDefaultSpecifier", e, t);
  }
  n(mTe, "assertExportDefaultSpecifier");
  function yTe(e, t) {
    P("RecordExpression", e, t);
  }
  n(yTe, "assertRecordExpression");
  function gTe(e, t) {
    P("TupleExpression", e, t);
  }
  n(gTe, "assertTupleExpression");
  function bTe(e, t) {
    P("DecimalLiteral", e, t);
  }
  n(bTe, "assertDecimalLiteral");
  function DTe(e, t) {
    P("ModuleExpression", e, t);
  }
  n(DTe, "assertModuleExpression");
  function vTe(e, t) {
    P("TopicReference", e, t);
  }
  n(vTe, "assertTopicReference");
  function xTe(e, t) {
    P("PipelineTopicExpression", e, t);
  }
  n(xTe, "assertPipelineTopicExpression");
  function ETe(e, t) {
    P("PipelineBareFunction", e, t);
  }
  n(ETe, "assertPipelineBareFunction");
  function STe(e, t) {
    P("PipelinePrimaryTopicReference", e, t);
  }
  n(STe, "assertPipelinePrimaryTopicReference");
  function TTe(e, t) {
    P("VoidPattern", e, t);
  }
  n(TTe, "assertVoidPattern");
  function CTe(e, t) {
    P("TSParameterProperty", e, t);
  }
  n(CTe, "assertTSParameterProperty");
  function wTe(e, t) {
    P("TSDeclareFunction", e, t);
  }
  n(wTe, "assertTSDeclareFunction");
  function ATe(e, t) {
    P("TSDeclareMethod", e, t);
  }
  n(ATe, "assertTSDeclareMethod");
  function _Te(e, t) {
    P("TSQualifiedName", e, t);
  }
  n(_Te, "assertTSQualifiedName");
  function PTe(e, t) {
    P("TSCallSignatureDeclaration", e, t);
  }
  n(PTe, "assertTSCallSignatureDeclaration");
  function FTe(e, t) {
    P("TSConstructSignatureDeclaration", e, t);
  }
  n(FTe, "assertTSConstructSignatureDeclaration");
  function ITe(e, t) {
    P("TSPropertySignature", e, t);
  }
  n(ITe, "assertTSPropertySignature");
  function OTe(e, t) {
    P("TSMethodSignature", e, t);
  }
  n(OTe, "assertTSMethodSignature");
  function kTe(e, t) {
    P("TSIndexSignature", e, t);
  }
  n(kTe, "assertTSIndexSignature");
  function BTe(e, t) {
    P("TSAnyKeyword", e, t);
  }
  n(BTe, "assertTSAnyKeyword");
  function NTe(e, t) {
    P("TSBooleanKeyword", e, t);
  }
  n(NTe, "assertTSBooleanKeyword");
  function MTe(e, t) {
    P("TSBigIntKeyword", e, t);
  }
  n(MTe, "assertTSBigIntKeyword");
  function RTe(e, t) {
    P("TSIntrinsicKeyword", e, t);
  }
  n(RTe, "assertTSIntrinsicKeyword");
  function LTe(e, t) {
    P("TSNeverKeyword", e, t);
  }
  n(LTe, "assertTSNeverKeyword");
  function jTe(e, t) {
    P("TSNullKeyword", e, t);
  }
  n(jTe, "assertTSNullKeyword");
  function qTe(e, t) {
    P("TSNumberKeyword", e, t);
  }
  n(qTe, "assertTSNumberKeyword");
  function UTe(e, t) {
    P("TSObjectKeyword", e, t);
  }
  n(UTe, "assertTSObjectKeyword");
  function $Te(e, t) {
    P("TSStringKeyword", e, t);
  }
  n($Te, "assertTSStringKeyword");
  function VTe(e, t) {
    P("TSSymbolKeyword", e, t);
  }
  n(VTe, "assertTSSymbolKeyword");
  function WTe(e, t) {
    P("TSUndefinedKeyword", e, t);
  }
  n(WTe, "assertTSUndefinedKeyword");
  function HTe(e, t) {
    P("TSUnknownKeyword", e, t);
  }
  n(HTe, "assertTSUnknownKeyword");
  function KTe(e, t) {
    P("TSVoidKeyword", e, t);
  }
  n(KTe, "assertTSVoidKeyword");
  function zTe(e, t) {
    P("TSThisType", e, t);
  }
  n(zTe, "assertTSThisType");
  function JTe(e, t) {
    P("TSFunctionType", e, t);
  }
  n(JTe, "assertTSFunctionType");
  function XTe(e, t) {
    P("TSConstructorType", e, t);
  }
  n(XTe, "assertTSConstructorType");
  function YTe(e, t) {
    P("TSTypeReference", e, t);
  }
  n(YTe, "assertTSTypeReference");
  function GTe(e, t) {
    P("TSTypePredicate", e, t);
  }
  n(GTe, "assertTSTypePredicate");
  function ZTe(e, t) {
    P("TSTypeQuery", e, t);
  }
  n(ZTe, "assertTSTypeQuery");
  function QTe(e, t) {
    P("TSTypeLiteral", e, t);
  }
  n(QTe, "assertTSTypeLiteral");
  function eCe(e, t) {
    P("TSArrayType", e, t);
  }
  n(eCe, "assertTSArrayType");
  function tCe(e, t) {
    P("TSTupleType", e, t);
  }
  n(tCe, "assertTSTupleType");
  function rCe(e, t) {
    P("TSOptionalType", e, t);
  }
  n(rCe, "assertTSOptionalType");
  function iCe(e, t) {
    P("TSRestType", e, t);
  }
  n(iCe, "assertTSRestType");
  function sCe(e, t) {
    P("TSNamedTupleMember", e, t);
  }
  n(sCe, "assertTSNamedTupleMember");
  function nCe(e, t) {
    P("TSUnionType", e, t);
  }
  n(nCe, "assertTSUnionType");
  function aCe(e, t) {
    P("TSIntersectionType", e, t);
  }
  n(aCe, "assertTSIntersectionType");
  function oCe(e, t) {
    P("TSConditionalType", e, t);
  }
  n(oCe, "assertTSConditionalType");
  function uCe(e, t) {
    P("TSInferType", e, t);
  }
  n(uCe, "assertTSInferType");
  function lCe(e, t) {
    P("TSParenthesizedType", e, t);
  }
  n(lCe, "assertTSParenthesizedType");
  function cCe(e, t) {
    P("TSTypeOperator", e, t);
  }
  n(cCe, "assertTSTypeOperator");
  function fCe(e, t) {
    P("TSIndexedAccessType", e, t);
  }
  n(fCe, "assertTSIndexedAccessType");
  function dCe(e, t) {
    P("TSMappedType", e, t);
  }
  n(dCe, "assertTSMappedType");
  function pCe(e, t) {
    P("TSTemplateLiteralType", e, t);
  }
  n(pCe, "assertTSTemplateLiteralType");
  function hCe(e, t) {
    P("TSLiteralType", e, t);
  }
  n(hCe, "assertTSLiteralType");
  function mCe(e, t) {
    P("TSExpressionWithTypeArguments", e, t);
  }
  n(mCe, "assertTSExpressionWithTypeArguments");
  function yCe(e, t) {
    P("TSInterfaceDeclaration", e, t);
  }
  n(yCe, "assertTSInterfaceDeclaration");
  function gCe(e, t) {
    P("TSInterfaceBody", e, t);
  }
  n(gCe, "assertTSInterfaceBody");
  function bCe(e, t) {
    P("TSTypeAliasDeclaration", e, t);
  }
  n(bCe, "assertTSTypeAliasDeclaration");
  function DCe(e, t) {
    P("TSInstantiationExpression", e, t);
  }
  n(DCe, "assertTSInstantiationExpression");
  function vCe(e, t) {
    P("TSAsExpression", e, t);
  }
  n(vCe, "assertTSAsExpression");
  function xCe(e, t) {
    P("TSSatisfiesExpression", e, t);
  }
  n(xCe, "assertTSSatisfiesExpression");
  function ECe(e, t) {
    P("TSTypeAssertion", e, t);
  }
  n(ECe, "assertTSTypeAssertion");
  function SCe(e, t) {
    P("TSEnumBody", e, t);
  }
  n(SCe, "assertTSEnumBody");
  function TCe(e, t) {
    P("TSEnumDeclaration", e, t);
  }
  n(TCe, "assertTSEnumDeclaration");
  function CCe(e, t) {
    P("TSEnumMember", e, t);
  }
  n(CCe, "assertTSEnumMember");
  function wCe(e, t) {
    P("TSModuleDeclaration", e, t);
  }
  n(wCe, "assertTSModuleDeclaration");
  function ACe(e, t) {
    P("TSModuleBlock", e, t);
  }
  n(ACe, "assertTSModuleBlock");
  function _Ce(e, t) {
    P("TSImportType", e, t);
  }
  n(_Ce, "assertTSImportType");
  function PCe(e, t) {
    P("TSImportEqualsDeclaration", e, t);
  }
  n(PCe, "assertTSImportEqualsDeclaration");
  function FCe(e, t) {
    P("TSExternalModuleReference", e, t);
  }
  n(FCe, "assertTSExternalModuleReference");
  function ICe(e, t) {
    P("TSNonNullExpression", e, t);
  }
  n(ICe, "assertTSNonNullExpression");
  function OCe(e, t) {
    P("TSExportAssignment", e, t);
  }
  n(OCe, "assertTSExportAssignment");
  function kCe(e, t) {
    P("TSNamespaceExportDeclaration", e, t);
  }
  n(kCe, "assertTSNamespaceExportDeclaration");
  function BCe(e, t) {
    P("TSTypeAnnotation", e, t);
  }
  n(BCe, "assertTSTypeAnnotation");
  function NCe(e, t) {
    P("TSTypeParameterInstantiation", e, t);
  }
  n(NCe, "assertTSTypeParameterInstantiation");
  function MCe(e, t) {
    P("TSTypeParameterDeclaration", e, t);
  }
  n(MCe, "assertTSTypeParameterDeclaration");
  function RCe(e, t) {
    P("TSTypeParameter", e, t);
  }
  n(RCe, "assertTSTypeParameter");
  function LCe(e, t) {
    P("Standardized", e, t);
  }
  n(LCe, "assertStandardized");
  function jCe(e, t) {
    P("Expression", e, t);
  }
  n(jCe, "assertExpression");
  function qCe(e, t) {
    P("Binary", e, t);
  }
  n(qCe, "assertBinary");
  function UCe(e, t) {
    P("Scopable", e, t);
  }
  n(UCe, "assertScopable");
  function $Ce(e, t) {
    P("BlockParent", e, t);
  }
  n($Ce, "assertBlockParent");
  function VCe(e, t) {
    P("Block", e, t);
  }
  n(VCe, "assertBlock");
  function WCe(e, t) {
    P("Statement", e, t);
  }
  n(WCe, "assertStatement");
  function HCe(e, t) {
    P("Terminatorless", e, t);
  }
  n(HCe, "assertTerminatorless");
  function KCe(e, t) {
    P("CompletionStatement", e, t);
  }
  n(KCe, "assertCompletionStatement");
  function zCe(e, t) {
    P("Conditional", e, t);
  }
  n(zCe, "assertConditional");
  function JCe(e, t) {
    P("Loop", e, t);
  }
  n(JCe, "assertLoop");
  function XCe(e, t) {
    P("While", e, t);
  }
  n(XCe, "assertWhile");
  function YCe(e, t) {
    P("ExpressionWrapper", e, t);
  }
  n(YCe, "assertExpressionWrapper");
  function GCe(e, t) {
    P("For", e, t);
  }
  n(GCe, "assertFor");
  function ZCe(e, t) {
    P("ForXStatement", e, t);
  }
  n(ZCe, "assertForXStatement");
  function QCe(e, t) {
    P("Function", e, t);
  }
  n(QCe, "assertFunction");
  function ewe(e, t) {
    P("FunctionParent", e, t);
  }
  n(ewe, "assertFunctionParent");
  function twe(e, t) {
    P("Pureish", e, t);
  }
  n(twe, "assertPureish");
  function rwe(e, t) {
    P("Declaration", e, t);
  }
  n(rwe, "assertDeclaration");
  function iwe(e, t) {
    P("FunctionParameter", e, t);
  }
  n(iwe, "assertFunctionParameter");
  function swe(e, t) {
    P("PatternLike", e, t);
  }
  n(swe, "assertPatternLike");
  function nwe(e, t) {
    P("LVal", e, t);
  }
  n(nwe, "assertLVal");
  function awe(e, t) {
    P("TSEntityName", e, t);
  }
  n(awe, "assertTSEntityName");
  function owe(e, t) {
    P("Literal", e, t);
  }
  n(owe, "assertLiteral");
  function uwe(e, t) {
    P("Immutable", e, t);
  }
  n(uwe, "assertImmutable");
  function lwe(e, t) {
    P("UserWhitespacable", e, t);
  }
  n(lwe, "assertUserWhitespacable");
  function cwe(e, t) {
    P("Method", e, t);
  }
  n(cwe, "assertMethod");
  function fwe(e, t) {
    P("ObjectMember", e, t);
  }
  n(fwe, "assertObjectMember");
  function dwe(e, t) {
    P("Property", e, t);
  }
  n(dwe, "assertProperty");
  function pwe(e, t) {
    P("UnaryLike", e, t);
  }
  n(pwe, "assertUnaryLike");
  function hwe(e, t) {
    P("Pattern", e, t);
  }
  n(hwe, "assertPattern");
  function mwe(e, t) {
    P("Class", e, t);
  }
  n(mwe, "assertClass");
  function ywe(e, t) {
    P("ImportOrExportDeclaration", e, t);
  }
  n(ywe, "assertImportOrExportDeclaration");
  function gwe(e, t) {
    P("ExportDeclaration", e, t);
  }
  n(gwe, "assertExportDeclaration");
  function bwe(e, t) {
    P("ModuleSpecifier", e, t);
  }
  n(bwe, "assertModuleSpecifier");
  function Dwe(e, t) {
    P("Accessor", e, t);
  }
  n(Dwe, "assertAccessor");
  function vwe(e, t) {
    P("Private", e, t);
  }
  n(vwe, "assertPrivate");
  function xwe(e, t) {
    P("Flow", e, t);
  }
  n(xwe, "assertFlow");
  function Ewe(e, t) {
    P("FlowType", e, t);
  }
  n(Ewe, "assertFlowType");
  function Swe(e, t) {
    P("FlowBaseAnnotation", e, t);
  }
  n(Swe, "assertFlowBaseAnnotation");
  function Twe(e, t) {
    P("FlowDeclaration", e, t);
  }
  n(Twe, "assertFlowDeclaration");
  function Cwe(e, t) {
    P("FlowPredicate", e, t);
  }
  n(Cwe, "assertFlowPredicate");
  function wwe(e, t) {
    P("EnumBody", e, t);
  }
  n(wwe, "assertEnumBody");
  function Awe(e, t) {
    P("EnumMember", e, t);
  }
  n(Awe, "assertEnumMember");
  function _we(e, t) {
    P("JSX", e, t);
  }
  n(_we, "assertJSX");
  function Pwe(e, t) {
    P("Miscellaneous", e, t);
  }
  n(Pwe, "assertMiscellaneous");
  function Fwe(e, t) {
    P("TypeScript", e, t);
  }
  n(Fwe, "assertTypeScript");
  function Iwe(e, t) {
    P("TSTypeElement", e, t);
  }
  n(Iwe, "assertTSTypeElement");
  function Owe(e, t) {
    P("TSType", e, t);
  }
  n(Owe, "assertTSType");
  function kwe(e, t) {
    P("TSBaseType", e, t);
  }
  n(kwe, "assertTSBaseType");
  function Bwe(e, t) {
    (0, Ad.default)("assertNumberLiteral", "assertNumericLiteral"), P("NumberLiteral", e, t);
  }
  n(Bwe, "assertNumberLiteral");
  function Nwe(e, t) {
    (0, Ad.default)("assertRegexLiteral", "assertRegExpLiteral"), P("RegexLiteral", e, t);
  }
  n(Nwe, "assertRegexLiteral");
  function Mwe(e, t) {
    (0, Ad.default)("assertRestProperty", "assertRestElement"), P("RestProperty", e, t);
  }
  n(Mwe, "assertRestProperty");
  function Rwe(e, t) {
    (0, Ad.default)("assertSpreadProperty", "assertSpreadElement"), P("SpreadProperty", e, t);
  }
  n(Rwe, "assertSpreadProperty");
  function Lwe(e, t) {
    (0, Ad.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), P("ModuleDeclaration", e, t);
  }
  n(Lwe, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var UM = E((Nm) => {
  "use strict";
  Object.defineProperty(Nm, "__esModule", {
    value: !0
  });
  Nm.default = void 0;
  var ps = hi(), Ypt = Nm.default = jwe;
  function jwe(e) {
    switch (e) {
      case "string":
        return (0, ps.stringTypeAnnotation)();
      case "number":
        return (0, ps.numberTypeAnnotation)();
      case "undefined":
        return (0, ps.voidTypeAnnotation)();
      case "boolean":
        return (0, ps.booleanTypeAnnotation)();
      case "function":
        return (0, ps.genericTypeAnnotation)((0, ps.identifier)("Function"));
      case "object":
        return (0, ps.genericTypeAnnotation)((0, ps.identifier)("Object"));
      case "symbol":
        return (0, ps.genericTypeAnnotation)((0, ps.identifier)("Symbol"));
      case "bigint":
        return (0, ps.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + e);
  }
  n(jwe, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var HE = E((WE) => {
  "use strict";
  Object.defineProperty(WE, "__esModule", {
    value: !0
  });
  WE.default = VM;
  var _d = Jt();
  function $M(e) {
    return (0, _d.isIdentifier)(e) ? e.name : `${e.id.name}.${$M(e.qualification)}`;
  }
  n($M, "getQualifiedName");
  function VM(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let u = t[o];
      if (u && !a.includes(u)) {
        if ((0, _d.isAnyTypeAnnotation)(u))
          return [u];
        if ((0, _d.isFlowBaseAnnotation)(u)) {
          i.set(u.type, u);
          continue;
        }
        if ((0, _d.isUnionTypeAnnotation)(u)) {
          s.has(u.types) || (t.push(...u.types), s.add(u.types));
          continue;
        }
        if ((0, _d.isGenericTypeAnnotation)(u)) {
          let l = $M(u.id);
          if (r.has(l)) {
            let c = r.get(l);
            c.typeParameters ? u.typeParameters && (c.typeParameters.params.push(...u.typeParameters.params), c.typeParameters.params = VM(c.
            typeParameters.params)) : c = u.typeParameters;
          } else
            r.set(l, u);
          continue;
        }
        a.push(u);
      }
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  n(VM, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var WM = E((KE) => {
  "use strict";
  Object.defineProperty(KE, "__esModule", {
    value: !0
  });
  KE.default = $we;
  var qwe = hi(), Uwe = HE();
  function $we(e) {
    let t = (0, Uwe.default)(e);
    return t.length === 1 ? t[0] : (0, qwe.unionTypeAnnotation)(t);
  }
  n($we, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var zM = E((zE) => {
  "use strict";
  Object.defineProperty(zE, "__esModule", {
    value: !0
  });
  zE.default = KM;
  var jl = Jt();
  function HM(e) {
    return (0, jl.isIdentifier)(e) ? e.name : (0, jl.isThisExpression)(e) ? "this" : `${e.right.name}.${HM(e.left)}`;
  }
  n(HM, "getQualifiedName");
  function KM(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let u = t[o];
      if (!u || a.includes(u))
        continue;
      if ((0, jl.isTSAnyKeyword)(u))
        return [u];
      if ((0, jl.isTSBaseType)(u)) {
        i.set(u.type, u);
        continue;
      }
      if ((0, jl.isTSUnionType)(u)) {
        s.has(u.types) || (t.push(...u.types), s.add(u.types));
        continue;
      }
      let l = "typeParameters";
      if ((0, jl.isTSTypeReference)(u) && u[l]) {
        let c = u[l], f = HM(u.typeName);
        if (r.has(f)) {
          let m = r.get(f), h = m[l];
          h ? (h.params.push(...c.params), h.params = KM(h.params)) : m = c;
        } else
          r.set(f, u);
        continue;
      }
      a.push(u);
    }
    for (let [, o] of i)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  n(KM, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var JM = E((JE) => {
  "use strict";
  Object.defineProperty(JE, "__esModule", {
    value: !0
  });
  JE.default = Kwe;
  var Vwe = hi(), Wwe = zM(), Hwe = Jt();
  function Kwe(e) {
    let t = e.map((i) => (0, Hwe.isTSTypeAnnotation)(i) ? i.typeAnnotation : i), r = (0, Wwe.default)(t);
    return r.length === 1 ? r[0] : (0, Vwe.tsUnionType)(r);
  }
  n(Kwe, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/productions.js
var YE = E((XE) => {
  "use strict";
  Object.defineProperty(XE, "__esModule", {
    value: !0
  });
  XE.buildUndefinedNode = zwe;
  var XM = hi();
  function zwe() {
    return (0, XM.unaryExpression)("void", (0, XM.numericLiteral)(0), !0);
  }
  n(zwe, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var Ia = E((ZE) => {
  "use strict";
  Object.defineProperty(ZE, "__esModule", {
    value: !0
  });
  ZE.default = Jwe;
  var YM = Vi(), GM = Jt(), {
    hasOwn: Gs
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function ZM(e, t, r, i) {
    return e && typeof e.type == "string" ? QM(e, t, r, i) : e;
  }
  n(ZM, "cloneIfNode");
  function GE(e, t, r, i) {
    return Array.isArray(e) ? e.map((s) => ZM(s, t, r, i)) : ZM(e, t, r, i);
  }
  n(GE, "cloneIfNodeOrArray");
  function Jwe(e, t = !0, r = !1) {
    return QM(e, t, r, /* @__PURE__ */ new Map());
  }
  n(Jwe, "cloneNode");
  function QM(e, t = !0, r = !1, i) {
    if (!e) return e;
    let {
      type: s
    } = e, a = {
      type: e.type
    };
    if ((0, GM.isIdentifier)(e))
      a.name = e.name, Gs(e, "optional") && typeof e.optional == "boolean" && (a.optional = e.optional), Gs(e, "typeAnnotation") && (a.typeAnnotation =
      t ? GE(e.typeAnnotation, !0, r, i) : e.typeAnnotation), Gs(e, "decorators") && (a.decorators = t ? GE(e.decorators, !0, r, i) : e.decorators);
    else if (Gs(YM.NODE_FIELDS, s))
      for (let o of Object.keys(YM.NODE_FIELDS[s]))
        Gs(e, o) && (t ? a[o] = (0, GM.isFile)(e) && o === "comments" ? Mm(e.comments, t, r, i) : GE(e[o], !0, r, i) : a[o] = e[o]);
    else
      throw new Error(`Unknown node type: "${s}"`);
    return Gs(e, "loc") && (r ? a.loc = null : a.loc = e.loc), Gs(e, "leadingComments") && (a.leadingComments = Mm(e.leadingComments, t, r, i)),
    Gs(e, "innerComments") && (a.innerComments = Mm(e.innerComments, t, r, i)), Gs(e, "trailingComments") && (a.trailingComments = Mm(e.trailingComments,
    t, r, i)), Gs(e, "extra") && (a.extra = Object.assign({}, e.extra)), a;
  }
  n(QM, "cloneNodeInternal");
  function Mm(e, t, r, i) {
    return !e || !t ? e : e.map((s) => {
      let a = i.get(s);
      if (a) return a;
      let {
        type: o,
        value: u,
        loc: l
      } = s, c = {
        type: o,
        value: u,
        loc: l
      };
      return r && (c.loc = null), i.set(s, c), c;
    });
  }
  n(Mm, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var eR = E((QE) => {
  "use strict";
  Object.defineProperty(QE, "__esModule", {
    value: !0
  });
  QE.default = Ywe;
  var Xwe = Ia();
  function Ywe(e) {
    return (0, Xwe.default)(e, !1);
  }
  n(Ywe, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var tR = E((eS) => {
  "use strict";
  Object.defineProperty(eS, "__esModule", {
    value: !0
  });
  eS.default = Zwe;
  var Gwe = Ia();
  function Zwe(e) {
    return (0, Gwe.default)(e);
  }
  n(Zwe, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var rR = E((tS) => {
  "use strict";
  Object.defineProperty(tS, "__esModule", {
    value: !0
  });
  tS.default = eAe;
  var Qwe = Ia();
  function eAe(e) {
    return (0, Qwe.default)(e, !0, !0);
  }
  n(eAe, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var iR = E((rS) => {
  "use strict";
  Object.defineProperty(rS, "__esModule", {
    value: !0
  });
  rS.default = rAe;
  var tAe = Ia();
  function rAe(e) {
    return (0, tAe.default)(e, !1, !0);
  }
  n(rAe, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var sS = E((iS) => {
  "use strict";
  Object.defineProperty(iS, "__esModule", {
    value: !0
  });
  iS.default = iAe;
  function iAe(e, t, r) {
    if (!r || !e) return e;
    let i = `${t}Comments`;
    return e[i] ? t === "leading" ? e[i] = r.concat(e[i]) : e[i].push(...r) : e[i] = r, e;
  }
  n(iAe, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var sR = E((nS) => {
  "use strict";
  Object.defineProperty(nS, "__esModule", {
    value: !0
  });
  nS.default = nAe;
  var sAe = sS();
  function nAe(e, t, r, i) {
    return (0, sAe.default)(e, t, [{
      type: i ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  n(nAe, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var Rm = E((aS) => {
  "use strict";
  Object.defineProperty(aS, "__esModule", {
    value: !0
  });
  aS.default = aAe;
  function aAe(e, t, r) {
    t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
  }
  n(aAe, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var uS = E((oS) => {
  "use strict";
  Object.defineProperty(oS, "__esModule", {
    value: !0
  });
  oS.default = uAe;
  var oAe = Rm();
  function uAe(e, t) {
    (0, oAe.default)("innerComments", e, t);
  }
  n(uAe, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var cS = E((lS) => {
  "use strict";
  Object.defineProperty(lS, "__esModule", {
    value: !0
  });
  lS.default = cAe;
  var lAe = Rm();
  function cAe(e, t) {
    (0, lAe.default)("leadingComments", e, t);
  }
  n(cAe, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var dS = E((fS) => {
  "use strict";
  Object.defineProperty(fS, "__esModule", {
    value: !0
  });
  fS.default = dAe;
  var fAe = Rm();
  function dAe(e, t) {
    (0, fAe.default)("trailingComments", e, t);
  }
  n(dAe, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var hS = E((pS) => {
  "use strict";
  Object.defineProperty(pS, "__esModule", {
    value: !0
  });
  pS.default = yAe;
  var pAe = dS(), hAe = cS(), mAe = uS();
  function yAe(e, t) {
    return (0, pAe.default)(e, t), (0, hAe.default)(e, t), (0, mAe.default)(e, t), e;
  }
  n(yAe, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var nR = E((mS) => {
  "use strict";
  Object.defineProperty(mS, "__esModule", {
    value: !0
  });
  mS.default = bAe;
  var gAe = Bl();
  function bAe(e) {
    return gAe.COMMENT_KEYS.forEach((t) => {
      e[t] = null;
    }), e;
  }
  n(bAe, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var aR = E((Q) => {
  "use strict";
  Object.defineProperty(Q, "__esModule", {
    value: !0
  });
  Q.WHILE_TYPES = Q.USERWHITESPACABLE_TYPES = Q.UNARYLIKE_TYPES = Q.TYPESCRIPT_TYPES = Q.TSTYPE_TYPES = Q.TSTYPEELEMENT_TYPES = Q.TSENTITYNAME_TYPES =
  Q.TSBASETYPE_TYPES = Q.TERMINATORLESS_TYPES = Q.STATEMENT_TYPES = Q.STANDARDIZED_TYPES = Q.SCOPABLE_TYPES = Q.PUREISH_TYPES = Q.PROPERTY_TYPES =
  Q.PRIVATE_TYPES = Q.PATTERN_TYPES = Q.PATTERNLIKE_TYPES = Q.OBJECTMEMBER_TYPES = Q.MODULESPECIFIER_TYPES = Q.MODULEDECLARATION_TYPES = Q.MISCELLANEOUS_TYPES =
  Q.METHOD_TYPES = Q.LVAL_TYPES = Q.LOOP_TYPES = Q.LITERAL_TYPES = Q.JSX_TYPES = Q.IMPORTOREXPORTDECLARATION_TYPES = Q.IMMUTABLE_TYPES = Q.FUNCTION_TYPES =
  Q.FUNCTIONPARENT_TYPES = Q.FUNCTIONPARAMETER_TYPES = Q.FOR_TYPES = Q.FORXSTATEMENT_TYPES = Q.FLOW_TYPES = Q.FLOWTYPE_TYPES = Q.FLOWPREDICATE_TYPES =
  Q.FLOWDECLARATION_TYPES = Q.FLOWBASEANNOTATION_TYPES = Q.EXPRESSION_TYPES = Q.EXPRESSIONWRAPPER_TYPES = Q.EXPORTDECLARATION_TYPES = Q.ENUMMEMBER_TYPES =
  Q.ENUMBODY_TYPES = Q.DECLARATION_TYPES = Q.CONDITIONAL_TYPES = Q.COMPLETIONSTATEMENT_TYPES = Q.CLASS_TYPES = Q.BLOCK_TYPES = Q.BLOCKPARENT_TYPES =
  Q.BINARY_TYPES = Q.ACCESSOR_TYPES = void 0;
  var Ie = Vi(), Nht = Q.STANDARDIZED_TYPES = Ie.FLIPPED_ALIAS_KEYS.Standardized, Mht = Q.EXPRESSION_TYPES = Ie.FLIPPED_ALIAS_KEYS.Expression,
  Rht = Q.BINARY_TYPES = Ie.FLIPPED_ALIAS_KEYS.Binary, Lht = Q.SCOPABLE_TYPES = Ie.FLIPPED_ALIAS_KEYS.Scopable, jht = Q.BLOCKPARENT_TYPES = Ie.
  FLIPPED_ALIAS_KEYS.BlockParent, qht = Q.BLOCK_TYPES = Ie.FLIPPED_ALIAS_KEYS.Block, Uht = Q.STATEMENT_TYPES = Ie.FLIPPED_ALIAS_KEYS.Statement,
  $ht = Q.TERMINATORLESS_TYPES = Ie.FLIPPED_ALIAS_KEYS.Terminatorless, Vht = Q.COMPLETIONSTATEMENT_TYPES = Ie.FLIPPED_ALIAS_KEYS.CompletionStatement,
  Wht = Q.CONDITIONAL_TYPES = Ie.FLIPPED_ALIAS_KEYS.Conditional, Hht = Q.LOOP_TYPES = Ie.FLIPPED_ALIAS_KEYS.Loop, Kht = Q.WHILE_TYPES = Ie.FLIPPED_ALIAS_KEYS.
  While, zht = Q.EXPRESSIONWRAPPER_TYPES = Ie.FLIPPED_ALIAS_KEYS.ExpressionWrapper, Jht = Q.FOR_TYPES = Ie.FLIPPED_ALIAS_KEYS.For, Xht = Q.FORXSTATEMENT_TYPES =
  Ie.FLIPPED_ALIAS_KEYS.ForXStatement, Yht = Q.FUNCTION_TYPES = Ie.FLIPPED_ALIAS_KEYS.Function, Ght = Q.FUNCTIONPARENT_TYPES = Ie.FLIPPED_ALIAS_KEYS.
  FunctionParent, Zht = Q.PUREISH_TYPES = Ie.FLIPPED_ALIAS_KEYS.Pureish, Qht = Q.DECLARATION_TYPES = Ie.FLIPPED_ALIAS_KEYS.Declaration, e0t = Q.
  FUNCTIONPARAMETER_TYPES = Ie.FLIPPED_ALIAS_KEYS.FunctionParameter, t0t = Q.PATTERNLIKE_TYPES = Ie.FLIPPED_ALIAS_KEYS.PatternLike, r0t = Q.
  LVAL_TYPES = Ie.FLIPPED_ALIAS_KEYS.LVal, i0t = Q.TSENTITYNAME_TYPES = Ie.FLIPPED_ALIAS_KEYS.TSEntityName, s0t = Q.LITERAL_TYPES = Ie.FLIPPED_ALIAS_KEYS.
  Literal, n0t = Q.IMMUTABLE_TYPES = Ie.FLIPPED_ALIAS_KEYS.Immutable, a0t = Q.USERWHITESPACABLE_TYPES = Ie.FLIPPED_ALIAS_KEYS.UserWhitespacable,
  o0t = Q.METHOD_TYPES = Ie.FLIPPED_ALIAS_KEYS.Method, u0t = Q.OBJECTMEMBER_TYPES = Ie.FLIPPED_ALIAS_KEYS.ObjectMember, l0t = Q.PROPERTY_TYPES =
  Ie.FLIPPED_ALIAS_KEYS.Property, c0t = Q.UNARYLIKE_TYPES = Ie.FLIPPED_ALIAS_KEYS.UnaryLike, f0t = Q.PATTERN_TYPES = Ie.FLIPPED_ALIAS_KEYS.Pattern,
  d0t = Q.CLASS_TYPES = Ie.FLIPPED_ALIAS_KEYS.Class, DAe = Q.IMPORTOREXPORTDECLARATION_TYPES = Ie.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration,
  p0t = Q.EXPORTDECLARATION_TYPES = Ie.FLIPPED_ALIAS_KEYS.ExportDeclaration, h0t = Q.MODULESPECIFIER_TYPES = Ie.FLIPPED_ALIAS_KEYS.ModuleSpecifier,
  m0t = Q.ACCESSOR_TYPES = Ie.FLIPPED_ALIAS_KEYS.Accessor, y0t = Q.PRIVATE_TYPES = Ie.FLIPPED_ALIAS_KEYS.Private, g0t = Q.FLOW_TYPES = Ie.FLIPPED_ALIAS_KEYS.
  Flow, b0t = Q.FLOWTYPE_TYPES = Ie.FLIPPED_ALIAS_KEYS.FlowType, D0t = Q.FLOWBASEANNOTATION_TYPES = Ie.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation,
  v0t = Q.FLOWDECLARATION_TYPES = Ie.FLIPPED_ALIAS_KEYS.FlowDeclaration, x0t = Q.FLOWPREDICATE_TYPES = Ie.FLIPPED_ALIAS_KEYS.FlowPredicate, E0t = Q.
  ENUMBODY_TYPES = Ie.FLIPPED_ALIAS_KEYS.EnumBody, S0t = Q.ENUMMEMBER_TYPES = Ie.FLIPPED_ALIAS_KEYS.EnumMember, T0t = Q.JSX_TYPES = Ie.FLIPPED_ALIAS_KEYS.
  JSX, C0t = Q.MISCELLANEOUS_TYPES = Ie.FLIPPED_ALIAS_KEYS.Miscellaneous, w0t = Q.TYPESCRIPT_TYPES = Ie.FLIPPED_ALIAS_KEYS.TypeScript, A0t = Q.
  TSTYPEELEMENT_TYPES = Ie.FLIPPED_ALIAS_KEYS.TSTypeElement, _0t = Q.TSTYPE_TYPES = Ie.FLIPPED_ALIAS_KEYS.TSType, P0t = Q.TSBASETYPE_TYPES =
  Ie.FLIPPED_ALIAS_KEYS.TSBaseType, F0t = Q.MODULEDECLARATION_TYPES = DAe;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var bS = E((gS) => {
  "use strict";
  Object.defineProperty(gS, "__esModule", {
    value: !0
  });
  gS.default = vAe;
  var Lm = Jt(), yS = hi();
  function vAe(e, t) {
    if ((0, Lm.isBlockStatement)(e))
      return e;
    let r = [];
    return (0, Lm.isEmptyStatement)(e) ? r = [] : ((0, Lm.isStatement)(e) || ((0, Lm.isFunction)(t) ? e = (0, yS.returnStatement)(e) : e = (0, yS.
    expressionStatement)(e)), r = [e]), (0, yS.blockStatement)(r);
  }
  n(vAe, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var oR = E((DS) => {
  "use strict";
  Object.defineProperty(DS, "__esModule", {
    value: !0
  });
  DS.default = EAe;
  var xAe = bS();
  function EAe(e, t = "body") {
    let r = (0, xAe.default)(e[t], e);
    return e[t] = r, r;
  }
  n(EAe, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var xS = E((vS) => {
  "use strict";
  Object.defineProperty(vS, "__esModule", {
    value: !0
  });
  vS.default = CAe;
  var SAe = kl(), TAe = Ol();
  function CAe(e) {
    e = e + "";
    let t = "";
    for (let r of e)
      t += (0, TAe.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(r, i) {
      return i ? i.toUpperCase() : "";
    }), (0, SAe.default)(t) || (t = `_${t}`), t || "_";
  }
  n(CAe, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var uR = E((ES) => {
  "use strict";
  Object.defineProperty(ES, "__esModule", {
    value: !0
  });
  ES.default = AAe;
  var wAe = xS();
  function AAe(e) {
    return e = (0, wAe.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
  }
  n(AAe, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var lR = E((SS) => {
  "use strict";
  Object.defineProperty(SS, "__esModule", {
    value: !0
  });
  SS.default = FAe;
  var _Ae = Jt(), PAe = hi();
  function FAe(e, t = e.key || e.property) {
    return !e.computed && (0, _Ae.isIdentifier)(t) && (t = (0, PAe.stringLiteral)(t.name)), t;
  }
  n(FAe, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var cR = E((jm) => {
  "use strict";
  Object.defineProperty(jm, "__esModule", {
    value: !0
  });
  jm.default = void 0;
  var Pd = Jt(), $0t = jm.default = IAe;
  function IAe(e) {
    if ((0, Pd.isExpressionStatement)(e) && (e = e.expression), (0, Pd.isExpression)(e))
      return e;
    if ((0, Pd.isClass)(e) ? (e.type = "ClassExpression", e.abstract = !1) : (0, Pd.isFunction)(e) && (e.type = "FunctionExpression"), !(0, Pd.
    isExpression)(e))
      throw new Error(`cannot turn ${e.type} to an expression`);
    return e;
  }
  n(IAe, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var CS = E((TS) => {
  "use strict";
  Object.defineProperty(TS, "__esModule", {
    value: !0
  });
  TS.default = Fd;
  var OAe = Vi(), fR = Symbol(), dR = Symbol();
  function Fd(e, t, r) {
    if (!e) return !1;
    let i = OAe.VISITOR_KEYS[e.type];
    if (!i) return !1;
    r = r || {};
    let s = t(e, r);
    if (s !== void 0)
      switch (s) {
        case fR:
          return !1;
        case dR:
          return !0;
      }
    for (let a of i) {
      let o = e[a];
      if (o) {
        if (Array.isArray(o)) {
          for (let u of o)
            if (Fd(u, t, r)) return !0;
        } else if (Fd(o, t, r)) return !0;
      }
    }
    return !1;
  }
  n(Fd, "traverseFast");
  Fd.skip = fR;
  Fd.stop = dR;
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var AS = E((wS) => {
  "use strict";
  Object.defineProperty(wS, "__esModule", {
    value: !0
  });
  wS.default = NAe;
  var kAe = Bl(), pR = ["tokens", "start", "end", "loc", "raw", "rawValue"], BAe = [...kAe.COMMENT_KEYS, "comments", ...pR];
  function NAe(e, t = {}) {
    let r = t.preserveComments ? pR : BAe;
    for (let s of r)
      e[s] != null && (e[s] = void 0);
    for (let s of Object.keys(e))
      s[0] === "_" && e[s] != null && (e[s] = void 0);
    let i = Object.getOwnPropertySymbols(e);
    for (let s of i)
      e[s] = null;
  }
  n(NAe, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var PS = E((_S) => {
  "use strict";
  Object.defineProperty(_S, "__esModule", {
    value: !0
  });
  _S.default = LAe;
  var MAe = CS(), RAe = AS();
  function LAe(e, t) {
    return (0, MAe.default)(e, RAe.default, t), e;
  }
  n(LAe, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var mR = E((FS) => {
  "use strict";
  Object.defineProperty(FS, "__esModule", {
    value: !0
  });
  FS.default = jo;
  var hR = Jt(), jAe = Ia(), qAe = PS();
  function jo(e, t = e.key) {
    let r;
    return e.kind === "method" ? jo.increment() + "" : ((0, hR.isIdentifier)(t) ? r = t.name : (0, hR.isStringLiteral)(t) ? r = JSON.stringify(
    t.value) : r = JSON.stringify((0, qAe.default)((0, jAe.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
  }
  n(jo, "toKeyAlias");
  jo.uid = 0;
  jo.increment = function() {
    return jo.uid >= Number.MAX_SAFE_INTEGER ? jo.uid = 0 : jo.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var yR = E((Um) => {
  "use strict";
  Object.defineProperty(Um, "__esModule", {
    value: !0
  });
  Um.default = void 0;
  var qm = Jt(), UAe = hi(), Q0t = Um.default = $Ae;
  function $Ae(e, t) {
    if ((0, qm.isStatement)(e))
      return e;
    let r = !1, i;
    if ((0, qm.isClass)(e))
      r = !0, i = "ClassDeclaration";
    else if ((0, qm.isFunction)(e))
      r = !0, i = "FunctionDeclaration";
    else if ((0, qm.isAssignmentExpression)(e))
      return (0, UAe.expressionStatement)(e);
    if (r && !e.id && (i = !1), !i) {
      if (t)
        return !1;
      throw new Error(`cannot turn ${e.type} to a statement`);
    }
    return e.type = i, e;
  }
  n($Ae, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var gR = E(($m) => {
  "use strict";
  Object.defineProperty($m, "__esModule", {
    value: !0
  });
  $m.default = void 0;
  var VAe = kl(), lr = hi(), rmt = $m.default = IS, WAe = Function.call.bind(Object.prototype.toString);
  function HAe(e) {
    return WAe(e) === "[object RegExp]";
  }
  n(HAe, "isRegExp");
  function KAe(e) {
    if (typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]")
      return !1;
    let t = Object.getPrototypeOf(e);
    return t === null || Object.getPrototypeOf(t) === null;
  }
  n(KAe, "isPlainObject");
  function IS(e) {
    if (e === void 0)
      return (0, lr.identifier)("undefined");
    if (e === !0 || e === !1)
      return (0, lr.booleanLiteral)(e);
    if (e === null)
      return (0, lr.nullLiteral)();
    if (typeof e == "string")
      return (0, lr.stringLiteral)(e);
    if (typeof e == "number") {
      let t;
      if (Number.isFinite(e))
        t = (0, lr.numericLiteral)(Math.abs(e));
      else {
        let r;
        Number.isNaN(e) ? r = (0, lr.numericLiteral)(0) : r = (0, lr.numericLiteral)(1), t = (0, lr.binaryExpression)("/", r, (0, lr.numericLiteral)(
        0));
      }
      return (e < 0 || Object.is(e, -0)) && (t = (0, lr.unaryExpression)("-", t)), t;
    }
    if (typeof e == "bigint")
      return e < 0 ? (0, lr.unaryExpression)("-", (0, lr.bigIntLiteral)(-e)) : (0, lr.bigIntLiteral)(e);
    if (HAe(e)) {
      let t = e.source, r = /\/([a-z]*)$/.exec(e.toString())[1];
      return (0, lr.regExpLiteral)(t, r);
    }
    if (Array.isArray(e))
      return (0, lr.arrayExpression)(e.map(IS));
    if (KAe(e)) {
      let t = [];
      for (let r of Object.keys(e)) {
        let i, s = !1;
        (0, VAe.default)(r) ? r === "__proto__" ? (s = !0, i = (0, lr.stringLiteral)(r)) : i = (0, lr.identifier)(r) : i = (0, lr.stringLiteral)(
        r), t.push((0, lr.objectProperty)(i, IS(e[r]), s));
      }
      return (0, lr.objectExpression)(t);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  n(IS, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var bR = E((OS) => {
  "use strict";
  Object.defineProperty(OS, "__esModule", {
    value: !0
  });
  OS.default = JAe;
  var zAe = hi();
  function JAe(e, t, r = !1) {
    return e.object = (0, zAe.memberExpression)(e.object, e.property, e.computed), e.property = t, e.computed = !!r, e;
  }
  n(JAe, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var vR = E((kS) => {
  "use strict";
  Object.defineProperty(kS, "__esModule", {
    value: !0
  });
  kS.default = YAe;
  var DR = Bl(), XAe = hS();
  function YAe(e, t) {
    if (!e || !t) return e;
    for (let r of DR.INHERIT_KEYS.optional)
      e[r] == null && (e[r] = t[r]);
    for (let r of Object.keys(t))
      r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
    for (let r of DR.INHERIT_KEYS.force)
      e[r] = t[r];
    return (0, XAe.default)(e, t), e;
  }
  n(YAe, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var xR = E((BS) => {
  "use strict";
  Object.defineProperty(BS, "__esModule", {
    value: !0
  });
  BS.default = QAe;
  var GAe = hi(), ZAe = Pe();
  function QAe(e, t) {
    if ((0, ZAe.isSuper)(e.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return e.object = (0, GAe.memberExpression)(t, e.object), e;
  }
  n(QAe, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var ER = E((NS) => {
  "use strict";
  Object.defineProperty(NS, "__esModule", {
    value: !0
  });
  NS.default = e_e;
  function e_e(e) {
    let t = [].concat(e), r = /* @__PURE__ */ Object.create(null);
    for (; t.length; ) {
      let i = t.pop();
      if (i)
        switch (i.type) {
          case "ArrayPattern":
            t.push(...i.elements);
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            t.push(i.left);
            break;
          case "ObjectPattern":
            t.push(...i.properties);
            break;
          case "ObjectProperty":
            t.push(i.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            t.push(i.argument);
            break;
          case "UnaryExpression":
            i.operator === "delete" && t.push(i.argument);
            break;
          case "Identifier":
            r[i.name] = i;
            break;
          default:
            break;
        }
    }
    return r;
  }
  n(e_e, "getAssignmentIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var Id = E((RS) => {
  "use strict";
  Object.defineProperty(RS, "__esModule", {
    value: !0
  });
  RS.default = MS;
  var Nn = Jt();
  function MS(e, t, r, i) {
    let s = [].concat(e), a = /* @__PURE__ */ Object.create(null);
    for (; s.length; ) {
      let o = s.shift();
      if (!o || i && ((0, Nn.isAssignmentExpression)(o) || (0, Nn.isUnaryExpression)(o) || (0, Nn.isUpdateExpression)(o)))
        continue;
      if ((0, Nn.isIdentifier)(o)) {
        t ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, Nn.isExportDeclaration)(o) && !(0, Nn.isExportAllDeclaration)(o)) {
        (0, Nn.isDeclaration)(o.declaration) && s.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, Nn.isFunctionDeclaration)(o)) {
          s.push(o.id);
          continue;
        }
        if ((0, Nn.isFunctionExpression)(o))
          continue;
      }
      let u = MS.keys[o.type];
      if (u)
        for (let l = 0; l < u.length; l++) {
          let c = u[l], f = o[c];
          f && (Array.isArray(f) ? s.push(...f) : s.push(f));
        }
    }
    return a;
  }
  n(MS, "getBindingIdentifiers");
  var t_e = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  MS.keys = t_e;
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var SR = E((Vm) => {
  "use strict";
  Object.defineProperty(Vm, "__esModule", {
    value: !0
  });
  Vm.default = void 0;
  var r_e = Id(), mmt = Vm.default = i_e;
  function i_e(e, t) {
    return (0, r_e.default)(e, t, !0);
  }
  n(i_e, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getFunctionName.js
var CR = E((LS) => {
  "use strict";
  Object.defineProperty(LS, "__esModule", {
    value: !0
  });
  LS.default = n_e;
  var Wi = Jt();
  function s_e(e) {
    return (0, Wi.isNullLiteral)(e) ? "null" : (0, Wi.isRegExpLiteral)(e) ? `/${e.pattern}/${e.flags}` : (0, Wi.isTemplateLiteral)(e) ? e.quasis.
    map((t) => t.value.raw).join("") : e.value !== void 0 ? String(e.value) : null;
  }
  n(s_e, "getNameFromLiteralId");
  function TR(e) {
    if (!e.computed || (0, Wi.isLiteral)(e.key))
      return e.key;
  }
  n(TR, "getObjectMemberKey");
  function n_e(e, t) {
    if ("id" in e && e.id)
      return {
        name: e.id.name,
        originalNode: e.id
      };
    let r = "", i;
    if ((0, Wi.isObjectProperty)(t, {
      value: e
    }) ? i = TR(t) : (0, Wi.isObjectMethod)(e) || (0, Wi.isClassMethod)(e) ? (i = TR(e), e.kind === "get" ? r = "get " : e.kind === "set" &&
    (r = "set ")) : (0, Wi.isVariableDeclarator)(t, {
      init: e
    }) ? i = t.id : (0, Wi.isAssignmentExpression)(t, {
      operator: "=",
      right: e
    }) && (i = t.left), !i) return null;
    let s = (0, Wi.isLiteral)(i) ? s_e(i) : (0, Wi.isIdentifier)(i) ? i.name : (0, Wi.isPrivateName)(i) ? i.id.name : null;
    return s == null ? null : {
      name: r + s,
      originalNode: i
    };
  }
  n(n_e, "getFunctionName");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var wR = E((qS) => {
  "use strict";
  Object.defineProperty(qS, "__esModule", {
    value: !0
  });
  qS.default = o_e;
  var a_e = Vi();
  function o_e(e, t, r) {
    typeof t == "function" && (t = {
      enter: t
    });
    let {
      enter: i,
      exit: s
    } = t;
    jS(e, i, s, r, []);
  }
  n(o_e, "traverse");
  function jS(e, t, r, i, s) {
    let a = a_e.VISITOR_KEYS[e.type];
    if (a) {
      t && t(e, s, i);
      for (let o of a) {
        let u = e[o];
        if (Array.isArray(u))
          for (let l = 0; l < u.length; l++) {
            let c = u[l];
            c && (s.push({
              node: e,
              key: o,
              index: l
            }), jS(c, t, r, i, s), s.pop());
          }
        else u && (s.push({
          node: e,
          key: o
        }), jS(u, t, r, i, s), s.pop());
      }
      r && r(e, s, i);
    }
  }
  n(jS, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var AR = E((US) => {
  "use strict";
  Object.defineProperty(US, "__esModule", {
    value: !0
  });
  US.default = l_e;
  var u_e = Id();
  function l_e(e, t, r) {
    if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let i = u_e.default.keys[t.type];
    if (i)
      for (let s = 0; s < i.length; s++) {
        let a = i[s], o = t[a];
        if (Array.isArray(o)) {
          if (o.includes(e)) return !0;
        } else if (o === e) return !0;
      }
    return !1;
  }
  n(l_e, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var VS = E(($S) => {
  "use strict";
  Object.defineProperty($S, "__esModule", {
    value: !0
  });
  $S.default = f_e;
  var c_e = Jt();
  _R = Symbol.for("var used to be block scoped");
  var _R;
  function f_e(e) {
    return (0, c_e.isVariableDeclaration)(e) && (e.kind !== "var" || e[_R]);
  }
  n(f_e, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var FR = E((WS) => {
  "use strict";
  Object.defineProperty(WS, "__esModule", {
    value: !0
  });
  WS.default = p_e;
  var PR = Jt(), d_e = VS();
  function p_e(e) {
    return (0, PR.isFunctionDeclaration)(e) || (0, PR.isClassDeclaration)(e) || (0, d_e.default)(e);
  }
  n(p_e, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var IR = E((HS) => {
  "use strict";
  Object.defineProperty(HS, "__esModule", {
    value: !0
  });
  HS.default = y_e;
  var h_e = Cm(), m_e = Jt();
  function y_e(e) {
    return (0, h_e.default)(e.type, "Immutable") ? !0 : (0, m_e.isIdentifier)(e) ? e.name === "undefined" : !1;
  }
  n(y_e, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var kR = E((zS) => {
  "use strict";
  Object.defineProperty(zS, "__esModule", {
    value: !0
  });
  zS.default = KS;
  var OR = Vi();
  function KS(e, t) {
    if (typeof e != "object" || typeof t != "object" || e == null || t == null)
      return e === t;
    if (e.type !== t.type)
      return !1;
    let r = Object.keys(OR.NODE_FIELDS[e.type] || e.type), i = OR.VISITOR_KEYS[e.type];
    for (let s of r) {
      let a = e[s], o = t[s];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let u = 0; u < a.length; u++)
            if (!KS(a[u], o[u]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(i != null && i.includes(s))) {
          for (let u of Object.keys(a))
            if (a[u] !== o[u])
              return !1;
          continue;
        }
        if (!KS(a, o))
          return !1;
      }
    }
    return !0;
  }
  n(KS, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var BR = E((JS) => {
  "use strict";
  Object.defineProperty(JS, "__esModule", {
    value: !0
  });
  JS.default = g_e;
  function g_e(e, t, r) {
    switch (t.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return t.property === e ? !!t.computed : t.object === e;
      case "JSXMemberExpression":
        return t.object === e;
      case "VariableDeclarator":
        return t.init === e;
      case "ArrowFunctionExpression":
        return t.body === e;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return t.key === e ? !!t.computed : !1;
      case "ObjectProperty":
        return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return t.key === e ? !!t.computed : !0;
      case "ClassPrivateProperty":
        return t.key !== e;
      case "ClassDeclaration":
      case "ClassExpression":
        return t.superClass === e;
      case "AssignmentExpression":
        return t.right === e;
      case "AssignmentPattern":
        return t.right === e;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : t.local === e;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return t.key !== e;
      case "TSEnumMember":
        return t.id !== e;
      case "TSPropertySignature":
        return t.key === e ? !!t.computed : !0;
    }
    return !0;
  }
  n(g_e, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var NR = E((XS) => {
  "use strict";
  Object.defineProperty(XS, "__esModule", {
    value: !0
  });
  XS.default = b_e;
  var qo = Jt();
  function b_e(e, t) {
    return (0, qo.isBlockStatement)(e) && ((0, qo.isFunction)(t) || (0, qo.isCatchClause)(t)) ? !1 : (0, qo.isPattern)(e) && ((0, qo.isFunction)(
    t) || (0, qo.isCatchClause)(t)) ? !0 : (0, qo.isScopable)(e);
  }
  n(b_e, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var RR = E((YS) => {
  "use strict";
  Object.defineProperty(YS, "__esModule", {
    value: !0
  });
  YS.default = D_e;
  var MR = Jt();
  function D_e(e) {
    return (0, MR.isImportDefaultSpecifier)(e) || (0, MR.isIdentifier)(e.imported || e.exported, {
      name: "default"
    });
  }
  n(D_e, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var LR = E((GS) => {
  "use strict";
  Object.defineProperty(GS, "__esModule", {
    value: !0
  });
  GS.default = E_e;
  var v_e = kl(), x_e = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "impleme\
nts", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "trans\
ient", "volatile"]);
  function E_e(e) {
    return (0, v_e.default)(e) && !x_e.has(e);
  }
  n(E_e, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var qR = E((ZS) => {
  "use strict";
  Object.defineProperty(ZS, "__esModule", {
    value: !0
  });
  ZS.default = T_e;
  var S_e = Jt();
  jR = Symbol.for("var used to be block scoped");
  var jR;
  function T_e(e) {
    return (0, S_e.isVariableDeclaration)(e, {
      kind: "var"
    }) && !e[jR];
  }
  n(T_e, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var UR = E((tT) => {
  "use strict";
  Object.defineProperty(tT, "__esModule", {
    value: !0
  });
  tT.default = Wm;
  var C_e = Id(), Uo = Jt(), QS = hi(), eT = YE(), w_e = Ia();
  function Wm(e, t) {
    let r = [], i = !0;
    for (let s of e)
      if ((0, Uo.isEmptyStatement)(s) || (i = !1), (0, Uo.isExpression)(s))
        r.push(s);
      else if ((0, Uo.isExpressionStatement)(s))
        r.push(s.expression);
      else if ((0, Uo.isVariableDeclaration)(s)) {
        if (s.kind !== "var") return;
        for (let a of s.declarations) {
          let o = (0, C_e.default)(a);
          for (let u of Object.keys(o))
            t.push({
              kind: s.kind,
              id: (0, w_e.default)(o[u])
            });
          a.init && r.push((0, QS.assignmentExpression)("=", a.id, a.init));
        }
        i = !0;
      } else if ((0, Uo.isIfStatement)(s)) {
        let a = s.consequent ? Wm([s.consequent], t) : (0, eT.buildUndefinedNode)(), o = s.alternate ? Wm([s.alternate], t) : (0, eT.buildUndefinedNode)();
        if (!a || !o) return;
        r.push((0, QS.conditionalExpression)(s.test, a, o));
      } else if ((0, Uo.isBlockStatement)(s)) {
        let a = Wm(s.body, t);
        if (!a) return;
        r.push(a);
      } else if ((0, Uo.isEmptyStatement)(s))
        e.indexOf(s) === 0 && (i = !0);
      else
        return;
    return i && r.push((0, eT.buildUndefinedNode)()), r.length === 1 ? r[0] : (0, QS.sequenceExpression)(r);
  }
  n(Wm, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var $R = E((rT) => {
  "use strict";
  Object.defineProperty(rT, "__esModule", {
    value: !0
  });
  rT.default = __e;
  var A_e = UR();
  function __e(e, t) {
    if (!(e != null && e.length)) return;
    let r = [], i = (0, A_e.default)(e, r);
    if (i) {
      for (let s of r)
        t.push(s);
      return i;
    }
  }
  n(__e, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var Pe = E((ae) => {
  "use strict";
  Object.defineProperty(ae, "__esModule", {
    value: !0
  });
  var Oa = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getAssignmentIdentifiers: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    getFunctionName: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(ae, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return O3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return q_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return U_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return r3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return O_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return I3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return M_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return R_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return L_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return N_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return j_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return VR.default;
    }, "get")
  });
  Object.defineProperty(ae, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return B_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return k_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return VR.default;
    }, "get")
  });
  Object.defineProperty(ae, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return z_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "getAssignmentIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return u3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return l3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "getFunctionName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return f3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return c3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return V_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return H_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return i3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return W_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return h3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return m3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return y3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return g3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return b3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return D3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return v3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return x3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return E3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return S3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return T3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return C3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return w3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return A3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return _3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return P3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return s3e.default;
    }, "get")
  });
  ae.react = void 0;
  Object.defineProperty(ae, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return K_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return n3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return a3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return o3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return p3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return J_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return X_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Y_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return G_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Z_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Q_e.default;
    }, "get")
  });
  Object.defineProperty(ae, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return e3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Hm.default;
    }, "get")
  });
  Object.defineProperty(ae, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return d3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return F3e.default;
    }, "get")
  });
  Object.defineProperty(ae, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return t3e.default;
    }, "get")
  });
  var P_e = KN(), F_e = zN(), I_e = LM(), O_e = jM(), iT = qM();
  Object.keys(iT).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Oa, e) || e in ae && ae[e] === iT[e] || Object.defineProperty(
    ae, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return iT[e];
      }, "get")
    });
  });
  var k_e = UM(), VR = WM(), B_e = JM(), sT = YE();
  Object.keys(sT).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Oa, e) || e in ae && ae[e] === sT[e] || Object.defineProperty(
    ae, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return sT[e];
      }, "get")
    });
  });
  var nT = hi();
  Object.keys(nT).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Oa, e) || e in ae && ae[e] === nT[e] || Object.defineProperty(
    ae, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return nT[e];
      }, "get")
    });
  });
  var N_e = Ia(), M_e = eR(), R_e = tR(), L_e = rR(), j_e = iR(), q_e = sR(), U_e = sS(), $_e = uS(), V_e = cS(), W_e = hS(), H_e = dS(), K_e = nR(),
  aT = aR();
  Object.keys(aT).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Oa, e) || e in ae && ae[e] === aT[e] || Object.defineProperty(
    ae, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return aT[e];
      }, "get")
    });
  });
  var oT = Bl();
  Object.keys(oT).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Oa, e) || e in ae && ae[e] === oT[e] || Object.defineProperty(
    ae, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return oT[e];
      }, "get")
    });
  });
  var z_e = oR(), J_e = uR(), X_e = bS(), Y_e = lR(), G_e = cR(), Z_e = xS(), Q_e = mR(), e3e = yR(), t3e = gR(), uT = Vi();
  Object.keys(uT).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Oa, e) || e in ae && ae[e] === uT[e] || Object.defineProperty(
    ae, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return uT[e];
      }, "get")
    });
  });
  var r3e = bR(), i3e = vR(), s3e = xR(), n3e = AS(), a3e = PS(), o3e = HE(), u3e = ER(), l3e = Id(), c3e = SR(), f3e = CR(), Hm = wR();
  Object.keys(Hm).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Oa, e) || e in ae && ae[e] === Hm[e] || Object.defineProperty(
    ae, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return Hm[e];
      }, "get")
    });
  });
  var d3e = CS(), p3e = Sm(), h3e = Il(), m3e = AR(), y3e = FR(), g3e = IR(), b3e = VS(), D3e = $E(), v3e = kR(), x3e = dE(), E3e = BR(), S3e = NR(),
  T3e = RR(), C3e = Cm(), w3e = LR(), A3e = kl(), _3e = qR(), P3e = aE(), F3e = Pm(), I3e = uE(), lT = Jt();
  Object.keys(lT).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Oa, e) || e in ae && ae[e] === lT[e] || Object.defineProperty(
    ae, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return lT[e];
      }, "get")
    });
  });
  var O3e = Fl(), k3e = $R(), Kmt = ae.react = {
    isReactComponent: P_e.default,
    isCompatTag: F_e.default,
    buildChildren: I_e.default
  };
  ae.toSequenceExpression = k3e.default;
  process.env.BABEL_TYPES_8_BREAKING && console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-releas\
e instead!");
});

// ../node_modules/@babel/template/lib/formatters.js
var WR = E((Hi) => {
  "use strict";
  Object.defineProperty(Hi, "__esModule", {
    value: !0
  });
  Hi.statements = Hi.statement = Hi.smart = Hi.program = Hi.expression = void 0;
  var B3e = Pe(), {
    assertExpressionStatement: N3e
  } = B3e;
  function cT(e) {
    return {
      code: /* @__PURE__ */ n((t) => `/* @babel/template */;
${t}`, "code"),
      validate: /* @__PURE__ */ n(() => {
      }, "validate"),
      unwrap: /* @__PURE__ */ n((t) => e(t.program.body.slice(1)), "unwrap")
    };
  }
  n(cT, "makeStatementFormatter");
  var Xmt = Hi.smart = cT((e) => e.length > 1 ? e : e[0]), Ymt = Hi.statements = cT((e) => e), Gmt = Hi.statement = cT((e) => {
    if (e.length === 0)
      throw new Error("Found nothing to return.");
    if (e.length > 1)
      throw new Error("Found multiple statements but wanted one");
    return e[0];
  }), M3e = Hi.expression = {
    code: /* @__PURE__ */ n((e) => `(
${e}
)`, "code"),
    validate: /* @__PURE__ */ n((e) => {
      if (e.program.body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      if (M3e.unwrap(e).start === 0)
        throw new Error("Parse result included parens.");
    }, "validate"),
    unwrap: /* @__PURE__ */ n(({
      program: e
    }) => {
      let [t] = e.body;
      return N3e(t), t.expression;
    }, "unwrap")
  }, Zmt = Hi.program = {
    code: /* @__PURE__ */ n((e) => e, "code"),
    validate: /* @__PURE__ */ n(() => {
    }, "validate"),
    unwrap: /* @__PURE__ */ n((e) => e.program, "unwrap")
  };
});

// ../node_modules/@babel/template/lib/options.js
var Km = E((Od) => {
  "use strict";
  Object.defineProperty(Od, "__esModule", {
    value: !0
  });
  Od.merge = j3e;
  Od.normalizeReplacements = U3e;
  Od.validate = q3e;
  var R3e = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function L3e(e, t) {
    if (e == null) return {};
    var r = {};
    for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) !== -1) continue;
      r[i] = e[i];
    }
    return r;
  }
  n(L3e, "_objectWithoutPropertiesLoose");
  function j3e(e, t) {
    let {
      placeholderWhitelist: r = e.placeholderWhitelist,
      placeholderPattern: i = e.placeholderPattern,
      preserveComments: s = e.preserveComments,
      syntacticPlaceholders: a = e.syntacticPlaceholders
    } = t;
    return {
      parser: Object.assign({}, e.parser, t.parser),
      placeholderWhitelist: r,
      placeholderPattern: i,
      preserveComments: s,
      syntacticPlaceholders: a
    };
  }
  n(j3e, "merge");
  function q3e(e) {
    if (e != null && typeof e != "object")
      throw new Error("Unknown template options.");
    let t = e || {}, {
      placeholderWhitelist: r,
      placeholderPattern: i,
      preserveComments: s,
      syntacticPlaceholders: a
    } = t, o = L3e(t, R3e);
    if (r != null && !(r instanceof Set))
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (i != null && !(i instanceof RegExp) && i !== !1)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (s != null && typeof s != "boolean")
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (a != null && typeof a != "boolean")
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (a === !0 && (r != null || i != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: o,
      placeholderWhitelist: r || void 0,
      placeholderPattern: i ?? void 0,
      preserveComments: s ?? void 0,
      syntacticPlaceholders: a ?? void 0
    };
  }
  n(q3e, "validate");
  function U3e(e) {
    if (Array.isArray(e))
      return e.reduce((t, r, i) => (t["$" + i] = r, t), {});
    if (typeof e == "object" || e == null)
      return e || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  n(U3e, "normalizeReplacements");
});

// ../node_modules/@babel/parser/lib/index.js
var Ho = E(($d) => {
  "use strict";
  Object.defineProperty($d, "__esModule", {
    value: !0
  });
  function $3e(e, t) {
    if (e == null) return {};
    var r = {};
    for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) !== -1) continue;
      r[i] = e[i];
    }
    return r;
  }
  n($3e, "_objectWithoutPropertiesLoose");
  var tn = class {
    static {
      n(this, "Position");
    }
    constructor(t, r, i) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = i;
    }
  }, Vl = class {
    static {
      n(this, "SourceLocation");
    }
    constructor(t, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
    }
  };
  function si(e, t) {
    let {
      line: r,
      column: i,
      index: s
    } = e;
    return new tn(r, i + t, s + t);
  }
  n(si, "createPositionWithColumnOffset");
  var HR = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", V3e = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: HR
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: HR
    }
  }, KR = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, Xm = /* @__PURE__ */ n((e) => e.type === "UpdateExpression" ? KR.UpdateExpression[`${e.prefix}`] : KR[e.type], "toNodeDescription"), W3e = {
    AccessorIsGenerator: /* @__PURE__ */ n(({
      kind: e
    }) => `A ${e}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ n(({
      kind: e
    }) => `Missing initializer in ${e} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ n(({
      exportName: e
    }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ n(({
      localName: e,
      exportName: t
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ n(({
      type: e
    }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ n(({
      type: e
    }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ n(({
      importName: e
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ n(({
      radix: e
    }) => `Expected number in radix ${e}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ n(({
      reservedWord: e
    }) => `Escape sequence in keyword ${e}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ n(({
      identifierName: e
    }) => `Invalid identifier ${e}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ n(({
      ancestor: e
    }) => `Invalid left-hand side in ${Xm(e)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ n(({
      ancestor: e
    }) => `Binding invalid left-hand side in ${Xm(e)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ n(({
      ancestor: e
    }) => `Invalid optional chaining in the left-hand side of ${Xm(e)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ n(({
      unexpected: e
    }) => `Unexpected character '${e}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ n(({
      identifierName: e
    }) => `Private name #${e} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ n(({
      labelName: e
    }) => `Label '${e}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ n(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ n(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ n(({
      key: e
    }) => `Duplicate key "${e}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ n(({
      surrogateCharCode: e
    }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ n(({
      localName: e
    }) => `Export '${e}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ n(({
      identifierName: e
    }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ n(({
      identifierName: e
    }) => `Duplicate private name #${e}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ n(({
      keyword: e
    }) => `Unexpected keyword '${e}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ n(({
      reservedWord: e
    }) => `Unexpected reserved word '${e}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ n(({
      expected: e,
      unexpected: t
    }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement\
.",
    UnexpectedVoidPattern: "Unexpected void binding.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ n(({
      target: e,
      onlyValidPropertyName: t
    }) => `The only valid meta property for ${e} is ${e}.${t}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ n(({
      identifierName: e
    }) => `Identifier '${e}' has already been declared.`, "VarRedeclaration"),
    VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to disca\
rd the caught error.",
    VoidPatternInitializer: "A void binding may not have an initializer.",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, H3e = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ n(({
      referenceName: e
    }) => `Assigning to '${e}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ n(({
      bindingName: e
    }) => `Binding '${e}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, K3e = {
    ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.",
    ParseExpressionExpectsEOF: /* @__PURE__ */ n(({
      unexpected: e
    }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the \
unexpected character \`${String.fromCodePoint(e)}\`.`, "ParseExpressionExpectsEOF")
  }, z3e = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), J3e = Object.
  assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ n(({
      token: e
    }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${e}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ n(({
      type: e
    }) => `Hack-style pipe body cannot be an unparenthesized ${Xm({
      type: e
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody")
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }), X3e = ["message"];
  function zR(e, t, r) {
    Object.defineProperty(e, t, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  n(zR, "defineHidden");
  function Y3e({
    toMessage: e,
    code: t,
    reasonCode: r,
    syntaxPlugin: i
  }) {
    let s = r === "MissingPlugin" || r === "MissingOneOfPlugins";
    {
      let a = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumRefer\
ence",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      a[r] && (r = a[r]);
    }
    return /* @__PURE__ */ n(function a(o, u) {
      let l = new SyntaxError();
      return l.code = t, l.reasonCode = r, l.loc = o, l.pos = o.index, l.syntaxPlugin = i, s && (l.missingPlugin = u.missingPlugin), zR(l, "\
clone", /* @__PURE__ */ n(function(f = {}) {
        var m;
        let {
          line: h,
          column: d,
          index: y
        } = (m = f.loc) != null ? m : o;
        return a(new tn(h, d, y), Object.assign({}, u, f.details));
      }, "clone")), zR(l, "details", u), Object.defineProperty(l, "message", {
        configurable: !0,
        get() {
          let c = `${e(u)} (${o.line}:${o.column})`;
          return this.message = c, c;
        },
        set(c) {
          Object.defineProperty(this, "message", {
            value: c,
            writable: !0
          });
        }
      }), l;
    }, "constructor");
  }
  n(Y3e, "toParseErrorConstructor");
  function Qs(e, t) {
    if (Array.isArray(e))
      return (i) => Qs(i, e[0]);
    let r = {};
    for (let i of Object.keys(e)) {
      let s = e[i], a = typeof s == "string" ? {
        message: /* @__PURE__ */ n(() => s, "message")
      } : typeof s == "function" ? {
        message: s
      } : s, {
        message: o
      } = a, u = $3e(a, X3e), l = typeof o == "string" ? () => o : o;
      r[i] = Y3e(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: i,
        toMessage: l
      }, t ? {
        syntaxPlugin: t
      } : {}, u));
    }
    return r;
  }
  n(Qs, "ParseErrorEnum");
  var R = Object.assign({}, Qs(V3e), Qs(W3e), Qs(H3e), Qs(K3e), Qs`pipelineOperator`(J3e));
  function G3e() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      allowYieldOutsideFunction: !1,
      plugins: [],
      strictMode: void 0,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  n(G3e, "createDefaultOptions");
  function Z3e(e) {
    let t = G3e();
    if (e == null)
      return t;
    if (e.annexB != null && e.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (let r of Object.keys(t))
      e[r] != null && (t[r] = e[r]);
    if (t.startLine === 1)
      e.startIndex == null && t.startColumn > 0 ? t.startIndex = t.startColumn : e.startColumn == null && t.startIndex > 0 && (t.startColumn =
      t.startIndex);
    else if ((e.startColumn == null || e.startIndex == null) && e.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    if (t.sourceType === "commonjs") {
      if (e.allowAwaitOutsideFunction != null)
        throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
      if (e.allowReturnOutsideFunction != null)
        throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction`\
 option or use `sourceType: 'script'`.");
      if (e.allowNewTargetOutsideFunction != null)
        throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFun\
ction` option or use `sourceType: 'script'`.");
    }
    return t;
  }
  n(Z3e, "getOptions");
  var {
    defineProperty: Q3e
  } = Object, JR = /* @__PURE__ */ n((e, t) => {
    e && Q3e(e, t, {
      enumerable: !1,
      value: e[t]
    });
  }, "toUnenumerable");
  function kd(e) {
    return JR(e.loc.start, "index"), JR(e.loc.end, "index"), e;
  }
  n(kd, "toESTreeLocation");
  var ePe = /* @__PURE__ */ n((e) => class extends e {
    static {
      n(this, "ESTreeParserMixin");
    }
    parse() {
      let r = kd(super.parse());
      return this.optionFlags & 256 && (r.tokens = r.tokens.map(kd)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: i
    }) {
      let s = null;
      try {
        s = new RegExp(r, i);
      } catch {
      }
      let a = this.estreeParseLiteral(s);
      return a.regex = {
        pattern: r,
        flags: i
      }, a;
    }
    parseBigIntLiteral(r) {
      let i;
      try {
        i = BigInt(r);
      } catch {
        i = null;
      }
      let s = this.estreeParseLiteral(i);
      return s.bigint = String(s.value || r), s;
    }
    parseDecimalLiteral(r) {
      let s = this.estreeParseLiteral(null);
      return s.decimal = String(s.value || r), s;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    estreeParseChainExpression(r, i) {
      let s = this.startNodeAtNode(r);
      return s.expression = r, this.finishNodeAt(s, "ChainExpression", i);
    }
    directiveToStmt(r) {
      let i = r.value;
      delete r.value, this.castNodeTo(i, "Literal"), i.raw = i.extra.raw, i.value = i.extra.expressionValue;
      let s = this.castNodeTo(r, "ExpressionStatement");
      return s.expression = i, s.directive = i.extra.rawValue, delete i.extra, s;
    }
    fillOptionalPropertiesForTSESLint(r) {
    }
    cloneEstreeStringLiteral(r) {
      let {
        start: i,
        end: s,
        loc: a,
        range: o,
        raw: u,
        value: l
      } = r, c = Object.create(r.constructor.prototype);
      return c.type = "Literal", c.start = i, c.end = s, c.loc = a, c.range = o, c.raw = u, c.value = l, c;
    }
    initFunction(r, i) {
      super.initFunction(r, i), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var i;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((i = r.expression.
      extra) != null && i.parenthesized);
    }
    parseBlockBody(r, i, s, a, o) {
      super.parseBlockBody(r, i, s, a, o);
      let u = r.directives.map((l) => this.directiveToStmt(l));
      r.body = u.concat(r.body), delete r.directives;
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let i = super.getPrivateNameSV(r);
      return delete r.id, r.name = i, this.castNodeTo(r, "PrivateIdentifier");
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, i) {
      let s = super.parseLiteral(r, i);
      return s.raw = s.extra.raw, delete s.extra, s;
    }
    parseFunctionBody(r, i, s = !1) {
      super.parseFunctionBody(r, i, s), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, i, s, a, o, u, l = !1) {
      let c = this.startNode();
      c.kind = r.kind, c = super.parseMethod(c, i, s, a, o, u, l), delete c.kind;
      let {
        typeParameters: f
      } = r;
      f && (delete r.typeParameters, c.typeParameters = f, this.resetStartLocationFromNode(c, f));
      let m = this.castNodeTo(c, "FunctionExpression");
      return r.value = m, u === "ClassPrivateMethod" && (r.computed = !1), u === "ObjectMethod" ? (r.kind === "method" && (r.kind = "init"),
      r.shorthand = !1, this.finishNode(r, "Property")) : this.finishNode(r, "MethodDefinition");
    }
    nameIsConstructor(r) {
      return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
    }
    parseClassProperty(...r) {
      let i = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && this.castNodeTo(i, "PropertyDefinition"), i;
    }
    parseClassPrivateProperty(...r) {
      let i = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (this.castNodeTo(i, "PropertyDefinition"), i.computed = !1), i;
    }
    parseClassAccessorProperty(r) {
      let i = super.parseClassAccessorProperty(r);
      return this.getPluginOption("estree", "classFeatures") && (i.abstract && this.hasPlugin("typescript") ? (delete i.abstract, this.castNodeTo(
      i, "TSAbstractAccessorProperty")) : this.castNodeTo(i, "AccessorProperty")), i;
    }
    parseObjectProperty(r, i, s, a) {
      let o = super.parseObjectProperty(r, i, s, a);
      return o && (o.kind = "init", this.castNodeTo(o, "Property")), o;
    }
    finishObjectProperty(r) {
      return r.kind = "init", this.finishNode(r, "Property");
    }
    isValidLVal(r, i, s, a) {
      return r === "Property" ? "value" : super.isValidLVal(r, i, s, a);
    }
    isAssignable(r, i) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: s,
          value: a
        } = r;
        this.isPrivateName(s) && this.classScope.usePrivateName(this.getPrivateNameSV(s), s.loc.start), this.toAssignable(a, i);
      } else
        super.toAssignable(r, i);
    }
    toAssignableObjectExpressionProp(r, i, s) {
      r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(R.PatternHasAccessor, r.key) : r.type === "Property" && r.
      method ? this.raise(R.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, i, s);
    }
    finishCallExpression(r, i) {
      let s = super.finishCallExpression(r, i);
      if (s.callee.type === "Import") {
        var a;
        this.castNodeTo(s, "ImportExpression"), s.source = s.arguments[0], s.options = (a = s.arguments[1]) != null ? a : null;
        {
          var o;
          s.attributes = (o = s.arguments[1]) != null ? o : null;
        }
        delete s.arguments, delete s.callee;
      } else s.type === "OptionalCallExpression" ? this.castNodeTo(s, "CallExpression") : s.optional = !1;
      return s;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, i) {
      let s = this.state.lastTokStartLoc, a = super.parseExport(r, i);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (this.castNodeTo(a, "ExportAllDeclaration"), a.
          exported = a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: u
            } = a;
            u?.type === "ClassDeclaration" && ((o = u.decorators) == null ? void 0 : o.length) > 0 && u.start === a.start && this.resetStartLocation(
            a, s);
          }
          break;
      }
      return a;
    }
    stopParseSubscript(r, i) {
      let s = super.stopParseSubscript(r, i);
      return i.optionalChainMember ? this.estreeParseChainExpression(s, r.loc.end) : s;
    }
    parseMember(r, i, s, a, o) {
      let u = super.parseMember(r, i, s, a, o);
      return u.type === "OptionalMemberExpression" ? this.castNodeTo(u, "MemberExpression") : u.optional = !1, u;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
    }
    castNodeTo(r, i) {
      let s = super.castNodeTo(r, i);
      return this.fillOptionalPropertiesForTSESLint(s), s;
    }
    cloneIdentifier(r) {
      let i = super.cloneIdentifier(r);
      return this.fillOptionalPropertiesForTSESLint(i), i;
    }
    cloneStringLiteral(r) {
      return r.type === "Literal" ? this.cloneEstreeStringLiteral(r) : super.cloneStringLiteral(r);
    }
    finishNodeAt(r, i, s) {
      return kd(super.finishNodeAt(r, i, s));
    }
    finishNode(r, i) {
      let s = super.finishNode(r, i);
      return this.fillOptionalPropertiesForTSESLint(s), s;
    }
    resetStartLocation(r, i) {
      super.resetStartLocation(r, i), kd(r);
    }
    resetEndLocation(r, i = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, i), kd(r);
    }
  }, "estree"), Vo = class {
    static {
      n(this, "TokContext");
    }
    constructor(t, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
    }
  }, at = {
    brace: new Vo("{"),
    j_oTag: new Vo("<tag"),
    j_cTag: new Vo("</tag"),
    j_expr: new Vo("<tag>...</tag>", !0)
  };
  at.template = new Vo("`", !0);
  var Ke = !0, fe = !0, fT = !0, Bd = !0, ka = !0, tPe = !0, Zm = class {
    static {
      n(this, "ExportedTokenType");
    }
    constructor(t, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, LT = /* @__PURE__ */ new Map();
  function rt(e, t = {}) {
    t.keyword = e;
    let r = Ee(e, t);
    return LT.set(e, r), r;
  }
  n(rt, "createKeyword");
  function ii(e, t) {
    return Ee(e, {
      beforeExpr: Ke,
      binop: t
    });
  }
  n(ii, "createBinop");
  var Ld = -1, Rn = [], jT = [], qT = [], UT = [], $T = [], VT = [];
  function Ee(e, t = {}) {
    var r, i, s, a;
    return ++Ld, jT.push(e), qT.push((r = t.binop) != null ? r : -1), UT.push((i = t.beforeExpr) != null ? i : !1), $T.push((s = t.startsExpr) !=
    null ? s : !1), VT.push((a = t.prefix) != null ? a : !1), Rn.push(new Zm(e, t)), Ld;
  }
  n(Ee, "createToken");
  function Je(e, t = {}) {
    var r, i, s, a;
    return ++Ld, LT.set(e, Ld), jT.push(e), qT.push((r = t.binop) != null ? r : -1), UT.push((i = t.beforeExpr) != null ? i : !1), $T.push((s =
    t.startsExpr) != null ? s : !1), VT.push((a = t.prefix) != null ? a : !1), Rn.push(new Zm("name", t)), Ld;
  }
  n(Je, "createKeywordLike");
  var rPe = {
    bracketL: Ee("[", {
      beforeExpr: Ke,
      startsExpr: fe
    }),
    bracketHashL: Ee("#[", {
      beforeExpr: Ke,
      startsExpr: fe
    }),
    bracketBarL: Ee("[|", {
      beforeExpr: Ke,
      startsExpr: fe
    }),
    bracketR: Ee("]"),
    bracketBarR: Ee("|]"),
    braceL: Ee("{", {
      beforeExpr: Ke,
      startsExpr: fe
    }),
    braceBarL: Ee("{|", {
      beforeExpr: Ke,
      startsExpr: fe
    }),
    braceHashL: Ee("#{", {
      beforeExpr: Ke,
      startsExpr: fe
    }),
    braceR: Ee("}"),
    braceBarR: Ee("|}"),
    parenL: Ee("(", {
      beforeExpr: Ke,
      startsExpr: fe
    }),
    parenR: Ee(")"),
    comma: Ee(",", {
      beforeExpr: Ke
    }),
    semi: Ee(";", {
      beforeExpr: Ke
    }),
    colon: Ee(":", {
      beforeExpr: Ke
    }),
    doubleColon: Ee("::", {
      beforeExpr: Ke
    }),
    dot: Ee("."),
    question: Ee("?", {
      beforeExpr: Ke
    }),
    questionDot: Ee("?."),
    arrow: Ee("=>", {
      beforeExpr: Ke
    }),
    template: Ee("template"),
    ellipsis: Ee("...", {
      beforeExpr: Ke
    }),
    backQuote: Ee("`", {
      startsExpr: fe
    }),
    dollarBraceL: Ee("${", {
      beforeExpr: Ke,
      startsExpr: fe
    }),
    templateTail: Ee("...`", {
      startsExpr: fe
    }),
    templateNonTail: Ee("...${", {
      beforeExpr: Ke,
      startsExpr: fe
    }),
    at: Ee("@"),
    hash: Ee("#", {
      startsExpr: fe
    }),
    interpreterDirective: Ee("#!..."),
    eq: Ee("=", {
      beforeExpr: Ke,
      isAssign: Bd
    }),
    assign: Ee("_=", {
      beforeExpr: Ke,
      isAssign: Bd
    }),
    slashAssign: Ee("_=", {
      beforeExpr: Ke,
      isAssign: Bd
    }),
    xorAssign: Ee("_=", {
      beforeExpr: Ke,
      isAssign: Bd
    }),
    moduloAssign: Ee("_=", {
      beforeExpr: Ke,
      isAssign: Bd
    }),
    incDec: Ee("++/--", {
      prefix: ka,
      postfix: tPe,
      startsExpr: fe
    }),
    bang: Ee("!", {
      beforeExpr: Ke,
      prefix: ka,
      startsExpr: fe
    }),
    tilde: Ee("~", {
      beforeExpr: Ke,
      prefix: ka,
      startsExpr: fe
    }),
    doubleCaret: Ee("^^", {
      startsExpr: fe
    }),
    doubleAt: Ee("@@", {
      startsExpr: fe
    }),
    pipeline: ii("|>", 0),
    nullishCoalescing: ii("??", 1),
    logicalOR: ii("||", 1),
    logicalAND: ii("&&", 2),
    bitwiseOR: ii("|", 3),
    bitwiseXOR: ii("^", 4),
    bitwiseAND: ii("&", 5),
    equality: ii("==/!=/===/!==", 6),
    lt: ii("</>/<=/>=", 7),
    gt: ii("</>/<=/>=", 7),
    relational: ii("</>/<=/>=", 7),
    bitShift: ii("<</>>/>>>", 8),
    bitShiftL: ii("<</>>/>>>", 8),
    bitShiftR: ii("<</>>/>>>", 8),
    plusMin: Ee("+/-", {
      beforeExpr: Ke,
      binop: 9,
      prefix: ka,
      startsExpr: fe
    }),
    modulo: Ee("%", {
      binop: 10,
      startsExpr: fe
    }),
    star: Ee("*", {
      binop: 10
    }),
    slash: ii("/", 10),
    exponent: Ee("**", {
      beforeExpr: Ke,
      binop: 11,
      rightAssociative: !0
    }),
    _in: rt("in", {
      beforeExpr: Ke,
      binop: 7
    }),
    _instanceof: rt("instanceof", {
      beforeExpr: Ke,
      binop: 7
    }),
    _break: rt("break"),
    _case: rt("case", {
      beforeExpr: Ke
    }),
    _catch: rt("catch"),
    _continue: rt("continue"),
    _debugger: rt("debugger"),
    _default: rt("default", {
      beforeExpr: Ke
    }),
    _else: rt("else", {
      beforeExpr: Ke
    }),
    _finally: rt("finally"),
    _function: rt("function", {
      startsExpr: fe
    }),
    _if: rt("if"),
    _return: rt("return", {
      beforeExpr: Ke
    }),
    _switch: rt("switch"),
    _throw: rt("throw", {
      beforeExpr: Ke,
      prefix: ka,
      startsExpr: fe
    }),
    _try: rt("try"),
    _var: rt("var"),
    _const: rt("const"),
    _with: rt("with"),
    _new: rt("new", {
      beforeExpr: Ke,
      startsExpr: fe
    }),
    _this: rt("this", {
      startsExpr: fe
    }),
    _super: rt("super", {
      startsExpr: fe
    }),
    _class: rt("class", {
      startsExpr: fe
    }),
    _extends: rt("extends", {
      beforeExpr: Ke
    }),
    _export: rt("export"),
    _import: rt("import", {
      startsExpr: fe
    }),
    _null: rt("null", {
      startsExpr: fe
    }),
    _true: rt("true", {
      startsExpr: fe
    }),
    _false: rt("false", {
      startsExpr: fe
    }),
    _typeof: rt("typeof", {
      beforeExpr: Ke,
      prefix: ka,
      startsExpr: fe
    }),
    _void: rt("void", {
      beforeExpr: Ke,
      prefix: ka,
      startsExpr: fe
    }),
    _delete: rt("delete", {
      beforeExpr: Ke,
      prefix: ka,
      startsExpr: fe
    }),
    _do: rt("do", {
      isLoop: fT,
      beforeExpr: Ke
    }),
    _for: rt("for", {
      isLoop: fT
    }),
    _while: rt("while", {
      isLoop: fT
    }),
    _as: Je("as", {
      startsExpr: fe
    }),
    _assert: Je("assert", {
      startsExpr: fe
    }),
    _async: Je("async", {
      startsExpr: fe
    }),
    _await: Je("await", {
      startsExpr: fe
    }),
    _defer: Je("defer", {
      startsExpr: fe
    }),
    _from: Je("from", {
      startsExpr: fe
    }),
    _get: Je("get", {
      startsExpr: fe
    }),
    _let: Je("let", {
      startsExpr: fe
    }),
    _meta: Je("meta", {
      startsExpr: fe
    }),
    _of: Je("of", {
      startsExpr: fe
    }),
    _sent: Je("sent", {
      startsExpr: fe
    }),
    _set: Je("set", {
      startsExpr: fe
    }),
    _source: Je("source", {
      startsExpr: fe
    }),
    _static: Je("static", {
      startsExpr: fe
    }),
    _using: Je("using", {
      startsExpr: fe
    }),
    _yield: Je("yield", {
      startsExpr: fe
    }),
    _asserts: Je("asserts", {
      startsExpr: fe
    }),
    _checks: Je("checks", {
      startsExpr: fe
    }),
    _exports: Je("exports", {
      startsExpr: fe
    }),
    _global: Je("global", {
      startsExpr: fe
    }),
    _implements: Je("implements", {
      startsExpr: fe
    }),
    _intrinsic: Je("intrinsic", {
      startsExpr: fe
    }),
    _infer: Je("infer", {
      startsExpr: fe
    }),
    _is: Je("is", {
      startsExpr: fe
    }),
    _mixins: Je("mixins", {
      startsExpr: fe
    }),
    _proto: Je("proto", {
      startsExpr: fe
    }),
    _require: Je("require", {
      startsExpr: fe
    }),
    _satisfies: Je("satisfies", {
      startsExpr: fe
    }),
    _keyof: Je("keyof", {
      startsExpr: fe
    }),
    _readonly: Je("readonly", {
      startsExpr: fe
    }),
    _unique: Je("unique", {
      startsExpr: fe
    }),
    _abstract: Je("abstract", {
      startsExpr: fe
    }),
    _declare: Je("declare", {
      startsExpr: fe
    }),
    _enum: Je("enum", {
      startsExpr: fe
    }),
    _module: Je("module", {
      startsExpr: fe
    }),
    _namespace: Je("namespace", {
      startsExpr: fe
    }),
    _interface: Je("interface", {
      startsExpr: fe
    }),
    _type: Je("type", {
      startsExpr: fe
    }),
    _opaque: Je("opaque", {
      startsExpr: fe
    }),
    name: Ee("name", {
      startsExpr: fe
    }),
    placeholder: Ee("%%", {
      startsExpr: fe
    }),
    string: Ee("string", {
      startsExpr: fe
    }),
    num: Ee("num", {
      startsExpr: fe
    }),
    bigint: Ee("bigint", {
      startsExpr: fe
    }),
    decimal: Ee("decimal", {
      startsExpr: fe
    }),
    regexp: Ee("regexp", {
      startsExpr: fe
    }),
    privateName: Ee("#name", {
      startsExpr: fe
    }),
    eof: Ee("eof"),
    jsxName: Ee("jsxName"),
    jsxText: Ee("jsxText", {
      beforeExpr: Ke
    }),
    jsxTagStart: Ee("jsxTagStart", {
      startsExpr: fe
    }),
    jsxTagEnd: Ee("jsxTagEnd")
  };
  function pt(e) {
    return e >= 93 && e <= 133;
  }
  n(pt, "tokenIsIdentifier");
  function iPe(e) {
    return e <= 92;
  }
  n(iPe, "tokenKeywordOrIdentifierIsKeyword");
  function hs(e) {
    return e >= 58 && e <= 133;
  }
  n(hs, "tokenIsKeywordOrIdentifier");
  function aL(e) {
    return e >= 58 && e <= 137;
  }
  n(aL, "tokenIsLiteralPropertyName");
  function sPe(e) {
    return UT[e];
  }
  n(sPe, "tokenComesBeforeExpression");
  function Md(e) {
    return $T[e];
  }
  n(Md, "tokenCanStartExpression");
  function nPe(e) {
    return e >= 29 && e <= 33;
  }
  n(nPe, "tokenIsAssignment");
  function XR(e) {
    return e >= 129 && e <= 131;
  }
  n(XR, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function aPe(e) {
    return e >= 90 && e <= 92;
  }
  n(aPe, "tokenIsLoop");
  function WT(e) {
    return e >= 58 && e <= 92;
  }
  n(WT, "tokenIsKeyword");
  function oPe(e) {
    return e >= 39 && e <= 59;
  }
  n(oPe, "tokenIsOperator");
  function uPe(e) {
    return e === 34;
  }
  n(uPe, "tokenIsPostfix");
  function lPe(e) {
    return VT[e];
  }
  n(lPe, "tokenIsPrefix");
  function cPe(e) {
    return e >= 121 && e <= 123;
  }
  n(cPe, "tokenIsTSTypeOperator");
  function fPe(e) {
    return e >= 124 && e <= 130;
  }
  n(fPe, "tokenIsTSDeclarationStart");
  function Ma(e) {
    return jT[e];
  }
  n(Ma, "tokenLabelName");
  function Ym(e) {
    return qT[e];
  }
  n(Ym, "tokenOperatorPrecedence");
  function dPe(e) {
    return e === 57;
  }
  n(dPe, "tokenIsRightAssociative");
  function Qm(e) {
    return e >= 24 && e <= 25;
  }
  n(Qm, "tokenIsTemplate");
  function Mn(e) {
    return Rn[e];
  }
  n(Mn, "getExportedToken");
  Rn[8].updateContext = (e) => {
    e.pop();
  }, Rn[5].updateContext = Rn[7].updateContext = Rn[23].updateContext = (e) => {
    e.push(at.brace);
  }, Rn[22].updateContext = (e) => {
    e[e.length - 1] === at.template ? e.pop() : e.push(at.template);
  }, Rn[143].updateContext = (e) => {
    e.push(at.j_expr, at.j_oTag);
  };
  var HT = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088F\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5C\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92\
-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDC-\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\
\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00\
-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\
\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7DC\uA7F1-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\
\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  oL = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ADD\u1AE0-\u1AEB\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0\
-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00\
-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", pPe = new RegExp("[" + HT + "]"), hPe = new RegExp("[" + HT + oL + "\
]");
  HT = oL = null;
  var uL = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28,
  36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21,
  43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20,
  1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0,
  2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0,
  3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0,
  50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637,
  96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24,
  3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395,
  2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0,
  4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322,
  29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26,
  2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2,
  3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489], mPe = [509,
  0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14,
  32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7,
  3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214,
  6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0,
  29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2,
  1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470,
  0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15,
  0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0,
  475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function gT(e, t) {
    let r = 65536;
    for (let i = 0, s = t.length; i < s; i += 2) {
      if (r += t[i], r > e) return !1;
      if (r += t[i + 1], r >= e) return !0;
    }
    return !1;
  }
  n(gT, "isInAstralSet");
  function en(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && pPe.test(String.fromCharCode(e)) :
    gT(e, uL);
  }
  n(en, "isIdentifierStart");
  function Wo(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && hPe.test(
    String.fromCharCode(e)) : gT(e, uL) || gT(e, mPe);
  }
  n(Wo, "isIdentifierChar");
  var KT = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, yPe = new Set(KT.keyword), gPe = new Set(KT.strict), bPe = new Set(KT.strictBind);
  function lL(e, t) {
    return t && e === "await" || e === "enum";
  }
  n(lL, "isReservedWord");
  function cL(e, t) {
    return lL(e, t) || gPe.has(e);
  }
  n(cL, "isStrictReservedWord");
  function fL(e) {
    return bPe.has(e);
  }
  n(fL, "isStrictBindOnlyReservedWord");
  function dL(e, t) {
    return cL(e, t) || fL(e);
  }
  n(dL, "isStrictBindReservedWord");
  function DPe(e) {
    return yPe.has(e);
  }
  n(DPe, "isKeyword");
  function vPe(e, t, r) {
    return e === 64 && t === 64 && en(r);
  }
  n(vPe, "isIteratorStart");
  var xPe = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function EPe(e) {
    return xPe.has(e);
  }
  n(EPe, "canBeReservedWord");
  var jd = class {
    static {
      n(this, "Scope");
    }
    constructor(t) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
    }
  }, qd = class {
    static {
      n(this, "ScopeHandler");
    }
    constructor(t, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get allowNewTarget() {
      return (this.currentThisScopeFlags() & 512) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let t = this.currentThisScopeFlags();
      return (t & 64) > 0 && (t & 2) === 0;
    }
    get inStaticBlock() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 128)
          return !0;
        if (r & 1731)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get inBareCaseStatement() {
      return (this.currentScope().flags & 256) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(t) {
      return new jd(t);
    }
    enter(t) {
      this.scopeStack.push(this.createScope(t));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(t) {
      return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
    }
    declareName(t, r, i) {
      let s = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(s, t, r, i);
        let a = s.names.get(t) || 0;
        r & 16 ? a = a | 4 : (s.firstLexicalName || (s.firstLexicalName = t), a = a | 2), s.names.set(t, a), r & 8 && this.maybeExportDefined(
        s, t);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (s = this.scopeStack[a], this.checkRedeclarationInScope(s, t, r, i), s.names.set(
        t, (s.names.get(t) || 0) | 1), this.maybeExportDefined(s, t), !(s.flags & 1667)); --a)
          ;
      this.parser.inModule && s.flags & 1 && this.undefinedExports.delete(t);
    }
    maybeExportDefined(t, r) {
      this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(t, r, i, s) {
      this.isRedeclaredInScope(t, r, i) && this.parser.raise(R.VarRedeclaration, s, {
        identifierName: r
      });
    }
    isRedeclaredInScope(t, r, i) {
      if (!(i & 1)) return !1;
      if (i & 8)
        return t.names.has(r);
      let s = t.names.get(r) || 0;
      return i & 16 ? (s & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (s & 1) > 0 : (s & 2) > 0 && !(t.flags & 8 && t.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(t) && (s & 4) > 0;
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, t.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 1667)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 1731 && !(r & 4))
          return r;
      }
    }
  }, bT = class extends jd {
    static {
      n(this, "FlowScope");
    }
    constructor(...t) {
      super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, DT = class extends qd {
    static {
      n(this, "FlowScopeHandler");
    }
    createScope(t) {
      return new bT(t);
    }
    declareName(t, r, i) {
      let s = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(s, t, r, i), this.maybeExportDefined(s, t), s.declareFunctions.add(t);
        return;
      }
      super.declareName(t, r, i);
    }
    isRedeclaredInScope(t, r, i) {
      if (super.isRedeclaredInScope(t, r, i)) return !0;
      if (i & 2048 && !t.declareFunctions.has(r)) {
        let s = t.names.get(r);
        return (s & 4) > 0 || (s & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(t) {
      this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
    }
  }, SPe = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "sta\
tic", "string", "true", "typeof", "void"]), we = Qs`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ n(({
      reservedType: e
    }) => `Cannot overwrite reserved type ${e}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ n(({
      memberName: e,
      enumName: t
    }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ n(({
      memberName: e,
      enumName: t
    }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ n(({
      enumName: e
    }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ n(({
      invalidEnumType: e,
      enumName: t
    }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ n(({
      enumName: e
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ n(({
      enumName: e,
      memberName: t,
      explicitType: r
    }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ n(({
      enumName: e,
      memberName: t
    }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ n(({
      enumName: e,
      memberName: t
    }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ n(({
      enumName: e,
      memberName: t,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ n(({
      enumName: e,
      memberName: t
    }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ n(({
      enumName: e
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ n(({
      reservedType: e
    }) => `Unexpected reserved type ${e}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ n(({
      unsupportedExportKind: e,
      suggestion: t
    }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function TPe(e) {
    return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "T\
ypeAlias" && e.declaration.type !== "InterfaceDeclaration");
  }
  n(TPe, "isEsModuleType");
  function YR(e) {
    return e.importKind === "type" || e.importKind === "typeof";
  }
  n(YR, "hasTypeImportKind");
  var CPe = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function wPe(e, t) {
    let r = [], i = [];
    for (let s = 0; s < e.length; s++)
      (t(e[s], s, e) ? r : i).push(e[s]);
    return [r, i];
  }
  n(wPe, "partition");
  var APe = /\*?\s*@((?:no)?flow)\b/, _Pe = /* @__PURE__ */ n((e) => class extends e {
    static {
      n(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return DT;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(r, i) {
      r !== 134 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, i);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let i = APe.exec(r.value);
        if (i) if (i[1] === "flow")
          this.flowPragma = "flow";
        else if (i[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let i = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let s = this.flowParseType();
      return this.state.inType = i, s;
    }
    flowParsePredicate() {
      let r = this.startNode(), i = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > i.index + 1 && this.raise(we.UnexpectedSpaceBetweenModuloChecks,
      i), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let i = null, s = null;
      return this.match(54) ? (this.state.inType = r, s = this.flowParsePredicate()) : (i = this.flowParseType(), this.state.inType = r, this.
      match(54) && (s = this.flowParsePredicate())), [i, s];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let i = r.id = this.parseIdentifier(), s = this.startNode(), a = this.startNode();
      this.match(47) ? s.typeParameters = this.flowParseTypeParameterDeclaration() : s.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return s.params = o.params, s.rest = o.rest, s.this = o._this, this.expect(11), [s.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(s, "FunctionTypeAnnotation"), i.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      i), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, i) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (i && this.raise(we.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, i);
      throw this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(134) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let i = r.body = this.startNode(), s = i.body = [];
      for (this.expect(5); !this.match(8); ) {
        let u = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(we.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), s.push(super.parseImport(u))) : (this.expectContextual(125, we.UnsupportedStatementInDeclareModule), s.push(
        this.flowParseDeclare(u, !0)));
      }
      this.scope.exit(), this.expect(8), this.finishNode(i, "BlockStatement");
      let a = null, o = !1;
      return s.forEach((u) => {
        TPe(u) ? (a === "CommonJS" && this.raise(we.AmbiguousDeclareModuleKind, u), a = "ES") : u.type === "DeclareModuleExports" && (o && this.
        raise(we.DuplicateDeclareModuleExports, u), a === "ES" && this.raise(we.AmbiguousDeclareModuleKind, u), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, i) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !i) {
        let s = this.state.value;
        throw this.raise(we.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: s,
          suggestion: CPe[s]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" ? (r.default = !1, delete r.exportKind, this.castNodeTo(r,
        "DeclareExportDeclaration")) : this.castNodeTo(r, "DeclareExportAllDeclaration");
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let i = this.flowParseTypeAlias(r);
      return this.castNodeTo(i, "DeclareTypeAlias"), i;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let i = this.flowParseOpaqueType(r, !0);
      return this.castNodeTo(i, "DeclareOpaqueType"), i;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, i) {
      if (r.id = this.flowParseRestrictedIdentifier(!i, !0), this.scope.declareName(r.id.name, i ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!i && this.eat(12));
      if (i) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: i,
        allowExact: !1,
        allowSpread: !1,
        allowProto: i,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(we.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, i, s) {
      SPe.has(r) && this.raise(s ? we.AssignReservedType : we.UnexpectedReservedType, i, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, i) {
      return this.checkReservedType(this.state.value, this.state.startLoc, i), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, i) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, i || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let i = this.state.startLoc, s = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return s.name = o.name, s.variance = a, s.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), s.default = this.flowParseType()) :
      r && this.raise(we.MissingTypeParamDefault, i), this.finishNode(s, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, i = this.startNode();
      i.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let s = !1;
      do {
        let a = this.flowParseTypeParameter(s);
        i.params.push(a), a.default && (s = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(i, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(r) {
      if (this.curContext() !== at.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return r();
        } finally {
          this.state.context = i;
        }
      } else
        return r();
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47)
        return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), i = this.state.inType;
      return this.state.inType = !0, r.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        let s = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = s;
      }), this.state.inType = i, !this.state.inType && this.curContext() === at.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(
      r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return null;
      let r = this.startNode(), i = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = i, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, i, s) {
      return r.static = i, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = s, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, i) {
      return r.static = i, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, i) {
      let s = this.startNode();
      return r.static = i, r.value = this.flowParseObjectTypeMethodish(s), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: i,
      allowSpread: s,
      allowProto: a,
      allowInexact: o
    }) {
      let u = this.state.inType;
      this.state.inType = !0;
      let l = this.startNode();
      l.callProperties = [], l.properties = [], l.indexers = [], l.internalSlots = [];
      let c, f, m = !1;
      for (i && this.match(6) ? (this.expect(6), c = 9, f = !0) : (this.expect(5), c = 8, f = !1), l.exact = f; !this.match(c); ) {
        let d = !1, y = null, p = null, g = this.startNode();
        if (a && this.isContextual(118)) {
          let D = this.lookahead();
          D.type !== 14 && D.type !== 17 && (this.next(), y = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let D = this.lookahead();
          D.type !== 14 && D.type !== 17 && (this.next(), d = !0);
        }
        let b = this.flowParseVariance();
        if (this.eat(0))
          y != null && this.unexpected(y), this.eat(0) ? (b && this.unexpected(b.loc.start), l.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          g, d))) : l.indexers.push(this.flowParseObjectTypeIndexer(g, d, b));
        else if (this.match(10) || this.match(47))
          y != null && this.unexpected(y), b && this.unexpected(b.loc.start), l.callProperties.push(this.flowParseObjectTypeCallProperty(g, d));
        else {
          let D = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let T = this.lookahead();
            aL(T.type) && (D = this.state.value, this.next());
          }
          let x = this.flowParseObjectTypeProperty(g, d, y, b, D, s, o ?? !f);
          x === null ? (m = !0, p = this.state.lastTokStartLoc) : l.properties.push(x);
        }
        this.flowObjectTypeSemicolon(), p && !this.match(8) && !this.match(9) && this.raise(we.UnexpectedExplicitInexactInObject, p);
      }
      this.expect(c), s && (l.inexact = m);
      let h = this.finishNode(l, "ObjectTypeAnnotation");
      return this.state.inType = u, h;
    }
    flowParseObjectTypeProperty(r, i, s, a, o, u, l) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (u ? l || this.raise(we.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(we.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(we.InexactVariance, a), null) : (u || this.raise(
        we.UnexpectedSpreadType, this.state.lastTokStartLoc), s != null && this.unexpected(s), a && this.raise(we.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = i, r.proto = s != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, s != null && this.unexpected(s), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !u && r.key.name === "constructor" && r.value.this && this.raise(we.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let i = r.kind === "get" ? 0 : 1, s = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? we.GetterMayNotHaveThisParam : we.SetterMayNotHaveThisParam, r.value.this), s !== i && this.
      raise(r.kind === "get" ? R.BadGetterArity : R.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(R.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, i) {
      r ?? (r = this.state.startLoc);
      let s = i || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let a = this.startNodeAt(r);
        a.qualification = s, a.id = this.flowParseRestrictedIdentifier(!0), s = this.finishNode(a, "QualifiedTypeIdentifier");
      }
      return s;
    }
    flowParseGenericType(r, i) {
      let s = this.startNodeAt(r);
      return s.typeParameters = null, s.id = this.flowParseQualifiedTypeIdentifier(r, i), this.match(47) && (s.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(s, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let i = null, s = !1, a = null, o = this.startNode(), u = this.lookahead(), l = this.state.type === 78;
      return u.type === 14 || u.type === 17 ? (l && !r && this.raise(we.ThisParamMustBeFirst, o), i = this.parseIdentifier(l), this.eat(17) &&
      (s = !0, l && this.raise(we.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = i,
      o.optional = s, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let i = this.startNodeAt(r.loc.start);
      return i.name = null, i.optional = !1, i.typeAnnotation = r, this.finishNode(i, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let i = null, s = null;
      for (this.match(78) && (s = this.flowParseFunctionTypeParam(!0), s.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (i = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: i,
        _this: s
      };
    }
    flowIdentToTypeAnnotation(r, i, s) {
      switch (s.name) {
        case "any":
          return this.finishNode(i, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(i, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(i, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(i, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(i, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(i, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(i, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(s.name), this.flowParseGenericType(r, s);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, i = this.startNode(), s, a, o = !1, u = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = u, a;
        case 47: {
          let l = this.startNode();
          return l.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), s = this.flowParseFunctionTypeParams(), l.params =
          s.params, l.rest = s.rest, l.this = s._this, this.expect(11), this.expect(19), l.returnType = this.flowParseType(), this.finishNode(
          l, "FunctionTypeAnnotation");
        }
        case 10: {
          let l = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (pt(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              o = c !== 17 && c !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = u, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? s = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : s = this.flowParseFunctionTypeParams(),
          l.params = s.params, l.rest = s.rest, l.this = s._this, this.expect(11), this.expect(19), l.returnType = this.flowParseType(), l.typeParameters =
          null, this.finishNode(l, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return i.value = this.match(85), this.next(), this.finishNode(i, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", i);
            if (this.match(136))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", i);
            throw this.raise(we.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          throw this.unexpected();
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(i, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(i, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(i, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(i, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (WT(this.state.type)) {
            let l = Ma(this.state.type);
            return this.next(), super.createIdentifier(i, l);
          } else if (pt(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, i, this.parseIdentifier());
      }
      throw this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, i = this.flowParsePrimaryType(), s = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        s = s || o, this.expect(0), !o && this.match(3) ? (a.elementType = i, this.next(), i = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = i, a.indexType = this.flowParseType(), this.expect(3), s ? (a.optional = o, i = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : i = this.finishNode(a, "IndexedAccessType"));
      }
      return i;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let i = this.startNodeAt(r.loc.start);
        return i.params = [this.reinterpretTypeAsFunctionTypeParam(r)], i.rest = null, i.this = null, i.returnType = this.flowParseType(), i.
        typeParameters = null, this.finishNode(i, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let i = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [i]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? i : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let i = this.flowParseIntersectionType();
      for (r.types = [i]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? i : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let i = this.flowParseUnionType();
      return this.state.inType = r, i;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, i = this.parseIdentifier();
        return this.flowParseGenericType(r, i);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let i = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (i.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(i)), i;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, i, s = !1) {
      if (i) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, s));
        return;
      }
      super.parseFunctionBody(r, !1, s);
    }
    parseFunctionBodyAndFinish(r, i, s = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, i, s);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let s = this.lookahead();
        if (hs(s.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.isContextual(126)) {
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      }
      let i = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(i) && (this.flowPragma = null), i;
    }
    parseExpressionStatement(r, i, s) {
      if (i.type === "Identifier") {
        if (i.name === "declare") {
          if (this.match(80) || pt(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (pt(this.state.type)) {
          if (i.name === "interface")
            return this.flowParseInterface(r);
          if (i.name === "type")
            return this.flowParseTypeAlias(r);
          if (i.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, i, s);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return r === 126 || XR(r) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return r === 126 || XR(r) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, i, s) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let h = this.lookaheadCharCode();
        if (h === 44 || h === 61 || h === 58 || h === 41)
          return this.setOptionalParametersError(s), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, u = this.startNodeAt(i), {
        consequent: l,
        failed: c
      } = this.tryParseConditionalConsequent(), [f, m] = this.getArrowLikeExpressions(l);
      if (c || m.length > 0) {
        let h = [...o];
        if (m.length > 0) {
          this.state = a, this.state.noArrowAt = h;
          for (let d = 0; d < m.length; d++)
            h.push(m[d].start);
          ({
            consequent: l,
            failed: c
          } = this.tryParseConditionalConsequent()), [f, m] = this.getArrowLikeExpressions(l);
        }
        c && f.length > 1 && this.raise(we.AmbiguousConditionalArrow, a.startLoc), c && f.length === 1 && (this.state = a, h.push(f[0].start),
        this.state.noArrowAt = h, {
          consequent: l,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(l, !0), this.state.noArrowAt = o, this.expect(14), u.test = r, u.consequent = l, u.alternate = this.
      forwardNoArrowParamsConversionAt(u, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(u, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), i = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: i
      };
    }
    getArrowLikeExpressions(r, i) {
      let s = [r], a = [];
      for (; s.length !== 0; ) {
        let o = s.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), s.push(o.body)) : o.type === "ConditionalExpression" && (s.push(o.consequent), s.push(o.alternate));
      }
      return i ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : wPe(a, (o) => o.params.every((u) => this.isAssignable(u, !0)));
    }
    finishArrowValidation(r) {
      var i;
      this.toAssignableList(r.params, (i = r.extra) == null ? void 0 : i.trailingCommaLoc, !1), this.scope.enter(518), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, i) {
      let s;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? (this.state.noArrowParamsConversionAt.push(this.
      state.start), s = i(), this.state.noArrowParamsConversionAt.pop()) : s = i(), s;
    }
    parseParenItem(r, i) {
      let s = super.parseParenItem(r, i);
      if (this.eat(17) && (s.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = s, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return s;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        i);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseOpaqueType(i, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let i = this.startNode();
        return this.next(), this.flowParseInterface(i);
      } else if (this.isContextual(126)) {
        r.exportKind = "value";
        let i = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(i);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: i
      } = this.state, s = super.maybeParseExportNamespaceSpecifier(r);
      return s && r.exportKind === "type" && this.unexpected(i), s;
    }
    parseClassId(r, i, s) {
      super.parseClassId(r, i, s), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, i, s) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, i))
          return;
        i.declare = !0;
      }
      super.parseClassMember(r, i, s), i.declare && (i.type !== "ClassProperty" && i.type !== "ClassPrivateProperty" && i.type !== "Property\
Definition" ? this.raise(we.DeclareClassElement, a) : i.value && this.raise(we.DeclareClassFieldInitializer, i.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), i = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(R.InvalidIdentifier, this.state.curPosition(), {
        identifierName: i
      }), this.finishToken(132, i);
    }
    getTokenFromCode(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && i === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? i === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : vPe(r, i, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, i) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, i) : super.isAssignable(r, i);
    }
    toAssignable(r, i = !1) {
      !i && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, i);
    }
    toAssignableList(r, i, s) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, i, s);
    }
    toReferencedList(r, i) {
      for (let a = 0; a < r.length; a++) {
        var s;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((s = o.extra) != null && s.parenthesized) && (r.length > 1 || !i) && this.raise(we.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, i, s) {
      let a = super.parseArrayLike(r, i, s);
      return s != null && !this.state.maybeInArrowParameters && this.toReferencedList(a.elements), a;
    }
    isValidLVal(r, i, s, a) {
      return r === "TypeCastExpression" || super.isValidLVal(r, i, s, a);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, i, s, a, o, u) {
      if (i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, i, s, a, o, u), i.params && o) {
        let l = i.params;
        l.length > 0 && this.isThisParam(l[0]) && this.raise(we.ThisParamBannedInConstructor, i);
      } else if (i.type === "MethodDefinition" && o && i.value.params) {
        let l = i.value.params;
        l.length > 0 && this.isThisParam(l[0]) && this.raise(we.ThisParamBannedInConstructor, i);
      }
    }
    pushClassPrivateMethod(r, i, s, a) {
      i.variance && this.unexpected(i.variance.loc.start), delete i.variance, this.match(47) && (i.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, i, s, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()),
      this.isContextual(113)) {
        this.next();
        let i = r.implements = [];
        do {
          let s = this.startNode();
          s.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? s.typeParameters = this.flowParseTypeParameterInstantiation() : s.
          typeParameters = null, i.push(this.finishNode(s, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let i = this.getObjectOrClassMethodParams(r);
      if (i.length > 0) {
        let s = i[0];
        this.isThisParam(s) && r.kind === "get" ? this.raise(we.GetterMayNotHaveThisParam, s) : this.isThisParam(s) && this.raise(we.SetterMayNotHaveThisParam,
        s);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, i, s, a, o, u, l) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !u && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let f = super.parseObjPropValue(r, i, s, a, o, u, l);
      return c && ((f.value || f).typeParameters = c), f;
    }
    parseFunctionParamType(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(we.PatternIsOptional, r), this.isThisParam(r) && this.raise(we.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(we.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(we.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, i) {
      let s = super.parseMaybeDefault(r, i);
      return s.type === "AssignmentPattern" && s.typeAnnotation && s.right.start < s.typeAnnotation.start && this.raise(we.TypeBeforeInitializer,
      s.typeAnnotation), s;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(we.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, i, s) {
      i.local = YR(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(i,
      s));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let i = this.lookaheadCharCode();
        return i === 123 || i === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, s, a) {
      if (super.applyImportPhase(r, i, s, a), i) {
        if (!s && this.match(65))
          return;
        r.exportKind = s === "type" ? s : "value";
      } else
        s === "type" && this.match(55) && this.unexpected(), r.importKind = s === "type" || s === "typeof" ? s : "value";
    }
    parseImportSpecifier(r, i, s, a, o) {
      let u = r.imported, l = null;
      u.type === "Identifier" && (u.name === "type" ? l = "type" : u.name === "typeof" && (l = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let m = this.parseIdentifier(!0);
        l !== null && !hs(this.state.type) ? (r.imported = m, r.importKind = l, r.local = this.cloneIdentifier(m)) : (r.imported = u, r.importKind =
        null, r.local = this.parseIdentifier());
      } else {
        if (l !== null && hs(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = l;
        else {
          if (i)
            throw this.raise(R.ImportBindingIsString, r, {
              importName: u.value
            });
          r.imported = u, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = this.cloneIdentifier(r.imported));
      }
      let f = YR(r);
      return s && f && this.raise(we.ImportTypeShorthandOnlyInPureImport, r), (s || f) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !s && !f && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, i) {
      let s = r.kind;
      s !== "get" && s !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      if (this.match(14)) {
        let s = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = s;
      }
      return super.parseAsyncArrowFromCallExpression(r, i);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, i) {
      var s;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, i), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, f = c[c.length - 1];
        (f === at.j_oTag || f === at.j_expr) && c.pop();
      }
      if ((s = o) != null && s.error || this.match(47)) {
        var u, l;
        a = a || this.state.clone();
        let c, f = this.tryParse((h) => {
          var d;
          c = this.flowParseTypeParameterDeclaration();
          let y = this.forwardNoArrowParamsConversionAt(c, () => {
            let g = super.parseMaybeAssign(r, i);
            return this.resetStartLocationFromNode(g, c), g;
          });
          (d = y.extra) != null && d.parenthesized && h();
          let p = this.maybeUnwrapTypeCastExpression(y);
          return p.type !== "ArrowFunctionExpression" && h(), p.typeParameters = c, this.resetStartLocationFromNode(p, c), y;
        }, a), m = null;
        if (f.node && this.maybeUnwrapTypeCastExpression(f.node).type === "ArrowFunctionExpression") {
          if (!f.error && !f.aborted)
            return f.node.async && this.raise(we.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), f.node;
          m = f.node;
        }
        if ((u = o) != null && u.node)
          return this.state = o.failState, o.node;
        if (m)
          return this.state = f.failState, m;
        throw (l = o) != null && l.thrown ? o.error : f.thrown ? f.error : this.raise(we.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse(() => {
          let s = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = s, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (i.thrown) return null;
        i.error && (this.state = i.failState), r.returnType = i.node.typeAnnotation ? this.finishNode(i.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, i) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? r.params = i : super.setArrowFunctionParameters(r, i);
    }
    checkParams(r, i, s, a = !0) {
      if (!(s && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)))) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(we.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, i, s, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(r, i, s) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.includes(i.index)) {
        this.next();
        let a = this.startNodeAt(i);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((l) => this.parseAsyncArrowWithTypeParameters(i) || l(), a);
        if (!o.error && !o.aborted) return o.node;
        let u = this.tryParse(() => super.parseSubscripts(r, i, s), a);
        if (u.node && !u.error) return u.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (u.node)
          return this.state = u.failState, u.node;
        throw o.error || u.error;
      }
      return super.parseSubscripts(r, i, s);
    }
    parseSubscript(r, i, s, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, s)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(i);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), o.arguments = this.parseCallExpressionArguments(),
        o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!s && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        let o = this.startNodeAt(i);
        o.callee = r;
        let u = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (u.node)
          return u.error && (this.state = u.failState), u.node;
      }
      return super.parseSubscript(r, i, s, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let i = null;
      this.shouldParseTypes() && this.match(47) && (i = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      i;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let i = this.startNodeAt(r);
      if (this.parseFunctionParams(i, !1), !!this.parseArrow(i))
        return super.parseArrowExpression(i, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && i === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let i = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && i === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, i) {
      let s = super.parseTopLevel(r, i);
      return this.state.hasFlowComment && this.raise(we.UnterminatedFlowComment, this.state.curPosition()), s;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(we.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, i = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + i)); )
        i++;
      let s = this.input.charCodeAt(i + r), a = this.input.charCodeAt(i + r + 1);
      return s === 58 && a === 58 ? i + 2 : this.input.slice(i + r, i + r + 12) === "flow-include" ? i + 12 : s === 58 && a !== 58 ? i : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(R.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: i,
      memberName: s
    }) {
      this.raise(we.EnumBooleanMemberNotInitialized, r, {
        memberName: s,
        enumName: i
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, i) {
      return this.raise(i.explicitType ? i.explicitType === "symbol" ? we.EnumInvalidMemberInitializerSymbolType : we.EnumInvalidMemberInitializerPrimaryType :
      we.EnumInvalidMemberInitializerUnknownType, r, i);
    }
    flowEnumErrorNumberMemberNotInitialized(r, i) {
      this.raise(we.EnumNumberMemberNotInitialized, r, i);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, i) {
      this.raise(we.EnumStringMemberInconsistentlyInitialized, r, i);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, i = /* @__PURE__ */ n(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 135: {
          let s = this.parseNumericLiteral(this.state.value);
          return i() ? {
            type: "number",
            loc: s.loc.start,
            value: s
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 134: {
          let s = this.parseStringLiteral(this.state.value);
          return i() ? {
            type: "string",
            loc: s.loc.start,
            value: s
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let s = this.parseBooleanLiteral(this.match(85));
          return i() ? {
            type: "boolean",
            loc: s.loc.start,
            value: s
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, i = this.parseIdentifier(!0), s = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: i,
        init: s
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, i, s) {
      let {
        explicitType: a
      } = i;
      a !== null && a !== s && this.flowEnumErrorInvalidMemberInitializer(r, i);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: i
    }) {
      let s = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let u = this.startNode(), {
          id: l,
          init: c
        } = this.flowEnumMemberRaw(), f = l.name;
        if (f === "")
          continue;
        /^[a-z]/.test(f) && this.raise(we.EnumInvalidMemberName, l, {
          memberName: f,
          suggestion: f[0].toUpperCase() + f.slice(1),
          enumName: r
        }), s.has(f) && this.raise(we.EnumDuplicateMemberName, l, {
          memberName: f,
          enumName: r
        }), s.add(f);
        let m = {
          enumName: r,
          explicitType: i,
          memberName: f
        };
        switch (u.id = l, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, m, "boolean"), u.init = c.value, a.booleanMembers.push(this.finishNode(u, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, m, "number"), u.init = c.value, a.numberMembers.push(this.finishNode(u, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, m, "string"), u.init = c.value, a.stringMembers.push(this.finishNode(u, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, m);
          case "none":
            switch (i) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, m);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, m);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(u, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, i, {
      enumName: s
    }) {
      if (r.length === 0)
        return i;
      if (i.length === 0)
        return r;
      if (i.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: s
          });
        return i;
      } else {
        for (let a of i)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: s
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!pt(this.state.type))
        throw this.raise(we.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: i
      } = this.state;
      return this.next(), i !== "boolean" && i !== "number" && i !== "string" && i !== "symbol" && this.raise(we.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: i
      }), i;
    }
    flowEnumBody(r, i) {
      let s = i.name, a = i.loc.start, o = this.flowEnumParseExplicitType({
        enumName: s
      });
      this.expect(5);
      let {
        members: u,
        hasUnknownMembers: l
      } = this.flowEnumMembers({
        enumName: s,
        explicitType: o
      });
      switch (r.hasUnknownMembers = l, o) {
        case "boolean":
          return r.explicitType = !0, r.members = u.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = u.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(u.stringMembers, u.defaultedMembers, {
            enumName: s
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = u.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ n(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let f = u.booleanMembers.length, m = u.numberMembers.length, h = u.stringMembers.length, d = u.defaultedMembers.length;
          if (!f && !m && !h && !d)
            return c();
          if (!f && !m)
            return r.members = this.flowEnumStringMembers(u.stringMembers, u.defaultedMembers, {
              enumName: s
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!m && !h && f >= d) {
            for (let y of u.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(y.loc.start, {
                enumName: s,
                memberName: y.id.name
              });
            return r.members = u.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!f && !h && m >= d) {
            for (let y of u.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(y.loc.start, {
                enumName: s,
                memberName: y.id.name
              });
            return r.members = u.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(we.EnumInconsistentMemberValues, a, {
              enumName: s
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let i = this.parseIdentifier();
      return r.id = i, r.body = this.flowEnumBody(this.startNode(), i), this.finishNode(r, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(r) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (r.typeArguments = this.flowParseTypeParameterInstantiationInExpression()),
      super.jsxParseOpeningElementAfterName(r);
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let i = this.input.charCodeAt(r + 1);
        return i !== 60 && i !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), PPe = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, FPe = /\r\n|[\r\n\u2028\u2029]/, zm = new RegExp(FPe.source, "g");
  function Ul(e) {
    switch (e) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  n(Ul, "isNewLine");
  function GR(e, t, r) {
    for (let i = t; i < r; i++)
      if (Ul(e.charCodeAt(i)))
        return !0;
    return !1;
  }
  n(GR, "hasNewLine");
  var dT = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, pT = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function IPe(e) {
    switch (e) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  n(IPe, "isWhitespace");
  var $o = Qs`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ n(({
      openingTagName: e
    }) => `Expected corresponding JSX closing tag for <${e}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ n(({
      unexpected: e,
      HTMLEntity: t
    }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function Ba(e) {
    return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
  }
  n(Ba, "isFragment");
  function ql(e) {
    if (e.type === "JSXIdentifier")
      return e.name;
    if (e.type === "JSXNamespacedName")
      return e.namespace.name + ":" + e.name.name;
    if (e.type === "JSXMemberExpression")
      return ql(e.object) + "." + ql(e.property);
    throw new Error("Node had unexpected type: " + e.type);
  }
  n(ql, "getQualifiedJSXName");
  var OPe = /* @__PURE__ */ n((e) => class extends e {
    static {
      n(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", i = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise($o.UnterminatedJsxContent, this.state.startLoc);
        let s = this.input.charCodeAt(this.state.pos);
        switch (s) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              s === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(s);
              return;
            }
            r += this.input.slice(i, this.state.pos), this.finishToken(142, r);
            return;
          case 38:
            r += this.input.slice(i, this.state.pos), r += this.jsxReadEntity(), i = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Ul(s) ? (r += this.input.slice(i, this.state.pos), r += this.jsxReadNewLine(!0), i = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let i = this.input.charCodeAt(this.state.pos), s;
      return ++this.state.pos, i === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, s = r ? `
` : `\r
`) : s = String.fromCharCode(i), ++this.state.curLine, this.state.lineStart = this.state.pos, s;
    }
    jsxReadString(r) {
      let i = "", s = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(R.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (i += this.input.slice(s, this.state.pos), i += this.jsxReadEntity(), s = this.state.pos) : Ul(a) ? (i += this.input.slice(
        s, this.state.pos), i += this.jsxReadNewLine(!1), s = this.state.pos) : ++this.state.pos;
      }
      i += this.input.slice(s, this.state.pos++), this.finishToken(134, i);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let i = 10;
        this.codePointAtPos(this.state.pos) === 120 && (i = 16, ++this.state.pos);
        let s = this.readInt(i, void 0, !1, "bail");
        if (s !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(s);
      } else {
        let i = 0, s = !1;
        for (; i++ < 10 && this.state.pos < this.length && !(s = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (s) {
          let a = this.input.slice(r, this.state.pos), o = PPe[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, i = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (Wo(r) || r === 45);
      this.finishToken(141, this.input.slice(i, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(141) ? r.name = this.state.value : WT(this.state.type) ? r.name = Ma(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, i = this.jsxParseIdentifier();
      if (!this.eat(14)) return i;
      let s = this.startNodeAt(r);
      return s.namespace = i, s.name = this.jsxParseIdentifier(), this.finishNode(s, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, i = this.jsxParseNamespacedName();
      if (i.type === "JSXNamespacedName")
        return i;
      for (; this.eat(16); ) {
        let s = this.startNodeAt(r);
        s.object = i, s.property = this.jsxParseIdentifier(), i = this.finishNode(s, "JSXMemberExpression");
      }
      return i;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(at.brace), this.next(), r = this.jsxParseExpressionContainer(r, at.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise($o.AttributeIsEmpty, r), r;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise($o.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(at.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, i) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let s = this.parseExpression();
        r.expression = s;
      }
      return this.setContext(i), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(at.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      at.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(i, "JSXOpeningFragment") : (i.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      i));
    }
    jsxParseOpeningElementAfterName(r) {
      let i = [];
      for (; !this.match(56) && !this.match(144); )
        i.push(this.jsxParseAttribute());
      return r.attributes = i, r.selfClosing = this.eat(56), this.expect(144), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let i = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(i, "JSXClosingFragment") : (i.name = this.jsxParseElementName(), this.expect(144), this.finishNode(
      i, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let i = this.startNodeAt(r), s = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 143:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              s.push(this.jsxParseElementAt(r));
              break;
            case 142:
              s.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let u = this.startNode();
              this.setContext(at.brace), this.next(), this.match(21) ? s.push(this.jsxParseSpreadChild(u)) : s.push(this.jsxParseExpressionContainer(
              u, at.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        Ba(a) && !Ba(o) && o !== null ? this.raise($o.MissingClosingTagFragment, o) : !Ba(a) && Ba(o) ? this.raise($o.MissingClosingTagElement,
        o, {
          openingTagName: ql(a.name)
        }) : !Ba(a) && !Ba(o) && ql(o.name) !== ql(a.name) && this.raise($o.MissingClosingTagElement, o, {
          openingTagName: ql(a.name)
        });
      }
      if (Ba(a) ? (i.openingFragment = a, i.closingFragment = o) : (i.openingElement = a, i.closingElement = o), i.children = s, this.match(
      47))
        throw this.raise($o.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return Ba(a) ? this.finishNode(i, "JSXFragment") : this.finishNode(i, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: i
      } = this.state;
      i[i.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      143), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let i = this.curContext();
      if (i === at.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (i === at.j_oTag || i === at.j_cTag) {
        if (en(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((r === 34 || r === 39) && i === at.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: i,
        type: s
      } = this.state;
      if (s === 56 && r === 143)
        i.splice(-2, 2, at.j_cTag), this.state.canStartJSXElement = !1;
      else if (s === 143)
        i.push(at.j_oTag);
      else if (s === 144) {
        let a = i[i.length - 1];
        a === at.j_oTag && r === 56 || a === at.j_cTag ? (i.pop(), this.state.canStartJSXElement = i[i.length - 1] === at.j_expr) : (this.setContext(
        at.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = sPe(s);
    }
  }, "jsx"), vT = class extends jd {
    static {
      n(this, "TypeScriptScope");
    }
    constructor(...t) {
      super(...t), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, xT = class extends qd {
    static {
      n(this, "TypeScriptScopeHandler");
    }
    constructor(...t) {
      super(...t), this.importsStack = [];
    }
    createScope(t) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new vT(t);
    }
    enter(t) {
      t === 1024 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
    }
    exit() {
      let t = super.exit();
      return t === 1024 && this.importsStack.pop(), t;
    }
    hasImport(t, r) {
      let i = this.importsStack.length;
      if (this.importsStack[i - 1].has(t))
        return !0;
      if (!r && i > 1) {
        for (let s = 0; s < i - 1; s++)
          if (this.importsStack[s].has(t)) return !0;
      }
      return !1;
    }
    declareName(t, r, i) {
      if (r & 4096) {
        this.hasImport(t, !0) && this.parser.raise(R.VarRedeclaration, i, {
          identifierName: t
        }), this.importsStack[this.importsStack.length - 1].add(t);
        return;
      }
      let s = this.currentScope(), a = s.tsNames.get(t) || 0;
      if (r & 1024) {
        this.maybeExportDefined(s, t), s.tsNames.set(t, a | 16);
        return;
      }
      super.declareName(t, r, i), r & 2 && (r & 1 || (this.checkRedeclarationInScope(s, t, r, i), this.maybeExportDefined(s, t)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && s.tsNames.set(t, a);
    }
    isRedeclaredInScope(t, r, i) {
      let s = t.tsNames.get(r);
      if ((s & 2) > 0) {
        if (i & 256) {
          let a = !!(i & 512), o = (s & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return i & 128 && (s & 8) > 0 ? t.names.get(r) & 2 ? !!(i & 1) : !1 : i & 2 && (s & 1) > 0 ? !0 : super.isRedeclaredInScope(t, r, i);
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      if (this.hasImport(r)) return;
      let i = this.scopeStack.length;
      for (let s = i - 1; s >= 0; s--) {
        let o = this.scopeStack[s].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(t);
    }
  }, ET = class {
    static {
      n(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(t) {
      this.stacks.push(t);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function Gm(e, t) {
    return (e ? 2 : 0) | (t ? 1 : 0);
  }
  n(Gm, "functionFlags");
  var ST = class {
    static {
      n(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(t) {
      return t + this.startIndex;
    }
    offsetToSourcePos(t) {
      return t - this.startIndex;
    }
    hasPlugin(t) {
      if (typeof t == "string")
        return this.plugins.has(t);
      {
        let [r, i] = t;
        if (!this.hasPlugin(r))
          return !1;
        let s = this.plugins.get(r);
        for (let a of Object.keys(i))
          if (s?.[a] !== i[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(t, r) {
      var i;
      return (i = this.plugins.get(t)) == null ? void 0 : i[r];
    }
  };
  function pL(e, t) {
    e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
  }
  n(pL, "setTrailingComments");
  function kPe(e, t) {
    e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
  }
  n(kPe, "setLeadingComments");
  function Ud(e, t) {
    e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
  }
  n(Ud, "setInnerComments");
  function Na(e, t, r) {
    let i = null, s = t.length;
    for (; i === null && s > 0; )
      i = t[--s];
    i === null || i.start > r.start ? Ud(e, r.comments) : pL(i, r.comments);
  }
  n(Na, "adjustInnerComments");
  var TT = class extends ST {
    static {
      n(this, "CommentsParser");
    }
    addComment(t) {
      this.filename && (t.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length !== r && (this.comments.length = r), this.comments.push(t), this.state.commentsLen++;
    }
    processComment(t) {
      let {
        commentStack: r
      } = this.state, i = r.length;
      if (i === 0) return;
      let s = i - 1, a = r[s];
      a.start === t.end && (a.leadingNode = t, s--);
      let {
        start: o
      } = t;
      for (; s >= 0; s--) {
        let u = r[s], l = u.end;
        if (l > o)
          u.containingNode = t, this.finalizeComment(u), r.splice(s, 1);
        else {
          l === o && (u.trailingNode = t);
          break;
        }
      }
    }
    finalizeComment(t) {
      var r;
      let {
        comments: i
      } = t;
      if (t.leadingNode !== null || t.trailingNode !== null)
        t.leadingNode !== null && pL(t.leadingNode, i), t.trailingNode !== null && kPe(t.trailingNode, i);
      else {
        let s = t.containingNode, a = t.start;
        if (this.input.charCodeAt(this.offsetToSourcePos(a) - 1) === 44)
          switch (s.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              Na(s, s.properties, t);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              Na(s, s.arguments, t);
              break;
            case "ImportExpression":
              Na(s, [s.source, (r = s.options) != null ? r : null], t);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              Na(s, s.params, t);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              Na(s, s.elements, t);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              Na(s, s.specifiers, t);
              break;
            case "TSEnumDeclaration":
              Na(s, s.members, t);
              break;
            case "TSEnumBody":
              Na(s, s.members, t);
              break;
            default:
              Ud(s, i);
          }
        else
          Ud(s, i);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: t
      } = this.state;
      for (let r = t.length - 1; r >= 0; r--)
        this.finalizeComment(t[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: i
      } = r;
      if (i === 0) return;
      let s = r[i - 1];
      s.leadingNode === t && (s.leadingNode = null);
    }
    takeSurroundingComments(t, r, i) {
      let {
        commentStack: s
      } = this.state, a = s.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let u = s[o], l = u.end;
        if (u.start === i)
          u.leadingNode = t;
        else if (l === r)
          u.trailingNode = t;
        else if (l < r)
          break;
      }
    }
  }, CT = class e {
    static {
      n(this, "State");
    }
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0,
      this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [at.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(t) {
      t ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: t,
      sourceType: r,
      startIndex: i,
      startLine: s,
      startColumn: a
    }) {
      this.strict = t === !1 ? !1 : t === !0 ? !0 : r === "module", this.startIndex = i, this.curLine = s, this.lineStart = -a, this.startLoc =
      this.endLoc = new tn(s, a, i);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(t) {
      t ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(t) {
      t ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(t) {
      t ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(t) {
      t ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(t) {
      t ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(t) {
      t ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(t) {
      t ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(t) {
      t ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(t) {
      t ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(t) {
      t ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(t) {
      t ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(t) {
      t ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new tn(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      let t = new e();
      return t.flags = this.flags, t.startIndex = this.startIndex, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.
      startLoc, t.endLoc = this.endLoc, t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.
      slice(), t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.
      slice(), t.commentsLen = this.commentsLen, t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value =
      this.value, t.start = this.start, t.end = this.end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.
      context = this.context.slice(), t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors,
      t.tokensLength = this.tokensLength, t;
    }
  }, BPe = /* @__PURE__ */ n(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), ZR = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, Jm = {
    bin: /* @__PURE__ */ n((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ n((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ n((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ n((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function QR(e, t, r, i, s, a) {
    let o = r, u = i, l = s, c = "", f = null, m = r, {
      length: h
    } = t;
    for (; ; ) {
      if (r >= h) {
        a.unterminated(o, u, l), c += t.slice(m, r);
        break;
      }
      let d = t.charCodeAt(r);
      if (NPe(e, d, t, r)) {
        c += t.slice(m, r);
        break;
      }
      if (d === 92) {
        c += t.slice(m, r);
        let y = MPe(t, r, i, s, e === "template", a);
        y.ch === null && !f ? f = {
          pos: r,
          lineStart: i,
          curLine: s
        } : c += y.ch, {
          pos: r,
          lineStart: i,
          curLine: s
        } = y, m = r;
      } else d === 8232 || d === 8233 ? (++r, ++s, i = r) : d === 10 || d === 13 ? e === "template" ? (c += t.slice(m, r) + `
`, ++r, d === 13 && t.charCodeAt(r) === 10 && ++r, ++s, m = i = r) : a.unterminated(o, u, l) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: f,
      lineStart: i,
      curLine: s,
      containsInvalid: !!f
    };
  }
  n(QR, "readStringContents");
  function NPe(e, t, r, i) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(i + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  n(NPe, "isStringEnd");
  function MPe(e, t, r, i, s, a) {
    let o = !s;
    t++;
    let u = /* @__PURE__ */ n((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: i
    }), "res"), l = e.charCodeAt(t++);
    switch (l) {
      case 110:
        return u(`
`);
      case 114:
        return u("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = wT(e, t, r, i, 2, !1, o, a), u(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = mL(e, t, r, i, o, a), u(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return u("	");
      case 98:
        return u("\b");
      case 118:
        return u("\v");
      case 102:
        return u("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++i;
      case 8232:
      case 8233:
        return u("");
      case 56:
      case 57:
        if (s)
          return u(null);
        a.strictNumericEscape(t - 1, r, i);
      default:
        if (l >= 48 && l <= 55) {
          let c = t - 1, m = /^[0-7]+/.exec(e.slice(c, t + 2))[0], h = parseInt(m, 8);
          h > 255 && (m = m.slice(0, -1), h = parseInt(m, 8)), t += m.length - 1;
          let d = e.charCodeAt(t);
          if (m !== "0" || d === 56 || d === 57) {
            if (s)
              return u(null);
            a.strictNumericEscape(c, r, i);
          }
          return u(String.fromCharCode(h));
        }
        return u(String.fromCharCode(l));
    }
  }
  n(MPe, "readEscapedChar");
  function wT(e, t, r, i, s, a, o, u) {
    let l = t, c;
    return {
      n: c,
      pos: t
    } = hL(e, t, r, i, 16, s, a, !1, u, !o), c === null && (o ? u.invalidEscapeSequence(l, r, i) : t = l - 1), {
      code: c,
      pos: t
    };
  }
  n(wT, "readHexChar");
  function hL(e, t, r, i, s, a, o, u, l, c) {
    let f = t, m = s === 16 ? ZR.hex : ZR.decBinOct, h = s === 16 ? Jm.hex : s === 10 ? Jm.dec : s === 8 ? Jm.oct : Jm.bin, d = !1, y = 0;
    for (let p = 0, g = a ?? 1 / 0; p < g; ++p) {
      let b = e.charCodeAt(t), D;
      if (b === 95 && u !== "bail") {
        let x = e.charCodeAt(t - 1), T = e.charCodeAt(t + 1);
        if (u) {
          if (Number.isNaN(T) || !h(T) || m.has(x) || m.has(T)) {
            if (c) return {
              n: null,
              pos: t
            };
            l.unexpectedNumericSeparator(t, r, i);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          l.numericSeparatorInEscapeSequence(t, r, i);
        }
        ++t;
        continue;
      }
      if (b >= 97 ? D = b - 97 + 10 : b >= 65 ? D = b - 65 + 10 : BPe(b) ? D = b - 48 : D = 1 / 0, D >= s) {
        if (D <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (D <= 9 && l.invalidDigit(t, r, i, s))
          D = 0;
        else if (o)
          D = 0, d = !0;
        else
          break;
      }
      ++t, y = y * s + D;
    }
    return t === f || a != null && t - f !== a || d ? {
      n: null,
      pos: t
    } : {
      n: y,
      pos: t
    };
  }
  n(hL, "readInt");
  function mL(e, t, r, i, s, a) {
    let o = e.charCodeAt(t), u;
    if (o === 123) {
      if (++t, {
        code: u,
        pos: t
      } = wT(e, t, r, i, e.indexOf("}", t) - t, !0, s, a), ++t, u !== null && u > 1114111)
        if (s)
          a.invalidCodePoint(t, r, i);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: u,
        pos: t
      } = wT(e, t, r, i, 4, !1, s, a));
    return {
      code: u,
      pos: t
    };
  }
  n(mL, "readCodePoint");
  function Nd(e, t, r) {
    return new tn(r, e - t, e);
  }
  n(Nd, "buildPosition");
  var RPe = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), Zs = class {
    static {
      n(this, "Token");
    }
    constructor(t) {
      let r = t.startIndex || 0;
      this.type = t.type, this.value = t.value, this.start = r + t.start, this.end = r + t.end, this.loc = new Vl(t.startLoc, t.endLoc);
    }
  }, AT = class extends TT {
    static {
      n(this, "Tokenizer");
    }
    constructor(t, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ n((i, s, a, o) => this.optionFlags & 2048 ? (this.raise(R.InvalidDigit, Nd(i, s, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(R.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(R.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(R.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(R.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ n((i, s, a) => {
          this.recordStrictModeErrors(R.StrictNumericEscape, Nd(i, s, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ n((i, s, a) => {
          throw this.raise(R.UnterminatedString, Nd(i - 1, s, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(R.StrictNumericEscape),
        unterminated: /* @__PURE__ */ n((i, s, a) => {
          throw this.raise(R.UnterminatedTemplate, Nd(i, s, a));
        }, "unterminated")
      }), this.state = new CT(), this.state.init(t), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(t) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new Zs(this.state)), this.state.lastTokEndLoc = this.state.endLoc,
      this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(t) {
      return this.match(t) ? (this.next(), !0) : !1;
    }
    match(t) {
      return this.state.type === t;
    }
    createLookaheadState(t) {
      return {
        pos: t.pos,
        value: null,
        type: t.type,
        start: t.start,
        end: t.end,
        context: [this.curContext()],
        inType: t.inType,
        startLoc: t.startLoc,
        lastTokEndLoc: t.lastTokEndLoc,
        curLine: t.curLine,
        lineStart: t.lineStart,
        curPosition: t.curPosition
      };
    }
    lookahead() {
      let t = this.state;
      this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = t, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(t) {
      return dT.lastIndex = t, dT.test(this.input) ? dT.lastIndex : t;
    }
    lookaheadCharCode() {
      return this.lookaheadCharCodeSince(this.state.pos);
    }
    lookaheadCharCodeSince(t) {
      return this.input.charCodeAt(this.nextTokenStartSince(t));
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(t) {
      return pT.lastIndex = t, pT.test(this.input) ? pT.lastIndex : t;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(t) {
      let r = this.input.charCodeAt(t);
      if ((r & 64512) === 55296 && ++t < this.input.length) {
        let i = this.input.charCodeAt(t);
        (i & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (i & 1023));
      }
      return r;
    }
    setStrict(t) {
      this.state.strict = t, t && (this.state.strictErrors.forEach(([r, i]) => this.raise(r, i)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(t) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let i = this.state.pos, s = this.input.indexOf(t, i + 2);
      if (s === -1)
        throw this.raise(R.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = s + t.length, zm.lastIndex = i + 2; zm.test(this.input) && zm.lastIndex <= s; )
        ++this.state.curLine, this.state.lineStart = zm.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(i + 2, s),
        start: this.sourceToOffsetPos(i),
        end: this.sourceToOffsetPos(s + t.length),
        loc: new Vl(r, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(a), a;
    }
    skipLineComment(t) {
      let r = this.state.pos, i;
      this.isLookahead || (i = this.state.curPosition());
      let s = this.input.charCodeAt(this.state.pos += t);
      if (this.state.pos < this.length)
        for (; !Ul(s) && ++this.state.pos < this.length; )
          s = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, u = {
        type: "CommentLine",
        value: this.input.slice(r + t, a),
        start: this.sourceToOffsetPos(r),
        end: this.sourceToOffsetPos(a),
        loc: new Vl(i, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(u), u;
    }
    skipSpace() {
      let t = this.state.pos, r = this.optionFlags & 4096 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        let i = this.input.charCodeAt(this.state.pos);
        switch (i) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let s = this.skipBlockComment("*/");
                s !== void 0 && (this.addComment(s), r?.push(s));
                break;
              }
              case 47: {
                let s = this.skipLineComment(2);
                s !== void 0 && (this.addComment(s), r?.push(s));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (IPe(i))
              ++this.state.pos;
            else if (i === 45 && !this.inModule && this.optionFlags & 8192) {
              let s = this.state.pos;
              if (this.input.charCodeAt(s + 1) === 45 && this.input.charCodeAt(s + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), r?.push(a));
              } else
                break e;
            } else if (i === 60 && !this.inModule && this.optionFlags & 8192) {
              let s = this.state.pos;
              if (this.input.charCodeAt(s + 1) === 33 && this.input.charCodeAt(s + 2) === 45 && this.input.charCodeAt(s + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), r?.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r?.length > 0) {
        let i = this.state.pos, s = {
          start: this.sourceToOffsetPos(t),
          end: this.sourceToOffsetPos(i),
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(s);
      }
    }
    finishToken(t, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let i = this.state.type;
      this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(i);
    }
    replaceToken(t) {
      this.state.type = t, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let t = this.state.pos + 1, r = this.codePointAtPos(t);
      if (r >= 48 && r <= 57)
        throw this.raise(R.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? R.RecordExpressionHashIncorrectStartSyntaxType : R.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else en(r) ? (++this.state.pos, this.finishToken(139, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(139, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t >= 48 && t <= 57) {
        this.readNumber(!0);
        return;
      }
      t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !Ul(t) && ++this.state.pos < this.length; )
        t = this.input.charCodeAt(this.state.pos);
      let i = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, i), !0;
    }
    readToken_mult_modulo(t) {
      let r = t === 42 ? 55 : 54, i = 1, s = this.input.charCodeAt(this.state.pos + 1);
      t === 42 && s === 42 && (i++, s = this.input.charCodeAt(this.state.pos + 2), r = 57), s === 61 && !this.state.inType && (i++, r = t ===
      37 ? 33 : 30), this.finishOp(r, i);
    }
    readToken_pipe_amp(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
        return;
      }
      if (t === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(R.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(R.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(t === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 60) {
        if (this.input.charCodeAt(t + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 62) {
        let i = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(t + i) === 61) {
          this.finishOp(30, i + 1);
          return;
        }
        this.finishOp(52, i);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (t === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(t === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(t) {
      switch (t) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(R.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(R.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(t);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(t);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(t);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(t);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(t);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (en(t)) {
            this.readWord(t);
            return;
          }
      }
      throw this.raise(R.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(t)
      });
    }
    finishOp(t, r) {
      let i = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(t, i);
    }
    readRegexp() {
      let t = this.state.startLoc, r = this.state.start + 1, i, s, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(R.UnterminatedRegExp, si(t, 1));
        let c = this.input.charCodeAt(a);
        if (Ul(c))
          throw this.raise(R.UnterminatedRegExp, si(t, 1));
        if (i)
          i = !1;
        else {
          if (c === 91)
            s = !0;
          else if (c === 93 && s)
            s = !1;
          else if (c === 47 && !s)
            break;
          i = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let u = "", l = /* @__PURE__ */ n(() => si(t, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), f = String.fromCharCode(c);
        if (RPe.has(c))
          c === 118 ? u.includes("u") && this.raise(R.IncompatibleRegExpUVFlags, l()) : c === 117 && u.includes("v") && this.raise(R.IncompatibleRegExpUVFlags,
          l()), u.includes(f) && this.raise(R.DuplicateRegExpFlags, l());
        else if (Wo(c) || c === 92)
          this.raise(R.MalformedRegExpFlags, l());
        else
          break;
        ++a, u += f;
      }
      this.state.pos = a, this.finishToken(138, {
        pattern: o,
        flags: u
      });
    }
    readInt(t, r, i = !1, s = !0) {
      let {
        n: a,
        pos: o
      } = hL(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, i, s, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(t) {
      let r = this.state.pos, i = this.state.curPosition(), s = !1;
      this.state.pos += 2;
      let a = this.readInt(t);
      a == null && this.raise(R.InvalidDigit, si(i, 2), {
        radix: t
      });
      let o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, s = !0;
      else if (o === 109)
        throw this.raise(R.InvalidDecimal, i);
      if (en(this.codePointAtPos(this.state.pos)))
        throw this.raise(R.NumberIdentifier, this.state.curPosition());
      if (s) {
        let u = this.input.slice(r, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, u);
        return;
      }
      this.finishToken(135, a);
    }
    readNumber(t) {
      let r = this.state.pos, i = this.state.curPosition(), s = !1, a = !1, o = !1, u = !1;
      !t && this.readInt(10) === null && this.raise(R.InvalidNumber, this.state.curPosition());
      let l = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (l) {
        let d = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(R.StrictOctalLiteral, i), !this.state.strict) {
          let y = d.indexOf("_");
          y > 0 && this.raise(R.ZeroDigitNumericSeparator, si(i, y));
        }
        u = l && !/[89]/.test(d);
      }
      let c = this.input.charCodeAt(this.state.pos);
      if (c === 46 && !u && (++this.state.pos, this.readInt(10), s = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) &&
      !u && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      R.InvalidOrMissingExponent, i), s = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((s || l) && this.raise(R.InvalidBigIntLiteral,
      i), ++this.state.pos, a = !0), c === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (o || l) && this.raise(R.InvalidDecimal, i), ++this.state.pos;
        var f = !0;
      }
      if (en(this.codePointAtPos(this.state.pos)))
        throw this.raise(R.NumberIdentifier, this.state.curPosition());
      let m = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(136, m);
        return;
      }
      if (f) {
        this.finishToken(137, m);
        return;
      }
      let h = u ? parseInt(m, 8) : parseFloat(m);
      this.finishToken(135, h);
    }
    readCodePoint(t) {
      let {
        code: r,
        pos: i
      } = mL(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
      return this.state.pos = i, r;
    }
    readString(t) {
      let {
        str: r,
        pos: i,
        curLine: s,
        lineStart: a
      } = QR(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = i + 1, this.state.lineStart = a, this.state.curLine = s, this.finishToken(134, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let t = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: i,
        pos: s,
        curLine: a,
        lineStart: o
      } = QR("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = s + 1, this.state.lineStart = o, this.state.curLine = a, i && (this.state.firstInvalidTemplateEscapePos = new tn(i.curLine,
      i.pos - i.lineStart, this.sourceToOffsetPos(i.pos))), this.input.codePointAt(s) === 96 ? this.finishToken(24, i ? null : t + r + "`") :
      (this.state.pos++, this.finishToken(25, i ? null : t + r + "${"));
    }
    recordStrictModeErrors(t, r) {
      let i = r.index;
      this.state.strict && !this.state.strictErrors.has(i) ? this.raise(t, r) : this.state.strictErrors.set(i, [t, r]);
    }
    readWord1(t) {
      this.state.containsEsc = !1;
      let r = "", i = this.state.pos, s = this.state.pos;
      for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (Wo(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(s, this.state.pos);
          let o = this.state.curPosition(), u = this.state.pos === i ? en : Wo;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(R.MissingUnicodeEscape, this.state.curPosition()), s = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let l = this.readCodePoint(!0);
          l !== null && (u(l) || this.raise(R.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(l)), s = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(s, this.state.pos);
    }
    readWord(t) {
      let r = this.readWord1(t), i = LT.get(r);
      i !== void 0 ? this.finishToken(i, Ma(i)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: t
      } = this.state;
      WT(t) && this.state.containsEsc && this.raise(R.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: Ma(t)
      });
    }
    raise(t, r, i = {}) {
      let s = r instanceof tn ? r : r.loc.start, a = t(s, i);
      if (!(this.optionFlags & 2048)) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(t, r, i = {}) {
      let s = r instanceof tn ? r : r.loc.start, a = s.index, o = this.state.errors;
      for (let u = o.length - 1; u >= 0; u--) {
        let l = o[u];
        if (l.loc.index === a)
          return o[u] = t(s, i);
        if (l.loc.index < a) break;
      }
      return this.raise(t, r, i);
    }
    updateContext(t) {
    }
    unexpected(t, r) {
      throw this.raise(R.UnexpectedToken, t ?? this.state.startLoc, {
        expected: r ? Ma(r) : null
      });
    }
    expectPlugin(t, r) {
      if (this.hasPlugin(t))
        return !0;
      throw this.raise(R.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [t]
      });
    }
    expectOnePlugin(t) {
      if (!t.some((r) => this.hasPlugin(r)))
        throw this.raise(R.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: t
        });
    }
    errorBuilder(t) {
      return (r, i, s) => {
        this.raise(t, Nd(r, i, s));
      };
    }
  }, _T = class {
    static {
      n(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, PT = class {
    static {
      n(this, "ClassScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new _T());
    }
    exit() {
      let t = this.stack.pop(), r = this.current();
      for (let [i, s] of Array.from(t.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(i) || r.undefinedPrivateNames.set(i, s) : this.parser.raise(R.InvalidPrivateFieldResolution, s, {
          identifierName: i
        });
    }
    declarePrivateName(t, r, i) {
      let {
        privateNames: s,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), u = s.has(t);
      if (r & 3) {
        let l = u && a.get(t);
        if (l) {
          let c = l & 4, f = r & 4, m = l & 3, h = r & 3;
          u = m === h || c !== f, u || a.delete(t);
        } else u || a.set(t, r);
      }
      u && this.parser.raise(R.PrivateNameRedeclaration, i, {
        identifierName: t
      }), s.add(t), o.delete(t);
    }
    usePrivateName(t, r) {
      let i;
      for (i of this.stack)
        if (i.privateNames.has(t)) return;
      i ? i.undefinedPrivateNames.set(t, r) : this.parser.raise(R.InvalidPrivateFieldResolution, r, {
        identifierName: t
      });
    }
  }, Wl = class {
    static {
      n(this, "ExpressionScope");
    }
    constructor(t = 0) {
      this.type = t;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, ey = class extends Wl {
    static {
      n(this, "ArrowHeadParsingScope");
    }
    constructor(t) {
      super(t), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(t, r) {
      let i = r.index;
      this.declarationErrors.set(i, [t, r]);
    }
    clearDeclarationError(t) {
      this.declarationErrors.delete(t);
    }
    iterateErrors(t) {
      this.declarationErrors.forEach(t);
    }
  }, FT = class {
    static {
      n(this, "ExpressionScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [new Wl()], this.parser = t;
    }
    enter(t) {
      this.stack.push(t);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(t, r) {
      let i = r.loc.start, {
        stack: s
      } = this, a = s.length - 1, o = s[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(t, i);
        else
          return;
        o = s[--a];
      }
      this.parser.raise(t, i);
    }
    recordArrowParameterBindingError(t, r) {
      let {
        stack: i
      } = this, s = i[i.length - 1], a = r.loc.start;
      if (s.isCertainlyParameterDeclaration())
        this.parser.raise(t, a);
      else if (s.canBeArrowParameterDeclaration())
        s.recordDeclarationError(t, a);
      else
        return;
    }
    recordAsyncArrowParametersError(t) {
      let {
        stack: r
      } = this, i = r.length - 1, s = r[i];
      for (; s.canBeArrowParameterDeclaration(); )
        s.type === 2 && s.recordDeclarationError(R.AwaitBindingIdentifier, t), s = r[--i];
    }
    validateAsPattern() {
      let {
        stack: t
      } = this, r = t[t.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([i, s]) => {
        this.parser.raise(i, s);
        let a = t.length - 2, o = t[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(s.index), o = t[--a];
      });
    }
  };
  function LPe() {
    return new Wl(3);
  }
  n(LPe, "newParameterDeclarationScope");
  function jPe() {
    return new ey(1);
  }
  n(jPe, "newArrowHeadScope");
  function qPe() {
    return new ey(2);
  }
  n(qPe, "newAsyncArrowScope");
  function yL() {
    return new Wl();
  }
  n(yL, "newExpressionScope");
  var IT = class extends AT {
    static {
      n(this, "UtilParser");
    }
    addExtra(t, r, i, s = !0) {
      if (!t) return;
      let {
        extra: a
      } = t;
      a == null && (a = {}, t.extra = a), s ? a[r] = i : Object.defineProperty(a, r, {
        enumerable: s,
        value: i
      });
    }
    isContextual(t) {
      return this.state.type === t && !this.state.containsEsc;
    }
    isUnparsedContextual(t, r) {
      if (this.input.startsWith(r, t)) {
        let i = this.input.charCodeAt(t + r.length);
        return !(Wo(i) || (i & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(t) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, t);
    }
    eatContextual(t) {
      return this.isContextual(t) ? (this.next(), !0) : !1;
    }
    expectContextual(t, r) {
      if (!this.eatContextual(t)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, t);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return GR(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return GR(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(t = !0) {
      (t ? this.isLineTerminator() : this.eat(13)) || this.raise(R.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(t, r) {
      this.eat(t) || this.unexpected(r, t);
    }
    tryParse(t, r = this.state.clone()) {
      let i = {
        node: null
      };
      try {
        let s = t((a = null) => {
          throw i.node = a, i;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: s,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: s,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (s) {
        let a = this.state;
        if (this.state = r, s instanceof SyntaxError)
          return {
            node: null,
            error: s,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (s === i)
          return {
            node: i.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw s;
      }
    }
    checkExpressionErrors(t, r) {
      if (!t) return !1;
      let {
        shorthandAssignLoc: i,
        doubleProtoLoc: s,
        privateKeyLoc: a,
        optionalParametersLoc: o,
        voidPatternLoc: u
      } = t, l = !!i || !!s || !!o || !!a || !!u;
      if (!r)
        return l;
      i != null && this.raise(R.InvalidCoverInitializedName, i), s != null && this.raise(R.DuplicateProto, s), a != null && this.raise(R.UnexpectedPrivateField,
      a), o != null && this.unexpected(o), u != null && this.raise(R.InvalidCoverDiscardElement, u);
    }
    isLiteralPropertyName() {
      return aL(this.state.type);
    }
    isPrivateName(t) {
      return t.type === "PrivateName";
    }
    getPrivateNameSV(t) {
      return t.id.name;
    }
    hasPropertyAsPrivateName(t) {
      return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
    }
    isObjectProperty(t) {
      return t.type === "ObjectProperty";
    }
    isObjectMethod(t) {
      return t.type === "ObjectMethod";
    }
    initializeScopes(t = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let i = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let s = this.inModule;
      this.inModule = t;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, t);
      let u = this.prodParam;
      this.prodParam = new ET();
      let l = this.classScope;
      this.classScope = new PT(this);
      let c = this.expressionScope;
      return this.expressionScope = new FT(this), () => {
        this.state.labels = r, this.exportedIdentifiers = i, this.inModule = s, this.scope = a, this.prodParam = u, this.classScope = l, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let t = 0;
      (this.inModule || this.optionFlags & 1) && (t |= 2), this.optionFlags & 32 && (t |= 1);
      let r = !this.inModule && this.options.sourceType === "commonjs";
      (r || this.optionFlags & 2) && (t |= 4), this.prodParam.enter(t);
      let i = r ? 514 : 1;
      this.optionFlags & 4 && (i |= 512), this.scope.enter(i);
    }
    checkDestructuringPrivate(t) {
      let {
        privateKeyLoc: r
      } = t;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, $l = class {
    static {
      n(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null, this.voidPatternLoc =
      null;
    }
  }, Hl = class {
    static {
      n(this, "Node");
    }
    constructor(t, r, i) {
      this.type = "", this.start = r, this.end = 0, this.loc = new Vl(i), t?.optionFlags & 128 && (this.range = [r, 0]), t != null && t.filename &&
      (this.loc.filename = t.filename);
    }
  }, OT = Hl.prototype;
  OT.__clone = function() {
    let e = new Hl(void 0, this.start, this.loc.start), t = Object.keys(this);
    for (let r = 0, i = t.length; r < i; r++) {
      let s = t[r];
      s !== "leadingComments" && s !== "trailingComments" && s !== "innerComments" && (e[s] = this[s]);
    }
    return e;
  };
  var kT = class extends IT {
    static {
      n(this, "NodeUtils");
    }
    startNode() {
      let t = this.state.startLoc;
      return new Hl(this, t.index, t);
    }
    startNodeAt(t) {
      return new Hl(this, t.index, t);
    }
    startNodeAtNode(t) {
      return this.startNodeAt(t.loc.start);
    }
    finishNode(t, r) {
      return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(t, r, i) {
      return t.type = r, t.end = i.index, t.loc.end = i, this.optionFlags & 128 && (t.range[1] = i.index), this.optionFlags & 4096 && this.processComment(
      t), t;
    }
    resetStartLocation(t, r) {
      t.start = r.index, t.loc.start = r, this.optionFlags & 128 && (t.range[0] = r.index);
    }
    resetEndLocation(t, r = this.state.lastTokEndLoc) {
      t.end = r.index, t.loc.end = r, this.optionFlags & 128 && (t.range[1] = r.index);
    }
    resetStartLocationFromNode(t, r) {
      this.resetStartLocation(t, r.loc.start);
    }
    castNodeTo(t, r) {
      return t.type = r, t;
    }
    cloneIdentifier(t) {
      let {
        type: r,
        start: i,
        end: s,
        loc: a,
        range: o,
        name: u
      } = t, l = Object.create(OT);
      return l.type = r, l.start = i, l.end = s, l.loc = a, l.range = o, l.name = u, t.extra && (l.extra = t.extra), l;
    }
    cloneStringLiteral(t) {
      let {
        type: r,
        start: i,
        end: s,
        loc: a,
        range: o,
        extra: u
      } = t, l = Object.create(OT);
      return l.type = r, l.start = i, l.end = s, l.loc = a, l.range = o, l.extra = u, l.value = t.value, l;
    }
  }, BT = /* @__PURE__ */ n((e) => e.type === "ParenthesizedExpression" ? BT(e.expression) : e, "unwrapParenthesizedExpression"), NT = class extends kT {
    static {
      n(this, "LValParser");
    }
    toAssignable(t, r = !1) {
      var i, s;
      let a;
      switch ((t.type === "ParenthesizedExpression" || (i = t.extra) != null && i.parenthesized) && (a = BT(t), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(R.InvalidParenthesizedAssignment, t) : a.type !== "CallExpression" && a.type !==
      "MemberExpression" && !this.isOptionalMemberExpression(a) && this.raise(R.InvalidParenthesizedAssignment, t) : this.raise(R.InvalidParenthesizedAssignment,
      t)), t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          break;
        case "ObjectExpression":
          this.castNodeTo(t, "ObjectPattern");
          for (let u = 0, l = t.properties.length, c = l - 1; u < l; u++) {
            var o;
            let f = t.properties[u], m = u === c;
            this.toAssignableObjectExpressionProp(f, m, r), m && f.type === "RestElement" && (o = t.extra) != null && o.trailingCommaLoc && this.
            raise(R.RestTrailingComma, t.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: u,
            value: l
          } = t;
          this.isPrivateName(u) && this.classScope.usePrivateName(this.getPrivateNameSV(u), u.loc.start), this.toAssignable(l, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          this.castNodeTo(t, "ArrayPattern"), this.toAssignableList(t.elements, (s = t.extra) == null ? void 0 : s.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          t.operator !== "=" && this.raise(R.MissingEqInAssignment, t.left.loc.end), this.castNodeTo(t, "AssignmentPattern"), delete t.operator,
          t.left.type === "VoidPattern" && this.raise(R.VoidPatternInitializer, t.left), this.toAssignable(t.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(t, r, i) {
      if (t.type === "ObjectMethod")
        this.raise(t.kind === "get" || t.kind === "set" ? R.PatternHasAccessor : R.PatternHasMethod, t.key);
      else if (t.type === "SpreadElement") {
        this.castNodeTo(t, "RestElement");
        let s = t.argument;
        this.checkToRestConversion(s, !1), this.toAssignable(s, i), r || this.raise(R.RestTrailingComma, t);
      } else
        this.toAssignable(t, i);
    }
    toAssignableList(t, r, i) {
      let s = t.length - 1;
      for (let a = 0; a <= s; a++) {
        let o = t[a];
        o && (this.toAssignableListItem(t, a, i), o.type === "RestElement" && (a < s ? this.raise(R.RestTrailingComma, o) : r && this.raise(
        R.RestTrailingComma, r)));
      }
    }
    toAssignableListItem(t, r, i) {
      let s = t[r];
      if (s.type === "SpreadElement") {
        this.castNodeTo(s, "RestElement");
        let a = s.argument;
        this.checkToRestConversion(a, !0), this.toAssignable(a, i);
      } else
        this.toAssignable(s, i);
    }
    isAssignable(t, r) {
      switch (t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          return !0;
        case "ObjectExpression": {
          let i = t.properties.length - 1;
          return t.properties.every((s, a) => s.type !== "ObjectMethod" && (a === i || s.type !== "SpreadElement") && this.isAssignable(s));
        }
        case "ObjectProperty":
          return this.isAssignable(t.value);
        case "SpreadElement":
          return this.isAssignable(t.argument);
        case "ArrayExpression":
          return t.elements.every((i) => i === null || this.isAssignable(i));
        case "AssignmentExpression":
          return t.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(t.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(t, r) {
      return t;
    }
    toReferencedListDeep(t, r) {
      this.toReferencedList(t, r);
      for (let i of t)
        i?.type === "ArrayExpression" && this.toReferencedListDeep(i.elements);
    }
    parseSpread(t) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let t = this.startNode();
      this.next();
      let r = this.parseBindingAtom();
      return r.type === "VoidPattern" && this.raise(R.UnexpectedVoidPattern, r), t.argument = r, this.finishNode(t, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let t = this.startNode();
          return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
        case 88:
          return this.parseVoidPattern(null);
      }
      return this.parseIdentifier();
    }
    parseBindingList(t, r, i) {
      let s = i & 1, a = [], o = !0;
      for (; !this.eat(t); )
        if (o ? o = !1 : this.expect(12), s && this.match(12))
          a.push(null);
        else {
          if (this.eat(t))
            break;
          if (this.match(21)) {
            let u = this.parseRestBinding();
            if ((this.hasPlugin("flow") || i & 2) && (u = this.parseFunctionParamType(u)), a.push(u), !this.checkCommaAfterRest(r)) {
              this.expect(t);
              break;
            }
          } else {
            let u = [];
            if (i & 2)
              for (this.match(26) && this.hasPlugin("decorators") && this.raise(R.UnsupportedParameterDecorator, this.state.startLoc); this.
              match(26); )
                u.push(this.parseDecorator());
            a.push(this.parseBindingElement(i, u));
          }
        }
      return a;
    }
    parseBindingRestProperty(t) {
      return this.next(), this.hasPlugin("discardBinding") && this.match(88) ? (t.argument = this.parseVoidPattern(null), this.raise(R.UnexpectedVoidPattern,
      t.argument)) : t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: t,
        startLoc: r
      } = this.state;
      if (t === 21)
        return this.parseBindingRestProperty(this.startNode());
      let i = this.startNode();
      return t === 139 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), i.key = this.parsePrivateName()) :
      this.parsePropertyName(i), i.method = !1, this.parseObjPropValue(i, r, !1, !1, !0, !1);
    }
    parseBindingElement(t, r) {
      let i = this.parseMaybeDefault();
      return (this.hasPlugin("flow") || t & 2) && this.parseFunctionParamType(i), r.length && (i.decorators = r, this.resetStartLocationFromNode(
      i, r[0])), this.parseMaybeDefault(i.loc.start, i);
    }
    parseFunctionParamType(t) {
      return t;
    }
    parseMaybeDefault(t, r) {
      if (t ?? (t = this.state.startLoc), r = r ?? this.parseBindingAtom(), !this.eat(29)) return r;
      let i = this.startNodeAt(t);
      return r.type === "VoidPattern" && this.raise(R.VoidPatternInitializer, r), i.left = r, i.right = this.parseMaybeAssignAllowIn(), this.
      finishNode(i, "AssignmentPattern");
    }
    isValidLVal(t, r, i, s) {
      switch (t) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
        case "VoidPattern":
          return !0;
        case "CallExpression":
          if (!r && !this.state.strict && this.optionFlags & 8192)
            return !0;
      }
      return !1;
    }
    isOptionalMemberExpression(t) {
      return t.type === "OptionalMemberExpression";
    }
    checkLVal(t, r, i = 64, s = !1, a = !1, o = !1, u = !1) {
      var l;
      let c = t.type;
      if (this.isObjectMethod(t)) return;
      let f = this.isOptionalMemberExpression(t);
      if (f || c === "MemberExpression") {
        f && (this.expectPlugin("optionalChainingAssign", t.loc.start), r.type !== "AssignmentExpression" && this.raise(R.InvalidLhsOptionalChaining,
        t, {
          ancestor: r
        })), i !== 64 && this.raise(R.InvalidPropertyBindingPattern, t);
        return;
      }
      if (c === "Identifier") {
        this.checkIdentifier(t, i, a);
        let {
          name: b
        } = t;
        s && (s.has(b) ? this.raise(R.ParamDupe, t) : s.add(b));
        return;
      } else c === "VoidPattern" && r.type === "CatchClause" && this.raise(R.VoidPatternCatchClauseParam, t);
      let m = BT(t);
      u || (u = m.type === "CallExpression" && (m.callee.type === "Import" || m.callee.type === "Super"));
      let h = this.isValidLVal(c, u, !(o || (l = t.extra) != null && l.parenthesized) && r.type === "AssignmentExpression", i);
      if (h === !0) return;
      if (h === !1) {
        let b = i === 64 ? R.InvalidLhs : R.InvalidLhsBinding;
        this.raise(b, t, {
          ancestor: r
        });
        return;
      }
      let d, y;
      typeof h == "string" ? (d = h, y = c === "ParenthesizedExpression") : [d, y] = h;
      let p = c === "ArrayPattern" || c === "ObjectPattern" ? {
        type: c
      } : r, g = t[d];
      if (Array.isArray(g))
        for (let b of g)
          b && this.checkLVal(b, p, i, s, a, y, !0);
      else g && this.checkLVal(g, p, i, s, a, y, u);
    }
    checkIdentifier(t, r, i = !1) {
      this.state.strict && (i ? dL(t.name, this.inModule) : fL(t.name)) && (r === 64 ? this.raise(R.StrictEvalArguments, t, {
        referenceName: t.name
      }) : this.raise(R.StrictEvalArgumentsBinding, t, {
        bindingName: t.name
      })), r & 8192 && t.name === "let" && this.raise(R.LetInLexicalBinding, t), r & 64 || this.declareNameFromIdentifier(t, r);
    }
    declareNameFromIdentifier(t, r) {
      this.scope.declareName(t.name, r, t.loc.start);
    }
    checkToRestConversion(t, r) {
      switch (t.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(t.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(R.InvalidRestAssignmentPattern, t);
      }
    }
    checkCommaAfterRest(t) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? R.RestTrailingComma : R.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  }, hT = /in(?:stanceof)?|as|satisfies/y;
  function UPe(e) {
    if (e == null)
      throw new Error(`Unexpected ${e} value.`);
    return e;
  }
  n(UPe, "nonNull");
  function eL(e) {
    if (!e)
      throw new Error("Assert fail");
  }
  n(eL, "assert");
  var me = Qs`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ n(({
      methodName: e
    }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ n(({
      propertyName: e
    }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or num\
eric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ n(({
      kind: e
    }) => `'declare' is not allowed in ${e}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ n(({
      modifier: e
    }) => `Accessibility modifier already seen: '${e}'.`, "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ n(({
      modifier: e
    }) => `Duplicate modifier: '${e}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ n(({
      token: e
    }) => `'${e}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ n(({
      modifiers: e
    }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ n(({
      modifier: e
    }) => `Index signatures cannot have an accessibility modifier ('${e}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidHeritageClauseType: /* @__PURE__ */ n(({
      token: e
    }) => `'${e}' list can only include identifiers or qualified-names with optional type arguments.`, "InvalidHeritageClauseType"),
    InvalidModifierOnAwaitUsingDeclaration: /* @__PURE__ */ n((e) => `'${e}' modifier cannot appear on an await using declaration.`, "Invali\
dModifierOnAwaitUsingDeclaration"),
    InvalidModifierOnTypeMember: /* @__PURE__ */ n(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ n(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ n(({
      modifier: e
    }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifierOnUsingDeclaration: /* @__PURE__ */ n((e) => `'${e}' modifier cannot appear on a using declaration.`, "InvalidModifierOnU\
singDeclaration"),
    InvalidModifiersOrder: /* @__PURE__ */ n(({
      orderedModifiers: e
    }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ n(({
      modifier: e
    }) => `Private elements cannot have an accessibility modifier ('${e}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ n(({
      typeParameterName: e
    }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ n(({
      type: e
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`, "UnsupportedSignatureParameterKind"),
    UsingDeclarationInAmbientContext: /* @__PURE__ */ n((e) => `'${e}' declarations are not allowed in ambient contexts.`, "UsingDeclaration\
InAmbientContext")
  });
  function $Pe(e) {
    switch (e) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  n($Pe, "keywordTypeFromName");
  function tL(e) {
    return e === "private" || e === "public" || e === "protected";
  }
  n(tL, "tsIsAccessModifier");
  function VPe(e) {
    return e === "in" || e === "out";
  }
  n(VPe, "tsIsVarianceAnnotations");
  var WPe = /* @__PURE__ */ n((e) => class extends e {
    static {
      n(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: me.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: me.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: me.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return xT;
    }
    tsIsIdentifier() {
      return pt(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(r, i, s) {
      if (!pt(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let a = this.state.value;
      if (r.includes(a)) {
        if (s && this.match(106) || i && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return a;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: i,
      stopOnStartOfClassStaticBlock: s,
      errorTemplate: a = me.InvalidModifierOnTypeMember
    }, o) {
      let u = /* @__PURE__ */ n((c, f, m, h) => {
        f === m && o[h] && this.raise(me.InvalidModifiersOrder, c, {
          orderedModifiers: [m, h]
        });
      }, "enforceOrder"), l = /* @__PURE__ */ n((c, f, m, h) => {
        (o[m] && f === h || o[h] && f === m) && this.raise(me.IncompatibleModifiers, c, {
          modifiers: [m, h]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, f = this.tsParseModifier(r.concat(i ?? []), s, o.static);
        if (!f) break;
        tL(f) ? o.accessibility ? this.raise(me.DuplicateAccessibilityModifier, c, {
          modifier: f
        }) : (u(c, f, f, "override"), u(c, f, f, "static"), u(c, f, f, "readonly"), o.accessibility = f) : VPe(f) ? (o[f] && this.raise(me.DuplicateModifier,
        c, {
          modifier: f
        }), o[f] = !0, u(c, f, "in", "out")) : (hasOwnProperty.call(o, f) ? this.raise(me.DuplicateModifier, c, {
          modifier: f
        }) : (u(c, f, "static", "readonly"), u(c, f, "static", "override"), u(c, f, "override", "readonly"), u(c, f, "abstract", "override"),
        l(c, f, "declare", "override"), l(c, f, "static", "abstract")), o[f] = !0), i != null && i.includes(f) && this.raise(a, c, {
          modifier: f
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, i) {
      let s = [];
      for (; !this.tsIsListTerminator(r); )
        s.push(i());
      return s;
    }
    tsParseDelimitedList(r, i, s) {
      return UPe(this.tsParseDelimitedListWorker(r, i, !0, s));
    }
    tsParseDelimitedListWorker(r, i, s, a) {
      let o = [], u = -1;
      for (; !this.tsIsListTerminator(r); ) {
        u = -1;
        let l = i();
        if (l == null)
          return;
        if (o.push(l), this.eat(12)) {
          u = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        s && this.expect(12);
        return;
      }
      return a && (a.value = u), o;
    }
    tsParseBracketedList(r, i, s, a, o) {
      a || (s ? this.expect(0) : this.expect(47));
      let u = this.tsParseDelimitedList(r, i, o);
      return s ? this.expect(3) : this.expect(48), u;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? r.argument = this.parseStringLiteral(this.state.value) : (this.raise(me.UnsupportedImportTypeArgument,
      this.state.startLoc), r.argument = super.parseExprAtom()), this.eat(12) ? r.options = this.tsParseImportTypeOptions() : r.options = null,
      this.expect(11), this.eat(16) && (r.qualifier = this.tsParseEntityName(3)), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSImportType");
    }
    tsParseImportTypeOptions() {
      let r = this.startNode();
      this.expect(5);
      let i = this.startNode();
      return this.isContextual(76) ? (i.method = !1, i.key = this.parseIdentifier(!0), i.computed = !1, i.shorthand = !1) : this.unexpected(
      null, 76), this.expect(14), i.value = this.tsParseImportTypeWithPropertyValue(), r.properties = [this.finishObjectProperty(i)], this.eat(
      12), this.expect(8), this.finishNode(r, "ObjectExpression");
    }
    tsParseImportTypeWithPropertyValue() {
      let r = this.startNode(), i = [];
      for (this.expect(5); !this.match(8); ) {
        let s = this.state.type;
        pt(s) || s === 134 ? i.push(super.parsePropertyDefinition(null)) : this.unexpected(), this.eat(12);
      }
      return r.properties = i, this.next(), this.finishNode(r, "ObjectExpression");
    }
    tsParseEntityName(r) {
      let i;
      if (r & 1 && this.match(78))
        if (r & 2)
          i = this.parseIdentifier(!0);
        else {
          let s = this.startNode();
          this.next(), i = this.finishNode(s, "ThisExpression");
        }
      else
        i = this.parseIdentifier(!!(r & 1));
      for (; this.eat(16); ) {
        let s = this.startNodeAtNode(i);
        s.left = i, s.right = this.parseIdentifier(!!(r & 1)), i = this.finishNode(s, "TSQualifiedName");
      }
      return i;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let i = this.startNodeAtNode(r);
      return i.parameterName = r, i.typeAnnotation = this.tsParseTypeAnnotation(!1), i.asserts = !1, this.finishNode(i, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let i = this.startNode();
      return r(i), i.name = this.tsParseTypeParameterName(), i.constraint = this.tsEatThenParseType(81), i.default = this.tsEatThenParseType(
      29), this.finishNode(i, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let i = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let s = {
        value: -1
      };
      return i.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, s), i.params.
      length === 0 && this.raise(me.EmptyTypeParameters, i), s.value !== -1 && this.addExtra(i, "trailingComma", s.value), this.finishNode(i,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, i) {
      let s = r === 19, a = "parameters", o = "typeAnnotation";
      i.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), i[a] = this.tsParseBindingListForSignature(),
      s ? i[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (i[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let i of r) {
        let {
          type: s
        } = i;
        (s === "AssignmentPattern" || s === "TSParameterProperty") && this.raise(me.UnsupportedSignatureParameterKind, i, {
          type: s
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, i) {
      return this.tsFillSignature(14, i), this.tsParseTypeMemberSemicolon(), this.finishNode(i, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), pt(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let i = this.parseIdentifier();
      i.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(i), this.expect(3), r.parameters = [i];
      let s = this.tsTryParseTypeAnnotation();
      return s && (r.typeAnnotation = s), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, i) {
      if (this.eat(17) && (r.optional = !0), this.match(10) || this.match(47)) {
        i && this.raise(me.ReadonlyForMethodSignature, r);
        let s = r;
        s.kind && this.match(47) && this.raise(me.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, s), this.
        tsParseTypeMemberSemicolon();
        let a = "parameters", o = "typeAnnotation";
        if (s.kind === "get")
          s[a].length > 0 && (this.raise(R.BadGetterArity, this.state.curPosition()), this.isThisParam(s[a][0]) && this.raise(me.AccessorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (s.kind === "set") {
          if (s[a].length !== 1)
            this.raise(R.BadSetterArity, this.state.curPosition());
          else {
            let u = s[a][0];
            this.isThisParam(u) && this.raise(me.AccessorCannotDeclareThisParameter, this.state.curPosition()), u.type === "Identifier" && u.
            optional && this.raise(me.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), u.type === "RestElement" && this.raise(
            me.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          s[o] && this.raise(me.SetAccessorCannotHaveReturnType, s[o]);
        } else
          s.kind = "method";
        return this.finishNode(s, "TSMethodSignature");
      } else {
        let s = r;
        i && (s.readonly = !0);
        let a = this.tsTryParseTypeAnnotation();
        return a && (s.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(s, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let s = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(s, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let i = this.tsTryParseIndexSignature(r);
      return i || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r), !this.match(10) && !this.match(47) && this.unexpected(
      null, 10)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      let r = this.startNode();
      this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) &&
      (r.readonly = !0), this.expect(0);
      {
        let i = this.startNode();
        i.name = this.tsParseTypeParameterName(), i.constraint = this.tsExpectThenParseType(58), r.typeParameter = this.finishNode(i, "TSTyp\
eParameter");
      }
      return r.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value,
      this.next(), this.expect(17)) : this.eat(17) && (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(
      8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let i = !1;
      return r.elementTypes.forEach((s) => {
        let {
          type: a
        } = s;
        i && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && s.optional) && this.raise(me.OptionalTypeBeforeRequired,
        s), i || (i = a === "TSNamedTupleMember" && s.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let r = this.state.startLoc, i = this.eat(21), {
        startLoc: s
      } = this.state, a, o, u, l, f = hs(this.state.type) ? this.lookaheadCharCode() : null;
      if (f === 58)
        a = !0, u = !1, o = this.parseIdentifier(!0), this.expect(14), l = this.tsParseType();
      else if (f === 63) {
        u = !0;
        let m = this.state.value, h = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (a = !0, o = this.createIdentifier(this.startNodeAt(s), m), this.expect(17), this.expect(14), l = this.
        tsParseType()) : (a = !1, l = h, this.expect(17));
      } else
        l = this.tsParseType(), u = this.eat(17), a = this.eat(14);
      if (a) {
        let m;
        o ? (m = this.startNodeAt(s), m.optional = u, m.label = o, m.elementType = l, this.eat(17) && (m.optional = !0, this.raise(me.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (m = this.startNodeAt(s), m.optional = u, this.raise(me.InvalidTupleMemberLabel, l), m.label = l, m.
        elementType = this.tsParseType()), l = this.finishNode(m, "TSNamedTupleMember");
      } else if (u) {
        let m = this.startNodeAt(s);
        m.typeAnnotation = l, l = this.finishNode(m, "TSOptionalType");
      }
      if (i) {
        let m = this.startNodeAt(r);
        m.typeAnnotation = l, l = this.finishNode(m, "TSRestType");
      }
      return l;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, i) {
      let s = this.startNode();
      return r === "TSConstructorType" && (s.abstract = !!i, i && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, s)), this.finishNode(s, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        let r = this.startNode();
        return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), i = this.lookahead();
            return i.type !== 135 && i.type !== 136 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (pt(r) || r === 88 || r === 84) {
            let i = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : $Pe(this.state.value);
            if (i !== void 0 && this.lookaheadCharCode() !== 46) {
              let s = this.startNode();
              return this.next(), this.finishNode(s, i);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let {
        startLoc: r
      } = this.state, i = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let s = this.startNodeAt(r);
          s.elementType = i, this.expect(3), i = this.finishNode(s, "TSArrayType");
        } else {
          let s = this.startNodeAt(r);
          s.objectType = i, s.indexType = this.tsParseType(), this.expect(3), i = this.finishNode(s, "TSIndexedAccessType");
        }
      return i;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), i = this.state.value;
      return this.next(), r.operator = i, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), i === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(me.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let i = this.startNode();
      return i.name = this.tsParseTypeParameterName(), i.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(i, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return cPe(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, i, s) {
      let a = this.startNode(), o = this.eat(s), u = [];
      do
        u.push(i());
      while (this.eat(s));
      return u.length === 1 && !o ? u[0] : (a.types = u, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (pt(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === i;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, i = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === i;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let i = this.startNode();
        this.expect(r);
        let s = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let l = this.tsParseThisTypeOrThisTypePredicate();
          return l.type === "TSThisType" ? (s.parameterName = l, s.asserts = !0, s.typeAnnotation = null, l = this.finishNode(s, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(l, s), l.asserts = !0), i.typeAnnotation = l, this.finishNode(i, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (s.parameterName = this.parseIdentifier(), s.asserts = a, s.typeAnnotation = null, i.typeAnnotation = this.finishNode(s,
          "TSTypePredicate"), this.finishNode(i, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, i);
        let u = this.tsParseTypeAnnotation(!1);
        return s.parameterName = o, s.typeAnnotation = u, s.asserts = a, i.typeAnnotation = this.finishNode(s, "TSTypePredicate"), this.finishNode(
        i, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !pt(this.state.type) && !this.match(78) ? !1 : (r && this.raise(R.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, i = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), i.typeAnnotation = this.tsParseType();
      }), this.finishNode(i, "TSTypeAnnotation");
    }
    tsParseType() {
      eL(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let i = this.startNodeAtNode(r);
      return i.checkType = r, i.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), i.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), i.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(i, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.isLookaheadContextual("new");
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(me.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let i = this.state.startLoc, s = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          let a = this.startNode();
          return a.expression = this.tsParseEntityName(3), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
          a, "TSExpressionWithTypeArguments");
        }
      });
      return s.length || this.raise(me.EmptyHeritageClauseType, i, {
        token: r
      }), s;
    }
    tsParseInterfaceDeclaration(r, i = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), i.declare && (r.declare = !0), pt(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(me.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let s = this.startNode();
      return s.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(s, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookaheadCharCode() !==
        46) {
          let i = this.startNode();
          return this.next(), this.finishNode(i, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(r) {
      if (this.curContext() !== at.brace) {
        let i = this.state.context;
        this.state.context = [i[0]];
        try {
          return r();
        } finally {
          this.state.context = i;
        }
      } else
        return r();
    }
    tsInType(r) {
      let i = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = i;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let i = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = i;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, i = {}) {
      return i.const && (r.const = !0), i.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      let r = this.startNode();
      return this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(
      r, "TSEnumBody");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, i = !1) {
      if (r.id = this.parseIdentifier(), i || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let s = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(s, !0), r.body = s;
      } else
        this.scope.enter(1024), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.kind = "global", r.global = !0, r.id = this.parseIdentifier()) : this.match(134) ? (r.kind = "modul\
e", r.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(1024), this.prodParam.enter(0),
      r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclarat\
ion");
    }
    tsParseImportEqualsDeclaration(r, i, s) {
      r.isExport = s || !1, r.id = i || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(me.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let i = this.state.clone(), s = r();
      return this.state = i, s;
    }
    tsTryParseAndCatch(r) {
      let i = this.tryParse((s) => r() || s());
      if (!(i.aborted || !i.node))
        return i.error && (this.state = i.failState), i.node;
    }
    tsTryParse(r) {
      let i = this.state.clone(), s = r();
      if (s !== void 0 && s !== !1)
        return s;
      this.state = i;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let i = this.state.type;
      return this.tsInAmbientContext(() => {
        switch (i) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 100:
            if (this.state.containsEsc)
              return;
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, this.state.value, !0)) :
            (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 107:
            if (this.isUsing())
              return this.raise(me.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare"), r.declare = !0, this.parseVarStatement(
              r, "using", !0);
            break;
          case 96:
            if (this.isAwaitUsing())
              return this.raise(me.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare"), r.declare = !0, this.next(), this.
              parseVarStatement(r, "await using", !0);
            break;
          case 129: {
            let s = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (s) return s;
          }
          default:
            if (pt(i))
              return this.tsParseDeclaration(r, this.state.type, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.type, !0, null);
    }
    tsParseDeclaration(r, i, s, a) {
      switch (i) {
        case 124:
          if (this.tsCheckLineTerminator(s) && (this.match(80) || pt(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case 127:
          if (this.tsCheckLineTerminator(s)) {
            if (this.match(134))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (pt(this.state.type))
              return r.kind = "module", this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case 128:
          if (this.tsCheckLineTerminator(s) && pt(this.state.type))
            return r.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case 130:
          if (this.tsCheckLineTerminator(s) && pt(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let i = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let s = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = i, !!s)
        return super.parseArrowExpression(s, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArgu\
ments", this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(me.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      at.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return fPe(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseBindingElement(r, i) {
      let s = i.length ? i[0].loc.start : this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, u = a.override, l = a.readonly;
      !(r & 4) && (o || l || u) && this.raise(me.UnexpectedParameterModifier, s);
      let c = this.parseMaybeDefault();
      r & 2 && this.parseFunctionParamType(c);
      let f = this.parseMaybeDefault(c.loc.start, c);
      if (o || l || u) {
        let m = this.startNodeAt(s);
        return i.length && (m.decorators = i), o && (m.accessibility = o), l && (m.readonly = l), u && (m.override = u), f.type !== "Identif\
ier" && f.type !== "AssignmentPattern" && this.raise(me.UnsupportedParameterPropertyKind, m), m.parameter = f, this.finishNode(m, "TSParamet\
erProperty");
      }
      return i.length && (c.decorators = i), f;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let i of r.params)
        i.type !== "Identifier" && i.optional && !this.state.isAmbientContext && this.raise(me.PatternIsOptional, i);
    }
    setArrowFunctionParameters(r, i, s) {
      super.setArrowFunctionParameters(r, i, s), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, i, s = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = i === "FunctionDeclaration" ? "TSDeclareFunction" : i === "ClassMethod" || i === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(me.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, s) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, i, s));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((i) => {
        i?.type === "TSTypeCastExpression" && this.raise(me.UnexpectedTypeAnnotation, i.typeAnnotation);
      });
    }
    toReferencedList(r, i) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, i, s) {
      let a = super.parseArrayLike(r, i, s);
      return a.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(a.elements), a;
    }
    parseSubscript(r, i, s, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let u = this.startNodeAt(i);
        return u.expression = r, this.finishNode(u, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (s)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let u, l = this.tsTryParseAndCatch(() => {
          if (!s && this.atPossibleAsyncArrow(r)) {
            let h = this.tsTryParseGenericAsyncArrowFunction(i);
            if (h)
              return a.stop = !0, h;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            u = this.state.curPosition();
            return;
          }
          if (Qm(this.state.type)) {
            let h = super.parseTaggedTemplateExpression(r, i, a);
            return h.typeParameters = c, h;
          }
          if (!s && this.eat(10)) {
            let h = this.startNodeAt(i);
            return h.callee = r, h.arguments = this.parseCallExpressionArguments(), this.tsCheckForInvalidTypeCasts(h.arguments), h.typeParameters =
            c, a.optionalChainMember && (h.optional = o), this.finishCallExpression(h, a.optionalChainMember);
          }
          let f = this.state.type;
          if (f === 48 || f === 52 || f !== 10 && Md(f) && !this.hasPrecedingLineBreak())
            return;
          let m = this.startNodeAt(i);
          return m.expression = r, m.typeParameters = c, this.finishNode(m, "TSInstantiationExpression");
        });
        if (u && this.unexpected(u, 10), l)
          return l.type === "TSInstantiationExpression" && ((this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          me.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), !this.match(16) && !this.match(18) && (l.expression = super.
          stopParseSubscript(r, a))), l;
      }
      return super.parseSubscript(r, i, s, a);
    }
    parseNewCallee(r) {
      var i;
      super.parseNewCallee(r);
      let {
        callee: s
      } = r;
      s.type === "TSInstantiationExpression" && !((i = s.extra) != null && i.parenthesized) && (r.typeParameters = s.typeParameters, r.callee =
      s.expression);
    }
    parseExprOp(r, i, s) {
      let a;
      if (Ym(58) > s && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(i);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(R.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, i, s);
      }
      return super.parseExprOp(r, i, s);
    }
    checkReservedWord(r, i, s, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, i, s, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(me.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let i = this.lookaheadCharCode();
        return r ? i === 123 || i === 42 : i !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, i, s, a) {
      super.applyImportPhase(r, i, s, a), i ? r.exportKind = s === "type" ? "type" : "value" : r.importKind = s === "type" || s === "typeof" ?
      s : "value";
    }
    parseImport(r) {
      if (this.match(134))
        return r.importKind = "value", super.parseImport(r);
      let i;
      if (pt(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let s = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, s);
        i = super.parseImportSpecifiersAndAfter(r, s);
      } else
        i = super.parseImport(r);
      return i.importKind === "type" && i.specifiers.length > 1 && i.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(me.TypeImportCannotSpecifyDefaultAndNamed,
      i), i;
    }
    parseExport(r, i) {
      if (this.match(83)) {
        let s = r;
        this.next();
        let a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(s, !1) : s.importKind = "value", this.
        tsParseImportEqualsDeclaration(s, a, !0);
      } else if (this.eat(29)) {
        let s = r;
        return s.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(s, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let s = r;
        return this.expectContextual(128), s.id = this.parseIdentifier(), this.semicolon(), this.finishNode(s, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, i);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.isLookaheadContextual("class");
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, i, s = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, i, s || a);
      if (!a) return o;
      if (!r.declare && (i === "using" || i === "await using"))
        return this.raiseOverwrite(me.UsingDeclarationInAmbientContext, r, i), o;
      for (let {
        id: u,
        init: l
      } of o.declarations)
        l && (i === "var" || i === "let" || u.typeAnnotation ? this.raise(me.InitializerNotAllowedInAmbientContext, l) : KPe(l, this.hasPlugin(
        "estree")) || this.raise(me.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, l));
      return o;
    }
    parseStatementContent(r, i) {
      if (!this.state.containsEsc)
        switch (this.state.type) {
          case 75: {
            if (this.isLookaheadContextual("enum")) {
              let s = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(s, {
                const: !0
              });
            }
            break;
          }
          case 124:
          case 125: {
            if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {
              let s = this.state.type, a = this.startNode();
              this.next();
              let o = s === 125 ? this.tsTryParseDeclare(a) : this.tsParseAbstractDeclaration(a, i);
              return o ? (s === 125 && (o.declare = !0), o) : (a.expression = this.createIdentifier(this.startNodeAt(a.loc.start), s === 125 ?
              "declare" : "abstract"), this.semicolon(!1), this.finishNode(a, "ExpressionStatement"));
            }
            break;
          }
          case 126:
            return this.tsParseEnumDeclaration(this.startNode());
          case 112: {
            if (this.lookaheadCharCode() === 123) {
              let a = this.startNode();
              return this.tsParseAmbientExternalModuleDeclaration(a);
            }
            break;
          }
          case 129: {
            let s = this.tsParseInterfaceDeclaration(this.startNode());
            if (s) return s;
            break;
          }
          case 127: {
            if (this.nextTokenIsIdentifierOrStringLiteralOnSameLine()) {
              let s = this.startNode();
              return this.next(), this.tsParseDeclaration(s, 127, !1, i);
            }
            break;
          }
          case 128: {
            if (this.nextTokenIsIdentifierOnSameLine()) {
              let s = this.startNode();
              return this.next(), this.tsParseDeclaration(s, 128, !1, i);
            }
            break;
          }
          case 130: {
            if (this.nextTokenIsIdentifierOnSameLine()) {
              let s = this.startNode();
              return this.next(), this.tsParseTypeAliasDeclaration(s);
            }
            break;
          }
        }
      return super.parseStatementContent(r, i);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, i) {
      return i.some((s) => tL(s) ? r.accessibility === s : !!r[s]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, i, s) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: me.InvalidModifierOnTypeParameterPositions
      }, i);
      let o = /* @__PURE__ */ n(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(i, a) && this.raise(me.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, i)) : this.parseClassMemberWithIsStatic(r, i, s, !!i.static);
      }, "callParseClassMemberWithIsStatic");
      i.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, i, s, a) {
      let o = this.tsTryParseIndexSignature(i);
      if (o) {
        r.body.push(o), i.abstract && this.raise(me.IndexSignatureHasAbstract, i), i.accessibility && this.raise(me.IndexSignatureHasAccessibility,
        i, {
          modifier: i.accessibility
        }), i.declare && this.raise(me.IndexSignatureHasDeclare, i), i.override && this.raise(me.IndexSignatureHasOverride, i);
        return;
      }
      !this.state.inAbstractClass && i.abstract && this.raise(me.NonAbstractClassHasAbstractMethod, i), i.override && (s.hadSuperClass || this.
      raise(me.OverrideNotInSubClass, i)), super.parseClassMemberWithIsStatic(r, i, s, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(me.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(me.ClassMethodHasDeclare, r);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, i, s) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let a = this.lookaheadCharCode();
        if (a === 44 || a === 61 || a === 58 || a === 41)
          return this.setOptionalParametersError(s), r;
      }
      return super.parseConditional(r, i, s);
    }
    parseParenItem(r, i) {
      let s = super.parseParenItem(r, i);
      if (this.eat(17) && (s.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(i);
        return a.expression = r, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let i = this.state.startLoc, s = this.eatContextual(125);
      if (s && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(me.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = pt(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || s) && (r.exportKind = "type"), s && o.type !==
      "TSImportEqualsDeclaration" && (this.resetStartLocation(o, i), o.declare = !0), o) : null;
    }
    parseClassId(r, i, s, a) {
      if ((!i || s) && this.isContextual(113))
        return;
      super.parseClassId(r, i, s, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let i = this.tsTryParseTypeAnnotation();
      i && (r.typeAnnotation = i);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(me.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: i
        } = r;
        this.raise(me.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: i.type === "Identifier" && !r.computed ? i.name : `[${this.input.slice(this.offsetToSourcePos(i.start), this.offsetToSourcePos(
          i.end))}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(me.PrivateElementHasAbstract, r), r.accessibility && this.raise(me.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(me.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, i, s, a, o, u) {
      let l = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      l && o && this.raise(me.ConstructorHasTypeParameters, l);
      let {
        declare: c = !1,
        kind: f
      } = i;
      c && (f === "get" || f === "set") && this.raise(me.DeclareAccessor, i, {
        kind: f
      }), l && (i.typeParameters = l), super.pushClassMethod(r, i, s, a, o, u);
    }
    pushClassPrivateMethod(r, i, s, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (i.typeParameters = o), super.pushClassPrivateMethod(r, i, s, a);
    }
    declareClassPrivateMethodInScope(r, i) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && r.value.body == null || super.declareClassPrivateMethodInScope(r, i));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, i, s, a, o, u, l) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, i, s, a, o, u, l);
    }
    parseFunctionParams(r, i) {
      let s = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      s && (r.typeParameters = s), super.parseFunctionParams(r, i);
    }
    parseVarId(r, i) {
      super.parseVarId(r, i), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let s = this.tsTryParseTypeAnnotation();
      s && (r.id.typeAnnotation = s, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, i) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, i);
    }
    parseMaybeAssign(r, i) {
      var s, a, o, u, l;
      let c, f, m;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (c = this.state.clone(), f = this.tryParse(() => super.parseMaybeAssign(r, i), c), !f.error) return f.node;
        let {
          context: y
        } = this.state, p = y[y.length - 1];
        (p === at.j_oTag || p === at.j_expr) && y.pop();
      }
      if (!((s = f) != null && s.error) && !this.match(47))
        return super.parseMaybeAssign(r, i);
      (!c || c === this.state) && (c = this.state.clone());
      let h, d = this.tryParse((y) => {
        var p, g;
        h = this.tsParseTypeParameters(this.tsParseConstModifier);
        let b = super.parseMaybeAssign(r, i);
        return (b.type !== "ArrowFunctionExpression" || (p = b.extra) != null && p.parenthesized) && y(), ((g = h) == null ? void 0 : g.params.
        length) !== 0 && this.resetStartLocationFromNode(b, h), b.typeParameters = h, b;
      }, c);
      if (!d.error && !d.aborted)
        return h && this.reportReservedArrowTypeParam(h), d.node;
      if (!f && (eL(!this.hasPlugin("jsx")), m = this.tryParse(() => super.parseMaybeAssign(r, i), c), !m.error))
        return m.node;
      if ((a = f) != null && a.node)
        return this.state = f.failState, f.node;
      if (d.node)
        return this.state = d.failState, h && this.reportReservedArrowTypeParam(h), d.node;
      if ((o = m) != null && o.node)
        return this.state = m.failState, m.node;
      throw ((u = f) == null ? void 0 : u.error) || d.error || ((l = m) == null ? void 0 : l.error);
    }
    reportReservedArrowTypeParam(r) {
      var i;
      r.params.length === 1 && !r.params[0].constraint && !((i = r.extra) != null && i.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(me.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, i) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, i);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let i = this.tryParse((s) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && s(), a;
        });
        if (i.aborted) return;
        i.thrown || (i.error && (this.state = i.failState), r.returnType = i.node);
      }
      return super.parseArrow(r);
    }
    parseFunctionParamType(r) {
      this.eat(17) && (r.optional = !0);
      let i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i), this.resetEndLocation(r), r;
    }
    isAssignable(r, i) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, i);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, i);
      }
    }
    toAssignable(r, i = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, i);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          i ? this.expressionScope.recordArrowParameterBindingError(me.UnexpectedTypeCastInParameter, r) : this.raise(me.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, i);
          break;
        case "AssignmentExpression":
          !i && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, i);
      }
    }
    toAssignableParenthesizedExpression(r, i) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, i);
          break;
        default:
          super.toAssignable(r, i);
      }
    }
    checkToRestConversion(r, i) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, i);
      }
    }
    isValidLVal(r, i, s, a) {
      switch (r) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (a !== 64 || !s) && ["expression", !0];
        default:
          return super.isValidLVal(r, i, s, a);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r, i) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let a = super.parseMaybeDecoratorArguments(r, i);
          return a.typeParameters = s, a;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r, i);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, i) {
      let s = super.parseMaybeDefault(r, i);
      return s.type === "AssignmentPattern" && s.typeAnnotation && s.right.start < s.typeAnnotation.start && this.raise(me.TypeAnnotationAfterAssign,
      s.typeAnnotation), s;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableListItem(r, i, s) {
      let a = r[i];
      a.type === "TSTypeCastExpression" && (r[i] = this.typeCastToParameter(a)), super.toAssignableListItem(r, i, s);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((i) => this.isAssignable(i, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let i = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        i && (r.typeParameters = i);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let i = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? i + 1 : i;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), i = this.tsTryParseTypeAnnotation();
      return i && (r.typeAnnotation = i, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let {
        isAmbientContext: i,
        strict: s
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = i, this.state.strict = s;
      }
    }
    parseClass(r, i, s) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, i, s);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, i) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(i, this.parseClass(r, !0, !1));
      if (this.isContextual(129))
        return this.hasFollowingLineBreak() ? null : (r.abstract = !0, this.raise(me.NonClassMethodPropertyHasAbstractModifier, r), this.tsParseInterfaceDeclaration(
        r));
      throw this.unexpected(null, 80);
    }
    parseMethod(r, i, s, a, o, u, l) {
      let c = super.parseMethod(r, i, s, a, o, u, l);
      if ((c.abstract || c.type === "TSAbstractMethodDefinition") && (this.hasPlugin("estree") ? c.value : c).body) {
        let {
          key: h
        } = c;
        this.raise(me.AbstractMethodHasImplementation, c, {
          methodName: h.type === "Identifier" && !c.computed ? h.name : `[${this.input.slice(this.offsetToSourcePos(h.start), this.offsetToSourcePos(
          h.end))}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, i, s, a) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, s), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, i, s, a));
    }
    parseImportSpecifier(r, i, s, a, o) {
      return !i && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, s), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, i, s, a, s ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, i, s) {
      let a = i ? "imported" : "local", o = i ? "local" : "exported", u = r[a], l, c = !1, f = !0, m = u.loc.start;
      if (this.isContextual(93)) {
        let d = this.parseIdentifier();
        if (this.isContextual(93)) {
          let y = this.parseIdentifier();
          hs(this.state.type) ? (c = !0, u = d, l = i ? this.parseIdentifier() : this.parseModuleExportName(), f = !1) : (l = y, f = !1);
        } else hs(this.state.type) ? (f = !1, l = i ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, u = d);
      } else hs(this.state.type) && (c = !0, i ? (u = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(u.name, u.loc.
      start, !0, !0)) : u = this.parseModuleExportName());
      c && s && this.raise(i ? me.TypeModifierIsUsedInTypeImports : me.TypeModifierIsUsedInTypeExports, m), r[a] = u, r[o] = l;
      let h = i ? "importKind" : "exportKind";
      r[h] = c ? "type" : "value", f && this.eatContextual(93) && (r[o] = i ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = this.cloneIdentifier(r[a])), i && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
    fillOptionalPropertiesForTSESLint(r) {
      var i, s, a, o, u, l, c, f, m, h, d, y, p, g, b, D, x, T, w, B, k, q, V, Y, G, ye, te, re, ve, je, Be, se, Ne, ke, Cr, Ae, _e, Me, Nt,
      tr, Yr, Ni, pn, co, Os, ks, Bs, fo;
      switch (r.type) {
        case "ExpressionStatement":
          (i = r.directive) != null || (r.directive = void 0);
          return;
        case "RestElement":
          r.value = void 0;
        case "Identifier":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "ObjectPattern":
          (s = r.decorators) != null || (r.decorators = []), (a = r.optional) != null || (r.optional = !1), (o = r.typeAnnotation) != null ||
          (r.typeAnnotation = void 0);
          return;
        case "TSParameterProperty":
          (u = r.accessibility) != null || (r.accessibility = void 0), (l = r.decorators) != null || (r.decorators = []), (c = r.override) !=
          null || (r.override = !1), (f = r.readonly) != null || (r.readonly = !1), (m = r.static) != null || (r.static = !1);
          return;
        case "TSEmptyBodyFunctionExpression":
          r.body = null;
        case "TSDeclareFunction":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          (h = r.declare) != null || (r.declare = !1), (d = r.returnType) != null || (r.returnType = void 0), (y = r.typeParameters) != null ||
          (r.typeParameters = void 0);
          return;
        case "Property":
          (p = r.optional) != null || (r.optional = !1);
          return;
        case "TSMethodSignature":
        case "TSPropertySignature":
          (g = r.optional) != null || (r.optional = !1);
        case "TSIndexSignature":
          (b = r.accessibility) != null || (r.accessibility = void 0), (D = r.readonly) != null || (r.readonly = !1), (x = r.static) != null ||
          (r.static = !1);
          return;
        case "TSAbstractPropertyDefinition":
        case "PropertyDefinition":
        case "TSAbstractAccessorProperty":
        case "AccessorProperty":
          (T = r.declare) != null || (r.declare = !1), (w = r.definite) != null || (r.definite = !1), (B = r.readonly) != null || (r.readonly =
          !1), (k = r.typeAnnotation) != null || (r.typeAnnotation = void 0);
        case "TSAbstractMethodDefinition":
        case "MethodDefinition":
          (q = r.accessibility) != null || (r.accessibility = void 0), (V = r.decorators) != null || (r.decorators = []), (Y = r.override) !=
          null || (r.override = !1), (G = r.optional) != null || (r.optional = !1);
          return;
        case "ClassExpression":
          (ye = r.id) != null || (r.id = null);
        case "ClassDeclaration":
          (te = r.abstract) != null || (r.abstract = !1), (re = r.declare) != null || (r.declare = !1), (ve = r.decorators) != null || (r.decorators =
          []), (je = r.implements) != null || (r.implements = []), (Be = r.superTypeArguments) != null || (r.superTypeArguments = void 0), (se =
          r.typeParameters) != null || (r.typeParameters = void 0);
          return;
        case "TSTypeAliasDeclaration":
        case "VariableDeclaration":
          (Ne = r.declare) != null || (r.declare = !1);
          return;
        case "VariableDeclarator":
          (ke = r.definite) != null || (r.definite = !1);
          return;
        case "TSEnumDeclaration":
          (Cr = r.const) != null || (r.const = !1), (Ae = r.declare) != null || (r.declare = !1);
          return;
        case "TSEnumMember":
          (_e = r.computed) != null || (r.computed = !1);
          return;
        case "TSImportType":
          (Me = r.qualifier) != null || (r.qualifier = null), (Nt = r.options) != null || (r.options = null);
          return;
        case "TSInterfaceDeclaration":
          (tr = r.declare) != null || (r.declare = !1), (Yr = r.extends) != null || (r.extends = []);
          return;
        case "TSMappedType":
          (Ni = r.optional) != null || (r.optional = !1), (pn = r.readonly) != null || (r.readonly = void 0);
          return;
        case "TSModuleDeclaration":
          (co = r.declare) != null || (r.declare = !1), (Os = r.global) != null || (r.global = r.kind === "global");
          return;
        case "TSTypeParameter":
          (ks = r.const) != null || (r.const = !1), (Bs = r.in) != null || (r.in = !1), (fo = r.out) != null || (r.out = !1);
          return;
      }
    }
    chStartsBindingIdentifierAndNotRelationalOperator(r, i) {
      if (en(r)) {
        if (hT.lastIndex = i, hT.test(this.input)) {
          let s = this.codePointAtPos(hT.lastIndex);
          if (!Wo(s) && s !== 92)
            return !1;
        }
        return !0;
      } else return r === 92;
    }
    nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {
      let r = this.nextTokenInLineStart(), i = this.codePointAtPos(r);
      return this.chStartsBindingIdentifierAndNotRelationalOperator(i, r);
    }
    nextTokenIsIdentifierOrStringLiteralOnSameLine() {
      let r = this.nextTokenInLineStart(), i = this.codePointAtPos(r);
      return this.chStartsBindingIdentifier(i, r) || i === 34 || i === 39;
    }
  }, "typescript");
  function HPe(e) {
    if (e.type !== "MemberExpression") return !1;
    let {
      computed: t,
      property: r
    } = e;
    return t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : bL(e.object);
  }
  n(HPe, "isPossiblyLiteralEnum");
  function KPe(e, t) {
    var r;
    let {
      type: i
    } = e;
    if ((r = e.extra) != null && r.parenthesized)
      return !1;
    if (t) {
      if (i === "Literal") {
        let {
          value: s
        } = e;
        if (typeof s == "string" || typeof s == "boolean")
          return !0;
      }
    } else if (i === "StringLiteral" || i === "BooleanLiteral")
      return !0;
    return !!(gL(e, t) || zPe(e, t) || i === "TemplateLiteral" && e.expressions.length === 0 || HPe(e));
  }
  n(KPe, "isValidAmbientConstInitializer");
  function gL(e, t) {
    return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLite\
ral";
  }
  n(gL, "isNumber");
  function zPe(e, t) {
    if (e.type === "UnaryExpression") {
      let {
        operator: r,
        argument: i
      } = e;
      if (r === "-" && gL(i, t))
        return !0;
    }
    return !1;
  }
  n(zPe, "isNegativeNumber");
  function bL(e) {
    return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : bL(e.object);
  }
  n(bL, "isUncomputedMemberExpressionChain");
  var rL = Qs`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), JPe = /* @__PURE__ */ n((e) => class extends e {
    static {
      n(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(133)) {
        let i = this.startNode();
        return this.next(), this.assertNoSpace(), i.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(
        i, r);
      }
    }
    finishPlaceholder(r, i) {
      let s = r;
      return (!s.expectedNode || !s.type) && (s = this.finishNode(s, "Placeholder")), s.expectedNode = i, s;
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, i, s, a) {
      r !== void 0 && super.checkReservedWord(r, i, s, a);
    }
    cloneIdentifier(r) {
      let i = super.cloneIdentifier(r);
      return i.type === "Placeholder" && (i.expectedNode = r.expectedNode), i;
    }
    cloneStringLiteral(r) {
      return r.type === "Placeholder" ? this.cloneIdentifier(r) : super.cloneStringLiteral(r);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, i, s, a) {
      return r === "Placeholder" || super.isValidLVal(r, i, s, a);
    }
    toAssignable(r, i) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, i);
    }
    chStartsBindingIdentifier(r, i) {
      if (super.chStartsBindingIdentifier(r, i))
        return !0;
      let s = this.nextTokenStart();
      return this.input.charCodeAt(s) === 37 && this.input.charCodeAt(s + 1) === 37;
    }
    verifyBreakContinue(r, i) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, i);
    }
    parseExpressionStatement(r, i) {
      var s;
      if (i.type !== "Placeholder" || (s = i.extra) != null && s.parenthesized)
        return super.parseExpressionStatement(r, i);
      if (this.match(14)) {
        let o = r;
        return o.label = this.finishPlaceholder(i, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = r;
      return a.name = i.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(r, i, s) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, i, s);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, i, s) {
      let a = i ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, u = this.parsePlaceholder("Identifier");
      if (u)
        if (this.match(81) || this.match(133) || this.match(5))
          r.id = u;
        else {
          if (s || !i)
            return r.id = null, r.body = this.finishPlaceholder(u, "ClassBody"), this.finishNode(r, a);
          throw this.raise(rL.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, i, s);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, i) {
      let s = this.parsePlaceholder("Identifier");
      if (!s) return super.parseExport(r, i);
      let a = r;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(s, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = s, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, i);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(Ma(133), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, i) {
      var s;
      return (s = r.specifiers) != null && s.length ? !0 : super.maybeParseExportDefaultSpecifier(r, i);
    }
    checkExport(r) {
      let {
        specifiers: i
      } = r;
      i != null && i.length && (r.specifiers = i.filter((s) => s.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = i;
    }
    parseImport(r) {
      let i = this.parsePlaceholder("Identifier");
      if (!i) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(i, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let s = this.startNodeAtNode(i);
      return s.local = i, r.specifiers.push(this.finishNode(s, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(rL.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), XPe = /* @__PURE__ */ n((e) => class extends e {
    static {
      n(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, i = this.startNode();
        if (this.next(), pt(this.state.type)) {
          let s = this.parseIdentifierName(), a = this.createIdentifier(i, s);
          if (this.castNodeTo(a, "V8IntrinsicIdentifier"), this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic"), iL = ["minimal", "fsharp", "hack", "smart"], sL = ["^^", "@@", "^", "%", "#"];
  function YPe(e) {
    if (e.has("decorators")) {
      if (e.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let i = e.get("decorators").decoratorsBeforeExport;
      if (i != null && typeof i != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let s = e.get("decorators").allowCallParenthesized;
      if (s != null && typeof s != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (e.has("flow") && e.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (e.has("placeholders") && e.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (e.has("pipelineOperator")) {
      var t;
      let i = e.get("pipelineOperator").proposal;
      if (!iL.includes(i)) {
        let s = iL.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${s}.`);
      }
      if (i === "hack") {
        if (e.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (e.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let s = e.get("pipelineOperator").topicToken;
        if (!sL.includes(s)) {
          let a = sL.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        {
          var r;
          if (s === "#" && ((r = e.get("recordAndTuple")) == null ? void 0 : r.syntaxType) === "hash")
            throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(
            ["recordAndTuple", e.get("recordAndTuple")])}\`.`);
        }
      } else if (i === "smart" && ((t = e.get("recordAndTuple")) == null ? void 0 : t.syntaxType) === "hash")
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", e.
        get("recordAndTuple")])}\`.`);
    }
    if (e.has("moduleAttributes")) {
      if (e.has("deprecatedImportAssert") || e.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (e.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (e.has("importAssertions") && e.has("deprecatedImportAssert"))
      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!e.has("deprecatedImportAssert") && e.has("importAttributes") && e.get("importAttributes").deprecatedAssertSyntax && e.set("deprecat\
edImportAssert", {}), e.has("recordAndTuple")) {
      let i = e.get("recordAndTuple").syntaxType;
      if (i != null) {
        let s = ["hash", "bar"];
        if (!s.includes(i))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + s.map((a) => `'${a}'`).join(", "));
      }
    }
    if (e.has("asyncDoExpressions") && !e.has("doExpressions")) {
      let i = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw i.missingPlugins = "doExpressions", i;
    }
    if (e.has("optionalChainingAssign") && e.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
    if (e.has("discardBinding") && e.get("discardBinding").syntaxType !== "void")
      throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
  }
  n(YPe, "validatePlugins");
  var DL = {
    estree: ePe,
    jsx: OPe,
    flow: _Pe,
    typescript: WPe,
    v8intrinsic: XPe,
    placeholders: JPe
  }, GPe = Object.keys(DL), MT = class extends NT {
    static {
      n(this, "ExpressionParser");
    }
    checkProto(t, r, i, s) {
      if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
        return i;
      let a = t.key;
      return (a.type === "Identifier" ? a.name : a.value) === "__proto__" ? r ? (this.raise(R.RecordNoProto, a), !0) : (i && (s ? s.doubleProtoLoc ===
      null && (s.doubleProtoLoc = a.loc.start) : this.raise(R.DuplicateProto, a)), !0) : i;
    }
    shouldExitDescending(t, r) {
      return t.type === "ArrowFunctionExpression" && this.offsetToSourcePos(t.start) === r;
    }
    getExpression() {
      if (this.enterInitialScopes(), this.nextToken(), this.match(140))
        throw this.raise(R.ParseExpressionEmptyInput, this.state.startLoc);
      let t = this.parseExpression();
      if (!this.match(140))
        throw this.raise(R.ParseExpressionExpectsEOF, this.state.startLoc, {
          unexpected: this.input.codePointAt(this.state.start)
        });
      return this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors, this.optionFlags & 256 && (t.tokens =
      this.tokens), t;
    }
    parseExpression(t, r) {
      return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(t) {
      let r = this.state.startLoc, i = this.parseMaybeAssign(t);
      if (this.match(12)) {
        let s = this.startNodeAt(r);
        for (s.expressions = [i]; this.eat(12); )
          s.expressions.push(this.parseMaybeAssign(t));
        return this.toReferencedList(s.expressions), this.finishNode(s, "SequenceExpression");
      }
      return i;
    }
    parseMaybeAssignDisallowIn(t, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
    }
    parseMaybeAssignAllowIn(t, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(t, r));
    }
    setOptionalParametersError(t) {
      t.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(t, r) {
      let i = this.state.startLoc, s = this.isContextual(108);
      if (s && this.prodParam.hasYield) {
        this.next();
        let l = this.parseYield(i);
        return r && (l = r.call(this, l, i)), l;
      }
      let a;
      t ? a = !1 : (t = new $l(), a = !0);
      let {
        type: o
      } = this.state;
      (o === 10 || pt(o)) && (this.state.potentialArrowAt = this.state.start);
      let u = this.parseMaybeConditional(t);
      if (r && (u = r.call(this, u, i)), nPe(this.state.type)) {
        let l = this.startNodeAt(i), c = this.state.value;
        if (l.operator = c, this.match(29)) {
          this.toAssignable(u, !0), l.left = u;
          let f = i.index;
          t.doubleProtoLoc != null && t.doubleProtoLoc.index >= f && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.
          index >= f && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= f && (this.checkDestructuringPrivate(
          t), t.privateKeyLoc = null), t.voidPatternLoc != null && t.voidPatternLoc.index >= f && (t.voidPatternLoc = null);
        } else
          l.left = u;
        return this.next(), l.right = this.parseMaybeAssign(), this.checkLVal(u, this.finishNode(l, "AssignmentExpression"), void 0, void 0,
        void 0, void 0, c === "||=" || c === "&&=" || c === "??="), l;
      } else a && this.checkExpressionErrors(t, !0);
      if (s) {
        let {
          type: l
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Md(l) : Md(l) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(R.YieldNotInGeneratorFunction, i), this.parseYield(i);
      }
      return u;
    }
    parseMaybeConditional(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseExprOps(t);
      return this.shouldExitDescending(s, i) ? s : this.parseConditional(s, r, t);
    }
    parseConditional(t, r, i) {
      if (this.eat(17)) {
        let s = this.startNodeAt(r);
        return s.test = t, s.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), s.alternate = this.parseMaybeAssign(), this.finishNode(
        s, "ConditionalExpression");
      }
      return t;
    }
    parseMaybeUnaryOrPrivate(t) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(t);
    }
    parseExprOps(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseMaybeUnaryOrPrivate(t);
      return this.shouldExitDescending(s, i) ? s : this.parseExprOp(s, r, -1);
    }
    parseExprOp(t, r, i) {
      if (this.isPrivateName(t)) {
        let a = this.getPrivateNameSV(t);
        (i >= Ym(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(R.PrivateInExpectedIn, t, {
          identifierName: a
        }), this.classScope.usePrivateName(a, t.loc.start);
      }
      let s = this.state.type;
      if (oPe(s) && (this.prodParam.hasIn || !this.match(58))) {
        let a = Ym(s);
        if (a > i) {
          if (s === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return t;
            this.checkPipelineAtInfixOperator(t, r);
          }
          let o = this.startNodeAt(r);
          o.left = t, o.operator = this.state.value;
          let u = s === 41 || s === 42, l = s === 40;
          if (l && (a = Ym(42)), this.next(), s === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(R.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(s, a);
          let c = this.finishNode(o, u || l ? "LogicalExpression" : "BinaryExpression"), f = this.state.type;
          if (l && (f === 41 || f === 42) || u && f === 40)
            throw this.raise(R.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, i);
        }
      }
      return t;
    }
    parseExprOpRightExpr(t, r) {
      let i = this.state.startLoc;
      switch (t) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart")
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(R.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), i);
            });
        default:
          return this.parseExprOpBaseRightExpr(t, r);
      }
    }
    parseExprOpBaseRightExpr(t, r) {
      let i = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), i, dPe(t) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var t;
      let {
        startLoc: r
      } = this.state, i = this.parseMaybeAssign();
      return z3e.has(i.type) && !((t = i.extra) != null && t.parenthesized) && this.raise(R.PipeUnparenthesizedBody, r, {
        type: i.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(R.PipeTopicUnused, r), i;
    }
    checkExponentialAfterUnary(t) {
      this.match(57) && this.raise(R.UnexpectedTokenUnaryExponentiation, t.argument);
    }
    parseMaybeUnary(t, r) {
      let i = this.state.startLoc, s = this.isContextual(96);
      if (s && this.recordAwaitIfAllowed()) {
        this.next();
        let l = this.parseAwait(i);
        return r || this.checkExponentialAfterUnary(l), l;
      }
      let a = this.match(34), o = this.startNode();
      if (lPe(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let l = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && l) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(R.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(R.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let u = this.parseUpdate(o, a, t);
      if (s) {
        let {
          type: l
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Md(l) : Md(l) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(R.AwaitNotInAsyncContext, i), this.parseAwait(i);
      }
      return u;
    }
    parseUpdate(t, r, i) {
      if (r) {
        let o = t;
        return this.checkLVal(o.argument, this.finishNode(o, "UpdateExpression")), t;
      }
      let s = this.state.startLoc, a = this.parseExprSubscripts(i);
      if (this.checkExpressionErrors(i, !1)) return a;
      for (; uPe(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(s);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, a = this.finishNode(o, "UpdateExpressio\
n"));
      }
      return a;
    }
    parseExprSubscripts(t) {
      let r = this.state.startLoc, i = this.state.potentialArrowAt, s = this.parseExprAtom(t);
      return this.shouldExitDescending(s, i) ? s : this.parseSubscripts(s, r);
    }
    parseSubscripts(t, r, i) {
      let s = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(t),
        stop: !1
      };
      do
        t = this.parseSubscript(t, r, i, s), s.maybeAsyncArrow = !1;
      while (!s.stop);
      return t;
    }
    parseSubscript(t, r, i, s) {
      let {
        type: a
      } = this.state;
      if (!i && a === 15)
        return this.parseBind(t, r, i, s);
      if (Qm(a))
        return this.parseTaggedTemplateExpression(t, r, s);
      let o = !1;
      if (a === 18) {
        if (i && (this.raise(R.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return this.stopParseSubscript(t, s);
        s.optionalChainMember = o = !0, this.next();
      }
      if (!i && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(t, r, s, o);
      {
        let u = this.eat(0);
        return u || o || this.eat(16) ? this.parseMember(t, r, s, u, o) : this.stopParseSubscript(t, s);
      }
    }
    stopParseSubscript(t, r) {
      return r.stop = !0, t;
    }
    parseMember(t, r, i, s, a) {
      let o = this.startNodeAt(r);
      return o.object = t, o.computed = s, s ? (o.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (t.type === "Super" &&
      this.raise(R.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), i.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(t, r, i, s) {
      let a = this.startNodeAt(r);
      return a.object = t, this.next(), a.callee = this.parseNoCallExpr(), s.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, i);
    }
    parseCoverCallAndAsyncArrowHead(t, r, i, s) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let u = this.startNodeAt(r);
      u.callee = t;
      let {
        maybeAsyncArrow: l,
        optionalChainMember: c
      } = i;
      l && (this.expressionScope.enter(qPe()), o = new $l()), c && (u.optional = s), s ? u.arguments = this.parseCallExpressionArguments() :
      u.arguments = this.parseCallExpressionArguments(t.type !== "Super", u, o);
      let f = this.finishCallExpression(u, c);
      return l && this.shouldParseAsyncArrow() && !s ? (i.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), f = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), f)) : (l && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(f)), this.state.maybeInArrowParameters = a, f;
    }
    toReferencedArguments(t, r) {
      this.toReferencedListDeep(t.arguments, r);
    }
    parseTaggedTemplateExpression(t, r, i) {
      let s = this.startNodeAt(r);
      return s.tag = t, s.quasi = this.parseTemplate(!0), i.optionalChainMember && this.raise(R.OptionalChainingNoTemplate, r), this.finishNode(
      s, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(t) {
      return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end -
      t.start === 5 && this.offsetToSourcePos(t.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(t, r) {
      if (t.callee.type === "Import")
        if (t.arguments.length === 0 || t.arguments.length > 2)
          this.raise(R.ImportCallArity, t);
        else
          for (let i of t.arguments)
            i.type === "SpreadElement" && this.raise(R.ImportCallSpreadArgument, i);
      return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(t, r, i) {
      let s = [], a = !0, o = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(11); ) {
        if (a)
          a = !1;
        else if (this.expect(12), this.match(11)) {
          r && this.addTrailingCommaExtraToNode(r), this.next();
          break;
        }
        s.push(this.parseExprListItem(11, !1, i, t));
      }
      return this.state.inFSharpPipelineDirectBody = o, s;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(t, r) {
      var i;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, !0, (i = r.extra) == null ?
      void 0 : i.trailingCommaLoc), r.innerComments && Ud(t, r.innerComments), r.callee.trailingComments && Ud(t, r.callee.trailingComments),
      t;
    }
    parseNoCallExpr() {
      let t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), t, !0);
    }
    parseExprAtom(t) {
      let r, i = null, {
        type: s
      } = this.state;
      switch (s) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaPropertyOrPhaseCall(r) : this.match(10) ? this.optionFlags &
          512 ? this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(R.UnsupportedImport, this.state.lastTokStartLoc), this.
          finishNode(r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 0:
          return this.parseArrayLike(3, !1, t);
        case 5:
          return this.parseObjectLike(8, !1, !1, t);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          i = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(i, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(R.UnsupportedBind, a);
        }
        case 139:
          return this.raise(R.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          throw this.unexpected();
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          throw en(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
        }
        default:
          {
            if (s === 137)
              return this.parseDecimalLiteral(this.state.value);
            if (s === 2 || s === 1)
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !0);
            if (s === 6 || s === 7)
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
          }
          if (pt(s)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, u = this.parseIdentifier();
            if (!o && u.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: l
              } = this.state;
              if (l === 68)
                return this.resetPreviousNodeTrailingComments(u), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(u));
              if (pt(l))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(u)) : u;
              if (l === 90)
                return this.resetPreviousNodeTrailingComments(u), this.parseDo(this.startNodeAtNode(u), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(u), [u],
            !1)) : u;
          } else
            throw this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(t, r) {
      let i = this.getPluginOption("pipelineOperator", "proposal");
      if (i)
        return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = si(this.state.endLoc, -1),
        this.parseTopicReference(i);
      throw this.unexpected();
    }
    parseTopicReference(t) {
      let r = this.startNode(), i = this.state.startLoc, s = this.state.type;
      return this.next(), this.finishTopicReference(r, i, t, s);
    }
    finishTopicReference(t, r, i, s) {
      if (this.testTopicReferenceConfiguration(i, r, s))
        return i === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(R.PipeTopicUnbound, r), this.registerTopicReference(),
        this.finishNode(t, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(R.PrimaryTopicNotAllowed, r), this.
        registerTopicReference(), this.finishNode(t, "PipelinePrimaryTopicReference"));
      throw this.raise(R.PipeTopicUnconfiguredToken, r, {
        token: Ma(s)
      });
    }
    testTopicReferenceConfiguration(t, r, i) {
      switch (t) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: Ma(i)
          }]);
        case "smart":
          return i === 27;
        default:
          throw this.raise(R.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(t) {
      this.prodParam.enter(Gm(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(R.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(t, r, !0);
    }
    parseDo(t, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
      let i = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(),
      this.state.labels = i, this.finishNode(t, "DoExpression");
    }
    parseSuper() {
      let t = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper ? this.optionFlags & 16 || this.raise(R.SuperNotAllowed, t) : this.
      scope.allowSuper || this.optionFlags & 16 || this.raise(R.UnexpectedSuper, t), !this.match(10) && !this.match(0) && !this.match(16) &&
      this.raise(R.UnsupportedSuper, t), this.finishNode(t, "Super");
    }
    parsePrivateName() {
      let t = this.startNode(), r = this.startNodeAt(si(this.state.startLoc, 1)), i = this.state.value;
      return this.next(), t.id = this.createIdentifier(r, i), this.finishNode(t, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let t = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(t, r, "sent");
      }
      return this.parseFunction(t);
    }
    parseMetaProperty(t, r, i) {
      t.meta = r;
      let s = this.state.containsEsc;
      return t.property = this.parseIdentifier(!0), (t.property.name !== i || s) && this.raise(R.UnsupportedMetaProperty, t.property, {
        target: r.name,
        onlyValidPropertyName: i
      }), this.finishNode(t, "MetaProperty");
    }
    parseImportMetaPropertyOrPhaseCall(t) {
      if (this.next(), this.isContextual(105) || this.isContextual(97)) {
        let r = this.isContextual(105);
        return this.expectPlugin(r ? "sourcePhaseImports" : "deferredImportEvaluation"), this.next(), t.phase = r ? "source" : "defer", this.
        parseImportCall(t);
      } else {
        let r = this.createIdentifierAt(this.startNodeAtNode(t), "import", this.state.lastTokStartLoc);
        return this.isContextual(101) && (this.inModule || this.raise(R.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0), this.parseMetaProperty(
        t, r, "meta");
      }
    }
    parseLiteralAtNode(t, r, i) {
      return this.addExtra(i, "rawValue", t), this.addExtra(i, "raw", this.input.slice(this.offsetToSourcePos(i.start), this.state.end)), i.
      value = t, this.next(), this.finishNode(i, r);
    }
    parseLiteral(t, r) {
      let i = this.startNode();
      return this.parseLiteralAtNode(t, r, i);
    }
    parseStringLiteral(t) {
      return this.parseLiteral(t, "StringLiteral");
    }
    parseNumericLiteral(t) {
      return this.parseLiteral(t, "NumericLiteral");
    }
    parseBigIntLiteral(t) {
      return this.parseLiteral(t, "BigIntLiteral");
    }
    parseDecimalLiteral(t) {
      return this.parseLiteral(t, "DecimalLiteral");
    }
    parseRegExpLiteral(t) {
      let r = this.startNode();
      return this.addExtra(r, "raw", this.input.slice(this.offsetToSourcePos(r.start), this.state.end)), r.pattern = t.pattern, r.flags = t.
      flags, this.next(), this.finishNode(r, "RegExpLiteral");
    }
    parseBooleanLiteral(t) {
      let r = this.startNode();
      return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let t = this.startNode();
      return this.next(), this.finishNode(t, "NullLiteral");
    }
    parseParenAndDistinguishExpression(t) {
      let r = this.state.startLoc, i;
      this.next(), this.expressionScope.enter(jPe());
      let s = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, u = [], l = new $l(), c = !0, f, m;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, l.optionalParametersLoc === null ? null : l.optionalParametersLoc), this.match(11)) {
          m = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let y = this.state.startLoc;
          if (f = this.state.startLoc, u.push(this.parseParenItem(this.parseRestBinding(), y)), !this.checkCommaAfterRest(41))
            break;
        } else
          u.push(this.parseMaybeAssignAllowInOrVoidPattern(11, l, this.parseParenItem));
      }
      let h = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = s, this.state.inFSharpPipelineDirectBody = a;
      let d = this.startNodeAt(r);
      return t && this.shouldParseArrow(u) && (d = this.parseArrow(d)) ? (this.checkDestructuringPrivate(l), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(d, u, !1), d) : (this.expressionScope.exit(), u.length || this.unexpected(this.
      state.lastTokStartLoc), m && this.unexpected(m), f && this.unexpected(f), this.checkExpressionErrors(l, !0), this.toReferencedListDeep(
      u, !0), u.length > 1 ? (i = this.startNodeAt(o), i.expressions = u, this.finishNode(i, "SequenceExpression"), this.resetEndLocation(i,
      h)) : i = u[0], this.wrapParenthesis(r, i));
    }
    wrapParenthesis(t, r) {
      if (!(this.optionFlags & 1024))
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.
        state.lastTokEndLoc.index), r;
      let i = this.startNodeAt(t);
      return i.expression = r, this.finishNode(i, "ParenthesizedExpression");
    }
    shouldParseArrow(t) {
      return !this.canInsertSemicolon();
    }
    parseArrow(t) {
      if (this.eat(19))
        return t;
    }
    parseParenItem(t, r) {
      return t;
    }
    parseNewOrNewTarget() {
      let t = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "new");
        this.next();
        let i = this.parseMetaProperty(t, r, "target");
        return this.scope.allowNewTarget || this.raise(R.UnexpectedNewTarget, i), i;
      }
      return this.parseNew(t);
    }
    parseNew(t) {
      if (this.parseNewCallee(t), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), t.arguments = r;
      } else
        t.arguments = [];
      return this.finishNode(t, "NewExpression");
    }
    parseNewCallee(t) {
      let r = this.match(83), i = this.parseNoCallExpr();
      t.callee = i, r && (i.type === "Import" || i.type === "ImportExpression") && this.raise(R.ImportCallNotNewExpression, i);
    }
    parseTemplateElement(t) {
      let {
        start: r,
        startLoc: i,
        end: s,
        value: a
      } = this.state, o = r + 1, u = this.startNodeAt(si(i, 1));
      a === null && (t || this.raise(R.InvalidEscapeSequenceTemplate, si(this.state.firstInvalidTemplateEscapePos, 1)));
      let l = this.match(24), c = l ? -1 : -2, f = s + c;
      u.value = {
        raw: this.input.slice(o, f).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, u.tail = l, this.next();
      let m = this.finishNode(u, "TemplateElement");
      return this.resetEndLocation(m, si(this.state.lastTokEndLoc, c)), m;
    }
    parseTemplate(t) {
      let r = this.startNode(), i = this.parseTemplateElement(t), s = [i], a = [];
      for (; !i.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), s.push(i = this.parseTemplateElement(t));
      return r.expressions = a, r.quasis = s, this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(t, r, i, s) {
      i && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = !1, u = !0, l = this.startNode();
      for (l.properties = [], this.next(); !this.match(t); ) {
        if (u)
          u = !1;
        else if (this.expect(12), this.match(t)) {
          this.addTrailingCommaExtraToNode(l);
          break;
        }
        let f;
        r ? f = this.parseBindingProperty() : (f = this.parsePropertyDefinition(s), o = this.checkProto(f, i, o, s)), i && !this.isObjectProperty(
        f) && f.type !== "SpreadElement" && this.raise(R.InvalidRecordProperty, f), f.shorthand && this.addExtra(f, "shorthand", !0), l.properties.
        push(f);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : i && (c = "RecordExpression"), this.finishNode(l, c);
    }
    addTrailingCommaExtraToNode(t) {
      this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(t) {
      return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(t) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(R.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let i = this.startNode(), s = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (i.decorators = r, r = []), i.method = !1, t && (o = this.state.startLoc);
      let u = this.eat(55);
      this.parsePropertyNamePrefixOperator(i);
      let l = this.state.containsEsc;
      if (this.parsePropertyName(i, t), !u && !l && this.maybeAsyncOrAccessorProp(i)) {
        let {
          key: c
        } = i, f = c.name;
        f === "async" && !this.hasPrecedingLineBreak() && (s = !0, this.resetPreviousNodeTrailingComments(c), u = this.eat(55), this.parsePropertyName(
        i)), (f === "get" || f === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), i.kind = f, this.match(55) && (u = !0, this.
        raise(R.AccessorIsGenerator, this.state.curPosition(), {
          kind: f
        }), this.next()), this.parsePropertyName(i));
      }
      return this.parseObjPropValue(i, o, u, s, !1, a, t);
    }
    getGetterSetterExpectedParamCount(t) {
      return t.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(t) {
      return t.params;
    }
    checkGetterSetterParams(t) {
      var r;
      let i = this.getGetterSetterExpectedParamCount(t), s = this.getObjectOrClassMethodParams(t);
      s.length !== i && this.raise(t.kind === "get" ? R.BadGetterArity : R.BadSetterArity, t), t.kind === "set" && ((r = s[s.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(R.BadSetterRestParameter, t);
    }
    parseObjectMethod(t, r, i, s, a) {
      if (a) {
        let o = this.parseMethod(t, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (i || r || this.match(10))
        return s && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, r, i, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(t, r, i, s) {
      if (t.shorthand = !1, this.eat(14))
        return t.value = i ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, s), this.finishObjectProperty(
        t);
      if (!t.computed && t.key.type === "Identifier") {
        if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), i)
          t.value = this.parseMaybeDefault(r, this.cloneIdentifier(t.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          s != null ? s.shorthandAssignLoc === null && (s.shorthandAssignLoc = a) : this.raise(R.InvalidCoverInitializedName, a), t.value = this.
          parseMaybeDefault(r, this.cloneIdentifier(t.key));
        } else
          t.value = this.cloneIdentifier(t.key);
        return t.shorthand = !0, this.finishObjectProperty(t);
      }
    }
    finishObjectProperty(t) {
      return this.finishNode(t, "ObjectProperty");
    }
    parseObjPropValue(t, r, i, s, a, o, u) {
      let l = this.parseObjectMethod(t, i, s, a, o) || this.parseObjectProperty(t, r, a, u);
      return l || this.unexpected(), l;
    }
    parsePropertyName(t, r) {
      if (this.eat(0))
        t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: i,
          value: s
        } = this.state, a;
        if (hs(i))
          a = this.parseIdentifier(!0);
        else
          switch (i) {
            case 135:
              a = this.parseNumericLiteral(s);
              break;
            case 134:
              a = this.parseStringLiteral(s);
              break;
            case 136:
              a = this.parseBigIntLiteral(s);
              break;
            case 139: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(R.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              if (i === 137) {
                a = this.parseDecimalLiteral(s);
                break;
              }
              this.unexpected();
          }
        t.key = a, i !== 139 && (t.computed = !1);
      }
    }
    initFunction(t, r) {
      t.id = null, t.generator = !1, t.async = r;
    }
    parseMethod(t, r, i, s, a, o, u = !1) {
      this.initFunction(t, i), t.generator = r, this.scope.enter(530 | (u ? 576 : 0) | (a ? 32 : 0)), this.prodParam.enter(Gm(i, t.generator)),
      this.parseFunctionParams(t, s);
      let l = this.parseFunctionBodyAndFinish(t, o, !0);
      return this.prodParam.exit(), this.scope.exit(), l;
    }
    parseArrayLike(t, r, i) {
      r && this.expectPlugin("recordAndTuple");
      let s = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let a = this.startNode();
      return this.next(), a.elements = this.parseExprList(t, !r, i, a), this.state.inFSharpPipelineDirectBody = s, this.finishNode(a, r ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(t, r, i, s) {
      this.scope.enter(518);
      let a = Gm(i, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(t, i);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, r, s)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(t, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(t, r, i) {
      this.toAssignableList(r, i, !1), t.params = r;
    }
    parseFunctionBodyAndFinish(t, r, i = !1) {
      return this.parseFunctionBody(t, !1, i), this.finishNode(t, r);
    }
    parseFunctionBody(t, r, i = !1) {
      let s = r && !this.match(5);
      if (this.expressionScope.enter(yL()), s)
        t.body = this.parseMaybeAssign(), this.checkParams(t, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (u) => {
          let l = !this.isSimpleParamList(t.params);
          u && l && this.raise(R.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
          let c = !a && this.state.strict;
          this.checkParams(t, !this.state.strict && !r && !i && !l, r, c), this.state.strict && t.id && this.checkIdentifier(t.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(t) {
      return t.type === "Identifier";
    }
    isSimpleParamList(t) {
      for (let r = 0, i = t.length; r < i; r++)
        if (!this.isSimpleParameter(t[r])) return !1;
      return !0;
    }
    checkParams(t, r, i, s = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let u of t.params)
        this.checkLVal(u, o, 5, a, s);
    }
    parseExprList(t, r, i, s) {
      let a = [], o = !0;
      for (; !this.eat(t); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(t)) {
          s && this.addTrailingCommaExtraToNode(s), this.next();
          break;
        }
        a.push(this.parseExprListItem(t, r, i));
      }
      return a;
    }
    parseExprListItem(t, r, i, s) {
      let a;
      if (this.match(12))
        r || this.raise(R.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), a = null;
      else if (this.match(21)) {
        let o = this.state.startLoc;
        a = this.parseParenItem(this.parseSpread(i), o);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), s || this.raise(R.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let o = this.startNode();
        this.next(), a = this.finishNode(o, "ArgumentPlaceholder");
      } else
        a = this.parseMaybeAssignAllowInOrVoidPattern(t, i, this.parseParenItem);
      return a;
    }
    parseIdentifier(t) {
      let r = this.startNode(), i = this.parseIdentifierName(t);
      return this.createIdentifier(r, i);
    }
    createIdentifier(t, r) {
      return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
    }
    createIdentifierAt(t, r, i) {
      return t.name = r, t.loc.identifierName = r, this.finishNodeAt(t, "Identifier", i);
    }
    parseIdentifierName(t) {
      let r, {
        startLoc: i,
        type: s
      } = this.state;
      hs(s) ? r = this.state.value : this.unexpected();
      let a = iPe(s);
      return t ? a && this.replaceToken(132) : this.checkReservedWord(r, i, a, !1), this.next(), r;
    }
    checkReservedWord(t, r, i, s) {
      if (t.length > 10 || !EPe(t))
        return;
      if (i && DPe(t)) {
        this.raise(R.UnexpectedKeyword, r, {
          keyword: t
        });
        return;
      }
      if ((this.state.strict ? s ? dL : cL : lL)(t, this.inModule)) {
        this.raise(R.UnexpectedReservedWord, r, {
          reservedWord: t
        });
        return;
      } else if (t === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(R.YieldBindingIdentifier, r);
          return;
        }
      } else if (t === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(R.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(R.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(R.ArgumentsInClass, r);
        return;
      }
    }
    recordAwaitIfAllowed() {
      let t = this.prodParam.hasAwait;
      return t && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), t;
    }
    parseAwait(t) {
      let r = this.startNodeAt(t);
      return this.expressionScope.recordParameterInitializerError(R.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(R.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 :
      this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExpressi\
on");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: t
      } = this.state;
      return t === 53 || t === 10 || t === 0 || Qm(t) || t === 102 && !this.state.containsEsc || t === 138 || t === 56 || this.hasPlugin("v8\
intrinsic") && t === 54;
    }
    parseYield(t) {
      let r = this.startNodeAt(t);
      this.expressionScope.recordParameterInitializerError(R.YieldInParameter, r);
      let i = !1, s = null;
      if (!this.hasPrecedingLineBreak())
        switch (i = this.eat(55), this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!i) break;
          default:
            s = this.parseMaybeAssign();
        }
      return r.delegate = i, r.argument = s, this.finishNode(r, "YieldExpression");
    }
    parseImportCall(t) {
      if (this.next(), t.source = this.parseMaybeAssignAllowIn(), t.options = null, this.eat(12)) {
        if (this.match(11))
          this.addTrailingCommaExtraToNode(t.source);
        else if (t.options = this.parseMaybeAssignAllowIn(), this.eat(12) && (this.addTrailingCommaExtraToNode(t.options), !this.match(11))) {
          do
            this.parseMaybeAssignAllowIn();
          while (this.eat(12) && !this.match(11));
          this.raise(R.ImportCallArity, t);
        }
      }
      return this.expect(11), this.finishNode(t, "ImportExpression");
    }
    checkPipelineAtInfixOperator(t, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && t.type === "SequenceExpression" && this.raise(R.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(t, r) {
      if (this.isSimpleReference(t)) {
        let i = this.startNodeAt(r);
        return i.callee = t, this.finishNode(i, "PipelineBareFunction");
      } else {
        let i = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), i.expression = t, this.finishNode(i, "PipelineTopicExpression");
      }
    }
    isSimpleReference(t) {
      switch (t.type) {
        case "MemberExpression":
          return !t.computed && this.isSimpleReference(t.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(t) {
      if (this.match(19))
        throw this.raise(R.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(R.PipelineTopicUnused, t);
    }
    withTopicBindingContext(t) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return t();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(t) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return t();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return t();
    }
    withSoloAwaitPermittingContext(t) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return t();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    disallowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(t) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let i = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let s = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
      return this.state.inFSharpPipelineDirectBody = i, s;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let t = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let i = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        t.body = this.parseProgram(r, 8, "module");
      } finally {
        i();
      }
      return this.finishNode(t, "ModuleExpression");
    }
    parseVoidPattern(t) {
      this.expectPlugin("discardBinding");
      let r = this.startNode();
      return t != null && (t.voidPatternLoc = this.state.startLoc), this.next(), this.finishNode(r, "VoidPattern");
    }
    parseMaybeAssignAllowInOrVoidPattern(t, r, i) {
      if (r != null && this.match(88)) {
        let s = this.lookaheadCharCode();
        if (s === 44 || s === (t === 3 ? 93 : t === 8 ? 125 : 41) || s === 61)
          return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(r));
      }
      return this.parseMaybeAssignAllowIn(r, i);
    }
    parsePropertyNamePrefixOperator(t) {
    }
  }, mT = {
    kind: 1
  }, ZPe = {
    kind: 2
  }, QPe = /[\uD800-\uDFFF]/u, yT = /in(?:stanceof)?/y;
  function e4e(e, t, r) {
    for (let i = 0; i < e.length; i++) {
      let s = e[i], {
        type: a
      } = s;
      if (typeof a == "number") {
        {
          if (a === 139) {
            let {
              loc: o,
              start: u,
              value: l,
              end: c
            } = s, f = u + 1, m = si(o.start, 1);
            e.splice(i, 1, new Zs({
              type: Mn(27),
              value: "#",
              start: u,
              end: f,
              startLoc: o.start,
              endLoc: m
            }), new Zs({
              type: Mn(132),
              value: l,
              start: f,
              end: c,
              startLoc: m,
              endLoc: o.end
            })), i++;
            continue;
          }
          if (Qm(a)) {
            let {
              loc: o,
              start: u,
              value: l,
              end: c
            } = s, f = u + 1, m = si(o.start, 1), h;
            t.charCodeAt(u - r) === 96 ? h = new Zs({
              type: Mn(22),
              value: "`",
              start: u,
              end: f,
              startLoc: o.start,
              endLoc: m
            }) : h = new Zs({
              type: Mn(8),
              value: "}",
              start: u,
              end: f,
              startLoc: o.start,
              endLoc: m
            });
            let d, y, p, g;
            a === 24 ? (y = c - 1, p = si(o.end, -1), d = l === null ? null : l.slice(1, -1), g = new Zs({
              type: Mn(22),
              value: "`",
              start: y,
              end: c,
              startLoc: p,
              endLoc: o.end
            })) : (y = c - 2, p = si(o.end, -2), d = l === null ? null : l.slice(1, -2), g = new Zs({
              type: Mn(23),
              value: "${",
              start: y,
              end: c,
              startLoc: p,
              endLoc: o.end
            })), e.splice(i, 1, h, new Zs({
              type: Mn(20),
              value: d,
              start: f,
              end: y,
              startLoc: m,
              endLoc: p
            }), g), i += 2;
            continue;
          }
        }
        s.type = Mn(a);
      }
    }
    return e;
  }
  n(e4e, "babel7CompatTokens");
  var RT = class extends MT {
    static {
      n(this, "StatementParser");
    }
    parseTopLevel(t, r) {
      return t.program = this.parseProgram(r, 140, this.options.sourceType === "module" ? "module" : "script"), t.comments = this.comments, this.
      optionFlags & 256 && (t.tokens = e4e(this.tokens, this.input, this.startIndex)), this.finishNode(t, "File");
    }
    parseProgram(t, r, i) {
      if (t.sourceType = i, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, r), this.inModule) {
        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0)
          for (let [a, o] of Array.from(this.scope.undefinedExports))
            this.raise(R.ModuleExportUndefined, o, {
              localName: a
            });
        this.addExtra(t, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let s;
      return r === 140 ? s = this.finishNode(t, "Program") : s = this.finishNodeAt(t, "Program", si(this.state.startLoc, -1)), s;
    }
    stmtToDirective(t) {
      let r = this.castNodeTo(t, "Directive"), i = this.castNodeTo(t.expression, "DirectiveLiteral"), s = i.value, a = this.input.slice(this.
      offsetToSourcePos(i.start), this.offsetToSourcePos(i.end)), o = i.value = a.slice(1, -1);
      return this.addExtra(i, "raw", a), this.addExtra(i, "rawValue", o), this.addExtra(i, "expressionValue", s), r.value = i, delete t.expression,
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let t = this.startNode();
      return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    isUsing() {
      return this.isContextual(107) ? this.nextTokenIsIdentifierOnSameLine() : !1;
    }
    isForUsing() {
      if (!this.isContextual(107))
        return !1;
      let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
      if (this.isUnparsedContextual(t, "of")) {
        let i = this.lookaheadCharCodeSince(t + 2);
        if (i !== 61 && i !== 58 && i !== 59)
          return !1;
      }
      return !!(this.chStartsBindingIdentifier(r, t) || this.isUnparsedContextual(t, "void"));
    }
    nextTokenIsIdentifierOnSameLine() {
      let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingIdentifier(r, t);
    }
    isAwaitUsing() {
      if (!this.isContextual(96))
        return !1;
      let t = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(t, "using")) {
        t = this.nextTokenInLineStartSince(t + 5);
        let r = this.codePointAtPos(t);
        if (this.chStartsBindingIdentifier(r, t))
          return !0;
      }
      return !1;
    }
    chStartsBindingIdentifier(t, r) {
      if (en(t)) {
        if (yT.lastIndex = r, yT.test(this.input)) {
          let i = this.codePointAtPos(yT.lastIndex);
          if (!Wo(i) && i !== 92)
            return !1;
        }
        return !0;
      } else return t === 92;
    }
    chStartsBindingPattern(t) {
      return t === 91 || t === 123;
    }
    hasFollowingBindingAtom() {
      let t = this.nextTokenStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
      return r === 123 || this.chStartsBindingIdentifier(r, t);
    }
    allowsUsing() {
      return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(t) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(t, r);
    }
    parseStatementContent(t, r) {
      let i = this.state.type, s = this.startNode(), a = !!(t & 2), o = !!(t & 4), u = t & 1;
      switch (i) {
        case 60:
          return this.parseBreakContinueStatement(s, !0);
        case 63:
          return this.parseBreakContinueStatement(s, !1);
        case 64:
          return this.parseDebuggerStatement(s);
        case 90:
          return this.parseDoWhileStatement(s);
        case 91:
          return this.parseForStatement(s);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? R.StrictFunction : this.options.annexB ? R.SloppyFunctionAnnexB : R.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(s, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, s), !0);
        case 69:
          return this.parseIfStatement(s);
        case 70:
          return this.parseReturnStatement(s);
        case 71:
          return this.parseSwitchStatement(s);
        case 72:
          return this.parseThrowStatement(s);
        case 73:
          return this.parseTryStatement(s);
        case 96:
          if (this.isAwaitUsing())
            return this.allowsUsing() ? a ? this.recordAwaitIfAllowed() || this.raise(R.AwaitUsingNotInAsyncContext, s) : this.raise(R.UnexpectedLexicalDeclaration,
            s) : this.raise(R.UnexpectedUsingDeclaration, s), this.next(), this.parseVarStatement(s, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.allowsUsing() ? a || this.raise(R.UnexpectedLexicalDeclaration, this.state.startLoc) : this.raise(R.UnexpectedUsingDeclaration,
          this.state.startLoc), this.parseVarStatement(s, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let f = this.nextTokenStart(), m = this.codePointAtPos(f);
          if (m !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(m, f) && m !== 123))
            break;
        }
        case 75:
          a || this.raise(R.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let f = this.state.value;
          return this.parseVarStatement(s, f);
        }
        case 92:
          return this.parseWhileStatement(s);
        case 76:
          return this.parseWithStatement(s);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(s);
        case 83: {
          let f = this.lookaheadCharCode();
          if (f === 40 || f === 46)
            break;
        }
        case 82: {
          !(this.optionFlags & 8) && !u && this.raise(R.UnexpectedImportExport, this.state.startLoc), this.next();
          let f;
          return i === 83 ? f = this.parseImport(s) : f = this.parseExport(s, r), this.assertModuleNodeAllowed(f), f;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(R.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(s,
            !0, !a && o);
      }
      let l = this.state.value, c = this.parseExpression();
      return pt(i) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(s, l, c, t) : this.parseExpressionStatement(s, c,
      r);
    }
    assertModuleNodeAllowed(t) {
      !(this.optionFlags & 8) && !this.inModule && this.raise(R.ImportOutsideModule, t);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(t, r, i) {
      if (t) {
        var s;
        (s = r.decorators) != null && s.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(
        R.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(r, t[0]),
        i && this.resetStartLocationFromNode(i, r);
      }
      return r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(t) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(R.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(R.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let t = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, i;
        if (this.match(10)) {
          let s = this.state.startLoc;
          this.next(), i = this.parseExpression(), this.expect(11), i = this.wrapParenthesis(s, i);
          let a = this.state.startLoc;
          t.expression = this.parseMaybeDecoratorArguments(i, s), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !==
          i && this.raise(R.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (i = this.parseIdentifier(!1); this.eat(16); ) {
            let s = this.startNodeAt(r);
            s.object = i, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), s.property = this.parsePrivateName()) :
            s.property = this.parseIdentifier(!0), s.computed = !1, i = this.finishNode(s, "MemberExpression");
          }
          t.expression = this.parseMaybeDecoratorArguments(i, r);
        }
      } else
        t.expression = this.parseExprSubscripts();
      return this.finishNode(t, "Decorator");
    }
    parseMaybeDecoratorArguments(t, r) {
      if (this.eat(10)) {
        let i = this.startNodeAt(r);
        return i.callee = t, i.arguments = this.parseCallExpressionArguments(), this.toReferencedList(i.arguments), this.finishNode(i, "Call\
Expression");
      }
      return t;
    }
    parseBreakContinueStatement(t, r) {
      return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(t, r) {
      let i;
      for (i = 0; i < this.state.labels.length; ++i) {
        let s = this.state.labels[i];
        if ((t.label == null || s.name === t.label.name) && (s.kind != null && (r || s.kind === 1) || t.label && r))
          break;
      }
      if (i === this.state.labels.length) {
        let s = r ? "BreakStatement" : "ContinueStatement";
        this.raise(R.IllegalBreakContinue, t, {
          type: s
        });
      }
    }
    parseDebuggerStatement(t) {
      return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let t = this.parseExpression();
      return this.expect(11), t;
    }
    parseDoWhileStatement(t) {
      return this.next(), this.state.labels.push(mT), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
    }
    parseForStatement(t) {
      this.next(), this.state.labels.push(mT);
      let r = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (r = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10),
      this.match(13))
        return r !== null && this.unexpected(r), this.parseFor(t, null);
      let i = this.isContextual(100);
      {
        let l = this.isAwaitUsing(), c = l || this.isForUsing(), f = i && this.hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || f) {
          let m = this.startNode(), h;
          l ? (h = "await using", this.recordAwaitIfAllowed() || this.raise(R.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) :
          h = this.state.value, this.next(), this.parseVar(m, !0, h);
          let d = this.finishNode(m, "VariableDeclaration"), y = this.match(58);
          return y && c && this.raise(R.ForInUsing, d), (y || this.isContextual(102)) && d.declarations.length === 1 ? this.parseForIn(t, d,
          r) : (r !== null && this.unexpected(r), this.parseFor(t, d));
        }
      }
      let s = this.isContextual(95), a = new $l(), o = this.parseExpression(!0, a), u = this.isContextual(102);
      if (u && (i && this.raise(R.ForOfLet, o), r === null && s && o.type === "Identifier" && this.raise(R.ForOfAsync, o)), u || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let l = u ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          type: l
        }), this.parseForIn(t, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(t, o);
    }
    parseFunctionStatement(t, r, i) {
      return this.next(), this.parseFunction(t, 1 | (i ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
    }
    parseReturnStatement(t) {
      return this.prodParam.hasReturn || this.raise(R.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t.argument =
      null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
    }
    parseSwitchStatement(t) {
      this.next(), t.discriminant = this.parseHeaderExpression();
      let r = t.cases = [];
      this.expect(5), this.state.labels.push(ZPe), this.scope.enter(256);
      let i;
      for (let s; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          i && this.finishNode(i, "SwitchCase"), r.push(i = this.startNode()), i.consequent = [], this.next(), a ? i.test = this.parseExpression() :
          (s && this.raise(R.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), s = !0, i.test = null), this.expect(14);
        } else
          i ? i.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), i && this.finishNode(i, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchState\
ment");
    }
    parseThrowStatement(t) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(R.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(t, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let t = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {
        type: "CatchClause"
      }, 9), t;
    }
    parseTryStatement(t) {
      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(
        r, "CatchClause");
      }
      return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(R.NoCatchOrFinally, t), this.finishNode(
      t, "TryStatement");
    }
    parseVarStatement(t, r, i = !1) {
      return this.next(), this.parseVar(t, !1, r, i), this.semicolon(), this.finishNode(t, "VariableDeclaration");
    }
    parseWhileStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(mT), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
    }
    parseWithStatement(t) {
      return this.state.strict && this.raise(R.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
    }
    parseEmptyStatement(t) {
      return this.next(), this.finishNode(t, "EmptyStatement");
    }
    parseLabeledStatement(t, r, i, s) {
      for (let o of this.state.labels)
        o.name === r && this.raise(R.LabelRedeclaration, i, {
          labelName: r
        });
      let a = aPe(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let u = this.state.labels[o];
        if (u.statementStart === t.start)
          u.statementStart = this.sourceToOffsetPos(this.state.start), u.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.sourceToOffsetPos(this.state.start)
      }), t.body = s & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label =
      i, this.finishNode(t, "LabeledStatement");
    }
    parseExpressionStatement(t, r, i) {
      return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
    }
    parseBlock(t = !1, r = !0, i) {
      let s = this.startNode();
      return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(s, t, !1, 8, i), r && this.
      scope.exit(), this.finishNode(s, "BlockStatement");
    }
    isValidDirective(t) {
      return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
    }
    parseBlockBody(t, r, i, s, a) {
      let o = t.body = [], u = t.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? u : void 0, i, s, a);
    }
    parseBlockOrModuleBlockBody(t, r, i, s, a) {
      let o = this.state.strict, u = !1, l = !1;
      for (; !this.match(s); ) {
        let c = i ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !l) {
          if (this.isValidDirective(c)) {
            let f = this.stmtToDirective(c);
            r.push(f), !u && f.value.value === "use strict" && (u = !0, this.setStrict(!0));
            continue;
          }
          l = !0, this.state.strictErrors.clear();
        }
        t.push(c);
      }
      a?.call(this, u), o || this.setStrict(!1), this.next();
    }
    parseFor(t, r) {
      return t.init = r, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
    }
    parseForIn(t, r, i) {
      let s = this.match(58);
      return this.next(), s ? i !== null && this.unexpected(i) : t.await = i !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!s || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(R.ForInOfLoopInitializer, r, {
        type: s ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(R.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), t.left = r, t.right = s ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, s ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(t, r, i, s = !1) {
      let a = t.declarations = [];
      for (t.kind = i; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, i), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !s && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(R.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (i === "const" || i === "using" || i === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(R.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: i
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return t;
    }
    parseVarId(t, r) {
      let i = this.parseBindingAtom();
      r === "using" || r === "await using" ? (i.type === "ArrayPattern" || i.type === "ObjectPattern") && this.raise(R.UsingDeclarationHasBindingPattern,
      i.loc.start) : i.type === "VoidPattern" && this.raise(R.UnexpectedVoidPattern, i.loc.start), this.checkLVal(i, {
        type: "VariableDeclarator"
      }, r === "var" ? 5 : 8201), t.id = i;
    }
    parseAsyncFunctionExpression(t) {
      return this.parseFunction(t, 8);
    }
    parseFunction(t, r = 0) {
      let i = r & 2, s = !!(r & 1), a = s && !(r & 4), o = !!(r & 8);
      this.initFunction(t, o), this.match(55) && (i && this.raise(R.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.
      generator = !0), s && (t.id = this.parseFunctionId(a));
      let u = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(514), this.prodParam.enter(Gm(o, t.generator)), s || (t.id = this.parseFunctionId()),
      this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(t, s ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), s && !i && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = u, t;
    }
    parseFunctionId(t) {
      return t || pt(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(t, r) {
      this.expect(10), this.expressionScope.enter(LPe()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(t) {
      t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, t.id.loc.start);
    }
    parseClass(t, r, i) {
      this.next();
      let s = this.state.strict;
      return this.state.strict = !0, this.parseClassId(t, r, i), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, s), this.
      finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(t) {
      return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
    }
    isNonstaticConstructor(t) {
      return !t.computed && !t.static && this.nameIsConstructor(t.key);
    }
    parseClassBody(t, r) {
      this.classScope.enter();
      let i = {
        hadConstructor: !1,
        hadSuperClass: t
      }, s = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (s.length > 0)
              throw this.raise(R.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            s.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          s.length && (o.decorators = s, this.resetStartLocationFromNode(o, s[0]), s = []), this.parseClassMember(a, o, i), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(R.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), s.length)
        throw this.raise(R.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(t, r) {
      let i = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let s = r;
        return s.kind = "method", s.computed = !1, s.key = i, s.static = !1, this.pushClassMethod(t, s, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let s = r;
        return s.computed = !1, s.key = i, s.static = !1, t.body.push(this.parseClassProperty(s)), !0;
      }
      return this.resetPreviousNodeTrailingComments(i), !1;
    }
    parseClassMember(t, r, i) {
      let s = this.isContextual(106);
      if (s) {
        if (this.parseClassMemberFromModifier(t, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(t, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(t, r, i, s);
    }
    parseClassMemberWithIsStatic(t, r, i, s) {
      let a = r, o = r, u = r, l = r, c = r, f = a, m = a;
      if (r.static = s, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        f.kind = "method";
        let b = this.match(139);
        if (this.parseClassElementName(f), this.parsePostMemberNameModifiers(f), b) {
          this.pushClassPrivateMethod(t, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(R.ConstructorIsGenerator, a.key), this.pushClassMethod(t, a, !0, !1, !1, !1);
        return;
      }
      let h = !this.state.containsEsc && pt(this.state.type), d = this.parseClassElementName(r), y = h ? d.name : null, p = this.isPrivateName(
      d), g = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(m), this.isClassMethod()) {
        if (f.kind = "method", p) {
          this.pushClassPrivateMethod(t, o, !1, !1);
          return;
        }
        let b = this.isNonstaticConstructor(a), D = !1;
        b && (a.kind = "constructor", i.hadConstructor && !this.hasPlugin("typescript") && this.raise(R.DuplicateConstructor, d), b && this.
        hasPlugin("typescript") && r.override && this.raise(R.OverrideOnConstructor, d), i.hadConstructor = !0, D = i.hadSuperClass), this.pushClassMethod(
        t, a, !1, !1, b, D);
      } else if (this.isClassProperty())
        p ? this.pushClassPrivateProperty(t, l) : this.pushClassProperty(t, u);
      else if (y === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(d);
        let b = this.eat(55);
        m.optional && this.unexpected(g), f.kind = "method";
        let D = this.match(139);
        this.parseClassElementName(f), this.parsePostMemberNameModifiers(m), D ? this.pushClassPrivateMethod(t, o, b, !0) : (this.isNonstaticConstructor(
        a) && this.raise(R.ConstructorIsAsync, a.key), this.pushClassMethod(t, a, b, !0, !1, !1));
      } else if ((y === "get" || y === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(d), f.kind = y;
        let b = this.match(139);
        this.parseClassElementName(a), b ? this.pushClassPrivateMethod(t, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(R.ConstructorIsAccessor,
        a.key), this.pushClassMethod(t, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (y === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(d);
        let b = this.match(139);
        this.parseClassElementName(u), this.pushClassAccessorProperty(t, c, b);
      } else this.isLineTerminator() ? p ? this.pushClassPrivateProperty(t, l) : this.pushClassProperty(t, u) : this.unexpected();
    }
    parseClassElementName(t) {
      let {
        type: r,
        value: i
      } = this.state;
      if ((r === 132 || r === 134) && t.static && i === "prototype" && this.raise(R.StaticPrototype, this.state.startLoc), r === 139) {
        i === "constructor" && this.raise(R.ConstructorClassPrivateField, this.state.startLoc);
        let s = this.parsePrivateName();
        return t.key = s, s;
      }
      return this.parsePropertyName(t), t.key;
    }
    parseClassStaticBlock(t, r) {
      var i;
      this.scope.enter(720);
      let s = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = s, t.body.push(this.
      finishNode(r, "StaticBlock")), (i = r.decorators) != null && i.length && this.raise(R.DecoratorStaticBlock, r);
    }
    pushClassProperty(t, r) {
      !r.computed && this.nameIsConstructor(r.key) && this.raise(R.ConstructorClassField, r.key), t.body.push(this.parseClassProperty(r));
    }
    pushClassPrivateProperty(t, r) {
      let i = this.parseClassPrivateProperty(r);
      t.body.push(i), this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
    }
    pushClassAccessorProperty(t, r, i) {
      !i && !r.computed && this.nameIsConstructor(r.key) && this.raise(R.ConstructorClassField, r.key);
      let s = this.parseClassAccessorProperty(r);
      t.body.push(s), i && this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
    }
    pushClassMethod(t, r, i, s, a, o) {
      t.body.push(this.parseMethod(r, i, s, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(t, r, i, s) {
      let a = this.parseMethod(r, i, s, !1, !1, "ClassPrivateMethod", !0);
      t.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(t, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
    }
    parsePostMemberNameModifiers(t) {
    }
    parseClassPrivateProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
    }
    parseClassProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
    }
    parseClassAccessorProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
    }
    parseInitializer(t) {
      this.scope.enter(592), this.expressionScope.enter(yL()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(t, r, i, s = 8331) {
      if (pt(this.state.type))
        t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, s);
      else if (i || !r)
        t.id = null;
      else
        throw this.raise(R.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(t) {
      t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(t, r) {
      let i = this.parseMaybeImportPhase(t, !0), s = this.maybeParseExportDefaultSpecifier(t, i), a = !s || this.eat(12), o = a && this.eatExportStar(
      t), u = o && this.maybeParseExportNamespaceSpecifier(t), l = a && (!u || this.eat(12)), c = s || o;
      if (o && !u) {
        if (s && this.unexpected(), r)
          throw this.raise(R.UnsupportedDecoratorExport, t);
        return this.parseExportFrom(t, !0), this.sawUnambiguousESM = !0, this.finishNode(t, "ExportAllDeclaration");
      }
      let f = this.maybeParseExportNamedSpecifiers(t);
      s && a && !o && !f && this.unexpected(null, 5), u && l && this.unexpected(null, 98);
      let m;
      if (c || f) {
        if (m = !1, r)
          throw this.raise(R.UnsupportedDecoratorExport, t);
        this.parseExportFrom(t, c);
      } else
        m = this.maybeParseExportDeclaration(t);
      if (c || f || m) {
        var h;
        let d = t;
        if (this.checkExport(d, !0, !1, !!d.source), ((h = d.declaration) == null ? void 0 : h.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, d.declaration, d);
        else if (r)
          throw this.raise(R.UnsupportedDecoratorExport, t);
        return this.sawUnambiguousESM = !0, this.finishNode(d, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let d = t, y = this.parseExportDefaultExpression();
        if (d.declaration = y, y.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, y, d);
        else if (r)
          throw this.raise(R.UnsupportedDecoratorExport, t);
        return this.checkExport(d, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(d, "ExportDefaultDeclaration");
      }
      throw this.unexpected(null, 5);
    }
    eatExportStar(t) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(t, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let i = r || this.parseIdentifier(!0), s = this.startNodeAtNode(i);
        return s.exported = i, t.specifiers = [this.finishNode(s, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(t) {
      if (this.isContextual(93)) {
        var r, i;
        (i = (r = t).specifiers) != null || (r.specifiers = []);
        let s = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), s.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(s, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(t) {
      if (this.match(5)) {
        let r = t;
        r.specifiers || (r.specifiers = []);
        let i = r.exportKind === "type";
        return r.specifiers.push(...this.parseExportSpecifiers(i)), r.source = null, this.hasPlugin("importAssertions") ? r.assertions = [] :
        r.attributes = [], r.declaration = null, !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(t) {
      return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") ? t.assertions = [] :
      t.attributes = [], t.declaration = this.parseExportDeclaration(t), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let t = this.nextTokenInLineStart();
      return this.isUnparsedContextual(t, "function");
    }
    parseExportDefaultExpression() {
      let t = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(t, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(t, 13);
      if (this.match(80))
        return this.parseClass(t, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(R.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing())
        throw this.raise(R.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(t) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: t
      } = this.state;
      if (pt(t)) {
        if (t === 95 && !this.state.containsEsc || t === 100)
          return !1;
        if ((t === 130 || t === 129) && !this.state.containsEsc) {
          let s = this.nextTokenStart(), a = this.input.charCodeAt(s);
          if (a === 123 || this.chStartsBindingIdentifier(a, s) && !this.input.startsWith("from", s))
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), i = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || pt(this.state.type) && i)
        return !0;
      if (this.match(65) && i) {
        let s = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return s === 34 || s === 39;
      }
      return !1;
    }
    parseExportFrom(t, r) {
      this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(
      t)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: t
      } = this.state;
      return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(R.DecoratorBeforeExport, this.state.startLoc), !0) : this.isUsing() ? (this.raise(
      R.UsingDeclarationExport, this.state.startLoc), !0) : this.isAwaitUsing() ? (this.raise(R.UsingDeclarationExport, this.state.startLoc),
      !0) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(t, r, i, s) {
      if (r) {
        var a;
        if (i) {
          if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let u = t.declaration;
            u.type === "Identifier" && u.name === "from" && u.end - u.start === 4 && !((o = u.extra) != null && o.parenthesized) && this.raise(
            R.ExportDefaultFromAsIdentifier, u);
          }
        } else if ((a = t.specifiers) != null && a.length)
          for (let u of t.specifiers) {
            let {
              exported: l
            } = u, c = l.type === "Identifier" ? l.name : l.value;
            if (this.checkDuplicateExports(u, c), !s && u.local) {
              let {
                local: f
              } = u;
              f.type !== "Identifier" ? this.raise(R.ExportBindingIsString, u, {
                localName: f.value,
                exportName: c
              }) : (this.checkReservedWord(f.name, f.loc.start, !0, !1), this.scope.checkLocalExport(f));
            }
          }
        else if (t.declaration) {
          let u = t.declaration;
          if (u.type === "FunctionDeclaration" || u.type === "ClassDeclaration") {
            let {
              id: l
            } = u;
            if (!l) throw new Error("Assertion failure");
            this.checkDuplicateExports(t, l.name);
          } else if (u.type === "VariableDeclaration")
            for (let l of u.declarations)
              this.checkDeclaration(l.id);
        }
      }
    }
    checkDeclaration(t) {
      if (t.type === "Identifier")
        this.checkDuplicateExports(t, t.name);
      else if (t.type === "ObjectPattern")
        for (let r of t.properties)
          this.checkDeclaration(r);
      else if (t.type === "ArrayPattern")
        for (let r of t.elements)
          r && this.checkDeclaration(r);
      else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type ===
      "AssignmentPattern" && this.checkDeclaration(t.left);
    }
    checkDuplicateExports(t, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(R.DuplicateDefaultExport, t) : this.raise(R.DuplicateExport, t, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(t) {
      let r = [], i = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (i)
          i = !1;
        else if (this.expect(12), this.eat(8)) break;
        let s = this.isContextual(130), a = this.match(134), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, t, s));
      }
      return r;
    }
    parseExportSpecifier(t, r, i, s) {
      return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = this.cloneStringLiteral(t.local) : t.exported ||
      (t.exported = this.cloneIdentifier(t.local)), this.finishNode(t, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        let t = this.parseStringLiteral(this.state.value), r = QPe.exec(t.value);
        return r && this.raise(R.ModuleExportNameHasLoneSurrogate, t, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), t;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(t) {
      return t.assertions != null ? t.assertions.some(({
        key: r,
        value: i
      }) => i.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(t) {
      let {
        specifiers: r
      } = t, i = r.length === 1 ? r[0].type : null;
      if (t.phase === "source")
        i !== "ImportDefaultSpecifier" && this.raise(R.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (t.phase === "defer")
        i !== "ImportNamespaceSpecifier" && this.raise(R.DeferImportRequiresNamespace, r[0].loc.start);
      else if (t.module) {
        var s;
        i !== "ImportDefaultSpecifier" && this.raise(R.ImportReflectionNotBinding, r[0].loc.start), ((s = t.assertions) == null ? void 0 : s.
        length) > 0 && this.raise(R.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(t) {
      if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = t;
        if (r != null) {
          let i = r.find((s) => {
            let a;
            if (s.type === "ExportSpecifier" ? a = s.local : s.type === "ImportSpecifier" && (a = s.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          i !== void 0 && this.raise(R.ImportJSONBindingNotDefault, i.loc.start);
        }
      }
    }
    isPotentialImportPhase(t) {
      return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(t, r, i, s) {
      r || (i === "module" ? (this.expectPlugin("importReflection", s), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1),
      i === "source" ? (this.expectPlugin("sourcePhaseImports", s), t.phase = "source") : i === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", s), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
    }
    parseMaybeImportPhase(t, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(t, r, null), null;
      let i = this.startNode(), s = this.parseIdentifierName(!0), {
        type: a
      } = this.state;
      return (hs(a) ? a !== 98 || this.lookaheadCharCode() === 102 : a !== 12) ? (this.applyImportPhase(t, r, s, i.loc.start), null) : (this.
      applyImportPhase(t, r, null), this.createIdentifier(i, s));
    }
    isPrecedingIdImportPhase(t) {
      let {
        type: r
      } = this.state;
      return pt(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(t) {
      return this.match(134) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
    }
    parseImportSpecifiersAndAfter(t, r) {
      t.specifiers = [];
      let s = !this.maybeParseDefaultImportSpecifier(t, r) || this.eat(12), a = s && this.maybeParseStarImportSpecifier(t);
      return s && !a && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
    }
    parseImportSourceAndAttributes(t) {
      var r;
      return (r = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.
      checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(t, "ImportDecl\
aration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(t, r, i) {
      r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, i));
    }
    finishImportSpecifier(t, r, i = 8201) {
      return this.checkLVal(t.local, {
        type: r
      }, i), this.finishNode(t, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let i = this.startNode(), s = this.state.value;
        if (r.has(s) && this.raise(R.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: s
        }), r.add(s), this.match(134) ? i.key = this.parseStringLiteral(s) : i.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        134))
          throw this.raise(R.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), t;
    }
    parseModuleAttributes() {
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        let i = this.startNode();
        if (i.key = this.parseIdentifier(!0), i.key.name !== "type" && this.raise(R.ModuleAttributeDifferentFromType, i.key), r.has(i.key.name) &&
        this.raise(R.ModuleAttributesWithDuplicateKeys, i.key, {
          key: i.key.name
        }), r.add(i.key.name), this.expect(14), !this.match(134))
          throw this.raise(R.ModuleAttributeInvalidValue, this.state.startLoc);
        i.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(i, "ImportAttribute"));
      } while (this.eat(12));
      return t;
    }
    maybeParseImportAttributes(t) {
      let r;
      var i = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? (r = this.parseModuleAttributes(), this.addExtra(t, "deprecatedWithLegacySyntax", !0)) :
        r = this.parseImportAttributes(), i = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importA\
ssertions") && this.raise(R.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(t, "depreca\
tedAssertSyntax", !0), this.next(), r = this.parseImportAttributes()) : r = [];
      !i && this.hasPlugin("importAssertions") ? t.assertions = r : t.attributes = r;
    }
    maybeParseDefaultImportSpecifier(t, r) {
      if (r) {
        let i = this.startNodeAtNode(r);
        return i.local = r, t.specifiers.push(this.finishImportSpecifier(i, "ImportDefaultSpecifier")), !0;
      } else if (hs(this.state.type))
        return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(t) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(t) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(R.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let i = this.startNode(), s = this.match(134), a = this.isContextual(130);
        i.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(i, s, t.importKind === "type" || t.importKind === "typeof", a, void 0);
        t.specifiers.push(o);
      }
    }
    parseImportSpecifier(t, r, i, s, a) {
      if (this.eatContextual(93))
        t.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = t;
        if (r)
          throw this.raise(R.ImportBindingIsString, t, {
            importName: o.value
          });
        this.checkReservedWord(o.name, t.loc.start, !0, !0), t.local || (t.local = this.cloneIdentifier(o));
      }
      return this.finishImportSpecifier(t, "ImportSpecifier", a);
    }
    isThisParam(t) {
      return t.type === "Identifier" && t.name === "this";
    }
  }, ty = class extends RT {
    static {
      n(this, "Parser");
    }
    constructor(t, r, i) {
      let s = Z3e(t);
      super(s, r), this.options = s, this.initializeScopes(), this.plugins = i, this.filename = s.sourceFilename, this.startIndex = s.startIndex;
      let a = 0;
      s.allowAwaitOutsideFunction && (a |= 1), s.allowReturnOutsideFunction && (a |= 2), s.allowImportExportEverywhere && (a |= 8), s.allowSuperOutsideMethod &&
      (a |= 16), s.allowUndeclaredExports && (a |= 64), s.allowNewTargetOutsideFunction && (a |= 4), s.allowYieldOutsideFunction && (a |= 32),
      s.ranges && (a |= 128), s.tokens && (a |= 256), s.createImportExpressions && (a |= 512), s.createParenthesizedExpressions && (a |= 1024),
      s.errorRecovery && (a |= 2048), s.attachComment && (a |= 4096), s.annexB && (a |= 8192), this.optionFlags = a;
    }
    getScopeHandler() {
      return qd;
    }
    parse() {
      this.enterInitialScopes();
      let t = this.startNode(), r = this.startNode();
      this.nextToken(), t.errors = null;
      let i = this.parseTopLevel(t, r);
      return i.errors = this.state.errors, i.comments.length = this.state.commentsLen, i;
    }
  };
  function t4e(e, t) {
    var r;
    if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
      t = Object.assign({}, t);
      try {
        t.sourceType = "module";
        let i = Rd(t, e), s = i.parse();
        if (i.sawUnambiguousESM)
          return s;
        if (i.ambiguousScriptDifferentAst)
          try {
            return t.sourceType = "script", Rd(t, e).parse();
          } catch {
          }
        else
          s.program.sourceType = "script";
        return s;
      } catch (i) {
        try {
          return t.sourceType = "script", Rd(t, e).parse();
        } catch {
        }
        throw i;
      }
    } else
      return Rd(t, e).parse();
  }
  n(t4e, "parse");
  function r4e(e, t) {
    let r = Rd(t, e);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  n(r4e, "parseExpression");
  function i4e(e) {
    let t = {};
    for (let r of Object.keys(e))
      t[r] = Mn(e[r]);
    return t;
  }
  n(i4e, "generateExportedTokenTypes");
  var s4e = i4e(rPe);
  function Rd(e, t) {
    let r = ty, i = /* @__PURE__ */ new Map();
    if (e != null && e.plugins) {
      for (let s of e.plugins) {
        let a, o;
        typeof s == "string" ? a = s : [a, o] = s, i.has(a) || i.set(a, o || {});
      }
      YPe(i), r = n4e(i);
    }
    return new r(e, t, i);
  }
  n(Rd, "getParser");
  var nL = /* @__PURE__ */ new Map();
  function n4e(e) {
    let t = [];
    for (let s of GPe)
      e.has(s) && t.push(s);
    let r = t.join("|"), i = nL.get(r);
    if (!i) {
      i = ty;
      for (let s of t)
        i = DL[s](i);
      nL.set(r, i);
    }
    return i;
  }
  n(n4e, "getParserClass");
  $d.parse = t4e;
  $d.parseExpression = r4e;
  $d.tokTypes = s4e;
});

// ../node_modules/js-tokens/index.js
var vL = E((ry) => {
  Object.defineProperty(ry, "__esModule", {
    value: !0
  });
  ry.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  ry.matchToToken = function(e) {
    var t = { type: "invalid", value: e[0], closed: void 0 };
    return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) :
    e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "white\
space"), t;
  };
});

// ../node_modules/@babel/code-frame/lib/index.js
var Wd = E((Vd) => {
  "use strict";
  Object.defineProperty(Vd, "__esModule", { value: !0 });
  var zT = Mh(), xL = vL(), EL = Ol();
  function a4e() {
    return typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? !1 : zT.isColorSupported;
  }
  n(a4e, "isColorSupported");
  var iy = /* @__PURE__ */ n((e, t) => (r) => e(t(r)), "compose");
  function CL(e) {
    return {
      keyword: e.cyan,
      capitalized: e.yellow,
      jsxIdentifier: e.yellow,
      punctuator: e.yellow,
      number: e.magenta,
      string: e.green,
      regex: e.magenta,
      comment: e.gray,
      invalid: iy(iy(e.white, e.bgRed), e.bold),
      gutter: e.gray,
      marker: iy(e.red, e.bold),
      message: iy(e.red, e.bold),
      reset: e.reset
    };
  }
  n(CL, "buildDefs");
  var o4e = CL(zT.createColors(!0)), u4e = CL(zT.createColors(!1));
  function wL(e) {
    return e ? o4e : u4e;
  }
  n(wL, "getDefs");
  var l4e = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]), c4e = /\r\n|[\n\r\u2028\u2029]/, f4e = /^[()[\]{}]$/, AL;
  {
    let e = /^[a-z][\w-]*$/i, t = /* @__PURE__ */ n(function(r, i, s) {
      if (r.type === "name") {
        if (EL.isKeyword(r.value) || EL.isStrictReservedWord(r.value, !0) || l4e.has(r.value))
          return "keyword";
        if (e.test(r.value) && (s[i - 1] === "<" || s.slice(i - 2, i) === "</"))
          return "jsxIdentifier";
        if (r.value[0] !== r.value[0].toLowerCase())
          return "capitalized";
      }
      return r.type === "punctuator" && f4e.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punc\
tuator" : r.type;
    }, "getTokenType");
    AL = /* @__PURE__ */ n(function* (r) {
      let i;
      for (; i = xL.default.exec(r); ) {
        let s = xL.matchToToken(i);
        yield {
          type: t(s, i.index, r),
          value: s.value
        };
      }
    }, "tokenize");
  }
  function _L(e) {
    if (e === "") return "";
    let t = wL(!0), r = "";
    for (let {
      type: i,
      value: s
    } of AL(e))
      i in t ? r += s.split(c4e).map((a) => t[i](a)).join(`
`) : r += s;
    return r;
  }
  n(_L, "highlight");
  var SL = !1, TL = /\r\n|[\n\r\u2028\u2029]/;
  function d4e(e, t, r) {
    let i = Object.assign({
      column: 0,
      line: -1
    }, e.start), s = Object.assign({}, i, e.end), {
      linesAbove: a = 2,
      linesBelow: o = 3
    } = r || {}, u = i.line, l = i.column, c = s.line, f = s.column, m = Math.max(u - (a + 1), 0), h = Math.min(t.length, c + o);
    u === -1 && (m = 0), c === -1 && (h = t.length);
    let d = c - u, y = {};
    if (d)
      for (let p = 0; p <= d; p++) {
        let g = p + u;
        if (!l)
          y[g] = !0;
        else if (p === 0) {
          let b = t[g - 1].length;
          y[g] = [l, b - l + 1];
        } else if (p === d)
          y[g] = [0, f];
        else {
          let b = t[g - p].length;
          y[g] = [0, b];
        }
      }
    else
      l === f ? l ? y[u] = [l, 0] : y[u] = !0 : y[u] = [l, f - l];
    return {
      start: m,
      end: h,
      markerLines: y
    };
  }
  n(d4e, "getMarkerLines");
  function PL(e, t, r = {}) {
    let i = r.forceColor || a4e() && r.highlightCode, s = wL(i), a = e.split(TL), {
      start: o,
      end: u,
      markerLines: l
    } = d4e(t, a, r), c = t.start && typeof t.start.column == "number", f = String(u).length, h = (i ? _L(e) : e).split(TL, u).slice(o, u).map(
    (d, y) => {
      let p = o + 1 + y, b = ` ${` ${p}`.slice(-f)} |`, D = l[p], x = !l[p + 1];
      if (D) {
        let T = "";
        if (Array.isArray(D)) {
          let w = d.slice(0, Math.max(D[0] - 1, 0)).replace(/[^\t]/g, " "), B = D[1] || 1;
          T = [`
 `, s.gutter(b.replace(/\d/g, " ")), " ", w, s.marker("^").repeat(B)].join(""), x && r.message && (T += " " + s.message(r.message));
        }
        return [s.marker(">"), s.gutter(b), d.length > 0 ? ` ${d}` : "", T].join("");
      } else
        return ` ${s.gutter(b)}${d.length > 0 ? ` ${d}` : ""}`;
    }).join(`
`);
    return r.message && !c && (h = `${" ".repeat(f + 1)}${r.message}
${h}`), i ? s.reset(h) : h;
  }
  n(PL, "codeFrameColumns");
  function p4e(e, t, r, i = {}) {
    if (!SL) {
      SL = !0;
      let a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(a, "DeprecationWarning");
      else {
        let o = new Error(a);
        o.name = "DeprecationWarning", console.warn(new Error(a));
      }
    }
    return r = Math.max(r, 0), PL(e, {
      start: {
        column: r,
        line: t
      }
    }, i);
  }
  n(p4e, "index");
  Vd.codeFrameColumns = PL;
  Vd.default = p4e;
  Vd.highlight = _L;
});

// ../node_modules/@babel/template/lib/parse.js
var XT = E((JT) => {
  "use strict";
  Object.defineProperty(JT, "__esModule", {
    value: !0
  });
  JT.default = A4e;
  var h4e = Pe(), m4e = Ho(), y4e = Wd(), {
    isCallExpression: g4e,
    isExpressionStatement: b4e,
    isFunction: D4e,
    isIdentifier: v4e,
    isJSXIdentifier: x4e,
    isNewExpression: E4e,
    isPlaceholder: sy,
    isStatement: S4e,
    isStringLiteral: FL,
    removePropertiesDeep: T4e,
    traverse: C4e
  } = h4e, w4e = /^[_$A-Z0-9]+$/;
  function A4e(e, t, r) {
    let {
      placeholderWhitelist: i,
      placeholderPattern: s,
      preserveComments: a,
      syntacticPlaceholders: o
    } = r, u = F4e(t, r.parser, o);
    T4e(u, {
      preserveComments: a
    }), e.validate(u);
    let l = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist: i,
      placeholderPattern: s,
      syntacticPlaceholders: o
    };
    return C4e(u, _4e, l), Object.assign({
      ast: u
    }, l.syntactic.placeholders.length ? l.syntactic : l.legacy);
  }
  n(A4e, "parseAndBuildMetadata");
  function _4e(e, t, r) {
    var i;
    let s, a = r.syntactic.placeholders.length > 0;
    if (sy(e)) {
      if (r.syntacticPlaceholders === !1)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      s = e.name.name, a = !0;
    } else {
      if (a || r.syntacticPlaceholders)
        return;
      if (v4e(e) || x4e(e))
        s = e.name;
      else if (FL(e))
        s = e.value;
      else
        return;
    }
    if (a && (r.placeholderPattern != null || r.placeholderWhitelist != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!a && (r.placeholderPattern === !1 || !(r.placeholderPattern || w4e).test(s)) && !((i = r.placeholderWhitelist) != null && i.has(s)))
      return;
    t = t.slice();
    let {
      node: o,
      key: u
    } = t[t.length - 1], l;
    FL(e) || sy(e, {
      expectedNode: "StringLiteral"
    }) ? l = "string" : E4e(o) && u === "arguments" || g4e(o) && u === "arguments" || D4e(o) && u === "params" ? l = "param" : b4e(o) && !sy(
    e) ? (l = "statement", t = t.slice(0, -1)) : S4e(e) && sy(e) ? l = "statement" : l = "other";
    let {
      placeholders: c,
      placeholderNames: f
    } = a ? r.syntactic : r.legacy;
    c.push({
      name: s,
      type: l,
      resolve: /* @__PURE__ */ n((m) => P4e(m, t), "resolve"),
      isDuplicate: f.has(s)
    }), f.add(s);
  }
  n(_4e, "placeholderVisitorHandler");
  function P4e(e, t) {
    let r = e;
    for (let a = 0; a < t.length - 1; a++) {
      let {
        key: o,
        index: u
      } = t[a];
      u === void 0 ? r = r[o] : r = r[o][u];
    }
    let {
      key: i,
      index: s
    } = t[t.length - 1];
    return {
      parent: r,
      key: i,
      index: s
    };
  }
  n(P4e, "resolveAncestors");
  function F4e(e, t, r) {
    let i = (t.plugins || []).slice();
    r !== !1 && i.push("placeholders"), t = Object.assign({
      allowAwaitOutsideFunction: !0,
      allowReturnOutsideFunction: !0,
      allowNewTargetOutsideFunction: !0,
      allowSuperOutsideMethod: !0,
      allowYieldOutsideFunction: !0,
      sourceType: "module"
    }, t, {
      plugins: i
    });
    try {
      return (0, m4e.parse)(e, t);
    } catch (s) {
      let a = s.loc;
      throw a && (s.message += `
` + (0, y4e.codeFrameColumns)(e, {
        start: a
      }), s.code = "BABEL_TEMPLATE_PARSE_ERROR"), s;
    }
  }
  n(F4e, "parseWithCodeFrame");
});

// ../node_modules/@babel/template/lib/populate.js
var QT = E((ZT) => {
  "use strict";
  Object.defineProperty(ZT, "__esModule", {
    value: !0
  });
  ZT.default = M4e;
  var I4e = Pe(), {
    blockStatement: O4e,
    cloneNode: GT,
    emptyStatement: k4e,
    expressionStatement: YT,
    identifier: ny,
    isStatement: IL,
    isStringLiteral: B4e,
    stringLiteral: N4e,
    validate: OL
  } = I4e;
  function M4e(e, t) {
    let r = GT(e.ast);
    return t && (e.placeholders.forEach((i) => {
      if (!hasOwnProperty.call(t, i.name)) {
        let s = i.name;
        throw new Error(`Error: No substitution given for "${s}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${s}'])}
            - { placeholderPattern: /^${s}$/ }`);
      }
    }), Object.keys(t).forEach((i) => {
      if (!e.placeholderNames.has(i))
        throw new Error(`Unknown substitution "${i}" given`);
    })), e.placeholders.slice().reverse().forEach((i) => {
      try {
        var s;
        R4e(i, r, (s = t && t[i.name]) != null ? s : null);
      } catch (a) {
        throw a.message = `@babel/template placeholder "${i.name}": ${a.message}`, a;
      }
    }), r;
  }
  n(M4e, "populatePlaceholders");
  function R4e(e, t, r) {
    e.isDuplicate && (Array.isArray(r) ? r = r.map((u) => GT(u)) : typeof r == "object" && (r = GT(r)));
    let {
      parent: i,
      key: s,
      index: a
    } = e.resolve(t);
    if (e.type === "string") {
      if (typeof r == "string" && (r = N4e(r)), !r || !B4e(r))
        throw new Error("Expected string substitution");
    } else if (e.type === "statement")
      a === void 0 ? r ? Array.isArray(r) ? r = O4e(r) : typeof r == "string" ? r = YT(ny(r)) : IL(r) || (r = YT(r)) : r = k4e() : r && !Array.
      isArray(r) && (typeof r == "string" && (r = ny(r)), IL(r) || (r = YT(r)));
    else if (e.type === "param") {
      if (typeof r == "string" && (r = ny(r)), a === void 0) throw new Error("Assertion failure.");
    } else if (typeof r == "string" && (r = ny(r)), Array.isArray(r))
      throw new Error("Cannot replace single expression with an array.");
    function o(u, l, c) {
      let f = u[l];
      u[l] = c, (f.type === "Identifier" || f.type === "Placeholder") && (f.typeAnnotation && (c.typeAnnotation = f.typeAnnotation), f.optional &&
      (c.optional = f.optional), f.decorators && (c.decorators = f.decorators));
    }
    if (n(o, "set"), a === void 0)
      OL(i, s, r), o(i, s, r);
    else {
      let u = i[s].slice();
      e.type === "statement" || e.type === "param" ? r == null ? u.splice(a, 1) : Array.isArray(r) ? u.splice(a, 1, ...r) : o(u, a, r) : o(u,
      a, r), OL(i, s, u), i[s] = u;
    }
  }
  n(R4e, "applyReplacement");
});

// ../node_modules/@babel/template/lib/string.js
var kL = E((eC) => {
  "use strict";
  Object.defineProperty(eC, "__esModule", {
    value: !0
  });
  eC.default = U4e;
  var L4e = Km(), j4e = XT(), q4e = QT();
  function U4e(e, t, r) {
    t = e.code(t);
    let i;
    return (s) => {
      let a = (0, L4e.normalizeReplacements)(s);
      return i || (i = (0, j4e.default)(e, t, r)), e.unwrap((0, q4e.default)(i, a));
    };
  }
  n(U4e, "stringTemplate");
});

// ../node_modules/@babel/template/lib/literal.js
var BL = E((tC) => {
  "use strict";
  Object.defineProperty(tC, "__esModule", {
    value: !0
  });
  tC.default = H4e;
  var $4e = Km(), V4e = XT(), W4e = QT();
  function H4e(e, t, r) {
    let {
      metadata: i,
      names: s
    } = K4e(e, t, r);
    return (a) => {
      let o = {};
      return a.forEach((u, l) => {
        o[s[l]] = u;
      }), (u) => {
        let l = (0, $4e.normalizeReplacements)(u);
        return l && Object.keys(l).forEach((c) => {
          if (hasOwnProperty.call(o, c))
            throw new Error("Unexpected replacement overlap.");
        }), e.unwrap((0, W4e.default)(i, l ? Object.assign(l, o) : o));
      };
    };
  }
  n(H4e, "literalTemplate");
  function K4e(e, t, r) {
    let i = "BABEL_TPL$", s = t.join("");
    do
      i = "$$" + i;
    while (s.includes(i));
    let {
      names: a,
      code: o
    } = z4e(t, i);
    return {
      metadata: (0, V4e.default)(e, e.code(o), {
        parser: r.parser,
        placeholderWhitelist: new Set(a.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
        placeholderPattern: r.placeholderPattern,
        preserveComments: r.preserveComments,
        syntacticPlaceholders: r.syntacticPlaceholders
      }),
      names: a
    };
  }
  n(K4e, "buildLiteralData");
  function z4e(e, t) {
    let r = [], i = e[0];
    for (let s = 1; s < e.length; s++) {
      let a = `${t}${s - 1}`;
      r.push(a), i += a + e[s];
    }
    return {
      names: r,
      code: i
    };
  }
  n(z4e, "buildTemplateCode");
});

// ../node_modules/@babel/template/lib/builder.js
var qL = E((rC) => {
  "use strict";
  Object.defineProperty(rC, "__esModule", {
    value: !0
  });
  rC.default = jL;
  var rn = Km(), NL = kL(), ML = BL(), RL = (0, rn.validate)({
    placeholderPattern: !1
  });
  function jL(e, t) {
    let r = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap(), s = t || (0, rn.validate)(null);
    return Object.assign((a, ...o) => {
      if (typeof a == "string") {
        if (o.length > 1) throw new Error("Unexpected extra params.");
        return LL((0, NL.default)(e, a, (0, rn.merge)(s, (0, rn.validate)(o[0]))));
      } else if (Array.isArray(a)) {
        let u = r.get(a);
        return u || (u = (0, ML.default)(e, a, s), r.set(a, u)), LL(u(o));
      } else if (typeof a == "object" && a) {
        if (o.length > 0) throw new Error("Unexpected extra params.");
        return jL(e, (0, rn.merge)(s, (0, rn.validate)(a)));
      }
      throw new Error(`Unexpected template param ${typeof a}`);
    }, {
      ast: /* @__PURE__ */ n((a, ...o) => {
        if (typeof a == "string") {
          if (o.length > 1) throw new Error("Unexpected extra params.");
          return (0, NL.default)(e, a, (0, rn.merge)((0, rn.merge)(s, (0, rn.validate)(o[0])), RL))();
        } else if (Array.isArray(a)) {
          let u = i.get(a);
          return u || (u = (0, ML.default)(e, a, (0, rn.merge)(s, RL)), i.set(a, u)), u(o)();
        }
        throw new Error(`Unexpected template param ${typeof a}`);
      }, "ast")
    });
  }
  n(jL, "createTemplateBuilder");
  function LL(e) {
    let t = "";
    try {
      throw new Error();
    } catch (r) {
      r.stack && (t = r.stack.split(`
`).slice(3).join(`
`));
    }
    return (r) => {
      try {
        return e(r);
      } catch (i) {
        throw i.stack += `
    =============
${t}`, i;
      }
    };
  }
  n(LL, "extendedTrace");
});

// ../node_modules/@babel/template/lib/index.js
var zd = E((mi) => {
  "use strict";
  Object.defineProperty(mi, "__esModule", {
    value: !0
  });
  mi.statements = mi.statement = mi.smart = mi.program = mi.expression = mi.default = void 0;
  var Hd = WR(), Kd = qL(), iC = mi.smart = (0, Kd.default)(Hd.smart), J4e = mi.statement = (0, Kd.default)(Hd.statement), X4e = mi.statements =
  (0, Kd.default)(Hd.statements), Y4e = mi.expression = (0, Kd.default)(Hd.expression), G4e = mi.program = (0, Kd.default)(Hd.program), Tyt = mi.
  default = Object.assign(iC.bind(void 0), {
    smart: iC,
    statement: J4e,
    statements: X4e,
    expression: Y4e,
    program: G4e,
    ast: iC.ast
  });
});

// ../node_modules/@babel/helpers/lib/helpers-generated.js
var UL = E((ay) => {
  "use strict";
  Object.defineProperty(ay, "__esModule", {
    value: !0
  });
  ay.default = void 0;
  var Z4e = zd();
  function J(e, t, r) {
    return Object.freeze({
      minVersion: e,
      ast: /* @__PURE__ */ n(() => Z4e.default.program.ast(t, {
        preserveComments: !0
      }), "ast"),
      metadata: r
    });
  }
  n(J, "helper");
  var Q4e = ay.default = {
    __proto__: null,
    OverloadYield: J("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", {
      globals: [],
      locals: {
        _OverloadYield: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_OverloadYield",
      dependencies: {},
      internal: !1
    }),
    applyDecoratedDescriptor: J("7.0.0-beta.0", 'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach(functi\
on(i){a[i]=n[i]}),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().reve\
rse().reduce(function(r,n){return n(i,e,r)||r},a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializ\
er=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}', {
      globals: ["Object"],
      locals: {
        _applyDecoratedDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_applyDecoratedDescriptor",
      dependencies: {},
      internal: !1
    }),
    applyDecs2311: J("7.24.0", 'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Obj\
ect.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length\
;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||\
"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("At\
tempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){retu\
rn function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunction\
Name(function(){return v(this)},r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPropert\
yDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!==(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supporte\
d yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["field\
","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to \
call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"c\
lass decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?functi\
on(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get\
,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.i\
nit,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init\
 properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,\
0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0\
,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n\
.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,\
l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,g\
et c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}', {
      globals: ["Symbol", "Object", "TypeError", "Error"],
      locals: {
        applyDecs2311: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2311",
      dependencies: {
        checkInRHS: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.cons\
equent.body.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.pro\
perties.0.value.callee", "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"],
        toPropertyKey: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.al\
ternate.callee"]
      },
      internal: !1
    }),
    arrayLikeToArray: J("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[\
e];return n}", {
      globals: ["Array"],
      locals: {
        _arrayLikeToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayLikeToArray",
      dependencies: {},
      internal: !1
    }),
    arrayWithHoles: J("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", {
      globals: ["Array"],
      locals: {
        _arrayWithHoles: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayWithHoles",
      dependencies: {},
      internal: !1
    }),
    arrayWithoutHoles: J("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", {
      globals: ["Array"],
      locals: {
        _arrayWithoutHoles: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayWithoutHoles",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.argument.callee"]
      },
      internal: !1
    }),
    assertClassBrand: J("7.24.0", 'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;th\
row new TypeError("Private element is not present on this object")}', {
      globals: ["TypeError"],
      locals: {
        _assertClassBrand: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_assertClassBrand",
      dependencies: {},
      internal: !1
    }),
    assertThisInitialized: J("7.0.0-beta.0", `function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been in\
itialised - super() hasn't been called");return e}`, {
      globals: ["ReferenceError"],
      locals: {
        _assertThisInitialized: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_assertThisInitialized",
      dependencies: {},
      internal: !1
    }),
    asyncGeneratorDelegate: J("7.0.0-beta.0", 'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promis\
e(function(n){n(t[e](r))}),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=functi\
on(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;re\
turn pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}', {
      globals: ["Promise", "Symbol"],
      locals: {
        _asyncGeneratorDelegate: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncGeneratorDelegate",
      dependencies: {
        OverloadYield: ["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"]
      },
      internal: !1
    }),
    asyncIterator: J("7.15.9", 'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.it\
erator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="\
@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation\
(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then(function\
(r){return{value:r,done:n}})}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null\
,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return voi\
d 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.retu\
rn;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}', {
      globals: ["Symbol", "TypeError", "Object", "Promise"],
      locals: {
        _asyncIterator: ["body.0.id"],
        AsyncFromSyncIterator: ["body.1.id", "body.0.body.body.1.body.body.1.consequent.argument.callee", "body.1.body.body.1.argument.expre\
ssions.1.left.object", "body.1.body.body.1.argument.expressions.2.callee", "body.1.body.body.1.argument.expressions.0.left"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncIterator",
      dependencies: {},
      internal: !1
    }),
    asyncToGenerator: J("7.0.0-beta.0", 'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.\
done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise(function(r,\
o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_t\
hrow,"throw",n)}_next(void 0)})}}', {
      globals: ["Promise"],
      locals: {
        asyncGeneratorStep: ["body.0.id", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.c\
allee", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"],
        _asyncToGenerator: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncToGenerator",
      dependencies: {},
      internal: !1
    }),
    awaitAsyncGenerator: J("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", {
      globals: [],
      locals: {
        _awaitAsyncGenerator: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_awaitAsyncGenerator",
      dependencies: {
        OverloadYield: ["body.0.body.body.0.argument.callee"]
      },
      internal: !1
    }),
    callSuper: J("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Ref\
lect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", {
      globals: ["Reflect"],
      locals: {
        _callSuper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_callSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.0.argument.expressions.0.right.callee", "body.0.body.body.0.argument.expressions.1.arguments.1.co\
nsequent.arguments.2.object.callee"],
        isNativeReflectConstruct: ["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"],
        possibleConstructorReturn: ["body.0.body.body.0.argument.expressions.1.callee"]
      },
      internal: !1
    }),
    checkInRHS: J("7.20.5", `function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(n\
ull!==e?typeof e:"null"));return e}`, {
      globals: ["Object", "TypeError"],
      locals: {
        _checkInRHS: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_checkInRHS",
      dependencies: {},
      internal: !1
    }),
    checkPrivateRedeclaration: J("7.14.1", 'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the \
same private elements twice on an object")}', {
      globals: ["TypeError"],
      locals: {
        _checkPrivateRedeclaration: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_checkPrivateRedeclaration",
      dependencies: {},
      internal: !1
    }),
    classCallCheck: J("7.0.0-beta.0", 'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a func\
tion")}', {
      globals: ["TypeError"],
      locals: {
        _classCallCheck: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCallCheck",
      dependencies: {},
      internal: !1
    }),
    classNameTDZError: J("7.0.0-beta.0", `function _classNameTDZError(e){throw new ReferenceError('Class "'+e+'" cannot be referenced in com\
puted property keys.')}`, {
      globals: ["ReferenceError"],
      locals: {
        _classNameTDZError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classNameTDZError",
      dependencies: {},
      internal: !1
    }),
    classPrivateFieldGet2: J("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", {
      globals: [],
      locals: {
        _classPrivateFieldGet2: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldGet2",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
      },
      internal: !1
    }),
    classPrivateFieldInitSpec: J("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", {
      globals: [],
      locals: {
        _classPrivateFieldInitSpec: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldInitSpec",
      dependencies: {
        checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
      },
      internal: !1
    }),
    classPrivateFieldLooseBase: J("7.0.0-beta.0", 'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError(\
"attempted to use private field on non-instance");return e}', {
      globals: ["TypeError"],
      locals: {
        _classPrivateFieldBase: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldBase",
      dependencies: {},
      internal: !1
    }),
    classPrivateFieldLooseKey: J("7.0.0-beta.0", 'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}', {
      globals: [],
      locals: {
        id: ["body.0.declarations.0.id", "body.1.body.body.0.argument.left.left.right.argument", "body.1.body.body.0.argument.left.left.righ\
t.argument"],
        _classPrivateFieldKey: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldKey",
      dependencies: {},
      internal: !1
    }),
    classPrivateFieldSet2: J("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", {
      globals: [],
      locals: {
        _classPrivateFieldSet2: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldSet2",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
      },
      internal: !1
    }),
    classPrivateGetter: J("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", {
      globals: [],
      locals: {
        _classPrivateGetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateGetter",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
      },
      internal: !1
    }),
    classPrivateMethodInitSpec: J("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", {
      globals: [],
      locals: {
        _classPrivateMethodInitSpec: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodInitSpec",
      dependencies: {
        checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
      },
      internal: !1
    }),
    classPrivateSetter: J("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", {
      globals: [],
      locals: {
        _classPrivateSetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateSetter",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
      },
      internal: !1
    }),
    classStaticPrivateMethodGet: J("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", {
      globals: [],
      locals: {
        _classStaticPrivateMethodGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateMethodGet",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
      },
      internal: !1
    }),
    construct: J("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);va\
r o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", {
      globals: ["Reflect"],
      locals: {
        _construct: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_construct",
      dependencies: {
        isNativeReflectConstruct: ["body.0.body.body.0.test.callee"],
        setPrototypeOf: ["body.0.body.body.4.argument.expressions.0.right.callee"]
      },
      internal: !1
    }),
    createClass: J("7.0.0-beta.0", 'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.c\
onfigurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineP\
roperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}', {
      globals: ["Object"],
      locals: {
        _defineProperties: ["body.0.id", "body.1.body.body.0.argument.expressions.0.right.callee", "body.1.body.body.0.argument.expressions.\
1.right.callee"],
        _createClass: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createClass",
      dependencies: {
        toPropertyKey: ["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"]
      },
      internal: !1
    }),
    createForOfIteratorHelper: J("7.9.0", 'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r[\
"@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){\
};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid atte\
mpt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;\
return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||\
t.return()}finally{if(u)throw o}}}}', {
      globals: ["Symbol", "Array", "TypeError"],
      locals: {
        _createForOfIteratorHelper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createForOfIteratorHelper",
      dependencies: {
        unsupportedIterableToArray: ["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"]
      },
      internal: !1
    }),
    createForOfIteratorHelperLoose: J("7.9.0", 'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.ite\
rator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof\
 r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to i\
terate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["Symbol", "Array", "TypeError"],
      locals: {
        _createForOfIteratorHelperLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createForOfIteratorHelperLoose",
      dependencies: {
        unsupportedIterableToArray: ["body.0.body.body.2.test.left.right.right.callee"]
      },
      internal: !1
    }),
    createSuper: J("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var\
 s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,\
e)}}", {
      globals: ["Reflect"],
      locals: {
        _createSuper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee", "body.0.body.body.1.argument.body.body.1.cons\
equent.body.0.declarations.0.init.object.callee"],
        isNativeReflectConstruct: ["body.0.body.body.0.declarations.0.init.callee"],
        possibleConstructorReturn: ["body.0.body.body.1.argument.body.body.2.argument.callee"]
      },
      internal: !1
    }),
    decorate: J("7.1.5", `function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r(function(e\
){o.initializeInstanceElements(e,a.elements)},t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.ini\
tializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e\
};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach(function(t){r.fo\
rEach(function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)},this)},this)},initializeClassElements:function(e,r){var t=e\
.prototype;["method","field"].forEach(function(i){r.forEach(function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){va\
r n="static"===o?e:t;this.defineClassElement(n,r)}},this)},this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){v\
ar i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defi\
neProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach(function(e){this.addElementP\
lacement(e,o)},this),e.forEach(function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.a\
pply(t,r.extras),i.push.apply(i,r.finishers)},this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.appl\
y(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError(\
"Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s\
=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,\
this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r\
);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=thi\
s.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elemen\
ts;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Du\
plicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:\
e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kin\
d&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map(function(e){var r=this.toElementDes\
criptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r},t\
his)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError('An element descriptor\\'s .kind prope\
rty must be either "method" or "field", but a decorator created an element descriptor with .kind "'+r+'"');var t=toPropertyKey(e.key),i=e.pl\
acement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError('An element descriptor\\'s .placement property must be one of "sta\
tic", "prototype" or "own", but a decorator created an element descriptor with .placement "'+i+'"');var o=e.descriptor;this.disallowProperty\
(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProper\
ty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowPrope\
rty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"\
),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableP\
roperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.f\
romElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:fun\
ction(e){var r=e.kind+"";if("class"!==r)throw new TypeError('A class descriptor\\'s .kind property must be "class", but a decorator created a\
 class descriptor with .kind "'+r+'"');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class desc\
riptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallo\
wProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.element\
s),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw n\
ew TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+\
" can't have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.\
value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,\
configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"metho\
d",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"fiel\
d"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.des\
criptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.ke\
y&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descri\
ptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can\
't be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can't be p\
laced on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}r\
eturn r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.va\
lue&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expect\
ed '"+r+"' to be a function");return t}`, {
      globals: ["Object", "TypeError", "Symbol", "ReferenceError"],
      locals: {
        _decorate: ["body.0.id"],
        _getDecoratorsApi: ["body.1.id", "body.0.body.body.0.declarations.0.init.callee", "body.1.body.body.0.expression.left"],
        _createElementDescriptor: ["body.2.id", "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"],
        _coalesceGetterSetter: ["body.3.id", "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"],
        _coalesceClassElements: ["body.4.id", "body.0.body.body.2.declarations.1.init.arguments.0.callee"],
        _hasDecorators: ["body.5.id", "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.\
body.body.0.test.argument.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee", "body.4.body.body.0.body.\
body.1.consequent.consequent.body.0.test.right.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee", "body.4.bo\
dy.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"],
        _isDataDescriptor: ["body.6.id", "body.4.body.body.0.body.body.1.consequent.test.left.callee", "body.4.body.body.0.body.body.1.conse\
quent.test.right.callee"],
        _optionalCallableProperty: ["body.7.id", "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties\
.1.value.callee", "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"]
      },
      exportBindingAssignments: [],
      exportName: "_decorate",
      dependencies: {
        toArray: ["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"],
        toPropertyKey: ["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee", "body.2.body.bo\
dy.0.declarations.1.init.callee"]
      },
      internal: !1
    }),
    defaults: J("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.get\
OwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", {
      globals: ["Object"],
      locals: {
        _defaults: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defaults",
      dependencies: {},
      internal: !1
    }),
    defineAccessor: J("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty\
(r,n,c)}", {
      globals: ["Object"],
      locals: {
        _defineAccessor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineAccessor",
      dependencies: {},
      internal: !1
    }),
    defineProperty: J("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enu\
merable:!0,configurable:!0,writable:!0}):e[r]=t,e}", {
      globals: ["Object"],
      locals: {
        _defineProperty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineProperty",
      dependencies: {
        toPropertyKey: ["body.0.body.body.0.argument.expressions.0.test.left.right.callee"]
      },
      internal: !1
    }),
    extends: J("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.l\
ength;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", {
      globals: ["Object"],
      locals: {
        _extends: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_extends",
      dependencies: {},
      internal: !1
    }),
    get: J("7.0.0-beta.0", 'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=su\
perPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,\
arguments)}', {
      globals: ["Reflect", "Object"],
      locals: {
        _get: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_get",
      dependencies: {
        superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    getPrototypeOf: J("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind()\
:function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", {
      globals: ["Object"],
      locals: {
        _getPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_getPrototypeOf",
      dependencies: {},
      internal: !1
    }),
    identity: J("7.17.0", "function _identity(t){return t}", {
      globals: [],
      locals: {
        _identity: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_identity",
      dependencies: {},
      internal: !1
    }),
    importDeferProxy: J("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=functi\
on(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValu\
e(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:c\
onstValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:const\
Value(!1)})}", {
      globals: ["Proxy", "Reflect"],
      locals: {
        _importDeferProxy: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_importDeferProxy",
      dependencies: {},
      internal: !1
    }),
    inherits: J("7.0.0-beta.0", 'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either\
 be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty\
(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}', {
      globals: ["TypeError", "Object"],
      locals: {
        _inherits: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_inherits",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.1.expression.expressions.2.right.callee"]
      },
      internal: !1
    }),
    inheritsLoose: J("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setProto\
typeOf(t,o)}", {
      globals: ["Object"],
      locals: {
        _inheritsLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_inheritsLoose",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.0.expression.expressions.2.callee"]
      },
      internal: !1
    }),
    initializerDefineProperty: J("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.en\
umerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", {
      globals: ["Object"],
      locals: {
        _initializerDefineProperty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_initializerDefineProperty",
      dependencies: {},
      internal: !1
    }),
    initializerWarningHelper: J("7.0.0-beta.0", 'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Plea\
se ensure that transform-class-properties is enabled and runs after the decorators transform.")}', {
      globals: ["Error"],
      locals: {
        _initializerWarningHelper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_initializerWarningHelper",
      dependencies: {},
      internal: !1
    }),
    instanceof: J("7.0.0-beta.0", 'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.ha\
sInstance](n):n instanceof e}', {
      globals: ["Symbol"],
      locals: {
        _instanceof: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_instanceof",
      dependencies: {},
      internal: !1
    }),
    interopRequireDefault: J("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", {
      globals: [],
      locals: {
        _interopRequireDefault: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_interopRequireDefault",
      dependencies: {},
      internal: !1
    }),
    interopRequireWildcard: J("7.14.0", 'function _interopRequireWildcard(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap\
;return(_interopRequireWildcard=function(e,t){if(!t&&e&&e.__esModule)return e;var o,i,f={__proto__:null,default:e};if(null===e||"object"!=ty\
peof e&&"function"!=typeof e)return f;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,f)}for(const t in e)"default"!==t&&{}.hasOwnProperty.c\
all(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(f,t,i):f[t]=e[t]);return f})(e,t)}', {
      globals: ["WeakMap", "Object"],
      locals: {
        _interopRequireWildcard: ["body.0.id", "body.0.body.body.1.argument.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
      exportName: "_interopRequireWildcard",
      dependencies: {},
      internal: !1
    }),
    isNativeFunction: J("7.0.0-beta.0", 'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}cat\
ch(n){return"function"==typeof t}}', {
      globals: ["Function"],
      locals: {
        _isNativeFunction: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_isNativeFunction",
      dependencies: {},
      internal: !1
    }),
    isNativeReflectConstruct: J("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(B\
oolean,[],function(){}))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", {
      globals: ["Boolean", "Reflect"],
      locals: {
        _isNativeReflectConstruct: ["body.0.id", "body.0.body.body.1.argument.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
      exportName: "_isNativeReflectConstruct",
      dependencies: {},
      internal: !1
    }),
    iterableToArray: J("7.0.0-beta.0", 'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@ite\
rator"])return Array.from(r)}', {
      globals: ["Symbol", "Array"],
      locals: {
        _iterableToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_iterableToArray",
      dependencies: {},
      internal: !1
    }),
    iterableToArrayLimit: J("7.0.0-beta.0", 'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.ite\
rator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f\
=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u\
))return}finally{if(o)throw n}}return a}}', {
      globals: ["Symbol", "Object"],
      locals: {
        _iterableToArrayLimit: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_iterableToArrayLimit",
      dependencies: {},
      internal: !1
    }),
    jsx: J("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="functio\
n"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:vo\
id 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&\
&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}', {
      globals: ["Symbol", "Array"],
      locals: {
        REACT_ELEMENT_TYPE: ["body.0.declarations.0.id", "body.1.body.body.0.expression.left", "body.1.body.body.4.argument.properties.0.val\
ue", "body.1.body.body.0.expression.right.left"],
        _createRawReactElement: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createRawReactElement",
      dependencies: {},
      internal: !1
    }),
    maybeArrayLike: J("7.9.0", 'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return ar\
rayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}', {
      globals: ["Array"],
      locals: {
        _maybeArrayLike: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_maybeArrayLike",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.body.1.argument.callee"]
      },
      internal: !1
    }),
    newArrowCheck: J("7.0.0-beta.0", 'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}', {
      globals: ["TypeError"],
      locals: {
        _newArrowCheck: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_newArrowCheck",
      dependencies: {},
      internal: !1
    }),
    nonIterableRest: J("7.0.0-beta.0", 'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instanc\
e.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["TypeError"],
      locals: {
        _nonIterableRest: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nonIterableRest",
      dependencies: {},
      internal: !1
    }),
    nonIterableSpread: J("7.0.0-beta.0", 'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance\
.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["TypeError"],
      locals: {
        _nonIterableSpread: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nonIterableSpread",
      dependencies: {},
      internal: !1
    }),
    nullishReceiverError: J("7.22.6", 'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}',
    {
      globals: ["TypeError"],
      locals: {
        _nullishReceiverError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nullishReceiverError",
      dependencies: {},
      internal: !1
    }),
    objectDestructuringEmpty: J("7.0.0-beta.0", 'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+\
t)}', {
      globals: ["TypeError"],
      locals: {
        _objectDestructuringEmpty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectDestructuringEmpty",
      dependencies: {},
      internal: !1
    }),
    objectSpread2: J("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbol\
s(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,o)}return t}function _objectSpread2\
(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){definePropert\
y(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(fun\
ction(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}", {
      globals: ["Object"],
      locals: {
        ownKeys: ["body.0.id", "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee", "body.1.body.body.0.body.body.1.\
expression.alternate.alternate.callee.object.callee"],
        _objectSpread2: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectSpread2",
      dependencies: {
        defineProperty: ["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"]
      },
      internal: !1
    }),
    objectWithoutProperties: J("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutProperties\
Loose(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],-1===t.indexOf(o)&&{}.proper\
tyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}", {
      globals: ["Object"],
      locals: {
        _objectWithoutProperties: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectWithoutProperties",
      dependencies: {
        objectWithoutPropertiesLoose: ["body.0.body.body.1.declarations.2.init.callee"]
      },
      internal: !1
    }),
    objectWithoutPropertiesLoose: J("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r\
)if({}.hasOwnProperty.call(r,n)){if(-1!==e.indexOf(n))continue;t[n]=r[n]}return t}", {
      globals: [],
      locals: {
        _objectWithoutPropertiesLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectWithoutPropertiesLoose",
      dependencies: {},
      internal: !1
    }),
    possibleConstructorReturn: J("7.0.0-beta.0", 'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))\
return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}', {
      globals: ["TypeError"],
      locals: {
        _possibleConstructorReturn: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_possibleConstructorReturn",
      dependencies: {
        assertThisInitialized: ["body.0.body.body.2.argument.callee"]
      },
      internal: !1
    }),
    readOnlyError: J("7.0.0-beta.0", `function _readOnlyError(r){throw new TypeError('"'+r+'" is read-only')}`, {
      globals: ["TypeError"],
      locals: {
        _readOnlyError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_readOnlyError",
      dependencies: {},
      internal: !1
    }),
    regenerator: J("7.27.0", `function _regenerator(){
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/ba\
bel-helpers/LICENSE */
var e,t,r="function"==typeof Symbol?Symbol:{},n=r.iterator||"@@iterator",o=r.toStringTag||"@@toStringTag";function i(r,n,o,i){var c=n&&n.pro\
totype instanceof Generator?n:Generator,u=Object.create(c.prototype);return define(u,"_invoke",function(r,n,o){var i,c,u,f=0,p=o||[],y=!1,G=\
{p:0,n:0,v:e,a:d,f:d.bind(e,4),d:function(t,r){return i=t,c=0,u=e,G.n=r,a}};function d(r,n){for(c=r,u=n,t=0;!y&&f&&!o&&t<p.length;t++){var o\
,i=p[t],d=G.p,l=i[2];r>3?(o=l===n)&&(u=i[(c=i[4])?5:(c=3,3)],i[4]=i[5]=e):i[0]<=d&&((o=r<2&&d<i[1])?(c=0,G.v=n,G.n=i[1]):d<l&&(o=r<3||i[0]>n\
||n>l)&&(i[4]=r,i[5]=n,G.n=l,c=0))}if(o||r>1)return a;throw y=!0,n}return function(o,p,l){if(f>1)throw TypeError("Generator is already runni\
ng");for(y&&1===p&&d(p,l),c=p,u=l;(t=c<2?e:u)||!y;){i||(c?c<3?(c>1&&(G.n=-1),d(c,u)):G.n=u:G.v=u);try{if(f=2,i){if(c||(o="next"),t=i[o]){if(\
!(t=t.call(i,u)))throw TypeError("iterator result is not an object");if(!t.done)return t;u=t.value,c<2&&(c=0)}else 1===c&&(t=i.return)&&t.ca\
ll(i),c<2&&(u=TypeError("The iterator does not provide a '"+o+"' method"),c=1);i=e}else if((t=(y=G.n<0)?u:r.call(n,G))!==a)break}catch(t){i=\
e,c=1,u=t}finally{f=1}}return{value:t,done:y}}}(r,o,i),!0),u}var a={};function Generator(){}function GeneratorFunction(){}function Generator\
FunctionPrototype(){}t=Object.getPrototypeOf;var c=[][n]?t(t([][n]())):(define(t={},n,function(){return this}),t),u=GeneratorFunctionPrototy\
pe.prototype=Generator.prototype=Object.create(c);function f(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,GeneratorFunctionProtot\
ype):(e.__proto__=GeneratorFunctionPrototype,define(e,o,"GeneratorFunction")),e.prototype=Object.create(u),e}return GeneratorFunction.protot\
ype=GeneratorFunctionPrototype,define(u,"constructor",GeneratorFunctionPrototype),define(GeneratorFunctionPrototype,"constructor",GeneratorF\
unction),GeneratorFunction.displayName="GeneratorFunction",define(GeneratorFunctionPrototype,o,"GeneratorFunction"),define(u),define(u,o,"Ge\
nerator"),define(u,n,function(){return this}),define(u,"toString",function(){return"[object Generator]"}),(_regenerator=function(){return{w:\
i,m:f}})()}`, {
      globals: ["Symbol", "Object", "TypeError"],
      locals: {
        _regenerator: ["body.0.id", "body.0.body.body.9.argument.expressions.9.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.9.argument.expressions.9.callee"],
      exportName: "_regenerator",
      dependencies: {
        regeneratorDefine: ["body.0.body.body.1.body.body.1.argument.expressions.0.callee", "body.0.body.body.7.declarations.0.init.alternat\
e.expressions.0.callee", "body.0.body.body.8.body.body.0.argument.expressions.0.alternate.expressions.1.callee", "body.0.body.body.9.argumen\
t.expressions.1.callee", "body.0.body.body.9.argument.expressions.2.callee", "body.0.body.body.9.argument.expressions.4.callee", "body.0.bod\
y.body.9.argument.expressions.5.callee", "body.0.body.body.9.argument.expressions.6.callee", "body.0.body.body.9.argument.expressions.7.call\
ee", "body.0.body.body.9.argument.expressions.8.callee"]
      },
      internal: !1
    }),
    regeneratorAsync: J("7.27.0", "function _regeneratorAsync(n,e,r,t,o){var a=asyncGen(n,e,r,t,o);return a.next().then(function(n){return n\
.done?n.value:a.next()})}", {
      globals: [],
      locals: {
        _regeneratorAsync: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorAsync",
      dependencies: {
        regeneratorAsyncGen: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    regeneratorAsyncGen: J("7.27.0", "function _regeneratorAsyncGen(r,e,t,o,n){return new regeneratorAsyncIterator(regenerator().w(r,e,t,o),\
n||Promise)}", {
      globals: ["Promise"],
      locals: {
        _regeneratorAsyncGen: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorAsyncGen",
      dependencies: {
        regenerator: ["body.0.body.body.0.argument.arguments.0.callee.object.callee"],
        regeneratorAsyncIterator: ["body.0.body.body.0.argument.callee"]
      },
      internal: !1
    }),
    regeneratorAsyncIterator: J("7.27.0", 'function AsyncIterator(t,e){function n(r,o,i,f){try{var c=t[r](o),u=c.value;return u instanceof O\
verloadYield?e.resolve(u.v).then(function(t){n("next",t,i,f)},function(t){n("throw",t,i,f)}):e.resolve(u).then(function(t){c.value=t,i(c)},f\
unction(t){return n("throw",t,i,f)})}catch(t){f(t)}}var r;this.next||(define(AsyncIterator.prototype),define(AsyncIterator.prototype,"functi\
on"==typeof Symbol&&Symbol.asyncIterator||"@asyncIterator",function(){return this})),define(this,"_invoke",function(t,o,i){function f(){retu\
rn new e(function(e,r){n(t,i,e,r)})}return r=r?r.then(f,f):f()},!0)}', {
      globals: ["Symbol"],
      locals: {
        AsyncIterator: ["body.0.id", "body.0.body.body.2.expression.expressions.0.right.expressions.0.arguments.0.object", "body.0.body.body\
.2.expression.expressions.0.right.expressions.1.arguments.0.object"]
      },
      exportBindingAssignments: [],
      exportName: "AsyncIterator",
      dependencies: {
        OverloadYield: ["body.0.body.body.0.body.body.0.block.body.1.argument.test.right"],
        regeneratorDefine: ["body.0.body.body.2.expression.expressions.0.right.expressions.0.callee", "body.0.body.body.2.expression.express\
ions.0.right.expressions.1.callee", "body.0.body.body.2.expression.expressions.1.callee"]
      },
      internal: !0
    }),
    regeneratorDefine: J("7.27.0", 'function regeneratorDefine(e,r,n,t){var i=Object.defineProperty;try{i({},"",{})}catch(e){i=0}regenerator\
Define=function(e,r,n,t){function o(r,n){regeneratorDefine(e,r,function(e){return this._invoke(r,n,e)})}r?i?i(e,r,{value:n,enumerable:!t,con\
figurable:!t,writable:!t}):e[r]=n:(o("next",0),o("throw",1),o("return",2))},regeneratorDefine(e,r,n,t)}', {
      globals: ["Object"],
      locals: {
        regeneratorDefine: ["body.0.id", "body.0.body.body.2.expression.expressions.0.right.body.body.0.body.body.0.expression.callee", "bod\
y.0.body.body.2.expression.expressions.1.callee", "body.0.body.body.2.expression.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.2.expression.expressions.0"],
      exportName: "regeneratorDefine",
      dependencies: {},
      internal: !0
    }),
    regeneratorKeys: J("7.27.0", "function _regeneratorKeys(e){var n=Object(e),r=[];for(var t in n)r.unshift(t);return function e(){for(;r.l\
ength;)if((t=r.pop())in n)return e.value=t,e.done=!1,e;return e.done=!0,e}}", {
      globals: ["Object"],
      locals: {
        _regeneratorKeys: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorKeys",
      dependencies: {},
      internal: !1
    }),
    regeneratorValues: J("7.18.0", 'function _regeneratorValues(e){if(null!=e){var t=e["function"==typeof Symbol&&Symbol.iterator||"@@iterat\
or"],r=0;if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length))return{next:function(){return e&&r>=e.length&&(e=vo\
id 0),{value:e&&e[r++],done:!e}}}}throw new TypeError(typeof e+" is not iterable")}', {
      globals: ["Symbol", "isNaN", "TypeError"],
      locals: {
        _regeneratorValues: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorValues",
      dependencies: {},
      internal: !1
    }),
    set: J("7.0.0-beta.0", 'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=\
superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOw\
nPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}f\
unction _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}', {
      globals: ["Reflect", "Object", "TypeError"],
      locals: {
        set: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.0.test.left.argument.callee", "body.0.body.\
body.0.argument.expressions.0.left"],
        _set: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_set",
      dependencies: {
        superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"],
        defineProperty: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"]
      },
      internal: !1
    }),
    setFunctionName: J("7.23.6", 'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.definePr\
operty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}', {
      globals: ["Object"],
      locals: {
        setFunctionName: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "setFunctionName",
      dependencies: {},
      internal: !1
    }),
    setPrototypeOf: J("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind\
():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", {
      globals: ["Object"],
      locals: {
        _setPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_setPrototypeOf",
      dependencies: {},
      internal: !1
    }),
    skipFirstGeneratorNext: J("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.\
next(),r}}", {
      globals: [],
      locals: {
        _skipFirstGeneratorNext: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_skipFirstGeneratorNext",
      dependencies: {},
      internal: !1
    }),
    slicedToArray: J("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableT\
oArray(r,e)||nonIterableRest()}", {
      globals: [],
      locals: {
        _slicedToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_slicedToArray",
      dependencies: {
        arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArrayLimit: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
      },
      internal: !1
    }),
    superPropBase: J("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return \
t}", {
      globals: [],
      locals: {
        _superPropBase: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropBase",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.0.test.right.right.right.callee"]
      },
      internal: !1
    }),
    superPropGet: J("7.25.0", 'function _superPropGet(t,o,e,r){var p=get(getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==type\
of p?function(t){return p.apply(e,t)}:p}', {
      globals: [],
      locals: {
        _superPropGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropGet",
      dependencies: {
        get: ["body.0.body.body.0.declarations.0.init.callee"],
        getPrototypeOf: ["body.0.body.body.0.declarations.0.init.arguments.0.callee"]
      },
      internal: !1
    }),
    superPropSet: J("7.25.0", "function _superPropSet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}", {
      globals: [],
      locals: {
        _superPropSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropSet",
      dependencies: {
        set: ["body.0.body.body.0.argument.callee"],
        getPrototypeOf: ["body.0.body.body.0.argument.arguments.0.callee"]
      },
      internal: !1
    }),
    taggedTemplateLiteral: J("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.definePrope\
rties(e,{raw:{value:Object.freeze(t)}}))}", {
      globals: ["Object"],
      locals: {
        _taggedTemplateLiteral: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_taggedTemplateLiteral",
      dependencies: {},
      internal: !1
    }),
    taggedTemplateLiteralLoose: J("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", {
      globals: [],
      locals: {
        _taggedTemplateLiteralLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_taggedTemplateLiteralLoose",
      dependencies: {},
      internal: !1
    }),
    tdz: J("7.5.5", 'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}', {
      globals: ["ReferenceError"],
      locals: {
        _tdzError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_tdzError",
      dependencies: {},
      internal: !1
    }),
    temporalRef: J("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", {
      globals: [],
      locals: {
        _temporalRef: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_temporalRef",
      dependencies: {
        temporalUndefined: ["body.0.body.body.0.argument.test.right"],
        tdz: ["body.0.body.body.0.argument.consequent.callee"]
      },
      internal: !1
    }),
    temporalUndefined: J("7.0.0-beta.0", "function _temporalUndefined(){}", {
      globals: [],
      locals: {
        _temporalUndefined: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_temporalUndefined",
      dependencies: {},
      internal: !1
    }),
    toArray: J("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterabl\
eRest()}", {
      globals: [],
      locals: {
        _toArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toArray",
      dependencies: {
        arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
      },
      internal: !1
    }),
    toConsumableArray: J("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterabl\
eToArray(r)||nonIterableSpread()}", {
      globals: [],
      locals: {
        _toConsumableArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toConsumableArray",
      dependencies: {
        arrayWithoutHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableSpread: ["body.0.body.body.0.argument.right.callee"]
      },
      internal: !1
    }),
    toPrimitive: J("7.1.5", 'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e\
.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r\
?String:Number)(t)}', {
      globals: ["Symbol", "TypeError", "String", "Number"],
      locals: {
        toPrimitive: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "toPrimitive",
      dependencies: {},
      internal: !1
    }),
    toPropertyKey: J("7.1.5", 'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}', {
      globals: [],
      locals: {
        toPropertyKey: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "toPropertyKey",
      dependencies: {
        toPrimitive: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    toSetter: J("7.24.0", 'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,\
t.apply(n,e)}})}', {
      globals: ["Object"],
      locals: {
        _toSetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toSetter",
      dependencies: {},
      internal: !1
    }),
    tsRewriteRelativeImportExtensions: J("7.27.0", 'function tsRewriteRelativeImportExtensions(t,e){return"string"==typeof t&&/^\\.\\.?\\//.tes\
t(t)?t.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+)?)\\.([cm]?)ts$/i,function(t,s,r,n,o){return s?e?".jsx":".js":!r||n&&o?r+n+"."+o.toLowerCase(\
)+"js":t}):t}', {
      globals: [],
      locals: {
        tsRewriteRelativeImportExtensions: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "tsRewriteRelativeImportExtensions",
      dependencies: {},
      internal: !1
    }),
    typeof: J("7.0.0-beta.0", 'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symb\
ol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symb\
ol":typeof o},_typeof(o)}', {
      globals: ["Symbol"],
      locals: {
        _typeof: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_typeof",
      dependencies: {},
      internal: !1
    }),
    unsupportedIterableToArray: J("7.9.0", 'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,\
a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Argum\
ents"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}', {
      globals: ["Array"],
      locals: {
        _unsupportedIterableToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_unsupportedIterableToArray",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.body.0.consequent.argument.callee", "body.0.body.body.0.consequent.body.2.argument\
.expressions.1.alternate.consequent.callee"]
      },
      internal: !1
    }),
    usingCtx: J("7.23.9", 'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return \
n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using d\
eclarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispos\
e")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is not\
 disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}\
return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)re\
turn s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}c\
atch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n\
,next()}return next()}}}', {
      globals: ["SuppressedError", "Error", "Object", "TypeError", "Symbol", "Promise"],
      locals: {
        _usingCtx: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_usingCtx",
      dependencies: {},
      internal: !1
    }),
    wrapAsyncGenerator: J("7.0.0-beta.0", 'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,argument\
s))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:\
o).then(function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"norm\
al",t)},function(e){resume("throw",e)})}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0})\
;break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){r\
eturn new Promise(function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))})},"function"!=typeof e.re\
turn&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return th\
is},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke(\
"throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};', {
      globals: ["Promise", "Symbol"],
      locals: {
        _wrapAsyncGenerator: ["body.0.id"],
        AsyncGenerator: ["body.1.id", "body.0.body.body.0.argument.body.body.0.argument.callee", "body.2.expression.expressions.0.left.objec\
t.object", "body.2.expression.expressions.1.left.object.object", "body.2.expression.expressions.2.left.object.object", "body.2.expression.ex\
pressions.3.left.object.object"]
      },
      exportBindingAssignments: [],
      exportName: "_wrapAsyncGenerator",
      dependencies: {
        OverloadYield: ["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"]
      },
      internal: !1
    }),
    wrapNativeSuper: J("7.0.0-beta.0", 'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=fun\
ction(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a f\
unction");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).c\
onstructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setP\
rototypeOf(Wrapper,t)},_wrapNativeSuper(t)}', {
      globals: ["Map", "TypeError", "Object"],
      locals: {
        _wrapNativeSuper: ["body.0.id", "body.0.body.body.1.argument.expressions.1.callee", "body.0.body.body.1.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.expressions.0"],
      exportName: "_wrapNativeSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"],
        setPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"],
        isNativeFunction: ["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"],
        construct: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"]
      },
      internal: !1
    }),
    wrapRegExp: J("7.19.0", 'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=n\
ew WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildG\
roups(e,t){var p=r.get(t);return Object.keys(p).reduce(function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[\
o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r},Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function\
(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.pro\
totype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)(>|$\
)/g,function(e,r,t){if(""===t)return e;var p=o[r];return Array.isArray(p)?"$"+p.join("$"):"number"==typeof p?"$"+p:""}))}if("function"==type\
of p){var i=this;return e[Symbol.replace].call(this,t,function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).\
push(buildGroups(e,i)),p.apply(this,e)})}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}', {
      globals: ["RegExp", "WeakMap", "Object", "Symbol", "Array"],
      locals: {
        _wrapRegExp: ["body.0.id", "body.0.body.body.4.argument.expressions.3.callee.object", "body.0.body.body.0.expression.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.expression"],
      exportName: "_wrapRegExp",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.2.body.body.1.argument.expressions.1.callee"],
        inherits: ["body.0.body.body.4.argument.expressions.0.callee"]
      },
      internal: !1
    }),
    writeOnlyError: J("7.12.13", `function _writeOnlyError(r){throw new TypeError('"'+r+'" is write-only')}`, {
      globals: ["TypeError"],
      locals: {
        _writeOnlyError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_writeOnlyError",
      dependencies: {},
      internal: !1
    })
  };
  Object.assign(Q4e, {
    AwaitValue: J("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", {
      globals: [],
      locals: {
        _AwaitValue: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_AwaitValue",
      dependencies: {},
      internal: !1
    }),
    applyDecs: J("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"g\
etMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.pri\
vate;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_a\
ssertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.publ\
ic={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMa\
pToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.len\
gth;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.fro\
m(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadat\
a||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer\
"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;cas\
e 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isSta\
tic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,\
v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function\
(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v\
=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMeta\
dataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("fun\
ction"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!\
==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&o\
ld_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,\
"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError\
((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.ini\
t)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberD\
ec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set\
:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPrope\
rtyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_member\
Dec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f\
=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1\
===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)\
))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length\
;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.v\
alue=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push(function(e,t){return f.get.call(e,t)}),e.push(function(e,t){return f.set.call(e,t)})):\
2===o?e.push(f):e.push(function(e,t){return f.call(e,t)}):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,\
l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&\
&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error(\
"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not current\
ly supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pus\
hInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push(function(e){for(var a=0;a<t.length;a++)t[a].call(e\
);return e})}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Obj\
ect.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,\
c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,function(){for(var e=0;e<o.length;e++)o[e].call(i)})}}function\
 applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r\
,e,o,a),old_convertMetadataMapToFinal(e,o),r}', {
      globals: ["Object", "Map", "Symbol", "Array", "Error", "TypeError", "console"],
      locals: {
        old_createMetadataMethodsForProperty: ["body.0.id", "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee", "body\
.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"],
        old_convertMetadataMapToFinal: ["body.1.id", "body.13.body.body.1.argument.expressions.1.callee", "body.13.body.body.1.argument.expr\
essions.3.callee"],
        old_createAddInitializerMethod: ["body.2.id", "body.3.body.body.3.test.expressions.0.right.right.callee", "body.12.body.body.0.conse\
quent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"],
        old_memberDec: ["body.3.id", "body.9.body.body.1.consequent.expression.left.right.right.callee", "body.9.body.body.1.alternate.body.\
body.1.expression.left.right.right.callee"],
        old_assertNotFinished: ["body.4.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee", "\
body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee", "body.2.body.body.0.argument.body.body.0.expres\
sion.expressions.0.callee"],
        old_assertMetadataKey: ["body.5.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee", "\
body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"],
        old_assertCallable: ["body.6.id", "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee", "body.7.body.body.1.con\
sequent.body.1.expression.expressions.0.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee", "body.7\
.body.body.1.consequent.body.1.expression.expressions.2.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.\
callee"],
        old_assertValidReturnValue: ["body.7.id", "body.9.body.body.1.consequent.expression.right.expressions.0.callee", "body.9.body.body.1\
.alternate.body.body.1.expression.right.expressions.0.callee", "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressio\
ns.0.callee"],
        old_getInit: ["body.8.id", "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.ca\
llee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"],
        old_applyMemberDec: ["body.9.id", "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"],
        old_applyMemberDecs: ["body.10.id", "body.13.body.body.1.argument.expressions.0.callee"],
        old_pushInitializers: ["body.11.id", "body.10.body.body.1.expression.expressions.0.callee", "body.10.body.body.1.expression.expressi\
ons.1.callee"],
        old_applyClassDecs: ["body.12.id", "body.13.body.body.1.argument.expressions.2.callee"],
        applyDecs: ["body.13.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs",
      dependencies: {
        setFunctionName: ["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.9.body.bo\
dy.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      },
      internal: !1
    }),
    applyDecs2203: J("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e){if(\
e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function\
 memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";brea\
k;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),\
0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=funct\
ion(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return \
e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertVali\
dReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get\
, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.se\
t"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method\
")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:\
r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:\
2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0=\
==n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(\
h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&\
(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof\
 l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.pus\
h(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push(function(e,t){return u.get.call(\
e,t)}),e.push(function(e,t){return u.set.call(e,t)})):2===n?e.push(u):e.push(function(e,t){return u.call(e,t)}):Object.defineProperty(t,a,c)\
)}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e})}return function(e,t,r){var a=[];re\
turn function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,\
h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4=\
==g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/access\
or. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,\
f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--\
){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertVali\
dReturnValue(10,c),n=c)}e.push(n,function(){for(var e=0;e<a.length;e++)a[e].call(n)})}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs22\
03(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2203Factory: ["body.0.id", "body.2.body.body.0.argument.callee.right.right.callee"],
        applyDecs2203Impl: ["body.1.declarations.0.id", "body.2.body.body.0.argument.callee.right.left", "body.2.body.body.0.argument.callee\
.left"],
        applyDecs2203: ["body.2.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2203",
      dependencies: {},
      internal: !1
    }),
    applyDecs2203R: J("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e){i\
f(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}functi\
on memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";br\
eak;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitial\
izerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a\
&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{s\
et:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}fu\
nction assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return a\
n object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t\
.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===\
e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(\
0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunc\
tionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2==\
=a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a\
?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g\
],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(vo\
id 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l)\
{var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l\
)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push(function(e,t){return f.get.call(e,t\
)}),e.push(function(e,t){return f.set.call(e,t)})):2===a?e.push(f):e.push(function(e,t){return f.call(e,t)}):Object.defineProperty(t,n,c))}f\
unction applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],\
d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3==\
=g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public \
method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMembe\
rDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0\
;r<t.length;r++)t[r].call(e);return e})}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for\
(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r\
,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}\
function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2203RFactory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
        applyDecs2203R: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
      },
      exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
      exportName: "applyDecs2203R",
      dependencies: {
        setFunctionName: ["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "bo\
dy.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      },
      internal: !1
    }),
    applyDecs2301: J("7.21.0", 'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e){if(\
e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function\
 assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n\
,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="fie\
ld"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)\
),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){r\
eturn assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(\
c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():func\
tion(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCall\
able(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e)\
{if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void\
 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init\
,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or \
void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0=\
==a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="se\
t"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropert\
yDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,\
n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m\
=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.\
get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)\
l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}el\
se{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set\
=p),s?1===a?(e.push(function(e,t){return p.get.call(e,t)}),e.push(function(e,t){return p.set.call(e,t)})):2===a?e.push(p):e.push(function(e,\
t){return p.call(e,t)}):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;\
u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){re\
turn checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)\
throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is\
 not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}\
}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0;r<t.length;r++)t[r].c\
all(e);return e})}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.\
name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=\
!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs\
2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2301Factory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
        applyDecs2301: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
      },
      exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
      exportName: "applyDecs2301",
      dependencies: {
        checkInRHS: ["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.b\
ody.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "bo\
dy.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      },
      internal: !1
    }),
    applyDecs2305: J("7.21.0", 'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}fu\
nction c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeEr\
ror(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))\
throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var \
w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName(function(){return g(this)},n,"get"),set:function(e){t[4](this,\
e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D\
=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,\
t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I\
)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.\
value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={\
has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&\
&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P\
)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+\
" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push(function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(\
e,t);return t}),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t\
){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length\
>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(\
t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){v\
ar d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw E\
rror("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not cu\
rrently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h)\
,d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&\
[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}', {
      globals: ["TypeError", "Array", "Object", "Error", "Symbol", "Map"],
      locals: {
        applyDecs2305: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2305",
      dependencies: {
        checkInRHS: ["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.\
0.value.callee", "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"],
        toPropertyKey: ["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alte\
rnate.callee"]
      },
      internal: !1
    }),
    classApplyDescriptorDestructureSet: J("7.13.10", 'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.\
__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");retu\
rn t}', {
      globals: ["TypeError"],
      locals: {
        _classApplyDescriptorDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorDestructureSet",
      dependencies: {},
      internal: !1
    }),
    classApplyDescriptorGet: J("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", {
      globals: [],
      locals: {
        _classApplyDescriptorGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorGet",
      dependencies: {},
      internal: !1
    }),
    classApplyDescriptorSet: J("7.13.10", 'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new T\
ypeError("attempted to set read only private field");t.value=l}}', {
      globals: ["TypeError"],
      locals: {
        _classApplyDescriptorSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorSet",
      dependencies: {},
      internal: !1
    }),
    classCheckPrivateStaticAccess: J("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", {
      globals: [],
      locals: {
        _classCheckPrivateStaticAccess: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCheckPrivateStaticAccess",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.callee"]
      },
      internal: !1
    }),
    classCheckPrivateStaticFieldDescriptor: J("7.13.10", 'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new Type\
Error("attempted to "+e+" private static field before its declaration")}', {
      globals: ["TypeError"],
      locals: {
        _classCheckPrivateStaticFieldDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCheckPrivateStaticFieldDescriptor",
      dependencies: {},
      internal: !1
    }),
    classExtractFieldDescriptor: J("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", {
      globals: [],
      locals: {
        _classExtractFieldDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classExtractFieldDescriptor",
      dependencies: {
        classPrivateFieldGet2: ["body.0.body.body.0.argument.callee"]
      },
      internal: !1
    }),
    classPrivateFieldDestructureSet: J("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return clas\
sApplyDescriptorDestructureSet(e,r)}", {
      globals: [],
      locals: {
        _classPrivateFieldDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldDestructureSet",
      dependencies: {
        classApplyDescriptorDestructureSet: ["body.0.body.body.1.argument.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    classPrivateFieldGet: J("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescripto\
rGet(e,r)}", {
      globals: [],
      locals: {
        _classPrivateFieldGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldGet",
      dependencies: {
        classApplyDescriptorGet: ["body.0.body.body.1.argument.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    classPrivateFieldSet: J("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescrip\
torSet(e,s,r),r}", {
      globals: [],
      locals: {
        _classPrivateFieldSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldSet",
      dependencies: {
        classApplyDescriptorSet: ["body.0.body.body.1.argument.expressions.0.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    classPrivateMethodGet: J("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", {
      globals: [],
      locals: {
        _classPrivateMethodGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodGet",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
      },
      internal: !1
    }),
    classPrivateMethodSet: J("7.1.6", 'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}', {
      globals: ["TypeError"],
      locals: {
        _classPrivateMethodSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodSet",
      dependencies: {},
      internal: !1
    }),
    classStaticPrivateFieldDestructureSet: J("7.13.10", 'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t)\
,classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldDestructureSet",
      dependencies: {
        classApplyDescriptorDestructureSet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      },
      internal: !1
    }),
    classStaticPrivateFieldSpecGet: J("7.0.2", 'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPriva\
teStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldSpecGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldSpecGet",
      dependencies: {
        classApplyDescriptorGet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      },
      internal: !1
    }),
    classStaticPrivateFieldSpecSet: J("7.0.2", 'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPri\
vateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldSpecSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldSpecSet",
      dependencies: {
        classApplyDescriptorSet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      },
      internal: !1
    }),
    classStaticPrivateMethodSet: J("7.3.2", 'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static \
private field")}', {
      globals: ["TypeError"],
      locals: {
        _classStaticPrivateMethodSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateMethodSet",
      dependencies: {},
      internal: !1
    }),
    defineEnumerableProperties: J("7.0.0-beta.0", 'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enu\
merable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(\
r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}',
    {
      globals: ["Object"],
      locals: {
        _defineEnumerableProperties: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineEnumerableProperties",
      dependencies: {},
      internal: !1
    }),
    dispose: J("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=Suppressed\
Error:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Obje\
ct.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}funct\
ion _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch\
(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}', {
      globals: ["SuppressedError", "Error", "Object", "Promise"],
      locals: {
        dispose_SuppressedError: ["body.0.id", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object", "body.0.body\
.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value", "body.0.body.body.0.argumen\
t.expressions.1.callee", "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee", "body.0.body.body.0.argument.expre\
ssions.0.consequent.left", "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"],
        _dispose: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_dispose",
      dependencies: {},
      internal: !1
    }),
    objectSpread: J("7.0.0-beta.0", 'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments\
[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter(function(e){\
return Object.getOwnPropertyDescriptor(t,e).enumerable})),o.forEach(function(r){defineProperty(e,r,t[r])})}return e}', {
      globals: ["Object"],
      locals: {
        _objectSpread: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectSpread",
      dependencies: {
        defineProperty: ["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"]
      },
      internal: !1
    }),
    regeneratorRuntime: J("7.18.0", 'function _regeneratorRuntime(){"use strict";var r=regenerator(),e=r.m(_regeneratorRuntime),t=(Object.ge\
tPrototypeOf?Object.getPrototypeOf(e):e.__proto__).constructor;function n(r){var e="function"==typeof r&&r.constructor;return!!e&&(e===t||"G\
eneratorFunction"===(e.displayName||e.name))}var o={throw:1,return:2,break:3,continue:3};function a(r){var e,t;return function(n){e||(e={sto\
p:function(){return t(n.a,2)},catch:function(){return n.v},abrupt:function(r,e){return t(n.a,o[r],e)},delegateYield:function(r,o,a){return e\
.resultName=o,t(n.d,values(r),a)},finish:function(r){return t(n.f,r)}},t=function(r,t,o){n.p=e.prev,n.n=e.next;try{return r(t,o)}finally{e.n\
ext=n.n}}),e.resultName&&(e[e.resultName]=n.v,e.resultName=void 0),e.sent=n.v,e.next=n.n;try{return r.call(this,e)}finally{n.p=e.prev,n.n=e.\
next}}}return(_regeneratorRuntime=function(){return{wrap:function(e,t,n,o){return r.w(a(e),t,n,o&&o.reverse())},isGeneratorFunction:n,mark:r\
.m,awrap:function(r,e){return new OverloadYield(r,e)},AsyncIterator:AsyncIterator,async:function(r,e,t,o,u){return(n(e)?asyncGen:async)(a(r)\
,e,t,o,u)},keys:keys,values:values}})()}', {
      globals: ["Object"],
      locals: {
        _regeneratorRuntime: ["body.0.id", "body.0.body.body.0.declarations.1.init.arguments.0", "body.0.body.body.4.argument.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.4.argument.callee"],
      exportName: "_regeneratorRuntime",
      dependencies: {
        OverloadYield: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.3.value.body.body.0.argument.callee"],
        regenerator: ["body.0.body.body.0.declarations.0.init.callee"],
        regeneratorAsync: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.5.value.body.body.0.argument.callee.alt\
ernate"],
        regeneratorAsyncGen: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.5.value.body.body.0.argument.callee.\
consequent"],
        regeneratorAsyncIterator: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.4.value"],
        regeneratorKeys: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.6.value"],
        regeneratorValues: ["body.0.body.body.3.body.body.1.argument.body.body.0.expression.expressions.0.right.expressions.0.right.properti\
es.3.value.body.body.0.argument.expressions.1.arguments.1.callee", "body.0.body.body.4.argument.callee.right.body.body.0.argument.properties\
.7.value"]
      },
      internal: !1
    }),
    using: J("7.22.0", 'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used\
 with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol\
.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.p\
ush({v:n,d:r,a:e}),n}', {
      globals: ["Object", "TypeError", "Symbol"],
      locals: {
        _using: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_using",
      dependencies: {},
      internal: !1
    })
  });
});

// ../node_modules/@babel/helpers/lib/index.js
var aC = E((ms) => {
  "use strict";
  Object.defineProperty(ms, "__esModule", {
    value: !0
  });
  ms.default = void 0;
  ms.get = VL;
  ms.getDependencies = s8e;
  ms.isInternal = n8e;
  ms.list = void 0;
  ms.minVersion = i8e;
  var e8e = Pe(), nC = UL(), {
    cloneNode: t8e,
    identifier: $L
  } = e8e;
  function oy(e, t, r) {
    try {
      let i = t.split("."), s = i.shift();
      for (; i.length > 0; )
        e = e[s], s = i.shift();
      if (arguments.length > 2)
        e[s] = r;
      else
        return e[s];
    } catch (i) {
      throw i.message += ` (when accessing ${t})`, i;
    }
  }
  n(oy, "deep");
  function r8e(e, t, r, i, s, a) {
    let {
      locals: o,
      dependencies: u,
      exportBindingAssignments: l,
      exportName: c
    } = t, f = new Set(i || []);
    r && f.add(r);
    for (let [m, h] of (Object.entries || ((d) => Object.keys(d).map((y) => [y, d[y]])))(o)) {
      let d = m;
      if (r && m === c)
        d = r;
      else
        for (; f.has(d); ) d = "_" + d;
      if (d !== m)
        for (let y of h)
          oy(e, y, $L(d));
    }
    for (let [m, h] of (Object.entries || ((d) => Object.keys(d).map((y) => [y, d[y]])))(u)) {
      let d = typeof s == "function" && s(m) || $L(m);
      for (let y of h)
        oy(e, y, t8e(d));
    }
    a?.(e, c, (m) => {
      l.forEach((h) => oy(e, h, m(oy(e, h))));
    });
  }
  n(r8e, "permuteHelperAST");
  var sC = /* @__PURE__ */ Object.create(null);
  function uy(e) {
    if (!sC[e]) {
      let t = nC.default[e];
      if (!t)
        throw Object.assign(new ReferenceError(`Unknown helper ${e}`), {
          code: "BABEL_HELPER_UNKNOWN",
          helper: e
        });
      sC[e] = {
        minVersion: t.minVersion,
        build(r, i, s, a) {
          let o = t.ast();
          return r8e(o, t.metadata, i, s, r, a), {
            nodes: o.body,
            globals: t.metadata.globals
          };
        },
        getDependencies() {
          return Object.keys(t.metadata.dependencies);
        }
      };
    }
    return sC[e];
  }
  n(uy, "loadHelper");
  function VL(e, t, r, i, s) {
    if (typeof r == "object") {
      let a = r;
      a?.type === "Identifier" ? r = a.name : r = void 0;
    }
    return uy(e).build(t, r, i, s);
  }
  n(VL, "get");
  function i8e(e) {
    return uy(e).minVersion;
  }
  n(i8e, "minVersion");
  function s8e(e) {
    return uy(e).getDependencies();
  }
  n(s8e, "getDependencies");
  function n8e(e) {
    var t;
    return (t = nC.default[e]) == null ? void 0 : t.metadata.internal;
  }
  n(n8e, "isInternal");
  ms.ensure = (e) => {
    uy(e);
  };
  var _yt = ms.list = Object.keys(nC.default).map((e) => e.replace(/^_/, "")), Pyt = ms.default = VL;
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var oC = E((Ye) => {
  "use strict";
  Object.defineProperty(Ye, "__esModule", {
    value: !0
  });
  Ye.Var = Ye.User = Ye.Statement = Ye.SpreadProperty = Ye.Scope = Ye.RestProperty = Ye.ReferencedMemberExpression = Ye.ReferencedIdentifier =
  Ye.Referenced = Ye.Pure = Ye.NumericLiteralTypeAnnotation = Ye.Generated = Ye.ForAwaitStatement = Ye.Flow = Ye.Expression = Ye.ExistentialTypeParam =
  Ye.BlockScoped = Ye.BindingIdentifier = void 0;
  var Oyt = Ye.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], kyt = Ye.ReferencedMemberExpression = ["MemberExpression"], Byt = Ye.
  BindingIdentifier = ["Identifier"], Nyt = Ye.Statement = ["Statement"], Myt = Ye.Expression = ["Expression"], Ryt = Ye.Scope = ["Scopable",
  "Pattern"], Lyt = Ye.Referenced = null, jyt = Ye.BlockScoped = ["FunctionDeclaration", "ClassDeclaration", "VariableDeclaration"], qyt = Ye.
  Var = ["VariableDeclaration"], Uyt = Ye.User = null, $yt = Ye.Generated = null, Vyt = Ye.Pure = null, Wyt = Ye.Flow = ["Flow", "ImportDecl\
aration", "ExportDeclaration", "ImportSpecifier"], Hyt = Ye.RestProperty = ["RestElement"], Kyt = Ye.SpreadProperty = ["RestElement"], zyt = Ye.
  ExistentialTypeParam = ["ExistsTypeAnnotation"], Jyt = Ye.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"], Xyt = Ye.ForAwaitStatement =
  ["ForOfStatement"];
});

// ../node_modules/ms/index.js
var HL = E((Gyt, WL) => {
  var Kl = 1e3, zl = Kl * 60, Jl = zl * 60, Ko = Jl * 24, a8e = Ko * 7, o8e = Ko * 365.25;
  WL.exports = function(e, t) {
    t = t || {};
    var r = typeof e;
    if (r === "string" && e.length > 0)
      return u8e(e);
    if (r === "number" && isFinite(e))
      return t.long ? c8e(e) : l8e(e);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(e)
    );
  };
  function u8e(e) {
    if (e = String(e), !(e.length > 100)) {
      var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.
      exec(
        e
      );
      if (t) {
        var r = parseFloat(t[1]), i = (t[2] || "ms").toLowerCase();
        switch (i) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * o8e;
          case "weeks":
          case "week":
          case "w":
            return r * a8e;
          case "days":
          case "day":
          case "d":
            return r * Ko;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * Jl;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * zl;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * Kl;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r;
          default:
            return;
        }
      }
    }
  }
  n(u8e, "parse");
  function l8e(e) {
    var t = Math.abs(e);
    return t >= Ko ? Math.round(e / Ko) + "d" : t >= Jl ? Math.round(e / Jl) + "h" : t >= zl ? Math.round(e / zl) + "m" : t >= Kl ? Math.round(
    e / Kl) + "s" : e + "ms";
  }
  n(l8e, "fmtShort");
  function c8e(e) {
    var t = Math.abs(e);
    return t >= Ko ? ly(e, t, Ko, "day") : t >= Jl ? ly(e, t, Jl, "hour") : t >= zl ? ly(e, t, zl, "minute") : t >= Kl ? ly(e, t, Kl, "secon\
d") : e + " ms";
  }
  n(c8e, "fmtLong");
  function ly(e, t, r, i) {
    var s = t >= r * 1.5;
    return Math.round(e / r) + " " + i + (s ? "s" : "");
  }
  n(ly, "plural");
});

// ../node_modules/debug/src/common.js
var uC = E((Qyt, KL) => {
  function f8e(e) {
    r.debug = r, r.default = r, r.coerce = l, r.disable = o, r.enable = s, r.enabled = u, r.humanize = HL(), r.destroy = c, Object.keys(e).forEach(
    (f) => {
      r[f] = e[f];
    }), r.names = [], r.skips = [], r.formatters = {};
    function t(f) {
      let m = 0;
      for (let h = 0; h < f.length; h++)
        m = (m << 5) - m + f.charCodeAt(h), m |= 0;
      return r.colors[Math.abs(m) % r.colors.length];
    }
    n(t, "selectColor"), r.selectColor = t;
    function r(f) {
      let m, h = null, d, y;
      function p(...g) {
        if (!p.enabled)
          return;
        let b = p, D = Number(/* @__PURE__ */ new Date()), x = D - (m || D);
        b.diff = x, b.prev = m, b.curr = D, m = D, g[0] = r.coerce(g[0]), typeof g[0] != "string" && g.unshift("%O");
        let T = 0;
        g[0] = g[0].replace(/%([a-zA-Z%])/g, (B, k) => {
          if (B === "%%")
            return "%";
          T++;
          let q = r.formatters[k];
          if (typeof q == "function") {
            let V = g[T];
            B = q.call(b, V), g.splice(T, 1), T--;
          }
          return B;
        }), r.formatArgs.call(b, g), (b.log || r.log).apply(b, g);
      }
      return n(p, "debug"), p.namespace = f, p.useColors = r.useColors(), p.color = r.selectColor(f), p.extend = i, p.destroy = r.destroy, Object.
      defineProperty(p, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: /* @__PURE__ */ n(() => h !== null ? h : (d !== r.namespaces && (d = r.namespaces, y = r.enabled(f)), y), "get"),
        set: /* @__PURE__ */ n((g) => {
          h = g;
        }, "set")
      }), typeof r.init == "function" && r.init(p), p;
    }
    n(r, "createDebug");
    function i(f, m) {
      let h = r(this.namespace + (typeof m > "u" ? ":" : m) + f);
      return h.log = this.log, h;
    }
    n(i, "extend");
    function s(f) {
      r.save(f), r.namespaces = f, r.names = [], r.skips = [];
      let m = (typeof f == "string" ? f : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (let h of m)
        h[0] === "-" ? r.skips.push(h.slice(1)) : r.names.push(h);
    }
    n(s, "enable");
    function a(f, m) {
      let h = 0, d = 0, y = -1, p = 0;
      for (; h < f.length; )
        if (d < m.length && (m[d] === f[h] || m[d] === "*"))
          m[d] === "*" ? (y = d, p = h, d++) : (h++, d++);
        else if (y !== -1)
          d = y + 1, p++, h = p;
        else
          return !1;
      for (; d < m.length && m[d] === "*"; )
        d++;
      return d === m.length;
    }
    n(a, "matchesTemplate");
    function o() {
      let f = [
        ...r.names,
        ...r.skips.map((m) => "-" + m)
      ].join(",");
      return r.enable(""), f;
    }
    n(o, "disable");
    function u(f) {
      for (let m of r.skips)
        if (a(f, m))
          return !1;
      for (let m of r.names)
        if (a(f, m))
          return !0;
      return !1;
    }
    n(u, "enabled");
    function l(f) {
      return f instanceof Error ? f.stack || f.message : f;
    }
    n(l, "coerce");
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major versio\
n of `debug`.");
    }
    return n(c, "destroy"), r.enable(r.load()), r;
  }
  n(f8e, "setup");
  KL.exports = f8e;
});

// ../node_modules/debug/src/browser.js
var zL = E((yi, cy) => {
  yi.formatArgs = p8e;
  yi.save = h8e;
  yi.load = m8e;
  yi.useColors = d8e;
  yi.storage = y8e();
  yi.destroy = /* @__PURE__ */ (() => {
    let e = !1;
    return () => {
      e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the nex\
t major version of `debug`."));
    };
  })();
  yi.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function d8e() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let e;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
    // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(e[1], 10) >=
    31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  n(d8e, "useColors");
  function p8e(e) {
    if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" +
    cy.exports.humanize(this.diff), !this.useColors)
      return;
    let t = "color: " + this.color;
    e.splice(1, 0, t, "color: inherit");
    let r = 0, i = 0;
    e[0].replace(/%[a-zA-Z%]/g, (s) => {
      s !== "%%" && (r++, s === "%c" && (i = r));
    }), e.splice(i, 0, t);
  }
  n(p8e, "formatArgs");
  yi.log = console.debug || console.log || (() => {
  });
  function h8e(e) {
    try {
      e ? yi.storage.setItem("debug", e) : yi.storage.removeItem("debug");
    } catch {
    }
  }
  n(h8e, "save");
  function m8e() {
    let e;
    try {
      e = yi.storage.getItem("debug") || yi.storage.getItem("DEBUG");
    } catch {
    }
    return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e;
  }
  n(m8e, "load");
  function y8e() {
    try {
      return localStorage;
    } catch {
    }
  }
  n(y8e, "localstorage");
  cy.exports = uC()(yi);
  var { formatters: g8e } = cy.exports;
  g8e.j = function(e) {
    try {
      return JSON.stringify(e);
    } catch (t) {
      return "[UnexpectedJSONParseError]: " + t.message;
    }
  };
});

// ../node_modules/has-flag/index.js
var XL = E((r1t, JL) => {
  "use strict";
  JL.exports = (e, t = process.argv) => {
    let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", i = t.indexOf(r + e), s = t.indexOf("--");
    return i !== -1 && (s === -1 || i < s);
  };
});

// ../node_modules/supports-color/index.js
var ZL = E((i1t, GL) => {
  "use strict";
  var b8e = require("os"), YL = require("tty"), Ki = XL(), { env: br } = process, Ra;
  Ki("no-color") || Ki("no-colors") || Ki("color=false") || Ki("color=never") ? Ra = 0 : (Ki("color") || Ki("colors") || Ki("color=true") ||
  Ki("color=always")) && (Ra = 1);
  "FORCE_COLOR" in br && (br.FORCE_COLOR === "true" ? Ra = 1 : br.FORCE_COLOR === "false" ? Ra = 0 : Ra = br.FORCE_COLOR.length === 0 ? 1 : Math.
  min(parseInt(br.FORCE_COLOR, 10), 3));
  function lC(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  n(lC, "translateLevel");
  function cC(e, t) {
    if (Ra === 0)
      return 0;
    if (Ki("color=16m") || Ki("color=full") || Ki("color=truecolor"))
      return 3;
    if (Ki("color=256"))
      return 2;
    if (e && !t && Ra === void 0)
      return 0;
    let r = Ra || 0;
    if (br.TERM === "dumb")
      return r;
    if (process.platform === "win32") {
      let i = b8e.release().split(".");
      return Number(i[0]) >= 10 && Number(i[2]) >= 10586 ? Number(i[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in br)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((i) => i in br) || br.CI_NAME === "codeship" ?
      1 : r;
    if ("TEAMCITY_VERSION" in br)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(br.TEAMCITY_VERSION) ? 1 : 0;
    if (br.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in br) {
      let i = parseInt((br.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (br.TERM_PROGRAM) {
        case "iTerm.app":
          return i >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(br.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(br.TERM) || "COLORTERM" in
    br ? 1 : r;
  }
  n(cC, "supportsColor");
  function D8e(e) {
    let t = cC(e, e && e.isTTY);
    return lC(t);
  }
  n(D8e, "getSupportLevel");
  GL.exports = {
    supportsColor: D8e,
    stdout: lC(cC(!0, YL.isatty(1))),
    stderr: lC(cC(!0, YL.isatty(2)))
  };
});

// ../node_modules/debug/src/node.js
var ej = E((Dr, dy) => {
  var v8e = require("tty"), fy = require("util");
  Dr.init = A8e;
  Dr.log = T8e;
  Dr.formatArgs = E8e;
  Dr.save = C8e;
  Dr.load = w8e;
  Dr.useColors = x8e;
  Dr.destroy = fy.deprecate(
    () => {
    },
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
  );
  Dr.colors = [6, 2, 3, 4, 5, 1];
  try {
    let e = ZL();
    e && (e.stderr || e).level >= 2 && (Dr.colors = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      128,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ]);
  } catch {
  }
  Dr.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, t) => {
    let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (s, a) => a.toUpperCase()), i = process.env[t];
    return /^(yes|on|true|enabled)$/i.test(i) ? i = !0 : /^(no|off|false|disabled)$/i.test(i) ? i = !1 : i === "null" ? i = null : i = Number(
    i), e[r] = i, e;
  }, {});
  function x8e() {
    return "colors" in Dr.inspectOpts ? !!Dr.inspectOpts.colors : v8e.isatty(process.stderr.fd);
  }
  n(x8e, "useColors");
  function E8e(e) {
    let { namespace: t, useColors: r } = this;
    if (r) {
      let i = this.color, s = "\x1B[3" + (i < 8 ? i : "8;5;" + i), a = `  ${s};1m${t} \x1B[0m`;
      e[0] = a + e[0].split(`
`).join(`
` + a), e.push(s + "m+" + dy.exports.humanize(this.diff) + "\x1B[0m");
    } else
      e[0] = S8e() + t + " " + e[0];
  }
  n(E8e, "formatArgs");
  function S8e() {
    return Dr.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  n(S8e, "getDate");
  function T8e(...e) {
    return process.stderr.write(fy.formatWithOptions(Dr.inspectOpts, ...e) + `
`);
  }
  n(T8e, "log");
  function C8e(e) {
    e ? process.env.DEBUG = e : delete process.env.DEBUG;
  }
  n(C8e, "save");
  function w8e() {
    return process.env.DEBUG;
  }
  n(w8e, "load");
  function A8e(e) {
    e.inspectOpts = {};
    let t = Object.keys(Dr.inspectOpts);
    for (let r = 0; r < t.length; r++)
      e.inspectOpts[t[r]] = Dr.inspectOpts[t[r]];
  }
  n(A8e, "init");
  dy.exports = uC()(Dr);
  var { formatters: QL } = dy.exports;
  QL.o = function(e) {
    return this.inspectOpts.colors = this.useColors, fy.inspect(e, this.inspectOpts).split(`
`).map((t) => t.trim()).join(" ");
  };
  QL.O = function(e) {
    return this.inspectOpts.colors = this.useColors, fy.inspect(e, this.inspectOpts);
  };
});

// ../node_modules/debug/src/index.js
var zo = E((a1t, fC) => {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? fC.exports = zL() : fC.exports = ej();
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var dC = E((cr) => {
  "use strict";
  Object.defineProperty(cr, "__esModule", {
    value: !0
  });
  cr.isBindingIdentifier = Y8e;
  cr.isBlockScoped = tFe;
  cr.isExpression = Z8e;
  cr.isFlow = aFe;
  cr.isForAwaitStatement = lFe;
  cr.isGenerated = sFe;
  cr.isPure = nFe;
  cr.isReferenced = eFe;
  cr.isReferencedIdentifier = J8e;
  cr.isReferencedMemberExpression = X8e;
  cr.isRestProperty = oFe;
  cr.isScope = Q8e;
  cr.isSpreadProperty = uFe;
  cr.isStatement = G8e;
  cr.isUser = iFe;
  cr.isVar = rFe;
  var _8e = Pe(), {
    isBinding: P8e,
    isBlockScoped: F8e,
    isExportDeclaration: I8e,
    isExpression: O8e,
    isFlow: k8e,
    isForStatement: B8e,
    isForXStatement: N8e,
    isIdentifier: tj,
    isImportDeclaration: M8e,
    isImportSpecifier: R8e,
    isJSXIdentifier: L8e,
    isJSXMemberExpression: j8e,
    isMemberExpression: q8e,
    isRestElement: rj,
    isReferenced: py,
    isScope: U8e,
    isStatement: $8e,
    isVar: V8e,
    isVariableDeclaration: W8e,
    react: H8e,
    isForOfStatement: K8e
  } = _8e, {
    isCompatTag: z8e
  } = H8e;
  function J8e(e) {
    let {
      node: t,
      parent: r
    } = this;
    return tj(t, e) ? py(t, r, this.parentPath.parent) : L8e(t, e) ? !j8e(r) && z8e(t.name) ? !1 : py(t, r, this.parentPath.parent) : !1;
  }
  n(J8e, "isReferencedIdentifier");
  function X8e() {
    let {
      node: e,
      parent: t
    } = this;
    return q8e(e) && py(e, t);
  }
  n(X8e, "isReferencedMemberExpression");
  function Y8e() {
    let {
      node: e,
      parent: t
    } = this, r = this.parentPath.parent;
    return tj(e) && P8e(e, t, r);
  }
  n(Y8e, "isBindingIdentifier");
  function G8e() {
    let {
      node: e,
      parent: t
    } = this;
    return $8e(e) ? !(W8e(e) && (N8e(t, {
      left: e
    }) || B8e(t, {
      init: e
    }))) : !1;
  }
  n(G8e, "isStatement");
  function Z8e() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : O8e(this.node);
  }
  n(Z8e, "isExpression");
  function Q8e() {
    return U8e(this.node, this.parent);
  }
  n(Q8e, "isScope");
  function eFe() {
    return py(this.node, this.parent);
  }
  n(eFe, "isReferenced");
  function tFe() {
    return F8e(this.node);
  }
  n(tFe, "isBlockScoped");
  function rFe() {
    return V8e(this.node);
  }
  n(rFe, "isVar");
  function iFe() {
    var e;
    return !!((e = this.node) != null && e.loc);
  }
  n(iFe, "isUser");
  function sFe() {
    return !this.isUser();
  }
  n(sFe, "isGenerated");
  function nFe(e) {
    return this.scope.isPure(this.node, e);
  }
  n(nFe, "isPure");
  function aFe() {
    let {
      node: e
    } = this;
    return k8e(e) ? !0 : M8e(e) ? e.importKind === "type" || e.importKind === "typeof" : I8e(e) ? e.exportKind === "type" : R8e(e) ? e.importKind ===
    "type" || e.importKind === "typeof" : !1;
  }
  n(aFe, "isFlow");
  function oFe() {
    var e;
    return rj(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectPattern());
  }
  n(oFe, "isRestProperty");
  function uFe() {
    var e;
    return rj(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectExpression());
  }
  n(uFe, "isSpreadProperty");
  function lFe() {
    return K8e(this.node, {
      await: !0
    });
  }
  n(lFe, "isForAwaitStatement");
  cr.isExistentialTypeParam = /* @__PURE__ */ n(function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, "isExistentialTypeParam"), cr.isNumericLiteralTypeAnnotation = /* @__PURE__ */ n(function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, "isNumericLiteralTypeAnnotation");
});

// ../node_modules/@babel/traverse/lib/visitors.js
var Xd = E((Xo) => {
  "use strict";
  Object.defineProperty(Xo, "__esModule", {
    value: !0
  });
  Xo.environmentVisitor = gFe;
  Xo.explode = pj;
  Xo.isExplodedVisitor = dj;
  Xo.merge = mj;
  Xo.verify = hj;
  var fj = oC(), cFe = dC(), fFe = Pe(), ij = zi(), {
    DEPRECATED_KEYS: sj,
    DEPRECATED_ALIASES: nj,
    FLIPPED_ALIAS_KEYS: aj,
    TYPES: dFe,
    __internal__deprecationWarning: oj
  } = fFe;
  function pFe(e) {
    return e in fj;
  }
  n(pFe, "isVirtualType");
  function dj(e) {
    return e?._exploded;
  }
  n(dj, "isExplodedVisitor");
  function pj(e) {
    if (dj(e)) return e;
    e._exploded = !0;
    for (let r of Object.keys(e)) {
      if (Jo(r)) continue;
      let i = r.split("|");
      if (i.length === 1) continue;
      let s = e[r];
      delete e[r];
      for (let a of i)
        e[a] = s;
    }
    hj(e), delete e.__esModule, hFe(e), cj(e);
    for (let r of Object.keys(e)) {
      if (Jo(r) || !pFe(r)) continue;
      let i = e[r];
      for (let a of Object.keys(i))
        i[a] = mFe(r, i[a]);
      delete e[r];
      let s = fj[r];
      if (s !== null)
        for (let a of s) {
          var t;
          (t = e[a]) != null || (e[a] = {}), Jd(e[a], i);
        }
      else
        Jd(e, i);
    }
    for (let r of Object.keys(e)) {
      if (Jo(r)) continue;
      let i = aj[r];
      if (r in sj) {
        let a = sj[r];
        oj(r, a, "Visitor "), i = [a];
      } else if (r in nj) {
        let a = nj[r];
        oj(r, a, "Visitor "), i = aj[a];
      }
      if (!i) continue;
      let s = e[r];
      delete e[r];
      for (let a of i) {
        let o = e[a];
        o ? Jd(o, s) : e[a] = Object.assign({}, s);
      }
    }
    for (let r of Object.keys(e))
      Jo(r) || cj(e[r]);
    return e;
  }
  n(pj, "explode$1");
  function hj(e) {
    if (!e._verified) {
      if (typeof e == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Functi\
on }`?");
      for (let t of Object.keys(e)) {
        if ((t === "enter" || t === "exit") && uj(t, e[t]), Jo(t)) continue;
        if (!dFe.includes(t))
          throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type in @babel/traverse 7.28.5`);
        let r = e[t];
        if (typeof r == "object")
          for (let i of Object.keys(r))
            if (i === "enter" || i === "exit")
              uj(`${t}.${i}`, r[i]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${i}`);
      }
      e._verified = !0;
    }
  }
  n(hj, "verify$1");
  function uj(e, t) {
    let r = [].concat(t);
    for (let i of r)
      if (typeof i != "function")
        throw new TypeError(`Non-function found defined in ${e} with type ${typeof i}`);
  }
  n(uj, "validateVisitorMethods");
  function mj(e, t = [], r) {
    let i = {
      _verified: !0,
      _exploded: !0
    };
    Object.defineProperty(i, "_exploded", {
      enumerable: !1
    }), Object.defineProperty(i, "_verified", {
      enumerable: !1
    });
    for (let s = 0; s < e.length; s++) {
      let a = pj(e[s]), o = t[s], u = a;
      (o || r) && (u = lj(u, o, r)), Jd(i, u);
      for (let l of Object.keys(a)) {
        if (Jo(l)) continue;
        let c = a[l];
        (o || r) && (c = lj(c, o, r));
        let f = i[l] || (i[l] = {});
        Jd(f, c);
      }
    }
    return i;
  }
  n(mj, "merge");
  function lj(e, t, r) {
    let i = {};
    for (let s of ["enter", "exit"]) {
      let a = e[s];
      Array.isArray(a) && (a = a.map(function(o) {
        let u = o;
        return t && (u = /* @__PURE__ */ n(function(l) {
          o.call(t, l, t);
        }, "newFn")), r && (u = r(t?.key, s, u)), u !== o && (u.toString = () => o.toString()), u;
      }), i[s] = a);
    }
    return i;
  }
  n(lj, "wrapWithStateOrWrapper");
  function hFe(e) {
    for (let t of Object.keys(e)) {
      if (Jo(t)) continue;
      let r = e[t];
      typeof r == "function" && (e[t] = {
        enter: r
      });
    }
  }
  n(hFe, "ensureEntranceObjects");
  function cj(e) {
    e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]), e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
  }
  n(cj, "ensureCallbackArrays");
  function mFe(e, t) {
    let r = `is${e}`, i = cFe[r], s = /* @__PURE__ */ n(function(a) {
      if (i.call(a))
        return t.apply(this, arguments);
    }, "newFn");
    return s.toString = () => t.toString(), s;
  }
  n(mFe, "wrapCheck");
  function Jo(e) {
    return e[0] === "_" || e === "enter" || e === "exit" || e === "shouldSkip" || e === "denylist" || e === "noScope" || e === "skipKeys" ||
    e === "blacklist";
  }
  n(Jo, "shouldIgnoreKey");
  function Jd(e, t) {
    for (let r of ["enter", "exit"])
      t[r] && (e[r] = [].concat(e[r] || [], t[r]));
  }
  n(Jd, "mergePair");
  var yFe = {
    FunctionParent(e) {
      e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && (e.requeueComputedKeyAndDecorators ? e.requeueComputedKeyAndDecorators() :
      ij.requeueComputedKeyAndDecorators.call(e)));
    },
    Property(e) {
      e.isObjectProperty() || (e.skip(), e.requeueComputedKeyAndDecorators ? e.requeueComputedKeyAndDecorators() : ij.requeueComputedKeyAndDecorators.
      call(e));
    }
  };
  function gFe(e) {
    return mj([yFe, e]);
  }
  n(gFe, "environmentVisitor");
});

// ../node_modules/@babel/traverse/lib/scope/lib/renamer.js
var yj = E((my) => {
  "use strict";
  Object.defineProperty(my, "__esModule", {
    value: !0
  });
  my.default = void 0;
  var hy = Pe(), bFe = hy, DFe = yy(), vFe = Xd(), xFe = zi(), {
    getAssignmentIdentifiers: EFe
  } = bFe, SFe = {
    ReferencedIdentifier({
      node: e
    }, t) {
      e.name === t.oldName && (e.name = t.newName);
    },
    Scope(e, t) {
      e.scope.bindingIdentifierEquals(t.oldName, t.binding.identifier) || (e.skip(), e.isMethod() && (e.requeueComputedKeyAndDecorators ? e.
      requeueComputedKeyAndDecorators() : xFe.requeueComputedKeyAndDecorators.call(e)));
    },
    ObjectProperty({
      node: e,
      scope: t
    }, r) {
      let {
        name: i
      } = e.key;
      if (e.shorthand && (i === r.oldName || i === r.newName) && t.getBindingIdentifier(i) === r.binding.identifier) {
        e.shorthand = !1;
        {
          var s;
          (s = e.extra) != null && s.shorthand && (e.extra.shorthand = !1);
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(e, t) {
      if (e.isVariableDeclaration()) return;
      let r = e.isAssignmentExpression() ? EFe(e.node) : e.getOuterBindingIdentifiers();
      for (let i in r)
        i === t.oldName && (r[i].name = t.newName);
    }
  }, pC = class {
    static {
      n(this, "Renamer");
    }
    constructor(t, r, i) {
      this.newName = i, this.oldName = r, this.binding = t;
    }
    maybeConvertFromExportDeclaration(t) {
      let r = t.parentPath;
      if (r.isExportDeclaration()) {
        if (r.isExportDefaultDeclaration()) {
          let {
            declaration: i
          } = r.node;
          if (hy.isDeclaration(i) && !i.id)
            return;
        }
        r.isExportAllDeclaration() || r.splitExportDeclaration();
      }
    }
    maybeConvertFromClassFunctionDeclaration(t) {
      return t;
    }
    maybeConvertFromClassFunctionExpression(t) {
      return t;
    }
    rename() {
      let {
        binding: t,
        oldName: r,
        newName: i
      } = this, {
        scope: s,
        path: a
      } = t, o = a.find((c) => c.isDeclaration() || c.isFunctionExpression() || c.isClassExpression());
      o && o.getOuterBindingIdentifiers()[r] === t.identifier && this.maybeConvertFromExportDeclaration(o);
      let u = arguments[0] || s.block, l = {
        discriminant: !0
      };
      hy.isMethod(u) && (u.computed && (l.key = !0), hy.isObjectMethod(u) || (l.decorators = !0)), (0, DFe.traverseNode)(u, (0, vFe.explode)(
      SFe), s, this, s.path, l), arguments[0] || (s.removeOwnBinding(r), s.bindings[i] = t, this.binding.identifier.name = i), o && (this.maybeConvertFromClassFunctionDeclaration(
      a), this.maybeConvertFromClassFunctionExpression(a));
    }
  };
  my.default = pC;
});

// ../node_modules/@babel/traverse/lib/scope/traverseForScope.js
var gj = E((hC) => {
  "use strict";
  Object.defineProperty(hC, "__esModule", {
    value: !0
  });
  hC.default = PFe;
  var TFe = Pe(), CFe = ir(), wFe = Xd(), AFe = zi(), {
    VISITOR_KEYS: _Fe
  } = TFe;
  function PFe(e, t, r) {
    let i = (0, wFe.explode)(t);
    if (i.enter || i.exit)
      throw new Error("Should not be used with enter/exit visitors.");
    s(e.parentPath, e.parent, e.node, e.container, e.key, e.listKey, e.hub, e);
    function s(a, o, u, l, c, f, m, h) {
      if (!u)
        return;
      let d = h || CFe.NodePath.get({
        hub: m,
        parentPath: a,
        parent: o,
        container: l,
        listKey: f,
        key: c
      });
      AFe.setScope.call(d);
      let y = i[u.type];
      if (y) {
        if (y.enter)
          for (let g of y.enter)
            g.call(r, d, r);
        if (y.exit)
          for (let g of y.exit)
            g.call(r, d, r);
      }
      if (d.shouldSkip)
        return;
      let p = _Fe[u.type];
      if (p != null && p.length)
        for (let g of p) {
          let b = u[g];
          if (b)
            if (Array.isArray(b))
              for (let D = 0; D < b.length; D++) {
                let x = b[D];
                s(d, u, x, b, D, g);
              }
            else
              s(d, u, b, u, g, null);
        }
    }
    n(s, "_traverse");
  }
  n(PFe, "traverseForScope");
});

// ../node_modules/@babel/traverse/lib/scope/binding.js
var bj = E((gy) => {
  "use strict";
  Object.defineProperty(gy, "__esModule", {
    value: !0
  });
  gy.default = void 0;
  var mC = class {
    static {
      n(this, "Binding");
    }
    constructor({
      identifier: t,
      scope: r,
      path: i,
      kind: s
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0,
      this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = t, this.scope = r, this.path = i, this.kind = s,
      (s === "var" || s === "hoisted") && FFe(i) && this.reassign(i), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(t) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = t);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(t) {
      this.constant = !1, !this.constantViolations.includes(t) && this.constantViolations.push(t);
    }
    reference(t) {
      this.referencePaths.includes(t) || (this.referenced = !0, this.references++, this.referencePaths.push(t));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
  gy.default = mC;
  function FFe(e) {
    let t = !e.isVariableDeclarator() || e.node.init;
    for (let {
      parentPath: r,
      key: i
    } = e; r; {
      parentPath: r,
      key: i
    } = r) {
      if (r.isFunctionParent()) return !1;
      if (i === "left" && r.isForXStatement() || t && i === "body" && r.isLoop())
        return !0;
    }
    return !1;
  }
  n(FFe, "isInitInLoop");
});

// ../node_modules/@babel/traverse/lib/cache.js
var Yo = E((Ci) => {
  "use strict";
  Object.defineProperty(Ci, "__esModule", {
    value: !0
  });
  Ci.clear = OFe;
  Ci.clearPath = Dj;
  Ci.clearScope = vj;
  Ci.getCachedPaths = kFe;
  Ci.getOrCreateCachedPaths = BFe;
  Ci.scope = Ci.path = void 0;
  var by = Ci.path = /* @__PURE__ */ new WeakMap(), IFe = Ci.scope = /* @__PURE__ */ new WeakMap();
  function OFe() {
    Dj(), vj();
  }
  n(OFe, "clear");
  function Dj() {
    Ci.path = by = /* @__PURE__ */ new WeakMap();
  }
  n(Dj, "clearPath");
  function vj() {
    Ci.scope = IFe = /* @__PURE__ */ new WeakMap();
  }
  n(vj, "clearScope");
  function kFe(e) {
    let {
      parent: t,
      parentPath: r
    } = e;
    return by.get(t);
  }
  n(kFe, "getCachedPaths");
  function BFe(e, t) {
    let r = by.get(e);
    return r || by.set(e, r = /* @__PURE__ */ new Map()), r;
  }
  n(BFe, "getOrCreateCachedPaths");
});

// ../node_modules/@babel/helper-globals/data/builtin-lower.json
var xj = E((D1t, NFe) => {
  NFe.exports = [
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "eval",
    "globalThis",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "undefined",
    "unescape"
  ];
});

// ../node_modules/@babel/helper-globals/data/builtin-upper.json
var Ej = E((v1t, MFe) => {
  MFe.exports = [
    "AggregateError",
    "Array",
    "ArrayBuffer",
    "Atomics",
    "BigInt",
    "BigInt64Array",
    "BigUint64Array",
    "Boolean",
    "DataView",
    "Date",
    "Error",
    "EvalError",
    "FinalizationRegistry",
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Function",
    "Infinity",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Intl",
    "Iterator",
    "JSON",
    "Map",
    "Math",
    "NaN",
    "Number",
    "Object",
    "Promise",
    "Proxy",
    "RangeError",
    "ReferenceError",
    "Reflect",
    "RegExp",
    "Set",
    "SharedArrayBuffer",
    "String",
    "Symbol",
    "SyntaxError",
    "TypeError",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "URIError",
    "WeakMap",
    "WeakRef",
    "WeakSet"
  ];
});

// ../node_modules/@babel/traverse/lib/scope/index.js
var vC = E((vy) => {
  "use strict";
  Object.defineProperty(vy, "__esModule", {
    value: !0
  });
  vy.default = void 0;
  var RFe = yj(), Ij = ir(), x1t = gj(), LFe = bj(), Oj = Pe(), kj = Oj, Sj = Yo(), jFe = xj(), qFe = Ej(), {
    assignmentExpression: UFe,
    callExpression: Tj,
    cloneNode: Cj,
    getBindingIdentifiers: Bj,
    identifier: Zo,
    isArrayExpression: Nj,
    isBinary: $Fe,
    isCallExpression: wj,
    isClass: VFe,
    isClassBody: WFe,
    isClassDeclaration: HFe,
    isExportAllDeclaration: Mj,
    isExportDefaultDeclaration: KFe,
    isExportNamedDeclaration: yC,
    isFunctionDeclaration: zFe,
    isIdentifier: Go,
    isImportDeclaration: gC,
    isLiteral: JFe,
    isMemberExpression: XFe,
    isMethod: YFe,
    isModuleSpecifier: GFe,
    isNullLiteral: ZFe,
    isObjectExpression: QFe,
    isProperty: e6e,
    isPureish: t6e,
    isRegExpLiteral: r6e,
    isSuper: i6e,
    isTaggedTemplateExpression: s6e,
    isTemplateLiteral: Rj,
    isThisExpression: Aj,
    isUnaryExpression: n6e,
    isVariableDeclaration: a6e,
    expressionStatement: o6e,
    matchesPattern: _j,
    memberExpression: bC,
    numericLiteral: u6e,
    toIdentifier: l6e,
    variableDeclaration: c6e,
    variableDeclarator: f6e,
    isRecordExpression: d6e,
    isTupleExpression: p6e,
    isObjectProperty: h6e,
    isTopicReference: Pj,
    isMetaProperty: m6e,
    isPrivateName: y6e,
    isExportDeclaration: g6e,
    buildUndefinedNode: b6e,
    sequenceExpression: D6e
  } = Oj;
  function wt(e, t) {
    switch (e?.type) {
      default:
        if (gC(e) || g6e(e)) {
          var r;
          if ((Mj(e) || yC(e) || gC(e)) && e.source)
            wt(e.source, t);
          else if ((yC(e) || gC(e)) && (r = e.specifiers) != null && r.length)
            for (let i of e.specifiers) wt(i, t);
          else (KFe(e) || yC(e)) && e.declaration && wt(e.declaration, t);
        } else GFe(e) ? wt(e.local, t) : JFe(e) && !ZFe(e) && !r6e(e) && !Rj(e) && t.push(e.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        wt(e.object, t), wt(e.property, t);
        break;
      case "Identifier":
      case "JSXIdentifier":
        t.push(e.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        wt(e.callee, t);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (let i of e.properties)
          wt(i, t);
        break;
      case "SpreadElement":
      case "RestElement":
        wt(e.argument, t);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        wt(e.key, t);
        break;
      case "ThisExpression":
        t.push("this");
        break;
      case "Super":
        t.push("super");
        break;
      case "Import":
      case "ImportExpression":
        t.push("import");
        break;
      case "DoExpression":
        t.push("do");
        break;
      case "YieldExpression":
        t.push("yield"), wt(e.argument, t);
        break;
      case "AwaitExpression":
        t.push("await"), wt(e.argument, t);
        break;
      case "AssignmentExpression":
        wt(e.left, t);
        break;
      case "VariableDeclarator":
        wt(e.id, t);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        wt(e.id, t);
        break;
      case "PrivateName":
        wt(e.id, t);
        break;
      case "ParenthesizedExpression":
        wt(e.expression, t);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        wt(e.argument, t);
        break;
      case "MetaProperty":
        wt(e.meta, t), wt(e.property, t);
        break;
      case "JSXElement":
        wt(e.openingElement, t);
        break;
      case "JSXOpeningElement":
        wt(e.name, t);
        break;
      case "JSXFragment":
        wt(e.openingFragment, t);
        break;
      case "JSXOpeningFragment":
        t.push("Fragment");
        break;
      case "JSXNamespacedName":
        wt(e.namespace, t), wt(e.name, t);
        break;
    }
  }
  n(wt, "gatherNodeParts");
  function Fj(e) {
    e.references = /* @__PURE__ */ Object.create(null), e.uids = /* @__PURE__ */ Object.create(null), e.bindings = /* @__PURE__ */ Object.create(
    null), e.globals = /* @__PURE__ */ Object.create(null);
  }
  n(Fj, "resetScope");
  function v6e(e) {
    return e.isFunctionExpression() && !e.node.id || e.isArrowFunctionExpression();
  }
  n(v6e, "isAnonymousFunctionExpression");
  DC = Symbol.for("should not be considered a local binding");
  var DC, x6e = {
    ForStatement(e) {
      let t = e.get("init");
      if (t.isVar()) {
        let {
          scope: r
        } = e;
        (r.getFunctionParent() || r.getProgramParent()).registerBinding("var", t);
      }
    },
    Declaration(e) {
      if (e.isBlockScoped() || e.isImportDeclaration() || e.isExportDeclaration()) return;
      (e.scope.getFunctionParent() || e.scope.getProgramParent()).registerDeclaration(e);
    },
    ImportDeclaration(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    TSImportEqualsDeclaration(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    ReferencedIdentifier(e, t) {
      kj.isTSQualifiedName(e.parent) && e.parent.right === e.node || e.parentPath.isTSImportEqualsDeclaration() || t.references.push(e);
    },
    ForXStatement(e, t) {
      let r = e.get("left");
      if (r.isPattern() || r.isIdentifier())
        t.constantViolations.push(e);
      else if (r.isVar()) {
        let {
          scope: i
        } = e;
        (i.getFunctionParent() || i.getProgramParent()).registerBinding("var", r);
      }
    },
    ExportDeclaration: {
      exit(e) {
        let {
          node: t,
          scope: r
        } = e;
        if (Mj(t)) return;
        let i = t.declaration;
        if (HFe(i) || zFe(i)) {
          let s = i.id;
          if (!s) return;
          let a = r.getBinding(s.name);
          a?.reference(e);
        } else if (a6e(i))
          for (let s of i.declarations)
            for (let a of Object.keys(Bj(s))) {
              let o = r.getBinding(a);
              o?.reference(e);
            }
      }
    },
    LabeledStatement(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    AssignmentExpression(e, t) {
      t.assignments.push(e);
    },
    UpdateExpression(e, t) {
      t.constantViolations.push(e);
    },
    UnaryExpression(e, t) {
      e.node.operator === "delete" && t.constantViolations.push(e);
    },
    BlockScoped(e) {
      let t = e.scope;
      if (t.path === e && (t = t.parent), t.getBlockParent().registerDeclaration(e), e.isClassDeclaration() && e.node.id) {
        let s = e.node.id.name;
        e.scope.bindings[s] = e.scope.parent.getBinding(s);
      }
    },
    CatchClause(e) {
      e.scope.registerBinding("let", e);
    },
    Function(e) {
      let t = e.get("params");
      for (let r of t)
        e.scope.registerBinding("param", r);
      e.isFunctionExpression() && e.node.id && !e.node.id[DC] && e.scope.registerBinding("local", e.get("id"), e);
    },
    ClassExpression(e) {
      e.node.id && !e.node.id[DC] && e.scope.registerBinding("local", e.get("id"), e);
    },
    TSTypeAnnotation(e) {
      e.skip();
    }
  }, Dy, E6e = 0, ys = class e {
    static {
      n(this, "Scope");
    }
    constructor(t) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.inited = void 0, this.labels = void 0, this.bindings = void 0, this.referencesSet =
      void 0, this.globals = void 0, this.uidsSet = void 0, this.data = void 0, this.crawling = void 0;
      let {
        node: r
      } = t, i = Sj.scope.get(r);
      if (i?.path === t)
        return i;
      Sj.scope.set(r, this), this.uid = E6e++, this.block = r, this.path = t, this.labels = /* @__PURE__ */ new Map(), this.inited = !1, Object.
      defineProperties(this, {
        references: {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: /* @__PURE__ */ Object.create(null)
        },
        uids: {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: /* @__PURE__ */ Object.create(null)
        }
      });
    }
    get parent() {
      var t;
      let r, i = this.path;
      do {
        var s;
        let a = i.key === "key" || i.listKey === "decorators";
        i = i.parentPath, a && i.isMethod() && (i = i.parentPath), (s = i) != null && s.isScope() && (r = i);
      } while (i && !r);
      return (t = r) == null ? void 0 : t.scope;
    }
    get references() {
      throw new Error("Scope#references is not available in Babel 8. Use Scope#referencesSet instead.");
    }
    get uids() {
      throw new Error("Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.");
    }
    generateDeclaredUidIdentifier(t) {
      let r = this.generateUidIdentifier(t);
      return this.push({
        id: r
      }), Cj(r);
    }
    generateUidIdentifier(t) {
      return Zo(this.generateUid(t));
    }
    generateUid(t = "temp") {
      t = l6e(t).replace(/^_+/, "").replace(/\d+$/g, "");
      let r, i = 0;
      do
        r = `_${t}`, i >= 11 ? r += i - 1 : i >= 9 ? r += i - 9 : i >= 1 && (r += i + 1), i++;
      while (this.hasLabel(r) || this.hasBinding(r) || this.hasGlobal(r) || this.hasReference(r));
      let s = this.getProgramParent();
      return s.references[r] = !0, s.uids[r] = !0, r;
    }
    generateUidBasedOnNode(t, r) {
      let i = [];
      wt(t, i);
      let s = i.join("$");
      return s = s.replace(/^_/, "") || r || "ref", this.generateUid(s.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(t, r) {
      return Zo(this.generateUidBasedOnNode(t, r));
    }
    isStatic(t) {
      if (Aj(t) || i6e(t) || Pj(t))
        return !0;
      if (Go(t)) {
        let r = this.getBinding(t.name);
        return r ? r.constant : this.hasBinding(t.name);
      }
      return !1;
    }
    maybeGenerateMemoised(t, r) {
      if (this.isStatic(t))
        return null;
      {
        let i = this.generateUidIdentifierBasedOnNode(t);
        return r ? i : (this.push({
          id: i
        }), Cj(i));
      }
    }
    checkBlockScopedCollisions(t, r, i, s) {
      if (r === "param" || t.kind === "local") return;
      if (r === "let" || t.kind === "let" || t.kind === "const" || t.kind === "module" || t.kind === "param" && r === "const")
        throw this.path.hub.buildError(s, `Duplicate declaration "${i}"`, TypeError);
    }
    rename(t, r) {
      let i = this.getBinding(t);
      i && (r || (r = this.generateUidIdentifier(t).name), new RFe.default(i, t, r).rename(arguments[2]));
    }
    dump() {
      let t = "-".repeat(60);
      console.log(t);
      let r = this;
      do {
        console.log("#", r.block.type);
        for (let i of Object.keys(r.bindings)) {
          let s = r.bindings[i];
          console.log(" -", i, {
            constant: s.constant,
            references: s.references,
            violations: s.constantViolations.length,
            kind: s.kind
          });
        }
      } while (r = r.parent);
      console.log(t);
    }
    hasLabel(t) {
      return !!this.getLabel(t);
    }
    getLabel(t) {
      return this.labels.get(t);
    }
    registerLabel(t) {
      this.labels.set(t.node.label.name, t);
    }
    registerDeclaration(t) {
      if (t.isLabeledStatement())
        this.registerLabel(t);
      else if (t.isFunctionDeclaration())
        this.registerBinding("hoisted", t.get("id"), t);
      else if (t.isVariableDeclaration()) {
        let r = t.get("declarations"), {
          kind: i
        } = t.node;
        for (let s of r)
          this.registerBinding(i === "using" || i === "await using" ? "const" : i, s);
      } else if (t.isClassDeclaration()) {
        if (t.node.declare) return;
        this.registerBinding("let", t);
      } else if (t.isImportDeclaration()) {
        let r = t.node.importKind === "type" || t.node.importKind === "typeof", i = t.get("specifiers");
        for (let s of i) {
          let a = r || s.isImportSpecifier() && (s.node.importKind === "type" || s.node.importKind === "typeof");
          this.registerBinding(a ? "unknown" : "module", s);
        }
      } else if (t.isExportDeclaration()) {
        let r = t.get("declaration");
        (r.isClassDeclaration() || r.isFunctionDeclaration() || r.isVariableDeclaration()) && this.registerDeclaration(r);
      } else
        this.registerBinding("unknown", t);
    }
    buildUndefinedNode() {
      return b6e();
    }
    registerConstantViolation(t) {
      let r = t.getAssignmentIdentifiers();
      for (let s of Object.keys(r)) {
        var i;
        (i = this.getBinding(s)) == null || i.reassign(t);
      }
    }
    registerBinding(t, r, i = r) {
      if (!t) throw new ReferenceError("no `kind`");
      if (r.isVariableDeclaration()) {
        let o = r.get("declarations");
        for (let u of o)
          this.registerBinding(t, u);
        return;
      }
      let s = this.getProgramParent(), a = r.getOuterBindingIdentifiers(!0);
      for (let o of Object.keys(a)) {
        s.references[o] = !0;
        for (let u of a[o]) {
          let l = this.getOwnBinding(o);
          if (l) {
            if (l.identifier === u) continue;
            this.checkBlockScopedCollisions(l, t, o, u);
          }
          l ? l.reassign(i) : this.bindings[o] = new LFe.default({
            identifier: u,
            scope: this,
            path: i,
            kind: t
          });
        }
      }
    }
    addGlobal(t) {
      this.globals[t.name] = t;
    }
    hasUid(t) {
      {
        let r = this;
        do
          if (r.uids[t]) return !0;
        while (r = r.parent);
        return !1;
      }
    }
    hasGlobal(t) {
      let r = this;
      do
        if (r.globals[t]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasReference(t) {
      return !!this.getProgramParent().references[t];
    }
    isPure(t, r) {
      if (Go(t)) {
        let o = this.getBinding(t.name);
        return o ? r ? o.constant : !0 : !1;
      } else {
        if (Aj(t) || m6e(t) || Pj(t) || y6e(t))
          return !0;
        if (VFe(t)) {
          var i;
          return t.superClass && !this.isPure(t.superClass, r) || ((i = t.decorators) == null ? void 0 : i.length) > 0 ? !1 : this.isPure(t.
          body, r);
        } else if (WFe(t)) {
          for (let o of t.body)
            if (!this.isPure(o, r)) return !1;
          return !0;
        } else {
          if ($Fe(t))
            return this.isPure(t.left, r) && this.isPure(t.right, r);
          if (Nj(t) || p6e(t)) {
            for (let o of t.elements)
              if (o !== null && !this.isPure(o, r)) return !1;
            return !0;
          } else if (QFe(t) || d6e(t)) {
            for (let o of t.properties)
              if (!this.isPure(o, r)) return !1;
            return !0;
          } else if (YFe(t)) {
            var s;
            return !(t.computed && !this.isPure(t.key, r) || ((s = t.decorators) == null ? void 0 : s.length) > 0);
          } else if (e6e(t)) {
            var a;
            return !(t.computed && !this.isPure(t.key, r) || ((a = t.decorators) == null ? void 0 : a.length) > 0 || (h6e(t) || t.static) &&
            t.value !== null && !this.isPure(t.value, r));
          } else {
            if (n6e(t))
              return this.isPure(t.argument, r);
            if (Rj(t)) {
              for (let o of t.expressions)
                if (!this.isPure(o, r)) return !1;
              return !0;
            } else return s6e(t) ? _j(t.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(t.quasi, r) : XFe(t) ? !t.computed && Go(t.object) && t.object.name === "Symbol" && Go(t.property) && t.property.
            name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : wj(t) ? _j(t.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && t.arguments.length === 1 && kj.isStringLiteral(t.arguments[0]) : t6e(t);
          }
        }
      }
    }
    setData(t, r) {
      return this.data[t] = r;
    }
    getData(t) {
      let r = this;
      do {
        let i = r.data[t];
        if (i != null) return i;
      } while (r = r.parent);
    }
    removeData(t) {
      let r = this;
      do
        r.data[t] != null && (r.data[t] = null);
      while (r = r.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      let t = this.path;
      Fj(this), this.data = /* @__PURE__ */ Object.create(null);
      let r = this;
      do {
        if (r.crawling) return;
        if (r.path.isProgram())
          break;
      } while (r = r.parent);
      let i = r, s = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, Dy || (Dy = Ij.default.visitors.merge([{
        Scope(a) {
          Fj(a.scope);
        }
      }, x6e])), t.type !== "Program") {
        let a = Dy[t.type];
        if (a)
          for (let o of a.enter)
            o.call(s, t, s);
      }
      t.traverse(Dy, s), this.crawling = !1;
      for (let a of s.assignments) {
        let o = a.getAssignmentIdentifiers();
        for (let u of Object.keys(o))
          a.scope.getBinding(u) || i.addGlobal(o[u]);
        a.scope.registerConstantViolation(a);
      }
      for (let a of s.references) {
        let o = a.scope.getBinding(a.node.name);
        o ? o.reference(a) : i.addGlobal(a.node);
      }
      for (let a of s.constantViolations)
        a.scope.registerConstantViolation(a);
    }
    push(t) {
      let r = this.path;
      r.isPattern() ? r = this.getPatternParent().path : !r.isBlockStatement() && !r.isProgram() && (r = this.getBlockParent().path), r.isSwitchStatement() &&
      (r = (this.getFunctionParent() || this.getProgramParent()).path);
      let {
        init: i,
        unique: s,
        kind: a = "var",
        id: o
      } = t;
      if (!i && !s && (a === "var" || a === "let") && v6e(r) && wj(r.parent, {
        callee: r.node
      }) && r.parent.arguments.length <= r.node.params.length && Go(o)) {
        r.pushContainer("params", o), r.scope.registerBinding("param", r.get("params")[r.node.params.length - 1]);
        return;
      }
      (r.isLoop() || r.isCatchClause() || r.isFunction()) && (r.ensureBlock(), r = r.get("body"));
      let u = t._blockHoist == null ? 2 : t._blockHoist, l = `declaration:${a}:${u}`, c = !s && r.getData(l);
      if (!c) {
        let h = c6e(a, []);
        h._blockHoist = u, [c] = r.unshiftContainer("body", [h]), s || r.setData(l, c);
      }
      let f = f6e(o, i), m = c.node.declarations.push(f);
      r.scope.registerBinding(a, c.get("declarations")[m - 1]);
    }
    getProgramParent() {
      let t = this;
      do
        if (t.path.isProgram())
          return t;
      while (t = t.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let t = this;
      do
        if (t.path.isFunctionParent())
          return t;
      while (t = t.parent);
      return null;
    }
    getBlockParent() {
      let t = this;
      do
        if (t.path.isBlockParent())
          return t;
      while (t = t.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let t = this;
      do
        if (!t.path.isPattern())
          return t.getBlockParent();
      while (t = t.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      let t = /* @__PURE__ */ Object.create(null), r = this;
      do {
        for (let i of Object.keys(r.bindings))
          i in t || (t[i] = r.bindings[i]);
        r = r.parent;
      } while (r);
      return t;
    }
    bindingIdentifierEquals(t, r) {
      return this.getBindingIdentifier(t) === r;
    }
    getBinding(t) {
      let r = this, i;
      do {
        let a = r.getOwnBinding(t);
        if (a) {
          var s;
          if (!((s = i) != null && s.isPattern() && a.kind !== "param" && a.kind !== "local"))
            return a;
        } else if (!a && t === "arguments" && r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
        i = r.path;
      } while (r = r.parent);
    }
    getOwnBinding(t) {
      return this.bindings[t];
    }
    getBindingIdentifier(t) {
      var r;
      return (r = this.getBinding(t)) == null ? void 0 : r.identifier;
    }
    getOwnBindingIdentifier(t) {
      let r = this.bindings[t];
      return r?.identifier;
    }
    hasOwnBinding(t) {
      return !!this.getOwnBinding(t);
    }
    hasBinding(t, r) {
      if (!t) return !1;
      let i, s, a;
      typeof r == "object" ? (i = r.noGlobals, s = r.noUids, a = r.upToScope) : typeof r == "boolean" && (i = r);
      let o = this;
      do {
        if (a === o)
          break;
        if (o.hasOwnBinding(t))
          return !0;
      } while (o = o.parent);
      return !!(!s && this.hasUid(t) || !i && e.globals.includes(t) || !i && e.contextVariables.includes(t));
    }
    parentHasBinding(t, r) {
      var i;
      return (i = this.parent) == null ? void 0 : i.hasBinding(t, r);
    }
    moveBindingTo(t, r) {
      let i = this.getBinding(t);
      i && (i.scope.removeOwnBinding(t), i.scope = r, r.bindings[t] = i);
    }
    removeOwnBinding(t) {
      delete this.bindings[t];
    }
    removeBinding(t) {
      var r;
      (r = this.getBinding(t)) == null || r.scope.removeOwnBinding(t);
      {
        let i = this;
        do
          i.uids[t] && (i.uids[t] = !1);
        while (i = i.parent);
      }
    }
    hoistVariables(t = (r) => this.push({
      id: r
    })) {
      this.crawl();
      let r = /* @__PURE__ */ new Set();
      for (let i of Object.keys(this.bindings)) {
        let s = this.bindings[i];
        if (!s) continue;
        let {
          path: a
        } = s;
        if (!a.isVariableDeclarator()) continue;
        let {
          parent: o,
          parentPath: u
        } = a;
        if (o.kind !== "var" || r.has(o)) continue;
        r.add(a.parent);
        let l, c = [];
        for (let f of o.declarations) {
          l ?? (l = f.id), f.init && c.push(UFe("=", f.id, f.init));
          let m = Object.keys(Bj(f, !1, !0, !0));
          for (let h of m)
            t(Zo(h), f.init != null);
        }
        if (u.parentPath.isForXStatement({
          left: o
        }))
          u.replaceWith(l);
        else if (c.length === 0)
          u.remove();
        else {
          let f = c.length === 1 ? c[0] : D6e(c);
          u.parentPath.isForStatement({
            init: o
          }) ? u.replaceWith(f) : u.replaceWith(o6e(f));
        }
      }
    }
  };
  vy.default = ys;
  ys.globals = [...jFe, ...qFe];
  ys.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  ys.prototype._renameFromMap = /* @__PURE__ */ n(function(t, r, i, s) {
    t[r] && (t[i] = s, t[r] = null);
  }, "_renameFromMap"), ys.prototype.traverse = function(e, t, r) {
    (0, Ij.default)(e, t, this, r, this.path);
  }, ys.prototype._generateUid = /* @__PURE__ */ n(function(t, r) {
    let i = t;
    return r > 1 && (i += r), `_${i}`;
  }, "_generateUid"), ys.prototype.toArray = /* @__PURE__ */ n(function(t, r, i) {
    if (Go(t)) {
      let o = this.getBinding(t.name);
      if (o != null && o.constant && o.path.isGenericType("Array"))
        return t;
    }
    if (Nj(t))
      return t;
    if (Go(t, {
      name: "arguments"
    }))
      return Tj(bC(bC(bC(Zo("Array"), Zo("prototype")), Zo("slice")), Zo("call")), [t]);
    let s, a = [t];
    return r === !0 ? s = "toConsumableArray" : typeof r == "number" ? (a.push(u6e(r)), s = "slicedToArray") : s = "toArray", i && (a.unshift(
    this.path.hub.addHelper(s)), s = "maybeArrayLike"), Tj(this.path.hub.addHelper(s), a);
  }, "toArray"), ys.prototype.getAllBindingsOfKind = /* @__PURE__ */ n(function(...t) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let i of t) {
      let s = this;
      do {
        for (let a of Object.keys(s.bindings)) {
          let o = s.bindings[a];
          o.kind === i && (r[a] = o);
        }
        s = s.parent;
      } while (s);
    }
    return r;
  }, "getAllBindingsOfKind"), Object.defineProperties(ys.prototype, {
    parentBlock: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.parent;
      }
    },
    hub: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.hub;
      }
    }
  });
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
function Yd(e, t) {
  let r = 0, i = 0, s = 0;
  do {
    let o = e.next();
    s = Wj[o], r |= (s & 31) << i, i += 5;
  } while (s & 32);
  let a = r & 1;
  return r >>>= 1, a && (r = -2147483648 | -r), t + r;
}
function Gd(e, t, r) {
  let i = t - r;
  i = i < 0 ? -i << 1 | 1 : i << 1;
  do {
    let s = i & 31;
    i >>>= 5, i > 0 && (s |= 32), e.write(Vj[s]);
  } while (i > 0);
  return t;
}
function jj(e, t) {
  return e.pos >= t ? !1 : e.peek() !== $j;
}
function Hj(e) {
  let { length: t } = e, r = new C6e(e), i = [], s = 0, a = 0, o = 0, u = 0, l = 0;
  do {
    let c = r.indexOf(";"), f = [], m = !0, h = 0;
    for (s = 0; r.pos < c; ) {
      let d;
      s = Yd(r, s), s < h && (m = !1), h = s, jj(r, c) ? (a = Yd(r, a), o = Yd(r, o), u = Yd(r, u), jj(r, c) ? (l = Yd(r, l), d = [s, a, o, u,
      l]) : d = [s, a, o, u]) : d = [s], f.push(d), r.pos++;
    }
    m || w6e(f), i.push(f), r.pos = c + 1;
  } while (r.pos <= t);
  return i;
}
function w6e(e) {
  e.sort(A6e);
}
function A6e(e, t) {
  return e[0] - t[0];
}
function xy(e) {
  let t = new T6e(), r = 0, i = 0, s = 0, a = 0;
  for (let o = 0; o < e.length; o++) {
    let u = e[o];
    if (o > 0 && t.write(S6e), u.length === 0) continue;
    let l = 0;
    for (let c = 0; c < u.length; c++) {
      let f = u[c];
      c > 0 && t.write($j), l = Gd(t, f[0], l), f.length !== 1 && (r = Gd(t, f[1], r), i = Gd(t, f[2], i), s = Gd(t, f[3], s), f.length !== 4 &&
      (a = Gd(t, f[4], a)));
    }
  }
  return t.flush();
}
var $j, S6e, Lj, Vj, Wj, qj, Uj, T6e, C6e, xC = ph(() => {
  $j = 44, S6e = 59, Lj = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Vj = new Uint8Array(64), Wj = new Uint8Array(128);
  for (let e = 0; e < Lj.length; e++) {
    let t = Lj.charCodeAt(e);
    Vj[e] = t, Wj[t] = e;
  }
  n(Yd, "decodeInteger");
  n(Gd, "encodeInteger");
  n(jj, "hasMoreVlq");
  qj = 1024 * 16, Uj = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
    decode(e) {
      return Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString();
    }
  } : {
    decode(e) {
      let t = "";
      for (let r = 0; r < e.length; r++)
        t += String.fromCharCode(e[r]);
      return t;
    }
  }, T6e = class {
    static {
      n(this, "StringWriter");
    }
    constructor() {
      this.pos = 0, this.out = "", this.buffer = new Uint8Array(qj);
    }
    write(e) {
      let { buffer: t } = this;
      t[this.pos++] = e, this.pos === qj && (this.out += Uj.decode(t), this.pos = 0);
    }
    flush() {
      let { buffer: e, out: t, pos: r } = this;
      return r > 0 ? t + Uj.decode(e.subarray(0, r)) : t;
    }
  }, C6e = class {
    static {
      n(this, "StringReader");
    }
    constructor(e) {
      this.pos = 0, this.buffer = e;
    }
    next() {
      return this.buffer.charCodeAt(this.pos++);
    }
    peek() {
      return this.buffer.charCodeAt(this.pos);
    }
    indexOf(e) {
      let { buffer: t, pos: r } = this, i = t.indexOf(e, r);
      return i === -1 ? t.length : i;
    }
  };
  n(Hj, "decode");
  n(w6e, "sort");
  n(A6e, "sortComparator");
  n(xy, "encode");
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var Kj = E((EC, SC) => {
  (function(e, t) {
    typeof EC == "object" && typeof SC < "u" ? SC.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, e.resolveURI = t());
  })(EC, function() {
    "use strict";
    let e = /^[\w+.-]+:\/\//, t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    function i(g) {
      return e.test(g);
    }
    n(i, "isAbsoluteUrl");
    function s(g) {
      return g.startsWith("//");
    }
    n(s, "isSchemeRelativeUrl");
    function a(g) {
      return g.startsWith("/");
    }
    n(a, "isAbsolutePath");
    function o(g) {
      return g.startsWith("file:");
    }
    n(o, "isFileUrl");
    function u(g) {
      return /^[.?#]/.test(g);
    }
    n(u, "isRelative");
    function l(g) {
      let b = t.exec(g);
      return f(b[1], b[2] || "", b[3], b[4] || "", b[5] || "/", b[6] || "", b[7] || "");
    }
    n(l, "parseAbsoluteUrl");
    function c(g) {
      let b = r.exec(g), D = b[2];
      return f("file:", "", b[1] || "", "", a(D) ? D : "/" + D, b[3] || "", b[4] || "");
    }
    n(c, "parseFileUrl");
    function f(g, b, D, x, T, w, B) {
      return {
        scheme: g,
        user: b,
        host: D,
        port: x,
        path: T,
        query: w,
        hash: B,
        type: 7
      };
    }
    n(f, "makeUrl");
    function m(g) {
      if (s(g)) {
        let D = l("http:" + g);
        return D.scheme = "", D.type = 6, D;
      }
      if (a(g)) {
        let D = l("http://foo.com" + g);
        return D.scheme = "", D.host = "", D.type = 5, D;
      }
      if (o(g))
        return c(g);
      if (i(g))
        return l(g);
      let b = l("http://foo.com/" + g);
      return b.scheme = "", b.host = "", b.type = g ? g.startsWith("?") ? 3 : g.startsWith("#") ? 2 : 4 : 1, b;
    }
    n(m, "parseUrl");
    function h(g) {
      if (g.endsWith("/.."))
        return g;
      let b = g.lastIndexOf("/");
      return g.slice(0, b + 1);
    }
    n(h, "stripPathFilename");
    function d(g, b) {
      y(b, b.type), g.path === "/" ? g.path = b.path : g.path = h(b.path) + g.path;
    }
    n(d, "mergePaths");
    function y(g, b) {
      let D = b <= 4, x = g.path.split("/"), T = 1, w = 0, B = !1;
      for (let q = 1; q < x.length; q++) {
        let V = x[q];
        if (!V) {
          B = !0;
          continue;
        }
        if (B = !1, V !== ".") {
          if (V === "..") {
            w ? (B = !0, w--, T--) : D && (x[T++] = V);
            continue;
          }
          x[T++] = V, w++;
        }
      }
      let k = "";
      for (let q = 1; q < T; q++)
        k += "/" + x[q];
      (!k || B && !k.endsWith("/..")) && (k += "/"), g.path = k;
    }
    n(y, "normalizePath");
    function p(g, b) {
      if (!g && !b)
        return "";
      let D = m(g), x = D.type;
      if (b && x !== 7) {
        let w = m(b), B = w.type;
        switch (x) {
          case 1:
            D.hash = w.hash;
          // fall through
          case 2:
            D.query = w.query;
          // fall through
          case 3:
          case 4:
            d(D, w);
          // fall through
          case 5:
            D.user = w.user, D.host = w.host, D.port = w.port;
          // fall through
          case 6:
            D.scheme = w.scheme;
        }
        B > x && (x = B);
      }
      y(D, x);
      let T = D.query + D.hash;
      switch (x) {
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case 2:
        case 3:
          return T;
        case 4: {
          let w = D.path.slice(1);
          return w ? u(b || g) && !u(w) ? "./" + w + T : w + T : T || ".";
        }
        case 5:
          return D.path + T;
        default:
          return D.scheme + "//" + D.user + D.host + D.port + D.path + T;
      }
    }
    return n(p, "resolve"), p;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
var lq = {};
hh(lq, {
  AnyMap: () => M6e,
  FlattenMap: () => M6e,
  GREATEST_LOWER_BOUND: () => ep,
  LEAST_UPPER_BOUND: () => Qd,
  TraceMap: () => Ln,
  allGeneratedPositionsFor: () => U6e,
  decodedMap: () => H6e,
  decodedMappings: () => bs,
  eachMapping: () => $6e,
  encodedMap: () => K6e,
  encodedMappings: () => nq,
  generatedPositionFor: () => q6e,
  isIgnored: () => W6e,
  originalPositionFor: () => j6e,
  presortedDecodedMap: () => oq,
  sourceContentFor: () => V6e,
  traceSegment: () => PC
});
function _6e(e) {
  if (!e) return "";
  let t = e.lastIndexOf("/");
  return e.slice(0, t + 1);
}
function P6e(e, t) {
  let r = _6e(e), i = t ? t + "/" : "";
  return (s) => (0, Jj.default)(i + (s || ""), r);
}
function F6e(e, t) {
  let r = zj(e, 0);
  if (r === e.length) return e;
  t || (e = e.slice());
  for (let i = r; i < e.length; i = zj(e, i + 1))
    e[i] = O6e(e[i], t);
  return e;
}
function zj(e, t) {
  for (let r = t; r < e.length; r++)
    if (!I6e(e[r])) return r;
  return e.length;
}
function I6e(e) {
  for (let t = 1; t < e.length; t++)
    if (e[t][gs] < e[t - 1][gs])
      return !1;
  return !0;
}
function O6e(e, t) {
  return t || (e = e.slice()), e.sort(Zj);
}
function Zj(e, t) {
  return e[gs] - t[gs];
}
function k6e(e, t) {
  let r = t.map(() => []);
  for (let i = 0; i < e.length; i++) {
    let s = e[i];
    for (let a = 0; a < s.length; a++) {
      let o = s[a];
      if (o.length === 1) continue;
      let u = o[CC], l = o[wC], c = o[AC], f = r[u];
      (f[l] || (f[l] = [])).push([c, i, o[gs]]);
    }
  }
  for (let i = 0; i < r.length; i++) {
    let s = r[i];
    for (let a = 0; a < s.length; a++) {
      let o = s[a];
      o && o.sort(Zj);
    }
  }
  return r;
}
function B6e(e, t, r, i) {
  for (; r <= i; ) {
    let s = r + (i - r >> 1), a = e[s][gs] - t;
    if (a === 0)
      return Qo = !0, s;
    a < 0 ? r = s + 1 : i = s - 1;
  }
  return Qo = !1, r - 1;
}
function Qj(e, t, r) {
  for (let i = r + 1; i < e.length && e[i][gs] === t; r = i++)
    ;
  return r;
}
function eq(e, t, r) {
  for (let i = r - 1; i >= 0 && e[i][gs] === t; r = i--)
    ;
  return r;
}
function tq() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function N6e(e, t, r, i) {
  let { lastKey: s, lastNeedle: a, lastIndex: o } = r, u = 0, l = e.length - 1;
  if (i === s) {
    if (t === a)
      return Qo = o !== -1 && e[o][gs] === t, o;
    t >= a ? u = o === -1 ? 0 : o : l = o;
  }
  return r.lastKey = i, r.lastNeedle = t, r.lastIndex = B6e(e, t, u, l);
}
function _C(e) {
  return typeof e == "string" ? JSON.parse(e) : e;
}
function rq(e, t, r, i, s, a, o, u, l, c, f) {
  let { sections: m } = e;
  for (let h = 0; h < m.length; h++) {
    let { map: d, offset: y } = m[h], p = c, g = f;
    if (h + 1 < m.length) {
      let b = m[h + 1].offset;
      p = Math.min(c, u + b.line), p === c ? g = Math.min(f, l + b.column) : p < c && (g = l + b.column);
    }
    R6e(
      d,
      t,
      r,
      i,
      s,
      a,
      o,
      u + y.line,
      l + y.column,
      p,
      g
    );
  }
}
function R6e(e, t, r, i, s, a, o, u, l, c, f) {
  let m = _C(e);
  if ("sections" in m) return rq(...arguments);
  let h = new Ln(m, t), d = i.length, y = a.length, p = bs(h), { resolvedSources: g, sourcesContent: b, ignoreList: D } = h;
  if (TC(i, g), TC(a, h.names), b) TC(s, b);
  else for (let x = 0; x < g.length; x++) s.push(null);
  if (D) for (let x = 0; x < D.length; x++) o.push(D[x] + d);
  for (let x = 0; x < p.length; x++) {
    let T = u + x;
    if (T > c) return;
    let w = L6e(r, T), B = x === 0 ? l : 0, k = p[x];
    for (let q = 0; q < k.length; q++) {
      let V = k[q], Y = B + V[gs];
      if (T === c && Y >= f) return;
      if (V.length === 1) {
        w.push([Y]);
        continue;
      }
      let G = d + V[CC], ye = V[wC], te = V[AC];
      w.push(
        V.length === 4 ? [Y, G, ye, te] : [Y, G, ye, te, y + V[Xj]]
      );
    }
  }
}
function TC(e, t) {
  for (let r = 0; r < t.length; r++) e.push(t[r]);
}
function L6e(e, t) {
  for (let r = e.length; r <= t; r++) e[r] = [];
  return e[t];
}
function nq(e) {
  var t, r;
  return (r = (t = e)._encoded) != null ? r : t._encoded = xy(e._decoded);
}
function bs(e) {
  var t;
  return (t = e)._decoded || (t._decoded = Hj(e._encoded));
}
function PC(e, t, r) {
  let i = bs(e);
  if (t >= i.length) return null;
  let s = i[t], a = Sy(
    s,
    e._decodedMemo,
    t,
    r,
    ep
  );
  return a === -1 ? null : s[a];
}
function j6e(e, t) {
  let { line: r, column: i, bias: s } = t;
  if (r--, r < 0) throw new Error(iq);
  if (i < 0) throw new Error(sq);
  let a = bs(e);
  if (r >= a.length) return Ey(null, null, null, null);
  let o = a[r], u = Sy(
    o,
    e._decodedMemo,
    r,
    i,
    s || ep
  );
  if (u === -1) return Ey(null, null, null, null);
  let l = o[u];
  if (l.length === 1) return Ey(null, null, null, null);
  let { names: c, resolvedSources: f } = e;
  return Ey(
    f[l[CC]],
    l[wC] + 1,
    l[AC],
    l.length === 5 ? c[l[Xj]] : null
  );
}
function q6e(e, t) {
  let { source: r, line: i, column: s, bias: a } = t;
  return uq(e, r, i, s, a || ep, !1);
}
function U6e(e, t) {
  let { source: r, line: i, column: s, bias: a } = t;
  return uq(e, r, i, s, a || Qd, !0);
}
function $6e(e, t) {
  let r = bs(e), { names: i, resolvedSources: s } = e;
  for (let a = 0; a < r.length; a++) {
    let o = r[a];
    for (let u = 0; u < o.length; u++) {
      let l = o[u], c = a + 1, f = l[0], m = null, h = null, d = null, y = null;
      l.length !== 1 && (m = s[l[1]], h = l[2] + 1, d = l[3]), l.length === 5 && (y = i[l[4]]), t({
        generatedLine: c,
        generatedColumn: f,
        source: m,
        originalLine: h,
        originalColumn: d,
        name: y
      });
    }
  }
}
function aq(e, t) {
  let { sources: r, resolvedSources: i } = e, s = r.indexOf(t);
  return s === -1 && (s = i.indexOf(t)), s;
}
function V6e(e, t) {
  let { sourcesContent: r } = e;
  if (r == null) return null;
  let i = aq(e, t);
  return i === -1 ? null : r[i];
}
function W6e(e, t) {
  let { ignoreList: r } = e;
  if (r == null) return !1;
  let i = aq(e, t);
  return i === -1 ? !1 : r.includes(i);
}
function oq(e, t) {
  let r = new Ln(FC(e, []), t);
  return r._decoded = e.mappings, r;
}
function H6e(e) {
  return FC(e, bs(e));
}
function K6e(e) {
  return FC(e, nq(e));
}
function FC(e, t) {
  return {
    version: e.version,
    file: e.file,
    names: e.names,
    sourceRoot: e.sourceRoot,
    sources: e.sources,
    sourcesContent: e.sourcesContent,
    mappings: t,
    ignoreList: e.ignoreList || e.x_google_ignoreList
  };
}
function Ey(e, t, r, i) {
  return { source: e, line: t, column: r, name: i };
}
function Zd(e, t) {
  return { line: e, column: t };
}
function Sy(e, t, r, i, s) {
  let a = N6e(e, i, t, r);
  return Qo ? a = (s === Qd ? Qj : eq)(e, i, a) : s === Qd && a++, a === -1 || a === e.length ? -1 : a;
}
function z6e(e, t, r, i, s) {
  let a = Sy(e, t, r, i, ep);
  if (!Qo && s === Qd && a++, a === -1 || a === e.length) return [];
  let o = Qo ? i : e[a][gs];
  Qo || (a = eq(e, o, a));
  let u = Qj(e, o, a), l = [];
  for (; a <= u; a++) {
    let c = e[a];
    l.push(Zd(c[Yj] + 1, c[Gj]));
  }
  return l;
}
function uq(e, t, r, i, s, a) {
  var o, u;
  if (r--, r < 0) throw new Error(iq);
  if (i < 0) throw new Error(sq);
  let { sources: l, resolvedSources: c } = e, f = l.indexOf(t);
  if (f === -1 && (f = c.indexOf(t)), f === -1) return a ? [] : Zd(null, null);
  let m = (o = e)._bySourceMemos || (o._bySourceMemos = l.map(tq)), d = ((u = e)._bySources || (u._bySources = k6e(bs(e), m)))[f][r];
  if (d == null) return a ? [] : Zd(null, null);
  let y = m[f];
  if (a) return z6e(d, y, r, i, s);
  let p = Sy(d, y, r, i, s);
  if (p === -1) return Zd(null, null);
  let g = d[p];
  return Zd(g[Yj] + 1, g[Gj]);
}
var Jj, gs, CC, wC, AC, Xj, Yj, Gj, Qo, M6e, iq, sq, Qd, ep, Ln, tp = ph(() => {
  xC();
  Jj = We(Kj(), 1);
  n(_6e, "stripFilename");
  n(P6e, "resolver");
  gs = 0, CC = 1, wC = 2, AC = 3, Xj = 4, Yj = 1, Gj = 2;
  n(F6e, "maybeSort");
  n(zj, "nextUnsortedSegmentLine");
  n(I6e, "isSorted");
  n(O6e, "sortSegments");
  n(Zj, "sortComparator");
  n(k6e, "buildBySources");
  Qo = !1;
  n(B6e, "binarySearch");
  n(Qj, "upperBound");
  n(eq, "lowerBound");
  n(tq, "memoizedState");
  n(N6e, "memoizedBinarySearch");
  n(_C, "parse");
  M6e = /* @__PURE__ */ n(function(e, t) {
    let r = _C(e);
    if (!("sections" in r))
      return new Ln(r, t);
    let i = [], s = [], a = [], o = [], u = [];
    rq(
      r,
      t,
      i,
      s,
      a,
      o,
      u,
      0,
      0,
      1 / 0,
      1 / 0
    );
    let l = {
      version: 3,
      file: r.file,
      names: o,
      sources: s,
      sourcesContent: a,
      mappings: i,
      ignoreList: u
    };
    return oq(l);
  }, "FlattenMap");
  n(rq, "recurse");
  n(R6e, "addSection");
  n(TC, "append");
  n(L6e, "getLine");
  iq = "`line` must be greater than 0 (lines start at line 1)", sq = "`column` must be greater than or equal to 0 (columns start at column 0\
)", Qd = -1, ep = 1, Ln = class {
    static {
      n(this, "TraceMap");
    }
    constructor(e, t) {
      let r = typeof e == "string";
      if (!r && e._decodedMemo) return e;
      let i = _C(e), { version: s, file: a, names: o, sourceRoot: u, sources: l, sourcesContent: c } = i;
      this.version = s, this.file = a, this.names = o || [], this.sourceRoot = u, this.sources = l, this.sourcesContent = c, this.ignoreList =
      i.ignoreList || i.x_google_ignoreList || void 0;
      let f = P6e(t, u);
      this.resolvedSources = l.map(f);
      let { mappings: m } = i;
      if (typeof m == "string")
        this._encoded = m, this._decoded = void 0;
      else if (Array.isArray(m))
        this._encoded = void 0, this._decoded = F6e(m, r);
      else throw i.sections ? new Error("TraceMap passed sectioned source map, please use FlattenMap export instead") : new Error(`invalid s\
ource map: ${JSON.stringify(i)}`);
      this._decodedMemo = tq(), this._bySources = void 0, this._bySourceMemos = void 0;
    }
  };
  n(nq, "encodedMappings");
  n(bs, "decodedMappings");
  n(PC, "traceSegment");
  n(j6e, "originalPositionFor");
  n(q6e, "generatedPositionFor");
  n(U6e, "allGeneratedPositionsFor");
  n($6e, "eachMapping");
  n(aq, "sourceIndex");
  n(V6e, "sourceContentFor");
  n(W6e, "isIgnored");
  n(oq, "presortedDecodedMap");
  n(H6e, "decodedMap");
  n(K6e, "encodedMap");
  n(FC, "clone");
  n(Ey, "OMapping");
  n(Zd, "GMapping");
  n(Sy, "traceSegmentInternal");
  n(z6e, "sliceGeneratedPositions");
  n(uq, "generatedPosition");
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs
var Dq = {};
hh(Dq, {
  GenMapping: () => Cy,
  addMapping: () => Y6e,
  addSegment: () => X6e,
  allMappings: () => Q6e,
  fromMap: () => Z6e,
  maybeAddMapping: () => G6e,
  maybeAddSegment: () => kC,
  setIgnore: () => NC,
  setSourceContent: () => BC,
  toDecodedMap: () => wy,
  toEncodedMap: () => MC
});
function fq(e, t) {
  return e._indexes[t];
}
function Xl(e, t) {
  let r = fq(e, t);
  if (r !== void 0) return r;
  let { array: i, _indexes: s } = e, a = i.push(t);
  return s[t] = a - 1;
}
function J6e(e, t) {
  let r = fq(e, t);
  if (r === void 0) return;
  let { array: i, _indexes: s } = e;
  for (let a = r + 1; a < i.length; a++) {
    let o = i[a];
    i[a - 1] = o, s[o]--;
  }
  s[t] = void 0, i.pop();
}
function X6e(e, t, r, i, s, a, o, u) {
  return Ty(
    !1,
    e,
    t,
    r,
    i,
    s,
    a,
    o,
    u
  );
}
function Y6e(e, t) {
  return bq(!1, e, t);
}
function BC(e, t, r) {
  let {
    _sources: i,
    _sourcesContent: s
    // _originalScopes: originalScopes,
  } = e, a = Xl(i, t);
  s[a] = r;
}
function NC(e, t, r = !0) {
  let {
    _sources: i,
    _sourcesContent: s,
    _ignoreList: a
    // _originalScopes: originalScopes,
  } = e, o = Xl(i, t);
  o === s.length && (s[o] = null), r ? Xl(a, o) : J6e(a, o);
}
function wy(e) {
  let {
    _mappings: t,
    _sources: r,
    _sourcesContent: i,
    _names: s,
    _ignoreList: a
    // _originalScopes: originalScopes,
    // _generatedRanges: generatedRanges,
  } = e;
  return rIe(t), {
    version: 3,
    file: e.file || void 0,
    names: s.array,
    sourceRoot: e.sourceRoot || void 0,
    sources: r.array,
    sourcesContent: i,
    mappings: t,
    // originalScopes,
    // generatedRanges,
    ignoreList: a.array
  };
}
function MC(e) {
  let t = wy(e);
  return Object.assign({}, t, {
    // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
    // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
    mappings: xy(t.mappings)
  });
}
function Z6e(e) {
  let t = new Ln(e), r = new Cy({ file: t.file, sourceRoot: t.sourceRoot });
  return OC(r._names, t.names), OC(r._sources, t.sources), r._sourcesContent = t.sourcesContent || t.sources.map(() => null), r._mappings = bs(
  t), t.ignoreList && OC(r._ignoreList, t.ignoreList), r;
}
function Q6e(e) {
  let t = [], { _mappings: r, _sources: i, _names: s } = e;
  for (let a = 0; a < r.length; a++) {
    let o = r[a];
    for (let u = 0; u < o.length; u++) {
      let l = o[u], c = { line: a + 1, column: l[dq] }, f, m, h;
      l.length !== 1 && (f = i.array[l[pq]], m = { line: l[hq] + 1, column: l[mq] }, l.length === 5 && (h = s.array[l[yq]])), t.push({ generated: c,
      source: f, original: m, name: h });
    }
  }
  return t;
}
function Ty(e, t, r, i, s, a, o, u, l) {
  let {
    _mappings: c,
    _sources: f,
    _sourcesContent: m,
    _names: h
    // _originalScopes: originalScopes,
  } = t, d = eIe(c, r), y = tIe(d, i);
  if (!s)
    return e && iIe(d, y) ? void 0 : cq(d, y, [i]);
  let p = Xl(f, s), g = u ? Xl(h, u) : gq;
  if (p === m.length && (m[p] = l ?? null), !(e && sIe(d, y, p, a, o, g)))
    return cq(
      d,
      y,
      u ? [i, p, a, o, g] : [i, p, a, o]
    );
}
function eIe(e, t) {
  for (let r = e.length; r <= t; r++)
    e[r] = [];
  return e[t];
}
function tIe(e, t) {
  let r = e.length;
  for (let i = r - 1; i >= 0; r = i--) {
    let s = e[i];
    if (t >= s[dq]) break;
  }
  return r;
}
function cq(e, t, r) {
  for (let i = e.length; i > t; i--)
    e[i] = e[i - 1];
  e[t] = r;
}
function rIe(e) {
  let { length: t } = e, r = t;
  for (let i = r - 1; i >= 0 && !(e[i].length > 0); r = i, i--)
    ;
  r < t && (e.length = r);
}
function OC(e, t) {
  for (let r = 0; r < t.length; r++) Xl(e, t[r]);
}
function iIe(e, t) {
  return t === 0 ? !0 : e[t - 1].length === 1;
}
function sIe(e, t, r, i, s, a) {
  if (t === 0) return !1;
  let o = e[t - 1];
  return o.length === 1 ? !1 : r === o[pq] && i === o[hq] && s === o[mq] && a === (o.length === 5 ? o[yq] : gq);
}
function bq(e, t, r) {
  let { generated: i, source: s, original: a, name: o, content: u } = r;
  return s ? Ty(
    e,
    t,
    i.line - 1,
    i.column,
    s,
    a.line - 1,
    a.column,
    o,
    u
  ) : Ty(
    e,
    t,
    i.line - 1,
    i.column,
    null,
    null,
    null,
    null,
    null
  );
}
var IC, dq, pq, hq, mq, yq, gq, Cy, kC, G6e, Ay = ph(() => {
  xC();
  tp();
  IC = class {
    static {
      n(this, "SetArray");
    }
    constructor() {
      this._indexes = { __proto__: null }, this.array = [];
    }
  };
  n(fq, "get");
  n(Xl, "put");
  n(J6e, "remove");
  dq = 0, pq = 1, hq = 2, mq = 3, yq = 4, gq = -1, Cy = class {
    static {
      n(this, "GenMapping");
    }
    constructor({ file: e, sourceRoot: t } = {}) {
      this._names = new IC(), this._sources = new IC(), this._sourcesContent = [], this._mappings = [], this.file = e, this.sourceRoot = t, this.
      _ignoreList = new IC();
    }
  };
  n(X6e, "addSegment");
  n(Y6e, "addMapping");
  kC = /* @__PURE__ */ n((e, t, r, i, s, a, o, u) => Ty(
    !0,
    e,
    t,
    r,
    i,
    s,
    a,
    o,
    u
  ), "maybeAddSegment"), G6e = /* @__PURE__ */ n((e, t) => bq(!0, e, t), "maybeAddMapping");
  n(BC, "setSourceContent");
  n(NC, "setIgnore");
  n(wy, "toDecodedMap");
  n(MC, "toEncodedMap");
  n(Z6e, "fromMap");
  n(Q6e, "allMappings");
  n(Ty, "addSegmentInternal");
  n(eIe, "getIndex");
  n(tIe, "getColumnIndex");
  n(cq, "insert");
  n(rIe, "removeEmptyFinalLines");
  n(OC, "putAll");
  n(iIe, "skipSourceless");
  n(sIe, "skipSource");
  n(bq, "addMappingInternal");
});

// ../node_modules/@babel/generator/lib/source-map.js
var vq = E((_y) => {
  "use strict";
  Object.defineProperty(_y, "__esModule", {
    value: !0
  });
  _y.default = void 0;
  var La = (Ay(), mh(Dq)), RC = (tp(), mh(lq)), LC = class {
    static {
      n(this, "SourceMap");
    }
    constructor(t, r) {
      var i;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = null;
      let s = this._map = new La.GenMapping({
        sourceRoot: t.sourceRoot
      });
      if (this._sourceFileName = (i = t.sourceFileName) == null ? void 0 : i.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
        this._inputMap = new RC.TraceMap(t.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let u = 0; u < o.length; u++) {
            var a;
            (0, La.setSourceContent)(s, o[u], (a = this._inputMap.sourcesContent) == null ? void 0 : a[u]);
          }
      }
      if (typeof r == "string" && !t.inputSourceMap)
        (0, La.setSourceContent)(s, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, La.setSourceContent)(s, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, La.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, La.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, La.allMappings)(this._map));
    }
    mark(t, r, i, s, a, o) {
      var u;
      this._rawMappings = void 0;
      let l;
      if (r != null)
        if (this._inputMap) {
          if (l = (0, RC.originalPositionFor)(this._inputMap, {
            line: r,
            column: i
          }), !l.name && a) {
            let c = (0, RC.originalPositionFor)(this._inputMap, a);
            c.name && (s = c.name);
          }
        } else
          l = {
            name: null,
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: i
          };
      (0, La.maybeAddMapping)(this._map, {
        name: s,
        generated: t,
        source: (u = l) == null ? void 0 : u.source,
        original: l
      });
    }
  };
  _y.default = LC;
});

// ../node_modules/@babel/generator/lib/buffer.js
var xq = E((Py) => {
  "use strict";
  Object.defineProperty(Py, "__esModule", {
    value: !0
  });
  Py.default = void 0;
  var jC = class {
    static {
      n(this, "Buffer");
    }
    constructor(t, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = t, this._indentChar = r;
      for (let i = 0; i < 64; i++)
        this._fastIndentations.push(r.repeat(i));
      this._allocQueue();
    }
    _allocQueue() {
      let t = this._queue;
      for (let r = 0; r < 16; r++)
        t.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(t, r, i, s, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let u = this._queue[o];
      u.char = t, u.repeat = r, u.line = i, u.column = s, u.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let t = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: t?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let i = t ? t.get() : null;
          return r.map = i, i;
        },
        set map(i) {
          Object.defineProperty(r, "map", {
            value: i,
            writable: !0
          });
        },
        get rawMappings() {
          let i = t?.getRawMappings();
          return r.rawMappings = i, i;
        },
        set rawMappings(i) {
          Object.defineProperty(r, "rawMappings", {
            value: i,
            writable: !0
          });
        }
      };
      return r;
    }
    append(t, r) {
      this._flush(), this._append(t, this._sourcePosition, r);
    }
    appendChar(t) {
      this._flush(), this._appendChar(t, 1, this._sourcePosition);
    }
    queue(t) {
      if (t === 10)
        for (; this._queueCursor !== 0; ) {
          let i = this._queue[this._queueCursor - 1].char;
          if (i !== 32 && i !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(t, 1, r.line, r.column, r.filename);
    }
    queueIndentation(t) {
      t !== 0 && this._pushQueue(-1, t, void 0, void 0, void 0);
    }
    _flush() {
      let t = this._queueCursor, r = this._queue;
      for (let i = 0; i < t; i++) {
        let s = r[i];
        this._appendChar(s.char, s.repeat, s);
      }
      this._queueCursor = 0;
    }
    _appendChar(t, r, i) {
      if (this._last = t, t === -1) {
        let s = this._fastIndentations[r];
        s !== void 0 ? this._str += s : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(t).repeat(r) : String.fromCharCode(t);
      t !== 10 ? (this._mark(i.line, i.column, i.identifierName, i.identifierNamePos, i.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (i.identifierName = void 0, i.identifierNamePos = void 0);
    }
    _append(t, r, i) {
      let s = t.length, a = this._position;
      if (this._last = t.charCodeAt(s - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount =
      0) : this._str += t, !i && !this._map) {
        a.column += s;
        return;
      }
      let {
        column: o,
        identifierName: u,
        identifierNamePos: l,
        filename: c
      } = r, f = r.line;
      (u != null || l != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let m = t.indexOf(`
`), h = 0;
      for (m !== 0 && this._mark(f, o, u, l, c); m !== -1; )
        a.line++, a.column = 0, h = m + 1, h < s && f !== void 0 && this._mark(++f, 0, void 0, void 0, c), m = t.indexOf(`
`, h);
      a.column += s - h;
    }
    _mark(t, r, i, s, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, t, r, i, s, a);
    }
    removeTrailingNewline() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let t = this._queueCursor;
      return t !== 0 ? this._queue[t - 1].char : this._last;
    }
    getNewlineCount() {
      let t = this._queueCursor, r = 0;
      if (t === 0) return this._last === 10 ? 1 : 0;
      for (let i = t - 1; i >= 0 && this._queue[i].char === 10; i--)
        r++;
      return r === t && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let t = this._queue, r = this._queueCursor;
      if (r !== 0)
        return t[r - 1].char !== 10 ? void 0 : r > 1 ? t[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(t, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", t);
      let i = t.identifierName, s = this._sourcePosition;
      i && (this._canMarkIdName = !1, s.identifierName = i), r(), i && (this._canMarkIdName = !0, s.identifierName = void 0, s.identifierNamePos =
      void 0), this.source("end", t);
    }
    source(t, r) {
      this._map && this._normalizePosition(t, r, 0);
    }
    sourceWithOffset(t, r, i) {
      this._map && this._normalizePosition(t, r, i);
    }
    _normalizePosition(t, r, i) {
      let s = r[t], a = this._sourcePosition;
      s && (a.line = s.line, a.column = Math.max(s.column + i, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let t = this._queue, r = this._queueCursor, i = -1, s = 0;
      for (let a = 0; a < r; a++) {
        let o = t[a];
        o.char === 10 && (i = s), s += o.repeat;
      }
      return i === -1 ? this._position.column + s : s - 1 - i;
    }
    getCurrentLine() {
      let t = 0, r = this._queue;
      for (let i = 0; i < this._queueCursor; i++)
        r[i].char === 10 && t++;
      return this._position.line + t;
    }
  };
  Py.default = jC;
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var wq = E((Iy) => {
  "use strict";
  Object.defineProperty(Iy, "__esModule", {
    value: !0
  });
  Iy.nodes = void 0;
  var nIe = Pe(), {
    FLIPPED_ALIAS_KEYS: aIe,
    isArrayExpression: oIe,
    isAssignmentExpression: Sq,
    isBinary: Tq,
    isBlockStatement: uIe,
    isCallExpression: Cq,
    isFunction: rp,
    isIdentifier: Fy,
    isLiteral: lIe,
    isMemberExpression: qC,
    isObjectExpression: cIe,
    isOptionalCallExpression: fIe,
    isOptionalMemberExpression: dIe,
    isStringLiteral: pIe
  } = nIe;
  function Yl(e, t) {
    return e && (qC(e) || dIe(e) ? (Yl(e.object, t), e.computed && Yl(e.property, t)) : Tq(e) || Sq(e) ? (Yl(e.left, t), Yl(e.right, t)) : Cq(
    e) || fIe(e) ? (t.hasCall = !0, Yl(e.callee, t)) : rp(e) ? t.hasFunction = !0 : Fy(e) && (t.hasHelper = t.hasHelper || e.callee && jn(e.
    callee))), t;
  }
  n(Yl, "crawlInternal");
  function Eq(e) {
    return Yl(e, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  n(Eq, "crawl");
  function jn(e) {
    return e ? qC(e) ? jn(e.object) || jn(e.property) : Fy(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : Cq(e) ? jn(e.callee) :
    Tq(e) || Sq(e) ? Fy(e.left) && jn(e.left) || jn(e.right) : !1 : !1;
  }
  n(jn, "isHelper");
  function hIe(e) {
    return lIe(e) || cIe(e) || oIe(e) || Fy(e) || qC(e);
  }
  n(hIe, "isType");
  var eu = Iy.nodes = {
    AssignmentExpression(e) {
      let t = Eq(e.right);
      return t.hasCall && t.hasHelper || t.hasFunction ? t.hasFunction ? 3 : 2 : 0;
    },
    SwitchCase(e, t) {
      return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
    },
    LogicalExpression(e) {
      return rp(e.left) || rp(e.right) ? 2 : 0;
    },
    Literal(e) {
      return pIe(e) && e.value === "use strict" ? 2 : 0;
    },
    CallExpression(e) {
      return rp(e.callee) || jn(e) ? 3 : 0;
    },
    OptionalCallExpression(e) {
      return rp(e.callee) ? 3 : 0;
    },
    VariableDeclaration(e) {
      for (let t = 0; t < e.declarations.length; t++) {
        let r = e.declarations[t], i = jn(r.id) && !hIe(r.init);
        if (!i && r.init) {
          let s = Eq(r.init);
          i = jn(r.init) && s.hasCall || s.hasFunction;
        }
        if (i)
          return 3;
      }
      return 0;
    },
    IfStatement(e) {
      return uIe(e.consequent) ? 3 : 0;
    }
  };
  eu.ObjectProperty = eu.ObjectTypeProperty = eu.ObjectMethod = function(e, t) {
    return t.properties[0] === e ? 1 : 0;
  };
  eu.ObjectTypeCallProperty = function(e, t) {
    var r;
    return t.callProperties[0] === e && !((r = t.properties) != null && r.length) ? 1 : 0;
  };
  eu.ObjectTypeIndexer = function(e, t) {
    var r, i;
    return t.indexers[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length) ? 1 : 0;
  };
  eu.ObjectTypeInternalSlot = function(e, t) {
    var r, i, s;
    return t.internalSlots[0] === e && !((r = t.properties) != null && r.length) && !((i = t.callProperties) != null && i.length) && !((s = t.
    indexers) != null && s.length) ? 1 : 0;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  e, t]) {
    [e].concat(aIe[e] || []).forEach(function(r) {
      let i = t ? 3 : 0;
      eu[r] = () => i;
    });
  });
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var Bq = E((Ze) => {
  "use strict";
  Object.defineProperty(Ze, "__esModule", {
    value: !0
  });
  Ze.AssignmentExpression = KIe;
  Ze.Binary = Iq;
  Ze.BinaryExpression = qIe;
  Ze.ClassExpression = VIe;
  Ze.ArrowFunctionExpression = Ze.ConditionalExpression = kq;
  Ze.DoExpression = PIe;
  Ze.FunctionExpression = WIe;
  Ze.FunctionTypeAnnotation = wIe;
  Ze.Identifier = JIe;
  Ze.LogicalExpression = zIe;
  Ze.NullableTypeAnnotation = CIe;
  Ze.ObjectExpression = _Ie;
  Ze.OptionalIndexedAccessType = IIe;
  Ze.OptionalCallExpression = Ze.OptionalMemberExpression = HIe;
  Ze.SequenceExpression = UIe;
  Ze.TSSatisfiesExpression = Ze.TSAsExpression = OIe;
  Ze.TSConditionalType = kIe;
  Ze.TSConstructorType = Ze.TSFunctionType = jIe;
  Ze.TSInferType = MIe;
  Ze.TSInstantiationExpression = LIe;
  Ze.TSIntersectionType = NIe;
  Ze.UnaryLike = Ze.TSTypeAssertion = Oq;
  Ze.TSTypeOperator = RIe;
  Ze.TSUnionType = BIe;
  Ze.IntersectionTypeAnnotation = Ze.UnionTypeAnnotation = FIe;
  Ze.UpdateExpression = AIe;
  Ze.AwaitExpression = Ze.YieldExpression = $Ie;
  var mIe = Pe(), wi = tu(), {
    isArrayTypeAnnotation: yIe,
    isBinaryExpression: gIe,
    isCallExpression: bIe,
    isForOfStatement: DIe,
    isIndexedAccessType: vIe,
    isMemberExpression: Pq,
    isObjectPattern: xIe,
    isOptionalMemberExpression: EIe,
    isYieldExpression: SIe,
    isStatement: TIe
  } = mIe, Aq = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["\
!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function _q(e, t) {
    if (t === "BinaryExpression" || t === "LogicalExpression")
      return Aq.get(e.operator);
    if (t === "TSAsExpression" || t === "TSSatisfiesExpression")
      return Aq.get("in");
  }
  n(_q, "getBinaryPrecedence");
  function UC(e) {
    return e === "TSAsExpression" || e === "TSSatisfiesExpression" || e === "TSTypeAssertion";
  }
  n(UC, "isTSTypeExpression");
  var Oy = /* @__PURE__ */ n((e, t) => {
    let r = t.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && t.superClass === e;
  }, "isClassExtendsClause"), ky = /* @__PURE__ */ n((e, t) => {
    let r = t.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && t.object === e || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && t.callee === e || r === "TaggedTemplateExpression" && t.tag === e || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function CIe(e, t) {
    return yIe(t);
  }
  n(CIe, "NullableTypeAnnotation");
  function wIe(e, t, r) {
    let i = t.type;
    return i === "UnionTypeAnnotation" || i === "IntersectionTypeAnnotation" || i === "ArrayTypeAnnotation" || !!(r & wi.TokenContext.arrowFlowReturnType);
  }
  n(wIe, "FunctionTypeAnnotation");
  function AIe(e, t) {
    return ky(e, t) || Oy(e, t);
  }
  n(AIe, "UpdateExpression");
  function Fq(e) {
    return !!(e & (wi.TokenContext.expressionStatement | wi.TokenContext.arrowBody));
  }
  n(Fq, "needsParenBeforeExpressionBrace");
  function _Ie(e, t, r) {
    return Fq(r);
  }
  n(_Ie, "ObjectExpression");
  function PIe(e, t, r) {
    return !e.async && !!(r & wi.TokenContext.expressionStatement);
  }
  n(PIe, "DoExpression");
  function Iq(e, t) {
    let r = t.type;
    if (e.type === "BinaryExpression" && e.operator === "**" && r === "BinaryExpression" && t.operator === "**")
      return t.left === e;
    if (Oy(e, t) || ky(e, t) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    let i = _q(t, r);
    if (i != null) {
      let s = _q(e, e.type);
      if (i === s && r === "BinaryExpression" && t.right === e || i > s)
        return !0;
    }
  }
  n(Iq, "Binary");
  function FIe(e, t) {
    let r = t.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  n(FIe, "UnionTypeAnnotation");
  function IIe(e, t) {
    return vIe(t) && t.objectType === e;
  }
  n(IIe, "OptionalIndexedAccessType");
  function OIe(e, t) {
    return (t.type === "AssignmentExpression" || t.type === "AssignmentPattern") && t.left === e || t.type === "BinaryExpression" && (t.operator ===
    "|" || t.operator === "&") && e === t.left ? !0 : Iq(e, t);
  }
  n(OIe, "TSAsExpression");
  function kIe(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType" || r === "TSTypeOperator" || r ===
    "TSTypeParameter" || (r === "TSIntersectionType" || r === "TSUnionType") && t.types[0] === e || r === "TSConditionalType" && (t.checkType ===
    e || t.extendsType === e);
  }
  n(kIe, "TSConditionalType");
  function BIe(e, t) {
    let r = t.type;
    return r === "TSIntersectionType" || r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e ||
    r === "TSOptionalType";
  }
  n(BIe, "TSUnionType");
  function NIe(e, t) {
    let r = t.type;
    return r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType";
  }
  n(NIe, "TSIntersectionType");
  function MIe(e, t) {
    let r = t.type;
    return !!(r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType" || e.typeParameter.constraint &&
    (r === "TSIntersectionType" || r === "TSUnionType") && t.types[0] === e);
  }
  n(MIe, "TSInferType");
  function RIe(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType";
  }
  n(RIe, "TSTypeOperator");
  function LIe(e, t) {
    let r = t.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!t.typeParameters;
  }
  n(LIe, "TSInstantiationExpression");
  function jIe(e, t) {
    let r = t.type;
    return r === "TSIntersectionType" || r === "TSUnionType" || r === "TSTypeOperator" || r === "TSOptionalType" || r === "TSArrayType" || r ===
    "TSIndexedAccessType" && t.objectType === e || r === "TSConditionalType" && (t.checkType === e || t.extendsType === e);
  }
  n(jIe, "TSFunctionType");
  function qIe(e, t, r) {
    return e.operator === "in" && !!(r & wi.TokenContext.forInOrInitHeadAccumulate);
  }
  n(qIe, "BinaryExpression");
  function UIe(e, t) {
    let r = t.type;
    return r === "SequenceExpression" || r === "ParenthesizedExpression" || r === "MemberExpression" && t.property === e || r === "OptionalM\
emberExpression" && t.property === e || r === "TemplateLiteral" ? !1 : r === "ClassDeclaration" ? !0 : r === "ForOfStatement" ? t.right === e :
    r === "ExportDefaultDeclaration" ? !0 : !TIe(t);
  }
  n(UIe, "SequenceExpression");
  function $Ie(e, t) {
    let r = t.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || ky(e, t) || r === "A\
waitExpression" && SIe(e) || r === "ConditionalExpression" && e === t.test || Oy(e, t) || UC(r);
  }
  n($Ie, "YieldExpression");
  function VIe(e, t, r) {
    return !!(r & (wi.TokenContext.expressionStatement | wi.TokenContext.exportDefault));
  }
  n(VIe, "ClassExpression");
  function Oq(e, t) {
    return ky(e, t) || gIe(t) && t.operator === "**" && t.left === e || Oy(e, t);
  }
  n(Oq, "UnaryLike");
  function WIe(e, t, r) {
    return !!(r & (wi.TokenContext.expressionStatement | wi.TokenContext.exportDefault));
  }
  n(WIe, "FunctionExpression");
  function kq(e, t) {
    let r = t.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && t.test === e || r === "AwaitExpression" || UC(r) ? !0 : Oq(e, t);
  }
  n(kq, "ConditionalExpression");
  function HIe(e, t) {
    return bIe(t) && t.callee === e || Pq(t) && t.object === e;
  }
  n(HIe, "OptionalMemberExpression");
  function KIe(e, t, r) {
    return Fq(r) && xIe(e.left) ? !0 : kq(e, t);
  }
  n(KIe, "AssignmentExpression");
  function zIe(e, t) {
    let r = t.type;
    if (UC(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (e.operator) {
      case "||":
        return t.operator === "??" || t.operator === "&&";
      case "&&":
        return t.operator === "??";
      case "??":
        return t.operator !== "??";
    }
  }
  n(zIe, "LogicalExpression");
  function JIe(e, t, r, i) {
    var s;
    let a = t.type;
    if ((s = e.extra) != null && s.parenthesized && a === "AssignmentExpression" && t.left === e) {
      let o = t.right.type;
      if ((o === "FunctionExpression" || o === "ClassExpression") && t.right.id == null)
        return !0;
    }
    return i && i(e) !== e.name ? !1 : e.name === "let" ? (Pq(t, {
      object: e,
      computed: !0
    }) || EIe(t, {
      object: e,
      computed: !0,
      optional: !1
    })) && r & (wi.TokenContext.expressionStatement | wi.TokenContext.forInitHead | wi.TokenContext.forInHead) ? !0 : !!(r & wi.TokenContext.
    forOfHead) : e.name === "async" && DIe(t, {
      left: e,
      await: !1
    });
  }
  n(JIe, "Identifier");
});

// ../node_modules/@babel/generator/lib/node/index.js
var tu = E((qn) => {
  "use strict";
  Object.defineProperty(qn, "__esModule", {
    value: !0
  });
  qn.TokenContext = void 0;
  qn.isLastChild = c5e;
  qn.needsParens = l5e;
  qn.needsWhitespace = VC;
  qn.needsWhitespaceAfter = u5e;
  qn.needsWhitespaceBefore = o5e;
  var XIe = wq(), YIe = Bq(), GIe = Pe(), {
    FLIPPED_ALIAS_KEYS: ZIe,
    VISITOR_KEYS: QIe,
    isCallExpression: Nq,
    isDecorator: e5e,
    isExpressionStatement: t5e,
    isMemberExpression: r5e,
    isNewExpression: i5e,
    isParenthesizedExpression: s5e
  } = GIe, H1t = qn.TokenContext = {
    normal: 0,
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    arrowFlowReturnType: 8,
    forInitHead: 16,
    forInHead: 32,
    forOfHead: 64,
    forInOrInitHeadAccumulate: 128,
    forInOrInitHeadAccumulatePassThroughMask: 128
  };
  function Mq(e) {
    let t = /* @__PURE__ */ new Map();
    function r(i, s) {
      let a = t.get(i);
      t.set(i, a ? function(o, u, l, c) {
        var f;
        return (f = a(o, u, l, c)) != null ? f : s(o, u, l, c);
      } : s);
    }
    n(r, "add");
    for (let i of Object.keys(e)) {
      let s = ZIe[i];
      if (s)
        for (let a of s)
          r(a, e[i]);
      else
        r(i, e[i]);
    }
    return t;
  }
  n(Mq, "expandAliases");
  var n5e = Mq(YIe), a5e = Mq(XIe.nodes);
  function Rq(e) {
    return Nq(e) ? !0 : r5e(e) && Rq(e.object);
  }
  n(Rq, "isOrHasCallExpression");
  function VC(e, t, r) {
    var i;
    if (!e) return !1;
    t5e(e) && (e = e.expression);
    let s = (i = a5e.get(e.type)) == null ? void 0 : i(e, t);
    return typeof s == "number" ? (s & r) !== 0 : !1;
  }
  n(VC, "needsWhitespace");
  function o5e(e, t) {
    return VC(e, t, 1);
  }
  n(o5e, "needsWhitespaceBefore");
  function u5e(e, t) {
    return VC(e, t, 2);
  }
  n(u5e, "needsWhitespaceAfter");
  function l5e(e, t, r, i) {
    var s;
    return t ? i5e(t) && t.callee === e && Rq(e) ? !0 : e5e(t) ? !$C(e) && !(Nq(e) && $C(e.callee)) && !s5e(e) : ((s = n5e.get(e.type)) == null ?
    void 0 : s(e, t, r, i)) || !1 : !1;
  }
  n(l5e, "needsParens");
  function $C(e) {
    switch (e.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !e.computed && e.property.type === "Identifier" && $C(e.object);
      default:
        return !1;
    }
  }
  n($C, "isDecoratorMemberExpression");
  function c5e(e, t) {
    let r = QIe[e.type];
    for (let i = r.length - 1; i >= 0; i--) {
      let s = e[r[i]];
      if (s === t)
        return !0;
      if (Array.isArray(s)) {
        let a = s.length - 1;
        for (; a >= 0 && s[a] === null; ) a--;
        return a >= 0 && s[a] === t;
      } else if (s)
        return !1;
    }
    return !1;
  }
  n(c5e, "isLastChild");
});

// ../node_modules/@babel/generator/lib/token-map.js
var Lq = E((By) => {
  "use strict";
  Object.defineProperty(By, "__esModule", {
    value: !0
  });
  By.TokenMap = void 0;
  var f5e = Pe(), {
    traverseFast: d5e,
    VISITOR_KEYS: p5e
  } = f5e, WC = class {
    static {
      n(this, "TokenMap");
    }
    constructor(t, r, i) {
      this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache =
      /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = r, this._source = i, d5e(t, (s) => {
        let a = this._getTokensIndexesOfNode(s);
        a.length > 0 && this._nodesToTokenIndexes.set(s, a);
      }), this._tokensCache.clear();
    }
    has(t) {
      return this._nodesToTokenIndexes.has(t);
    }
    getIndexes(t) {
      return this._nodesToTokenIndexes.get(t);
    }
    find(t, r) {
      let i = this._nodesToTokenIndexes.get(t);
      if (i)
        for (let s = 0; s < i.length; s++) {
          let a = i[s], o = this._tokens[a];
          if (r(o, a)) return o;
        }
      return null;
    }
    findLastIndex(t, r) {
      let i = this._nodesToTokenIndexes.get(t);
      if (i)
        for (let s = i.length - 1; s >= 0; s--) {
          let a = i[s], o = this._tokens[a];
          if (r(o, a)) return a;
        }
      return -1;
    }
    findMatching(t, r, i = 0) {
      let s = this._nodesToTokenIndexes.get(t);
      if (s) {
        let a = 0, o = i;
        if (o > 1) {
          let u = this._nodesOccurrencesCountCache.get(t);
          u && u.test === r && u.count < o && (a = u.i + 1, i -= u.count + 1);
        }
        for (; a < s.length; a++) {
          let u = this._tokens[s[a]];
          if (this.matchesOriginal(u, r)) {
            if (i === 0)
              return o > 0 && this._nodesOccurrencesCountCache.set(t, {
                test: r,
                count: o,
                i: a
              }), u;
            i--;
          }
        }
      }
      return null;
    }
    matchesOriginal(t, r) {
      return t.end - t.start !== r.length ? !1 : t.value != null ? t.value === r : this._source.startsWith(r, t.start);
    }
    startMatches(t, r) {
      let i = this._nodesToTokenIndexes.get(t);
      if (!i) return !1;
      let s = this._tokens[i[0]];
      return s.start !== t.start ? !1 : this.matchesOriginal(s, r);
    }
    endMatches(t, r) {
      let i = this._nodesToTokenIndexes.get(t);
      if (!i) return !1;
      let s = this._tokens[i[i.length - 1]];
      return s.end !== t.end ? !1 : this.matchesOriginal(s, r);
    }
    _getTokensIndexesOfNode(t) {
      if (t.start == null || t.end == null) return [];
      let {
        first: r,
        last: i
      } = this._findTokensOfNode(t, 0, this._tokens.length - 1), s = r, a = h5e(t);
      (t.type === "ExportNamedDeclaration" || t.type === "ExportDefaultDeclaration") && t.declaration && t.declaration.type === "ClassDeclar\
ation" && a.next();
      let o = [];
      for (let u of a) {
        if (u == null || u.start == null || u.end == null) continue;
        let l = this._findTokensOfNode(u, s, i), c = l.first;
        for (let f = s; f < c; f++) o.push(f);
        s = l.last + 1;
      }
      for (let u = s; u <= i; u++) o.push(u);
      return o;
    }
    _findTokensOfNode(t, r, i) {
      let s = this._tokensCache.get(t);
      if (s) return s;
      let a = this._findFirstTokenOfNode(t.start, r, i), o = this._findLastTokenOfNode(t.end, a, i);
      return this._tokensCache.set(t, {
        first: a,
        last: o
      }), {
        first: a,
        last: o
      };
    }
    _findFirstTokenOfNode(t, r, i) {
      for (; r <= i; ) {
        let s = i + r >> 1;
        if (t < this._tokens[s].start)
          i = s - 1;
        else if (t > this._tokens[s].start)
          r = s + 1;
        else
          return s;
      }
      return r;
    }
    _findLastTokenOfNode(t, r, i) {
      for (; r <= i; ) {
        let s = i + r >> 1;
        if (t < this._tokens[s].end)
          i = s - 1;
        else if (t > this._tokens[s].end)
          r = s + 1;
        else
          return s;
      }
      return i;
    }
  };
  By.TokenMap = WC;
  function* h5e(e) {
    if (e.type === "TemplateLiteral") {
      yield e.quasis[0];
      for (let r = 1; r < e.quasis.length; r++)
        yield e.expressions[r - 1], yield e.quasis[r];
      return;
    }
    let t = p5e[e.type];
    for (let r of t) {
      let i = e[r];
      i && (Array.isArray(i) ? yield* i : yield i);
    }
  }
  n(h5e, "childrenIterator");
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var jq = E((Gl) => {
  "use strict";
  Object.defineProperty(Gl, "__esModule", {
    value: !0
  });
  Gl.TaggedTemplateExpression = m5e;
  Gl.TemplateElement = y5e;
  Gl.TemplateLiteral = b5e;
  Gl._printTemplate = g5e;
  function m5e(e) {
    this.print(e.tag), this.print(e.typeParameters), this.print(e.quasi);
  }
  n(m5e, "TaggedTemplateExpression");
  function y5e() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  n(y5e, "TemplateElement");
  function g5e(e, t) {
    let r = e.quasis, i = "`";
    for (let s = 0; s < r.length - 1; s++)
      if (i += r[s].value.raw, this.token(i + "${", !0), this.print(t[s]), i = "}", this.tokenMap) {
        let a = this.tokenMap.findMatching(e, "}", s);
        a && this._catchUpTo(a.loc.start);
      }
    i += r[r.length - 1].value.raw, this.token(i + "`", !0);
  }
  n(g5e, "_printTemplate");
  function b5e(e) {
    this._printTemplate(e, e.expressions);
  }
  n(b5e, "TemplateLiteral");
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var Uq = E((ht) => {
  "use strict";
  Object.defineProperty(ht, "__esModule", {
    value: !0
  });
  ht.LogicalExpression = ht.BinaryExpression = ht.AssignmentExpression = W5e;
  ht.AssignmentPattern = V5e;
  ht.AwaitExpression = j5e;
  ht.BindExpression = H5e;
  ht.CallExpression = R5e;
  ht.ConditionalExpression = _5e;
  ht.Decorator = B5e;
  ht.DoExpression = C5e;
  ht.EmptyStatement = U5e;
  ht.ExpressionStatement = $5e;
  ht.Import = L5e;
  ht.MemberExpression = K5e;
  ht.MetaProperty = z5e;
  ht.ModuleExpression = Y5e;
  ht.NewExpression = P5e;
  ht.OptionalCallExpression = M5e;
  ht.OptionalMemberExpression = N5e;
  ht.ParenthesizedExpression = w5e;
  ht.PrivateName = J5e;
  ht.SequenceExpression = F5e;
  ht.Super = O5e;
  ht.ThisExpression = I5e;
  ht.UnaryExpression = T5e;
  ht.UpdateExpression = A5e;
  ht.V8IntrinsicIdentifier = X5e;
  ht.YieldExpression = q5e;
  ht._shouldPrintDecoratorsBeforeExport = k5e;
  var D5e = Pe(), v5e = tu(), {
    isCallExpression: x5e,
    isLiteral: qq,
    isMemberExpression: HC,
    isNewExpression: E5e,
    isPattern: S5e
  } = D5e;
  function T5e(e) {
    let {
      operator: t
    } = e;
    t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument);
  }
  n(T5e, "UnaryExpression");
  function C5e(e) {
    e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body);
  }
  n(C5e, "DoExpression");
  function w5e(e) {
    this.tokenChar(40);
    let t = this.enterDelimited();
    this.print(e.expression), t(), this.rightParens(e);
  }
  n(w5e, "ParenthesizedExpression");
  function A5e(e) {
    e.prefix ? (this.token(e.operator), this.print(e.argument)) : (this.print(e.argument, !0), this.token(e.operator));
  }
  n(A5e, "UpdateExpression");
  function _5e(e) {
    this.print(e.test), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent), this.space(), this.tokenChar(58), this.space(),
    this.print(e.alternate);
  }
  n(_5e, "ConditionalExpression");
  function P5e(e, t) {
    if (this.word("new"), this.space(), this.print(e.callee), this.format.minified && e.arguments.length === 0 && !e.optional && !x5e(t, {
      callee: e
    }) && !HC(t) && !E5e(t) || (this.print(e.typeArguments), this.print(e.typeParameters), e.optional && this.token("?."), e.arguments.length ===
    0 && this.tokenMap && !this.tokenMap.endMatches(e, ")")))
      return;
    this.tokenChar(40);
    let r = this.enterDelimited();
    this.printList(e.arguments, this.shouldPrintTrailingComma(")")), r(), this.rightParens(e);
  }
  n(P5e, "NewExpression");
  function F5e(e) {
    this.printList(e.expressions);
  }
  n(F5e, "SequenceExpression");
  function I5e() {
    this.word("this");
  }
  n(I5e, "ThisExpression");
  function O5e() {
    this.word("super");
  }
  n(O5e, "Super");
  function k5e(e) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start ===
    e.declaration.start;
  }
  n(k5e, "_shouldPrintDecoratorsBeforeExport");
  function B5e(e) {
    this.tokenChar(64), this.print(e.expression), this.newline();
  }
  n(B5e, "Decorator");
  function N5e(e) {
    let {
      computed: t
    } = e, {
      optional: r,
      property: i
    } = e;
    if (this.print(e.object), !t && HC(i))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    qq(i) && typeof i.value == "number" && (t = !0), r && this.token("?."), t ? (this.tokenChar(91), this.print(i), this.tokenChar(93)) : (r ||
    this.tokenChar(46), this.print(i));
  }
  n(N5e, "OptionalMemberExpression");
  function M5e(e) {
    this.print(e.callee), this.print(e.typeParameters), e.optional && this.token("?."), this.print(e.typeArguments), this.tokenChar(40);
    let t = this.enterDelimited();
    this.printList(e.arguments), t(), this.rightParens(e);
  }
  n(M5e, "OptionalCallExpression");
  function R5e(e) {
    this.print(e.callee), this.print(e.typeArguments), this.print(e.typeParameters), this.tokenChar(40);
    let t = this.enterDelimited();
    this.printList(e.arguments, this.shouldPrintTrailingComma(")")), t(), this.rightParens(e);
  }
  n(R5e, "CallExpression");
  function L5e() {
    this.word("import");
  }
  n(L5e, "Import");
  function j5e(e) {
    this.word("await"), this.space(), this.print(e.argument);
  }
  n(j5e, "AwaitExpression");
  function q5e(e) {
    e.delegate ? (this.word("yield", !0), this.tokenChar(42), e.argument && (this.space(), this.print(e.argument))) : e.argument ? (this.word(
    "yield", !0), this.space(), this.print(e.argument)) : this.word("yield");
  }
  n(q5e, "YieldExpression");
  function U5e() {
    this.semicolon(!0);
  }
  n(U5e, "EmptyStatement");
  function $5e(e) {
    this.tokenContext |= v5e.TokenContext.expressionStatement, this.print(e.expression), this.semicolon();
  }
  n($5e, "ExpressionStatement");
  function V5e(e) {
    this.print(e.left), (e.left.type === "Identifier" || S5e(e.left)) && (e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation)),
    this.space(), this.tokenChar(61), this.space(), this.print(e.right);
  }
  n(V5e, "AssignmentPattern");
  function W5e(e) {
    this.print(e.left), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) : (this.token(e.operator), this.
    _endsWithDiv = e.operator === "/"), this.space(), this.print(e.right);
  }
  n(W5e, "AssignmentExpression");
  function H5e(e) {
    this.print(e.object), this.token("::"), this.print(e.callee);
  }
  n(H5e, "BindExpression");
  function K5e(e) {
    if (this.print(e.object), !e.computed && HC(e.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let t = e.computed;
    if (qq(e.property) && typeof e.property.value == "number" && (t = !0), t) {
      let r = this.enterDelimited();
      this.tokenChar(91), this.print(e.property), this.tokenChar(93), r();
    } else
      this.tokenChar(46), this.print(e.property);
  }
  n(K5e, "MemberExpression");
  function z5e(e) {
    this.print(e.meta), this.tokenChar(46), this.print(e.property);
  }
  n(z5e, "MetaProperty");
  function J5e(e) {
    this.tokenChar(35), this.print(e.id);
  }
  n(J5e, "PrivateName");
  function X5e(e) {
    this.tokenChar(37), this.word(e.name);
  }
  n(X5e, "V8IntrinsicIdentifier");
  function Y5e(e) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: t
    } = e;
    (t.body.length || t.directives.length) && this.newline(), this.print(t), this.dedent(), this.rightBrace(e);
  }
  n(Y5e, "ModuleExpression");
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var Hq = E((Ht) => {
  "use strict";
  Object.defineProperty(Ht, "__esModule", {
    value: !0
  });
  Ht.BreakStatement = a7e;
  Ht.CatchClause = d7e;
  Ht.ContinueStatement = o7e;
  Ht.DebuggerStatement = m7e;
  Ht.DoWhileStatement = n7e;
  Ht.ForOfStatement = Ht.ForInStatement = void 0;
  Ht.ForStatement = i7e;
  Ht.IfStatement = r7e;
  Ht.LabeledStatement = c7e;
  Ht.ReturnStatement = u7e;
  Ht.SwitchCase = h7e;
  Ht.SwitchStatement = p7e;
  Ht.ThrowStatement = l7e;
  Ht.TryStatement = f7e;
  Ht.VariableDeclaration = y7e;
  Ht.VariableDeclarator = g7e;
  Ht.WhileStatement = s7e;
  Ht.WithStatement = t7e;
  var G5e = Pe(), {
    isFor: $q,
    isForStatement: Z5e,
    isIfStatement: Q5e,
    isStatement: e7e
  } = G5e;
  function t7e(e) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(e.object), this.tokenChar(41), this.printBlock(e);
  }
  n(t7e, "WithStatement");
  function r7e(e) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(e.test), this.tokenChar(41), this.space();
    let t = e.alternate && Q5e(Vq(e.consequent));
    t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent), t && (this.dedent(), this.newline(),
    this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    e.alternate));
  }
  n(r7e, "IfStatement");
  function Vq(e) {
    let {
      body: t
    } = e;
    return e7e(t) === !1 ? e : Vq(t);
  }
  n(Vq, "getLastStatement");
  function i7e(e) {
    this.word("for"), this.space(), this.tokenChar(40);
    {
      let t = this.enterForStatementInit();
      this.print(e.init), t();
    }
    this.tokenChar(59), e.test && (this.space(), this.print(e.test)), this.token(";", !1, 1), e.update && (this.space(), this.print(e.update)),
    this.tokenChar(41), this.printBlock(e);
  }
  n(i7e, "ForStatement");
  function s7e(e) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(e.test), this.tokenChar(41), this.printBlock(e);
  }
  n(s7e, "WhileStatement");
  function Wq(e) {
    this.word("for"), this.space();
    let t = e.type === "ForOfStatement";
    t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
    {
      let r = this.enterForXStatementInit(t);
      this.print(e.left), r?.();
    }
    this.space(), this.word(t ? "of" : "in"), this.space(), this.print(e.right), this.tokenChar(41), this.printBlock(e);
  }
  n(Wq, "ForXStatement");
  var egt = Ht.ForInStatement = Wq, tgt = Ht.ForOfStatement = Wq;
  function n7e(e) {
    this.word("do"), this.space(), this.print(e.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test),
    this.tokenChar(41), this.semicolon();
  }
  n(n7e, "DoWhileStatement");
  function Ny(e, t) {
    t && (e.space(), e.printTerminatorless(t)), e.semicolon();
  }
  n(Ny, "printStatementAfterKeyword");
  function a7e(e) {
    this.word("break"), Ny(this, e.label);
  }
  n(a7e, "BreakStatement");
  function o7e(e) {
    this.word("continue"), Ny(this, e.label);
  }
  n(o7e, "ContinueStatement");
  function u7e(e) {
    this.word("return"), Ny(this, e.argument);
  }
  n(u7e, "ReturnStatement");
  function l7e(e) {
    this.word("throw"), Ny(this, e.argument);
  }
  n(l7e, "ThrowStatement");
  function c7e(e) {
    this.print(e.label), this.tokenChar(58), this.space(), this.print(e.body);
  }
  n(c7e, "LabeledStatement");
  function f7e(e) {
    this.word("try"), this.space(), this.print(e.block), this.space(), e.handlers ? this.print(e.handlers[0]) : this.print(e.handler), e.finalizer &&
    (this.space(), this.word("finally"), this.space(), this.print(e.finalizer));
  }
  n(f7e, "TryStatement");
  function d7e(e) {
    this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param), this.print(e.param.typeAnnotation), this.tokenChar(
    41), this.space()), this.print(e.body);
  }
  n(d7e, "CatchClause");
  function p7e(e) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(e.cases, !0), this.rightBrace(e);
  }
  n(p7e, "SwitchStatement");
  function h7e(e) {
    e.test ? (this.word("case"), this.space(), this.print(e.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.
    length && (this.newline(), this.printSequence(e.consequent, !0));
  }
  n(h7e, "SwitchCase");
  function m7e() {
    this.word("debugger"), this.semicolon();
  }
  n(m7e, "DebuggerStatement");
  function y7e(e, t) {
    e.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = e;
    r === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(r, r === "using"), this.space();
    let i = !1;
    if (!$q(t))
      for (let s of e.declarations)
        s.init && (i = !0);
    if (this.printList(e.declarations, void 0, void 0, e.declarations.length > 1, i ? function(s) {
      this.token(",", !1, s), this.newline();
    } : void 0), $q(t)) {
      if (Z5e(t)) {
        if (t.init === e) return;
      } else if (t.left === e) return;
    }
    this.semicolon();
  }
  n(y7e, "VariableDeclaration");
  function g7e(e) {
    this.print(e.id), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation), e.init && (this.space(), this.tokenChar(61), this.space(),
    this.print(e.init));
  }
  n(g7e, "VariableDeclarator");
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var Kq = E((Ji) => {
  "use strict";
  Object.defineProperty(Ji, "__esModule", {
    value: !0
  });
  Ji.ClassAccessorProperty = C7e;
  Ji.ClassBody = E7e;
  Ji.ClassExpression = Ji.ClassDeclaration = x7e;
  Ji.ClassMethod = A7e;
  Ji.ClassPrivateMethod = _7e;
  Ji.ClassPrivateProperty = w7e;
  Ji.ClassProperty = T7e;
  Ji.StaticBlock = F7e;
  Ji._classMethodHead = P7e;
  var b7e = Pe(), {
    isExportDefaultDeclaration: D7e,
    isExportNamedDeclaration: v7e
  } = b7e;
  function x7e(e, t) {
    (!(D7e(t) || v7e(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators), e.declare && (this.word("declare"),
    this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id)), this.print(
    e.typeParameters), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass), this.print(e.superTypeParameters)),
    e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements)), this.space(), this.print(e.body);
  }
  n(x7e, "ClassDeclaration");
  function E7e(e) {
    if (this.tokenChar(123), e.body.length === 0)
      this.tokenChar(125);
    else {
      this.newline();
      let t = S7e(this, e);
      t?.(-1);
      let r = this.enterDelimited();
      this.printJoin(e.body, !0, !0, t, !0), r(), this.endsWith(10) || this.newline(), this.rightBrace(e);
    }
  }
  n(E7e, "ClassBody");
  function S7e(e, t) {
    if (!e.tokenMap || t.start == null || t.end == null)
      return null;
    let r = e.tokenMap.getIndexes(t);
    if (!r) return null;
    let i = 1, s = 0, a = 0, o = /* @__PURE__ */ n(() => {
      for (; a < t.body.length && t.body[a].start == null; )
        a++;
    }, "advanceNextLocIndex");
    return o(), (u) => {
      a <= u && (a = u + 1, o());
      let l = a === t.body.length ? t.end : t.body[a].start, c;
      for (; i < r.length && e.tokenMap.matchesOriginal(c = e._tokens[r[i]], ";") && c.start < l; )
        e.token(";", void 0, s++), i++;
    };
  }
  n(S7e, "classBodyEmptySemicolonsPrinter");
  function T7e(e) {
    if (this.printJoin(e.decorators), !e.static && !this.format.preserveFormat) {
      var t;
      let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
      r && this.catchUp(r);
    }
    this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key), this.tokenChar(93)) : (this._variance(e), this.
    print(e.key)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation), e.value && (this.space(),
    this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
  }
  n(T7e, "ClassProperty");
  function C7e(e) {
    var t;
    this.printJoin(e.decorators);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.
    print(e.key), this.tokenChar(93)) : (this._variance(e), this.print(e.key)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(
    33), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
  }
  n(C7e, "ClassAccessorProperty");
  function w7e(e) {
    this.printJoin(e.decorators), this.tsPrintClassMemberModifiers(e), this.print(e.key), e.optional && this.tokenChar(63), e.definite && this.
    tokenChar(33), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
  }
  n(w7e, "ClassPrivateProperty");
  function A7e(e) {
    this._classMethodHead(e), this.space(), this.print(e.body);
  }
  n(A7e, "ClassMethod");
  function _7e(e) {
    this._classMethodHead(e), this.space(), this.print(e.body);
  }
  n(_7e, "ClassPrivateMethod");
  function P7e(e) {
    if (this.printJoin(e.decorators), !this.format.preserveFormat) {
      var t;
      let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
      r && this.catchUp(r);
    }
    this.tsPrintClassMemberModifiers(e), this._methodHead(e);
  }
  n(P7e, "_classMethodHead");
  function F7e(e) {
    this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    e.body, !0), this.rightBrace(e));
  }
  n(F7e, "StaticBlock");
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var zq = E((Xi) => {
  "use strict";
  Object.defineProperty(Xi, "__esModule", {
    value: !0
  });
  Xi.ArrowFunctionExpression = U7e;
  Xi.FunctionDeclaration = Xi.FunctionExpression = q7e;
  Xi._functionHead = j7e;
  Xi._methodHead = R7e;
  Xi._param = M7e;
  Xi._parameters = N7e;
  Xi._params = B7e;
  Xi._predicate = L7e;
  Xi._shouldPrintArrowParamsParens = $7e;
  var I7e = Pe(), O7e = tu(), {
    isIdentifier: k7e
  } = I7e;
  function B7e(e, t, r) {
    this.print(e.typeParameters);
    let i = V7e.call(this, t, r);
    i && this.sourceIdentifierName(i.name, i.pos), this.tokenChar(40), this._parameters(e.params, ")");
    let s = e.type === "ArrowFunctionExpression";
    this.print(e.returnType, s), this._noLineTerminator = s;
  }
  n(B7e, "_params");
  function N7e(e, t) {
    let r = this.enterDelimited(), i = this.shouldPrintTrailingComma(t), s = e.length;
    for (let a = 0; a < s; a++)
      this._param(e[a]), (i || a < s - 1) && (this.token(",", void 0, a), this.space());
    this.token(t), r();
  }
  n(N7e, "_parameters");
  function M7e(e) {
    this.printJoin(e.decorators), this.print(e), e.optional && this.tokenChar(63), this.print(e.typeAnnotation);
  }
  n(M7e, "_param");
  function R7e(e) {
    let t = e.kind, r = e.key;
    (t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t ===
    "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(r), this.tokenChar(93)) : this.print(r), e.optional &&
    this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key);
  }
  n(R7e, "_methodHead");
  function L7e(e, t) {
    e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, t));
  }
  n(L7e, "_predicate");
  function j7e(e, t) {
    e.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.space()), this.word("function"), e.generator &&
    (this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.tokenChar(42)), this.space(), e.id && this.print(e.id), this._params(
    e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(e);
  }
  n(j7e, "_functionHead");
  function q7e(e, t) {
    this._functionHead(e, t), this.space(), this.print(e.body);
  }
  n(q7e, "FunctionExpression");
  function U7e(e, t) {
    e.async && (this.word("async", !0), this.space()), this._shouldPrintArrowParamsParens(e) ? this._params(e, void 0, t) : this.print(e.params[0],
    !0), this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= O7e.TokenContext.
    arrowBody, this.print(e.body);
  }
  n(U7e, "ArrowFunctionExpression");
  function $7e(e) {
    var t, r;
    if (e.params.length !== 1 || e.typeParameters || e.returnType || e.predicate)
      return !0;
    let i = e.params[0];
    if (!k7e(i) || i.typeAnnotation || i.optional || (t = i.leadingComments) != null && t.length || (r = i.trailingComments) != null && r.length)
      return !0;
    if (this.tokenMap) {
      if (e.loc == null || this.tokenMap.findMatching(e, "(") !== null) return !0;
      let s = this.tokenMap.findMatching(e, "=>");
      return s?.loc == null ? !0 : s.loc.start.line !== e.loc.start.line;
    }
    return !!this.format.retainLines;
  }
  n($7e, "_shouldPrintArrowParamsParens");
  function V7e(e, t) {
    let r = e;
    if (!r && t) {
      let l = t.type;
      l === "VariableDeclarator" ? r = t.id : l === "AssignmentExpression" || l === "AssignmentPattern" ? r = t.left : l === "ObjectProperty" ||
      l === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (r = t.key) : (l === "ClassPrivateProperty" || l === "Class\
AccessorProperty") && (r = t.key);
    }
    if (!r) return;
    let i;
    if (r.type === "Identifier") {
      var s, a;
      i = {
        pos: (s = r.loc) == null ? void 0 : s.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      i = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var u;
      i = {
        pos: (u = r.loc) == null ? void 0 : u.start,
        name: r.value
      };
    }
    return i;
  }
  n(V7e, "_getFuncIdName");
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var KC = E((ni) => {
  "use strict";
  Object.defineProperty(ni, "__esModule", {
    value: !0
  });
  ni.ExportAllDeclaration = i9e;
  ni.ExportDefaultDeclaration = n9e;
  ni.ExportDefaultSpecifier = Q7e;
  ni.ExportNamedDeclaration = s9e;
  ni.ExportNamespaceSpecifier = t9e;
  ni.ExportSpecifier = e9e;
  ni.ImportAttribute = o9e;
  ni.ImportDeclaration = a9e;
  ni.ImportDefaultSpecifier = Z7e;
  ni.ImportExpression = l9e;
  ni.ImportNamespaceSpecifier = u9e;
  ni.ImportSpecifier = G7e;
  ni._printAttributes = r9e;
  var W7e = Pe(), H7e = tu(), {
    isClassDeclaration: K7e,
    isExportDefaultSpecifier: z7e,
    isExportNamespaceSpecifier: J7e,
    isImportDefaultSpecifier: X7e,
    isImportNamespaceSpecifier: Y7e,
    isStatement: Xq
  } = W7e;
  function G7e(e) {
    (e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported), e.local && e.
    local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local));
  }
  n(G7e, "ImportSpecifier");
  function Z7e(e) {
    this.print(e.local);
  }
  n(Z7e, "ImportDefaultSpecifier");
  function Q7e(e) {
    this.print(e.exported);
  }
  n(Q7e, "ExportDefaultSpecifier");
  function e9e(e) {
    e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local), e.exported && e.local.name !== e.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(e.exported));
  }
  n(e9e, "ExportSpecifier");
  function t9e(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported);
  }
  n(t9e, "ExportNamespaceSpecifier");
  var Jq = !1;
  function r9e(e, t) {
    var r;
    let {
      importAttributesKeyword: i
    } = this.format, {
      attributes: s,
      assertions: a
    } = e;
    s && !i && e.extra && (e.extra.deprecatedAssertSyntax || e.extra.deprecatedWithLegacySyntax) && !Jq && (Jq = !0, console.warn('You are u\
sing import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose v\
alue can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { typ\
e: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let o = i === "assert" || !i && a;
    if (this.word(o ? "assert" : "with"), this.space(), !o && (i === "with-legacy" || !i && (r = e.extra) != null && r.deprecatedWithLegacySyntax)) {
      this.printList(s || a);
      return;
    }
    let u = t ? 1 : 0;
    this.token("{", void 0, u), this.space(), this.printList(s || a, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", void 0,
    u);
  }
  n(r9e, "_printAttributes");
  function i9e(e) {
    var t, r;
    this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, !0),
    this.space(), this._printAttributes(e, !1)) : this.print(e.source), this.semicolon();
  }
  n(i9e, "ExportAllDeclaration");
  function Yq(e, t) {
    K7e(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators);
  }
  n(Yq, "maybePrintDecoratorsBeforeExport");
  function s9e(e) {
    if (Yq(this, e), this.word("export"), this.space(), e.declaration) {
      let i = e.declaration;
      this.print(i), Xq(i) || this.semicolon();
    } else {
      e.exportKind === "type" && (this.word("type"), this.space());
      let i = e.specifiers.slice(0), s = !1;
      for (; ; ) {
        let o = i[0];
        if (z7e(o) || J7e(o))
          s = !0, this.print(i.shift()), i.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      let a = !1;
      if ((i.length || !i.length && !s) && (a = !0, this.tokenChar(123), i.length && (this.space(), this.printList(i, this.shouldPrintTrailingComma(
      "}")), this.space()), this.tokenChar(125)), e.source) {
        var t, r;
        this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.
        print(e.source, !0), this.space(), this._printAttributes(e, a)) : this.print(e.source);
      }
      this.semicolon();
    }
  }
  n(s9e, "ExportNamedDeclaration");
  function n9e(e) {
    Yq(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |=
    H7e.TokenContext.exportDefault;
    let t = e.declaration;
    this.print(t), Xq(t) || this.semicolon();
  }
  n(n9e, "ExportDefaultDeclaration");
  function a9e(e) {
    var t, r;
    this.word("import"), this.space();
    let i = e.importKind === "type" || e.importKind === "typeof";
    i ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : e.phase && (this.noIndentInnerCommentsHere(), this.word(e.phase), this.space());
    let s = e.specifiers.slice(0), a = !!s.length;
    for (; a; ) {
      let u = s[0];
      if (X7e(u) || Y7e(u))
        this.print(s.shift()), s.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    let o = !1;
    s.length ? (o = !0, this.tokenChar(123), this.space(), this.printList(s, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(
    125)) : i && !a && (o = !0, this.tokenChar(123), this.tokenChar(125)), (a || i) && (this.space(), this.word("from"), this.space()), (t =
    e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, !0), this.space(), this._printAttributes(
    e, o)) : this.print(e.source), this.semicolon();
  }
  n(a9e, "ImportDeclaration");
  function o9e(e) {
    this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
  }
  n(o9e, "ImportAttribute");
  function u9e(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local);
  }
  n(u9e, "ImportNamespaceSpecifier");
  function l9e(e) {
    this.word("import"), e.phase && (this.tokenChar(46), this.word(e.phase)), this.tokenChar(40);
    let t = this.shouldPrintTrailingComma(")");
    this.print(e.source), e.options != null && (this.tokenChar(44), this.space(), this.print(e.options)), t && this.tokenChar(44), this.rightParens(
    e);
  }
  n(l9e, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var eU = E((cgt, Qq) => {
  "use strict";
  var Gq = {}, c9e = Gq.hasOwnProperty, Zq = /* @__PURE__ */ n((e, t) => {
    for (let r in e)
      c9e.call(e, r) && t(r, e[r]);
  }, "forOwn"), f9e = /* @__PURE__ */ n((e, t) => (t && Zq(t, (r, i) => {
    e[r] = i;
  }), e), "extend"), d9e = /* @__PURE__ */ n((e, t) => {
    let r = e.length, i = -1;
    for (; ++i < r; )
      t(e[i]);
  }, "forEach"), My = /* @__PURE__ */ n((e) => "\\u" + ("0000" + e).slice(-4), "fourHexEscape"), ip = /* @__PURE__ */ n((e, t) => {
    let r = e.toString(16);
    return t ? r : r.toUpperCase();
  }, "hexadecimal"), sp = Gq.toString, p9e = Array.isArray, h9e = /* @__PURE__ */ n((e) => typeof Buffer == "function" && Buffer.isBuffer(e),
  "isBuffer"), m9e = /* @__PURE__ */ n((e) => sp.call(e) == "[object Object]", "isObject"), y9e = /* @__PURE__ */ n((e) => typeof e == "stri\
ng" || sp.call(e) == "[object String]", "isString"), g9e = /* @__PURE__ */ n((e) => typeof e == "number" || sp.call(e) == "[object Number]",
  "isNumber"), zC = /* @__PURE__ */ n((e) => typeof e == "bigint", "isBigInt"), b9e = /* @__PURE__ */ n((e) => typeof e == "function", "isFu\
nction"), D9e = /* @__PURE__ */ n((e) => sp.call(e) == "[object Map]", "isMap"), v9e = /* @__PURE__ */ n((e) => sp.call(e) == "[object Set]",
  "isSet"), x9e = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, E9e = /[\\\b\f\n\r\t]/, S9e = /[0-9]/, T9e = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, C9e = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g,
  w9e = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, ja = /* @__PURE__ */ n((e, t) => {
    let r = /* @__PURE__ */ n(() => {
      c = l, ++t.indentLevel, l = t.indent.repeat(t.indentLevel);
    }, "increaseIndentation"), i = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, s = t && t.json;
    s && (i.quotes = "double", i.wrap = !0), t = f9e(i, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes =
    "single");
    let a = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'", o = t.compact, u = t.lowercaseHex, l = t.indent.repeat(t.indentLevel),
    c = "", f = t.__inline1__, m = t.__inline2__, h = o ? "" : `
`, d, y = !0, p = t.numbers == "binary", g = t.numbers == "octal", b = t.numbers == "decimal", D = t.numbers == "hexadecimal";
    if (s && e && b9e(e.toJSON) && (e = e.toJSON()), !y9e(e)) {
      if (D9e(e))
        return e.size == 0 ? "new Map()" : (o || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + ja(Array.from(e), t) + ")");
      if (v9e(e))
        return e.size == 0 ? "new Set()" : "new Set(" + ja(Array.from(e), t) + ")";
      if (h9e(e))
        return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + ja(Array.from(e), t) + ")";
      if (p9e(e))
        return d = [], t.wrap = !0, f && (t.__inline1__ = !1, t.__inline2__ = !0), m || r(), d9e(e, (T) => {
          y = !1, m && (t.__inline2__ = !1), d.push(
            (o || m ? "" : l) + ja(T, t)
          );
        }), y ? "[]" : m ? "[" + d.join(", ") + "]" : "[" + h + d.join("," + h) + h + (o ? "" : c) + "]";
      if (g9e(e) || zC(e)) {
        if (s)
          return JSON.stringify(Number(e));
        let T;
        if (b)
          T = String(e);
        else if (D) {
          let w = e.toString(16);
          u || (w = w.toUpperCase()), T = "0x" + w;
        } else p ? T = "0b" + e.toString(2) : g && (T = "0o" + e.toString(8));
        return zC(e) ? T + "n" : T;
      } else return zC(e) ? s ? JSON.stringify(Number(e)) : e + "n" : m9e(e) ? (d = [], t.wrap = !0, r(), Zq(e, (T, w) => {
        y = !1, d.push(
          (o ? "" : l) + ja(T, t) + ":" + (o ? "" : " ") + ja(w, t)
        );
      }), y ? "{}" : "{" + h + d.join("," + h) + h + (o ? "" : c) + "}") : s ? JSON.stringify(e) || "null" : String(e);
    }
    let x = t.escapeEverything ? C9e : w9e;
    return d = e.replace(x, (T, w, B, k, q, V) => {
      if (w) {
        if (t.minimal) return w;
        let G = w.charCodeAt(0), ye = w.charCodeAt(1);
        if (t.es6) {
          let te = (G - 55296) * 1024 + ye - 56320 + 65536;
          return "\\u{" + ip(te, u) + "}";
        }
        return My(ip(G, u)) + My(ip(ye, u));
      }
      if (B)
        return My(ip(B.charCodeAt(0), u));
      if (T == "\0" && !s && !S9e.test(V.charAt(q + 1)))
        return "\\0";
      if (k)
        return k == a || t.escapeEverything ? "\\" + k : k;
      if (E9e.test(T))
        return x9e[T];
      if (t.minimal && !T9e.test(T))
        return T;
      let Y = ip(T.charCodeAt(0), u);
      return s || Y.length > 2 ? My(Y) : "\\x" + ("00" + Y).slice(-2);
    }), a == "`" && (d = d.replace(/\$\{/g, "\\${")), t.isScriptContext && (d = d.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, s ?
    "\\u003C!--" : "\\x3C!--")), t.wrap && (d = a + d + a), d;
  }, "jsesc");
  ja.version = "3.0.2";
  Qq.exports = ja;
});

// ../node_modules/@babel/generator/lib/generators/types.js
var XC = E((At) => {
  "use strict";
  Object.defineProperty(At, "__esModule", {
    value: !0
  });
  At.ArgumentPlaceholder = I9e;
  At.ArrayPattern = At.ArrayExpression = M9e;
  At.BigIntLiteral = W9e;
  At.BooleanLiteral = q9e;
  At.Identifier = F9e;
  At.NullLiteral = U9e;
  At.NumericLiteral = $9e;
  At.ObjectPattern = At.ObjectExpression = k9e;
  At.ObjectMethod = B9e;
  At.ObjectProperty = N9e;
  At.PipelineBareFunction = z9e;
  At.PipelinePrimaryTopicReference = J9e;
  At.PipelineTopicExpression = K9e;
  At.RecordExpression = R9e;
  At.RegExpLiteral = j9e;
  At.SpreadElement = At.RestElement = O9e;
  At.StringLiteral = V9e;
  At.TopicReference = H9e;
  At.TupleExpression = L9e;
  At.VoidPattern = X9e;
  At._getRawIdentifier = P9e;
  var A9e = Pe(), iU = eU(), {
    isAssignmentPattern: _9e,
    isIdentifier: JC
  } = A9e, tU = null, Ry = "";
  function P9e(e) {
    if (e === tU) return Ry;
    tU = e;
    let {
      name: t
    } = e, r = this.tokenMap.find(e, (i) => i.value === t);
    return r ? (Ry = this._originalCode.slice(r.start, r.end), Ry) : Ry = e.name;
  }
  n(P9e, "_getRawIdentifier");
  function F9e(e) {
    var t;
    this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(this.tokenMap ? this._getRawIdentifier(
    e) : e.name);
  }
  n(F9e, "Identifier");
  function I9e() {
    this.tokenChar(63);
  }
  n(I9e, "ArgumentPlaceholder");
  function O9e(e) {
    this.token("..."), this.print(e.argument);
  }
  n(O9e, "RestElement");
  function k9e(e) {
    let t = e.properties;
    if (this.tokenChar(123), t.length) {
      let r = this.enterDelimited();
      this.space(), this.printList(t, this.shouldPrintTrailingComma("}"), !0, !0), this.space(), r();
    }
    this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
  }
  n(k9e, "ObjectExpression");
  function B9e(e) {
    this.printJoin(e.decorators), this._methodHead(e), this.space(), this.print(e.body);
  }
  n(B9e, "ObjectMethod");
  function N9e(e) {
    if (this.printJoin(e.decorators), e.computed)
      this.tokenChar(91), this.print(e.key), this.tokenChar(93);
    else {
      if (_9e(e.value) && JC(e.key) && e.key.name === e.value.left.name) {
        this.print(e.value);
        return;
      }
      if (this.print(e.key), e.shorthand && JC(e.key) && JC(e.value) && e.key.name === e.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(e.value);
  }
  n(N9e, "ObjectProperty");
  function M9e(e) {
    let t = e.elements, r = t.length;
    this.tokenChar(91);
    let i = this.enterDelimited();
    for (let s = 0; s < t.length; s++) {
      let a = t[s];
      a ? (s > 0 && this.space(), this.print(a), (s < r - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", !1, s)) : this.token("\
,", !1, s);
    }
    i(), this.tokenChar(93);
  }
  n(M9e, "ArrayExpression");
  function R9e(e) {
    let t = e.properties, r, i;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", i = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", i = "}";
    }
    this.token(r), t.length && (this.space(), this.printList(t, this.shouldPrintTrailingComma(i), !0, !0), this.space()), this.token(i);
  }
  n(R9e, "RecordExpression");
  function L9e(e) {
    let t = e.elements, r = t.length, i, s;
    if (this.format.recordAndTupleSyntaxType === "bar")
      i = "[|", s = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      i = "#[", s = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(i);
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      o && (a > 0 && this.space(), this.print(o), (a < r - 1 || this.shouldPrintTrailingComma(s)) && this.token(",", !1, a));
    }
    this.token(s);
  }
  n(L9e, "TupleExpression");
  function j9e(e) {
    this.word(`/${e.pattern}/${e.flags}`);
  }
  n(j9e, "RegExpLiteral");
  function q9e(e) {
    this.word(e.value ? "true" : "false");
  }
  n(q9e, "BooleanLiteral");
  function U9e() {
    this.word("null");
  }
  n(U9e, "NullLiteral");
  function $9e(e) {
    let t = this.getPossibleRaw(e), r = this.format.jsescOption, i = e.value, s = i + "";
    r.numbers ? this.number(iU(i, r), i) : t == null ? this.number(s, i) : this.format.minified ? this.number(t.length < s.length ? t : s, i) :
    this.number(t, i);
  }
  n($9e, "NumericLiteral");
  function V9e(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let r = iU(e.value, this.format.jsescOption);
    this.token(r);
  }
  n(V9e, "StringLiteral");
  function W9e(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.word(t);
      return;
    }
    this.word(e.value + "n");
  }
  n(W9e, "BigIntLiteral");
  var rU = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function H9e() {
    let {
      topicToken: e
    } = this.format;
    if (rU.has(e))
      this.token(e);
    else {
      let t = JSON.stringify(e), r = Array.from(rU, (i) => JSON.stringify(i));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${t} received instead).`);
    }
  }
  n(H9e, "TopicReference");
  function K9e(e) {
    this.print(e.expression);
  }
  n(K9e, "PipelineTopicExpression");
  function z9e(e) {
    this.print(e.callee);
  }
  n(z9e, "PipelineBareFunction");
  function J9e() {
    this.tokenChar(35);
  }
  n(J9e, "PipelinePrimaryTopicReference");
  function X9e() {
    this.word("void");
  }
  n(X9e, "VoidPattern");
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var nU = E((he) => {
  "use strict";
  Object.defineProperty(he, "__esModule", {
    value: !0
  });
  he.AnyTypeAnnotation = eOe;
  he.ArrayTypeAnnotation = tOe;
  he.BooleanLiteralTypeAnnotation = iOe;
  he.BooleanTypeAnnotation = rOe;
  he.DeclareClass = nOe;
  he.DeclareExportAllDeclaration = yOe;
  he.DeclareExportDeclaration = mOe;
  he.DeclareFunction = aOe;
  he.DeclareInterface = lOe;
  he.DeclareModule = cOe;
  he.DeclareModuleExports = fOe;
  he.DeclareOpaqueType = pOe;
  he.DeclareTypeAlias = dOe;
  he.DeclareVariable = hOe;
  he.DeclaredPredicate = uOe;
  he.EmptyTypeAnnotation = LOe;
  he.EnumBooleanBody = bOe;
  he.EnumBooleanMember = SOe;
  he.EnumDeclaration = gOe;
  he.EnumDefaultedMember = EOe;
  he.EnumNumberBody = DOe;
  he.EnumNumberMember = TOe;
  he.EnumStringBody = vOe;
  he.EnumStringMember = COe;
  he.EnumSymbolBody = xOe;
  he.ExistsTypeAnnotation = AOe;
  he.FunctionTypeAnnotation = _Oe;
  he.FunctionTypeParam = POe;
  he.IndexedAccessType = lke;
  he.InferredPredicate = oOe;
  he.InterfaceDeclaration = kOe;
  he.GenericTypeAnnotation = he.ClassImplements = he.InterfaceExtends = FOe;
  he.InterfaceTypeAnnotation = NOe;
  he.IntersectionTypeAnnotation = MOe;
  he.MixedTypeAnnotation = ROe;
  he.NullLiteralTypeAnnotation = sOe;
  he.NullableTypeAnnotation = jOe;
  Object.defineProperty(he, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return sU.NumericLiteral;
    }, "get")
  });
  he.NumberTypeAnnotation = qOe;
  he.ObjectTypeAnnotation = YOe;
  he.ObjectTypeCallProperty = ZOe;
  he.ObjectTypeIndexer = QOe;
  he.ObjectTypeInternalSlot = GOe;
  he.ObjectTypeProperty = eke;
  he.ObjectTypeSpreadProperty = tke;
  he.OpaqueType = XOe;
  he.OptionalIndexedAccessType = cke;
  he.QualifiedTypeIdentifier = rke;
  Object.defineProperty(he, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return sU.StringLiteral;
    }, "get")
  });
  he.StringTypeAnnotation = UOe;
  he.SymbolTypeAnnotation = ike;
  he.ThisTypeAnnotation = $Oe;
  he.TupleTypeAnnotation = VOe;
  he.TypeAlias = HOe;
  he.TypeAnnotation = KOe;
  he.TypeCastExpression = ake;
  he.TypeParameter = JOe;
  he.TypeParameterDeclaration = he.TypeParameterInstantiation = zOe;
  he.TypeofTypeAnnotation = WOe;
  he.UnionTypeAnnotation = nke;
  he.Variance = oke;
  he.VoidTypeAnnotation = uke;
  he._interfaceish = IOe;
  he._variance = OOe;
  var Y9e = Pe(), G9e = KC(), Z9e = tu(), sU = XC(), {
    isDeclareExportDeclaration: Ly,
    isStatement: Q9e
  } = Y9e;
  function eOe() {
    this.word("any");
  }
  n(eOe, "AnyTypeAnnotation");
  function tOe(e) {
    this.print(e.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(tOe, "ArrayTypeAnnotation");
  function rOe() {
    this.word("boolean");
  }
  n(rOe, "BooleanTypeAnnotation");
  function iOe(e) {
    this.word(e.value ? "true" : "false");
  }
  n(iOe, "BooleanLiteralTypeAnnotation");
  function sOe() {
    this.word("null");
  }
  n(sOe, "NullLiteralTypeAnnotation");
  function nOe(e, t) {
    Ly(t) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e);
  }
  n(nOe, "DeclareClass");
  function aOe(e, t) {
    Ly(t) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e.id), this.print(e.id.typeAnnotation.typeAnnotation),
    e.predicate && (this.space(), this.print(e.predicate)), this.semicolon();
  }
  n(aOe, "DeclareFunction");
  function oOe() {
    this.tokenChar(37), this.word("checks");
  }
  n(oOe, "InferredPredicate");
  function uOe(e) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e.value), this.tokenChar(41);
  }
  n(uOe, "DeclaredPredicate");
  function lOe(e) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(e);
  }
  n(lOe, "DeclareInterface");
  function cOe(e) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e.id), this.space(), this.print(e.body);
  }
  n(cOe, "DeclareModule");
  function fOe(e) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e.typeAnnotation);
  }
  n(fOe, "DeclareModuleExports");
  function dOe(e) {
    this.word("declare"), this.space(), this.TypeAlias(e);
  }
  n(dOe, "DeclareTypeAlias");
  function pOe(e, t) {
    Ly(t) || (this.word("declare"), this.space()), this.OpaqueType(e);
  }
  n(pOe, "DeclareOpaqueType");
  function hOe(e, t) {
    Ly(t) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e.id), this.print(e.id.typeAnnotation), this.semicolon();
  }
  n(hOe, "DeclareVariable");
  function mOe(e) {
    this.word("declare"), this.space(), this.word("export"), this.space(), e.default && (this.word("default"), this.space()), wOe.call(this,
    e);
  }
  n(mOe, "DeclareExportDeclaration");
  function yOe(e) {
    this.word("declare"), this.space(), G9e.ExportAllDeclaration.call(this, e);
  }
  n(yOe, "DeclareExportAllDeclaration");
  function gOe(e) {
    let {
      id: t,
      body: r
    } = e;
    this.word("enum"), this.space(), this.print(t), this.print(r);
  }
  n(gOe, "EnumDeclaration");
  function jy(e, t, r) {
    r && (e.space(), e.word("of"), e.space(), e.word(t)), e.space();
  }
  n(jy, "enumExplicitType");
  function qy(e, t) {
    let {
      members: r
    } = t;
    e.token("{"), e.indent(), e.newline();
    for (let i of r)
      e.print(i), e.newline();
    t.hasUnknownMembers && (e.token("..."), e.newline()), e.dedent(), e.token("}");
  }
  n(qy, "enumBody");
  function bOe(e) {
    let {
      explicitType: t
    } = e;
    jy(this, "boolean", t), qy(this, e);
  }
  n(bOe, "EnumBooleanBody");
  function DOe(e) {
    let {
      explicitType: t
    } = e;
    jy(this, "number", t), qy(this, e);
  }
  n(DOe, "EnumNumberBody");
  function vOe(e) {
    let {
      explicitType: t
    } = e;
    jy(this, "string", t), qy(this, e);
  }
  n(vOe, "EnumStringBody");
  function xOe(e) {
    jy(this, "symbol", !0), qy(this, e);
  }
  n(xOe, "EnumSymbolBody");
  function EOe(e) {
    let {
      id: t
    } = e;
    this.print(t), this.tokenChar(44);
  }
  n(EOe, "EnumDefaultedMember");
  function YC(e, t) {
    e.print(t.id), e.space(), e.token("="), e.space(), e.print(t.init), e.token(",");
  }
  n(YC, "enumInitializedMember");
  function SOe(e) {
    YC(this, e);
  }
  n(SOe, "EnumBooleanMember");
  function TOe(e) {
    YC(this, e);
  }
  n(TOe, "EnumNumberMember");
  function COe(e) {
    YC(this, e);
  }
  n(COe, "EnumStringMember");
  function wOe(e) {
    if (e.declaration) {
      let t = e.declaration;
      this.print(t), Q9e(t) || this.semicolon();
    } else
      this.tokenChar(123), e.specifiers.length && (this.space(), this.printList(e.specifiers), this.space()), this.tokenChar(125), e.source &&
      (this.space(), this.word("from"), this.space(), this.print(e.source)), this.semicolon();
  }
  n(wOe, "FlowExportDeclaration");
  function AOe() {
    this.tokenChar(42);
  }
  n(AOe, "ExistsTypeAnnotation");
  function _Oe(e, t) {
    this.print(e.typeParameters), this.tokenChar(40), e.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e.this.typeAnnotation),
    (e.params.length || e.rest) && (this.tokenChar(44), this.space())), this.printList(e.params), e.rest && (e.params.length && (this.tokenChar(
    44), this.space()), this.token("..."), this.print(e.rest)), this.tokenChar(41);
    let r = t?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    t.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e.returnType);
  }
  n(_Oe, "FunctionTypeAnnotation");
  function POe(e) {
    this.print(e.name), e.optional && this.tokenChar(63), e.name && (this.tokenChar(58), this.space()), this.print(e.typeAnnotation);
  }
  n(POe, "FunctionTypeParam");
  function FOe(e) {
    this.print(e.id), this.print(e.typeParameters, !0);
  }
  n(FOe, "InterfaceExtends");
  function IOe(e) {
    var t;
    if (this.print(e.id), this.print(e.typeParameters), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(),
    this.printList(e.extends)), e.type === "DeclareClass") {
      var r, i;
      (r = e.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(e.mixins)), (i = e.implements) !=
      null && i.length && (this.space(), this.word("implements"), this.space(), this.printList(e.implements));
    }
    this.space(), this.print(e.body);
  }
  n(IOe, "_interfaceish");
  function OOe(e) {
    var t;
    let r = (t = e.variance) == null ? void 0 : t.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  n(OOe, "_variance");
  function kOe(e) {
    this.word("interface"), this.space(), this._interfaceish(e);
  }
  n(kOe, "InterfaceDeclaration");
  function BOe(e) {
    this.space(), this.token("&", !1, e), this.space();
  }
  n(BOe, "andSeparator");
  function NOe(e) {
    var t;
    this.word("interface"), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(), this.printList(e.extends)),
    this.space(), this.print(e.body);
  }
  n(NOe, "InterfaceTypeAnnotation");
  function MOe(e) {
    this.printJoin(e.types, void 0, void 0, BOe);
  }
  n(MOe, "IntersectionTypeAnnotation");
  function ROe() {
    this.word("mixed");
  }
  n(ROe, "MixedTypeAnnotation");
  function LOe() {
    this.word("empty");
  }
  n(LOe, "EmptyTypeAnnotation");
  function jOe(e) {
    this.tokenChar(63), this.print(e.typeAnnotation);
  }
  n(jOe, "NullableTypeAnnotation");
  function qOe() {
    this.word("number");
  }
  n(qOe, "NumberTypeAnnotation");
  function UOe() {
    this.word("string");
  }
  n(UOe, "StringTypeAnnotation");
  function $Oe() {
    this.word("this");
  }
  n($Oe, "ThisTypeAnnotation");
  function VOe(e) {
    this.tokenChar(91), this.printList(e.types), this.tokenChar(93);
  }
  n(VOe, "TupleTypeAnnotation");
  function WOe(e) {
    this.word("typeof"), this.space(), this.print(e.argument);
  }
  n(WOe, "TypeofTypeAnnotation");
  function HOe(e) {
    this.word("type"), this.space(), this.print(e.id), this.print(e.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(
    e.right), this.semicolon();
  }
  n(HOe, "TypeAlias");
  function KOe(e, t) {
    this.tokenChar(58), this.space(), t.type === "ArrowFunctionExpression" ? this.tokenContext |= Z9e.TokenContext.arrowFlowReturnType : e.optional &&
    this.tokenChar(63), this.print(e.typeAnnotation);
  }
  n(KOe, "TypeAnnotation");
  function zOe(e) {
    this.tokenChar(60), this.printList(e.params), this.tokenChar(62);
  }
  n(zOe, "TypeParameterInstantiation");
  function JOe(e) {
    this._variance(e), this.word(e.name), e.bound && this.print(e.bound), e.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(e.default));
  }
  n(JOe, "TypeParameter");
  function XOe(e) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e.id), this.print(e.typeParameters), e.supertype && (this.
    tokenChar(58), this.space(), this.print(e.supertype)), e.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(e.impltype)),
    this.semicolon();
  }
  n(XOe, "OpaqueType");
  function YOe(e) {
    e.exact ? this.token("{|") : this.tokenChar(123);
    let t = [...e.properties, ...e.callProperties || [], ...e.indexers || [], ...e.internalSlots || []];
    t.length && (this.newline(), this.space(), this.printJoin(t, !0, !0, void 0, void 0, () => {
      (t.length !== 1 || e.inexact) && (this.tokenChar(44), this.space());
    }), this.space()), e.inexact && (this.indent(), this.token("..."), t.length && this.newline(), this.dedent()), e.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  n(YOe, "ObjectTypeAnnotation");
  function GOe(e) {
    e.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e.id), this.tokenChar(93), this.tokenChar(
    93), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58), this.space()), this.print(e.value);
  }
  n(GOe, "ObjectTypeInternalSlot");
  function ZOe(e) {
    e.static && (this.word("static"), this.space()), this.print(e.value);
  }
  n(ZOe, "ObjectTypeCallProperty");
  function QOe(e) {
    e.static && (this.word("static"), this.space()), this._variance(e), this.tokenChar(91), e.id && (this.print(e.id), this.tokenChar(58), this.
    space()), this.print(e.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e.value);
  }
  n(QOe, "ObjectTypeIndexer");
  function eke(e) {
    e.proto && (this.word("proto"), this.space()), e.static && (this.word("static"), this.space()), (e.kind === "get" || e.kind === "set") &&
    (this.word(e.kind), this.space()), this._variance(e), this.print(e.key), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58),
    this.space()), this.print(e.value);
  }
  n(eke, "ObjectTypeProperty");
  function tke(e) {
    this.token("..."), this.print(e.argument);
  }
  n(tke, "ObjectTypeSpreadProperty");
  function rke(e) {
    this.print(e.qualification), this.tokenChar(46), this.print(e.id);
  }
  n(rke, "QualifiedTypeIdentifier");
  function ike() {
    this.word("symbol");
  }
  n(ike, "SymbolTypeAnnotation");
  function ske(e) {
    this.space(), this.token("|", !1, e), this.space();
  }
  n(ske, "orSeparator");
  function nke(e) {
    this.printJoin(e.types, void 0, void 0, ske);
  }
  n(nke, "UnionTypeAnnotation");
  function ake(e) {
    this.tokenChar(40), this.print(e.expression), this.print(e.typeAnnotation), this.tokenChar(41);
  }
  n(ake, "TypeCastExpression");
  function oke(e) {
    e.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  n(oke, "Variance");
  function uke() {
    this.word("void");
  }
  n(uke, "VoidTypeAnnotation");
  function lke(e) {
    this.print(e.objectType, !0), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
  }
  n(lke, "IndexedAccessType");
  function cke(e) {
    this.print(e.objectType), e.optional && this.token("?."), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
  }
  n(cke, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/generator/lib/generators/base.js
var aU = E((Un) => {
  "use strict";
  Object.defineProperty(Un, "__esModule", {
    value: !0
  });
  Un.BlockStatement = pke;
  Un.Directive = hke;
  Un.DirectiveLiteral = gke;
  Un.File = fke;
  Un.InterpreterDirective = bke;
  Un.Placeholder = Dke;
  Un.Program = dke;
  function fke(e) {
    e.program && this.print(e.program.interpreter), this.print(e.program);
  }
  n(fke, "File");
  function dke(e) {
    var t;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (t = e.directives) == null ? void 0 : t.length;
    if (r) {
      var i;
      let s = e.body.length ? 2 : 1;
      this.printSequence(e.directives, void 0, s), (i = e.directives[r - 1].trailingComments) != null && i.length || this.newline(s);
    }
    this.printSequence(e.body);
  }
  n(dke, "Program");
  function pke(e) {
    var t;
    this.tokenChar(123);
    let r = this.enterDelimited(), i = (t = e.directives) == null ? void 0 : t.length;
    if (i) {
      var s;
      let a = e.body.length ? 2 : 1;
      this.printSequence(e.directives, !0, a), (s = e.directives[i - 1].trailingComments) != null && s.length || this.newline(a);
    }
    this.printSequence(e.body, !0), r(), this.rightBrace(e);
  }
  n(pke, "BlockStatement");
  function hke(e) {
    this.print(e.value), this.semicolon();
  }
  n(hke, "Directive");
  var mke = /(?:^|[^\\])(?:\\\\)*'/, yke = /(?:^|[^\\])(?:\\\\)*"/;
  function gke(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let {
      value: r
    } = e;
    if (!yke.test(r))
      this.token(`"${r}"`);
    else if (!mke.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  n(gke, "DirectiveLiteral");
  function bke(e) {
    this.token(`#!${e.value}`), this.newline(1, !0);
  }
  n(bke, "InterpreterDirective");
  function Dke(e) {
    this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
  }
  n(Dke, "Placeholder");
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var oU = E((Or) => {
  "use strict";
  Object.defineProperty(Or, "__esModule", {
    value: !0
  });
  Or.JSXAttribute = vke;
  Or.JSXClosingElement = Ike;
  Or.JSXClosingFragment = Nke;
  Or.JSXElement = _ke;
  Or.JSXEmptyExpression = Oke;
  Or.JSXExpressionContainer = Cke;
  Or.JSXFragment = kke;
  Or.JSXIdentifier = xke;
  Or.JSXMemberExpression = Ske;
  Or.JSXNamespacedName = Eke;
  Or.JSXOpeningElement = Fke;
  Or.JSXOpeningFragment = Bke;
  Or.JSXSpreadAttribute = Tke;
  Or.JSXSpreadChild = wke;
  Or.JSXText = Ake;
  function vke(e) {
    this.print(e.name), e.value && (this.tokenChar(61), this.print(e.value));
  }
  n(vke, "JSXAttribute");
  function xke(e) {
    this.word(e.name);
  }
  n(xke, "JSXIdentifier");
  function Eke(e) {
    this.print(e.namespace), this.tokenChar(58), this.print(e.name);
  }
  n(Eke, "JSXNamespacedName");
  function Ske(e) {
    this.print(e.object), this.tokenChar(46), this.print(e.property);
  }
  n(Ske, "JSXMemberExpression");
  function Tke(e) {
    this.tokenChar(123), this.token("..."), this.print(e.argument), this.rightBrace(e);
  }
  n(Tke, "JSXSpreadAttribute");
  function Cke(e) {
    this.tokenChar(123), this.print(e.expression), this.rightBrace(e);
  }
  n(Cke, "JSXExpressionContainer");
  function wke(e) {
    this.tokenChar(123), this.token("..."), this.print(e.expression), this.rightBrace(e);
  }
  n(wke, "JSXSpreadChild");
  function Ake(e) {
    let t = this.getPossibleRaw(e);
    t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
  }
  n(Ake, "JSXText");
  function _ke(e) {
    let t = e.openingElement;
    if (this.print(t), !t.selfClosing) {
      this.indent();
      for (let r of e.children)
        this.print(r);
      this.dedent(), this.print(e.closingElement);
    }
  }
  n(_ke, "JSXElement");
  function Pke() {
    this.space();
  }
  n(Pke, "spaceSeparator");
  function Fke(e) {
    this.tokenChar(60), this.print(e.name), e.typeArguments && this.print(e.typeArguments), this.print(e.typeParameters), e.attributes.length >
    0 && (this.space(), this.printJoin(e.attributes, void 0, void 0, Pke)), e.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(
    62);
  }
  n(Fke, "JSXOpeningElement");
  function Ike(e) {
    this.tokenChar(60), this.tokenChar(47), this.print(e.name), this.tokenChar(62);
  }
  n(Ike, "JSXClosingElement");
  function Oke() {
    this.printInnerComments();
  }
  n(Oke, "JSXEmptyExpression");
  function kke(e) {
    this.print(e.openingFragment), this.indent();
    for (let t of e.children)
      this.print(t);
    this.dedent(), this.print(e.closingFragment);
  }
  n(kke, "JSXFragment");
  function Bke() {
    this.tokenChar(60), this.tokenChar(62);
  }
  n(Bke, "JSXOpeningFragment");
  function Nke() {
    this.token("</"), this.tokenChar(62);
  }
  n(Nke, "JSXClosingFragment");
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var dU = E((de) => {
  "use strict";
  Object.defineProperty(de, "__esModule", {
    value: !0
  });
  de.TSAnyKeyword = Xke;
  de.TSArrayType = yBe;
  de.TSSatisfiesExpression = de.TSAsExpression = NBe;
  de.TSBigIntKeyword = Yke;
  de.TSBooleanKeyword = eBe;
  de.TSCallSignatureDeclaration = Vke;
  de.TSInterfaceHeritage = de.TSClassImplements = IBe;
  de.TSConditionalType = SBe;
  de.TSConstructSignatureDeclaration = Wke;
  de.TSConstructorType = cBe;
  de.TSDeclareFunction = qke;
  de.TSDeclareMethod = Uke;
  de.TSEnumBody = fU;
  de.TSEnumDeclaration = LBe;
  de.TSEnumMember = jBe;
  de.TSExportAssignment = KBe;
  de.TSExternalModuleReference = WBe;
  de.TSFunctionType = lBe;
  de.TSImportEqualsDeclaration = VBe;
  de.TSImportType = $Be;
  de.TSIndexSignature = Jke;
  de.TSIndexedAccessType = ABe;
  de.TSInferType = TBe;
  de.TSInstantiationExpression = RBe;
  de.TSInterfaceBody = kBe;
  de.TSInterfaceDeclaration = OBe;
  de.TSIntersectionType = EBe;
  de.TSIntrinsicKeyword = oBe;
  de.TSLiteralType = FBe;
  de.TSMappedType = _Be;
  de.TSMethodSignature = zke;
  de.TSModuleBlock = UBe;
  de.TSModuleDeclaration = qBe;
  de.TSNamedTupleMember = vBe;
  de.TSNamespaceExportDeclaration = zBe;
  de.TSNeverKeyword = aBe;
  de.TSNonNullExpression = HBe;
  de.TSNullKeyword = nBe;
  de.TSNumberKeyword = Zke;
  de.TSObjectKeyword = Qke;
  de.TSOptionalType = bBe;
  de.TSParameterProperty = jke;
  de.TSParenthesizedType = CBe;
  de.TSPropertySignature = Hke;
  de.TSQualifiedName = $ke;
  de.TSRestType = DBe;
  de.TSStringKeyword = tBe;
  de.TSSymbolKeyword = rBe;
  de.TSTemplateLiteralType = PBe;
  de.TSThisType = uBe;
  de.TSTupleType = gBe;
  de.TSTypeAliasDeclaration = BBe;
  de.TSTypeAnnotation = Mke;
  de.TSTypeAssertion = MBe;
  de.TSTypeLiteral = mBe;
  de.TSTypeOperator = wBe;
  de.TSTypeParameter = Lke;
  de.TSTypeParameterDeclaration = de.TSTypeParameterInstantiation = Rke;
  de.TSTypePredicate = pBe;
  de.TSTypeQuery = hBe;
  de.TSTypeReference = dBe;
  de.TSUndefinedKeyword = sBe;
  de.TSUnionType = xBe;
  de.TSUnknownKeyword = Gke;
  de.TSVoidKeyword = iBe;
  de.tsPrintClassMemberModifiers = XBe;
  de.tsPrintFunctionOrConstructorType = fBe;
  de.tsPrintPropertyOrMethodName = Kke;
  de.tsPrintSignatureDeclarationBase = JBe;
  function Mke(e, t) {
    this.token((t.type === "TSFunctionType" || t.type === "TSConstructorType") && t.typeAnnotation === e ? "=>" : ":"), this.space(), e.optional &&
    this.tokenChar(63), this.print(e.typeAnnotation);
  }
  n(Mke, "TSTypeAnnotation");
  function Rke(e, t) {
    this.tokenChar(60);
    let r = t.type === "ArrowFunctionExpression" && e.params.length === 1;
    this.tokenMap && e.start != null && e.end != null && (r && (r = !!this.tokenMap.find(e, (i) => this.tokenMap.matchesOriginal(i, ","))), r ||
    (r = this.shouldPrintTrailingComma(">"))), this.printList(e.params, r), this.tokenChar(62);
  }
  n(Rke, "TSTypeParameterInstantiation");
  function Lke(e) {
    e.const && (this.word("const"), this.space()), e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.
    word(e.name), e.constraint && (this.space(), this.word("extends"), this.space(), this.print(e.constraint)), e.default && (this.space(), this.
    tokenChar(61), this.space(), this.print(e.default));
  }
  n(Lke, "TSTypeParameter");
  function jke(e) {
    e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
  }
  n(jke, "TSParameterProperty");
  function qke(e, t) {
    e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.semicolon();
  }
  n(qke, "TSDeclareFunction");
  function Uke(e) {
    this._classMethodHead(e), this.semicolon();
  }
  n(Uke, "TSDeclareMethod");
  function $ke(e) {
    this.print(e.left), this.tokenChar(46), this.print(e.right);
  }
  n($ke, "TSQualifiedName");
  function Vke(e) {
    this.tsPrintSignatureDeclarationBase(e), np(this, e);
  }
  n(Vke, "TSCallSignatureDeclaration");
  function np(e, t) {
    if (!e.tokenMap || !t.start || !t.end) {
      e.semicolon();
      return;
    }
    e.tokenMap.endMatches(t, ",") ? e.token(",") : e.tokenMap.endMatches(t, ";") && e.semicolon();
  }
  n(np, "maybePrintTrailingCommaOrSemicolon");
  function Wke(e) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), np(this, e);
  }
  n(Wke, "TSConstructSignatureDeclaration");
  function Hke(e) {
    let {
      readonly: t
    } = e;
    t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation), np(this, e);
  }
  n(Hke, "TSPropertySignature");
  function Kke(e) {
    e.computed && this.tokenChar(91), this.print(e.key), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
  }
  n(Kke, "tsPrintPropertyOrMethodName");
  function zke(e) {
    let {
      kind: t
    } = e;
    (t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(
    e), np(this, e);
  }
  n(zke, "TSMethodSignature");
  function Jke(e) {
    let {
      readonly: t,
      static: r
    } = e;
    r && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters,
    "]"), this.print(e.typeAnnotation), np(this, e);
  }
  n(Jke, "TSIndexSignature");
  function Xke() {
    this.word("any");
  }
  n(Xke, "TSAnyKeyword");
  function Yke() {
    this.word("bigint");
  }
  n(Yke, "TSBigIntKeyword");
  function Gke() {
    this.word("unknown");
  }
  n(Gke, "TSUnknownKeyword");
  function Zke() {
    this.word("number");
  }
  n(Zke, "TSNumberKeyword");
  function Qke() {
    this.word("object");
  }
  n(Qke, "TSObjectKeyword");
  function eBe() {
    this.word("boolean");
  }
  n(eBe, "TSBooleanKeyword");
  function tBe() {
    this.word("string");
  }
  n(tBe, "TSStringKeyword");
  function rBe() {
    this.word("symbol");
  }
  n(rBe, "TSSymbolKeyword");
  function iBe() {
    this.word("void");
  }
  n(iBe, "TSVoidKeyword");
  function sBe() {
    this.word("undefined");
  }
  n(sBe, "TSUndefinedKeyword");
  function nBe() {
    this.word("null");
  }
  n(nBe, "TSNullKeyword");
  function aBe() {
    this.word("never");
  }
  n(aBe, "TSNeverKeyword");
  function oBe() {
    this.word("intrinsic");
  }
  n(oBe, "TSIntrinsicKeyword");
  function uBe() {
    this.word("this");
  }
  n(uBe, "TSThisType");
  function lBe(e) {
    this.tsPrintFunctionOrConstructorType(e);
  }
  n(lBe, "TSFunctionType");
  function cBe(e) {
    e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
  }
  n(cBe, "TSConstructorType");
  function fBe(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t), this.tokenChar(40), this._parameters(r, ")"), this.space();
    let i = e.typeAnnotation;
    this.print(i);
  }
  n(fBe, "tsPrintFunctionOrConstructorType");
  function dBe(e) {
    let t = e.typeParameters;
    this.print(e.typeName, !!t), this.print(t);
  }
  n(dBe, "TSTypeReference");
  function pBe(e) {
    e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(e.typeAnnotation.typeAnnotation));
  }
  n(pBe, "TSTypePredicate");
  function hBe(e) {
    this.word("typeof"), this.space(), this.print(e.exprName);
    let t = e.typeParameters;
    t && this.print(t);
  }
  n(hBe, "TSTypeQuery");
  function mBe(e) {
    Uy(this, e, () => this.printJoin(e.members, !0, !0));
  }
  n(mBe, "TSTypeLiteral");
  function yBe(e) {
    this.print(e.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  n(yBe, "TSArrayType");
  function gBe(e) {
    this.tokenChar(91), this.printList(e.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
  }
  n(gBe, "TSTupleType");
  function bBe(e) {
    this.print(e.typeAnnotation), this.tokenChar(63);
  }
  n(bBe, "TSOptionalType");
  function DBe(e) {
    this.token("..."), this.print(e.typeAnnotation);
  }
  n(DBe, "TSRestType");
  function vBe(e) {
    this.print(e.label), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType);
  }
  n(vBe, "TSNamedTupleMember");
  function xBe(e) {
    cU(this, e, "|");
  }
  n(xBe, "TSUnionType");
  function EBe(e) {
    cU(this, e, "&");
  }
  n(EBe, "TSIntersectionType");
  function cU(e, t, r) {
    var i;
    let s = 0;
    (i = e.tokenMap) != null && i.startMatches(t, r) && (s = 1, e.token(r)), e.printJoin(t.types, void 0, void 0, function(a) {
      this.space(), this.token(r, void 0, a + s), this.space();
    });
  }
  n(cU, "tsPrintUnionOrIntersectionType");
  function SBe(e) {
    this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
  }
  n(SBe, "TSConditionalType");
  function TBe(e) {
    this.word("infer"), this.print(e.typeParameter);
  }
  n(TBe, "TSInferType");
  function CBe(e) {
    this.tokenChar(40), this.print(e.typeAnnotation), this.tokenChar(41);
  }
  n(CBe, "TSParenthesizedType");
  function wBe(e) {
    this.word(e.operator), this.space(), this.print(e.typeAnnotation);
  }
  n(wBe, "TSTypeOperator");
  function ABe(e) {
    this.print(e.objectType, !0), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
  }
  n(ABe, "TSIndexedAccessType");
  function _Be(e) {
    let {
      nameType: t,
      optional: r,
      readonly: i,
      typeAnnotation: s
    } = e;
    this.tokenChar(123);
    let a = this.enterDelimited();
    this.space(), i && (uU(this, i), this.word("readonly"), this.space()), this.tokenChar(91), this.word(e.typeParameter.name), this.space(),
    this.word("in"), this.space(), this.print(e.typeParameter.constraint), t && (this.space(), this.word("as"), this.space(), this.print(t)),
    this.tokenChar(93), r && (uU(this, r), this.tokenChar(63)), s && (this.tokenChar(58), this.space(), this.print(s)), this.space(), a(), this.
    tokenChar(125);
  }
  n(_Be, "TSMappedType");
  function uU(e, t) {
    t !== !0 && e.token(t);
  }
  n(uU, "tokenIfPlusMinus");
  function PBe(e) {
    this._printTemplate(e, e.types);
  }
  n(PBe, "TSTemplateLiteralType");
  function FBe(e) {
    this.print(e.literal);
  }
  n(FBe, "TSLiteralType");
  function IBe(e) {
    this.print(e.expression), this.print(e.typeArguments);
  }
  n(IBe, "TSClassImplements");
  function OBe(e) {
    let {
      declare: t,
      id: r,
      typeParameters: i,
      extends: s,
      body: a
    } = e;
    t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r), this.print(i), s != null && s.length && (this.
    space(), this.word("extends"), this.space(), this.printList(s)), this.space(), this.print(a);
  }
  n(OBe, "TSInterfaceDeclaration");
  function kBe(e) {
    Uy(this, e, () => this.printJoin(e.body, !0, !0));
  }
  n(kBe, "TSInterfaceBody");
  function BBe(e) {
    let {
      declare: t,
      id: r,
      typeParameters: i,
      typeAnnotation: s
    } = e;
    t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r), this.print(i), this.space(), this.tokenChar(61),
    this.space(), this.print(s), this.semicolon();
  }
  n(BBe, "TSTypeAliasDeclaration");
  function NBe(e) {
    let {
      type: t,
      expression: r,
      typeAnnotation: i
    } = e;
    this.print(r, !0), this.space(), this.word(t === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(i);
  }
  n(NBe, "TSTypeExpression");
  function MBe(e) {
    let {
      typeAnnotation: t,
      expression: r
    } = e;
    this.tokenChar(60), this.print(t), this.tokenChar(62), this.space(), this.print(r);
  }
  n(MBe, "TSTypeAssertion");
  function RBe(e) {
    this.print(e.expression), this.print(e.typeParameters);
  }
  n(RBe, "TSInstantiationExpression");
  function LBe(e) {
    let {
      declare: t,
      const: r,
      id: i
    } = e;
    t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(i), this.
    space(), fU.call(this, e);
  }
  n(LBe, "TSEnumDeclaration");
  function fU(e) {
    Uy(this, e, () => {
      var t;
      return this.printList(e.members, (t = this.shouldPrintTrailingComma("}")) != null ? t : !0, !0, !0);
    });
  }
  n(fU, "TSEnumBody");
  function jBe(e) {
    let {
      id: t,
      initializer: r
    } = e;
    this.print(t), r && (this.space(), this.tokenChar(61), this.space(), this.print(r));
  }
  n(jBe, "TSEnumMember");
  function qBe(e) {
    let {
      declare: t,
      id: r,
      kind: i
    } = e;
    t && (this.word("declare"), this.space());
    {
      if (e.global || (this.word(i ?? (r.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(r), !e.body) {
        this.semicolon();
        return;
      }
      let s = e.body;
      for (; s.type === "TSModuleDeclaration"; )
        this.tokenChar(46), this.print(s.id), s = s.body;
      this.space(), this.print(s);
    }
  }
  n(qBe, "TSModuleDeclaration");
  function UBe(e) {
    Uy(this, e, () => this.printSequence(e.body, !0));
  }
  n(UBe, "TSModuleBlock");
  function $Be(e) {
    let {
      argument: t,
      qualifier: r,
      options: i
    } = e;
    this.word("import"), this.tokenChar(40), this.print(t), i && (this.tokenChar(44), this.print(i)), this.tokenChar(41), r && (this.tokenChar(
    46), this.print(r));
    let s = e.typeParameters;
    s && this.print(s);
  }
  n($Be, "TSImportType");
  function VBe(e) {
    let {
      id: t,
      moduleReference: r
    } = e;
    e.isExport && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(t), this.space(), this.tokenChar(61), this.
    space(), this.print(r), this.semicolon();
  }
  n(VBe, "TSImportEqualsDeclaration");
  function WBe(e) {
    this.token("require("), this.print(e.expression), this.tokenChar(41);
  }
  n(WBe, "TSExternalModuleReference");
  function HBe(e) {
    this.print(e.expression), this.tokenChar(33);
  }
  n(HBe, "TSNonNullExpression");
  function KBe(e) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression), this.semicolon();
  }
  n(KBe, "TSExportAssignment");
  function zBe(e) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id), this.semicolon();
  }
  n(zBe, "TSNamespaceExportDeclaration");
  function JBe(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t), this.tokenChar(40), this._parameters(r, ")");
    let i = e.typeAnnotation;
    this.print(i);
  }
  n(JBe, "tsPrintSignatureDeclarationBase");
  function XBe(e) {
    let t = e.type === "ClassPrivateProperty", r = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
    lU(this, e, [r && e.declare && "declare", !t && e.accessibility]), e.static && (this.word("static"), this.space()), lU(this, e, [!t && e.
    abstract && "abstract", !t && e.override && "override", (r || t) && e.readonly && "readonly"]);
  }
  n(XBe, "tsPrintClassMemberModifiers");
  function Uy(e, t, r) {
    e.token("{");
    let i = e.enterDelimited();
    r(), i(), e.rightBrace(t);
  }
  n(Uy, "printBraced");
  function lU(e, t, r) {
    var i;
    let s = /* @__PURE__ */ new Set();
    for (let a of r)
      a && s.add(a);
    (i = e.tokenMap) == null || i.find(t, (a) => s.has(a.value) ? (e.token(a.value), e.space(), s.delete(a.value), s.size === 0) : !1);
    for (let a of s)
      e.word(a), e.space();
  }
  n(lU, "printModifiersList");
});

// ../node_modules/@babel/generator/lib/generators/index.js
var pU = E((it) => {
  "use strict";
  Object.defineProperty(it, "__esModule", {
    value: !0
  });
  var GC = jq();
  Object.keys(GC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in it && it[e] === GC[e] || Object.defineProperty(it, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return GC[e];
      }, "get")
    });
  });
  var ZC = Uq();
  Object.keys(ZC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in it && it[e] === ZC[e] || Object.defineProperty(it, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return ZC[e];
      }, "get")
    });
  });
  var QC = Hq();
  Object.keys(QC).forEach(function(e) {
    e === "default" || e === "__esModule" || e in it && it[e] === QC[e] || Object.defineProperty(it, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return QC[e];
      }, "get")
    });
  });
  var ew = Kq();
  Object.keys(ew).forEach(function(e) {
    e === "default" || e === "__esModule" || e in it && it[e] === ew[e] || Object.defineProperty(it, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return ew[e];
      }, "get")
    });
  });
  var tw = zq();
  Object.keys(tw).forEach(function(e) {
    e === "default" || e === "__esModule" || e in it && it[e] === tw[e] || Object.defineProperty(it, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return tw[e];
      }, "get")
    });
  });
  var rw = KC();
  Object.keys(rw).forEach(function(e) {
    e === "default" || e === "__esModule" || e in it && it[e] === rw[e] || Object.defineProperty(it, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return rw[e];
      }, "get")
    });
  });
  var iw = XC();
  Object.keys(iw).forEach(function(e) {
    e === "default" || e === "__esModule" || e in it && it[e] === iw[e] || Object.defineProperty(it, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return iw[e];
      }, "get")
    });
  });
  var sw = nU();
  Object.keys(sw).forEach(function(e) {
    e === "default" || e === "__esModule" || e in it && it[e] === sw[e] || Object.defineProperty(it, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return sw[e];
      }, "get")
    });
  });
  var nw = aU();
  Object.keys(nw).forEach(function(e) {
    e === "default" || e === "__esModule" || e in it && it[e] === nw[e] || Object.defineProperty(it, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return nw[e];
      }, "get")
    });
  });
  var aw = oU();
  Object.keys(aw).forEach(function(e) {
    e === "default" || e === "__esModule" || e in it && it[e] === aw[e] || Object.defineProperty(it, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return aw[e];
      }, "get")
    });
  });
  var ow = dU();
  Object.keys(ow).forEach(function(e) {
    e === "default" || e === "__esModule" || e in it && it[e] === ow[e] || Object.defineProperty(it, e, {
      enumerable: !0,
      get: /* @__PURE__ */ n(function() {
        return ow[e];
      }, "get")
    });
  });
});

// ../node_modules/@babel/generator/lib/generators/deprecated.js
var hU = E((uw) => {
  "use strict";
  Object.defineProperty(uw, "__esModule", {
    value: !0
  });
  uw.addDeprecatedGenerators = YBe;
  function YBe(e) {
    {
      let t = {
        Noop() {
        },
        TSExpressionWithTypeArguments(r) {
          this.print(r.expression), this.print(r.typeParameters);
        },
        DecimalLiteral(r) {
          let i = this.getPossibleRaw(r);
          if (!this.format.minified && i !== void 0) {
            this.word(i);
            return;
          }
          this.word(r.value + "m");
        }
      };
      Object.assign(e.prototype, t);
    }
  }
  n(YBe, "addDeprecatedGenerators");
});

// ../node_modules/@babel/generator/lib/printer.js
var bU = E(($y) => {
  "use strict";
  Object.defineProperty($y, "__esModule", {
    value: !0
  });
  $y.default = void 0;
  var GBe = xq(), Vr = tu(), yU = Vr, ZBe = Pe(), QBe = Lq(), eNe = pU(), tNe = hU(), {
    isExpression: rNe,
    isFunction: iNe,
    isStatement: sNe,
    isClassBody: nNe,
    isTSInterfaceBody: aNe,
    isTSEnumMember: oNe
  } = ZBe, uNe = /e/i, lNe = /\.0+$/, gU = /[\n\r\u2028\u2029]/, cNe = /[\n\r\u2028\u2029]|\*\//;
  function mU(e) {
    return e.type === "CommentLine" || gU.test(e.value);
  }
  n(mU, "commentIsNewline");
  var {
    needsParens: fNe
  } = yU, ap = class {
    static {
      n(this, "Printer");
    }
    constructor(t, r, i = null, s = null) {
      this.tokenContext = Vr.TokenContext.normal, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent = 0,
      this._indentRepeat = 0, this._insideAux = !1, this._noLineTerminator = !1, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode =
      !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._endsWithDiv = !1, this.
      _lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.tokenMap = null, this._boundGetRawIdentifier =
      this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = t,
      this._tokens = i, this._originalCode = s, this._indentRepeat = t.indent.style.length, this._inputMap = r?._inputMap || null, this._buf =
      new GBe.default(r, t.indent.style[0]);
    }
    enterForStatementInit() {
      return this.tokenContext |= Vr.TokenContext.forInitHead | Vr.TokenContext.forInOrInitHeadAccumulate, () => this.tokenContext = Vr.TokenContext.
      normal;
    }
    enterForXStatementInit(t) {
      return t ? (this.tokenContext |= Vr.TokenContext.forOfHead, null) : (this.tokenContext |= Vr.TokenContext.forInHead | Vr.TokenContext.
      forInOrInitHeadAccumulate, () => this.tokenContext = Vr.TokenContext.normal);
    }
    enterDelimited() {
      let t = this.tokenContext, r = this._noLineTerminatorAfterNode;
      return !(t & Vr.TokenContext.forInOrInitHeadAccumulate) && r === null ? () => {
      } : (this._noLineTerminatorAfterNode = null, this.tokenContext = Vr.TokenContext.normal, () => {
        this._noLineTerminatorAfterNode = r, this.tokenContext = t;
      });
    }
    generate(t) {
      return this.format.preserveFormat && (this.tokenMap = new QBe.TokenMap(t, this._tokens, this._originalCode)), this.print(t), this._maybeAddAuxComment(),
      this._buf.get();
    }
    indent() {
      let {
        format: t
      } = this;
      t.preserveFormat || t.compact || t.concise || this._indent++;
    }
    dedent() {
      let {
        format: t
      } = this;
      t.preserveFormat || t.compact || t.concise || this._indent--;
    }
    semicolon(t = !1) {
      if (this._maybeAddAuxComment(), t) {
        this._appendChar(59), this._noLineTerminator = !1;
        return;
      }
      if (this.tokenMap) {
        let r = this._currentNode;
        if (r.start != null && r.end != null) {
          if (!this.tokenMap.endMatches(r, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          let i = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[i[i.length - 1]].loc.start);
        }
      }
      this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(t) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
    }
    rightParens(t) {
      this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
    }
    space(t = !1) {
      let {
        format: r
      } = this;
      if (!(r.compact || r.preserveFormat)) {
        if (t)
          this._space();
        else if (this._buf.hasContent()) {
          let i = this.getLastChar();
          i !== 32 && i !== 10 && this._space();
        }
      }
    }
    word(t, r = !1) {
      this.tokenContext &= Vr.TokenContext.forInOrInitHeadAccumulatePassThroughMask, this._maybePrintInnerComments(t), this._maybeAddAuxComment(),
      this.tokenMap && this._catchUpToCurrentToken(t), (this._endsWithWord || this._endsWithDiv && t.charCodeAt(0) === 47) && this._space(),
      this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator = r;
    }
    number(t, r) {
      function i(s) {
        if (s.length > 2 && s.charCodeAt(0) === 48) {
          let a = s.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      n(i, "isNonDecimalLiteral"), this.word(t), this._endsWithInteger = Number.isInteger(r) && !i(t) && !uNe.test(t) && !lNe.test(t) && t.charCodeAt(
      t.length - 1) !== 46;
    }
    token(t, r = !1, i = 0) {
      this.tokenContext &= Vr.TokenContext.forInOrInitHeadAccumulatePassThroughMask, this._maybePrintInnerComments(t, i), this._maybeAddAuxComment(),
      this.tokenMap && this._catchUpToCurrentToken(t, i);
      let s = this.getLastChar(), a = t.charCodeAt(0);
      (s === 33 && (t === "--" || a === 61) || a === 43 && s === 43 || a === 45 && s === 45 || a === 46 && this._endsWithInteger) && this._space(),
      this._append(t, r), this._noLineTerminator = !1;
    }
    tokenChar(t) {
      this.tokenContext &= Vr.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
      let r = String.fromCharCode(t);
      this._maybePrintInnerComments(r), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(r);
      let i = this.getLastChar();
      (t === 43 && i === 43 || t === 45 && i === 45 || t === 46 && this._endsWithInteger) && this._space(), this._appendChar(t), this._noLineTerminator =
      !1;
    }
    newline(t = 1, r) {
      if (!(t <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        t > 2 && (t = 2), t -= this._buf.getNewlineCount();
        for (let i = 0; i < t; i++)
          this._newline();
      }
    }
    endsWith(t) {
      return this.getLastChar() === t;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(t, r) {
      if (!t) {
        r();
        return;
      }
      this._catchUp("start", t), this._buf.exactSource(t, r);
    }
    source(t, r) {
      r && (this._catchUp(t, r), this._buf.source(t, r));
    }
    sourceWithOffset(t, r, i) {
      !r || this.format.preserveFormat || (this._catchUp(t, r), this._buf.sourceWithOffset(t, r, i));
    }
    sourceIdentifierName(t, r) {
      if (!this._buf._canMarkIdName) return;
      let i = this._buf._sourcePosition;
      i.identifierNamePos = r, i.identifierName = t;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(t, r = 0) {
      let i = this.tokenMap.findMatching(this._currentNode, t, r);
      i && this._catchUpTo(i.loc.start), this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() &&
      (this._buf.appendChar(59), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1), this._printSemicolonBeforeNextToken =
      -1, this._printSemicolonBeforeNextNode = -1;
    }
    _append(t, r) {
      this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, r), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _appendChar(t) {
      this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _queue(t) {
      this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(t) {
      this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(t) {
      if (this._indent && t !== 10 && this.endsWith(10))
        return !0;
    }
    catchUp(t) {
      if (!this.format.retainLines) return;
      let r = t - this._buf.getCurrentLine();
      for (let i = 0; i < r; i++)
        this._newline();
    }
    _catchUp(t, r) {
      let {
        format: i
      } = this;
      if (!i.preserveFormat) {
        i.retainLines && r != null && r[t] && this.catchUp(r[t].line);
        return;
      }
      let s = r?.[t];
      s != null && this._catchUpTo(s);
    }
    _catchUpTo({
      line: t,
      column: r,
      index: i
    }) {
      let s = t - this._buf.getCurrentLine();
      if (s > 0 && this._noLineTerminator)
        return;
      for (let o = 0; o < s; o++)
        this._newline();
      let a = s > 0 ? r : r - this._buf.getCurrentColumn();
      if (a > 0) {
        let o = this._originalCode ? this._originalCode.slice(i - a, i).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu,
        " ") : " ".repeat(a);
        this._append(o, !1);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(t) {
      this._noLineTerminator = !0, this.print(t);
    }
    print(t, r = !1, i) {
      var s, a, o;
      if (!t) return;
      this._endsWithInnerRaw = !1;
      let u = t.type, l = this.format, c = l.concise;
      t._compact && (l.concise = !0);
      let f = this[u];
      if (f === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(u)} with constructor ${JSON.stringify(t.constructor.name)}`);
      let m = this._currentNode;
      this._currentNode = t, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
      let h = this._insideAux;
      this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !h);
      let d = (s = t.extra) == null ? void 0 : s.parenthesized, y = d && l.preserveFormat || d && l.retainFunctionParens && u === "FunctionE\
xpression" || fNe(t, m, this.tokenContext, l.preserveFormat ? this._boundGetRawIdentifier : void 0);
      if (!y && d && (a = t.leadingComments) != null && a.length && t.leadingComments[0].type === "CommentBlock")
        switch (m?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (m.callee !== t) break;
          default:
            y = !0;
        }
      let p = !1;
      !y && this._noLineTerminator && ((o = t.leadingComments) != null && o.some(mU) || this.format.retainLines && t.loc && t.loc.start.line >
      this._buf.getCurrentLine()) && (y = !0, p = !0);
      let g, b;
      if (!y && (r || (r = !!m && this._noLineTerminatorAfterNode === m && yU.isLastChild(m, t)), r)) {
        var D;
        (D = t.trailingComments) != null && D.some(mU) ? rNe(t) && (y = !0) : (g = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode =
        t);
      }
      y && (this.tokenChar(40), p && this.indent(), this._endsWithInnerRaw = !1, this.tokenContext & Vr.TokenContext.forInOrInitHeadAccumulate &&
      (b = this.tokenContext, this.tokenContext = Vr.TokenContext.normal), g = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode =
      null), this._lastCommentLine = 0, this._printLeadingComments(t, m);
      let x = u === "Program" || u === "File" ? null : t.loc;
      this.exactSource(x, f.bind(this, t, m)), y ? (this._printTrailingComments(t, m), p && (this.dedent(), this.newline()), this.tokenChar(
      41), this._noLineTerminator = r, b && (this.tokenContext = b)) : r && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(
      t, m)) : this._printTrailingComments(t, m, i), this._currentNode = m, l.concise = c, this._insideAux = h, g !== void 0 && (this._noLineTerminatorAfterNode =
      g), this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(t) {
      t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let t = this.format.auxiliaryCommentBefore;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let t = this.format.auxiliaryCommentAfter;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    getPossibleRaw(t) {
      let r = t.extra;
      if (r?.raw != null && r.rawValue != null && t.value === r.rawValue)
        return r.raw;
    }
    printJoin(t, r, i, s, a, o, u) {
      if (!(t != null && t.length)) return;
      if (i == null && this.format.retainLines) {
        var l;
        let y = (l = t[0].loc) == null ? void 0 : l.start.line;
        y != null && y !== this._buf.getCurrentLine() && (i = !0);
      }
      i && this.indent();
      let c = {
        nextNodeStartLine: 0
      }, f = s?.bind(this), m = t.length;
      for (let y = 0; y < m; y++) {
        let p = t[y];
        if (p && (r && this._printNewline(y === 0, c), this.print(p, void 0, u || 0), o?.(p, y), f != null && (y < m - 1 ? f(y, !1) : a && f(
        y, !0)), r)) {
          var h;
          if ((h = p.trailingComments) != null && h.length || (this._lastCommentLine = 0), y + 1 === m)
            this.newline(1);
          else {
            var d;
            let g = t[y + 1];
            c.nextNodeStartLine = ((d = g.loc) == null ? void 0 : d.start.line) || 0, this._printNewline(!0, c);
          }
        }
      }
      i && this.dedent();
    }
    printAndIndentOnComments(t) {
      let r = t.leadingComments && t.leadingComments.length > 0;
      r && this.indent(), this.print(t), r && this.dedent();
    }
    printBlock(t) {
      let r = t.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r);
    }
    _printTrailingComments(t, r, i) {
      let {
        innerComments: s,
        trailingComments: a
      } = t;
      s != null && s.length && this._printComments(2, s, t, r, i), a != null && a.length && this._printComments(2, a, t, r, i);
    }
    _printLeadingComments(t, r) {
      let i = t.leadingComments;
      i != null && i.length && this._printComments(0, i, t, r);
    }
    _maybePrintInnerComments(t, r) {
      if (this._endsWithInnerRaw) {
        var i;
        this.printInnerComments((i = this.tokenMap) == null ? void 0 : i.findMatching(this._currentNode, t, r));
      }
      this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments(t) {
      let r = this._currentNode, i = r.innerComments;
      if (!(i != null && i.length)) return;
      let s = this.endsWith(32), a = this._indentInnerComments, o = this._printedComments.size;
      a && this.indent(), this._printComments(1, i, r, void 0, void 0, t), s && o !== this._printedComments.size && this.space(), a && this.
      dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(t, r, i) {
      this.printJoin(t, !0, r ?? !1, void 0, void 0, void 0, i);
    }
    printList(t, r, i, s, a, o) {
      this.printJoin(t, i, s, a ?? dNe, r, o);
    }
    shouldPrintTrailingComma(t) {
      if (!this.tokenMap) return null;
      let r = this.tokenMap.findLastIndex(this._currentNode, (i) => this.tokenMap.matchesOriginal(i, t));
      return r <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[r - 1], ",");
    }
    _printNewline(t, r) {
      let i = this.format;
      if (i.retainLines || i.compact) return;
      if (i.concise) {
        this.space();
        return;
      }
      if (!t)
        return;
      let s = r.nextNodeStartLine, a = this._lastCommentLine;
      if (s > 0 && a > 0) {
        let o = s - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(t, r) {
      if (t.ignore || this._printedComments.has(t)) return 0;
      if (this._noLineTerminator && cNe.test(t.value))
        return 2;
      if (r && this.tokenMap) {
        let i = this.tokenMap.find(this._currentNode, (s) => s.value === t.value);
        if (i && i.start > r.start)
          return 2;
      }
      return this._printedComments.add(t), this.format.shouldPrintComment(t.value) ? 1 : 0;
    }
    _printComment(t, r) {
      let i = this._noLineTerminator, s = t.type === "CommentBlock", a = s && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && o !== 40 && this.space();
      let u;
      if (s) {
        if (u = `/*${t.value}*/`, this.format.indent.adjustMultilineComment) {
          var l;
          let c = (l = t.loc) == null ? void 0 : l.start.column;
          if (c) {
            let f = new RegExp("\\n\\s{1," + c + "}", "g");
            u = u.replace(f, `
`);
          }
          if (this.format.concise)
            u = u.replace(/\n(?!$)/g, `
`);
          else {
            let f = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (f += this._getIndent()), u = u.replace(/\n(?!$)/g, `
${" ".repeat(f)}`);
          }
        }
      } else i ? u = `/*${t.value}*/` : u = `//${t.value}`;
      if (this._endsWithDiv && this._space(), this.tokenMap) {
        let {
          _printSemicolonBeforeNextToken: c,
          _printSemicolonBeforeNextNode: f
        } = this;
        this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", t.loc), this._append(u, s), this.
        _printSemicolonBeforeNextNode = f, this._printSemicolonBeforeNextToken = c;
      } else
        this.source("start", t.loc), this._append(u, s);
      !s && !i && this.newline(1, !0), a && r !== 3 && this.newline(1);
    }
    _printComments(t, r, i, s, a = 0, o) {
      let u = i.loc, l = r.length, c = !!u, f = c ? u.start.line : 0, m = c ? u.end.line : 0, h = 0, d = 0, y = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let p = 0; p < l; p++) {
        let g = r[p], b = this._shouldPrintComment(g, o);
        if (b === 2) {
          c = !1;
          break;
        }
        if (c && g.loc && b === 1) {
          let D = g.loc.start.line, x = g.loc.end.line;
          if (t === 0) {
            let T = 0;
            p === 0 ? this._buf.hasContent() && (g.type === "CommentLine" || D !== x) && (T = d = 1) : T = D - h, h = x, y(T), this._printComment(
            g, 1), p + 1 === l && (y(Math.max(f - h, d)), h = f);
          } else if (t === 1) {
            let T = D - (p === 0 ? f : h);
            h = x, y(T), this._printComment(g, 1), p + 1 === l && (y(Math.min(1, m - h)), h = m);
          } else {
            let T = D - (p === 0 ? m - a : h);
            h = x, y(T), this._printComment(g, 1);
          }
        } else {
          if (c = !1, b !== 1)
            continue;
          if (l === 1) {
            let D = g.loc ? g.loc.start.line === g.loc.end.line : !gU.test(g.value), x = D && !sNe(i) && !nNe(s) && !aNe(s) && !oNe(i);
            t === 0 ? this._printComment(g, x && i.type !== "ObjectExpression" || D && iNe(s, {
              body: i
            }) ? 1 : 0) : x && t === 2 ? this._printComment(g, 1) : this._printComment(g, 0);
          } else t === 1 && !(i.type === "ObjectExpression" && i.properties.length > 1) && i.type !== "ClassBody" && i.type !== "TSInterface\
Body" ? this._printComment(g, p === 0 ? 2 : p === l - 1 ? 3 : 0) : this._printComment(g, 0);
        }
      }
      t === 2 && c && h && (this._lastCommentLine = h);
    }
  };
  Object.assign(ap.prototype, eNe);
  (0, tNe.addDeprecatedGenerators)(ap);
  var wgt = $y.default = ap;
  function dNe(e, t) {
    this.token(",", !1, e), t || this.space();
  }
  n(dNe, "commaSeparator");
});

// ../node_modules/@babel/generator/lib/index.js
var op = E((Zl) => {
  "use strict";
  Object.defineProperty(Zl, "__esModule", {
    value: !0
  });
  Zl.default = void 0;
  Zl.generate = EU;
  var DU = vq(), vU = bU();
  function xU(e, t, r) {
    if (t.experimental_preserveFormat) {
      if (typeof e != "string")
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      if (!t.retainLines)
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      if (t.compact && t.compact !== "auto")
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      if (t.minified)
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      if (t.jsescOption)
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      if (!Array.isArray(r.tokens))
        throw new Error("`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable th\
e `tokens: true` parser option.");
    }
    let i = {
      auxiliaryCommentBefore: t.auxiliaryCommentBefore,
      auxiliaryCommentAfter: t.auxiliaryCommentAfter,
      shouldPrintComment: t.shouldPrintComment,
      preserveFormat: t.experimental_preserveFormat,
      retainLines: t.retainLines,
      retainFunctionParens: t.retainFunctionParens,
      comments: t.comments == null || t.comments,
      compact: t.compact,
      minified: t.minified,
      concise: t.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, t.jsescOption),
      topicToken: t.topicToken,
      importAttributesKeyword: t.importAttributesKeyword
    };
    {
      var s;
      i.decoratorsBeforeExport = t.decoratorsBeforeExport, i.jsescOption.json = t.jsonCompatibleStrings, i.recordAndTupleSyntaxType = (s = t.
      recordAndTupleSyntaxType) != null ? s : "hash";
    }
    i.minified ? (i.compact = !0, i.shouldPrintComment = i.shouldPrintComment || (() => i.comments)) : i.shouldPrintComment = i.shouldPrintComment ||
    ((l) => i.comments || l.includes("@license") || l.includes("@preserve")), i.compact === "auto" && (i.compact = typeof e == "string" && e.
    length > 5e5, i.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds th\
e max of 500KB.`)), (i.compact || i.preserveFormat) && (i.indent.adjustMultilineComment = !1);
    let {
      auxiliaryCommentBefore: a,
      auxiliaryCommentAfter: o,
      shouldPrintComment: u
    } = i;
    return a && !u(a) && (i.auxiliaryCommentBefore = void 0), o && !u(o) && (i.auxiliaryCommentAfter = void 0), i;
  }
  n(xU, "normalizeOptions");
  Zl.CodeGenerator = class {
    static {
      n(this, "CodeGenerator");
    }
    constructor(t, r = {}, i) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = t, this._format = xU(i, r, t), this._map = r.sourceMaps ? new DU.
      default(r, i) : null;
    }
    generate() {
      return new vU.default(this._format, this._map).generate(this._ast);
    }
  };
  function EU(e, t = {}, r) {
    let i = xU(r, t, e), s = t.sourceMaps ? new DU.default(t, r) : null;
    return new vU.default(i, s, e.tokens, typeof r == "string" ? r : null).generate(e);
  }
  n(EU, "generate");
  var Fgt = Zl.default = EU;
});

// ../node_modules/@babel/traverse/lib/path/ancestry.js
var SU = E((Yi) => {
  "use strict";
  Object.defineProperty(Yi, "__esModule", {
    value: !0
  });
  Yi.find = yNe;
  Yi.findParent = mNe;
  Yi.getAncestry = xNe;
  Yi.getDeepestCommonAncestorFrom = vNe;
  Yi.getEarliestCommonAncestorFrom = DNe;
  Yi.getFunctionParent = gNe;
  Yi.getStatementParent = bNe;
  Yi.inType = TNe;
  Yi.isAncestor = ENe;
  Yi.isDescendant = SNe;
  var pNe = Pe(), {
    VISITOR_KEYS: hNe
  } = pNe;
  function mNe(e) {
    let t = this;
    for (; t = t.parentPath; )
      if (e(t)) return t;
    return null;
  }
  n(mNe, "findParent");
  function yNe(e) {
    let t = this;
    do
      if (e(t)) return t;
    while (t = t.parentPath);
    return null;
  }
  n(yNe, "find");
  function gNe() {
    return this.findParent((e) => e.isFunction());
  }
  n(gNe, "getFunctionParent");
  function bNe() {
    let e = this;
    do {
      if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
        break;
      e = e.parentPath;
    } while (e);
    if (e && (e.isProgram() || e.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return e;
  }
  n(bNe, "getStatementParent");
  function DNe(e) {
    return this.getDeepestCommonAncestorFrom(e, function(t, r, i) {
      let s, a = hNe[t.type];
      for (let o of i) {
        let u = o[r + 1];
        if (!s) {
          s = u;
          continue;
        }
        if (u.listKey && s.listKey === u.listKey && u.key < s.key) {
          s = u;
          continue;
        }
        let l = a.indexOf(s.parentKey), c = a.indexOf(u.parentKey);
        l > c && (s = u);
      }
      return s;
    });
  }
  n(DNe, "getEarliestCommonAncestorFrom");
  function vNe(e, t) {
    if (!e.length)
      return this;
    if (e.length === 1)
      return e[0];
    let r = 1 / 0, i, s, a = e.map((u) => {
      let l = [];
      do
        l.unshift(u);
      while ((u = u.parentPath) && u !== this);
      return l.length < r && (r = l.length), l;
    }), o = a[0];
    e: for (let u = 0; u < r; u++) {
      let l = o[u];
      for (let c of a)
        if (c[u] !== l)
          break e;
      i = u, s = l;
    }
    if (s)
      return t ? t(s, i, a) : s;
    throw new Error("Couldn't find intersection");
  }
  n(vNe, "getDeepestCommonAncestorFrom");
  function xNe() {
    let e = this, t = [];
    do
      t.push(e);
    while (e = e.parentPath);
    return t;
  }
  n(xNe, "getAncestry");
  function ENe(e) {
    return e.isDescendant(this);
  }
  n(ENe, "isAncestor");
  function SNe(e) {
    return !!this.findParent((t) => t === e);
  }
  n(SNe, "isDescendant");
  function TNe(...e) {
    let t = this;
    for (; t; ) {
      if (e.includes(t.node.type)) return !0;
      t = t.parentPath;
    }
    return !1;
  }
  n(TNe, "inType");
});

// ../node_modules/@babel/traverse/lib/path/inference/util.js
var cw = E((lw) => {
  "use strict";
  Object.defineProperty(lw, "__esModule", {
    value: !0
  });
  lw.createUnionType = PNe;
  var CNe = Pe(), {
    createFlowUnionType: TU,
    createTSUnionType: CU,
    createUnionTypeAnnotation: wNe,
    isFlowType: ANe,
    isTSType: _Ne
  } = CNe;
  function PNe(e) {
    {
      if (e.every((t) => ANe(t)))
        return TU ? TU(e) : wNe(e);
      if (e.every((t) => _Ne(t)) && CU)
        return CU(e);
    }
  }
  n(PNe, "createUnionType");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var FU = E((fw) => {
  "use strict";
  Object.defineProperty(fw, "__esModule", {
    value: !0
  });
  fw.default = BNe;
  var FNe = Pe(), AU = cw(), {
    BOOLEAN_NUMBER_BINARY_OPERATORS: INe,
    createTypeAnnotationBasedOnTypeof: ONe,
    numberTypeAnnotation: _U,
    voidTypeAnnotation: kNe
  } = FNe;
  function BNe(e) {
    if (!this.isReferenced()) return;
    let t = this.scope.getBinding(e.name);
    if (t)
      return t.identifier.typeAnnotation ? t.identifier.typeAnnotation : NNe(t, this, e.name);
    if (e.name === "undefined")
      return kNe();
    if (e.name === "NaN" || e.name === "Infinity")
      return _U();
    e.name;
  }
  n(BNe, "_default");
  function NNe(e, t, r) {
    let i = [], s = [], a = wU(e, t, s), o = PU(e, t, r);
    if (o) {
      let u = wU(e, o.ifStatement);
      a = a.filter((l) => !u.includes(l)), i.push(o.typeAnnotation);
    }
    if (a.length) {
      a.push(...s);
      for (let u of a)
        i.push(u.getTypeAnnotation());
    }
    if (i.length)
      return (0, AU.createUnionType)(i);
  }
  n(NNe, "getTypeAnnotationBindingConstantViolations");
  function wU(e, t, r) {
    let i = e.constantViolations.slice();
    return i.unshift(e.path), i.filter((s) => {
      s = s.resolve();
      let a = s._guessExecutionStatusRelativeTo(t);
      return r && a === "unknown" && r.push(s), a === "before";
    });
  }
  n(wU, "getConstantViolationsBefore");
  function MNe(e, t) {
    let r = t.node.operator, i = t.get("right").resolve(), s = t.get("left").resolve(), a;
    if (s.isIdentifier({
      name: e
    }) ? a = i : i.isIdentifier({
      name: e
    }) && (a = s), a)
      return r === "===" ? a.getTypeAnnotation() : INe.includes(r) ? _U() : void 0;
    if (r !== "===" && r !== "==") return;
    let o, u;
    if (s.isUnaryExpression({
      operator: "typeof"
    }) ? (o = s, u = i) : i.isUnaryExpression({
      operator: "typeof"
    }) && (o = i, u = s), !o || !o.get("argument").isIdentifier({
      name: e
    }) || (u = u.resolve(), !u.isLiteral())) return;
    let l = u.node.value;
    if (typeof l == "string")
      return ONe(l);
  }
  n(MNe, "inferAnnotationFromBinaryExpression");
  function RNe(e, t, r) {
    let i;
    for (; i = t.parentPath; ) {
      if (i.isIfStatement() || i.isConditionalExpression())
        return t.key === "test" ? void 0 : i;
      if (i.isFunction() && (r == null || i.parentPath.scope.getBinding(r) !== e))
        return;
      t = i;
    }
  }
  n(RNe, "getParentConditionalPath");
  function PU(e, t, r) {
    let i = RNe(e, t, r);
    if (!i) return;
    let a = [i.get("test")], o = [];
    for (let u = 0; u < a.length; u++) {
      let l = a[u];
      if (l.isLogicalExpression())
        l.node.operator === "&&" && (a.push(l.get("left")), a.push(l.get("right")));
      else if (l.isBinaryExpression()) {
        let c = MNe(r, l);
        c && o.push(c);
      }
    }
    return o.length ? {
      typeAnnotation: (0, AU.createUnionType)(o),
      ifStatement: i
    } : PU(e, i, r);
  }
  n(PU, "getConditionalAnnotation");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferers.js
var LU = E((ot) => {
  "use strict";
  Object.defineProperty(ot, "__esModule", {
    value: !0
  });
  ot.ArrayExpression = NU;
  ot.AssignmentExpression = aMe;
  ot.BinaryExpression = tMe;
  ot.BooleanLiteral = cMe;
  ot.CallExpression = DMe;
  ot.ConditionalExpression = iMe;
  ot.ClassDeclaration = ot.ClassExpression = ot.FunctionDeclaration = ot.ArrowFunctionExpression = ot.FunctionExpression = hMe;
  Object.defineProperty(ot, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jNe.default;
    }, "get")
  });
  ot.LogicalExpression = rMe;
  ot.NewExpression = ZNe;
  ot.NullLiteral = fMe;
  ot.NumericLiteral = lMe;
  ot.ObjectExpression = pMe;
  ot.ParenthesizedExpression = nMe;
  ot.RegExpLiteral = dMe;
  ot.RestElement = MU;
  ot.SequenceExpression = sMe;
  ot.StringLiteral = uMe;
  ot.TSAsExpression = BU;
  ot.TSNonNullExpression = GNe;
  ot.TaggedTemplateExpression = vMe;
  ot.TemplateLiteral = QNe;
  ot.TypeCastExpression = kU;
  ot.UnaryExpression = eMe;
  ot.UpdateExpression = oMe;
  ot.VariableDeclarator = YNe;
  var LNe = Pe(), jNe = FU(), OU = cw(), {
    BOOLEAN_BINARY_OPERATORS: qNe,
    BOOLEAN_UNARY_OPERATORS: UNe,
    NUMBER_BINARY_OPERATORS: $Ne,
    NUMBER_UNARY_OPERATORS: VNe,
    STRING_UNARY_OPERATORS: WNe,
    anyTypeAnnotation: IU,
    arrayTypeAnnotation: dw,
    booleanTypeAnnotation: pw,
    buildMatchMemberExpression: Vy,
    genericTypeAnnotation: qa,
    identifier: ru,
    nullLiteralTypeAnnotation: HNe,
    numberTypeAnnotation: Ql,
    stringTypeAnnotation: iu,
    tupleTypeAnnotation: KNe,
    unionTypeAnnotation: zNe,
    voidTypeAnnotation: JNe,
    isIdentifier: XNe
  } = LNe;
  function YNe() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  n(YNe, "VariableDeclarator");
  function kU(e) {
    return e.typeAnnotation;
  }
  n(kU, "TypeCastExpression");
  kU.validParent = !0;
  function BU(e) {
    return e.typeAnnotation;
  }
  n(BU, "TSAsExpression");
  BU.validParent = !0;
  function GNe() {
    return this.get("expression").getTypeAnnotation();
  }
  n(GNe, "TSNonNullExpression");
  function ZNe(e) {
    if (e.callee.type === "Identifier")
      return qa(e.callee);
  }
  n(ZNe, "NewExpression");
  function QNe() {
    return iu();
  }
  n(QNe, "TemplateLiteral");
  function eMe(e) {
    let t = e.operator;
    if (t === "void")
      return JNe();
    if (VNe.includes(t))
      return Ql();
    if (WNe.includes(t))
      return iu();
    if (UNe.includes(t))
      return pw();
  }
  n(eMe, "UnaryExpression");
  function tMe(e) {
    let t = e.operator;
    if ($Ne.includes(t))
      return Ql();
    if (qNe.includes(t))
      return pw();
    if (t === "+") {
      let r = this.get("right"), i = this.get("left");
      return i.isBaseType("number") && r.isBaseType("number") ? Ql() : i.isBaseType("string") || r.isBaseType("string") ? iu() : zNe([iu(), Ql()]);
    }
  }
  n(tMe, "BinaryExpression");
  function rMe() {
    let e = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, OU.createUnionType)(e);
  }
  n(rMe, "LogicalExpression");
  function iMe() {
    let e = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, OU.createUnionType)(e);
  }
  n(iMe, "ConditionalExpression");
  function sMe() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  n(sMe, "SequenceExpression");
  function nMe() {
    return this.get("expression").getTypeAnnotation();
  }
  n(nMe, "ParenthesizedExpression");
  function aMe() {
    return this.get("right").getTypeAnnotation();
  }
  n(aMe, "AssignmentExpression");
  function oMe(e) {
    let t = e.operator;
    if (t === "++" || t === "--")
      return Ql();
  }
  n(oMe, "UpdateExpression");
  function uMe() {
    return iu();
  }
  n(uMe, "StringLiteral");
  function lMe() {
    return Ql();
  }
  n(lMe, "NumericLiteral");
  function cMe() {
    return pw();
  }
  n(cMe, "BooleanLiteral");
  function fMe() {
    return HNe();
  }
  n(fMe, "NullLiteral");
  function dMe() {
    return qa(ru("RegExp"));
  }
  n(dMe, "RegExpLiteral");
  function pMe() {
    return qa(ru("Object"));
  }
  n(pMe, "ObjectExpression");
  function NU() {
    return qa(ru("Array"));
  }
  n(NU, "ArrayExpression");
  function MU() {
    return NU();
  }
  n(MU, "RestElement");
  MU.validParent = !0;
  function hMe() {
    return qa(ru("Function"));
  }
  n(hMe, "Func");
  var mMe = Vy("Array.from"), yMe = Vy("Object.keys"), gMe = Vy("Object.values"), bMe = Vy("Object.entries");
  function DMe() {
    let {
      callee: e
    } = this.node;
    return yMe(e) ? dw(iu()) : mMe(e) || gMe(e) || XNe(e, {
      name: "Array"
    }) ? dw(IU()) : bMe(e) ? dw(KNe([iu(), IU()])) : RU(this.get("callee"));
  }
  n(DMe, "CallExpression");
  function vMe() {
    return RU(this.get("tag"));
  }
  n(vMe, "TaggedTemplateExpression");
  function RU(e) {
    if (e = e.resolve(), e.isFunction()) {
      let {
        node: t
      } = e;
      if (t.async)
        return t.generator ? qa(ru("AsyncIterator")) : qa(ru("Promise"));
      if (t.generator)
        return qa(ru("Iterator"));
      if (e.node.returnType)
        return e.node.returnType;
    }
  }
  n(RU, "resolveCall");
});

// ../node_modules/@babel/traverse/lib/path/inference/index.js
var VU = E((Ua) => {
  "use strict";
  Object.defineProperty(Ua, "__esModule", {
    value: !0
  });
  Ua._getTypeAnnotation = $U;
  Ua.baseTypeStrictlyMatches = $Me;
  Ua.couldBeBaseType = UMe;
  Ua.getTypeAnnotation = jMe;
  Ua.isBaseType = qMe;
  Ua.isGenericType = VMe;
  var jU = LU(), xMe = Pe(), {
    anyTypeAnnotation: UU,
    isAnyTypeAnnotation: Wy,
    isArrayTypeAnnotation: EMe,
    isBooleanTypeAnnotation: SMe,
    isEmptyTypeAnnotation: TMe,
    isFlowBaseAnnotation: CMe,
    isGenericTypeAnnotation: wMe,
    isIdentifier: qU,
    isMixedTypeAnnotation: AMe,
    isNumberTypeAnnotation: _Me,
    isStringTypeAnnotation: PMe,
    isTSArrayType: FMe,
    isTSTypeAnnotation: IMe,
    isTSTypeReference: OMe,
    isTupleTypeAnnotation: kMe,
    isTypeAnnotation: BMe,
    isUnionTypeAnnotation: NMe,
    isVoidTypeAnnotation: MMe,
    stringTypeAnnotation: RMe,
    voidTypeAnnotation: LMe
  } = xMe;
  function jMe() {
    let e = this.getData("typeAnnotation");
    return e != null || (e = $U.call(this) || UU(), (BMe(e) || IMe(e)) && (e = e.typeAnnotation), this.setData("typeAnnotation", e)), e;
  }
  n(jMe, "getTypeAnnotation");
  var hw = /* @__PURE__ */ new WeakSet();
  function $U() {
    let e = this.node;
    if (!e)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        let r = this.parentPath.parentPath, i = r.parentPath;
        return r.key === "left" && i.isForInStatement() ? RMe() : r.key === "left" && i.isForOfStatement() ? UU() : LMe();
      } else
        return;
    if (e.typeAnnotation)
      return e.typeAnnotation;
    if (!hw.has(e)) {
      hw.add(e);
      try {
        var t;
        let r = jU[e.type];
        if (r)
          return r.call(this, e);
        if (r = jU[this.parentPath.type], (t = r) != null && t.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        hw.delete(e);
      }
    }
  }
  n($U, "_getTypeAnnotation");
  function qMe(e, t) {
    return mw(e, this.getTypeAnnotation(), t);
  }
  n(qMe, "isBaseType");
  function mw(e, t, r) {
    if (e === "string")
      return PMe(t);
    if (e === "number")
      return _Me(t);
    if (e === "boolean")
      return SMe(t);
    if (e === "any")
      return Wy(t);
    if (e === "mixed")
      return AMe(t);
    if (e === "empty")
      return TMe(t);
    if (e === "void")
      return MMe(t);
    if (r)
      return !1;
    throw new Error(`Unknown base type ${e}`);
  }
  n(mw, "_isBaseType");
  function UMe(e) {
    let t = this.getTypeAnnotation();
    if (Wy(t)) return !0;
    if (NMe(t)) {
      for (let r of t.types)
        if (Wy(r) || mw(e, r, !0))
          return !0;
      return !1;
    } else
      return mw(e, t, !0);
  }
  n(UMe, "couldBeBaseType");
  function $Me(e) {
    let t = this.getTypeAnnotation(), r = e.getTypeAnnotation();
    return !Wy(t) && CMe(t) ? r.type === t.type : !1;
  }
  n($Me, "baseTypeStrictlyMatches");
  function VMe(e) {
    let t = this.getTypeAnnotation();
    return e === "Array" && (FMe(t) || EMe(t) || kMe(t)) ? !0 : wMe(t) && qU(t.id, {
      name: e
    }) || OMe(t) && qU(t.typeName, {
      name: e
    });
  }
  n(VMe, "isGenericType");
});

// ../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var WU = E((Hy) => {
  "use strict";
  Object.defineProperty(Hy, "__esModule", {
    value: !0
  });
  Hy.hooks = void 0;
  var Vgt = Hy.hooks = [function(e, t) {
    if (e.key === "test" && (t.isWhile() || t.isSwitchCase()) || e.key === "declaration" && t.isExportDeclaration() || e.key === "body" && t.
    isLabeledStatement() || e.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e.key === "expr\
ession" && t.isExpressionStatement())
      return t.remove(), !0;
  }, function(e, t) {
    if (t.isSequenceExpression() && t.node.expressions.length === 1)
      return t.replaceWith(t.node.expressions[0]), !0;
  }, function(e, t) {
    if (t.isBinary())
      return e.key === "left" ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
  }, function(e, t) {
    if (t.isIfStatement() && e.key === "consequent" || e.key === "body" && (t.isLoop() || t.isArrowFunctionExpression()))
      return e.replaceWith({
        type: "BlockStatement",
        directives: [],
        body: []
      }), !0;
  }];
});

// ../node_modules/@babel/traverse/lib/path/removal.js
var Ky = E(($a) => {
  "use strict";
  Object.defineProperty($a, "__esModule", {
    value: !0
  });
  $a._assertUnremoved = XU;
  $a._callRemovalHooks = zU;
  $a._markRemoved = yw;
  $a._remove = JU;
  $a._removeFromScope = KU;
  $a.remove = YMe;
  var WMe = WU(), HMe = Yo(), KMe = gw(), HU = $n(), zMe = Pe(), JMe = zy(), XMe = zi();
  function YMe() {
    var e;
    if (XU.call(this), XMe.resync.call(this), zU.call(this)) {
      yw.call(this);
      return;
    }
    (e = this.opts) != null && e.noScope || KU.call(this), this.shareCommentsWithSiblings(), JU.call(this), yw.call(this);
  }
  n(YMe, "remove");
  function KU() {
    let e = zMe.getBindingIdentifiers(this.node, !1, !1, !0);
    Object.keys(e).forEach((t) => this.scope.removeBinding(t));
  }
  n(KU, "_removeFromScope");
  function zU() {
    if (this.parentPath) {
      for (let e of WMe.hooks)
        if (e(this, this.parentPath)) return !0;
    }
  }
  n(zU, "_callRemovalHooks");
  function JU() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), JMe.updateSiblingKeys.call(this, this.key, -1)) : KMe._replaceWith.
    call(this, null);
  }
  n(JU, "_remove");
  function yw() {
    if (this._traverseFlags |= HU.SHOULD_SKIP | HU.REMOVED, this.parent) {
      var e;
      (e = (0, HMe.getCachedPaths)(this)) == null || e.delete(this.node);
    }
    this.node = null;
  }
  n(yw, "_markRemoved");
  function XU() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  n(XU, "_assertUnremoved");
});

// ../node_modules/@babel/traverse/lib/path/lib/hoister.js
var GU = E((Jy) => {
  "use strict";
  Object.defineProperty(Jy, "__esModule", {
    value: !0
  });
  Jy.default = void 0;
  var YU = Pe(), GMe = YU, {
    react: ZMe
  } = YU, {
    cloneNode: QMe,
    jsxExpressionContainer: eRe,
    variableDeclaration: tRe,
    variableDeclarator: rRe
  } = GMe, iRe = {
    ReferencedIdentifier(e, t) {
      if (e.isJSXIdentifier() && ZMe.isCompatTag(e.node.name) && !e.parentPath.isJSXMemberExpression())
        return;
      if (e.node.name === "this") {
        let i = e.scope;
        do
          if (i.path.isFunction() && !i.path.isArrowFunctionExpression())
            break;
        while (i = i.parent);
        i && t.breakOnScopePaths.push(i.path);
      }
      let r = e.scope.getBinding(e.node.name);
      if (r) {
        for (let i of r.constantViolations)
          if (i.scope !== r.path.scope) {
            t.mutableBinding = !0, e.stop();
            return;
          }
        r === t.scope.getBinding(e.node.name) && (t.bindings[e.node.name] = r);
      }
    }
  }, bw = class {
    static {
      n(this, "PathHoister");
    }
    constructor(t, r) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.
      path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [],
      this.scope = r, this.path = t, this.attachAfter = !1;
    }
    isCompatibleScope(t) {
      for (let r of Object.keys(this.bindings)) {
        let i = this.bindings[r];
        if (!t.bindingIdentifierEquals(r, i.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let t = this.path.scope;
      do {
        if (this.isCompatibleScope(t))
          this.scopes.push(t);
        else
          break;
        if (this.breakOnScopePaths.includes(t.path))
          break;
      } while (t = t.parent);
    }
    getAttachmentPath() {
      let t = this._getAttachmentPath();
      if (!t) return;
      let r = t.scope;
      if (r.path === t && (r = t.scope.parent), r.path.isProgram() || r.path.isFunction())
        for (let i of Object.keys(this.bindings)) {
          if (!r.hasOwnBinding(i)) continue;
          let s = this.bindings[i];
          if (s.kind === "param" || s.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(s.path).key >= t.key) {
            this.attachAfter = !0, t = s.path;
            for (let o of s.constantViolations)
              this.getAttachmentParentForPath(o).key > t.key && (t = o);
          }
        }
      return t;
    }
    _getAttachmentPath() {
      let r = this.scopes.pop();
      if (r) {
        if (r.path.isFunction())
          if (this.hasOwnParamBindings(r)) {
            if (this.scope === r) return;
            let i = r.path.get("body").get("body");
            for (let s = 0; s < i.length; s++)
              if (!i[s].node._blockHoist)
                return i[s];
          } else
            return this.getNextScopeAttachmentParent();
        else if (r.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      let t = this.scopes.pop();
      if (t) return this.getAttachmentParentForPath(t.path);
    }
    getAttachmentParentForPath(t) {
      do
        if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
          return t;
      while (t = t.parentPath);
      return t;
    }
    hasOwnParamBindings(t) {
      for (let r of Object.keys(this.bindings)) {
        if (!t.hasOwnBinding(r)) continue;
        let i = this.bindings[r];
        if (i.kind === "param" && i.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(iRe, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      let t = this.getAttachmentPath();
      if (!t || t.getFunctionParent() === this.path.getFunctionParent()) return;
      let r = t.scope.generateUidIdentifier("ref"), i = rRe(r, this.path.node), s = this.attachAfter ? "insertAfter" : "insertBefore", [a] = t[s](
      [t.isVariableDeclarator() ? i : tRe("var", [i])]), o = this.path.parentPath;
      return o.isJSXElement() && this.path.container === o.node.children && (r = eRe(r)), this.path.replaceWith(QMe(r)), a.isVariableDeclarator() ?
      a.get("init") : a.get("declarations.0.init");
    }
  };
  Jy.default = bw;
});

// ../node_modules/@babel/traverse/lib/path/modification.js
var zy = E((Gi) => {
  "use strict";
  Object.defineProperty(Gi, "__esModule", {
    value: !0
  });
  Gi._containerInsert = Sw;
  Gi._containerInsertAfter = e$;
  Gi._containerInsertBefore = Tw;
  Gi._verifyNodeList = up;
  Gi.insertAfter = vRe;
  Gi.insertBefore = bRe;
  Gi.pushContainer = ERe;
  Gi.unshiftContainer = xRe;
  Gi.updateSiblingKeys = i$;
  var sRe = Yo(), Ew = $n(), Dw = zi(), Xy = Ky(), nRe = Pe(), aRe = GU(), {
    arrowFunctionExpression: oRe,
    assertExpression: uRe,
    assignmentExpression: lRe,
    blockStatement: ZU,
    callExpression: cRe,
    cloneNode: vw,
    expressionStatement: xw,
    isAssignmentExpression: fRe,
    isCallExpression: dRe,
    isExportNamedDeclaration: QU,
    isExpression: pRe,
    isIdentifier: hRe,
    isSequenceExpression: mRe,
    isSuper: yRe,
    thisExpression: gRe
  } = nRe;
  function bRe(e) {
    Xy._assertUnremoved.call(this);
    let t = up.call(this, e), {
      parentPath: r,
      parent: i
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || QU(i) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertBefore(t);
    if (this.isNodeType("Expression") && !this.isJSXElement() || r.isForStatement() && this.key === "init")
      return this.node && t.push(this.node), this.replaceExpressionWithStatements(t);
    if (Array.isArray(this.container))
      return Tw.call(this, t);
    if (this.isStatementOrBlock()) {
      let s = this.node, a = s && (!this.isExpressionStatement() || s.expression != null), [o] = this.replaceWith(ZU(a ? [s] : []));
      return o.unshiftContainer("body", t);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  n(bRe, "insertBefore");
  function Sw(e, t) {
    i$.call(this, e, t.length);
    let r = [];
    this.container.splice(e, 0, ...t);
    for (let a = 0; a < t.length; a++) {
      var i;
      let o = e + a, u = this.getSibling(o);
      r.push(u), (i = this.context) != null && i.queue && Dw.pushContext.call(u, this.context);
    }
    let s = Dw._getQueueContexts.call(this);
    for (let a of r) {
      Dw.setScope.call(a), a.debug("Inserted.");
      for (let o of s)
        o.maybeQueue(a, !0);
    }
    return r;
  }
  n(Sw, "_containerInsert");
  function Tw(e) {
    return Sw.call(this, this.key, e);
  }
  n(Tw, "_containerInsertBefore");
  function e$(e) {
    return Sw.call(this, this.key + 1, e);
  }
  n(e$, "_containerInsertAfter");
  var t$ = /* @__PURE__ */ n((e) => e[e.length - 1], "last");
  function r$(e) {
    return mRe(e.parent) && (t$(e.parent.expressions) !== e.node || r$(e.parentPath));
  }
  n(r$, "isHiddenInSequenceExpression");
  function DRe(e, t) {
    if (!fRe(e) || !hRe(e.left))
      return !1;
    let r = t.getBlockParent();
    return r.hasOwnBinding(e.left.name) && r.getOwnBinding(e.left.name).constantViolations.length <= 1;
  }
  n(DRe, "isAlmostConstantAssignment");
  function vRe(e) {
    if (Xy._assertUnremoved.call(this), this.isSequenceExpression())
      return t$(this.get("expressions")).insertAfter(e);
    let t = up.call(this, e), {
      parentPath: r,
      parent: i
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || QU(i) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertAfter(t.map((s) => pRe(s) ? xw(s) : s));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !r.isJSXElement() || r.isForStatement() && this.key === "init") {
      let s = this;
      if (s.node) {
        let a = s.node, {
          scope: o
        } = this;
        if (o.path.isPattern())
          return uRe(a), s.replaceWith(cRe(oRe([], a), [])), s.get("callee.body").insertAfter(t), [s];
        if (r$(s))
          t.unshift(a);
        else if (dRe(a) && yRe(a.callee))
          t.unshift(a), t.push(gRe());
        else if (DRe(a, o))
          t.unshift(a), t.push(vw(a.left));
        else if (o.isPure(a, !0))
          t.push(a);
        else {
          r.isMethod({
            computed: !0,
            key: a
          }) && (o = o.parent);
          let u = o.generateDeclaredUidIdentifier();
          t.unshift(xw(lRe("=", vw(u), a))), t.push(xw(vw(u)));
        }
      }
      return this.replaceExpressionWithStatements(t);
    } else {
      if (Array.isArray(this.container))
        return e$.call(this, t);
      if (this.isStatementOrBlock()) {
        let s = this.node, a = s && (!this.isExpressionStatement() || s.expression != null), [o] = this.replaceWith(ZU(a ? [s] : []));
        return o.pushContainer("body", t);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  n(vRe, "insertAfter");
  function i$(e, t) {
    if (!this.parent) return;
    let r = (0, sRe.getCachedPaths)(this);
    if (r)
      for (let [, i] of r)
        typeof i.key == "number" && i.container === this.container && i.key >= e && (i.key += t);
  }
  n(i$, "updateSiblingKeys");
  function up(e) {
    if (!e)
      return [];
    Array.isArray(e) || (e = [e]);
    for (let t = 0; t < e.length; t++) {
      let r = e[t], i;
      if (r ? typeof r != "object" ? i = "contains a non-object node" : r.type ? r instanceof Ew.default && (i = "has a NodePath when it exp\
ected a raw object") : i = "without a type" : i = "has falsy node", i) {
        let s = Array.isArray(r) ? "array" : typeof r;
        throw new Error(`Node list ${i} with the index of ${t} and type of ${s}`);
      }
    }
    return e;
  }
  n(up, "_verifyNodeList");
  function xRe(e, t) {
    Xy._assertUnremoved.call(this);
    let r = up.call(this, t), i = this.node[e], s = Ew.default.get({
      parentPath: this,
      parent: this.node,
      container: i,
      listKey: e,
      key: 0
    }).setContext(this.context);
    return Tw.call(s, r);
  }
  n(xRe, "unshiftContainer");
  function ERe(e, t) {
    Xy._assertUnremoved.call(this);
    let r = up.call(this, t), i = this.node[e];
    return Ew.default.get({
      parentPath: this,
      parent: this.node,
      container: i,
      listKey: e,
      key: i.length
    }).setContext(this.context).replaceWithMultiple(r);
  }
  n(ERe, "pushContainer");
  Gi.hoist = /* @__PURE__ */ n(function(t = this.scope) {
    return new aRe.default(this, t).run();
  }, "hoist");
});

// ../node_modules/@babel/traverse/lib/path/replacement.js
var gw = E((Va) => {
  "use strict";
  Object.defineProperty(Va, "__esModule", {
    value: !0
  });
  Va._replaceWith = f$;
  Va.replaceExpressionWithStatements = YRe;
  Va.replaceInline = GRe;
  Va.replaceWith = XRe;
  Va.replaceWithMultiple = zRe;
  Va.replaceWithSourceString = JRe;
  var SRe = Wd(), ww = ir(), TRe = $n(), u$ = Yo(), Aw = zy(), CRe = Ho(), wRe = Pe(), ec = zi(), {
    FUNCTION_TYPES: s$,
    arrowFunctionExpression: ARe,
    assignmentExpression: l$,
    awaitExpression: _Re,
    blockStatement: PRe,
    buildUndefinedNode: Cw,
    callExpression: FRe,
    cloneNode: _w,
    conditionalExpression: IRe,
    expressionStatement: ORe,
    getBindingIdentifiers: kRe,
    identifier: BRe,
    inheritLeadingComments: NRe,
    inheritTrailingComments: MRe,
    inheritsComments: RRe,
    isBlockStatement: LRe,
    isEmptyStatement: n$,
    isExpression: c$,
    isExpressionStatement: jRe,
    isIfStatement: qRe,
    isProgram: URe,
    isStatement: $Re,
    isVariableDeclaration: VRe,
    removeComments: WRe,
    returnStatement: a$,
    sequenceExpression: HRe,
    validate: o$,
    yieldExpression: KRe
  } = wRe;
  function zRe(e) {
    var t;
    ec.resync.call(this);
    let r = Aw._verifyNodeList.call(this, e);
    NRe(r[0], this.node), MRe(r[r.length - 1], this.node), (t = (0, u$.getCachedPaths)(this)) == null || t.delete(this.node), this.node = this.
    container[this.key] = null;
    let i = this.insertAfter(e);
    return this.node ? this.requeue() : this.remove(), i;
  }
  n(zRe, "replaceWithMultiple");
  function JRe(e) {
    ec.resync.call(this);
    let t;
    try {
      e = `(${e})`, t = (0, CRe.parse)(e);
    } catch (i) {
      let s = i.loc;
      throw s && (i.message += ` - make sure this is an expression.
` + (0, SRe.codeFrameColumns)(e, {
        start: {
          line: s.line,
          column: s.column + 1
        }
      }), i.code = "BABEL_REPLACE_SOURCE_ERROR"), i;
    }
    let r = t.program.body[0].expression;
    return ww.default.removeProperties(r), this.replaceWith(r);
  }
  n(JRe, "replaceWithSourceString");
  function XRe(e) {
    if (ec.resync.call(this), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let t = e instanceof TRe.default ? e.node : e;
    if (!t)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === t)
      return [this];
    if (this.isProgram() && !URe(t))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(t))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof t == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let r = "";
    if (this.isNodeType("Statement") && c$(t) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(
    t) && !this.parentPath.isExportDefaultDeclaration() && (t = ORe(t), r = "expression"), this.isNodeType("Expression") && $Re(t) && !this.
    canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t))
      return this.replaceExpressionWithStatements([t]);
    let i = this.node;
    return i && (RRe(t, i), WRe(i)), f$.call(this, t), this.type = t.type, ec.setScope.call(this), this.requeue(), [r ? this.get(r) : this];
  }
  n(XRe, "replaceWith");
  function f$(e) {
    var t;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? o$(this.parent, this.key, [e]) : o$(this.parent, this.key, e), this.debug(`Replace with ${e?.type}`), (t = (0, u$.getCachedPaths)(
    this)) == null || t.set(e, this).delete(this.node), this.node = e, this.container[this.key] = e;
  }
  n(f$, "_replaceWith");
  function YRe(e) {
    ec.resync.call(this);
    let t = [], r = Yy(e, t);
    if (r) {
      for (let h of t) this.scope.push({
        id: h
      });
      return this.replaceWith(r)[0].get("expressions");
    }
    let i = this.getFunctionParent(), s = i?.node.async, a = i?.node.generator, o = ARe([], PRe(e));
    this.replaceWith(FRe(o, []));
    let u = this.get("callee");
    u.get("body").scope.hoistVariables((h) => this.scope.push({
      id: h
    }));
    let l = u.getCompletionRecords();
    for (let h of l) {
      if (!h.isExpressionStatement()) continue;
      let d = h.findParent((y) => y.isLoop());
      if (d) {
        let y = d.getData("expressionReplacementReturnUid");
        y ? y = BRe(y.name) : (y = u.scope.generateDeclaredUidIdentifier("ret"), u.get("body").pushContainer("body", a$(_w(y))), d.setData("\
expressionReplacementReturnUid", y)), h.get("expression").replaceWith(l$("=", _w(y), h.node.expression));
      } else
        h.replaceWith(a$(h.node.expression));
    }
    u.arrowFunctionToExpression();
    let c = u, f = s && ww.default.hasType(this.get("callee.body").node, "AwaitExpression", s$), m = a && ww.default.hasType(this.get("calle\
e.body").node, "YieldExpression", s$);
    return f && (c.set("async", !0), m || this.replaceWith(_Re(this.node))), m && (c.set("generator", !0), this.replaceWith(KRe(this.node, !0))),
    c.get("body.body");
  }
  n(YRe, "replaceExpressionWithStatements");
  function Yy(e, t) {
    let r = [], i = !0;
    for (let s of e)
      if (n$(s) || (i = !1), c$(s))
        r.push(s);
      else if (jRe(s))
        r.push(s.expression);
      else if (VRe(s)) {
        if (s.kind !== "var") return;
        for (let a of s.declarations) {
          let o = kRe(a);
          for (let u of Object.keys(o))
            t.push(_w(o[u]));
          a.init && r.push(l$("=", a.id, a.init));
        }
        i = !0;
      } else if (qRe(s)) {
        let a = s.consequent ? Yy([s.consequent], t) : Cw(), o = s.alternate ? Yy([s.alternate], t) : Cw();
        if (!a || !o) return;
        r.push(IRe(s.test, a, o));
      } else if (LRe(s)) {
        let a = Yy(s.body, t);
        if (!a) return;
        r.push(a);
      } else if (n$(s))
        e.indexOf(s) === 0 && (i = !0);
      else
        return;
    return i && r.push(Cw()), r.length === 1 ? r[0] : HRe(r);
  }
  n(Yy, "gatherSequenceExpressions");
  function GRe(e) {
    if (ec.resync.call(this), Array.isArray(e))
      if (Array.isArray(this.container)) {
        e = Aw._verifyNodeList.call(this, e);
        let t = Aw._containerInsertAfter.call(this, e);
        return this.remove(), t;
      } else
        return this.replaceWithMultiple(e);
    else
      return this.replaceWith(e);
  }
  n(GRe, "replaceInline");
});

// ../node_modules/@babel/traverse/lib/path/evaluation.js
var m$ = E((Gy) => {
  "use strict";
  Object.defineProperty(Gy, "__esModule", {
    value: !0
  });
  Gy.evaluate = nLe;
  Gy.evaluateTruthy = iLe;
  var ZRe = ["Number", "String", "Math"], QRe = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeUR\
I", "encodeURIComponent", null, null], eLe = ["random"];
  function d$(e) {
    return ZRe.includes(e);
  }
  n(d$, "isValidObjectCallee");
  function tLe(e) {
    return QRe.includes(e);
  }
  n(tLe, "isValidIdentifierCallee");
  function rLe(e) {
    return eLe.includes(e);
  }
  n(rLe, "isInvalidMethod");
  function iLe() {
    let e = this.evaluate();
    if (e.confident) return !!e.value;
  }
  n(iLe, "evaluateTruthy");
  function Ds(e, t) {
    t.confident && (t.deoptPath = e, t.confident = !1);
  }
  n(Ds, "deopt");
  var p$ = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function ai(e, t) {
    let {
      node: r
    } = e, {
      seen: i
    } = t;
    if (i.has(r)) {
      let s = i.get(r);
      if (s.resolved)
        return s.value;
      Ds(e, t);
      return;
    } else {
      let s = {
        resolved: !1
      };
      i.set(r, s);
      let a = sLe(e, t);
      return t.confident && (s.resolved = !0, s.value = a), a;
    }
  }
  n(ai, "evaluateCached");
  function sLe(e, t) {
    if (t.confident) {
      if (e.isSequenceExpression()) {
        let i = e.get("expressions");
        return ai(i[i.length - 1], t);
      }
      if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral())
        return e.node.value;
      if (e.isNullLiteral())
        return null;
      if (e.isTemplateLiteral())
        return h$(e, e.node.quasis, t);
      if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
        let i = e.get("tag.object"), {
          node: {
            name: s
          }
        } = i, a = e.get("tag.property");
        if (i.isIdentifier() && s === "String" && !e.scope.getBinding(s) && a.isIdentifier() && a.node.name === "raw")
          return h$(e, e.node.quasi.quasis, t, !0);
      }
      if (e.isConditionalExpression()) {
        let i = ai(e.get("test"), t);
        return t.confident ? ai(i ? e.get("consequent") : e.get("alternate"), t) : void 0;
      }
      if (e.isExpressionWrapper())
        return ai(e.get("expression"), t);
      if (e.isMemberExpression() && !e.parentPath.isCallExpression({
        callee: e.node
      })) {
        let i = e.get("property"), s = e.get("object");
        if (s.isLiteral()) {
          let a = s.node.value, o = typeof a, u = null;
          if (e.node.computed) {
            if (u = ai(i, t), !t.confident) return;
          } else i.isIdentifier() && (u = i.node.name);
          if ((o === "number" || o === "string") && u != null && (typeof u == "number" || typeof u == "string"))
            return a[u];
        }
      }
      if (e.isReferencedIdentifier()) {
        let i = e.scope.getBinding(e.node.name);
        if (i) {
          if (i.constantViolations.length > 0 || e.node.start < i.path.node.end) {
            Ds(i.path, t);
            return;
          }
          let u = i.path.scope;
          if (i.kind === "var" && u !== i.scope) {
            let l = !u.path.parentPath.isBlockStatement();
            for (let c = u.parent; c; c = c.parent) {
              var r;
              if (c === e.scope) {
                if (l) {
                  Ds(i.path, t);
                  return;
                }
                break;
              }
              (r = c.path.parentPath) != null && r.isBlockStatement() && (l = !0);
            }
          }
          if (i.hasValue)
            return i.value;
        }
        let s = e.node.name;
        if (p$.has(s)) {
          if (!i)
            return p$.get(s);
          Ds(i.path, t);
          return;
        }
        let a = e.resolve();
        if (a === e) {
          Ds(e, t);
          return;
        }
        let o = ai(a, t);
        if (typeof o == "object" && o !== null && i.references > 1) {
          Ds(a, t);
          return;
        }
        return o;
      }
      if (e.isUnaryExpression({
        prefix: !0
      })) {
        if (e.node.operator === "void")
          return;
        let i = e.get("argument");
        if (e.node.operator === "typeof" && (i.isFunction() || i.isClass()))
          return "function";
        let s = ai(i, t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "!":
            return !s;
          case "+":
            return +s;
          case "-":
            return -s;
          case "~":
            return ~s;
          case "typeof":
            return typeof s;
        }
      }
      if (e.isArrayExpression()) {
        let i = [], s = e.get("elements");
        for (let a of s) {
          let o = a.evaluate();
          if (o.confident)
            i.push(o.value);
          else {
            Ds(o.deopt, t);
            return;
          }
        }
        return i;
      }
      if (e.isObjectExpression()) {
        let i = {}, s = e.get("properties");
        for (let a of s) {
          if (a.isObjectMethod() || a.isSpreadElement()) {
            Ds(a, t);
            return;
          }
          let o = a.get("key"), u;
          if (a.node.computed) {
            if (u = o.evaluate(), !u.confident) {
              Ds(u.deopt, t);
              return;
            }
            u = u.value;
          } else o.isIdentifier() ? u = o.node.name : u = o.node.value;
          let c = a.get("value").evaluate();
          if (!c.confident) {
            Ds(c.deopt, t);
            return;
          }
          c = c.value, i[u] = c;
        }
        return i;
      }
      if (e.isLogicalExpression()) {
        let i = t.confident, s = ai(e.get("left"), t), a = t.confident;
        t.confident = i;
        let o = ai(e.get("right"), t), u = t.confident;
        switch (e.node.operator) {
          case "||":
            return t.confident = a && (!!s || u), t.confident ? s || o : void 0;
          case "&&":
            return t.confident = a && (!s || u), t.confident ? s && o : void 0;
          case "??":
            return t.confident = a && (s != null || u), t.confident ? s ?? o : void 0;
        }
      }
      if (e.isBinaryExpression()) {
        let i = ai(e.get("left"), t);
        if (!t.confident) return;
        let s = ai(e.get("right"), t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "-":
            return i - s;
          case "+":
            return i + s;
          case "/":
            return i / s;
          case "*":
            return i * s;
          case "%":
            return i % s;
          case "**":
            return Math.pow(i, s);
          case "<":
            return i < s;
          case ">":
            return i > s;
          case "<=":
            return i <= s;
          case ">=":
            return i >= s;
          case "==":
            return i == s;
          case "!=":
            return i != s;
          case "===":
            return i === s;
          case "!==":
            return i !== s;
          case "|":
            return i | s;
          case "&":
            return i & s;
          case "^":
            return i ^ s;
          case "<<":
            return i << s;
          case ">>":
            return i >> s;
          case ">>>":
            return i >>> s;
        }
      }
      if (e.isCallExpression()) {
        let i = e.get("callee"), s, a;
        if (i.isIdentifier() && !e.scope.getBinding(i.node.name) && (d$(i.node.name) || tLe(i.node.name)) && (a = global[i.node.name]), i.isMemberExpression()) {
          let o = i.get("object"), u = i.get("property");
          if (o.isIdentifier() && u.isIdentifier() && d$(o.node.name) && !rLe(u.node.name)) {
            s = global[o.node.name];
            let l = u.node.name;
            hasOwnProperty.call(s, l) && (a = s[l]);
          }
          if (o.isLiteral() && u.isIdentifier()) {
            let l = typeof o.node.value;
            (l === "string" || l === "number") && (s = o.node.value, a = s[u.node.name]);
          }
        }
        if (a) {
          let o = e.get("arguments").map((u) => ai(u, t));
          return t.confident ? a.apply(s, o) : void 0;
        }
      }
      Ds(e, t);
    }
  }
  n(sLe, "_evaluate");
  function h$(e, t, r, i = !1) {
    let s = "", a = 0, o = e.isTemplateLiteral() ? e.get("expressions") : e.get("quasi.expressions");
    for (let u of t) {
      if (!r.confident) break;
      s += i ? u.value.raw : u.value.cooked;
      let l = o[a++];
      l && (s += String(ai(l, r)));
    }
    if (r.confident)
      return s;
  }
  n(h$, "evaluateQuasis");
  function nLe() {
    let e = {
      confident: !0,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    }, t = ai(this, e);
    return e.confident || (t = void 0), {
      confident: e.confident,
      deopt: e.deoptPath,
      value: t
    };
  }
  n(nLe, "evaluate");
});

// ../node_modules/@babel/traverse/lib/path/conversion.js
var S$ = E((Vn) => {
  "use strict";
  Object.defineProperty(Vn, "__esModule", {
    value: !0
  });
  Vn.arrowFunctionToExpression = NLe;
  Vn.ensureBlock = OLe;
  Vn.ensureFunctionName = zLe;
  Vn.splitExportDeclaration = HLe;
  Vn.toComputedKey = ILe;
  Vn.unwrapFunctionEnvironment = kLe;
  var aLe = Pe(), oLe = zd(), Iw = Xd(), uLe = zi(), {
    arrowFunctionExpression: Ow,
    assignmentExpression: su,
    binaryExpression: Pw,
    blockStatement: lLe,
    callExpression: tc,
    conditionalExpression: cLe,
    expressionStatement: b$,
    identifier: gt,
    isIdentifier: fLe,
    jsxIdentifier: dLe,
    logicalExpression: pLe,
    LOGICAL_OPERATORS: hLe,
    memberExpression: vs,
    metaProperty: mLe,
    numericLiteral: yLe,
    objectExpression: gLe,
    restElement: bLe,
    returnStatement: DLe,
    sequenceExpression: vLe,
    spreadElement: xLe,
    stringLiteral: D$,
    super: Fw,
    thisExpression: lp,
    toExpression: v$,
    unaryExpression: ELe,
    toBindingIdentifierName: SLe,
    isFunction: TLe,
    isAssignmentPattern: CLe,
    isRestElement: wLe,
    getFunctionName: ALe,
    cloneNode: nu,
    variableDeclaration: _Le,
    variableDeclarator: PLe,
    exportNamedDeclaration: y$,
    exportSpecifier: g$,
    inherits: FLe
  } = aLe;
  function ILe() {
    let e;
    if (this.isMemberExpression())
      e = this.node.property;
    else if (this.isProperty() || this.isMethod())
      e = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || fLe(e) && (e = D$(e.name)), e;
  }
  n(ILe, "toComputedKey");
  function OLe() {
    let e = this.get("body"), t = e.node;
    if (Array.isArray(e))
      throw new Error("Can't convert array path to a block statement");
    if (!t)
      throw new Error("Can't convert node without a body");
    if (e.isBlockStatement())
      return t;
    let r = [], i = "body", s, a;
    e.isStatement() ? (a = "body", s = 0, r.push(e.node)) : (i += ".body.0", this.isFunction() ? (s = "argument", r.push(DLe(e.node))) : (s =
    "expression", r.push(b$(e.node)))), this.node.body = lLe(r);
    let o = this.get(i);
    return uLe.setup.call(e, o, a ? o.node[a] : o.node, a, s), this.node;
  }
  n(OLe, "ensureBlock");
  Vn.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  function kLe() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    x$(this);
  }
  n(kLe, "unwrapFunctionEnvironment");
  function BLe(e, t) {
    e.node.type = t;
  }
  n(BLe, "setType");
  function NLe({
    allowInsertArrow: e = !0,
    allowInsertArrowWithRest: t = e,
    noNewArrows: r = !((i) => (i = arguments[0]) == null ? void 0 : i.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    let i = this;
    if (!r) {
      var s;
      i = (s = i.ensureFunctionName(!1)) != null ? s : i;
    }
    let {
      thisBinding: a,
      fnPath: o
    } = x$(i, r, e, t);
    if (o.ensureBlock(), BLe(o, "FunctionExpression"), !r) {
      let u = a ? null : o.scope.generateUidIdentifier("arrowCheckId");
      return u && o.parentPath.scope.push({
        id: u,
        init: gLe([])
      }), o.get("body").unshiftContainer("body", b$(tc(this.hub.addHelper("newArrowCheck"), [lp(), gt(u ? u.name : a)]))), o.replaceWith(tc(
      vs(o.node, gt("bind")), [u ? gt(u.name) : lp()])), o.get("callee.object");
    }
    return o;
  }
  n(NLe, "arrowFunctionToExpression");
  var MLe = (0, Iw.environmentVisitor)({
    CallExpression(e, {
      allSuperCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    }
  });
  function x$(e, t = !0, r = !0, i = !0) {
    let s, a = e.findParent((d) => d.isArrowFunctionExpression() ? (s ?? (s = d), !1) : d.isFunction() || d.isProgram() || d.isClassProperty(
    {
      static: !1
    }) || d.isClassPrivateProperty({
      static: !1
    })), o = a.isClassMethod({
      kind: "constructor"
    });
    if (a.isClassProperty() || a.isClassPrivateProperty())
      if (s)
        a = s;
      else if (r)
        e.replaceWith(tc(Ow([], v$(e.node)), [])), a = e.get("callee"), e = a.get("body");
      else
        throw e.buildCodeFrameError("Unable to transform arrow inside class property");
    let {
      thisPaths: u,
      argumentsPaths: l,
      newTargetPaths: c,
      superProps: f,
      superCalls: m
    } = WLe(e);
    if (o && m.length > 0) {
      if (!r)
        throw m[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an a\
rrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!i)
        throw m[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow \
function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration\
.");
      let d = [];
      a.traverse(MLe, {
        allSuperCalls: d
      });
      let y = ULe(a);
      d.forEach((p) => {
        let g = gt(y);
        g.loc = p.node.callee.loc, p.get("callee").replaceWith(g);
      });
    }
    if (l.length > 0) {
      let d = cp(a, "arguments", () => {
        let y = /* @__PURE__ */ n(() => gt("arguments"), "args");
        return a.scope.path.isProgram() ? cLe(Pw("===", ELe("typeof", y()), D$("undefined")), a.scope.buildUndefinedNode(), y()) : y();
      });
      l.forEach((y) => {
        let p = gt(d);
        p.loc = y.node.loc, y.replaceWith(p);
      });
    }
    if (c.length > 0) {
      let d = cp(a, "newtarget", () => mLe(gt("new"), gt("target")));
      c.forEach((y) => {
        let p = gt(d);
        p.loc = y.node.loc, y.replaceWith(p);
      });
    }
    if (f.length > 0) {
      if (!r)
        throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in a\
n arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      f.reduce((y, p) => y.concat(LLe(p)), []).forEach((y) => {
        let p = y.node.computed ? "" : y.get("property").node.name, g = y.parentPath, b = g.isAssignmentExpression({
          left: y.node
        }), D = g.isCallExpression({
          callee: y.node
        }), x = g.isTaggedTemplateExpression({
          tag: y.node
        }), T = $Le(a, b, p), w = [];
        if (y.node.computed && w.push(y.get("property").node), b) {
          let k = g.node.right;
          w.push(k);
        }
        let B = tc(gt(T), w);
        D ? (g.unshiftContainer("arguments", lp()), y.replaceWith(vs(B, gt("call"))), u.push(g.get("arguments.0"))) : b ? g.replaceWith(B) :
        x ? (y.replaceWith(tc(vs(B, gt("bind"), !1), [lp()])), u.push(y.get("arguments.0"))) : y.replaceWith(B);
      });
    }
    let h;
    return (u.length > 0 || !t) && (h = qLe(a, o), (t || o && E$(a)) && (u.forEach((d) => {
      let y = d.isJSX() ? dLe(h) : gt(h);
      y.loc = d.node.loc, d.replaceWith(y);
    }), t || (h = null))), {
      thisBinding: h,
      fnPath: e
    };
  }
  n(x$, "hoistFunctionEnvironment");
  function RLe(e) {
    return hLe.includes(e);
  }
  n(RLe, "isLogicalOp");
  function LLe(e) {
    if (e.parentPath.isAssignmentExpression() && e.parentPath.node.operator !== "=") {
      let r = e.parentPath, i = r.node.operator.slice(0, -1), s = r.node.right, a = RLe(i);
      if (e.node.computed) {
        let o = e.scope.generateDeclaredUidIdentifier("tmp"), {
          object: u,
          property: l
        } = e.node;
        r.get("left").replaceWith(vs(u, su("=", o, l), !0)), r.get("right").replaceWith(t(a ? "=" : i, vs(u, gt(o.name), !0), s));
      } else {
        let o = e.node.object, u = e.node.property;
        r.get("left").replaceWith(vs(o, u)), r.get("right").replaceWith(t(a ? "=" : i, vs(o, gt(u.name)), s));
      }
      return a ? r.replaceWith(pLe(i, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
    } else if (e.parentPath.isUpdateExpression()) {
      let r = e.parentPath, i = e.scope.generateDeclaredUidIdentifier("tmp"), s = e.node.computed ? e.scope.generateDeclaredUidIdentifier("p\
rop") : null, a = [su("=", i, vs(e.node.object, s ? su("=", s, e.node.property) : e.node.property, e.node.computed)), su("=", vs(e.node.object,
      s ? gt(s.name) : e.node.property, e.node.computed), Pw(e.parentPath.node.operator[0], gt(i.name), yLe(1)))];
      e.parentPath.node.prefix || a.push(gt(i.name)), r.replaceWith(vLe(a));
      let o = r.get("expressions.0.right"), u = r.get("expressions.1.left");
      return [o, u];
    }
    return [e];
    function t(r, i, s) {
      return r === "=" ? su("=", i, s) : Pw(r, i, s);
    }
  }
  n(LLe, "standardizeSuperProperty");
  function E$(e) {
    return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
  }
  n(E$, "hasSuperClass");
  var jLe = (0, Iw.environmentVisitor)({
    CallExpression(e, {
      supers: t,
      thisBinding: r
    }) {
      e.get("callee").isSuper() && (t.has(e.node) || (t.add(e.node), e.replaceWithMultiple([e.node, su("=", gt(r), gt("this"))])));
    }
  });
  function qLe(e, t) {
    return cp(e, "this", (r) => {
      if (!t || !E$(e)) return lp();
      e.traverse(jLe, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: r
      });
    });
  }
  n(qLe, "getThisBinding");
  function ULe(e) {
    return cp(e, "supercall", () => {
      let t = e.scope.generateUidIdentifier("args");
      return Ow([bLe(t)], tc(Fw(), [xLe(gt(t.name))]));
    });
  }
  n(ULe, "getSuperBinding");
  function $Le(e, t, r) {
    return cp(e, `superprop_${t ? "set" : "get"}:${r || ""}`, () => {
      let s = [], a;
      if (r)
        a = vs(Fw(), gt(r));
      else {
        let o = e.scope.generateUidIdentifier("prop");
        s.unshift(o), a = vs(Fw(), gt(o.name), !0);
      }
      if (t) {
        let o = e.scope.generateUidIdentifier("value");
        s.push(o), a = su("=", a, gt(o.name));
      }
      return Ow(s, a);
    });
  }
  n($Le, "getSuperPropBinding");
  function cp(e, t, r) {
    let i = "binding:" + t, s = e.getData(i);
    if (!s) {
      let a = e.scope.generateUidIdentifier(t);
      s = a.name, e.setData(i, s), e.scope.push({
        id: a,
        init: r(s)
      });
    }
    return s;
  }
  n(cp, "getBinding");
  var VLe = (0, Iw.environmentVisitor)({
    ThisExpression(e, {
      thisPaths: t
    }) {
      t.push(e);
    },
    JSXIdentifier(e, {
      thisPaths: t
    }) {
      e.node.name === "this" && (!e.parentPath.isJSXMemberExpression({
        object: e.node
      }) && !e.parentPath.isJSXOpeningElement({
        name: e.node
      }) || t.push(e));
    },
    CallExpression(e, {
      superCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    },
    MemberExpression(e, {
      superProps: t
    }) {
      e.get("object").isSuper() && t.push(e);
    },
    Identifier(e, {
      argumentsPaths: t
    }) {
      if (!e.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let r = e.scope;
      do {
        if (r.hasOwnBinding("arguments")) {
          r.rename("arguments");
          return;
        }
        if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
      } while (r = r.parent);
      t.push(e);
    },
    MetaProperty(e, {
      newTargetPaths: t
    }) {
      e.get("meta").isIdentifier({
        name: "new"
      }) && e.get("property").isIdentifier({
        name: "target"
      }) && t.push(e);
    }
  });
  function WLe(e) {
    let t = [], r = [], i = [], s = [], a = [];
    return e.traverse(VLe, {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: i,
      superProps: s,
      superCalls: a
    }), {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: i,
      superProps: s,
      superCalls: a
    };
  }
  n(WLe, "getScopeInformation");
  function HLe() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let e = this.get("declaration");
    if (this.isExportDefaultDeclaration()) {
      let s = e.isFunctionDeclaration() || e.isClassDeclaration(), a = e.isFunctionExpression() || e.isClassExpression(), o = e.isScope() ? e.
      scope.parent : e.scope, u = e.node.id, l = !1;
      u ? a && o.hasBinding(u.name) && (l = !0, u = o.generateUidIdentifier(u.name)) : (l = !0, u = o.generateUidIdentifier("default"), (s ||
      a) && (e.node.id = nu(u)));
      let c = s ? e.node : _Le("var", [PLe(nu(u), e.node)]), f = y$(null, [g$(nu(u), gt("default"))]);
      return this.insertAfter(f), this.replaceWith(c), l && o.registerDeclaration(this), this;
    } else if (this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let t = e.getOuterBindingIdentifiers(), r = Object.keys(t).map((s) => g$(gt(s), gt(s))), i = y$(null, r);
    return this.insertAfter(i), this.replaceWith(e.node), this;
  }
  n(HLe, "splitExportDeclaration");
  var KLe = {
    "ReferencedIdentifier|BindingIdentifier"(e, t) {
      e.node.name === t.name && (t.needsRename = !0, e.stop());
    },
    Scope(e, t) {
      e.scope.hasOwnBinding(t.name) && e.skip();
    }
  };
  function zLe(e) {
    if (this.node.id) return this;
    let t = ALe(this.node, this.parent);
    if (t == null) return this;
    let {
      name: r
    } = t;
    if (!e && /[\uD800-\uDFFF]/.test(r) || r.startsWith("get ") || r.startsWith("set "))
      return null;
    r = SLe(r.replace(/[/ ]/g, "_"));
    let i = gt(r);
    FLe(i, t.originalNode);
    let s = {
      needsRename: !1,
      name: r
    }, {
      scope: a
    } = this, o = a.getOwnBinding(r);
    if (o ? o.kind === "param" && (s.needsRename = !0) : (a.parent.hasBinding(r) || a.hasGlobal(r)) && this.traverse(KLe, s), !s.needsRename)
      return this.node.id = i, a.getProgramParent().references[i.name] = !0, this;
    if (a.hasBinding(i.name) && !a.hasGlobal(i.name))
      return a.rename(i.name), this.node.id = i, a.getProgramParent().references[i.name] = !0, this;
    if (!TLe(this.node)) return null;
    let u = a.generateUidIdentifier(i.name), l = [];
    for (let f = 0, m = JLe(this.node); f < m; f++)
      l.push(a.generateUidIdentifier("x"));
    let c = oLe.default.expression.ast`
    (function (${u}) {
      function ${i}(${l}) {
        return ${nu(u)}.apply(this, arguments);
      }

      ${nu(i)}.toString = function () {
        return ${nu(u)}.toString();
      }

      return ${nu(i)};
    })(${v$(this.node)})
  `;
    return this.replaceWith(c)[0].get("arguments.0");
  }
  n(zLe, "ensureFunctionName");
  function JLe(e) {
    let t = e.params.findIndex((r) => CLe(r) || wLe(r));
    return t === -1 ? e.params.length : t;
  }
  n(JLe, "getFunctionArity");
});

// ../node_modules/@babel/traverse/lib/path/introspection.js
var P$ = E((Xt) => {
  "use strict";
  Object.defineProperty(Xt, "__esModule", {
    value: !0
  });
  Xt._guessExecutionStatusRelativeTo = mje;
  Xt._resolve = _$;
  Xt.canHaveVariableDeclarationOrExpression = oje;
  Xt.canSwapBetweenExpressionAndStatement = uje;
  Xt.getSource = dje;
  Xt.isCompletionRecord = lje;
  Xt.isConstantExpression = Dje;
  Xt.isInStrictMode = vje;
  Xt.isNodeType = aje;
  Xt.isStatementOrBlock = cje;
  Xt.isStatic = nje;
  Xt.matchesPattern = sje;
  Xt.referencesImport = fje;
  Xt.resolve = bje;
  Xt.willIMaybeExecuteBefore = pje;
  var XLe = Pe(), {
    STATEMENT_OR_BLOCK_KEYS: YLe,
    VISITOR_KEYS: GLe,
    isBlockStatement: A$,
    isExpression: ZLe,
    isIdentifier: QLe,
    isLiteral: eje,
    isStringLiteral: tje,
    isType: rje,
    matchesPattern: ije
  } = XLe;
  function sje(e, t) {
    return ije(this.node, e, t);
  }
  n(sje, "matchesPattern");
  Xt.has = /* @__PURE__ */ n(function(t) {
    var r;
    let i = (r = this.node) == null ? void 0 : r[t];
    return i && Array.isArray(i) ? !!i.length : !!i;
  }, "has");
  function nje() {
    return this.scope.isStatic(this.node);
  }
  n(nje, "isStatic");
  Xt.is = Xt.has, Xt.isnt = /* @__PURE__ */ n(function(t) {
    return !this.has(t);
  }, "isnt"), Xt.equals = /* @__PURE__ */ n(function(t, r) {
    return this.node[t] === r;
  }, "equals");
  function aje(e) {
    return rje(this.type, e);
  }
  n(aje, "isNodeType");
  function oje() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  n(oje, "canHaveVariableDeclarationOrExpression");
  function uje(e) {
    return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? A$(e) : this.isBlockStatement() ?
    ZLe(e) : !1;
  }
  n(uje, "canSwapBetweenExpressionAndStatement");
  function lje(e) {
    let t = this, r = !0;
    do {
      let {
        type: i,
        container: s
      } = t;
      if (!r && (t.isFunction() || i === "StaticBlock"))
        return !!e;
      if (r = !1, Array.isArray(s) && t.key !== s.length - 1)
        return !1;
    } while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
    return !0;
  }
  n(lje, "isCompletionRecord");
  function cje() {
    return this.parentPath.isLabeledStatement() || A$(this.container) ? !1 : YLe.includes(this.key);
  }
  n(cje, "isStatementOrBlock");
  function fje(e, t) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) &&
      (this.node.computed ? tje(this.node.property, {
        value: t
      }) : this.node.property.name === t)) {
        let a = this.get("object");
        return a.isReferencedIdentifier() && a.referencesImport(e, "*");
      }
      return !1;
    }
    let r = this.scope.getBinding(this.node.name);
    if (!r || r.kind !== "module") return !1;
    let i = r.path, s = i.parentPath;
    if (!s.isImportDeclaration()) return !1;
    if (s.node.source.value === e) {
      if (!t) return !0;
    } else
      return !1;
    return !!(i.isImportDefaultSpecifier() && t === "default" || i.isImportNamespaceSpecifier() && t === "*" || i.isImportSpecifier() && QLe(
    i.node.imported, {
      name: t
    }));
  }
  n(fje, "referencesImport");
  function dje() {
    let e = this.node;
    if (e.end) {
      let t = this.hub.getCode();
      if (t) return t.slice(e.start, e.end);
    }
    return "";
  }
  n(dje, "getSource");
  function pje(e) {
    return this._guessExecutionStatusRelativeTo(e) !== "after";
  }
  n(pje, "willIMaybeExecuteBefore");
  function T$(e) {
    return e.isProgram() ? e : (e.parentPath.scope.getFunctionParent() || e.parentPath.scope.getProgramParent()).path;
  }
  n(T$, "getOuterFunction");
  function hje(e, t) {
    switch (e) {
      case "LogicalExpression":
        return t === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return t === "consequent" || t === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return t === "body";
      case "ForStatement":
        return t === "body" || t === "update";
      case "SwitchStatement":
        return t === "cases";
      case "TryStatement":
        return t === "handler";
      case "AssignmentPattern":
        return t === "right";
      case "OptionalMemberExpression":
        return t === "property";
      case "OptionalCallExpression":
        return t === "arguments";
      default:
        return !1;
    }
  }
  n(hje, "isExecutionUncertain");
  function C$(e, t) {
    for (let r = 0; r < t; r++) {
      let i = e[r];
      if (hje(i.parent.type, i.parentKey))
        return !0;
    }
    return !1;
  }
  n(C$, "isExecutionUncertainInList");
  var w$ = Symbol();
  function mje(e) {
    return kw(this, e, /* @__PURE__ */ new Map());
  }
  n(mje, "_guessExecutionStatusRelativeTo");
  function kw(e, t, r) {
    let i = {
      this: T$(e),
      target: T$(t)
    };
    if (i.target.node !== i.this.node)
      return gje(e, i.target, r);
    let s = {
      target: t.getAncestry(),
      this: e.getAncestry()
    };
    if (s.target.includes(e)) return "after";
    if (s.this.includes(t)) return "before";
    let a, o = {
      target: 0,
      this: 0
    };
    for (; !a && o.this < s.this.length; ) {
      let f = s.this[o.this];
      o.target = s.target.indexOf(f), o.target >= 0 ? a = f : o.this++;
    }
    if (!a)
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (C$(s.this, o.this - 1) || C$(s.target, o.target - 1))
      return "unknown";
    let u = {
      this: s.this[o.this - 1],
      target: s.target[o.target - 1]
    };
    if (u.target.listKey && u.this.listKey && u.target.container === u.this.container)
      return u.target.key > u.this.key ? "before" : "after";
    let l = GLe[a.type], c = {
      this: l.indexOf(u.this.parentKey),
      target: l.indexOf(u.target.parentKey)
    };
    return c.target > c.this ? "before" : "after";
  }
  n(kw, "_guessExecutionStatusRelativeToCached");
  function yje(e, t, r) {
    if (t.isFunctionDeclaration()) {
      if (t.parentPath.isExportDeclaration())
        return "unknown";
    } else return kw(e, t, r) === "before" ? "before" : "unknown";
    let i = t.scope.getBinding(t.node.id.name);
    if (!i.references) return "before";
    let s = i.referencePaths, a;
    for (let o of s) {
      if (!!o.find((c) => c.node === t.node)) continue;
      if (o.key !== "callee" || !o.parentPath.isCallExpression())
        return "unknown";
      let l = kw(e, o, r);
      if (a && a !== l)
        return "unknown";
      a = l;
    }
    return a;
  }
  n(yje, "_guessExecutionStatusRelativeToDifferentFunctionsInternal");
  function gje(e, t, r) {
    let i = r.get(e.node), s;
    if (!i)
      r.set(e.node, i = /* @__PURE__ */ new Map());
    else if (s = i.get(t.node))
      return s === w$ ? "unknown" : s;
    i.set(t.node, w$);
    let a = yje(e, t, r);
    return i.set(t.node, a), a;
  }
  n(gje, "_guessExecutionStatusRelativeToDifferentFunctionsCached");
  function bje(e, t) {
    return _$.call(this, e, t) || this;
  }
  n(bje, "resolve");
  function _$(e, t) {
    var r;
    if (!((r = t) != null && r.includes(this)))
      if (t = t || [], t.push(this), this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier())
          return this.get("init").resolve(e, t);
      } else if (this.isReferencedIdentifier()) {
        let i = this.scope.getBinding(this.node.name);
        if (!i || !i.constant || i.kind === "module") return;
        if (i.path !== this) {
          let s = i.path.resolve(e, t);
          return this.find((a) => a.node === s.node) ? void 0 : s;
        }
      } else {
        if (this.isTypeCastExpression())
          return this.get("expression").resolve(e, t);
        if (e && this.isMemberExpression()) {
          let i = this.toComputedKey();
          if (!eje(i)) return;
          let s = i.value, a = this.get("object").resolve(e, t);
          if (a.isObjectExpression()) {
            let o = a.get("properties");
            for (let u of o) {
              if (!u.isProperty()) continue;
              let l = u.get("key"), c = u.isnt("computed") && l.isIdentifier({
                name: s
              });
              if (c = c || l.isLiteral({
                value: s
              }), c) return u.get("value").resolve(e, t);
            }
          } else if (a.isArrayExpression() && !isNaN(+s)) {
            let u = a.get("elements")[s];
            if (u) return u.resolve(e, t);
          }
        }
      }
  }
  n(_$, "_resolve");
  function Dje() {
    if (this.isIdentifier()) {
      let e = this.scope.getBinding(this.node.name);
      return e ? e.constant : !1;
    }
    if (this.isLiteral())
      return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((e) => e.isConstantExpression()) : !0;
    if (this.isUnaryExpression())
      return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      let {
        operator: e
      } = this.node;
      return e !== "in" && e !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
      name: "Symbol"
    }) && !this.scope.hasBinding("Symbol", {
      noGlobals: !0
    }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding(
    "Symbol", {
      noGlobals: !0
    }) && this.get("arguments")[0].isStringLiteral() : !1;
  }
  n(Dje, "isConstantExpression");
  function vje() {
    return !!(this.isProgram() ? this : this.parentPath).find((r) => {
      if (r.isProgram({
        sourceType: "module"
      }) || r.isClass()) return !0;
      if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement())
        return !1;
      let i;
      if (r.isFunction())
        i = r.node.body;
      else if (r.isProgram())
        i = r.node;
      else
        return !1;
      for (let s of i.directives)
        if (s.value.value === "use strict")
          return !0;
      return !1;
    });
  }
  n(vje, "isInStrictMode");
});

// ../node_modules/@babel/traverse/lib/path/family.js
var B$ = E((kr) => {
  "use strict";
  Object.defineProperty(kr, "__esModule", {
    value: !0
  });
  kr._getKey = O$;
  kr._getPattern = k$;
  kr.get = Rje;
  kr.getAllNextSiblings = Nje;
  kr.getAllPrevSiblings = Mje;
  kr.getAssignmentIdentifiers = Lje;
  kr.getBindingIdentifierPaths = Uje;
  kr.getBindingIdentifiers = jje;
  kr.getCompletionRecords = Ije;
  kr.getNextSibling = Bje;
  kr.getOpposite = _je;
  kr.getOuterBindingIdentifierPaths = $je;
  kr.getOuterBindingIdentifiers = qje;
  kr.getPrevSibling = kje;
  kr.getSibling = Oje;
  var Nw = $n(), xje = Pe(), {
    getAssignmentIdentifiers: Eje,
    getBindingIdentifiers: I$,
    getOuterBindingIdentifiers: Sje,
    numericLiteral: Tje,
    unaryExpression: Cje
  } = xje, Mw = 0, fp = 1;
  function wje(e) {
    return {
      type: Mw,
      path: e
    };
  }
  n(wje, "NormalCompletion");
  function Aje(e) {
    return {
      type: fp,
      path: e
    };
  }
  n(Aje, "BreakCompletion");
  function _je() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  n(_je, "getOpposite");
  function rc(e, t, r) {
    return e && t.push(...ic(e, r)), t;
  }
  n(rc, "addCompletionRecords");
  function Pje(e, t, r) {
    let i = [];
    for (let s = 0; s < e.length; s++) {
      let a = e[s], o = ic(a, r), u = [], l = [];
      for (let c of o)
        c.type === Mw && u.push(c), c.type === fp && l.push(c);
      u.length && (i = u), t.push(...l);
    }
    return t.push(...i), t;
  }
  n(Pje, "completionRecordForSwitch");
  function Fje(e) {
    e.forEach((t) => {
      t.type = fp;
    });
  }
  n(Fje, "normalCompletionToBreak");
  function Bw(e, t) {
    e.forEach((r) => {
      r.path.isBreakStatement({
        label: null
      }) && (t ? r.path.replaceWith(Cje("void", Tje(0))) : r.path.remove());
    });
  }
  n(Bw, "replaceBreakStatementInBreakCompletion");
  function F$(e, t) {
    let r = [];
    if (t.canHaveBreak) {
      let i = [];
      for (let s = 0; s < e.length; s++) {
        let a = e[s], o = Object.assign({}, t, {
          inCaseClause: !1
        });
        a.isBlockStatement() && (t.inCaseClause || t.shouldPopulateBreak) ? o.shouldPopulateBreak = !0 : o.shouldPopulateBreak = !1;
        let u = ic(a, o);
        if (u.length > 0 && u.every((l) => l.type === fp)) {
          i.length > 0 && u.every((l) => l.path.isBreakStatement({
            label: null
          })) ? (Fje(i), r.push(...i), i.some((l) => l.path.isDeclaration()) && (r.push(...u), t.shouldPreserveBreak || Bw(u, !0)), t.shouldPreserveBreak ||
          Bw(u, !1)) : (r.push(...u), !t.shouldPopulateBreak && !t.shouldPreserveBreak && Bw(u, !0));
          break;
        }
        if (s === e.length - 1)
          r.push(...u);
        else {
          i = [];
          for (let l = 0; l < u.length; l++) {
            let c = u[l];
            c.type === fp && r.push(c), c.type === Mw && i.push(c);
          }
        }
      }
    } else if (e.length)
      for (let i = e.length - 1; i >= 0; i--) {
        let s = ic(e[i], t);
        if (s.length > 1 || s.length === 1 && !s[0].path.isVariableDeclaration() && !s[0].path.isEmptyStatement()) {
          r.push(...s);
          break;
        }
      }
    return r;
  }
  n(F$, "getStatementListCompletion");
  function ic(e, t) {
    let r = [];
    if (e.isIfStatement())
      r = rc(e.get("consequent"), r, t), r = rc(e.get("alternate"), r, t);
    else {
      if (e.isDoExpression() || e.isFor() || e.isWhile() || e.isLabeledStatement())
        return rc(e.get("body"), r, t);
      if (e.isProgram() || e.isBlockStatement())
        return F$(e.get("body"), t);
      if (e.isFunction())
        return ic(e.get("body"), t);
      if (e.isTryStatement())
        r = rc(e.get("block"), r, t), r = rc(e.get("handler"), r, t);
      else {
        if (e.isCatchClause())
          return rc(e.get("body"), r, t);
        if (e.isSwitchStatement())
          return Pje(e.get("cases"), r, t);
        if (e.isSwitchCase())
          return F$(e.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0,
            shouldPreserveBreak: t.shouldPreserveBreak
          });
        e.isBreakStatement() ? r.push(Aje(e)) : r.push(wje(e));
      }
    }
    return r;
  }
  n(ic, "_getCompletionRecords");
  function Ije(e = !1) {
    return ic(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1,
      shouldPreserveBreak: e
    }).map((r) => r.path);
  }
  n(Ije, "getCompletionRecords");
  function Oje(e) {
    return Nw.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: e
    }).setContext(this.context);
  }
  n(Oje, "getSibling");
  function kje() {
    return this.getSibling(this.key - 1);
  }
  n(kje, "getPrevSibling");
  function Bje() {
    return this.getSibling(this.key + 1);
  }
  n(Bje, "getNextSibling");
  function Nje() {
    let e = this.key, t = this.getSibling(++e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(++e);
    return r;
  }
  n(Nje, "getAllNextSiblings");
  function Mje() {
    let e = this.key, t = this.getSibling(--e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(--e);
    return r;
  }
  n(Mje, "getAllPrevSiblings");
  function Rje(e, t = !0) {
    t === !0 && (t = this.context);
    let r = e.split(".");
    return r.length === 1 ? O$.call(this, e, t) : k$.call(this, r, t);
  }
  n(Rje, "get");
  function O$(e, t) {
    let r = this.node, i = r[e];
    return Array.isArray(i) ? i.map((s, a) => Nw.default.get({
      listKey: e,
      parentPath: this,
      parent: r,
      container: i,
      key: a
    }).setContext(t)) : Nw.default.get({
      parentPath: this,
      parent: r,
      container: r,
      key: e
    }).setContext(t);
  }
  n(O$, "_getKey");
  function k$(e, t) {
    let r = this;
    for (let i of e)
      i === "." ? r = r.parentPath : Array.isArray(r) ? r = r[i] : r = r.get(i, t);
    return r;
  }
  n(k$, "_getPattern");
  function Lje() {
    return Eje(this.node);
  }
  n(Lje, "getAssignmentIdentifiers");
  function jje(e) {
    return I$(this.node, e);
  }
  n(jje, "getBindingIdentifiers");
  function qje(e) {
    return Sje(this.node, e);
  }
  n(qje, "getOuterBindingIdentifiers");
  function Uje(e = !1, t = !1) {
    let i = [this], s = /* @__PURE__ */ Object.create(null);
    for (; i.length; ) {
      let a = i.shift();
      if (!a || !a.node) continue;
      let o = I$.keys[a.node.type];
      if (a.isIdentifier()) {
        e ? (s[a.node.name] = s[a.node.name] || []).push(a) : s[a.node.name] = a;
        continue;
      }
      if (a.isExportDeclaration()) {
        let u = a.get("declaration");
        u.isDeclaration() && i.push(u);
        continue;
      }
      if (t) {
        if (a.isFunctionDeclaration()) {
          i.push(a.get("id"));
          continue;
        }
        if (a.isFunctionExpression())
          continue;
      }
      if (o)
        for (let u = 0; u < o.length; u++) {
          let l = o[u], c = a.get(l);
          Array.isArray(c) ? i.push(...c) : c.node && i.push(c);
        }
    }
    return s;
  }
  n(Uje, "getBindingIdentifierPaths");
  function $je(e = !1) {
    return this.getBindingIdentifierPaths(e, !0);
  }
  n($je, "getOuterBindingIdentifierPaths");
});

// ../node_modules/@babel/traverse/lib/path/comments.js
var M$ = E((dp) => {
  "use strict";
  Object.defineProperty(dp, "__esModule", {
    value: !0
  });
  dp.addComment = zje;
  dp.addComments = Jje;
  dp.shareCommentsWithSiblings = Kje;
  var Vje = Pe(), {
    addComment: Wje,
    addComments: Hje
  } = Vje;
  function Kje() {
    if (typeof this.key == "string") return;
    let e = this.node;
    if (!e) return;
    let t = e.trailingComments, r = e.leadingComments;
    if (!t && !r) return;
    let i = this.getSibling(this.key - 1), s = this.getSibling(this.key + 1), a = !!i.node, o = !!s.node;
    a && (r && i.addComments("trailing", N$(r, i.node.trailingComments)), t && !o && i.addComments("trailing", t)), o && (t && s.addComments(
    "leading", N$(t, s.node.leadingComments)), r && !a && s.addComments("leading", r));
  }
  n(Kje, "shareCommentsWithSiblings");
  function N$(e, t) {
    if (!(t != null && t.length)) return e;
    let r = new Set(t);
    return e.filter((i) => !r.has(i));
  }
  n(N$, "removeIfExisting");
  function zje(e, t, r) {
    Wje(this.node, e, t, r);
  }
  n(zje, "addComment");
  function Jje(e, t) {
    Hje(this.node, e, t);
  }
  n(Jje, "addComments");
});

// ../node_modules/@babel/traverse/lib/path/index.js
var $n = E((an) => {
  "use strict";
  Object.defineProperty(an, "__esModule", {
    value: !0
  });
  an.default = an.SHOULD_STOP = an.SHOULD_SKIP = an.REMOVED = void 0;
  var Xje = oC(), Yje = zo(), Gje = ir(), Zje = vC(), j$ = Pe(), Zy = j$, Qje = Yo(), eqe = op(), sn = SU(), sc = VU(), nc = gw(), R$ = m$(),
  au = S$(), sr = P$(), q$ = zi(), Yt = q$, ac = Ky(), nn = zy(), oi = B$(), Rw = M$(), tqe = dC(), {
    validate: rqe
  } = j$, L$ = Yje("babel"), lbt = an.REMOVED = 1, cbt = an.SHOULD_STOP = 2, fbt = an.SHOULD_SKIP = 4, Wn = an.default = class U$ {
    static {
      n(this, "NodePath");
    }
    constructor(t, r) {
      this.contexts = [], this.state = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.
      listKey = null, this.key = null, this.node = null, this.type = null, this._store = null, this.parent = r, this.hub = t, this.data = null,
      this.context = null, this.scope = null;
    }
    get removed() {
      return (this._traverseFlags & 1) > 0;
    }
    set removed(t) {
      t ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
    }
    get shouldStop() {
      return (this._traverseFlags & 2) > 0;
    }
    set shouldStop(t) {
      t ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
    }
    get shouldSkip() {
      return (this._traverseFlags & 4) > 0;
    }
    set shouldSkip(t) {
      t ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
    }
    static get({
      hub: t,
      parentPath: r,
      parent: i,
      container: s,
      listKey: a,
      key: o
    }) {
      if (!t && r && (t = r.hub), !i)
        throw new Error("To get a node path the parent needs to exist");
      let u = s[o], l = Qje.getOrCreateCachedPaths(i, r), c = l.get(u);
      return c || (c = new U$(t, i), u && l.set(u, c)), q$.setup.call(c, r, s, a, o), c;
    }
    getScope(t) {
      return this.isScope() ? new Zje.default(this) : t;
    }
    setData(t, r) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[t] = r;
    }
    getData(t, r) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let i = this.data[t];
      return i === void 0 && r !== void 0 && (i = this.data[t] = r), i;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(t, r = SyntaxError) {
      return this.hub.buildError(this.node, t, r);
    }
    traverse(t, r) {
      (0, Gje.default)(this.node, t, this.scope, r, this);
    }
    set(t, r) {
      rqe(this.node, t, r), this.node[t] = r;
    }
    getPathLocation() {
      let t = [], r = this;
      do {
        let i = r.key;
        r.inList && (i = `${r.listKey}[${i}]`), t.unshift(i);
      } while (r = r.parentPath);
      return t.join(".");
    }
    debug(t) {
      L$.enabled && L$(`${this.getPathLocation()} ${this.type}: ${t}`);
    }
    toString() {
      return (0, eqe.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(t) {
      t || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
  }, iqe = {
    findParent: sn.findParent,
    find: sn.find,
    getFunctionParent: sn.getFunctionParent,
    getStatementParent: sn.getStatementParent,
    getEarliestCommonAncestorFrom: sn.getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: sn.getDeepestCommonAncestorFrom,
    getAncestry: sn.getAncestry,
    isAncestor: sn.isAncestor,
    isDescendant: sn.isDescendant,
    inType: sn.inType,
    getTypeAnnotation: sc.getTypeAnnotation,
    isBaseType: sc.isBaseType,
    couldBeBaseType: sc.couldBeBaseType,
    baseTypeStrictlyMatches: sc.baseTypeStrictlyMatches,
    isGenericType: sc.isGenericType,
    replaceWithMultiple: nc.replaceWithMultiple,
    replaceWithSourceString: nc.replaceWithSourceString,
    replaceWith: nc.replaceWith,
    replaceExpressionWithStatements: nc.replaceExpressionWithStatements,
    replaceInline: nc.replaceInline,
    evaluateTruthy: R$.evaluateTruthy,
    evaluate: R$.evaluate,
    toComputedKey: au.toComputedKey,
    ensureBlock: au.ensureBlock,
    unwrapFunctionEnvironment: au.unwrapFunctionEnvironment,
    arrowFunctionToExpression: au.arrowFunctionToExpression,
    splitExportDeclaration: au.splitExportDeclaration,
    ensureFunctionName: au.ensureFunctionName,
    matchesPattern: sr.matchesPattern,
    isStatic: sr.isStatic,
    isNodeType: sr.isNodeType,
    canHaveVariableDeclarationOrExpression: sr.canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: sr.canSwapBetweenExpressionAndStatement,
    isCompletionRecord: sr.isCompletionRecord,
    isStatementOrBlock: sr.isStatementOrBlock,
    referencesImport: sr.referencesImport,
    getSource: sr.getSource,
    willIMaybeExecuteBefore: sr.willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: sr._guessExecutionStatusRelativeTo,
    resolve: sr.resolve,
    isConstantExpression: sr.isConstantExpression,
    isInStrictMode: sr.isInStrictMode,
    isDenylisted: Yt.isDenylisted,
    visit: Yt.visit,
    skip: Yt.skip,
    skipKey: Yt.skipKey,
    stop: Yt.stop,
    setContext: Yt.setContext,
    requeue: Yt.requeue,
    requeueComputedKeyAndDecorators: Yt.requeueComputedKeyAndDecorators,
    remove: ac.remove,
    insertBefore: nn.insertBefore,
    insertAfter: nn.insertAfter,
    unshiftContainer: nn.unshiftContainer,
    pushContainer: nn.pushContainer,
    getOpposite: oi.getOpposite,
    getCompletionRecords: oi.getCompletionRecords,
    getSibling: oi.getSibling,
    getPrevSibling: oi.getPrevSibling,
    getNextSibling: oi.getNextSibling,
    getAllNextSiblings: oi.getAllNextSiblings,
    getAllPrevSiblings: oi.getAllPrevSiblings,
    get: oi.get,
    getAssignmentIdentifiers: oi.getAssignmentIdentifiers,
    getBindingIdentifiers: oi.getBindingIdentifiers,
    getOuterBindingIdentifiers: oi.getOuterBindingIdentifiers,
    getBindingIdentifierPaths: oi.getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: oi.getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings: Rw.shareCommentsWithSiblings,
    addComment: Rw.addComment,
    addComments: Rw.addComments
  };
  Object.assign(Wn.prototype, iqe);
  Wn.prototype.arrowFunctionToShadowed = au.arrowFunctionToShadowed, Object.assign(Wn.prototype, {
    has: sr.has,
    is: sr.is,
    isnt: sr.isnt,
    equals: sr.equals,
    hoist: nn.hoist,
    updateSiblingKeys: nn.updateSiblingKeys,
    call: Yt.call,
    isBlacklisted: Yt.isBlacklisted,
    setScope: Yt.setScope,
    resync: Yt.resync,
    popContext: Yt.popContext,
    pushContext: Yt.pushContext,
    setup: Yt.setup,
    setKey: Yt.setKey
  });
  Wn.prototype._guessExecutionStatusRelativeToDifferentFunctions = sr._guessExecutionStatusRelativeTo, Wn.prototype._guessExecutionStatusRelativeToDifferentFunctions =
  sr._guessExecutionStatusRelativeTo, Object.assign(Wn.prototype, {
    _getTypeAnnotation: sc._getTypeAnnotation,
    _replaceWith: nc._replaceWith,
    _resolve: sr._resolve,
    _call: Yt._call,
    _resyncParent: Yt._resyncParent,
    _resyncKey: Yt._resyncKey,
    _resyncList: Yt._resyncList,
    _resyncRemoved: Yt._resyncRemoved,
    _getQueueContexts: Yt._getQueueContexts,
    _removeFromScope: ac._removeFromScope,
    _callRemovalHooks: ac._callRemovalHooks,
    _remove: ac._remove,
    _markRemoved: ac._markRemoved,
    _assertUnremoved: ac._assertUnremoved,
    _containerInsert: nn._containerInsert,
    _containerInsertBefore: nn._containerInsertBefore,
    _containerInsertAfter: nn._containerInsertAfter,
    _verifyNodeList: nn._verifyNodeList,
    _getKey: oi._getKey,
    _getPattern: oi._getPattern
  });
  for (let e of Zy.TYPES) {
    let t = `is${e}`, r = Zy[t];
    Wn.prototype[t] = function(i) {
      return r(this.node, i);
    }, Wn.prototype[`assert${e}`] = function(i) {
      if (!r(this.node, i))
        throw new TypeError(`Expected node path of type ${e}`);
    };
  }
  Object.assign(Wn.prototype, tqe);
  for (let e of Object.keys(Xje))
    e[0] !== "_" && (Zy.TYPES.includes(e) || Zy.TYPES.push(e));
});

// ../node_modules/@babel/traverse/lib/context.js
var $$ = E((Qy) => {
  "use strict";
  Object.defineProperty(Qy, "__esModule", {
    value: !0
  });
  Qy.default = void 0;
  var sqe = $n(), nqe = Pe(), Lw = zi(), {
    VISITOR_KEYS: aqe
  } = nqe, jw = class {
    static {
      n(this, "TraversalContext");
    }
    constructor(t, r, i, s) {
      this.queue = null, this.priorityQueue = null, this.parentPath = s, this.scope = t, this.state = i, this.opts = r;
    }
    shouldVisit(t) {
      let r = this.opts;
      if (r.enter || r.exit || r[t.type]) return !0;
      let i = aqe[t.type];
      if (!(i != null && i.length)) return !1;
      for (let s of i)
        if (t[s])
          return !0;
      return !1;
    }
    create(t, r, i, s) {
      return sqe.default.get({
        parentPath: this.parentPath,
        parent: t,
        container: r,
        key: i,
        listKey: s
      });
    }
    maybeQueue(t, r) {
      this.queue && (r ? this.queue.push(t) : this.priorityQueue.push(t));
    }
    visitMultiple(t, r, i) {
      if (t.length === 0) return !1;
      let s = [];
      for (let a = 0; a < t.length; a++) {
        let o = t[a];
        o && this.shouldVisit(o) && s.push(this.create(r, t, a, i));
      }
      return this.visitQueue(s);
    }
    visitSingle(t, r) {
      return this.shouldVisit(t[r]) ? this.visitQueue([this.create(t, t, r)]) : !1;
    }
    visitQueue(t) {
      this.queue = t, this.priorityQueue = [];
      let r = /* @__PURE__ */ new WeakSet(), i = !1, s = 0;
      for (; s < t.length; ) {
        let a = t[s];
        if (s++, Lw.resync.call(a), (a.contexts.length === 0 || a.contexts[a.contexts.length - 1] !== this) && Lw.pushContext.call(a, this),
        a.key === null) continue;
        let {
          node: o
        } = a;
        if (!r.has(o)) {
          if (o && r.add(o), a.visit()) {
            i = !0;
            break;
          }
          if (this.priorityQueue.length && (i = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = t, i))
            break;
        }
      }
      for (let a = 0; a < s; a++)
        Lw.popContext.call(t[a]);
      return this.queue = null, i;
    }
    visit(t, r) {
      let i = t[r];
      return i ? Array.isArray(i) ? this.visitMultiple(i, t, r) : this.visitSingle(t, r) : !1;
    }
  };
  Qy.default = jw;
});

// ../node_modules/@babel/traverse/lib/traverse-node.js
var yy = E((qw) => {
  "use strict";
  Object.defineProperty(qw, "__esModule", {
    value: !0
  });
  qw.traverseNode = cqe;
  var oqe = $$(), ybt = $n(), uqe = Pe(), gbt = zi(), {
    VISITOR_KEYS: lqe
  } = uqe;
  function cqe(e, t, r, i, s, a, o) {
    let u = lqe[e.type];
    if (!u) return !1;
    let l = new oqe.default(r, t, i, s);
    if (o)
      return a != null && a[s.parentKey] ? !1 : l.visitQueue([s]);
    for (let c of u)
      if (!(a != null && a[c]) && l.visit(e, c))
        return !0;
    return !1;
  }
  n(cqe, "traverseNode");
});

// ../node_modules/@babel/traverse/lib/path/context.js
var zi = E((qt) => {
  "use strict";
  Object.defineProperty(qt, "__esModule", {
    value: !0
  });
  qt._call = $w;
  qt._getQueueContexts = wqe;
  qt._resyncKey = J$;
  qt._resyncList = X$;
  qt._resyncParent = z$;
  qt._resyncRemoved = vqe;
  qt.call = Uw;
  qt.isDenylisted = H$;
  qt.popContext = xqe;
  qt.pushContext = Eqe;
  qt.requeue = Tqe;
  qt.requeueComputedKeyAndDecorators = Cqe;
  qt.resync = Dqe;
  qt.setContext = bqe;
  qt.setKey = e1;
  qt.setScope = K$;
  qt.setup = Sqe;
  qt.skip = mqe;
  qt.skipKey = yqe;
  qt.stop = gqe;
  qt.visit = hqe;
  var fqe = yy(), V$ = $n(), dqe = Ky(), pqe = Pe();
  function Uw(e) {
    let t = this.opts;
    if (this.debug(e), this.node && $w.call(this, t[e]))
      return !0;
    if (this.node) {
      var r;
      return $w.call(this, (r = t[this.node.type]) == null ? void 0 : r[e]);
    }
    return !1;
  }
  n(Uw, "call");
  function $w(e) {
    if (!e) return !1;
    for (let t of e) {
      if (!t) continue;
      let r = this.node;
      if (!r) return !0;
      let i = t.call(this.state, this, this.state);
      if (i && typeof i == "object" && typeof i.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not suppo\
rt. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (i)
        throw new Error(`Unexpected return value from visitor method ${t}`);
      if (this.node !== r || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  n($w, "_call");
  function H$() {
    var e;
    let t = (e = this.opts.denylist) != null ? e : this.opts.blacklist;
    return t?.includes(this.node.type);
  }
  n(H$, "isDenylisted");
  qt.isBlacklisted = H$;
  function W$(e, t) {
    e.context !== t && (e.context = t, e.state = t.state, e.opts = t.opts);
  }
  n(W$, "restoreContext");
  function hqe() {
    var e, t;
    if (!this.node || this.isDenylisted() || (e = (t = this.opts).shouldSkip) != null && e.call(t, this))
      return !1;
    let r = this.context;
    return this.shouldSkip || Uw.call(this, "enter") ? (this.debug("Skip..."), this.shouldStop) : (W$(this, r), this.debug("Recursing into..\
."), this.shouldStop = (0, fqe.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), W$(this, r), Uw.call(this, "\
exit"), this.shouldStop);
  }
  n(hqe, "visit");
  function mqe() {
    this.shouldSkip = !0;
  }
  n(mqe, "skip");
  function yqe(e) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[e] = !0;
  }
  n(yqe, "skipKey");
  function gqe() {
    this._traverseFlags |= V$.SHOULD_SKIP | V$.SHOULD_STOP;
  }
  n(gqe, "stop");
  function K$() {
    var e, t;
    if ((e = this.opts) != null && e.noScope) return;
    let r = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && r.isMethod() || this.key === "discriminant" && r.isSwitchStatement()) && (r = r.
    parentPath);
    let i;
    for (; r && !i; ) {
      var s;
      if ((s = r.opts) != null && s.noScope) return;
      i = r.scope, r = r.parentPath;
    }
    this.scope = this.getScope(i), (t = this.scope) == null || t.init();
  }
  n(K$, "setScope");
  function bqe(e) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, e && (this.context = e, this.state = e.state, this.opts =
    e.opts), K$.call(this), this;
  }
  n(bqe, "setContext");
  function Dqe() {
    this.removed || (z$.call(this), X$.call(this), J$.call(this));
  }
  n(Dqe, "resync");
  function z$() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  n(z$, "_resyncParent");
  function J$() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let e = 0; e < this.container.length; e++)
          if (this.container[e] === this.node) {
            e1.call(this, e);
            return;
          }
      } else
        for (let e of Object.keys(this.container))
          if (this.container[e] === this.node) {
            e1.call(this, e);
            return;
          }
      this.key = null;
    }
  }
  n(J$, "_resyncKey");
  function X$() {
    if (!this.parent || !this.inList) return;
    let e = this.parent[this.listKey];
    this.container !== e && (this.container = e || null);
  }
  n(X$, "_resyncList");
  function vqe() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && dqe._markRemoved.call(this);
  }
  n(vqe, "_resyncRemoved");
  function xqe() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  n(xqe, "popContext");
  function Eqe(e) {
    this.contexts.push(e), this.setContext(e);
  }
  n(Eqe, "pushContext");
  function Sqe(e, t, r, i) {
    this.listKey = r, this.container = t, this.parentPath = e || this.parentPath, e1.call(this, i);
  }
  n(Sqe, "setup");
  function e1(e) {
    var t;
    this.key = e, this.node = this.container[this.key], this.type = (t = this.node) == null ? void 0 : t.type;
  }
  n(e1, "setKey");
  function Tqe(e = this) {
    if (e.removed) return;
    let t = this.contexts;
    for (let r of t)
      r.maybeQueue(e);
  }
  n(Tqe, "requeue");
  function Cqe() {
    let {
      context: e,
      node: t
    } = this;
    if (!pqe.isPrivate(t) && t.computed && e.maybeQueue(this.get("key")), t.decorators)
      for (let r of this.get("decorators"))
        e.maybeQueue(r);
  }
  n(Cqe, "requeueComputedKeyAndDecorators");
  function wqe() {
    let e = this, t = this.contexts;
    for (; !t.length && (e = e.parentPath, !!e); )
      t = e.contexts;
    return t;
  }
  n(wqe, "_getQueueContexts");
});

// ../node_modules/@babel/traverse/lib/hub.js
var Y$ = E((t1) => {
  "use strict";
  Object.defineProperty(t1, "__esModule", {
    value: !0
  });
  t1.default = void 0;
  var Vw = class {
    static {
      n(this, "Hub");
    }
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(t, r, i = TypeError) {
      return new i(r);
    }
  };
  t1.default = Vw;
});

// ../node_modules/@babel/traverse/lib/index.js
var ir = E((Hn) => {
  "use strict";
  Object.defineProperty(Hn, "__esModule", {
    value: !0
  });
  Object.defineProperty(Hn, "Hub", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Iqe.default;
    }, "get")
  });
  Object.defineProperty(Hn, "NodePath", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Pqe.default;
    }, "get")
  });
  Object.defineProperty(Hn, "Scope", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Fqe.default;
    }, "get")
  });
  Hn.visitors = Hn.default = void 0;
  zi();
  var hp = Xd();
  Hn.visitors = hp;
  var Aqe = Pe(), _qe = Yo(), G$ = yy(), Pqe = $n(), Fqe = vC(), Iqe = Y$(), {
    VISITOR_KEYS: Oqe,
    removeProperties: kqe,
    traverseFast: pp
  } = Aqe;
  function xs(e, t = {}, r, i, s, a) {
    if (e) {
      if (!t.noScope && !r && e.type !== "Program" && e.type !== "File")
        throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e.
        type} node without passing scope and parentPath.`);
      if (!s && a)
        throw new Error("visitSelf can only be used when providing a NodePath.");
      Oqe[e.type] && (hp.explode(t), (0, G$.traverseNode)(e, t, r, i, s, void 0, a));
    }
  }
  n(xs, "traverse");
  var Tbt = Hn.default = xs;
  xs.visitors = hp;
  xs.verify = hp.verify;
  xs.explode = hp.explode;
  xs.cheap = function(e, t) {
    pp(e, t);
  };
  xs.node = function(e, t, r, i, s, a) {
    (0, G$.traverseNode)(e, t, r, i, s, a);
  };
  xs.clearNode = function(e, t) {
    kqe(e, t);
  };
  xs.removeProperties = function(e, t) {
    return pp(e, xs.clearNode, t), e;
  };
  xs.hasType = function(e, t, r) {
    return r != null && r.includes(e.type) ? !1 : e.type === t ? !0 : pp(e, function(i) {
      if (r != null && r.includes(i.type))
        return pp.skip;
      if (i.type === t)
        return pp.stop;
    });
  };
  xs.cache = _qe;
});

// ../node_modules/@babel/helper-module-imports/lib/import-builder.js
var eV = E((i1) => {
  "use strict";
  Object.defineProperty(i1, "__esModule", {
    value: !0
  });
  i1.default = void 0;
  var Es = require("assert"), Bqe = Pe(), {
    callExpression: Ww,
    cloneNode: r1,
    expressionStatement: Z$,
    identifier: mp,
    importDeclaration: Nqe,
    importDefaultSpecifier: Mqe,
    importNamespaceSpecifier: Rqe,
    importSpecifier: Lqe,
    memberExpression: Hw,
    stringLiteral: Q$,
    variableDeclaration: jqe,
    variableDeclarator: qqe
  } = Bqe, Kw = class {
    static {
      n(this, "ImportBuilder");
    }
    constructor(t, r, i) {
      this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = r, this._hub = i, this._importedSource = t;
    }
    done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    }
    import() {
      return this._statements.push(Nqe([], Q$(this._importedSource))), this;
    }
    require() {
      return this._statements.push(Z$(Ww(mp("require"), [Q$(this._importedSource)]))), this;
    }
    namespace(t = "namespace") {
      let r = this._scope.generateUidIdentifier(t), i = this._statements[this._statements.length - 1];
      return Es(i.type === "ImportDeclaration"), Es(i.specifiers.length === 0), i.specifiers = [Rqe(r)], this._resultName = r1(r), this;
    }
    default(t) {
      let r = this._scope.generateUidIdentifier(t), i = this._statements[this._statements.length - 1];
      return Es(i.type === "ImportDeclaration"), Es(i.specifiers.length === 0), i.specifiers = [Mqe(r)], this._resultName = r1(r), this;
    }
    named(t, r) {
      if (r === "default") return this.default(t);
      let i = this._scope.generateUidIdentifier(t), s = this._statements[this._statements.length - 1];
      return Es(s.type === "ImportDeclaration"), Es(s.specifiers.length === 0), s.specifiers = [Lqe(i, mp(r))], this._resultName = r1(i), this;
    }
    var(t) {
      let r = this._scope.generateUidIdentifier(t), i = this._statements[this._statements.length - 1];
      return i.type !== "ExpressionStatement" && (Es(this._resultName), i = Z$(this._resultName), this._statements.push(i)), this._statements[this.
      _statements.length - 1] = jqe("var", [qqe(r, i.expression)]), this._resultName = r1(r), this;
    }
    defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(t) {
      let r = this._statements[this._statements.length - 1];
      return r.type === "ExpressionStatement" ? r.expression = Ww(t, [r.expression]) : r.type === "VariableDeclaration" ? (Es(r.declarations.
      length === 1), r.declarations[0].init = Ww(t, [r.declarations[0].init])) : Es.fail("Unexpected type."), this;
    }
    prop(t) {
      let r = this._statements[this._statements.length - 1];
      return r.type === "ExpressionStatement" ? r.expression = Hw(r.expression, mp(t)) : r.type === "VariableDeclaration" ? (Es(r.declarations.
      length === 1), r.declarations[0].init = Hw(r.declarations[0].init, mp(t))) : Es.fail("Unexpected type:" + r.type), this;
    }
    read(t) {
      this._resultName = Hw(this._resultName, mp(t));
    }
  };
  i1.default = Kw;
});

// ../node_modules/@babel/helper-module-imports/lib/is-module.js
var Jw = E((zw) => {
  "use strict";
  Object.defineProperty(zw, "__esModule", {
    value: !0
  });
  zw.default = Uqe;
  function Uqe(e) {
    return e.node.sourceType === "module";
  }
  n(Uqe, "isModule");
});

// ../node_modules/@babel/helper-module-imports/lib/import-injector.js
var aV = E((n1) => {
  "use strict";
  Object.defineProperty(n1, "__esModule", {
    value: !0
  });
  n1.default = void 0;
  var tV = require("assert"), $qe = Pe(), Vqe = eV(), Wqe = Jw(), {
    identifier: Hqe,
    importSpecifier: Kqe,
    numericLiteral: zqe,
    sequenceExpression: Jqe,
    isImportDeclaration: rV
  } = $qe, Xw = class {
    static {
      n(this, "ImportInjector");
    }
    constructor(t, r, i) {
      this._defaultOpts = {
        importedSource: null,
        importedType: "commonjs",
        importedInterop: "babel",
        importingInterop: "babel",
        ensureLiveReference: !1,
        ensureNoContext: !1,
        importPosition: "before"
      };
      let s = t.find((a) => a.isProgram());
      this._programPath = s, this._programScope = s.scope, this._hub = s.hub, this._defaultOpts = this._applyDefaults(r, i, !0);
    }
    addDefault(t, r) {
      return this.addNamed("default", t, r);
    }
    addNamed(t, r, i) {
      return tV(typeof t == "string"), this._generateImport(this._applyDefaults(r, i), t);
    }
    addNamespace(t, r) {
      return this._generateImport(this._applyDefaults(t, r), null);
    }
    addSideEffect(t, r) {
      return this._generateImport(this._applyDefaults(t, r), void 0);
    }
    _applyDefaults(t, r, i = !1) {
      let s;
      return typeof t == "string" ? s = Object.assign({}, this._defaultOpts, {
        importedSource: t
      }, r) : (tV(!r, "Unexpected secondary arguments."), s = Object.assign({}, this._defaultOpts, t)), !i && r && (r.nameHint !== void 0 &&
      (s.nameHint = r.nameHint), r.blockHoist !== void 0 && (s.blockHoist = r.blockHoist)), s;
    }
    _generateImport(t, r) {
      let i = r === "default", s = !!r && !i, a = r === null, {
        importedSource: o,
        importedType: u,
        importedInterop: l,
        importingInterop: c,
        ensureLiveReference: f,
        ensureNoContext: m,
        nameHint: h,
        importPosition: d,
        blockHoist: y
      } = t, p = h || r, g = (0, Wqe.default)(this._programPath), b = g && c === "node", D = g && c === "babel";
      if (d === "after" && !g)
        throw new Error('"importPosition": "after" is only supported in modules');
      let x = new Vqe.default(o, this._programScope, this._hub);
      if (u === "es6") {
        if (!b && !D)
          throw new Error("Cannot import an ES6 module from CommonJS");
        x.import(), a ? x.namespace(h || o) : (i || s) && x.named(p, r);
      } else {
        if (u !== "commonjs")
          throw new Error(`Unexpected interopType "${u}"`);
        if (l === "babel")
          if (b) {
            p = p !== "default" ? p : o;
            let B = `${o}$es6Default`;
            x.import(), a ? x.default(B).var(p || o).wildcardInterop() : i ? f ? x.default(B).var(p || o).defaultInterop().read("default") :
            x.default(B).var(p).defaultInterop().prop(r) : s && x.default(B).read(r);
          } else D ? (x.import(), a ? x.namespace(p || o) : (i || s) && x.named(p, r)) : (x.require(), a ? x.var(p || o).wildcardInterop() :
          (i || s) && f ? i ? (p = p !== "default" ? p : o, x.var(p).read(r), x.defaultInterop()) : x.var(o).read(r) : i ? x.var(p).defaultInterop().
          prop(r) : s && x.var(p).prop(r));
        else if (l === "compiled")
          b ? (x.import(), a ? x.default(p || o) : (i || s) && x.default(o).read(p)) : D ? (x.import(), a ? x.namespace(p || o) : (i || s) &&
          x.named(p, r)) : (x.require(), a ? x.var(p || o) : (i || s) && (f ? x.var(o).read(p) : x.prop(r).var(p)));
        else if (l === "uncompiled") {
          if (i && f)
            throw new Error("No live reference for commonjs default");
          b ? (x.import(), a ? x.default(p || o) : i ? x.default(p) : s && x.default(o).read(p)) : D ? (x.import(), a ? x.default(p || o) : i ?
          x.default(p) : s && x.named(p, r)) : (x.require(), a ? x.var(p || o) : i ? x.var(p) : s && (f ? x.var(o).read(p) : x.var(p).prop(r)));
        } else
          throw new Error(`Unknown importedInterop "${l}".`);
      }
      let {
        statements: T,
        resultName: w
      } = x.done();
      return this._insertStatements(T, d, y), (i || s) && m && w.type !== "Identifier" ? Jqe([zqe(0), w]) : w;
    }
    _insertStatements(t, r = "before", i = 3) {
      if (r === "after") {
        if (this._insertStatementsAfter(t)) return;
      } else if (this._insertStatementsBefore(t, i)) return;
      this._programPath.unshiftContainer("body", t);
    }
    _insertStatementsBefore(t, r) {
      if (t.length === 1 && rV(t[0]) && s1(t[0])) {
        let s = this._programPath.get("body").find((a) => a.isImportDeclaration() && s1(a.node));
        if (s?.node.source.value === t[0].source.value && nV(s.node, t[0]))
          return !0;
      }
      t.forEach((s) => {
        s._blockHoist = r;
      });
      let i = this._programPath.get("body").find((s) => {
        let a = s.node._blockHoist;
        return Number.isFinite(a) && a < 4;
      });
      return i ? (i.insertBefore(t), !0) : !1;
    }
    _insertStatementsAfter(t) {
      let r = new Set(t), i = /* @__PURE__ */ new Map();
      for (let a of t)
        if (rV(a) && s1(a)) {
          let o = a.source.value;
          i.has(o) || i.set(o, []), i.get(o).push(a);
        }
      let s = null;
      for (let a of this._programPath.get("body"))
        if (a.isImportDeclaration() && s1(a.node)) {
          s = a;
          let o = a.node.source.value, u = i.get(o);
          if (!u) continue;
          for (let l of u)
            r.has(l) && nV(a.node, l) && r.delete(l);
        }
      return r.size === 0 ? !0 : (s && s.insertAfter(Array.from(r)), !!s);
    }
  };
  n1.default = Xw;
  function s1(e) {
    return e.importKind !== "type" && e.importKind !== "typeof";
  }
  n(s1, "isValueImport");
  function iV(e) {
    return e.specifiers.length === 1 && e.specifiers[0].type === "ImportNamespaceSpecifier" || e.specifiers.length === 2 && e.specifiers[1].
    type === "ImportNamespaceSpecifier";
  }
  n(iV, "hasNamespaceImport");
  function sV(e) {
    return e.specifiers.length > 0 && e.specifiers[0].type === "ImportDefaultSpecifier";
  }
  n(sV, "hasDefaultImport");
  function nV(e, t) {
    return e.specifiers.length ? t.specifiers.length ? iV(e) || iV(t) ? !1 : (sV(t) && (sV(e) ? t.specifiers[0] = Kqe(t.specifiers[0].local,
    Hqe("default")) : e.specifiers.unshift(t.specifiers.shift())), e.specifiers.push(...t.specifiers), !0) : !0 : (e.specifiers = t.specifiers,
    !0);
  }
  n(nV, "maybeAppendImportSpecifiers");
});

// ../node_modules/@babel/helper-module-imports/lib/index.js
var oV = E((Wa) => {
  "use strict";
  Object.defineProperty(Wa, "__esModule", {
    value: !0
  });
  Object.defineProperty(Wa, "ImportInjector", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return yp.default;
    }, "get")
  });
  Wa.addDefault = Yqe;
  Wa.addNamed = Gqe;
  Wa.addNamespace = Zqe;
  Wa.addSideEffect = Qqe;
  Object.defineProperty(Wa, "isModule", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Xqe.default;
    }, "get")
  });
  var yp = aV(), Xqe = Jw();
  function Yqe(e, t, r) {
    return new yp.default(e).addDefault(t, r);
  }
  n(Yqe, "addDefault");
  function Gqe(e, t, r, i) {
    return new yp.default(e).addNamed(t, r, i);
  }
  n(Gqe, "addNamed");
  function Zqe(e, t, r) {
    return new yp.default(e).addNamespace(t, r);
  }
  n(Zqe, "addNamespace");
  function Qqe(e, t, r) {
    return new yp.default(e).addSideEffect(t, r);
  }
  n(Qqe, "addSideEffect");
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-this.js
var cV = E((Yw) => {
  "use strict";
  Object.defineProperty(Yw, "__esModule", {
    value: !0
  });
  Yw.default = eUe;
  var uV = Gt(), lV = ir(), a1;
  function eUe(e) {
    a1 || (a1 = lV.visitors.environmentVisitor({
      ThisExpression(t) {
        t.replaceWith(uV.types.unaryExpression("void", uV.types.numericLiteral(0), !0));
      }
    }), a1.noScope = !0), (0, lV.default)(e.node, a1);
  }
  n(eUe, "rewriteThis");
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js
var fV = E((Gw) => {
  "use strict";
  Object.defineProperty(Gw, "__esModule", {
    value: !0
  });
  Gw.default = rUe;
  var Fe = Gt();
  function tUe(e) {
    do
      switch (e.parent.type) {
        case "TSTypeAnnotation":
        case "TSTypeAliasDeclaration":
        case "TSTypeReference":
        case "TypeAnnotation":
        case "TypeAlias":
          return !0;
        case "ExportSpecifier":
          return e.parentPath.parent.exportKind === "type";
        default:
          if (e.parentPath.isStatement() || e.parentPath.isExpression())
            return !1;
      }
    while (e = e.parentPath);
  }
  n(tUe, "isInType");
  function rUe(e, t, r) {
    let i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ n((l) => {
      e.requeue(l);
    }, "requeueInParent");
    for (let [l, c] of t.source) {
      for (let [f, m] of c.imports)
        i.set(f, [l, m, null]);
      for (let f of c.importsNamespace)
        i.set(f, [l, null, f]);
    }
    for (let [l, c] of t.local) {
      let f = s.get(l);
      f || (f = [], s.set(l, f)), f.push(...c.names);
    }
    let o = {
      metadata: t,
      requeueInParent: a,
      scope: e.scope,
      exported: s
    };
    e.traverse(iUe, o);
    let u = {
      seen: /* @__PURE__ */ new WeakSet(),
      metadata: t,
      requeueInParent: a,
      scope: e.scope,
      imported: i,
      exported: s,
      buildImportReference([l, c, f], m) {
        let h = t.source.get(l);
        if (h.referenced = !0, f) {
          if (h.wrap) {
            var d;
            m = (d = r(m, h.wrap)) != null ? d : m;
          }
          return m;
        }
        let y = Fe.types.identifier(h.name);
        if (h.wrap) {
          var p;
          y = (p = r(y, h.wrap)) != null ? p : y;
        }
        if (c === "default" && h.interop === "node-default")
          return y;
        let g = t.stringSpecifiers.has(c);
        return Fe.types.memberExpression(y, g ? Fe.types.stringLiteral(c) : Fe.types.identifier(c), g);
      }
    };
    e.traverse(sUe, u);
  }
  n(rUe, "rewriteLiveReferences");
  var iUe = {
    Scope(e) {
      e.skip();
    },
    ClassDeclaration(e) {
      let {
        requeueInParent: t,
        exported: r,
        metadata: i
      } = this, {
        id: s
      } = e.node;
      if (!s) throw new Error("Expected class to have a name");
      let a = s.name, o = r.get(a) || [];
      if (o.length > 0) {
        let u = Fe.types.expressionStatement(ou(i, o, Fe.types.identifier(a), e.scope));
        u._blockHoist = e.node._blockHoist, t(e.insertAfter(u)[0]);
      }
    },
    VariableDeclaration(e) {
      let {
        requeueInParent: t,
        exported: r,
        metadata: i
      } = this, s = e.node.kind === "var";
      for (let a of e.get("declarations")) {
        let {
          id: o
        } = a.node, {
          init: u
        } = a.node;
        if (Fe.types.isIdentifier(o) && r.has(o.name) && !Fe.types.isArrowFunctionExpression(u) && (!Fe.types.isFunctionExpression(u) || u.id) &&
        (!Fe.types.isClassExpression(u) || u.id)) {
          if (!u) {
            if (s)
              continue;
            u = e.scope.buildUndefinedNode();
          }
          a.node.init = ou(i, r.get(o.name), u, e.scope), t(a.get("init"));
        } else
          for (let l of Object.keys(a.getOuterBindingIdentifiers()))
            if (r.has(l)) {
              let c = Fe.types.expressionStatement(ou(i, r.get(l), Fe.types.identifier(l), e.scope));
              c._blockHoist = e.node._blockHoist, t(e.insertAfter(c)[0]);
            }
      }
    }
  }, ou = /* @__PURE__ */ n((e, t, r, i) => {
    let s = e.exportName;
    for (let a = i; a != null; a = a.parent)
      a.hasOwnBinding(s) && a.rename(s);
    return (t || []).reduce((a, o) => {
      let {
        stringSpecifiers: u
      } = e, l = u.has(o);
      return Fe.types.assignmentExpression("=", Fe.types.memberExpression(Fe.types.identifier(s), l ? Fe.types.stringLiteral(o) : Fe.types.identifier(
      o), l), a);
    }, r);
  }, "buildBindingExportAssignmentExpression"), o1 = /* @__PURE__ */ n((e) => Fe.template.expression.ast`
    (function() {
      throw new Error('"' + '${e}' + '" is read-only.');
    })()
  `, "buildImportThrow"), sUe = {
    ReferencedIdentifier(e) {
      let {
        seen: t,
        buildImportReference: r,
        scope: i,
        imported: s,
        requeueInParent: a
      } = this;
      if (t.has(e.node)) return;
      t.add(e.node);
      let o = e.node.name, u = s.get(o);
      if (u) {
        if (tUe(e))
          throw e.buildCodeFrameError(`Cannot transform the imported binding "${o}" since it's also used in a type annotation. Please strip \
type annotations using @babel/preset-typescript or @babel/preset-flow.`);
        let l = e.scope.getBinding(o);
        if (i.getBinding(o) !== l) return;
        let f = r(u, e.node);
        if (f.loc = e.node.loc, (e.parentPath.isCallExpression({
          callee: e.node
        }) || e.parentPath.isOptionalCallExpression({
          callee: e.node
        }) || e.parentPath.isTaggedTemplateExpression({
          tag: e.node
        })) && Fe.types.isMemberExpression(f))
          e.replaceWith(Fe.types.sequenceExpression([Fe.types.numericLiteral(0), f]));
        else if (e.isJSXIdentifier() && Fe.types.isMemberExpression(f)) {
          let {
            object: m,
            property: h
          } = f;
          e.replaceWith(Fe.types.jsxMemberExpression(Fe.types.jsxIdentifier(m.name), Fe.types.jsxIdentifier(h.name)));
        } else
          e.replaceWith(f);
        a(e), e.skip();
      }
    },
    UpdateExpression(e) {
      let {
        scope: t,
        seen: r,
        imported: i,
        exported: s,
        requeueInParent: a,
        buildImportReference: o
      } = this;
      if (r.has(e.node)) return;
      r.add(e.node);
      let u = e.get("argument");
      if (u.isMemberExpression()) return;
      let l = e.node;
      if (u.isIdentifier()) {
        let c = u.node.name;
        if (t.getBinding(c) !== e.scope.getBinding(c))
          return;
        let f = s.get(c), m = i.get(c);
        if (f?.length > 0 || m)
          if (m)
            e.replaceWith(Fe.types.assignmentExpression(l.operator[0] + "=", o(m, u.node), o1(c)));
          else if (l.prefix)
            e.replaceWith(ou(this.metadata, f, Fe.types.cloneNode(l), e.scope));
          else {
            let h = t.generateDeclaredUidIdentifier(c);
            e.replaceWith(Fe.types.sequenceExpression([Fe.types.assignmentExpression("=", Fe.types.cloneNode(h), Fe.types.cloneNode(l)), ou(
            this.metadata, f, Fe.types.identifier(c), e.scope), Fe.types.cloneNode(h)]));
          }
      }
      a(e), e.skip();
    },
    AssignmentExpression: {
      exit(e) {
        let {
          scope: t,
          seen: r,
          imported: i,
          exported: s,
          requeueInParent: a,
          buildImportReference: o
        } = this;
        if (r.has(e.node)) return;
        r.add(e.node);
        let u = e.get("left");
        if (!u.isMemberExpression())
          if (u.isIdentifier()) {
            let l = u.node.name;
            if (t.getBinding(l) !== e.scope.getBinding(l))
              return;
            let c = s.get(l), f = i.get(l);
            if (c?.length > 0 || f) {
              let m = e.node;
              f && (m.left = o(f, u.node), m.right = Fe.types.sequenceExpression([m.right, o1(l)]));
              let {
                operator: h
              } = m, d;
              h === "=" ? d = m : h === "&&=" || h === "||=" || h === "??=" ? d = Fe.types.assignmentExpression("=", m.left, Fe.types.logicalExpression(
              h.slice(0, -1), Fe.types.cloneNode(m.left), m.right)) : d = Fe.types.assignmentExpression("=", m.left, Fe.types.binaryExpression(
              h.slice(0, -1), Fe.types.cloneNode(m.left), m.right)), e.replaceWith(ou(this.metadata, c, d, e.scope)), a(e), e.skip();
            }
          } else {
            let l = u.getOuterBindingIdentifiers(), c = Object.keys(l).filter((h) => t.getBinding(h) === e.scope.getBinding(h)), f = c.find(
            (h) => i.has(h));
            f && (e.node.right = Fe.types.sequenceExpression([e.node.right, o1(f)]));
            let m = [];
            if (c.forEach((h) => {
              let d = s.get(h) || [];
              d.length > 0 && m.push(ou(this.metadata, d, Fe.types.identifier(h), e.scope));
            }), m.length > 0) {
              let h = Fe.types.sequenceExpression(m);
              e.parentPath.isExpressionStatement() && (h = Fe.types.expressionStatement(h), h._blockHoist = e.parentPath.node._blockHoist);
              let d = e.insertAfter(h)[0];
              a(d);
            }
          }
      }
    },
    ForXStatement(e) {
      let {
        scope: t,
        node: r
      } = e, {
        left: i
      } = r, {
        exported: s,
        imported: a,
        scope: o
      } = this;
      if (!Fe.types.isVariableDeclaration(i)) {
        let u = !1, l, c = e.get("body").scope;
        for (let h of Object.keys(Fe.types.getOuterBindingIdentifiers(i)))
          o.getBinding(h) === t.getBinding(h) && (s.has(h) && (u = !0, c.hasOwnBinding(h) && c.rename(h)), a.has(h) && !l && (l = h));
        if (!u && !l)
          return;
        e.ensureBlock();
        let f = e.get("body"), m = t.generateUidIdentifierBasedOnNode(i);
        e.get("left").replaceWith(Fe.types.variableDeclaration("let", [Fe.types.variableDeclarator(Fe.types.cloneNode(m))])), t.registerDeclaration(
        e.get("left")), u && f.unshiftContainer("body", Fe.types.expressionStatement(Fe.types.assignmentExpression("=", i, m))), l && f.unshiftContainer(
        "body", Fe.types.expressionStatement(o1(l)));
      }
    }
  };
});

// ../node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js
var Zw = E((oc) => {
  "use strict";
  Object.defineProperty(oc, "__esModule", {
    value: !0
  });
  oc.default = lUe;
  oc.hasExports = aUe;
  oc.isSideEffectImport = oUe;
  oc.validateImportInteropOption = pV;
  var dV = require("path"), nUe = Ol();
  function aUe(e) {
    return e.hasExports;
  }
  n(aUe, "hasExports");
  function oUe(e) {
    return e.imports.size === 0 && e.importsNamespace.size === 0 && e.reexports.size === 0 && e.reexportNamespace.size === 0 && !e.reexportAll;
  }
  n(oUe, "isSideEffectImport");
  function pV(e) {
    if (typeof e != "function" && e !== "none" && e !== "babel" && e !== "node")
      throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${e}).`);
    return e;
  }
  n(pV, "validateImportInteropOption");
  function uUe(e, t, r) {
    return typeof e == "function" ? pV(e(t, r)) : e;
  }
  n(uUe, "resolveImportInterop");
  function lUe(e, t, {
    importInterop: r,
    initializeReexports: i = !1,
    getWrapperPayload: s,
    esNamespaceOnly: a = !1,
    filename: o
  }) {
    t || (t = e.scope.generateUidIdentifier("exports").name);
    let u = /* @__PURE__ */ new Set();
    dUe(e);
    let {
      local: l,
      sources: c,
      hasExports: f
    } = cUe(e, {
      initializeReexports: i,
      getWrapperPayload: s
    }, u);
    pUe(e);
    for (let [m, h] of c) {
      let {
        importsNamespace: d,
        imports: y
      } = h;
      if (d.size > 0 && y.size === 0) {
        let [g] = d;
        h.name = g;
      }
      let p = uUe(r, m, o);
      p === "none" ? h.interop = "none" : p === "node" && h.interop === "namespace" ? h.interop = "node-namespace" : p === "node" && h.interop ===
      "default" ? h.interop = "node-default" : a && h.interop === "namespace" && (h.interop = "default");
    }
    return {
      exportName: t,
      exportNameListName: null,
      hasExports: f,
      local: l,
      source: c,
      stringSpecifiers: u
    };
  }
  n(lUe, "normalizeModuleAndLoadMetadata");
  function u1(e, t) {
    if (e.isIdentifier())
      return e.node.name;
    if (e.isStringLiteral()) {
      let r = e.node.value;
      return (0, nUe.isIdentifierName)(r) || t.add(r), r;
    } else
      throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${e.node.type}`);
  }
  n(u1, "getExportSpecifierName");
  function hV(e) {
    if (!e.isExportSpecifier())
      throw e.isExportNamespaceSpecifier() ? e.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform\
-export-namespace-from`.") : e.buildCodeFrameError("Unexpected export specifier type");
  }
  n(hV, "assertExportSpecifier");
  function cUe(e, {
    getWrapperPayload: t,
    initializeReexports: r
  }, i) {
    let s = fUe(e, r, i), a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ n((c, f) => {
      let m = c.value, h = o.get(m);
      return h ? a.get(m).push(f) : (h = {
        name: e.scope.generateUidIdentifier((0, dV.basename)(m, (0, dV.extname)(m))).name,
        interop: "none",
        loc: null,
        imports: /* @__PURE__ */ new Map(),
        importsNamespace: /* @__PURE__ */ new Set(),
        reexports: /* @__PURE__ */ new Map(),
        reexportNamespace: /* @__PURE__ */ new Set(),
        reexportAll: null,
        wrap: null,
        get lazy() {
          return this.wrap === "lazy";
        },
        referenced: !1
      }, o.set(m, h), a.set(m, [f])), h;
    }, "getData"), l = !1;
    e.get("body").forEach((c) => {
      if (c.isImportDeclaration()) {
        let f = u(c.node.source, c.node);
        f.loc || (f.loc = c.node.loc), c.get("specifiers").forEach((m) => {
          if (m.isImportDefaultSpecifier()) {
            let h = m.get("local").node.name;
            f.imports.set(h, "default");
            let d = s.get(h);
            d && (s.delete(h), d.names.forEach((y) => {
              f.reexports.set(y, "default");
            }), f.referenced = !0);
          } else if (m.isImportNamespaceSpecifier()) {
            let h = m.get("local").node.name;
            f.importsNamespace.add(h);
            let d = s.get(h);
            d && (s.delete(h), d.names.forEach((y) => {
              f.reexportNamespace.add(y);
            }), f.referenced = !0);
          } else if (m.isImportSpecifier()) {
            let h = u1(m.get("imported"), i), d = m.get("local").node.name;
            f.imports.set(d, h);
            let y = s.get(d);
            y && (s.delete(d), y.names.forEach((p) => {
              f.reexports.set(p, h);
            }), f.referenced = !0);
          }
        });
      } else if (c.isExportAllDeclaration()) {
        l = !0;
        let f = u(c.node.source, c.node);
        f.loc || (f.loc = c.node.loc), f.reexportAll = {
          loc: c.node.loc
        }, f.referenced = !0;
      } else if (c.isExportNamedDeclaration() && c.node.source) {
        l = !0;
        let f = u(c.node.source, c.node);
        f.loc || (f.loc = c.node.loc), c.get("specifiers").forEach((m) => {
          hV(m);
          let h = u1(m.get("local"), i), d = u1(m.get("exported"), i);
          if (f.reexports.set(d, h), f.referenced = !0, d === "__esModule")
            throw m.get("exported").buildCodeFrameError('Illegal export "__esModule".');
        });
      } else (c.isExportNamedDeclaration() || c.isExportDefaultDeclaration()) && (l = !0);
    });
    for (let c of o.values()) {
      let f = !1, m = !1;
      c.importsNamespace.size > 0 && (f = !0, m = !0), c.reexportAll && (m = !0);
      for (let h of c.imports.values())
        h === "default" ? f = !0 : m = !0;
      for (let h of c.reexports.values())
        h === "default" ? f = !0 : m = !0;
      f && m ? c.interop = "namespace" : f && (c.interop = "default");
    }
    if (t)
      for (let [c, f] of o)
        f.wrap = t(c, f, a.get(c));
    return {
      hasExports: l,
      local: s,
      sources: o
    };
  }
  n(cUe, "getModuleMetadata");
  function fUe(e, t, r) {
    let i = /* @__PURE__ */ new Map(), s = e.scope, a = e.get("body");
    a.forEach((l) => {
      let c;
      if (l.isImportDeclaration())
        c = "import";
      else {
        if (l.isExportDefaultDeclaration() && (l = l.get("declaration")), l.isExportNamedDeclaration()) {
          if (l.node.declaration)
            l = l.get("declaration");
          else if (t && l.node.source && l.get("source").isStringLiteral()) {
            l.get("specifiers").forEach((f) => {
              hV(f), i.set(f.get("local").node.name, "block");
            });
            return;
          }
        }
        if (l.isFunctionDeclaration())
          c = "hoisted";
        else if (l.isClassDeclaration())
          c = "block";
        else if (l.isVariableDeclaration({
          kind: "var"
        }))
          c = "var";
        else if (l.isVariableDeclaration())
          c = "block";
        else
          return;
      }
      Object.keys(l.getOuterBindingIdentifiers()).forEach((f) => {
        i.set(f, c);
      });
    });
    let o = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ n((l) => {
      let c = l.node.name, f = o.get(c);
      if (!f) {
        var m, h;
        let d = (m = i.get(c)) != null ? m : (h = s.getBinding(c)) == null ? void 0 : h.kind;
        if (d === void 0)
          throw l.buildCodeFrameError(`Exporting local "${c}", which is not declared.`);
        f = {
          names: [],
          kind: d
        }, o.set(c, f);
      }
      return f;
    }, "getLocalMetadata");
    return a.forEach((l) => {
      if (l.isExportNamedDeclaration() && (t || !l.node.source))
        if (l.node.declaration) {
          let c = l.get("declaration"), f = c.getOuterBindingIdentifierPaths();
          Object.keys(f).forEach((m) => {
            if (m === "__esModule")
              throw c.buildCodeFrameError('Illegal export "__esModule".');
            u(f[m]).names.push(m);
          });
        } else
          l.get("specifiers").forEach((c) => {
            let f = c.get("local"), m = c.get("exported"), h = u(f), d = u1(m, r);
            if (d === "__esModule")
              throw m.buildCodeFrameError('Illegal export "__esModule".');
            h.names.push(d);
          });
      else if (l.isExportDefaultDeclaration()) {
        let c = l.get("declaration");
        if (c.isFunctionDeclaration() || c.isClassDeclaration())
          u(c.get("id")).names.push("default");
        else
          throw c.buildCodeFrameError("Unexpected default expression export.");
      }
    }), o;
  }
  n(fUe, "getLocalExportMetadata");
  function dUe(e) {
    e.get("body").forEach((t) => {
      if (t.isExportDefaultDeclaration()) {
        {
          var r;
          (r = t.splitExportDeclaration) != null || (t.splitExportDeclaration = ir().NodePath.prototype.splitExportDeclaration);
        }
        t.splitExportDeclaration();
      }
    });
  }
  n(dUe, "nameAnonymousExports");
  function pUe(e) {
    e.get("body").forEach((t) => {
      if (t.isImportDeclaration())
        t.remove();
      else if (t.isExportNamedDeclaration())
        t.node.declaration ? (t.node.declaration._blockHoist = t.node._blockHoist, t.replaceWith(t.node.declaration)) : t.remove();
      else if (t.isExportDefaultDeclaration()) {
        let r = t.get("declaration");
        if (r.isFunctionDeclaration() || r.isClassDeclaration())
          r._blockHoist = t.node._blockHoist, t.replaceWith(r);
        else
          throw r.buildCodeFrameError("Unexpected default expression export.");
      } else t.isExportAllDeclaration() && t.remove();
    });
  }
  n(pUe, "removeImportExportDeclarations");
});

// ../node_modules/@babel/helper-module-transforms/lib/lazy-modules.js
var mV = E((l1) => {
  "use strict";
  Object.defineProperty(l1, "__esModule", {
    value: !0
  });
  l1.toGetWrapperPayload = yUe;
  l1.wrapReference = gUe;
  var hUe = Gt(), mUe = Zw();
  function yUe(e) {
    return (t, r) => {
      if (e === !1 || (0, mUe.isSideEffectImport)(r) || r.reexportAll) return null;
      if (e === !0)
        return t.includes(".") ? null : "lazy";
      if (Array.isArray(e))
        return e.includes(t) ? "lazy" : null;
      if (typeof e == "function")
        return e(t) ? "lazy" : null;
      throw new Error(".lazy must be a boolean, string array, or function");
    };
  }
  n(yUe, "toGetWrapperPayload");
  function gUe(e, t) {
    return t === "lazy" ? hUe.types.callExpression(e, []) : null;
  }
  n(gUe, "wrapReference");
});

// ../node_modules/@babel/helper-module-transforms/lib/dynamic-import.js
var Qw = E((c1) => {
  "use strict";
  Object.defineProperty(c1, "__esModule", {
    value: !0
  });
  c1.buildDynamicImport = bUe;
  var Br = Gt();
  c1.getDynamicImportSource = /* @__PURE__ */ n(function(t) {
    let [r] = t.arguments;
    return Br.types.isStringLiteral(r) || Br.types.isTemplateLiteral(r) ? r : Br.template.expression.ast`\`\${${r}}\``;
  }, "getDynamicImportSource");
  function bUe(e, t, r, i) {
    let s = Br.types.isCallExpression(e) ? e.arguments[0] : e.source;
    if (Br.types.isStringLiteral(s) || Br.types.isTemplateLiteral(s) && s.quasis.length === 0)
      return t ? Br.template.expression.ast`
        Promise.resolve().then(() => ${i(s)})
      ` : i(s);
    let a = Br.types.isTemplateLiteral(s) ? Br.types.identifier("specifier") : Br.types.templateLiteral([Br.types.templateElement({
      raw: ""
    }), Br.types.templateElement({
      raw: ""
    })], [Br.types.identifier("specifier")]);
    return t ? Br.template.expression.ast`
      (specifier =>
        new Promise(r => r(${a}))
          .then(s => ${i(Br.types.identifier("s"))})
      )(${s})
    ` : r ? Br.template.expression.ast`
      (specifier =>
        new Promise(r => r(${i(a)}))
      )(${s})
    ` : Br.template.expression.ast`
      (specifier => ${i(a)})(${s})
    `;
  }
  n(bUe, "buildDynamicImport");
});

// ../node_modules/@babel/helper-module-transforms/lib/get-module-name.js
var yV = E((f1) => {
  "use strict";
  Object.defineProperty(f1, "__esModule", {
    value: !0
  });
  f1.default = eA;
  {
    let e = eA;
    f1.default = eA = /* @__PURE__ */ n(function(r, i) {
      var s, a, o, u;
      return e(r, {
        moduleId: (s = i.moduleId) != null ? s : r.moduleId,
        moduleIds: (a = i.moduleIds) != null ? a : r.moduleIds,
        getModuleId: (o = i.getModuleId) != null ? o : r.getModuleId,
        moduleRoot: (u = i.moduleRoot) != null ? u : r.moduleRoot
      });
    }, "getModuleName");
  }
  function eA(e, t) {
    let {
      filename: r,
      filenameRelative: i = r,
      sourceRoot: s = t.moduleRoot
    } = e, {
      moduleId: a,
      moduleIds: o = !!a,
      getModuleId: u,
      moduleRoot: l = s
    } = t;
    if (!o) return null;
    if (a != null && !u)
      return a;
    let c = l != null ? l + "/" : "";
    if (i) {
      let f = s != null ? new RegExp("^" + s + "/?") : "";
      c += i.replace(f, "").replace(/\.\w*$/, "");
    }
    return c = c.replace(/\\/g, "/"), u && u(c) || c;
  }
  n(eA, "getModuleName");
});

// ../node_modules/@babel/helper-module-transforms/lib/index.js
var bp = E((Ai) => {
  "use strict";
  Object.defineProperty(Ai, "__esModule", {
    value: !0
  });
  Object.defineProperty(Ai, "buildDynamicImport", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return xUe.buildDynamicImport;
    }, "get")
  });
  Ai.buildNamespaceInitStatements = wUe;
  Ai.ensureStatementsHoisted = TUe;
  Object.defineProperty(Ai, "getModuleName", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return EUe.default;
    }, "get")
  });
  Object.defineProperty(Ai, "hasExports", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gp.hasExports;
    }, "get")
  });
  Object.defineProperty(Ai, "isModule", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gV.isModule;
    }, "get")
  });
  Object.defineProperty(Ai, "isSideEffectImport", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return gp.isSideEffectImport;
    }, "get")
  });
  Ai.rewriteModuleStatementsAndPrepareHeader = SUe;
  Object.defineProperty(Ai, "rewriteThis", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return bV.default;
    }, "get")
  });
  Ai.wrapInterop = CUe;
  var DUe = require("assert"), Qe = Gt(), gV = oV(), bV = cV(), vUe = fV(), gp = Zw(), sA = mV(), xUe = Qw(), EUe = yV();
  Ai.getDynamicImportSource = Qw().getDynamicImportSource;
  function SUe(e, {
    exportName: t,
    strict: r,
    allowTopLevelThis: i,
    strictMode: s,
    noInterop: a,
    importInterop: o = a ? "none" : "babel",
    lazy: u,
    getWrapperPayload: l = sA.toGetWrapperPayload(u ?? !1),
    wrapReference: c = sA.wrapReference,
    esNamespaceOnly: f,
    filename: m,
    constantReexports: h = arguments[1].loose,
    enumerableModuleMeta: d = arguments[1].loose,
    noIncompleteNsImportDetection: y
  }) {
    (0, gp.validateImportInteropOption)(o), DUe((0, gV.isModule)(e), "Cannot process module statements in a script"), e.node.sourceType = "s\
cript";
    let p = (0, gp.default)(e, t, {
      importInterop: o,
      initializeReexports: h,
      getWrapperPayload: l,
      esNamespaceOnly: f,
      filename: m
    });
    i || (0, bV.default)(e), (0, vUe.default)(e, p, c), s !== !1 && (e.node.directives.some((x) => x.value.value === "use strict") || e.unshiftContainer(
    "directives", Qe.types.directive(Qe.types.directiveLiteral("use strict"))));
    let g = [];
    (0, gp.hasExports)(p) && !r && g.push(AUe(p, d));
    let b = PUe(e, p);
    return b && (p.exportNameListName = b.name, g.push(b.statement)), g.push(...FUe(e, p, c, h, y)), {
      meta: p,
      headers: g
    };
  }
  n(SUe, "rewriteModuleStatementsAndPrepareHeader");
  function TUe(e) {
    e.forEach((t) => {
      t._blockHoist = 3;
    });
  }
  n(TUe, "ensureStatementsHoisted");
  function CUe(e, t, r) {
    if (r === "none")
      return null;
    if (r === "node-namespace")
      return Qe.types.callExpression(e.hub.addHelper("interopRequireWildcard"), [t, Qe.types.booleanLiteral(!0)]);
    if (r === "node-default")
      return null;
    let i;
    if (r === "default")
      i = "interopRequireDefault";
    else if (r === "namespace")
      i = "interopRequireWildcard";
    else
      throw new Error(`Unknown interop: ${r}`);
    return Qe.types.callExpression(e.hub.addHelper(i), [t]);
  }
  n(CUe, "wrapInterop");
  function wUe(e, t, r = !1, i = sA.wrapReference) {
    var s;
    let a = [], o = Qe.types.identifier(t.name);
    for (let l of t.importsNamespace)
      l !== t.name && a.push(Qe.template.statement`var NAME = SOURCE;`({
        NAME: l,
        SOURCE: Qe.types.cloneNode(o)
      }));
    let u = (s = i(o, t.wrap)) != null ? s : o;
    r && a.push(...DV(e, t, !0, i));
    for (let l of t.reexportNamespace)
      a.push((Qe.types.isIdentifier(u) ? Qe.template.statement`EXPORTS.NAME = NAMESPACE;` : Qe.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({
        EXPORTS: e.exportName,
        NAME: l,
        NAMESPACE: Qe.types.cloneNode(u)
      }));
    if (t.reexportAll) {
      let l = _Ue(e, Qe.types.cloneNode(u), r);
      l.loc = t.reexportAll.loc, a.push(l);
    }
    return a;
  }
  n(wUe, "buildNamespaceInitStatements");
  var tA = {
    constant: /* @__PURE__ */ n(({
      exports: e,
      exportName: t,
      namespaceImport: r
    }) => Qe.template.statement.ast`
      ${e}.${t} = ${r};
    `, "constant"),
    constantComputed: /* @__PURE__ */ n(({
      exports: e,
      exportName: t,
      namespaceImport: r
    }) => Qe.template.statement.ast`
      ${e}["${t}"] = ${r};
    `, "constantComputed"),
    spec: /* @__PURE__ */ n(({
      exports: e,
      exportName: t,
      namespaceImport: r
    }) => Qe.template.statement.ast`
      Object.defineProperty(${e}, "${t}", {
        enumerable: true,
        get: function() {
          return ${r};
        },
      });
    `, "spec")
  };
  function DV(e, t, r, i) {
    var s;
    let a = Qe.types.identifier(t.name);
    a = (s = i(a, t.wrap)) != null ? s : a;
    let {
      stringSpecifiers: o
    } = e;
    return Array.from(t.reexports, ([u, l]) => {
      let c = Qe.types.cloneNode(a);
      l === "default" && t.interop === "node-default" || (o.has(l) ? c = Qe.types.memberExpression(c, Qe.types.stringLiteral(l), !0) : c = Qe.
      types.memberExpression(c, Qe.types.identifier(l)));
      let f = {
        exports: e.exportName,
        exportName: u,
        namespaceImport: c
      };
      return r || Qe.types.isIdentifier(c) ? o.has(u) ? tA.constantComputed(f) : tA.constant(f) : tA.spec(f);
    });
  }
  n(DV, "buildReexportsFromMeta");
  function AUe(e, t = !1) {
    return (t ? Qe.template.statement`
        EXPORTS.__esModule = true;
      ` : Qe.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
      EXPORTS: e.exportName
    });
  }
  n(AUe, "buildESModuleHeader");
  function _Ue(e, t, r) {
    return (r ? Qe.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : Qe.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
      NAMESPACE: t,
      EXPORTS: e.exportName,
      VERIFY_NAME_LIST: e.exportNameListName ? (0, Qe.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
        EXPORTS_LIST: e.exportNameListName
      }) : null
    });
  }
  n(_Ue, "buildNamespaceReexport");
  function PUe(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let a of t.local.values())
      for (let o of a.names)
        r[o] = !0;
    let i = !1;
    for (let a of t.source.values()) {
      for (let o of a.reexports.keys())
        r[o] = !0;
      for (let o of a.reexportNamespace)
        r[o] = !0;
      i = i || !!a.reexportAll;
    }
    if (!i || Object.keys(r).length === 0) return null;
    let s = e.scope.generateUidIdentifier("exportNames");
    return delete r.default, {
      name: s.name,
      statement: Qe.types.variableDeclaration("var", [Qe.types.variableDeclarator(s, Qe.types.valueToNode(r))])
    };
  }
  n(PUe, "buildExportNameListDeclaration");
  function FUe(e, t, r, i = !1, s = !1) {
    let a = [];
    for (let [u, l] of t.local)
      if (l.kind !== "import") {
        if (l.kind === "hoisted")
          a.push([l.names[0], iA(t, l.names, Qe.types.identifier(u))]);
        else if (!s)
          for (let c of l.names)
            a.push([c, null]);
      }
    for (let u of t.source.values()) {
      if (!i) {
        let l = DV(t, u, !1, r), c = [...u.reexports.keys()];
        for (let f = 0; f < l.length; f++)
          a.push([c[f], l[f]]);
      }
      if (!s)
        for (let l of u.reexportNamespace)
          a.push([l, null]);
    }
    a.sort(([u], [l]) => u < l ? -1 : l < u ? 1 : 0);
    let o = [];
    if (s)
      for (let [, u] of a)
        o.push(u);
    else
      for (let l = 0; l < a.length; l += 100) {
        let c = [];
        for (let f = 0; f < 100 && l + f < a.length; f++) {
          let [m, h] = a[l + f];
          h !== null ? (c.length > 0 && (o.push(iA(t, c, e.scope.buildUndefinedNode())), c = []), o.push(h)) : c.push(m);
        }
        c.length > 0 && o.push(iA(t, c, e.scope.buildUndefinedNode()));
      }
    return o;
  }
  n(FUe, "buildExportInitializationStatements");
  var rA = {
    computed: /* @__PURE__ */ n(({
      exports: e,
      name: t,
      value: r
    }) => Qe.template.expression.ast`${e}["${t}"] = ${r}`, "computed"),
    default: /* @__PURE__ */ n(({
      exports: e,
      name: t,
      value: r
    }) => Qe.template.expression.ast`${e}.${t} = ${r}`, "default"),
    define: /* @__PURE__ */ n(({
      exports: e,
      name: t,
      value: r
    }) => Qe.template.expression.ast`
      Object.defineProperty(${e}, "${t}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${t}"] = ${r}`, "define")
  };
  function iA(e, t, r) {
    let {
      stringSpecifiers: i,
      exportName: s
    } = e;
    return Qe.types.expressionStatement(t.reduce((a, o) => {
      let u = {
        exports: s,
        name: o,
        value: a
      };
      return o === "__proto__" ? rA.define(u) : i.has(o) ? rA.computed(u) : rA.default(u);
    }, r));
  }
  n(iA, "buildInitStatement");
});

// ../node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs
var xV = E((vV) => {
  vV.getModuleName = () => bp().getModuleName;
});

// ../node_modules/@babel/core/lib/transformation/file/file.js
var aA = E((p1) => {
  "use strict";
  Object.defineProperty(p1, "__esModule", {
    value: !0
  });
  p1.default = void 0;
  function uu() {
    let e = aC();
    return uu = /* @__PURE__ */ n(function() {
      return e;
    }, "helpers"), e;
  }
  n(uu, "helpers");
  function nA() {
    let e = ir();
    return nA = /* @__PURE__ */ n(function() {
      return e;
    }, "_traverse"), e;
  }
  n(nA, "_traverse");
  function EV() {
    let e = Wd();
    return EV = /* @__PURE__ */ n(function() {
      return e;
    }, "_codeFrame"), e;
  }
  n(EV, "_codeFrame");
  function SV() {
    let e = Pe();
    return SV = /* @__PURE__ */ n(function() {
      return e;
    }, "_t"), e;
  }
  n(SV, "_t");
  function d1() {
    let e = require("semver");
    return d1 = /* @__PURE__ */ n(function() {
      return e;
    }, "_semver"), e;
  }
  n(d1, "_semver");
  var IUe = xV(), {
    cloneNode: OUe,
    interpreterDirective: kUe
  } = SV(), BUe = {
    enter(e, t) {
      let r = e.node.loc;
      r && (t.loc = r, e.stop());
    }
  }, uc = class {
    static {
      n(this, "File");
    }
    constructor(t, {
      code: r,
      ast: i,
      inputMap: s
    }) {
      this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope =
      void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = {
        file: this,
        getCode: /* @__PURE__ */ n(() => this.code, "getCode"),
        getScope: /* @__PURE__ */ n(() => this.scope, "getScope"),
        addHelper: this.addHelper.bind(this),
        buildError: this.buildCodeFrameError.bind(this)
      }, this.opts = t, this.code = r, this.ast = i, this.inputMap = s, this.path = nA().NodePath.get({
        hub: this.hub,
        parentPath: null,
        parent: this.ast,
        container: this.ast,
        key: "program"
      }).setContext(), this.scope = this.path.scope;
    }
    get shebang() {
      let {
        interpreter: t
      } = this.path.node;
      return t ? t.value : "";
    }
    set shebang(t) {
      t ? this.path.get("interpreter").replaceWith(kUe(t)) : this.path.get("interpreter").remove();
    }
    set(t, r) {
      if (t === "helpersNamespace")
        throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-\
helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to \
explore using 'helperGenerator' alongside 'file.availableHelper()'.");
      this._map.set(t, r);
    }
    get(t) {
      return this._map.get(t);
    }
    has(t) {
      return this._map.has(t);
    }
    availableHelper(t, r) {
      if (uu().isInternal(t)) return !1;
      let i;
      try {
        i = uu().minVersion(t);
      } catch (s) {
        if (s.code !== "BABEL_HELPER_UNKNOWN") throw s;
        return !1;
      }
      return typeof r != "string" ? !0 : (d1().valid(r) && (r = `^${r}`), !d1().intersects(`<${i}`, r) && !d1().intersects(">=8.0.0", r));
    }
    addHelper(t) {
      if (uu().isInternal(t))
        throw new Error("Cannot use internal helper " + t);
      return this._addHelper(t);
    }
    _addHelper(t) {
      let r = this.declarations[t];
      if (r) return OUe(r);
      let i = this.get("helperGenerator");
      if (i) {
        let c = i(t);
        if (c) return c;
      }
      uu().minVersion(t);
      let s = this.declarations[t] = this.scope.generateUidIdentifier(t), a = {};
      for (let c of uu().getDependencies(t))
        a[c] = this._addHelper(c);
      let {
        nodes: o,
        globals: u
      } = uu().get(t, (c) => a[c], s.name, Object.keys(this.scope.getAllBindings()));
      u.forEach((c) => {
        this.path.scope.hasBinding(c, !0) && this.path.scope.rename(c);
      }), o.forEach((c) => {
        c._compact = !0;
      });
      let l = this.path.unshiftContainer("body", o);
      for (let c of l)
        c.isVariableDeclaration() && this.scope.registerDeclaration(c);
      return s;
    }
    buildCodeFrameError(t, r, i = SyntaxError) {
      let s = t?.loc;
      if (!s && t) {
        let a = {
          loc: null
        };
        (0, nA().default)(t, BUe, this.scope, a), s = a.loc;
        let o = "This is an error on an internal node. Probably an internal error.";
        s && (o += " Location has been estimated."), r += ` (${o})`;
      }
      if (s) {
        let {
          highlightCode: a = !0
        } = this.opts;
        r += `
` + (0, EV().codeFrameColumns)(this.code, {
          start: {
            line: s.start.line,
            column: s.start.column + 1
          },
          end: s.end && s.start.line === s.end.line ? {
            line: s.end.line,
            column: s.end.column + 1
          } : void 0
        }, {
          highlightCode: a
        });
      }
      return new i(r);
    }
  };
  p1.default = uc;
  uc.prototype.addImport = /* @__PURE__ */ n(function() {
    throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-mo\
dule-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
  }, "addImport"), uc.prototype.addTemplateObject = /* @__PURE__ */ n(function() {
    throw new Error("This function has been moved into the template literal transform itself.");
  }, "addTemplateObject"), uc.prototype.getModuleName = /* @__PURE__ */ n(function() {
    return IUe.getModuleName()(this.opts, this.opts);
  }, "getModuleName");
});

// ../node_modules/@babel/core/lib/tools/build-external-helpers.js
var _V = E((pA) => {
  "use strict";
  Object.defineProperty(pA, "__esModule", {
    value: !0
  });
  pA.default = YUe;
  function oA() {
    let e = aC();
    return oA = /* @__PURE__ */ n(function() {
      return e;
    }, "helpers"), e;
  }
  n(oA, "helpers");
  function TV() {
    let e = op();
    return TV = /* @__PURE__ */ n(function() {
      return e;
    }, "_generator"), e;
  }
  n(TV, "_generator");
  function CV() {
    let e = zd();
    return CV = /* @__PURE__ */ n(function() {
      return e;
    }, "_template"), e;
  }
  n(CV, "_template");
  function wV() {
    let e = Pe();
    return wV = /* @__PURE__ */ n(function() {
      return e;
    }, "_t"), e;
  }
  n(wV, "_t");
  var {
    arrayExpression: NUe,
    assignmentExpression: h1,
    binaryExpression: MUe,
    blockStatement: RUe,
    callExpression: LUe,
    cloneNode: jUe,
    conditionalExpression: qUe,
    exportNamedDeclaration: UUe,
    exportSpecifier: $Ue,
    expressionStatement: uA,
    functionExpression: VUe,
    identifier: Nr,
    memberExpression: lA,
    objectExpression: cA,
    program: m1,
    stringLiteral: AV,
    unaryExpression: WUe,
    variableDeclaration: fA,
    variableDeclarator: dA
  } = wV(), HUe = /* @__PURE__ */ n((e) => CV().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(e), "buildUmdWrapper");
  function KUe(e) {
    let t = Nr("babelHelpers"), r = [], i = VUe(null, [Nr("global")], RUe(r)), s = m1([uA(LUe(i, [qUe(MUe("===", WUe("typeof", Nr("global")),
    AV("undefined")), Nr("self"), Nr("global"))]))]);
    return r.push(fA("var", [dA(t, h1("=", lA(Nr("global"), t), cA([])))])), y1(r, t, e), s;
  }
  n(KUe, "buildGlobal");
  function zUe(e) {
    let t = [], r = y1(t, null, e);
    return t.unshift(UUe(null, Object.keys(r).map((i) => $Ue(jUe(r[i]), Nr(i))))), m1(t, [], "module");
  }
  n(zUe, "buildModule");
  function JUe(e) {
    let t = Nr("babelHelpers"), r = [];
    return r.push(fA("var", [dA(t, Nr("global"))])), y1(r, t, e), m1([HUe({
      FACTORY_PARAMETERS: Nr("global"),
      BROWSER_ARGUMENTS: h1("=", lA(Nr("root"), t), cA([])),
      COMMON_ARGUMENTS: Nr("exports"),
      AMD_ARGUMENTS: NUe([AV("exports")]),
      FACTORY_BODY: r,
      UMD_ROOT: Nr("this")
    })]);
  }
  n(JUe, "buildUmd");
  function XUe(e) {
    let t = Nr("babelHelpers"), r = [];
    r.push(fA("var", [dA(t, cA([]))]));
    let i = m1(r);
    return y1(r, t, e), r.push(uA(t)), i;
  }
  n(XUe, "buildVar");
  function y1(e, t, r) {
    let i = /* @__PURE__ */ n((a) => t ? lA(t, Nr(a)) : Nr(`_${a}`), "getHelperReference"), s = {};
    return oA().list.forEach(function(a) {
      if (r && !r.includes(a)) return;
      let o = s[a] = i(a), {
        nodes: u
      } = oA().get(a, i, t ? null : `_${a}`, [], t ? (l, c, f) => {
        f((m) => h1("=", o, m)), l.body.push(uA(h1("=", o, Nr(c))));
      } : null);
      e.push(...u);
    }), s;
  }
  n(y1, "buildHelpers");
  function YUe(e, t = "global") {
    let r, i = {
      global: KUe,
      module: zUe,
      umd: JUe,
      var: XUe
    }[t];
    if (i)
      r = i(e);
    else
      throw new Error(`Unsupported output type ${t}`);
    return (0, TV().default)(r).code;
  }
  n(YUe, "_default");
});

// ../node_modules/gensync/index.js
var _i = E((e2t, MV) => {
  "use strict";
  var FV = Symbol.for("gensync:v1:start"), IV = Symbol.for("gensync:v1:suspend"), GUe = "GENSYNC_EXPECTED_START", ZUe = "GENSYNC_EXPECTED_SU\
SPEND", OV = "GENSYNC_OPTIONS_ERROR", PV = "GENSYNC_RACE_NONEMPTY", QUe = "GENSYNC_ERRBACK_NO_CALLBACK";
  MV.exports = Object.assign(
    /* @__PURE__ */ n(function(t) {
      let r = t;
      return typeof t != "function" ? r = t$e(t) : r = r$e(t), Object.assign(r, e$e(r));
    }, "gensync"),
    {
      all: hA({
        name: "all",
        arity: 1,
        sync: /* @__PURE__ */ n(function(e) {
          return Array.from(e[0]).map((r) => mA(r));
        }, "sync"),
        async: /* @__PURE__ */ n(function(e, t, r) {
          let i = Array.from(e[0]);
          if (i.length === 0) {
            Promise.resolve().then(() => t([]));
            return;
          }
          let s = 0, a = i.map(() => {
          });
          i.forEach((o, u) => {
            g1(
              o,
              (l) => {
                a[u] = l, s += 1, s === a.length && t(a);
              },
              r
            );
          });
        }, "async")
      }),
      race: hA({
        name: "race",
        arity: 1,
        sync: /* @__PURE__ */ n(function(e) {
          let t = Array.from(e[0]);
          if (t.length === 0)
            throw lu("Must race at least 1 item", PV);
          return mA(t[0]);
        }, "sync"),
        async: /* @__PURE__ */ n(function(e, t, r) {
          let i = Array.from(e[0]);
          if (i.length === 0)
            throw lu("Must race at least 1 item", PV);
          for (let s of i)
            g1(s, t, r);
        }, "async")
      })
    }
  );
  function e$e(e) {
    return {
      sync: /* @__PURE__ */ n(function(...r) {
        return mA(e.apply(this, r));
      }, "sync"),
      async: /* @__PURE__ */ n(function(...r) {
        return new Promise((i, s) => {
          g1(e.apply(this, r), i, s);
        });
      }, "async"),
      errback: /* @__PURE__ */ n(function(...r) {
        let i = r.pop();
        if (typeof i != "function")
          throw lu(
            "Asynchronous function called without callback",
            QUe
          );
        let s;
        try {
          s = e.apply(this, r);
        } catch (a) {
          i(a);
          return;
        }
        g1(s, (a) => i(void 0, a), (a) => i(a));
      }, "errback")
    };
  }
  n(e$e, "makeFunctionAPI");
  function Dp(e, t, r, i) {
    if (typeof r === e || i && typeof r > "u")
      return;
    let s;
    throw i ? s = `Expected opts.${t} to be either a ${e}, or undefined.` : s = `Expected opts.${t} to be a ${e}.`, lu(s, OV);
  }
  n(Dp, "assertTypeof");
  function lu(e, t) {
    return Object.assign(new Error(e), { code: t });
  }
  n(lu, "makeError");
  function t$e({ name: e, arity: t, sync: r, async: i, errback: s }) {
    if (Dp(
      "string",
      "name",
      e,
      !0
      /* allowUndefined */
    ), Dp(
      "number",
      "arity",
      t,
      !0
      /* allowUndefined */
    ), Dp("function", "sync", r), Dp(
      "function",
      "async",
      i,
      !0
      /* allowUndefined */
    ), Dp(
      "function",
      "errback",
      s,
      !0
      /* allowUndefined */
    ), i && s)
      throw lu(
        "Expected one of either opts.async or opts.errback, but got _both_.",
        OV
      );
    if (typeof e != "string") {
      let a;
      s && s.name && s.name !== "errback" && (a = s.name), i && i.name && i.name !== "async" && (a = i.name.replace(/Async$/, "")), r && r.name &&
      r.name !== "sync" && (a = r.name.replace(/Sync$/, "")), typeof a == "string" && (e = a);
    }
    return typeof t != "number" && (t = r.length), hA({
      name: e,
      arity: t,
      sync: /* @__PURE__ */ n(function(a) {
        return r.apply(this, a);
      }, "sync"),
      async: /* @__PURE__ */ n(function(a, o, u) {
        i ? i.apply(this, a).then(o, u) : s ? s.call(this, ...a, (l, c) => {
          l == null ? o(c) : u(l);
        }) : o(r.apply(this, a));
      }, "async")
    });
  }
  n(t$e, "newGenerator");
  function r$e(e) {
    return NV(e.name, e.length, function(...t) {
      return e.apply(this, t);
    });
  }
  n(r$e, "wrapGenerator");
  function hA({ name: e, arity: t, sync: r, async: i }) {
    return NV(e, t, function* (...s) {
      let a = yield FV;
      if (!a)
        return r.call(this, s);
      let o;
      try {
        i.call(
          this,
          s,
          (u) => {
            o || (o = { value: u }, a());
          },
          (u) => {
            o || (o = { err: u }, a());
          }
        );
      } catch (u) {
        o = { err: u }, a();
      }
      if (yield IV, o.hasOwnProperty("err"))
        throw o.err;
      return o.value;
    });
  }
  n(hA, "buildOperation");
  function mA(e) {
    let t;
    for (; !({ value: t } = e.next()).done; )
      kV(t, e);
    return t;
  }
  n(mA, "evaluateSync");
  function g1(e, t, r) {
    (/* @__PURE__ */ n(function i() {
      try {
        let s;
        for (; !({ value: s } = e.next()).done; ) {
          kV(s, e);
          let a = !0, o = !1, u = e.next(() => {
            a ? o = !0 : i();
          });
          if (a = !1, i$e(u, e), !o)
            return;
        }
        return t(s);
      } catch (s) {
        return r(s);
      }
    }, "step"))();
  }
  n(g1, "evaluateAsync");
  function kV(e, t) {
    e !== FV && BV(
      t,
      lu(
        `Got unexpected yielded value in gensync generator: ${JSON.stringify(
          e
        )}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,
        GUe
      )
    );
  }
  n(kV, "assertStart");
  function i$e({ value: e, done: t }, r) {
    !t && e === IV || BV(
      r,
      lu(
        t ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(
          e
        )}. If you get this, it is probably a gensync bug.`,
        ZUe
      )
    );
  }
  n(i$e, "assertSuspend");
  function BV(e, t) {
    throw e.throw && e.throw(t), t;
  }
  n(BV, "throwError");
  function NV(e, t, r) {
    if (typeof e == "string") {
      let i = Object.getOwnPropertyDescriptor(r, "name");
      (!i || i.configurable) && Object.defineProperty(
        r,
        "name",
        Object.assign(i || {}, {
          configurable: !0,
          value: e
        })
      );
    }
    if (typeof t == "number") {
      let i = Object.getOwnPropertyDescriptor(r, "length");
      (!i || i.configurable) && Object.defineProperty(
        r,
        "length",
        Object.assign(i || {}, {
          configurable: !0,
          value: t
        })
      );
    }
    return r;
  }
  n(NV, "setFunctionMetadata");
});

// ../node_modules/@babel/core/lib/gensync-utils/async.js
var Ka = E((Ss) => {
  "use strict";
  Object.defineProperty(Ss, "__esModule", {
    value: !0
  });
  Ss.forwardAsync = a$e;
  Ss.isAsync = void 0;
  Ss.isThenable = qV;
  Ss.maybeAsync = s$e;
  Ss.waitFor = Ss.onFirstPause = void 0;
  function Ha() {
    let e = _i();
    return Ha = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n(Ha, "_gensync");
  function RV(e, t, r, i, s, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      return void r(c);
    }
    u.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(RV, "asyncGeneratorStep");
  function jV(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var a = e.apply(t, r);
        function o(l) {
          RV(a, i, s, o, u, "next", l);
        }
        n(o, "_next");
        function u(l) {
          RV(a, i, s, o, u, "throw", l);
        }
        n(u, "_throw"), o(void 0);
      });
    };
  }
  n(jV, "_asyncToGenerator");
  var LV = Ha()(function* (e) {
    return yield* e;
  }), r2t = Ss.isAsync = Ha()({
    sync: /* @__PURE__ */ n(() => !1, "sync"),
    errback: /* @__PURE__ */ n((e) => e(null, !0), "errback")
  });
  function s$e(e, t) {
    return Ha()({
      sync(...r) {
        let i = e.apply(this, r);
        if (qV(i)) throw new Error(t);
        return i;
      },
      async(...r) {
        return Promise.resolve(e.apply(this, r));
      }
    });
  }
  n(s$e, "maybeAsync");
  var n$e = Ha()({
    sync: /* @__PURE__ */ n((e) => e("sync"), "sync"),
    async: function() {
      var e = jV(function* (t) {
        return t("async");
      });
      return /* @__PURE__ */ n(function(r) {
        return e.apply(this, arguments);
      }, "async");
    }()
  });
  function a$e(e, t) {
    let r = Ha()(e);
    return n$e((i) => {
      let s = r[i];
      return t(s);
    });
  }
  n(a$e, "forwardAsync");
  var i2t = Ss.onFirstPause = Ha()({
    name: "onFirstPause",
    arity: 2,
    sync: /* @__PURE__ */ n(function(e) {
      return LV.sync(e);
    }, "sync"),
    errback: /* @__PURE__ */ n(function(e, t, r) {
      let i = !1;
      LV.errback(e, (s, a) => {
        i = !0, r(s, a);
      }), i || t();
    }, "errback")
  }), s2t = Ss.waitFor = Ha()({
    sync: /* @__PURE__ */ n((e) => e, "sync"),
    async: function() {
      var e = jV(function* (t) {
        return t;
      });
      return /* @__PURE__ */ n(function(r) {
        return e.apply(this, arguments);
      }, "async");
    }()
  });
  function qV(e) {
    return !!e && (typeof e == "object" || typeof e == "function") && !!e.then && typeof e.then == "function";
  }
  n(qV, "isThenable");
});

// ../node_modules/@babel/core/lib/config/util.js
var D1 = E((b1) => {
  "use strict";
  Object.defineProperty(b1, "__esModule", {
    value: !0
  });
  b1.isIterableIterator = l$e;
  b1.mergeOptions = o$e;
  function o$e(e, t) {
    for (let r of Object.keys(t))
      if ((r === "parserOpts" || r === "generatorOpts" || r === "assumptions") && t[r]) {
        let i = t[r], s = e[r] || (e[r] = {});
        u$e(s, i);
      } else {
        let i = t[r];
        i !== void 0 && (e[r] = i);
      }
  }
  n(o$e, "mergeOptions");
  function u$e(e, t) {
    for (let r of Object.keys(t)) {
      let i = t[r];
      i !== void 0 && (e[r] = i);
    }
  }
  n(u$e, "mergeDefaultFields");
  function l$e(e) {
    return !!e && typeof e.next == "function" && typeof e[Symbol.iterator] == "function";
  }
  n(l$e, "isIterableIterator");
});

// ../node_modules/@babel/core/lib/config/caching.js
var fu = E((cu) => {
  "use strict";
  Object.defineProperty(cu, "__esModule", {
    value: !0
  });
  cu.assertSimpleType = v1;
  cu.makeStrongCache = HV;
  cu.makeStrongCacheSync = p$e;
  cu.makeWeakCache = WV;
  cu.makeWeakCacheSync = d$e;
  function $V() {
    let e = _i();
    return $V = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n($V, "_gensync");
  var lc = Ka(), c$e = D1(), VV = /* @__PURE__ */ n((e) => $V()(e).sync, "synchronize");
  function* f$e() {
    return !0;
  }
  n(f$e, "genTrue");
  function WV(e) {
    return KV(WeakMap, e);
  }
  n(WV, "makeWeakCache");
  function d$e(e) {
    return VV(WV(e));
  }
  n(d$e, "makeWeakCacheSync");
  function HV(e) {
    return KV(Map, e);
  }
  n(HV, "makeStrongCache");
  function p$e(e) {
    return VV(HV(e));
  }
  n(p$e, "makeStrongCacheSync");
  function KV(e, t) {
    let r = new e(), i = new e(), s = new e();
    return /* @__PURE__ */ n(function* (o, u) {
      let l = yield* (0, lc.isAsync)(), c = l ? i : r, f = yield* h$e(l, c, s, o, u);
      if (f.valid) return f.value;
      let m = new yA(u), h = t(o, m), d, y;
      return (0, c$e.isIterableIterator)(h) ? y = yield* (0, lc.onFirstPause)(h, () => {
        d = m$e(m, s, o);
      }) : y = h, zV(c, m, o, y), d && (s.delete(o), d.release(y)), y;
    }, "cachedFunction");
  }
  n(KV, "makeCachedFunction");
  function* UV(e, t, r) {
    let i = e.get(t);
    if (i) {
      for (let {
        value: s,
        valid: a
      } of i)
        if (yield* a(r)) return {
          valid: !0,
          value: s
        };
    }
    return {
      valid: !1,
      value: null
    };
  }
  n(UV, "getCachedValue");
  function* h$e(e, t, r, i, s) {
    let a = yield* UV(t, i, s);
    if (a.valid)
      return a;
    if (e) {
      let o = yield* UV(r, i, s);
      if (o.valid)
        return {
          valid: !0,
          value: yield* (0, lc.waitFor)(o.value.promise)
        };
    }
    return {
      valid: !1,
      value: null
    };
  }
  n(h$e, "getCachedValueOrWait");
  function m$e(e, t, r) {
    let i = new gA();
    return zV(t, e, r, i), i;
  }
  n(m$e, "setupAsyncLocks");
  function zV(e, t, r, i) {
    t.configured() || t.forever();
    let s = e.get(r);
    switch (t.deactivate(), t.mode()) {
      case "forever":
        s = [{
          value: i,
          valid: f$e
        }], e.set(r, s);
        break;
      case "invalidate":
        s = [{
          value: i,
          valid: t.validator()
        }], e.set(r, s);
        break;
      case "valid":
        s ? s.push({
          value: i,
          valid: t.validator()
        }) : (s = [{
          value: i,
          valid: t.validator()
        }], e.set(r, s));
    }
  }
  n(zV, "updateFunctionCache");
  var yA = class {
    static {
      n(this, "CacheConfigurator");
    }
    constructor(t) {
      this._active = !0, this._never = !1, this._forever = !1, this._invalidate = !1, this._configured = !1, this._pairs = [], this._data = void 0,
      this._data = t;
    }
    simple() {
      return y$e(this);
    }
    mode() {
      return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
    }
    forever() {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never)
        throw new Error("Caching has already been configured with .never()");
      this._forever = !0, this._configured = !0;
    }
    never() {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._forever)
        throw new Error("Caching has already been configured with .forever()");
      this._never = !0, this._configured = !0;
    }
    using(t) {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never || this._forever)
        throw new Error("Caching has already been configured with .never or .forever()");
      this._configured = !0;
      let r = t(this._data), i = (0, lc.maybeAsync)(t, "You appear to be using an async cache handler, but Babel has been called synchronous\
ly");
      return (0, lc.isThenable)(r) ? r.then((s) => (this._pairs.push([s, i]), s)) : (this._pairs.push([r, i]), r);
    }
    invalidate(t) {
      return this._invalidate = !0, this.using(t);
    }
    validator() {
      let t = this._pairs;
      return function* (r) {
        for (let [i, s] of t)
          if (i !== (yield* s(r))) return !1;
        return !0;
      };
    }
    deactivate() {
      this._active = !1;
    }
    configured() {
      return this._configured;
    }
  };
  function y$e(e) {
    function t(r) {
      if (typeof r == "boolean") {
        r ? e.forever() : e.never();
        return;
      }
      return e.using(() => v1(r()));
    }
    return n(t, "cacheFn"), t.forever = () => e.forever(), t.never = () => e.never(), t.using = (r) => e.using(() => v1(r())), t.invalidate =
    (r) => e.invalidate(() => v1(r())), t;
  }
  n(y$e, "makeSimpleConfigurator");
  function v1(e) {
    if ((0, lc.isThenable)(e))
      throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add suppo\
rt for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchron\
ously handle your caching logic.");
    if (e != null && typeof e != "string" && typeof e != "boolean" && typeof e != "number")
      throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    return e;
  }
  n(v1, "assertSimpleType");
  var gA = class {
    static {
      n(this, "Lock");
    }
    constructor() {
      this.released = !1, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((t) => {
        this._resolve = t;
      });
    }
    release(t) {
      this.released = !0, this._resolve(t);
    }
  };
});

// ../node_modules/@babel/core/lib/gensync-utils/fs.js
var x1 = E((cc) => {
  "use strict";
  Object.defineProperty(cc, "__esModule", {
    value: !0
  });
  cc.stat = cc.readFile = void 0;
  function vp() {
    let e = require("fs");
    return vp = /* @__PURE__ */ n(function() {
      return e;
    }, "_fs"), e;
  }
  n(vp, "_fs");
  function bA() {
    let e = _i();
    return bA = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n(bA, "_gensync");
  var f2t = cc.readFile = bA()({
    sync: vp().readFileSync,
    errback: vp().readFile
  }), d2t = cc.stat = bA()({
    sync: vp().statSync,
    errback: vp().stat
  });
});

// ../node_modules/@babel/core/lib/config/files/utils.js
var xA = E((vA) => {
  "use strict";
  Object.defineProperty(vA, "__esModule", {
    value: !0
  });
  vA.makeStaticFileCache = D$e;
  var g$e = fu(), b$e = x1();
  function DA() {
    let e = require("fs");
    return DA = /* @__PURE__ */ n(function() {
      return e;
    }, "_fs2"), e;
  }
  n(DA, "_fs2");
  function D$e(e) {
    return (0, g$e.makeStrongCache)(function* (t, r) {
      return r.invalidate(() => v$e(t)) === null ? null : e(t, yield* b$e.readFile(t, "utf8"));
    });
  }
  n(D$e, "makeStaticFileCache");
  function v$e(e) {
    if (!DA().existsSync(e)) return null;
    try {
      return +DA().statSync(e).mtime;
    } catch (t) {
      if (t.code !== "ENOENT" && t.code !== "ENOTDIR") throw t;
    }
    return null;
  }
  n(v$e, "fileMtime");
});

// ../node_modules/@babel/core/lib/errors/rewrite-stack-trace.js
var Kn = E((fc) => {
  "use strict";
  Object.defineProperty(fc, "__esModule", {
    value: !0
  });
  fc.beginHiddenCallStack = T$e;
  fc.endHiddenCallStack = C$e;
  fc.expectedError = S$e;
  fc.injectVirtualStackFrame = E$e;
  var JV, XV = Function.call.bind(Error.prototype.toString), S1 = !!Error.captureStackTrace && ((JV = Object.getOwnPropertyDescriptor(Error,
  "stackTraceLimit")) == null ? void 0 : JV.writable) === !0, YV = "startHiding - secret - don't use this - v1", GV = "stopHiding - secret -\
 don't use this - v1", ZV = /* @__PURE__ */ new WeakSet(), E1 = /* @__PURE__ */ new WeakMap();
  function x$e(e) {
    return /* @__PURE__ */ Object.create({
      isNative: /* @__PURE__ */ n(() => !1, "isNative"),
      isConstructor: /* @__PURE__ */ n(() => !1, "isConstructor"),
      isToplevel: /* @__PURE__ */ n(() => !0, "isToplevel"),
      getFileName: /* @__PURE__ */ n(() => e, "getFileName"),
      getLineNumber: /* @__PURE__ */ n(() => {
      }, "getLineNumber"),
      getColumnNumber: /* @__PURE__ */ n(() => {
      }, "getColumnNumber"),
      getFunctionName: /* @__PURE__ */ n(() => {
      }, "getFunctionName"),
      getMethodName: /* @__PURE__ */ n(() => {
      }, "getMethodName"),
      getTypeName: /* @__PURE__ */ n(() => {
      }, "getTypeName"),
      toString: /* @__PURE__ */ n(() => e, "toString")
    });
  }
  n(x$e, "CallSite");
  function E$e(e, t) {
    if (!S1) return;
    let r = E1.get(e);
    return r || E1.set(e, r = []), r.push(x$e(t)), e;
  }
  n(E$e, "injectVirtualStackFrame");
  function S$e(e) {
    if (S1)
      return ZV.add(e), e;
  }
  n(S$e, "expectedError");
  function T$e(e) {
    return S1 ? Object.defineProperty(function(...t) {
      return QV(), e(...t);
    }, "name", {
      value: GV
    }) : e;
  }
  n(T$e, "beginHiddenCallStack");
  function C$e(e) {
    return S1 ? Object.defineProperty(function(...t) {
      return e(...t);
    }, "name", {
      value: YV
    }) : e;
  }
  n(C$e, "endHiddenCallStack");
  function QV() {
    QV = /* @__PURE__ */ n(() => {
    }, "setupPrepareStackTrace");
    let {
      prepareStackTrace: e = w$e
    } = Error, t = 50;
    Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, t)), Error.prepareStackTrace = /* @__PURE__ */ n(function(i, s) {
      let a = [], u = ZV.has(i) ? "hiding" : "unknown";
      for (let l = 0; l < s.length; l++) {
        let c = s[l].getFunctionName();
        if (c === YV)
          u = "hiding";
        else if (c === GV) {
          if (u === "hiding")
            u = "showing", E1.has(i) && a.unshift(...E1.get(i));
          else if (u === "unknown") {
            a = s;
            break;
          }
        } else u !== "hiding" && a.push(s[l]);
      }
      return e(i, a);
    }, "stackTraceRewriter");
  }
  n(QV, "setupPrepareStackTrace");
  function w$e(e, t) {
    return t.length === 0 ? XV(e) : `${XV(e)}
    at ${t.join(`
    at `)}`;
  }
  n(w$e, "defaultPrepareStackTrace");
});

// ../node_modules/@babel/core/lib/errors/config-error.js
var du = E((T1) => {
  "use strict";
  Object.defineProperty(T1, "__esModule", {
    value: !0
  });
  T1.default = void 0;
  var eW = Kn(), EA = class extends Error {
    static {
      n(this, "ConfigError");
    }
    constructor(t, r) {
      super(t), (0, eW.expectedError)(this), r && (0, eW.injectVirtualStackFrame)(this, r);
    }
  };
  T1.default = EA;
});

// ../node_modules/@babel/core/lib/config/files/package.js
var tW = E((TA) => {
  "use strict";
  Object.defineProperty(TA, "__esModule", {
    value: !0
  });
  TA.findPackageData = F$e;
  function dc() {
    let e = require("path");
    return dc = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(dc, "_path");
  var A$e = xA(), SA = du(), _$e = "package.json", P$e = (0, A$e.makeStaticFileCache)((e, t) => {
    let r;
    try {
      r = JSON.parse(t);
    } catch (i) {
      throw new SA.default(`Error while parsing JSON - ${i.message}`, e);
    }
    if (!r) throw new Error(`${e}: No config detected`);
    if (typeof r != "object")
      throw new SA.default(`Config returned typeof ${typeof r}`, e);
    if (Array.isArray(r))
      throw new SA.default("Expected config object but found array", e);
    return {
      filepath: e,
      dirname: dc().dirname(e),
      options: r
    };
  });
  function* F$e(e) {
    let t = null, r = [], i = !0, s = dc().dirname(e);
    for (; !t && dc().basename(s) !== "node_modules"; ) {
      r.push(s), t = yield* P$e(dc().join(s, _$e));
      let a = dc().dirname(s);
      if (s === a) {
        i = !1;
        break;
      }
      s = a;
    }
    return {
      filepath: e,
      directories: r,
      pkg: t,
      isPackage: i
    };
  }
  n(F$e, "findPackageData");
});

// ../node_modules/json5/lib/unicode.js
var rW = E((S2t, C1) => {
  C1.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
  C1.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
  C1.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
});

// ../node_modules/json5/lib/util.js
var wA = E((T2t, iW) => {
  var CA = rW();
  iW.exports = {
    isSpaceSeparator(e) {
      return typeof e == "string" && CA.Space_Separator.test(e);
    },
    isIdStartChar(e) {
      return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e === "$" || e === "_" || CA.ID_Start.test(e));
    },
    isIdContinueChar(e) {
      return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e >= "0" && e <= "9" || e === "$" || e === "_" || e ===
      "\u200C" || e === "\u200D" || CA.ID_Continue.test(e));
    },
    isDigit(e) {
      return typeof e == "string" && /[0-9]/.test(e);
    },
    isHexDigit(e) {
      return typeof e == "string" && /[0-9A-Fa-f]/.test(e);
    }
  };
});

// ../node_modules/json5/lib/parse.js
var uW = E((C2t, oW) => {
  var vr = wA(), _A, ui, Jn, A1, za, Ts, xr, IA, Ep;
  oW.exports = /* @__PURE__ */ n(function(t, r) {
    _A = String(t), ui = "start", Jn = [], A1 = 0, za = 1, Ts = 0, xr = void 0, IA = void 0, Ep = void 0;
    do
      xr = I$e(), B$e[ui]();
    while (xr.type !== "eof");
    return typeof r == "function" ? PA({ "": Ep }, "", r) : Ep;
  }, "parse");
  function PA(e, t, r) {
    let i = e[t];
    if (i != null && typeof i == "object")
      if (Array.isArray(i))
        for (let s = 0; s < i.length; s++) {
          let a = String(s), o = PA(i, a, r);
          o === void 0 ? delete i[a] : Object.defineProperty(i, a, {
            value: o,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
      else
        for (let s in i) {
          let a = PA(i, s, r);
          a === void 0 ? delete i[s] : Object.defineProperty(i, s, {
            value: a,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
    return r.call(e, t, i);
  }
  n(PA, "internalize");
  var ze, Le, xp, zn, et;
  function I$e() {
    for (ze = "default", Le = "", xp = !1, zn = 1; ; ) {
      et = Xn();
      let e = nW[ze]();
      if (e)
        return e;
    }
  }
  n(I$e, "lex");
  function Xn() {
    if (_A[A1])
      return String.fromCodePoint(_A.codePointAt(A1));
  }
  n(Xn, "peek");
  function Z() {
    let e = Xn();
    return e === `
` ? (za++, Ts = 0) : e ? Ts += e.length : Ts++, e && (A1 += e.length), e;
  }
  n(Z, "read");
  var nW = {
    default() {
      switch (et) {
        case "	":
        case "\v":
        case "\f":
        case " ":
        case "\xA0":
        case "\uFEFF":
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          Z();
          return;
        case "/":
          Z(), ze = "comment";
          return;
        case void 0:
          return Z(), kt("eof");
      }
      if (vr.isSpaceSeparator(et)) {
        Z();
        return;
      }
      return nW[ui]();
    },
    comment() {
      switch (et) {
        case "*":
          Z(), ze = "multiLineComment";
          return;
        case "/":
          Z(), ze = "singleLineComment";
          return;
      }
      throw Bt(Z());
    },
    multiLineComment() {
      switch (et) {
        case "*":
          Z(), ze = "multiLineCommentAsterisk";
          return;
        case void 0:
          throw Bt(Z());
      }
      Z();
    },
    multiLineCommentAsterisk() {
      switch (et) {
        case "*":
          Z();
          return;
        case "/":
          Z(), ze = "default";
          return;
        case void 0:
          throw Bt(Z());
      }
      Z(), ze = "multiLineComment";
    },
    singleLineComment() {
      switch (et) {
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          Z(), ze = "default";
          return;
        case void 0:
          return Z(), kt("eof");
      }
      Z();
    },
    value() {
      switch (et) {
        case "{":
        case "[":
          return kt("punctuator", Z());
        case "n":
          return Z(), pu("ull"), kt("null", null);
        case "t":
          return Z(), pu("rue"), kt("boolean", !0);
        case "f":
          return Z(), pu("alse"), kt("boolean", !1);
        case "-":
        case "+":
          Z() === "-" && (zn = -1), ze = "sign";
          return;
        case ".":
          Le = Z(), ze = "decimalPointLeading";
          return;
        case "0":
          Le = Z(), ze = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          Le = Z(), ze = "decimalInteger";
          return;
        case "I":
          return Z(), pu("nfinity"), kt("numeric", 1 / 0);
        case "N":
          return Z(), pu("aN"), kt("numeric", NaN);
        case '"':
        case "'":
          xp = Z() === '"', Le = "", ze = "string";
          return;
      }
      throw Bt(Z());
    },
    identifierNameStartEscape() {
      if (et !== "u")
        throw Bt(Z());
      Z();
      let e = FA();
      switch (e) {
        case "$":
        case "_":
          break;
        default:
          if (!vr.isIdStartChar(e))
            throw sW();
          break;
      }
      Le += e, ze = "identifierName";
    },
    identifierName() {
      switch (et) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          Le += Z();
          return;
        case "\\":
          Z(), ze = "identifierNameEscape";
          return;
      }
      if (vr.isIdContinueChar(et)) {
        Le += Z();
        return;
      }
      return kt("identifier", Le);
    },
    identifierNameEscape() {
      if (et !== "u")
        throw Bt(Z());
      Z();
      let e = FA();
      switch (e) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          break;
        default:
          if (!vr.isIdContinueChar(e))
            throw sW();
          break;
      }
      Le += e, ze = "identifierName";
    },
    sign() {
      switch (et) {
        case ".":
          Le = Z(), ze = "decimalPointLeading";
          return;
        case "0":
          Le = Z(), ze = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          Le = Z(), ze = "decimalInteger";
          return;
        case "I":
          return Z(), pu("nfinity"), kt("numeric", zn * (1 / 0));
        case "N":
          return Z(), pu("aN"), kt("numeric", NaN);
      }
      throw Bt(Z());
    },
    zero() {
      switch (et) {
        case ".":
          Le += Z(), ze = "decimalPoint";
          return;
        case "e":
        case "E":
          Le += Z(), ze = "decimalExponent";
          return;
        case "x":
        case "X":
          Le += Z(), ze = "hexadecimal";
          return;
      }
      return kt("numeric", zn * 0);
    },
    decimalInteger() {
      switch (et) {
        case ".":
          Le += Z(), ze = "decimalPoint";
          return;
        case "e":
        case "E":
          Le += Z(), ze = "decimalExponent";
          return;
      }
      if (vr.isDigit(et)) {
        Le += Z();
        return;
      }
      return kt("numeric", zn * Number(Le));
    },
    decimalPointLeading() {
      if (vr.isDigit(et)) {
        Le += Z(), ze = "decimalFraction";
        return;
      }
      throw Bt(Z());
    },
    decimalPoint() {
      switch (et) {
        case "e":
        case "E":
          Le += Z(), ze = "decimalExponent";
          return;
      }
      if (vr.isDigit(et)) {
        Le += Z(), ze = "decimalFraction";
        return;
      }
      return kt("numeric", zn * Number(Le));
    },
    decimalFraction() {
      switch (et) {
        case "e":
        case "E":
          Le += Z(), ze = "decimalExponent";
          return;
      }
      if (vr.isDigit(et)) {
        Le += Z();
        return;
      }
      return kt("numeric", zn * Number(Le));
    },
    decimalExponent() {
      switch (et) {
        case "+":
        case "-":
          Le += Z(), ze = "decimalExponentSign";
          return;
      }
      if (vr.isDigit(et)) {
        Le += Z(), ze = "decimalExponentInteger";
        return;
      }
      throw Bt(Z());
    },
    decimalExponentSign() {
      if (vr.isDigit(et)) {
        Le += Z(), ze = "decimalExponentInteger";
        return;
      }
      throw Bt(Z());
    },
    decimalExponentInteger() {
      if (vr.isDigit(et)) {
        Le += Z();
        return;
      }
      return kt("numeric", zn * Number(Le));
    },
    hexadecimal() {
      if (vr.isHexDigit(et)) {
        Le += Z(), ze = "hexadecimalInteger";
        return;
      }
      throw Bt(Z());
    },
    hexadecimalInteger() {
      if (vr.isHexDigit(et)) {
        Le += Z();
        return;
      }
      return kt("numeric", zn * Number(Le));
    },
    string() {
      switch (et) {
        case "\\":
          Z(), Le += O$e();
          return;
        case '"':
          if (xp)
            return Z(), kt("string", Le);
          Le += Z();
          return;
        case "'":
          if (!xp)
            return Z(), kt("string", Le);
          Le += Z();
          return;
        case `
`:
        case "\r":
          throw Bt(Z());
        case "\u2028":
        case "\u2029":
          N$e(et);
          break;
        case void 0:
          throw Bt(Z());
      }
      Le += Z();
    },
    start() {
      switch (et) {
        case "{":
        case "[":
          return kt("punctuator", Z());
      }
      ze = "value";
    },
    beforePropertyName() {
      switch (et) {
        case "$":
        case "_":
          Le = Z(), ze = "identifierName";
          return;
        case "\\":
          Z(), ze = "identifierNameStartEscape";
          return;
        case "}":
          return kt("punctuator", Z());
        case '"':
        case "'":
          xp = Z() === '"', ze = "string";
          return;
      }
      if (vr.isIdStartChar(et)) {
        Le += Z(), ze = "identifierName";
        return;
      }
      throw Bt(Z());
    },
    afterPropertyName() {
      if (et === ":")
        return kt("punctuator", Z());
      throw Bt(Z());
    },
    beforePropertyValue() {
      ze = "value";
    },
    afterPropertyValue() {
      switch (et) {
        case ",":
        case "}":
          return kt("punctuator", Z());
      }
      throw Bt(Z());
    },
    beforeArrayValue() {
      if (et === "]")
        return kt("punctuator", Z());
      ze = "value";
    },
    afterArrayValue() {
      switch (et) {
        case ",":
        case "]":
          return kt("punctuator", Z());
      }
      throw Bt(Z());
    },
    end() {
      throw Bt(Z());
    }
  };
  function kt(e, t) {
    return {
      type: e,
      value: t,
      line: za,
      column: Ts
    };
  }
  n(kt, "newToken");
  function pu(e) {
    for (let t of e) {
      if (Xn() !== t)
        throw Bt(Z());
      Z();
    }
  }
  n(pu, "literal");
  function O$e() {
    switch (Xn()) {
      case "b":
        return Z(), "\b";
      case "f":
        return Z(), "\f";
      case "n":
        return Z(), `
`;
      case "r":
        return Z(), "\r";
      case "t":
        return Z(), "	";
      case "v":
        return Z(), "\v";
      case "0":
        if (Z(), vr.isDigit(Xn()))
          throw Bt(Z());
        return "\0";
      case "x":
        return Z(), k$e();
      case "u":
        return Z(), FA();
      case `
`:
      case "\u2028":
      case "\u2029":
        return Z(), "";
      case "\r":
        return Z(), Xn() === `
` && Z(), "";
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        throw Bt(Z());
      case void 0:
        throw Bt(Z());
    }
    return Z();
  }
  n(O$e, "escape");
  function k$e() {
    let e = "", t = Xn();
    if (!vr.isHexDigit(t) || (e += Z(), t = Xn(), !vr.isHexDigit(t)))
      throw Bt(Z());
    return e += Z(), String.fromCodePoint(parseInt(e, 16));
  }
  n(k$e, "hexEscape");
  function FA() {
    let e = "", t = 4;
    for (; t-- > 0; ) {
      let r = Xn();
      if (!vr.isHexDigit(r))
        throw Bt(Z());
      e += Z();
    }
    return String.fromCodePoint(parseInt(e, 16));
  }
  n(FA, "unicodeEscape");
  var B$e = {
    start() {
      if (xr.type === "eof")
        throw hu();
      AA();
    },
    beforePropertyName() {
      switch (xr.type) {
        case "identifier":
        case "string":
          IA = xr.value, ui = "afterPropertyName";
          return;
        case "punctuator":
          w1();
          return;
        case "eof":
          throw hu();
      }
    },
    afterPropertyName() {
      if (xr.type === "eof")
        throw hu();
      ui = "beforePropertyValue";
    },
    beforePropertyValue() {
      if (xr.type === "eof")
        throw hu();
      AA();
    },
    beforeArrayValue() {
      if (xr.type === "eof")
        throw hu();
      if (xr.type === "punctuator" && xr.value === "]") {
        w1();
        return;
      }
      AA();
    },
    afterPropertyValue() {
      if (xr.type === "eof")
        throw hu();
      switch (xr.value) {
        case ",":
          ui = "beforePropertyName";
          return;
        case "}":
          w1();
      }
    },
    afterArrayValue() {
      if (xr.type === "eof")
        throw hu();
      switch (xr.value) {
        case ",":
          ui = "beforeArrayValue";
          return;
        case "]":
          w1();
      }
    },
    end() {
    }
  };
  function AA() {
    let e;
    switch (xr.type) {
      case "punctuator":
        switch (xr.value) {
          case "{":
            e = {};
            break;
          case "[":
            e = [];
            break;
        }
        break;
      case "null":
      case "boolean":
      case "numeric":
      case "string":
        e = xr.value;
        break;
    }
    if (Ep === void 0)
      Ep = e;
    else {
      let t = Jn[Jn.length - 1];
      Array.isArray(t) ? t.push(e) : Object.defineProperty(t, IA, {
        value: e,
        writable: !0,
        enumerable: !0,
        configurable: !0
      });
    }
    if (e !== null && typeof e == "object")
      Jn.push(e), Array.isArray(e) ? ui = "beforeArrayValue" : ui = "beforePropertyName";
    else {
      let t = Jn[Jn.length - 1];
      t == null ? ui = "end" : Array.isArray(t) ? ui = "afterArrayValue" : ui = "afterPropertyValue";
    }
  }
  n(AA, "push");
  function w1() {
    Jn.pop();
    let e = Jn[Jn.length - 1];
    e == null ? ui = "end" : Array.isArray(e) ? ui = "afterArrayValue" : ui = "afterPropertyValue";
  }
  n(w1, "pop");
  function Bt(e) {
    return _1(e === void 0 ? `JSON5: invalid end of input at ${za}:${Ts}` : `JSON5: invalid character '${aW(e)}' at ${za}:${Ts}`);
  }
  n(Bt, "invalidChar");
  function hu() {
    return _1(`JSON5: invalid end of input at ${za}:${Ts}`);
  }
  n(hu, "invalidEOF");
  function sW() {
    return Ts -= 5, _1(`JSON5: invalid identifier character at ${za}:${Ts}`);
  }
  n(sW, "invalidIdentifier");
  function N$e(e) {
    console.warn(`JSON5: '${aW(e)}' in strings is not valid ECMAScript; consider escaping`);
  }
  n(N$e, "separatorChar");
  function aW(e) {
    let t = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    if (t[e])
      return t[e];
    if (e < " ") {
      let r = e.charCodeAt(0).toString(16);
      return "\\x" + ("00" + r).substring(r.length);
    }
    return e;
  }
  n(aW, "formatChar");
  function _1(e) {
    let t = new SyntaxError(e);
    return t.lineNumber = za, t.columnNumber = Ts, t;
  }
  n(_1, "syntaxError");
});

// ../node_modules/json5/lib/stringify.js
var cW = E((A2t, lW) => {
  var OA = wA();
  lW.exports = /* @__PURE__ */ n(function(t, r, i) {
    let s = [], a = "", o, u, l = "", c;
    if (r != null && typeof r == "object" && !Array.isArray(r) && (i = r.space, c = r.quote, r = r.replacer), typeof r == "function")
      u = r;
    else if (Array.isArray(r)) {
      o = [];
      for (let p of r) {
        let g;
        typeof p == "string" ? g = p : (typeof p == "number" || p instanceof String || p instanceof Number) && (g = String(p)), g !== void 0 &&
        o.indexOf(g) < 0 && o.push(g);
      }
    }
    return i instanceof Number ? i = Number(i) : i instanceof String && (i = String(i)), typeof i == "number" ? i > 0 && (i = Math.min(10, Math.
    floor(i)), l = "          ".substr(0, i)) : typeof i == "string" && (l = i.substr(0, 10)), f("", { "": t });
    function f(p, g) {
      let b = g[p];
      switch (b != null && (typeof b.toJSON5 == "function" ? b = b.toJSON5(p) : typeof b.toJSON == "function" && (b = b.toJSON(p))), u && (b =
      u.call(g, p, b)), b instanceof Number ? b = Number(b) : b instanceof String ? b = String(b) : b instanceof Boolean && (b = b.valueOf()),
      b) {
        case null:
          return "null";
        case !0:
          return "true";
        case !1:
          return "false";
      }
      if (typeof b == "string")
        return m(b, !1);
      if (typeof b == "number")
        return String(b);
      if (typeof b == "object")
        return Array.isArray(b) ? y(b) : h(b);
    }
    n(f, "serializeProperty");
    function m(p) {
      let g = {
        "'": 0.1,
        '"': 0.2
      }, b = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      }, D = "";
      for (let T = 0; T < p.length; T++) {
        let w = p[T];
        switch (w) {
          case "'":
          case '"':
            g[w]++, D += w;
            continue;
          case "\0":
            if (OA.isDigit(p[T + 1])) {
              D += "\\x00";
              continue;
            }
        }
        if (b[w]) {
          D += b[w];
          continue;
        }
        if (w < " ") {
          let B = w.charCodeAt(0).toString(16);
          D += "\\x" + ("00" + B).substring(B.length);
          continue;
        }
        D += w;
      }
      let x = c || Object.keys(g).reduce((T, w) => g[T] < g[w] ? T : w);
      return D = D.replace(new RegExp(x, "g"), b[x]), x + D + x;
    }
    n(m, "quoteString");
    function h(p) {
      if (s.indexOf(p) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      s.push(p);
      let g = a;
      a = a + l;
      let b = o || Object.keys(p), D = [];
      for (let T of b) {
        let w = f(T, p);
        if (w !== void 0) {
          let B = d(T) + ":";
          l !== "" && (B += " "), B += w, D.push(B);
        }
      }
      let x;
      if (D.length === 0)
        x = "{}";
      else {
        let T;
        if (l === "")
          T = D.join(","), x = "{" + T + "}";
        else {
          let w = `,
` + a;
          T = D.join(w), x = `{
` + a + T + `,
` + g + "}";
        }
      }
      return s.pop(), a = g, x;
    }
    n(h, "serializeObject");
    function d(p) {
      if (p.length === 0)
        return m(p, !0);
      let g = String.fromCodePoint(p.codePointAt(0));
      if (!OA.isIdStartChar(g))
        return m(p, !0);
      for (let b = g.length; b < p.length; b++)
        if (!OA.isIdContinueChar(String.fromCodePoint(p.codePointAt(b))))
          return m(p, !0);
      return p;
    }
    n(d, "serializeKey");
    function y(p) {
      if (s.indexOf(p) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      s.push(p);
      let g = a;
      a = a + l;
      let b = [];
      for (let x = 0; x < p.length; x++) {
        let T = f(String(x), p);
        b.push(T !== void 0 ? T : "null");
      }
      let D;
      if (b.length === 0)
        D = "[]";
      else if (l === "")
        D = "[" + b.join(",") + "]";
      else {
        let x = `,
` + a, T = b.join(x);
        D = `[
` + a + T + `,
` + g + "]";
      }
      return s.pop(), a = g, D;
    }
    n(y, "serializeArray");
  }, "stringify");
});

// ../node_modules/json5/lib/index.js
var dW = E((P2t, fW) => {
  var M$e = uW(), R$e = cW(), L$e = {
    parse: M$e,
    stringify: R$e
  };
  fW.exports = L$e;
});

// ../node_modules/@babel/core/lib/config/helpers/config-api.js
var kA = E((Sp) => {
  "use strict";
  Object.defineProperty(Sp, "__esModule", {
    value: !0
  });
  Sp.makeConfigAPI = mW;
  Sp.makePluginAPI = j$e;
  Sp.makePresetAPI = yW;
  function hW() {
    let e = require("semver");
    return hW = /* @__PURE__ */ n(function() {
      return e;
    }, "_semver"), e;
  }
  n(hW, "_semver");
  var P1 = Gt(), pW = fu();
  function mW(e) {
    let t = /* @__PURE__ */ n((i) => e.using((s) => i === void 0 ? s.envName : typeof i == "function" ? (0, pW.assertSimpleType)(i(s.envName)) :
    (Array.isArray(i) ? i : [i]).some((a) => {
      if (typeof a != "string")
        throw new Error("Unexpected non-string value");
      return a === s.envName;
    })), "env"), r = /* @__PURE__ */ n((i) => e.using((s) => (0, pW.assertSimpleType)(i(s.caller))), "caller");
    return {
      version: P1.version,
      cache: e.simple(),
      env: t,
      async: /* @__PURE__ */ n(() => !1, "async"),
      caller: r,
      assertVersion: q$e
    };
  }
  n(mW, "makeConfigAPI");
  function yW(e, t) {
    let r = /* @__PURE__ */ n(() => JSON.parse(e.using((s) => JSON.stringify(s.targets))), "targets"), i = /* @__PURE__ */ n((s) => {
      t.push(s);
    }, "addExternalDependency");
    return Object.assign({}, mW(e), {
      targets: r,
      addExternalDependency: i
    });
  }
  n(yW, "makePresetAPI");
  function j$e(e, t) {
    let r = /* @__PURE__ */ n((i) => e.using((s) => s.assumptions[i]), "assumption");
    return Object.assign({}, yW(e, t), {
      assumption: r
    });
  }
  n(j$e, "makePluginAPI");
  function q$e(e) {
    if (typeof e == "number") {
      if (!Number.isInteger(e))
        throw new Error("Expected string or integer value.");
      e = `^${e}.0.0-0`;
    }
    if (typeof e != "string")
      throw new Error("Expected string or integer value.");
    if (e === "*" || hW().satisfies(P1.version, e)) return;
    let t = Error.stackTraceLimit;
    typeof t == "number" && t < 25 && (Error.stackTraceLimit = 25);
    let r = new Error(`Requires Babel "${e}", but was loaded with "${P1.version}". If you are sure you have a compatible version of @babel/c\
ore, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the f\
irst entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
    throw typeof t == "number" && (Error.stackTraceLimit = t), Object.assign(r, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: P1.version,
      range: e
    });
  }
  n(q$e, "assertVersion");
});

// ../node_modules/@babel/core/lib/config/helpers/deep-array.js
var I1 = E((F1) => {
  "use strict";
  Object.defineProperty(F1, "__esModule", {
    value: !0
  });
  F1.finalize = U$e;
  F1.flattenToSet = $$e;
  function U$e(e) {
    return Object.freeze(e);
  }
  n(U$e, "finalize");
  function $$e(e) {
    let t = /* @__PURE__ */ new Set(), r = [e];
    for (; r.length > 0; )
      for (let i of r.pop())
        Array.isArray(i) ? r.push(i) : t.add(i);
    return t;
  }
  n($$e, "flattenToSet");
});

// ../node_modules/@babel/core/lib/config/plugin.js
var k1 = E((O1) => {
  "use strict";
  Object.defineProperty(O1, "__esModule", {
    value: !0
  });
  O1.default = void 0;
  var V$e = I1(), BA = class {
    static {
      n(this, "Plugin");
    }
    constructor(t, r, i, s = (0, V$e.finalize)([])) {
      this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride =
      void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = t.name || i, this.manipulateOptions =
      t.manipulateOptions, this.post = t.post, this.pre = t.pre, this.visitor = t.visitor || {}, this.parserOverride = t.parserOverride, this.
      generatorOverride = t.generatorOverride, this.options = r, this.externalDependencies = s;
    }
  };
  O1.default = BA;
});

// ../node_modules/@babel/core/lib/gensync-utils/functional.js
var bW = E((NA) => {
  "use strict";
  Object.defineProperty(NA, "__esModule", {
    value: !0
  });
  NA.once = W$e;
  var gW = Ka();
  function W$e(e) {
    let t, r, i = !1;
    return function* () {
      if (!t) {
        if (r)
          return i = !0, yield* (0, gW.waitFor)(r);
        if (yield* (0, gW.isAsync)()) {
          let s, a;
          r = new Promise((o, u) => {
            s = o, a = u;
          });
          try {
            t = {
              ok: !0,
              value: yield* e()
            }, r = null, i && s(t.value);
          } catch (o) {
            t = {
              ok: !1,
              value: o
            }, r = null, i && a(o);
          }
        } else
          try {
            t = {
              ok: !0,
              value: yield* e()
            };
          } catch (s) {
            t = {
              ok: !1,
              value: s
            };
          }
      }
      if (t.ok) return t.value;
      throw t.value;
    };
  }
  n(W$e, "once");
});

// ../node_modules/baseline-browser-mapping/dist/index.cjs
var _W = E((MA) => {
  "use strict";
  var H$e = { chrome: { releases: [["1", "2008-12-11", "r", "w", "528"], ["2", "2009-05-21", "r", "w", "530"], ["3", "2009-09-15", "r", "w",
  "532"], ["4", "2010-01-25", "r", "w", "532.5"], ["5", "2010-05-25", "r", "w", "533"], ["6", "2010-09-02", "r", "w", "534.3"], ["7", "2010-\
10-19", "r", "w", "534.7"], ["8", "2010-12-02", "r", "w", "534.10"], ["9", "2011-02-03", "r", "w", "534.13"], ["10", "2011-03-08", "r", "w",
  "534.16"], ["11", "2011-04-27", "r", "w", "534.24"], ["12", "2011-06-07", "r", "w", "534.30"], ["13", "2011-08-02", "r", "w", "535.1"], ["\
14", "2011-09-16", "r", "w", "535.1"], ["15", "2011-10-25", "r", "w", "535.2"], ["16", "2011-12-13", "r", "w", "535.7"], ["17", "2012-02-08",
  "r", "w", "535.11"], ["18", "2012-03-28", "r", "w", "535.19"], ["19", "2012-05-15", "r", "w", "536.5"], ["20", "2012-06-26", "r", "w", "53\
6.10"], ["21", "2012-07-31", "r", "w", "537.1"], ["22", "2012-09-25", "r", "w", "537.4"], ["23", "2012-11-06", "r", "w", "537.11"], ["24", "\
2013-01-10", "r", "w", "537.17"], ["25", "2013-02-21", "r", "w", "537.22"], ["26", "2013-03-26", "r", "w", "537.31"], ["27", "2013-05-21", "\
r", "w", "537.36"], ["28", "2013-07-09", "r", "b", "28"], ["29", "2013-08-20", "r", "b", "29"], ["30", "2013-10-01", "r", "b", "30"], ["31",
  "2013-11-12", "r", "b", "31"], ["32", "2014-01-14", "r", "b", "32"], ["33", "2014-02-20", "r", "b", "33"], ["34", "2014-04-08", "r", "b", "\
34"], ["35", "2014-05-20", "r", "b", "35"], ["36", "2014-07-16", "r", "b", "36"], ["37", "2014-08-26", "r", "b", "37"], ["38", "2014-10-07",
  "r", "b", "38"], ["39", "2014-11-18", "r", "b", "39"], ["40", "2015-01-21", "r", "b", "40"], ["41", "2015-03-03", "r", "b", "41"], ["42", "\
2015-04-14", "r", "b", "42"], ["43", "2015-05-19", "r", "b", "43"], ["44", "2015-07-21", "r", "b", "44"], ["45", "2015-09-01", "r", "b", "45"],
  ["46", "2015-10-13", "r", "b", "46"], ["47", "2015-12-01", "r", "b", "47"], ["48", "2016-01-20", "r", "b", "48"], ["49", "2016-03-02", "r",
  "b", "49"], ["50", "2016-04-13", "r", "b", "50"], ["51", "2016-05-25", "r", "b", "51"], ["52", "2016-07-20", "r", "b", "52"], ["53", "2016\
-08-31", "r", "b", "53"], ["54", "2016-10-12", "r", "b", "54"], ["55", "2016-12-01", "r", "b", "55"], ["56", "2017-01-25", "r", "b", "56"], [
  "57", "2017-03-09", "r", "b", "57"], ["58", "2017-04-19", "r", "b", "58"], ["59", "2017-06-05", "r", "b", "59"], ["60", "2017-07-25", "r",
  "b", "60"], ["61", "2017-09-05", "r", "b", "61"], ["62", "2017-10-17", "r", "b", "62"], ["63", "2017-12-06", "r", "b", "63"], ["64", "2018\
-01-23", "r", "b", "64"], ["65", "2018-03-06", "r", "b", "65"], ["66", "2018-04-17", "r", "b", "66"], ["67", "2018-05-29", "r", "b", "67"], [
  "68", "2018-07-24", "r", "b", "68"], ["69", "2018-09-04", "r", "b", "69"], ["70", "2018-10-16", "r", "b", "70"], ["71", "2018-12-04", "r",
  "b", "71"], ["72", "2019-01-29", "r", "b", "72"], ["73", "2019-03-12", "r", "b", "73"], ["74", "2019-04-23", "r", "b", "74"], ["75", "2019\
-06-04", "r", "b", "75"], ["76", "2019-07-30", "r", "b", "76"], ["77", "2019-09-10", "r", "b", "77"], ["78", "2019-10-22", "r", "b", "78"], [
  "79", "2019-12-10", "r", "b", "79"], ["80", "2020-02-04", "r", "b", "80"], ["81", "2020-04-07", "r", "b", "81"], ["83", "2020-05-19", "r",
  "b", "83"], ["84", "2020-07-27", "r", "b", "84"], ["85", "2020-08-25", "r", "b", "85"], ["86", "2020-10-20", "r", "b", "86"], ["87", "2020\
-11-17", "r", "b", "87"], ["88", "2021-01-19", "r", "b", "88"], ["89", "2021-03-02", "r", "b", "89"], ["90", "2021-04-13", "r", "b", "90"], [
  "91", "2021-05-25", "r", "b", "91"], ["92", "2021-07-20", "r", "b", "92"], ["93", "2021-08-31", "r", "b", "93"], ["94", "2021-09-21", "r",
  "b", "94"], ["95", "2021-10-19", "r", "b", "95"], ["96", "2021-11-15", "r", "b", "96"], ["97", "2022-01-04", "r", "b", "97"], ["98", "2022\
-02-01", "r", "b", "98"], ["99", "2022-03-01", "r", "b", "99"], ["100", "2022-03-29", "r", "b", "100"], ["101", "2022-04-26", "r", "b", "101"],
  ["102", "2022-05-24", "r", "b", "102"], ["103", "2022-06-21", "r", "b", "103"], ["104", "2022-08-02", "r", "b", "104"], ["105", "2022-09-0\
2", "r", "b", "105"], ["106", "2022-09-27", "r", "b", "106"], ["107", "2022-10-25", "r", "b", "107"], ["108", "2022-11-29", "r", "b", "108"],
  ["109", "2023-01-10", "r", "b", "109"], ["110", "2023-02-07", "r", "b", "110"], ["111", "2023-03-07", "r", "b", "111"], ["112", "2023-04-0\
4", "r", "b", "112"], ["113", "2023-05-02", "r", "b", "113"], ["114", "2023-05-30", "r", "b", "114"], ["115", "2023-07-18", "r", "b", "115"],
  ["116", "2023-08-15", "r", "b", "116"], ["117", "2023-09-12", "r", "b", "117"], ["118", "2023-10-10", "r", "b", "118"], ["119", "2023-10-3\
1", "r", "b", "119"], ["120", "2023-12-05", "r", "b", "120"], ["121", "2024-01-23", "r", "b", "121"], ["122", "2024-02-20", "r", "b", "122"],
  ["123", "2024-03-19", "r", "b", "123"], ["124", "2024-04-16", "r", "b", "124"], ["125", "2024-05-14", "r", "b", "125"], ["126", "2024-06-1\
1", "r", "b", "126"], ["127", "2024-07-23", "r", "b", "127"], ["128", "2024-08-20", "r", "b", "128"], ["129", "2024-09-17", "r", "b", "129"],
  ["130", "2024-10-15", "r", "b", "130"], ["131", "2024-11-12", "r", "b", "131"], ["132", "2025-01-14", "r", "b", "132"], ["133", "2025-02-0\
4", "r", "b", "133"], ["134", "2025-03-04", "r", "b", "134"], ["135", "2025-04-01", "r", "b", "135"], ["136", "2025-04-29", "r", "b", "136"],
  ["137", "2025-05-27", "r", "b", "137"], ["138", "2025-06-24", "r", "b", "138"], ["139", "2025-08-05", "r", "b", "139"], ["140", "2025-09-0\
2", "c", "b", "140"], ["141", "2025-09-30", "b", "b", "141"], ["142", "2025-10-28", "n", "b", "142"], ["143", null, "p", "b", "143"]] }, chrome_android: {
  releases: [["18", "2012-06-27", "r", "w", "535.19"], ["25", "2013-02-27", "r", "w", "537.22"], ["26", "2013-04-03", "r", "w", "537.31"], [
  "27", "2013-05-22", "r", "w", "537.36"], ["28", "2013-07-10", "r", "b", "28"], ["29", "2013-08-21", "r", "b", "29"], ["30", "2013-10-02", "\
r", "b", "30"], ["31", "2013-11-14", "r", "b", "31"], ["32", "2014-01-15", "r", "b", "32"], ["33", "2014-02-26", "r", "b", "33"], ["34", "20\
14-04-02", "r", "b", "34"], ["35", "2014-05-20", "r", "b", "35"], ["36", "2014-07-16", "r", "b", "36"], ["37", "2014-09-03", "r", "b", "37"],
  ["38", "2014-10-08", "r", "b", "38"], ["39", "2014-11-12", "r", "b", "39"], ["40", "2015-01-21", "r", "b", "40"], ["41", "2015-03-11", "r",
  "b", "41"], ["42", "2015-04-15", "r", "b", "42"], ["43", "2015-05-27", "r", "b", "43"], ["44", "2015-07-29", "r", "b", "44"], ["45", "2015\
-09-01", "r", "b", "45"], ["46", "2015-10-14", "r", "b", "46"], ["47", "2015-12-02", "r", "b", "47"], ["48", "2016-01-26", "r", "b", "48"], [
  "49", "2016-03-09", "r", "b", "49"], ["50", "2016-04-13", "r", "b", "50"], ["51", "2016-06-08", "r", "b", "51"], ["52", "2016-07-27", "r",
  "b", "52"], ["53", "2016-09-07", "r", "b", "53"], ["54", "2016-10-19", "r", "b", "54"], ["55", "2016-12-06", "r", "b", "55"], ["56", "2017\
-02-01", "r", "b", "56"], ["57", "2017-03-16", "r", "b", "57"], ["58", "2017-04-25", "r", "b", "58"], ["59", "2017-06-06", "r", "b", "59"], [
  "60", "2017-08-01", "r", "b", "60"], ["61", "2017-09-05", "r", "b", "61"], ["62", "2017-10-24", "r", "b", "62"], ["63", "2017-12-05", "r",
  "b", "63"], ["64", "2018-01-23", "r", "b", "64"], ["65", "2018-03-06", "r", "b", "65"], ["66", "2018-04-17", "r", "b", "66"], ["67", "2018\
-05-31", "r", "b", "67"], ["68", "2018-07-24", "r", "b", "68"], ["69", "2018-09-04", "r", "b", "69"], ["70", "2018-10-17", "r", "b", "70"], [
  "71", "2018-12-04", "r", "b", "71"], ["72", "2019-01-29", "r", "b", "72"], ["73", "2019-03-12", "r", "b", "73"], ["74", "2019-04-24", "r",
  "b", "74"], ["75", "2019-06-04", "r", "b", "75"], ["76", "2019-07-30", "r", "b", "76"], ["77", "2019-09-10", "r", "b", "77"], ["78", "2019\
-10-22", "r", "b", "78"], ["79", "2019-12-17", "r", "b", "79"], ["80", "2020-02-04", "r", "b", "80"], ["81", "2020-04-07", "r", "b", "81"], [
  "83", "2020-05-19", "r", "b", "83"], ["84", "2020-07-27", "r", "b", "84"], ["85", "2020-08-25", "r", "b", "85"], ["86", "2020-10-20", "r",
  "b", "86"], ["87", "2020-11-17", "r", "b", "87"], ["88", "2021-01-19", "r", "b", "88"], ["89", "2021-03-02", "r", "b", "89"], ["90", "2021\
-04-13", "r", "b", "90"], ["91", "2021-05-25", "r", "b", "91"], ["92", "2021-07-20", "r", "b", "92"], ["93", "2021-08-31", "r", "b", "93"], [
  "94", "2021-09-21", "r", "b", "94"], ["95", "2021-10-19", "r", "b", "95"], ["96", "2021-11-15", "r", "b", "96"], ["97", "2022-01-04", "r",
  "b", "97"], ["98", "2022-02-01", "r", "b", "98"], ["99", "2022-03-01", "r", "b", "99"], ["100", "2022-03-29", "r", "b", "100"], ["101", "2\
022-04-26", "r", "b", "101"], ["102", "2022-05-24", "r", "b", "102"], ["103", "2022-06-21", "r", "b", "103"], ["104", "2022-08-02", "r", "b",
  "104"], ["105", "2022-09-02", "r", "b", "105"], ["106", "2022-09-27", "r", "b", "106"], ["107", "2022-10-25", "r", "b", "107"], ["108", "2\
022-11-29", "r", "b", "108"], ["109", "2023-01-10", "r", "b", "109"], ["110", "2023-02-07", "r", "b", "110"], ["111", "2023-03-07", "r", "b",
  "111"], ["112", "2023-04-04", "r", "b", "112"], ["113", "2023-05-02", "r", "b", "113"], ["114", "2023-05-30", "r", "b", "114"], ["115", "2\
023-07-21", "r", "b", "115"], ["116", "2023-08-15", "r", "b", "116"], ["117", "2023-09-12", "r", "b", "117"], ["118", "2023-10-10", "r", "b",
  "118"], ["119", "2023-10-31", "r", "b", "119"], ["120", "2023-12-05", "r", "b", "120"], ["121", "2024-01-23", "r", "b", "121"], ["122", "2\
024-02-20", "r", "b", "122"], ["123", "2024-03-19", "r", "b", "123"], ["124", "2024-04-16", "r", "b", "124"], ["125", "2024-05-14", "r", "b",
  "125"], ["126", "2024-06-11", "r", "b", "126"], ["127", "2024-07-23", "r", "b", "127"], ["128", "2024-08-20", "r", "b", "128"], ["129", "2\
024-09-17", "r", "b", "129"], ["130", "2024-10-15", "r", "b", "130"], ["131", "2024-11-12", "r", "b", "131"], ["132", "2025-01-14", "r", "b",
  "132"], ["133", "2025-02-04", "r", "b", "133"], ["134", "2025-03-04", "r", "b", "134"], ["135", "2025-04-01", "r", "b", "135"], ["136", "2\
025-04-29", "r", "b", "136"], ["137", "2025-05-27", "r", "b", "137"], ["138", "2025-06-24", "r", "b", "138"], ["139", "2025-08-05", "r", "b",
  "139"], ["140", "2025-09-02", "c", "b", "140"], ["141", "2025-09-30", "b", "b", "141"], ["142", "2025-10-28", "n", "b", "142"], ["143", null,
  "p", "b", "143"]] }, edge: { releases: [["12", "2015-07-29", "r", null, "12"], ["13", "2015-11-12", "r", null, "13"], ["14", "2016-08-02",
  "r", null, "14"], ["15", "2017-04-05", "r", null, "15"], ["16", "2017-10-17", "r", null, "16"], ["17", "2018-04-30", "r", null, "17"], ["1\
8", "2018-10-02", "r", null, "18"], ["79", "2020-01-15", "r", "b", "79"], ["80", "2020-02-07", "r", "b", "80"], ["81", "2020-04-13", "r", "b",
  "81"], ["83", "2020-05-21", "r", "b", "83"], ["84", "2020-07-16", "r", "b", "84"], ["85", "2020-08-27", "r", "b", "85"], ["86", "2020-10-0\
9", "r", "b", "86"], ["87", "2020-11-19", "r", "b", "87"], ["88", "2021-01-21", "r", "b", "88"], ["89", "2021-03-04", "r", "b", "89"], ["90",
  "2021-04-15", "r", "b", "90"], ["91", "2021-05-27", "r", "b", "91"], ["92", "2021-07-22", "r", "b", "92"], ["93", "2021-09-02", "r", "b", "\
93"], ["94", "2021-09-24", "r", "b", "94"], ["95", "2021-10-21", "r", "b", "95"], ["96", "2021-11-19", "r", "b", "96"], ["97", "2022-01-06",
  "r", "b", "97"], ["98", "2022-02-03", "r", "b", "98"], ["99", "2022-03-03", "r", "b", "99"], ["100", "2022-04-01", "r", "b", "100"], ["101",
  "2022-04-28", "r", "b", "101"], ["102", "2022-05-31", "r", "b", "102"], ["103", "2022-06-23", "r", "b", "103"], ["104", "2022-08-05", "r",
  "b", "104"], ["105", "2022-09-01", "r", "b", "105"], ["106", "2022-10-03", "r", "b", "106"], ["107", "2022-10-27", "r", "b", "107"], ["108",
  "2022-12-05", "r", "b", "108"], ["109", "2023-01-12", "r", "b", "109"], ["110", "2023-02-09", "r", "b", "110"], ["111", "2023-03-13", "r",
  "b", "111"], ["112", "2023-04-06", "r", "b", "112"], ["113", "2023-05-05", "r", "b", "113"], ["114", "2023-06-02", "r", "b", "114"], ["115",
  "2023-07-21", "r", "b", "115"], ["116", "2023-08-21", "r", "b", "116"], ["117", "2023-09-15", "r", "b", "117"], ["118", "2023-10-13", "r",
  "b", "118"], ["119", "2023-11-02", "r", "b", "119"], ["120", "2023-12-07", "r", "b", "120"], ["121", "2024-01-25", "r", "b", "121"], ["122",
  "2024-02-23", "r", "b", "122"], ["123", "2024-03-22", "r", "b", "123"], ["124", "2024-04-18", "r", "b", "124"], ["125", "2024-05-17", "r",
  "b", "125"], ["126", "2024-06-13", "r", "b", "126"], ["127", "2024-07-25", "r", "b", "127"], ["128", "2024-08-22", "r", "b", "128"], ["129",
  "2024-09-19", "r", "b", "129"], ["130", "2024-10-17", "r", "b", "130"], ["131", "2024-11-14", "r", "b", "131"], ["132", "2025-01-17", "r",
  "b", "132"], ["133", "2025-02-06", "r", "b", "133"], ["134", "2025-03-06", "r", "b", "134"], ["135", "2025-04-04", "r", "b", "135"], ["136",
  "2025-05-01", "r", "b", "136"], ["137", "2025-05-29", "r", "b", "137"], ["138", "2025-06-26", "r", "b", "138"], ["139", "2025-08-07", "r",
  "b", "139"], ["140", "2025-09-05", "c", "b", "140"], ["141", "2025-10-02", "b", "b", "141"], ["142", "2025-10-30", "n", "b", "142"], ["143",
  "2025-12-04", "p", "b", "143"]] }, firefox: { releases: [["1", "2004-11-09", "r", "g", "1.7"], ["2", "2006-10-24", "r", "g", "1.8.1"], ["3",
  "2008-06-17", "r", "g", "1.9"], ["4", "2011-03-22", "r", "g", "2"], ["5", "2011-06-21", "r", "g", "5"], ["6", "2011-08-16", "r", "g", "6"],
  ["7", "2011-09-27", "r", "g", "7"], ["8", "2011-11-08", "r", "g", "8"], ["9", "2011-12-20", "r", "g", "9"], ["10", "2012-01-31", "r", "g",
  "10"], ["11", "2012-03-13", "r", "g", "11"], ["12", "2012-04-24", "r", "g", "12"], ["13", "2012-06-05", "r", "g", "13"], ["14", "2012-07-1\
7", "r", "g", "14"], ["15", "2012-08-28", "r", "g", "15"], ["16", "2012-10-09", "r", "g", "16"], ["17", "2012-11-20", "r", "g", "17"], ["18",
  "2013-01-08", "r", "g", "18"], ["19", "2013-02-19", "r", "g", "19"], ["20", "2013-04-02", "r", "g", "20"], ["21", "2013-05-14", "r", "g", "\
21"], ["22", "2013-06-25", "r", "g", "22"], ["23", "2013-08-06", "r", "g", "23"], ["24", "2013-09-17", "r", "g", "24"], ["25", "2013-10-29",
  "r", "g", "25"], ["26", "2013-12-10", "r", "g", "26"], ["27", "2014-02-04", "r", "g", "27"], ["28", "2014-03-18", "r", "g", "28"], ["29", "\
2014-04-29", "r", "g", "29"], ["30", "2014-06-10", "r", "g", "30"], ["31", "2014-07-22", "r", "g", "31"], ["32", "2014-09-02", "r", "g", "32"],
  ["33", "2014-10-14", "r", "g", "33"], ["34", "2014-12-01", "r", "g", "34"], ["35", "2015-01-13", "r", "g", "35"], ["36", "2015-02-24", "r",
  "g", "36"], ["37", "2015-03-31", "r", "g", "37"], ["38", "2015-05-12", "r", "g", "38"], ["39", "2015-07-02", "r", "g", "39"], ["40", "2015\
-08-11", "r", "g", "40"], ["41", "2015-09-22", "r", "g", "41"], ["42", "2015-11-03", "r", "g", "42"], ["43", "2015-12-15", "r", "g", "43"], [
  "44", "2016-01-26", "r", "g", "44"], ["45", "2016-03-08", "r", "g", "45"], ["46", "2016-04-26", "r", "g", "46"], ["47", "2016-06-07", "r",
  "g", "47"], ["48", "2016-08-02", "r", "g", "48"], ["49", "2016-09-20", "r", "g", "49"], ["50", "2016-11-15", "r", "g", "50"], ["51", "2017\
-01-24", "r", "g", "51"], ["52", "2017-03-07", "r", "g", "52"], ["53", "2017-04-19", "r", "g", "53"], ["54", "2017-06-13", "r", "g", "54"], [
  "55", "2017-08-08", "r", "g", "55"], ["56", "2017-09-28", "r", "g", "56"], ["57", "2017-11-14", "r", "g", "57"], ["58", "2018-01-23", "r",
  "g", "58"], ["59", "2018-03-13", "r", "g", "59"], ["60", "2018-05-09", "r", "g", "60"], ["61", "2018-06-26", "r", "g", "61"], ["62", "2018\
-09-05", "r", "g", "62"], ["63", "2018-10-23", "r", "g", "63"], ["64", "2018-12-11", "r", "g", "64"], ["65", "2019-01-29", "r", "g", "65"], [
  "66", "2019-03-19", "r", "g", "66"], ["67", "2019-05-21", "r", "g", "67"], ["68", "2019-07-09", "r", "g", "68"], ["69", "2019-09-03", "r",
  "g", "69"], ["70", "2019-10-22", "r", "g", "70"], ["71", "2019-12-10", "r", "g", "71"], ["72", "2020-01-07", "r", "g", "72"], ["73", "2020\
-02-11", "r", "g", "73"], ["74", "2020-03-10", "r", "g", "74"], ["75", "2020-04-07", "r", "g", "75"], ["76", "2020-05-05", "r", "g", "76"], [
  "77", "2020-06-02", "r", "g", "77"], ["78", "2020-06-30", "r", "g", "78"], ["79", "2020-07-28", "r", "g", "79"], ["80", "2020-08-25", "r",
  "g", "80"], ["81", "2020-09-22", "r", "g", "81"], ["82", "2020-10-20", "r", "g", "82"], ["83", "2020-11-17", "r", "g", "83"], ["84", "2020\
-12-15", "r", "g", "84"], ["85", "2021-01-26", "r", "g", "85"], ["86", "2021-02-23", "r", "g", "86"], ["87", "2021-03-23", "r", "g", "87"], [
  "88", "2021-04-19", "r", "g", "88"], ["89", "2021-06-01", "r", "g", "89"], ["90", "2021-07-13", "r", "g", "90"], ["91", "2021-08-10", "r",
  "g", "91"], ["92", "2021-09-07", "r", "g", "92"], ["93", "2021-10-05", "r", "g", "93"], ["94", "2021-11-02", "r", "g", "94"], ["95", "2021\
-12-07", "r", "g", "95"], ["96", "2022-01-11", "r", "g", "96"], ["97", "2022-02-08", "r", "g", "97"], ["98", "2022-03-08", "r", "g", "98"], [
  "99", "2022-04-05", "r", "g", "99"], ["100", "2022-05-03", "r", "g", "100"], ["101", "2022-05-31", "r", "g", "101"], ["102", "2022-06-28",
  "r", "g", "102"], ["103", "2022-07-26", "r", "g", "103"], ["104", "2022-08-23", "r", "g", "104"], ["105", "2022-09-20", "r", "g", "105"], [
  "106", "2022-10-18", "r", "g", "106"], ["107", "2022-11-15", "r", "g", "107"], ["108", "2022-12-13", "r", "g", "108"], ["109", "2023-01-17",
  "r", "g", "109"], ["110", "2023-02-14", "r", "g", "110"], ["111", "2023-03-14", "r", "g", "111"], ["112", "2023-04-11", "r", "g", "112"], [
  "113", "2023-05-09", "r", "g", "113"], ["114", "2023-06-06", "r", "g", "114"], ["115", "2023-07-04", "r", "g", "115"], ["116", "2023-08-01",
  "r", "g", "116"], ["117", "2023-08-29", "r", "g", "117"], ["118", "2023-09-26", "r", "g", "118"], ["119", "2023-10-24", "r", "g", "119"], [
  "120", "2023-11-21", "r", "g", "120"], ["121", "2023-12-19", "r", "g", "121"], ["122", "2024-01-23", "r", "g", "122"], ["123", "2024-02-20",
  "r", "g", "123"], ["124", "2024-03-19", "r", "g", "124"], ["125", "2024-04-16", "r", "g", "125"], ["126", "2024-05-14", "r", "g", "126"], [
  "127", "2024-06-11", "r", "g", "127"], ["128", "2024-07-09", "r", "g", "128"], ["129", "2024-08-06", "r", "g", "129"], ["130", "2024-09-03",
  "r", "g", "130"], ["131", "2024-10-01", "r", "g", "131"], ["132", "2024-10-29", "r", "g", "132"], ["133", "2024-11-26", "r", "g", "133"], [
  "134", "2025-01-07", "r", "g", "134"], ["135", "2025-02-04", "r", "g", "135"], ["136", "2025-03-04", "r", "g", "136"], ["137", "2025-04-01",
  "r", "g", "137"], ["138", "2025-04-29", "r", "g", "138"], ["139", "2025-05-27", "r", "g", "139"], ["140", "2025-06-24", "e", "g", "140"], [
  "141", "2025-07-22", "r", "g", "141"], ["142", "2025-08-19", "c", "g", "142"], ["143", "2025-09-16", "b", "g", "143"], ["144", "2025-10-14",
  "n", "g", "144"], ["145", "2025-11-11", "p", "g", "145"], ["1.5", "2005-11-29", "r", "g", "1.8"], ["3.5", "2009-06-30", "r", "g", "1.9.1"],
  ["3.6", "2010-01-21", "r", "g", "1.9.2"]] }, firefox_android: { releases: [["4", "2011-03-29", "r", "g", "2"], ["5", "2011-06-21", "r", "g",
  "5"], ["6", "2011-08-16", "r", "g", "6"], ["7", "2011-09-27", "r", "g", "7"], ["8", "2011-11-08", "r", "g", "8"], ["9", "2011-12-21", "r",
  "g", "9"], ["10", "2012-01-31", "r", "g", "10"], ["14", "2012-06-26", "r", "g", "14"], ["15", "2012-08-28", "r", "g", "15"], ["16", "2012-\
10-09", "r", "g", "16"], ["17", "2012-11-20", "r", "g", "17"], ["18", "2013-01-08", "r", "g", "18"], ["19", "2013-02-19", "r", "g", "19"], [
  "20", "2013-04-02", "r", "g", "20"], ["21", "2013-05-14", "r", "g", "21"], ["22", "2013-06-25", "r", "g", "22"], ["23", "2013-08-06", "r",
  "g", "23"], ["24", "2013-09-17", "r", "g", "24"], ["25", "2013-10-29", "r", "g", "25"], ["26", "2013-12-10", "r", "g", "26"], ["27", "2014\
-02-04", "r", "g", "27"], ["28", "2014-03-18", "r", "g", "28"], ["29", "2014-04-29", "r", "g", "29"], ["30", "2014-06-10", "r", "g", "30"], [
  "31", "2014-07-22", "r", "g", "31"], ["32", "2014-09-02", "r", "g", "32"], ["33", "2014-10-14", "r", "g", "33"], ["34", "2014-12-01", "r",
  "g", "34"], ["35", "2015-01-13", "r", "g", "35"], ["36", "2015-02-27", "r", "g", "36"], ["37", "2015-03-31", "r", "g", "37"], ["38", "2015\
-05-12", "r", "g", "38"], ["39", "2015-07-02", "r", "g", "39"], ["40", "2015-08-11", "r", "g", "40"], ["41", "2015-09-22", "r", "g", "41"], [
  "42", "2015-11-03", "r", "g", "42"], ["43", "2015-12-15", "r", "g", "43"], ["44", "2016-01-26", "r", "g", "44"], ["45", "2016-03-08", "r",
  "g", "45"], ["46", "2016-04-26", "r", "g", "46"], ["47", "2016-06-07", "r", "g", "47"], ["48", "2016-08-02", "r", "g", "48"], ["49", "2016\
-09-20", "r", "g", "49"], ["50", "2016-11-15", "r", "g", "50"], ["51", "2017-01-24", "r", "g", "51"], ["52", "2017-03-07", "r", "g", "52"], [
  "53", "2017-04-19", "r", "g", "53"], ["54", "2017-06-13", "r", "g", "54"], ["55", "2017-08-08", "r", "g", "55"], ["56", "2017-09-28", "r",
  "g", "56"], ["57", "2017-11-28", "r", "g", "57"], ["58", "2018-01-22", "r", "g", "58"], ["59", "2018-03-13", "r", "g", "59"], ["60", "2018\
-05-09", "r", "g", "60"], ["61", "2018-06-26", "r", "g", "61"], ["62", "2018-09-05", "r", "g", "62"], ["63", "2018-10-23", "r", "g", "63"], [
  "64", "2018-12-11", "r", "g", "64"], ["65", "2019-01-29", "r", "g", "65"], ["66", "2019-03-19", "r", "g", "66"], ["67", "2019-05-21", "r",
  "g", "67"], ["68", "2019-07-09", "r", "g", "68"], ["79", "2020-07-28", "r", "g", "79"], ["80", "2020-08-31", "r", "g", "80"], ["81", "2020\
-09-22", "r", "g", "81"], ["82", "2020-10-20", "r", "g", "82"], ["83", "2020-11-17", "r", "g", "83"], ["84", "2020-12-15", "r", "g", "84"], [
  "85", "2021-01-26", "r", "g", "85"], ["86", "2021-02-23", "r", "g", "86"], ["87", "2021-03-23", "r", "g", "87"], ["88", "2021-04-19", "r",
  "g", "88"], ["89", "2021-06-01", "r", "g", "89"], ["90", "2021-07-13", "r", "g", "90"], ["91", "2021-08-10", "r", "g", "91"], ["92", "2021\
-09-07", "r", "g", "92"], ["93", "2021-10-05", "r", "g", "93"], ["94", "2021-11-02", "r", "g", "94"], ["95", "2021-12-07", "r", "g", "95"], [
  "96", "2022-01-11", "r", "g", "96"], ["97", "2022-02-08", "r", "g", "97"], ["98", "2022-03-08", "r", "g", "98"], ["99", "2022-04-05", "r",
  "g", "99"], ["100", "2022-05-03", "r", "g", "100"], ["101", "2022-05-31", "r", "g", "101"], ["102", "2022-06-28", "r", "g", "102"], ["103",
  "2022-07-26", "r", "g", "103"], ["104", "2022-08-23", "r", "g", "104"], ["105", "2022-09-20", "r", "g", "105"], ["106", "2022-10-18", "r",
  "g", "106"], ["107", "2022-11-15", "r", "g", "107"], ["108", "2022-12-13", "r", "g", "108"], ["109", "2023-01-17", "r", "g", "109"], ["110",
  "2023-02-14", "r", "g", "110"], ["111", "2023-03-14", "r", "g", "111"], ["112", "2023-04-11", "r", "g", "112"], ["113", "2023-05-09", "r",
  "g", "113"], ["114", "2023-06-06", "r", "g", "114"], ["115", "2023-07-04", "r", "g", "115"], ["116", "2023-08-01", "r", "g", "116"], ["117",
  "2023-08-29", "r", "g", "117"], ["118", "2023-09-26", "r", "g", "118"], ["119", "2023-10-24", "r", "g", "119"], ["120", "2023-11-21", "r",
  "g", "120"], ["121", "2023-12-19", "r", "g", "121"], ["122", "2024-01-23", "r", "g", "122"], ["123", "2024-02-20", "r", "g", "123"], ["124",
  "2024-03-19", "r", "g", "124"], ["125", "2024-04-16", "r", "g", "125"], ["126", "2024-05-14", "r", "g", "126"], ["127", "2024-06-11", "r",
  "g", "127"], ["128", "2024-07-09", "r", "g", "128"], ["129", "2024-08-06", "r", "g", "129"], ["130", "2024-09-03", "r", "g", "130"], ["131",
  "2024-10-01", "r", "g", "131"], ["132", "2024-10-29", "r", "g", "132"], ["133", "2024-11-26", "r", "g", "133"], ["134", "2025-01-07", "r",
  "g", "134"], ["135", "2025-02-04", "r", "g", "135"], ["136", "2025-03-04", "r", "g", "136"], ["137", "2025-04-01", "r", "g", "137"], ["138",
  "2025-04-29", "r", "g", "138"], ["139", "2025-05-27", "r", "g", "139"], ["140", "2025-06-24", "e", "g", "140"], ["141", "2025-07-22", "r",
  "g", "141"], ["142", "2025-08-19", "c", "g", "142"], ["143", "2025-09-16", "b", "g", "143"], ["144", "2025-10-14", "n", "g", "144"], ["145",
  "2025-11-11", "p", "g", "145"]] }, opera: { releases: [["2", "1996-07-14", "r", null, null], ["3", "1997-12-01", "r", null, null], ["4", "\
2000-06-28", "r", null, null], ["5", "2000-12-06", "r", null, null], ["6", "2001-12-18", "r", null, null], ["7", "2003-01-28", "r", "p", "1"],
  ["8", "2005-04-19", "r", "p", "1"], ["9", "2006-06-20", "r", "p", "2"], ["10", "2009-09-01", "r", "p", "2.2"], ["11", "2010-12-16", "r", "\
p", "2.7"], ["12", "2012-06-14", "r", "p", "2.10"], ["15", "2013-07-02", "r", "b", "28"], ["16", "2013-08-27", "r", "b", "29"], ["17", "2013\
-10-08", "r", "b", "30"], ["18", "2013-11-19", "r", "b", "31"], ["19", "2014-01-28", "r", "b", "32"], ["20", "2014-03-04", "r", "b", "33"], [
  "21", "2014-05-06", "r", "b", "34"], ["22", "2014-06-03", "r", "b", "35"], ["23", "2014-07-22", "r", "b", "36"], ["24", "2014-09-02", "r",
  "b", "37"], ["25", "2014-10-15", "r", "b", "38"], ["26", "2014-12-03", "r", "b", "39"], ["27", "2015-01-27", "r", "b", "40"], ["28", "2015\
-03-10", "r", "b", "41"], ["29", "2015-04-28", "r", "b", "42"], ["30", "2015-06-09", "r", "b", "43"], ["31", "2015-08-04", "r", "b", "44"], [
  "32", "2015-09-15", "r", "b", "45"], ["33", "2015-10-27", "r", "b", "46"], ["34", "2015-12-08", "r", "b", "47"], ["35", "2016-02-02", "r",
  "b", "48"], ["36", "2016-03-15", "r", "b", "49"], ["37", "2016-05-04", "r", "b", "50"], ["38", "2016-06-08", "r", "b", "51"], ["39", "2016\
-08-02", "r", "b", "52"], ["40", "2016-09-20", "r", "b", "53"], ["41", "2016-10-25", "r", "b", "54"], ["42", "2016-12-13", "r", "b", "55"], [
  "43", "2017-02-07", "r", "b", "56"], ["44", "2017-03-21", "r", "b", "57"], ["45", "2017-05-10", "r", "b", "58"], ["46", "2017-06-22", "r",
  "b", "59"], ["47", "2017-08-09", "r", "b", "60"], ["48", "2017-09-27", "r", "b", "61"], ["49", "2017-11-08", "r", "b", "62"], ["50", "2018\
-01-04", "r", "b", "63"], ["51", "2018-02-07", "r", "b", "64"], ["52", "2018-03-22", "r", "b", "65"], ["53", "2018-05-10", "r", "b", "66"], [
  "54", "2018-06-28", "r", "b", "67"], ["55", "2018-08-16", "r", "b", "68"], ["56", "2018-09-25", "r", "b", "69"], ["57", "2018-11-28", "r",
  "b", "70"], ["58", "2019-01-23", "r", "b", "71"], ["60", "2019-04-09", "r", "b", "73"], ["62", "2019-06-27", "r", "b", "75"], ["63", "2019\
-08-20", "r", "b", "76"], ["64", "2019-10-07", "r", "b", "77"], ["65", "2019-11-13", "r", "b", "78"], ["66", "2020-01-07", "r", "b", "79"], [
  "67", "2020-03-03", "r", "b", "80"], ["68", "2020-04-22", "r", "b", "81"], ["69", "2020-06-24", "r", "b", "83"], ["70", "2020-07-27", "r",
  "b", "84"], ["71", "2020-09-15", "r", "b", "85"], ["72", "2020-10-21", "r", "b", "86"], ["73", "2020-12-09", "r", "b", "87"], ["74", "2021\
-02-02", "r", "b", "88"], ["75", "2021-03-24", "r", "b", "89"], ["76", "2021-04-28", "r", "b", "90"], ["77", "2021-06-09", "r", "b", "91"], [
  "78", "2021-08-03", "r", "b", "92"], ["79", "2021-09-14", "r", "b", "93"], ["80", "2021-10-05", "r", "b", "94"], ["81", "2021-11-04", "r",
  "b", "95"], ["82", "2021-12-02", "r", "b", "96"], ["83", "2022-01-19", "r", "b", "97"], ["84", "2022-02-16", "r", "b", "98"], ["85", "2022\
-03-23", "r", "b", "99"], ["86", "2022-04-20", "r", "b", "100"], ["87", "2022-05-17", "r", "b", "101"], ["88", "2022-06-08", "r", "b", "102"],
  ["89", "2022-07-07", "r", "b", "103"], ["90", "2022-08-18", "r", "b", "104"], ["91", "2022-09-14", "r", "b", "105"], ["92", "2022-10-19", "\
r", "b", "106"], ["93", "2022-11-17", "r", "b", "107"], ["94", "2022-12-15", "r", "b", "108"], ["95", "2023-02-01", "r", "b", "109"], ["96",
  "2023-02-22", "r", "b", "110"], ["97", "2023-03-22", "r", "b", "111"], ["98", "2023-04-20", "r", "b", "112"], ["99", "2023-05-16", "r", "b",
  "113"], ["100", "2023-06-29", "r", "b", "114"], ["101", "2023-07-26", "r", "b", "115"], ["102", "2023-08-23", "r", "b", "116"], ["103", "2\
023-10-03", "r", "b", "117"], ["104", "2023-10-23", "r", "b", "118"], ["105", "2023-11-14", "r", "b", "119"], ["106", "2023-12-19", "r", "b",
  "120"], ["107", "2024-02-07", "r", "b", "121"], ["108", "2024-03-05", "r", "b", "122"], ["109", "2024-03-27", "r", "b", "123"], ["110", "2\
024-05-14", "r", "b", "124"], ["111", "2024-06-12", "r", "b", "125"], ["112", "2024-07-11", "r", "b", "126"], ["113", "2024-08-22", "r", "b",
  "127"], ["114", "2024-09-25", "r", "b", "128"], ["115", "2024-11-27", "r", "b", "130"], ["116", "2025-01-08", "r", "b", "131"], ["117", "2\
025-02-13", "r", "b", "132"], ["118", "2025-04-15", "r", "b", "133"], ["119", "2025-05-13", "r", "b", "134"], ["120", "2025-07-02", "r", "b",
  "135"], ["121", "2025-08-27", "r", "b", "137"], ["122", "2025-09-11", "c", "b", "138"], ["123", null, "b", "b", "139"], ["124", null, "n",
  "b", "140"], ["10.1", "2009-11-23", "r", "p", "2.2"], ["10.5", "2010-03-02", "r", "p", "2.5"], ["10.6", "2010-07-01", "r", "p", "2.6"], ["\
11.1", "2011-04-12", "r", "p", "2.8"], ["11.5", "2011-06-28", "r", "p", "2.9"], ["11.6", "2011-12-06", "r", "p", "2.10"], ["12.1", "2012-11-\
20", "r", "p", "2.12"], ["3.5", "1998-11-18", "r", null, null], ["3.6", "1999-05-06", "r", null, null], ["5.1", "2001-04-10", "r", null, null],
  ["7.1", "2003-04-11", "r", "p", "1"], ["7.2", "2003-09-23", "r", "p", "1"], ["7.5", "2004-05-12", "r", "p", "1"], ["8.5", "2005-09-20", "r",
  "p", "1"], ["9.1", "2006-12-18", "r", "p", "2"], ["9.2", "2007-04-11", "r", "p", "2"], ["9.5", "2008-06-12", "r", "p", "2.1"], ["9.6", "20\
08-10-08", "r", "p", "2.1"]] }, opera_android: { releases: [["11", "2011-03-22", "r", "p", "2.7"], ["12", "2012-02-25", "r", "p", "2.10"], [
  "14", "2013-05-21", "r", "w", "537.31"], ["15", "2013-07-08", "r", "b", "28"], ["16", "2013-09-18", "r", "b", "29"], ["18", "2013-11-20", "\
r", "b", "31"], ["19", "2014-01-28", "r", "b", "32"], ["20", "2014-03-06", "r", "b", "33"], ["21", "2014-04-22", "r", "b", "34"], ["22", "20\
14-06-17", "r", "b", "35"], ["24", "2014-09-10", "r", "b", "37"], ["25", "2014-10-16", "r", "b", "38"], ["26", "2014-12-02", "r", "b", "39"],
  ["27", "2015-01-29", "r", "b", "40"], ["28", "2015-03-10", "r", "b", "41"], ["29", "2015-04-28", "r", "b", "42"], ["30", "2015-06-10", "r",
  "b", "43"], ["32", "2015-09-23", "r", "b", "45"], ["33", "2015-11-03", "r", "b", "46"], ["34", "2015-12-16", "r", "b", "47"], ["35", "2016\
-02-04", "r", "b", "48"], ["36", "2016-03-31", "r", "b", "49"], ["37", "2016-06-16", "r", "b", "50"], ["41", "2016-10-25", "r", "b", "54"], [
  "42", "2017-01-21", "r", "b", "55"], ["43", "2017-09-27", "r", "b", "59"], ["44", "2017-12-11", "r", "b", "60"], ["45", "2018-02-15", "r",
  "b", "61"], ["46", "2018-05-14", "r", "b", "63"], ["47", "2018-07-23", "r", "b", "66"], ["48", "2018-11-08", "r", "b", "69"], ["49", "2018\
-12-07", "r", "b", "70"], ["50", "2019-02-18", "r", "b", "71"], ["51", "2019-03-21", "r", "b", "72"], ["52", "2019-05-17", "r", "b", "73"], [
  "53", "2019-07-11", "r", "b", "74"], ["54", "2019-10-18", "r", "b", "76"], ["55", "2019-12-03", "r", "b", "77"], ["56", "2020-02-06", "r",
  "b", "78"], ["57", "2020-03-30", "r", "b", "80"], ["58", "2020-05-13", "r", "b", "81"], ["59", "2020-06-30", "r", "b", "83"], ["60", "2020\
-09-23", "r", "b", "85"], ["61", "2020-12-07", "r", "b", "86"], ["62", "2021-02-16", "r", "b", "87"], ["63", "2021-04-16", "r", "b", "89"], [
  "64", "2021-05-25", "r", "b", "91"], ["65", "2021-10-20", "r", "b", "92"], ["66", "2021-12-15", "r", "b", "94"], ["67", "2022-01-31", "r",
  "b", "96"], ["68", "2022-03-30", "r", "b", "99"], ["69", "2022-05-09", "r", "b", "100"], ["70", "2022-06-29", "r", "b", "102"], ["71", "20\
22-09-16", "r", "b", "104"], ["72", "2022-10-21", "r", "b", "106"], ["73", "2023-01-17", "r", "b", "108"], ["74", "2023-03-13", "r", "b", "1\
10"], ["75", "2023-05-17", "r", "b", "112"], ["76", "2023-06-26", "r", "b", "114"], ["77", "2023-08-31", "r", "b", "115"], ["78", "2023-10-2\
3", "r", "b", "117"], ["79", "2023-12-06", "r", "b", "119"], ["80", "2024-01-25", "r", "b", "120"], ["81", "2024-03-14", "r", "b", "122"], [
  "82", "2024-05-02", "r", "b", "124"], ["83", "2024-06-25", "r", "b", "126"], ["84", "2024-08-26", "r", "b", "127"], ["85", "2024-10-29", "\
r", "b", "128"], ["86", "2024-12-02", "r", "b", "130"], ["87", "2025-01-22", "r", "b", "132"], ["88", "2025-03-19", "r", "b", "134"], ["89",
  "2025-04-29", "r", "b", "135"], ["90", "2025-06-18", "r", "b", "137"], ["91", "2025-08-19", "c", "b", "139"], ["10.1", "2010-11-09", "r", "\
p", "2.5"], ["11.1", "2011-06-30", "r", "p", "2.8"], ["11.5", "2011-10-12", "r", "p", "2.9"], ["12.1", "2012-10-09", "r", "p", "2.11"]] }, safari: {
  releases: [["1", "2003-06-23", "r", "w", "85"], ["2", "2005-04-29", "r", "w", "412"], ["3", "2007-10-26", "r", "w", "523.10"], ["4", "2009\
-06-08", "r", "w", "530.17"], ["5", "2010-06-07", "r", "w", "533.16"], ["6", "2012-07-25", "r", "w", "536.25"], ["7", "2013-10-22", "r", "w",
  "537.71"], ["8", "2014-10-16", "r", "w", "538.35"], ["9", "2015-09-30", "r", "w", "601.1.56"], ["10", "2016-09-20", "r", "w", "602.1.50"],
  ["11", "2017-09-19", "r", "w", "604.2.4"], ["12", "2018-09-17", "r", "w", "606.1.36"], ["13", "2019-09-19", "r", "w", "608.2.11"], ["14", "\
2020-09-16", "r", "w", "610.1.28"], ["15", "2021-09-20", "r", "w", "612.1.27"], ["16", "2022-09-12", "r", "w", "614.1.25"], ["17", "2023-09-\
18", "r", "w", "616.1.27"], ["18", "2024-09-16", "r", "w", "619.1.26"], ["26", null, "b", "w", "622.1.22"], ["1.1", "2003-10-24", "r", "w", "\
100"], ["1.2", "2004-02-02", "r", "w", "125"], ["1.3", "2005-04-15", "r", "w", "312"], ["10.1", "2017-03-27", "r", "w", "603.2.1"], ["11.1",
  "2018-04-12", "r", "w", "605.1.33"], ["12.1", "2019-03-25", "r", "w", "607.1.40"], ["13.1", "2020-03-24", "r", "w", "609.1.20"], ["14.1", "\
2021-04-26", "r", "w", "611.1.21"], ["15.1", "2021-10-25", "r", "w", "612.2.9"], ["15.2", "2021-12-13", "r", "w", "612.3.6"], ["15.3", "2022\
-01-26", "r", "w", "612.4.9"], ["15.4", "2022-03-14", "r", "w", "613.1.17"], ["15.5", "2022-05-16", "r", "w", "613.2.7"], ["15.6", "2022-07-\
20", "r", "w", "613.3.9"], ["16.1", "2022-10-24", "r", "w", "614.2.9"], ["16.2", "2022-12-13", "r", "w", "614.3.7"], ["16.3", "2023-01-23", "\
r", "w", "614.4.6"], ["16.4", "2023-03-27", "r", "w", "615.1.26"], ["16.5", "2023-05-18", "r", "w", "615.2.9"], ["16.6", "2023-07-24", "r", "\
w", "615.3.12"], ["17.1", "2023-10-25", "r", "w", "616.2.9"], ["17.2", "2023-12-11", "r", "w", "617.1.17"], ["17.3", "2024-01-22", "r", "w",
  "617.2.4"], ["17.4", "2024-03-05", "r", "w", "618.1.15"], ["17.5", "2024-05-13", "r", "w", "618.2.12"], ["17.6", "2024-07-29", "r", "w", "\
618.3.11"], ["18.1", "2024-10-28", "r", "w", "619.2.8"], ["18.2", "2024-12-11", "r", "w", "620.1.16"], ["18.3", "2025-01-27", "r", "w", "620\
.2.4"], ["18.4", "2025-03-31", "r", "w", "621.1.15"], ["18.5", "2025-05-12", "r", "w", "621.2.5"], ["18.6", "2025-07-29", "c", "w", "621.3.1\
1"], ["3.1", "2008-03-18", "r", "w", "525.13"], ["5.1", "2011-07-20", "r", "w", "534.48"], ["9.1", "2016-03-21", "r", "w", "601.5.17"]] }, safari_ios: {
  releases: [["1", "2007-06-29", "r", "w", "522.11"], ["2", "2008-07-11", "r", "w", "525.18"], ["3", "2009-06-17", "r", "w", "528.18"], ["4",
  "2010-06-21", "r", "w", "532.9"], ["5", "2011-10-12", "r", "w", "534.46"], ["6", "2012-09-10", "r", "w", "536.26"], ["7", "2013-09-18", "r",
  "w", "537.51"], ["8", "2014-09-17", "r", "w", "600.1.4"], ["9", "2015-09-16", "r", "w", "601.1.56"], ["10", "2016-09-13", "r", "w", "602.1\
.50"], ["11", "2017-09-19", "r", "w", "604.2.4"], ["12", "2018-09-17", "r", "w", "606.1.36"], ["13", "2019-09-19", "r", "w", "608.2.11"], ["\
14", "2020-09-16", "r", "w", "610.1.28"], ["15", "2021-09-20", "r", "w", "612.1.27"], ["16", "2022-09-12", "r", "w", "614.1.25"], ["17", "20\
23-09-18", "r", "w", "616.1.27"], ["18", "2024-09-16", "r", "w", "619.1.26"], ["26", null, "b", "w", "622.1.22"], ["10.3", "2017-03-27", "r",
  "w", "603.2.1"], ["11.3", "2018-03-29", "r", "w", "605.1.33"], ["12.2", "2019-03-25", "r", "w", "607.1.40"], ["13.4", "2020-03-24", "r", "\
w", "609.1.20"], ["14.5", "2021-04-26", "r", "w", "611.1.21"], ["15.1", "2021-10-25", "r", "w", "612.2.9"], ["15.2", "2021-12-13", "r", "w",
  "612.3.6"], ["15.3", "2022-01-26", "r", "w", "612.4.9"], ["15.4", "2022-03-14", "r", "w", "613.1.17"], ["15.5", "2022-05-16", "r", "w", "6\
13.2.7"], ["15.6", "2022-07-20", "r", "w", "613.3.9"], ["16.1", "2022-10-24", "r", "w", "614.2.9"], ["16.2", "2022-12-13", "r", "w", "614.3.\
7"], ["16.3", "2023-01-23", "r", "w", "614.4.6"], ["16.4", "2023-03-27", "r", "w", "615.1.26"], ["16.5", "2023-05-18", "r", "w", "615.2.9"],
  ["16.6", "2023-07-24", "r", "w", "615.3.12"], ["17.1", "2023-10-25", "r", "w", "616.2.9"], ["17.2", "2023-12-11", "r", "w", "617.1.17"], [
  "17.3", "2024-01-22", "r", "w", "617.2.4"], ["17.4", "2024-03-05", "r", "w", "618.1.15"], ["17.5", "2024-05-13", "r", "w", "618.2.12"], ["\
17.6", "2024-07-29", "r", "w", "618.3.11"], ["18.1", "2024-10-28", "r", "w", "619.2.8"], ["18.2", "2024-12-11", "r", "w", "620.1.16"], ["18.\
3", "2025-01-27", "r", "w", "620.2.4"], ["18.4", "2025-03-31", "r", "w", "621.1.15"], ["18.5", "2025-05-12", "r", "w", "621.2.5"], ["18.6", "\
2025-07-29", "c", "w", "621.3.11"], ["3.2", "2010-04-03", "r", "w", "531.21"], ["4.2", "2010-11-22", "r", "w", "533.17"], ["9.3", "2016-03-2\
1", "r", "w", "601.5.17"]] }, samsunginternet_android: { releases: [["1.0", "2013-04-27", "r", "w", "535.19"], ["1.5", "2013-09-25", "r", "b",
  "28"], ["1.6", "2014-04-11", "r", "b", "28"], ["10.0", "2019-08-22", "r", "b", "71"], ["10.2", "2019-10-09", "r", "b", "71"], ["11.0", "20\
19-12-05", "r", "b", "75"], ["11.2", "2020-03-22", "r", "b", "75"], ["12.0", "2020-06-19", "r", "b", "79"], ["12.1", "2020-07-07", "r", "b",
  "79"], ["13.0", "2020-12-02", "r", "b", "83"], ["13.2", "2021-01-20", "r", "b", "83"], ["14.0", "2021-04-17", "r", "b", "87"], ["14.2", "2\
021-06-25", "r", "b", "87"], ["15.0", "2021-08-13", "r", "b", "90"], ["16.0", "2021-11-25", "r", "b", "92"], ["16.2", "2022-03-06", "r", "b",
  "92"], ["17.0", "2022-05-04", "r", "b", "96"], ["18.0", "2022-08-08", "r", "b", "99"], ["18.1", "2022-09-09", "r", "b", "99"], ["19.0", "2\
022-11-01", "r", "b", "102"], ["19.1", "2022-11-08", "r", "b", "102"], ["2.0", "2014-10-17", "r", "b", "34"], ["2.1", "2015-01-07", "r", "b",
  "34"], ["20.0", "2023-02-10", "r", "b", "106"], ["21.0", "2023-05-19", "r", "b", "110"], ["22.0", "2023-07-14", "r", "b", "111"], ["23.0",
  "2023-10-18", "r", "b", "115"], ["24.0", "2024-01-25", "r", "b", "117"], ["25.0", "2024-04-24", "r", "b", "121"], ["26.0", "2024-06-07", "\
r", "b", "122"], ["27.0", "2024-11-06", "r", "b", "125"], ["28.0", "2025-04-02", "c", "b", "130"], ["3.0", "2015-04-10", "r", "b", "38"], ["\
3.2", "2015-08-24", "r", "b", "38"], ["4.0", "2016-03-11", "r", "b", "44"], ["4.2", "2016-08-02", "r", "b", "44"], ["5.0", "2016-12-15", "r",
  "b", "51"], ["5.2", "2017-04-21", "r", "b", "51"], ["5.4", "2017-05-17", "r", "b", "51"], ["6.0", "2017-08-23", "r", "b", "56"], ["6.2", "\
2017-10-26", "r", "b", "56"], ["6.4", "2018-02-19", "r", "b", "56"], ["7.0", "2018-03-16", "r", "b", "59"], ["7.2", "2018-06-20", "r", "b", "\
59"], ["7.4", "2018-09-12", "r", "b", "59"], ["8.0", "2018-07-18", "r", "b", "63"], ["8.2", "2018-12-21", "r", "b", "63"], ["9.0", "2018-09-\
15", "r", "b", "67"], ["9.2", "2019-04-02", "r", "b", "67"], ["9.4", "2019-07-25", "r", "b", "67"]] }, webview_android: { releases: [["1", "\
2008-09-23", "r", "w", "523.12"], ["2", "2009-10-26", "r", "w", "530.17"], ["3", "2011-02-22", "r", "w", "534.13"], ["4", "2011-10-18", "r",
  "w", "534.30"], ["37", "2014-09-03", "r", "b", "37"], ["38", "2014-10-08", "r", "b", "38"], ["39", "2014-11-12", "r", "b", "39"], ["40", "\
2015-01-21", "r", "b", "40"], ["41", "2015-03-11", "r", "b", "41"], ["42", "2015-04-15", "r", "b", "42"], ["43", "2015-05-27", "r", "b", "43"],
  ["44", "2015-07-29", "r", "b", "44"], ["45", "2015-09-01", "r", "b", "45"], ["46", "2015-10-14", "r", "b", "46"], ["47", "2015-12-02", "r",
  "b", "47"], ["48", "2016-01-26", "r", "b", "48"], ["49", "2016-03-09", "r", "b", "49"], ["50", "2016-04-13", "r", "b", "50"], ["51", "2016\
-06-08", "r", "b", "51"], ["52", "2016-07-27", "r", "b", "52"], ["53", "2016-09-07", "r", "b", "53"], ["54", "2016-10-19", "r", "b", "54"], [
  "55", "2016-12-06", "r", "b", "55"], ["56", "2017-02-01", "r", "b", "56"], ["57", "2017-03-16", "r", "b", "57"], ["58", "2017-04-25", "r",
  "b", "58"], ["59", "2017-06-06", "r", "b", "59"], ["60", "2017-08-01", "r", "b", "60"], ["61", "2017-09-05", "r", "b", "61"], ["62", "2017\
-10-24", "r", "b", "62"], ["63", "2017-12-05", "r", "b", "63"], ["64", "2018-01-23", "r", "b", "64"], ["65", "2018-03-06", "r", "b", "65"], [
  "66", "2018-04-17", "r", "b", "66"], ["67", "2018-05-31", "r", "b", "67"], ["68", "2018-07-24", "r", "b", "68"], ["69", "2018-09-04", "r",
  "b", "69"], ["70", "2018-10-17", "r", "b", "70"], ["71", "2018-12-04", "r", "b", "71"], ["72", "2019-01-29", "r", "b", "72"], ["73", "2019\
-03-12", "r", "b", "73"], ["74", "2019-04-24", "r", "b", "74"], ["75", "2019-06-04", "r", "b", "75"], ["76", "2019-07-30", "r", "b", "76"], [
  "77", "2019-09-10", "r", "b", "77"], ["78", "2019-10-22", "r", "b", "78"], ["79", "2019-12-17", "r", "b", "79"], ["80", "2020-02-04", "r",
  "b", "80"], ["81", "2020-04-07", "r", "b", "81"], ["83", "2020-05-19", "r", "b", "83"], ["84", "2020-07-27", "r", "b", "84"], ["85", "2020\
-08-25", "r", "b", "85"], ["86", "2020-10-20", "r", "b", "86"], ["87", "2020-11-17", "r", "b", "87"], ["88", "2021-01-19", "r", "b", "88"], [
  "89", "2021-03-02", "r", "b", "89"], ["90", "2021-04-13", "r", "b", "90"], ["91", "2021-05-25", "r", "b", "91"], ["92", "2021-07-20", "r",
  "b", "92"], ["93", "2021-08-31", "r", "b", "93"], ["94", "2021-09-21", "r", "b", "94"], ["95", "2021-10-19", "r", "b", "95"], ["96", "2021\
-11-15", "r", "b", "96"], ["97", "2022-01-04", "r", "b", "97"], ["98", "2022-02-01", "r", "b", "98"], ["99", "2022-03-01", "r", "b", "99"], [
  "100", "2022-03-29", "r", "b", "100"], ["101", "2022-04-26", "r", "b", "101"], ["102", "2022-05-24", "r", "b", "102"], ["103", "2022-06-21",
  "r", "b", "103"], ["104", "2022-08-02", "r", "b", "104"], ["105", "2022-09-02", "r", "b", "105"], ["106", "2022-09-27", "r", "b", "106"], [
  "107", "2022-10-25", "r", "b", "107"], ["108", "2022-11-29", "r", "b", "108"], ["109", "2023-01-10", "r", "b", "109"], ["110", "2023-02-07",
  "r", "b", "110"], ["111", "2023-03-01", "r", "b", "111"], ["112", "2023-04-04", "r", "b", "112"], ["113", "2023-05-02", "r", "b", "113"], [
  "114", "2023-05-30", "r", "b", "114"], ["115", "2023-07-21", "r", "b", "115"], ["116", "2023-08-15", "r", "b", "116"], ["117", "2023-09-12",
  "r", "b", "117"], ["118", "2023-10-10", "r", "b", "118"], ["119", "2023-10-31", "r", "b", "119"], ["120", "2023-12-05", "r", "b", "120"], [
  "121", "2024-01-23", "r", "b", "121"], ["122", "2024-02-20", "r", "b", "122"], ["123", "2024-03-19", "r", "b", "123"], ["124", "2024-04-16",
  "r", "b", "124"], ["125", "2024-05-14", "r", "b", "125"], ["126", "2024-06-11", "r", "b", "126"], ["127", "2024-07-23", "r", "b", "127"], [
  "128", "2024-08-20", "r", "b", "128"], ["129", "2024-09-17", "r", "b", "129"], ["130", "2024-10-15", "r", "b", "130"], ["131", "2024-11-12",
  "r", "b", "131"], ["132", "2025-01-14", "r", "b", "132"], ["133", "2025-02-04", "r", "b", "133"], ["134", "2025-03-04", "r", "b", "134"], [
  "135", "2025-04-01", "r", "b", "135"], ["136", "2025-04-29", "r", "b", "136"], ["137", "2025-05-27", "r", "b", "137"], ["138", "2025-06-24",
  "r", "b", "138"], ["139", "2025-08-05", "r", "b", "139"], ["140", "2025-09-02", "c", "b", "140"], ["141", "2025-09-30", "b", "b", "141"], [
  "142", "2025-10-28", "n", "b", "142"], ["143", null, "p", "b", "143"], ["1.5", "2009-04-27", "r", "w", "525.20"], ["2.2", "2010-05-20", "r",
  "w", "533.1"], ["4.4", "2013-12-09", "r", "b", "30"], ["4.4.3", "2014-06-02", "r", "b", "33"]] } }, K$e = { ya_android: { releases: [["1.0",
  "u", "u", "b", "25"], ["1.5", "u", "u", "b", "22"], ["1.6", "u", "u", "b", "25"], ["1.7", "u", "u", "b", "25"], ["1.20", "u", "u", "b", "2\
5"], ["2.5", "u", "u", "b", "25"], ["3.2", "u", "u", "b", "25"], ["4.6", "u", "u", "b", "25"], ["5.3", "u", "u", "b", "25"], ["5.4", "u", "u",
  "b", "25"], ["7.4", "u", "u", "b", "25"], ["9.6", "u", "u", "b", "25"], ["10.5", "u", "u", "b", "25"], ["11.4", "u", "u", "b", "25"], ["11\
.5", "u", "u", "b", "25"], ["12.7", "u", "u", "b", "25"], ["13.9", "u", "u", "b", "28"], ["13.10", "u", "u", "b", "28"], ["13.11", "u", "u",
  "b", "28"], ["13.12", "u", "u", "b", "30"], ["14.2", "u", "u", "b", "32"], ["14.4", "u", "u", "b", "33"], ["14.5", "u", "u", "b", "34"], [
  "14.7", "u", "u", "b", "35"], ["14.8", "u", "u", "b", "36"], ["14.10", "u", "u", "b", "37"], ["14.12", "u", "u", "b", "38"], ["15.2", "u",
  "u", "b", "40"], ["15.4", "u", "u", "b", "41"], ["15.6", "u", "u", "b", "42"], ["15.7", "u", "u", "b", "43"], ["15.9", "u", "u", "b", "44"],
  ["15.10", "u", "u", "b", "45"], ["15.12", "u", "u", "b", "46"], ["16.2", "u", "u", "b", "47"], ["16.3", "u", "u", "b", "47"], ["16.4", "u",
  "u", "b", "49"], ["16.6", "u", "u", "b", "50"], ["16.7", "u", "u", "b", "51"], ["16.9", "u", "u", "b", "52"], ["16.10", "u", "u", "b", "53"],
  ["16.11", "u", "u", "b", "54"], ["17.1", "u", "u", "b", "55"], ["17.3", "u", "u", "b", "56"], ["17.4", "u", "u", "b", "57"], ["17.6", "u",
  "u", "b", "58"], ["17.7", "u", "u", "b", "59"], ["17.9", "u", "u", "b", "60"], ["17.10", "u", "u", "b", "61"], ["17.11", "u", "u", "b", "6\
2"], ["18.1", "u", "u", "b", "63"], ["18.2", "u", "u", "b", "63"], ["18.3", "u", "u", "b", "64"], ["18.4", "u", "u", "b", "65"], ["18.6", "u",
  "u", "b", "66"], ["18.7", "u", "u", "b", "67"], ["18.9", "u", "u", "b", "68"], ["18.10", "u", "u", "b", "69"], ["18.11", "u", "u", "b", "7\
0"], ["19.1", "u", "u", "b", "71"], ["19.3", "u", "u", "b", "72"], ["19.4", "u", "u", "b", "73"], ["19.5", "u", "u", "b", "75"], ["19.6", "u",
  "u", "b", "75"], ["19.7", "u", "u", "b", "75"], ["19.9", "u", "u", "b", "76"], ["19.10", "u", "u", "b", "77"], ["19.11", "u", "u", "b", "7\
8"], ["19.12", "u", "u", "b", "78"], ["20.2", "u", "u", "b", "79"], ["20.3", "u", "u", "b", "80"], ["20.4", "u", "u", "b", "81"], ["20.6", "\
u", "u", "b", "81"], ["20.7", "u", "u", "b", "83"], ["20.8", "2020-09-02", "u", "b", "84"], ["20.9", "2020-09-27", "u", "b", "85"], ["20.11",
  "2020-11-11", "u", "b", "86"], ["20.12", "2020-12-20", "u", "b", "87"], ["21.1", "2021-12-31", "u", "b", "88"], ["21.2", "u", "u", "b", "8\
8"], ["21.3", "2021-04-04", "u", "b", "89"], ["21.5", "u", "u", "b", "90"], ["21.6", "2021-09-28", "u", "b", "91"], ["21.8", "2021-09-28", "\
u", "b", "92"], ["21.9", "2021-09-29", "u", "b", "93"], ["21.11", "2021-10-29", "u", "b", "94"], ["22.1", "2021-12-31", "u", "b", "96"], ["2\
2.3", "2022-03-25", "u", "b", "98"], ["22.4", "u", "u", "b", "92"], ["22.5", "2022-05-20", "u", "b", "100"], ["22.7", "2022-07-07", "u", "b",
  "102"], ["22.8", "u", "u", "b", "104"], ["22.9", "2022-08-27", "u", "b", "104"], ["22.11", "2022-11-11", "u", "b", "106"], ["23.1", "2023-\
01-10", "u", "b", "108"], ["23.3", "2023-03-26", "u", "b", "110"], ["23.5", "2023-05-19", "u", "b", "112"], ["23.7", "2023-07-06", "u", "b",
  "114"], ["23.9", "2023-09-13", "u", "b", "116"], ["23.11", "2023-11-15", "u", "b", "118"], ["24.1", "2024-01-18", "u", "b", "120"], ["24.2",
  "2024-03-25", "u", "b", "120"], ["24.4", "2024-03-27", "u", "b", "122"], ["24.6", "2024-06-04", "u", "b", "124"], ["24.7", "2024-07-18", "\
u", "b", "126"], ["24.9", "2024-10-01", "u", "b", "126"], ["24.10", "2024-10-11", "u", "b", "128"], ["24.12", "2024-11-30", "u", "b", "130"],
  ["25.2", "2025-04-24", "u", "b", "132"], ["25.3", "2025-04-23", "u", "b", "132"], ["25.4", "2025-04-23", "u", "b", "134"], ["25.6", "2025-\
09-04", "u", "b", "136"], ["25.8", "2025-08-30", "u", "b", "138"]] }, uc_android: { releases: [["10.5", "u", "u", "b", "31"], ["10.7", "u", "\
u", "b", "31"], ["10.8", "u", "u", "b", "31"], ["10.10", "u", "u", "b", "31"], ["11.0", "u", "u", "b", "31"], ["11.1", "u", "u", "b", "40"],
  ["11.2", "u", "u", "b", "40"], ["11.3", "u", "u", "b", "40"], ["11.4", "u", "u", "b", "40"], ["11.5", "u", "u", "b", "40"], ["11.6", "u", "\
u", "b", "57"], ["11.8", "u", "u", "b", "57"], ["11.9", "u", "u", "b", "57"], ["12.0", "u", "u", "b", "57"], ["12.1", "u", "u", "b", "57"], [
  "12.2", "u", "u", "b", "57"], ["12.3", "u", "u", "b", "57"], ["12.4", "u", "u", "b", "57"], ["12.5", "u", "u", "b", "57"], ["12.6", "u", "\
u", "b", "57"], ["12.7", "u", "u", "b", "57"], ["12.8", "u", "u", "b", "57"], ["12.9", "u", "u", "b", "57"], ["12.10", "u", "u", "b", "57"],
  ["12.11", "u", "u", "b", "57"], ["12.12", "u", "u", "b", "57"], ["12.13", "u", "u", "b", "57"], ["12.14", "u", "u", "b", "57"], ["13.0", "\
u", "u", "b", "57"], ["13.1", "u", "u", "b", "57"], ["13.2", "u", "u", "b", "57"], ["13.3", "2020-09-09", "u", "b", "78"], ["13.4", "2021-09\
-28", "u", "b", "78"], ["13.5", "2023-08-25", "u", "b", "78"], ["13.6", "2023-12-17", "u", "b", "78"], ["13.7", "2023-06-24", "u", "b", "78"],
  ["13.8", "2022-04-30", "u", "b", "78"], ["13.9", "2022-05-18", "u", "b", "78"], ["15.0", "2022-08-24", "u", "b", "78"], ["15.1", "2022-11-\
11", "u", "b", "78"], ["15.2", "2023-04-23", "u", "b", "78"], ["15.3", "2023-03-17", "u", "b", "100"], ["15.4", "2023-10-25", "u", "b", "100"],
  ["15.5", "2023-08-22", "u", "b", "100"], ["16.0", "2023-08-24", "u", "b", "100"], ["16.1", "2023-10-15", "u", "b", "100"], ["16.2", "2023-\
12-09", "u", "b", "100"], ["16.3", "2024-03-08", "u", "b", "100"], ["16.4", "2024-10-03", "u", "b", "100"], ["16.5", "2024-05-30", "u", "b",
  "100"], ["16.6", "2024-07-23", "u", "b", "100"], ["17.0", "2024-08-24", "u", "b", "100"], ["17.1", "2024-09-26", "u", "b", "100"], ["17.2",
  "2024-11-29", "u", "b", "100"], ["17.3", "2025-01-07", "u", "b", "100"], ["17.4", "2025-02-26", "u", "b", "100"], ["17.5", "2025-04-08", "\
u", "b", "100"], ["17.6", "2025-05-15", "u", "b", "123"], ["17.7", "2025-06-11", "u", "b", "123"], ["17.8", "2025-07-30", "u", "b", "123"], [
  "18.0", "2025-08-17", "u", "b", "123"]] }, qq_android: { releases: [["6.0", "u", "u", "b", "37"], ["6.1", "u", "u", "b", "37"], ["6.2", "u",
  "u", "b", "37"], ["6.3", "u", "u", "b", "37"], ["6.4", "u", "u", "b", "37"], ["6.6", "u", "u", "b", "37"], ["6.7", "u", "u", "b", "37"], [
  "6.8", "u", "u", "b", "37"], ["6.9", "u", "u", "b", "37"], ["7.0", "u", "u", "b", "37"], ["7.1", "u", "u", "b", "37"], ["7.2", "u", "u", "\
b", "37"], ["7.3", "u", "u", "b", "37"], ["7.4", "u", "u", "b", "37"], ["7.5", "u", "u", "b", "37"], ["7.6", "u", "u", "b", "37"], ["7.7", "\
u", "u", "b", "37"], ["7.8", "u", "u", "b", "37"], ["7.9", "u", "u", "b", "37"], ["8.0", "u", "u", "b", "37"], ["8.1", "u", "u", "b", "57"],
  ["8.2", "u", "u", "b", "57"], ["8.3", "u", "u", "b", "57"], ["8.4", "u", "u", "b", "57"], ["8.5", "u", "u", "b", "57"], ["8.6", "u", "u", "\
b", "57"], ["8.7", "u", "u", "b", "57"], ["8.8", "u", "u", "b", "57"], ["8.9", "u", "u", "b", "57"], ["9.1", "u", "u", "b", "57"], ["9.6", "\
u", "u", "b", "66"], ["9.7", "u", "u", "b", "66"], ["9.8", "u", "u", "b", "66"], ["10.0", "u", "u", "b", "66"], ["10.1", "u", "u", "b", "66"],
  ["10.2", "u", "u", "b", "66"], ["10.3", "u", "u", "b", "66"], ["10.4", "u", "u", "b", "66"], ["10.5", "u", "u", "b", "66"], ["10.7", "2020\
-09-09", "u", "b", "66"], ["10.9", "2020-11-22", "u", "b", "77"], ["11.0", "u", "u", "b", "77"], ["11.2", "2021-01-30", "u", "b", "77"], ["1\
1.3", "2021-03-31", "u", "b", "77"], ["11.7", "2021-11-02", "u", "b", "89"], ["11.9", "u", "u", "b", "89"], ["12.0", "2021-11-04", "u", "b",
  "89"], ["12.1", "2021-11-05", "u", "b", "89"], ["12.2", "2021-12-07", "u", "b", "89"], ["12.5", "2022-04-07", "u", "b", "89"], ["12.7", "2\
022-05-21", "u", "b", "89"], ["12.8", "2022-06-30", "u", "b", "89"], ["12.9", "2022-07-26", "u", "b", "89"], ["13.0", "2022-08-15", "u", "b",
  "89"], ["13.1", "2022-09-10", "u", "b", "89"], ["13.2", "2022-10-26", "u", "b", "89"], ["13.3", "2022-11-09", "u", "b", "89"], ["13.4", "2\
023-04-26", "u", "b", "98"], ["13.5", "2023-02-06", "u", "b", "98"], ["13.6", "2023-02-09", "u", "b", "98"], ["13.7", "2023-04-21", "u", "b",
  "98"], ["13.8", "2023-04-21", "u", "b", "98"], ["14.0", "2023-12-12", "u", "b", "98"], ["14.1", "2023-07-16", "u", "b", "98"], ["14.2", "2\
023-10-14", "u", "b", "109"], ["14.3", "2023-09-13", "u", "b", "109"], ["14.4", "2023-10-31", "u", "b", "109"], ["14.5", "2023-11-12", "u", "\
b", "109"], ["14.6", "2023-12-24", "u", "b", "109"], ["14.7", "2024-01-18", "u", "b", "109"], ["14.8", "2024-03-04", "u", "b", "109"], ["14.\
9", "2024-04-09", "u", "b", "109"], ["15.0", "2024-04-17", "u", "b", "109"], ["15.1", "2024-05-18", "u", "b", "109"], ["15.2", "2024-10-24",
  "u", "b", "109"], ["15.3", "2024-07-28", "u", "b", "109"], ["15.4", "2024-09-07", "u", "b", "109"], ["15.5", "2024-09-24", "u", "b", "109"],
  ["15.6", "2024-10-24", "u", "b", "109"], ["15.7", "2024-12-03", "u", "b", "109"], ["15.8", "2024-12-11", "u", "b", "109"], ["15.9", "2025-\
02-01", "u", "b", "109"], ["19.1", "2025-07-08", "u", "b", "121"], ["19.2", "2025-07-15", "u", "b", "121"], ["19.3", "2025-08-31", "u", "b",
  "121"]] }, kai_os: { releases: [["1.0", "2017-03-01", "u", "g", "37"], ["2.0", "2017-07-01", "u", "g", "48"], ["2.5", "2017-07-01", "u", "\
g", "48"], ["3.0", "2021-09-01", "u", "g", "84"], ["3.1", "2022-03-01", "u", "g", "84"], ["4.0", "2025-05-01", "u", "g", "123"]] }, facebook_android: {
  releases: [["66", "u", "u", "b", "48"], ["68", "u", "u", "b", "48"], ["74", "u", "u", "b", "50"], ["75", "u", "u", "b", "50"], ["76", "u",
  "u", "b", "50"], ["77", "u", "u", "b", "50"], ["78", "u", "u", "b", "50"], ["79", "u", "u", "b", "50"], ["80", "u", "u", "b", "51"], ["81",
  "u", "u", "b", "51"], ["82", "u", "u", "b", "51"], ["83", "u", "u", "b", "51"], ["84", "u", "u", "b", "51"], ["86", "u", "u", "b", "51"], [
  "87", "u", "u", "b", "52"], ["88", "u", "u", "b", "52"], ["89", "u", "u", "b", "52"], ["90", "u", "u", "b", "52"], ["91", "u", "u", "b", "\
52"], ["92", "u", "u", "b", "52"], ["93", "u", "u", "b", "52"], ["94", "u", "u", "b", "52"], ["95", "u", "u", "b", "53"], ["96", "u", "u", "\
b", "53"], ["97", "u", "u", "b", "53"], ["98", "u", "u", "b", "53"], ["99", "u", "u", "b", "53"], ["100", "u", "u", "b", "54"], ["101", "u",
  "u", "b", "54"], ["103", "u", "u", "b", "54"], ["104", "u", "u", "b", "54"], ["105", "u", "u", "b", "54"], ["106", "u", "u", "b", "55"], [
  "107", "u", "u", "b", "55"], ["108", "u", "u", "b", "55"], ["109", "u", "u", "b", "55"], ["110", "u", "u", "b", "55"], ["111", "u", "u", "\
b", "55"], ["112", "u", "u", "b", "56"], ["113", "u", "u", "b", "56"], ["114", "u", "u", "b", "56"], ["115", "u", "u", "b", "56"], ["116", "\
u", "u", "b", "56"], ["117", "u", "u", "b", "57"], ["118", "u", "u", "b", "57"], ["119", "u", "u", "b", "57"], ["120", "u", "u", "b", "57"],
  ["121", "u", "u", "b", "57"], ["122", "u", "u", "b", "58"], ["123", "u", "u", "b", "58"], ["124", "u", "u", "b", "58"], ["125", "u", "u", "\
b", "58"], ["126", "u", "u", "b", "58"], ["127", "u", "u", "b", "58"], ["128", "u", "u", "b", "58"], ["129", "u", "u", "b", "58"], ["130", "\
u", "u", "b", "59"], ["131", "u", "u", "b", "59"], ["132", "u", "u", "b", "59"], ["133", "u", "u", "b", "59"], ["134", "u", "u", "b", "59"],
  ["135", "u", "u", "b", "59"], ["136", "u", "u", "b", "59"], ["137", "u", "u", "b", "59"], ["138", "u", "u", "b", "60"], ["140", "u", "u", "\
b", "60"], ["142", "u", "u", "b", "61"], ["143", "u", "u", "b", "61"], ["144", "u", "u", "b", "61"], ["145", "u", "u", "b", "61"], ["146", "\
u", "u", "b", "61"], ["147", "u", "u", "b", "61"], ["148", "u", "u", "b", "61"], ["149", "u", "u", "b", "62"], ["150", "u", "u", "b", "62"],
  ["151", "u", "u", "b", "62"], ["152", "u", "u", "b", "62"], ["153", "u", "u", "b", "63"], ["154", "u", "u", "b", "63"], ["155", "u", "u", "\
b", "63"], ["156", "u", "u", "b", "63"], ["157", "u", "u", "b", "64"], ["158", "u", "u", "b", "64"], ["159", "u", "u", "b", "64"], ["160", "\
u", "u", "b", "64"], ["161", "u", "u", "b", "64"], ["162", "u", "u", "b", "64"], ["163", "u", "u", "b", "65"], ["164", "u", "u", "b", "65"],
  ["165", "u", "u", "b", "65"], ["166", "u", "u", "b", "65"], ["167", "u", "u", "b", "65"], ["168", "u", "u", "b", "65"], ["169", "u", "u", "\
b", "66"], ["170", "u", "u", "b", "66"], ["171", "u", "u", "b", "66"], ["172", "u", "u", "b", "66"], ["173", "u", "u", "b", "66"], ["174", "\
u", "u", "b", "66"], ["175", "u", "u", "b", "67"], ["176", "u", "u", "b", "67"], ["177", "u", "u", "b", "67"], ["178", "u", "u", "b", "67"],
  ["180", "u", "u", "b", "67"], ["181", "u", "u", "b", "67"], ["182", "u", "u", "b", "67"], ["183", "u", "u", "b", "68"], ["184", "u", "u", "\
b", "68"], ["185", "u", "u", "b", "68"], ["186", "u", "u", "b", "68"], ["187", "u", "u", "b", "68"], ["188", "u", "u", "b", "68"], ["202", "\
u", "u", "b", "71"], ["227", "u", "u", "b", "75"], ["228", "u", "u", "b", "75"], ["229", "u", "u", "b", "75"], ["230", "u", "u", "b", "75"],
  ["231", "u", "u", "b", "75"], ["233", "u", "u", "b", "76"], ["235", "u", "u", "b", "76"], ["236", "u", "u", "b", "76"], ["237", "u", "u", "\
b", "76"], ["238", "u", "u", "b", "76"], ["240", "u", "u", "b", "77"], ["241", "u", "u", "b", "77"], ["242", "u", "u", "b", "77"], ["243", "\
u", "u", "b", "77"], ["244", "u", "u", "b", "78"], ["245", "u", "u", "b", "78"], ["246", "u", "u", "b", "78"], ["247", "u", "u", "b", "78"],
  ["248", "u", "u", "b", "78"], ["249", "u", "u", "b", "78"], ["250", "u", "u", "b", "78"], ["251", "u", "u", "b", "79"], ["252", "u", "u", "\
b", "79"], ["253", "u", "u", "b", "79"], ["254", "u", "u", "b", "79"], ["255", "u", "u", "b", "79"], ["256", "u", "u", "b", "80"], ["257", "\
u", "u", "b", "80"], ["258", "u", "u", "b", "80"], ["259", "u", "u", "b", "80"], ["260", "u", "u", "b", "80"], ["261", "u", "u", "b", "80"],
  ["262", "u", "u", "b", "80"], ["263", "u", "u", "b", "80"], ["264", "u", "u", "b", "80"], ["265", "u", "u", "b", "80"], ["266", "u", "u", "\
b", "81"], ["267", "u", "u", "b", "81"], ["268", "u", "u", "b", "81"], ["269", "u", "u", "b", "81"], ["270", "u", "u", "b", "81"], ["271", "\
u", "u", "b", "81"], ["272", "u", "u", "b", "83"], ["273", "u", "u", "b", "83"], ["274", "u", "u", "b", "83"], ["275", "u", "u", "b", "83"],
  ["297", "2020-12-02", "u", "b", "86"], ["348", "2021-12-19", "u", "b", "96"], ["399", "2023-02-04", "u", "b", "109"], ["400", "2023-02-10",
  "u", "b", "109"], ["420", "2023-06-28", "u", "b", "114"], ["430", "2023-09-03", "u", "b", "116"], ["434", "2023-10-05", "u", "b", "117"], [
  "436", "2023-10-13", "u", "b", "117"], ["437", "u", "u", "b", "118"], ["438", "2023-10-28", "u", "b", "118"], ["439", "2023-11-11", "u", "\
b", "119"], ["440", "2023-11-12", "u", "b", "119"], ["441", "2023-11-20", "u", "b", "119"], ["442", "2023-11-29", "u", "b", "119"], ["443", "\
2023-12-07", "u", "b", "120"], ["444", "2023-12-13", "u", "b", "120"], ["445", "2023-12-21", "u", "b", "120"], ["446", "2024-01-06", "u", "b",
  "120"], ["447", "2024-01-12", "u", "b", "120"], ["448", "2024-01-29", "u", "b", "121"], ["449", "2024-02-02", "u", "b", "121"], ["450", "2\
024-02-05", "u", "b", "121"], ["451", "2024-02-17", "u", "b", "121"], ["452", "2024-02-25", "u", "b", "122"], ["453", "2024-02-28", "u", "b",
  "122"], ["454", "2024-03-04", "u", "b", "122"], ["465", "2024-07-07", "u", "b", "126"], ["466", "u", "u", "b", "126"], ["469", "u", "u", "\
b", "126"], ["471", "2024-07-10", "u", "b", "126"], ["472", "2024-07-11", "u", "b", "126"], ["474", "2024-07-30", "u", "b", "127"], ["475", "\
2024-08-01", "u", "b", "127"], ["476", "2024-08-09", "u", "b", "127"], ["477", "2024-08-16", "u", "b", "127"], ["478", "2024-08-21", "u", "b",
  "128"], ["479", "2024-08-31", "u", "b", "128"], ["480", "2024-09-07", "u", "b", "128"], ["481", "2024-09-14", "u", "b", "128"], ["482", "2\
024-09-20", "u", "b", "129"], ["483", "2024-09-27", "u", "b", "129"], ["484", "2024-10-04", "u", "b", "129"], ["485", "2024-10-11", "u", "b",
  "129"], ["486", "2024-10-18", "u", "b", "130"], ["487", "2024-10-26", "u", "b", "130"], ["488", "2024-11-02", "u", "b", "130"], ["489", "2\
024-11-09", "u", "b", "130"], ["494", "2024-12-26", "u", "b", "131"], ["497", "2025-01-26", "u", "b", "132"], ["503", "2025-03-12", "u", "b",
  "134"], ["514", "2025-05-28", "u", "b", "136"], ["515", "2025-05-31", "u", "b", "137"]] }, instagram_android: { releases: [["23", "u", "u",
  "b", "62"], ["24", "u", "u", "b", "62"], ["25", "u", "u", "b", "62"], ["26", "u", "u", "b", "63"], ["27", "u", "u", "b", "63"], ["28", "u",
  "u", "b", "63"], ["29", "u", "u", "b", "63"], ["30", "u", "u", "b", "63"], ["31", "u", "u", "b", "64"], ["32", "u", "u", "b", "64"], ["33",
  "u", "u", "b", "64"], ["34", "u", "u", "b", "64"], ["35", "u", "u", "b", "65"], ["36", "u", "u", "b", "65"], ["37", "u", "u", "b", "65"], [
  "38", "u", "u", "b", "65"], ["39", "u", "u", "b", "65"], ["40", "u", "u", "b", "65"], ["41", "u", "u", "b", "65"], ["42", "u", "u", "b", "\
66"], ["43", "u", "u", "b", "66"], ["44", "u", "u", "b", "66"], ["45", "u", "u", "b", "66"], ["46", "u", "u", "b", "66"], ["47", "u", "u", "\
b", "66"], ["48", "u", "u", "b", "67"], ["49", "u", "u", "b", "67"], ["50", "u", "u", "b", "67"], ["51", "u", "u", "b", "67"], ["52", "u", "\
u", "b", "67"], ["53", "u", "u", "b", "67"], ["54", "u", "u", "b", "67"], ["55", "u", "u", "b", "67"], ["56", "u", "u", "b", "68"], ["57", "\
u", "u", "b", "68"], ["58", "u", "u", "b", "68"], ["59", "u", "u", "b", "68"], ["60", "u", "u", "b", "68"], ["61", "u", "u", "b", "68"], ["6\
5", "u", "u", "b", "69"], ["66", "u", "u", "b", "69"], ["68", "u", "u", "b", "69"], ["72", "u", "u", "b", "70"], ["74", "u", "u", "b", "71"],
  ["75", "u", "u", "b", "71"], ["79", "u", "u", "b", "71"], ["81", "u", "u", "b", "72"], ["82", "u", "u", "b", "72"], ["83", "u", "u", "b", "\
72"], ["84", "u", "u", "b", "73"], ["86", "u", "u", "b", "73"], ["95", "u", "u", "b", "74"], ["96", "u", "u", "b", "80"], ["97", "u", "u", "\
b", "80"], ["98", "u", "u", "b", "80"], ["103", "u", "u", "b", "80"], ["104", "u", "u", "b", "80"], ["117", "u", "u", "b", "80"], ["118", "u",
  "u", "b", "80"], ["119", "u", "u", "b", "80"], ["120", "u", "u", "b", "80"], ["121", "u", "u", "b", "80"], ["127", "u", "u", "b", "80"], [
  "128", "u", "u", "b", "80"], ["129", "u", "u", "b", "80"], ["130", "u", "u", "b", "80"], ["131", "u", "u", "b", "80"], ["132", "u", "u", "\
b", "80"], ["133", "u", "u", "b", "80"], ["134", "u", "u", "b", "80"], ["135", "u", "u", "b", "80"], ["136", "u", "u", "b", "80"], ["137", "\
u", "u", "b", "81"], ["138", "u", "u", "b", "81"], ["139", "u", "u", "b", "81"], ["140", "u", "u", "b", "81"], ["141", "u", "u", "b", "81"],
  ["142", "u", "u", "b", "81"], ["143", "u", "u", "b", "83"], ["144", "u", "u", "b", "83"], ["145", "u", "u", "b", "83"], ["146", "u", "u", "\
b", "83"], ["153", "u", "u", "b", "84"], ["163", "u", "u", "b", "92"], ["164", "u", "u", "b", "92"], ["230", "u", "u", "b", "92"], ["258", "\
2022-11-04", "u", "b", "106"], ["259", "2022-11-04", "u", "b", "106"], ["279", "2023-12-31", "u", "b", "109"], ["281", "u", "u", "b", "109"],
  ["288", "u", "u", "b", "114"], ["289", "2023-12-21", "u", "b", "114"], ["290", "2023-12-30", "u", "b", "114"], ["292", "u", "u", "b", "115"],
  ["295", "u", "u", "b", "115"], ["296", "u", "u", "b", "115"], ["297", "u", "u", "b", "115"], ["298", "2024-01-11", "u", "b", "115"], ["299",
  "u", "u", "b", "115"], ["300", "u", "u", "b", "116"], ["301", "2024-01-12", "u", "b", "116"], ["302", "u", "u", "b", "117"], ["303", "u", "\
u", "b", "117"], ["304", "u", "u", "b", "117"], ["305", "u", "u", "b", "117"], ["306", "2024-01-17", "u", "b", "118"], ["307", "u", "u", "b",
  "118"], ["308", "2024-01-19", "u", "b", "118"], ["309", "u", "u", "b", "119"], ["310", "u", "u", "b", "119"], ["311", "u", "u", "b", "120"],
  ["312", "u", "u", "b", "120"], ["313", "u", "u", "b", "120"], ["314", "u", "u", "b", "120"], ["315", "2024-01-19", "u", "b", "120"], ["316",
  "2024-01-25", "u", "b", "120"], ["317", "2024-02-03", "u", "b", "121"], ["318", "2024-02-16", "u", "b", "121"], ["320", "2024-03-04", "u",
  "b", "121"], ["321", "2024-03-07", "u", "b", "122"], ["338", "2024-07-06", "u", "b", "126"], ["346", "2024-09-01", "u", "b", "127"], ["347",
  "2024-09-11", "u", "b", "127"], ["349", "2024-09-20", "u", "b", "128"], ["355", "2024-11-06", "u", "b", "130"], ["366", "u", "u", "b", "13\
2"], ["367", "2025-02-15", "u", "b", "132"], ["378", "2025-05-03", "u", "b", "135"], ["381", "2025-06-19", "u", "b", "137"], ["382", "2025-0\
6-19", "u", "b", "137"], ["383", "2025-06-18", "u", "b", "137"], ["384", "2025-06-16", "u", "b", "137"], ["385", "2025-06-27", "u", "b", "13\
7"], ["387", "2025-07-09", "u", "b", "137"], ["390", "2025-07-26", "u", "b", "138"], ["392", "2025-08-12", "u", "b", "138"], ["394", "2025-0\
8-26", "u", "b", "139"], ["395", "2025-09-13", "u", "b", "139"]] } }, z$e = [["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\
1", si: "1" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1", fa: "4", s: "4", si: "3.2" }], ["2019-03-25", { c: "66", ca: "66", e: "1\
6", f: "57", fa: "57", s: "12.1", si: "12.2" }], ["2019-03-25", { c: "66", ca: "66", e: "16", f: "57", fa: "57", s: "12.1", si: "12.2" }], [
  "2024-03-19", { c: "116", ca: "116", e: "116", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2025-06-26", { c: "138", ca: "138", e: "13\
8", f: "118", fa: "118", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-0\
7-29", { c: "17", ca: "18", e: "12", f: "5", fa: "5", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1",
  si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-04-16", { c: "123", ca: "123", e: "123",
  f: "125", fa: "125", s: "17.4", si: "17.4" }], ["2020-01-15", { c: "37", ca: "37", e: "79", f: "27", fa: "27", s: "9.1", si: "9.3" }], ["2\
024-07-09", { c: "77", ca: "77", e: "79", f: "128", fa: "128", s: "17.4", si: "17.4" }], ["2016-06-07", { c: "32", ca: "30", e: "12", f: "47",
  fa: "47", s: "8", si: "8" }], ["2023-07-04", { c: "112", ca: "112", e: "112", f: "115", fa: "115", s: "16", si: "16" }], ["2015-09-30", { c: "\
43", ca: "43", e: "12", f: "16", fa: "16", s: "9", si: "9" }], ["2022-03-14", { c: "84", ca: "84", e: "84", f: "80", fa: "80", s: "15.4", si: "\
15.4" }], ["2023-10-24", { c: "103", ca: "103", e: "103", f: "119", fa: "119", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "\
12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-03-14", { c: "92", ca: "92", e: "92", f: "90", fa: "90", s: "15.4", si: "15.4" }], ["2023-0\
7-04", { c: "110", ca: "110", e: "110", f: "115", fa: "115", s: "16", si: "16" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "34", fa: "\
34", s: "10", si: "10" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "37", fa: "37", s: "10", si: "10" }], ["2016-09-20", { c: "45", ca: "\
45", e: "12", f: "37", fa: "37", s: "10", si: "10" }], ["2022-08-23", { c: "97", ca: "97", e: "97", f: "104", fa: "104", s: "15.4", si: "15.\
4" }], ["2020-01-15", { c: "69", ca: "69", e: "79", f: "62", fa: "62", s: "12", si: "12" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "\
38", fa: "38", s: "10", si: "10" }], ["2024-01-25", { c: "121", ca: "121", e: "121", f: "115", fa: "115", s: "16.4", si: "16.4" }], ["2024-0\
3-05", { c: "117", ca: "117", e: "117", f: "119", fa: "119", s: "17.4", si: "17.4" }], ["2016-09-20", { c: "47", ca: "47", e: "14", f: "43",
  fa: "43", s: "10", si: "10" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "5" }], ["2015-07-29", { c: "3", ca: "\
18", e: "12", f: "3", fa: "4", s: "4", si: "3.2" }], ["2018-05-09", { c: "66", ca: "66", e: "14", f: "60", fa: "60", s: "10", si: "10" }], [
  "2016-09-20", { c: "45", ca: "45", e: "12", f: "38", fa: "38", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "5", ca: "18",
  e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2021-09-20", { c: "88", ca: "88", e: "88", f: "89", fa: "89", s: "15", si: "15" }], ["20\
17-04-05", { c: "55", ca: "55", e: "15", f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2024-06-11", { c: "76", ca: "76", e: "79", f: "127",
  fa: "127", s: "13.1", si: "13.4" }], ["2020-01-15", { c: "63", ca: "63", e: "79", f: "55", fa: "55", s: "12", si: "12" }], ["2020-01-15", {
  c: "63", ca: "63", e: "79", f: "57", fa: "57", s: "12", si: "12" }], ["2025-04-01", { c: "133", ca: "133", e: "133", f: "137", fa: "137", s: "\
18.4", si: "18.4" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "3", ca: "18", e: "\
12", f: "3.5", fa: "4", s: "3.1", si: "3" }], ["2021-04-26", { c: "66", ca: "66", e: "79", f: "76", fa: "79", s: "14.1", si: "14.5" }], ["20\
23-02-09", { c: "110", ca: "110", e: "110", f: "86", fa: "86", s: "15", si: "15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "4", si: "3.2" }], ["2020-01-15", { c: "54", ca: "54", e: "79", f: "63", fa: "63", s: "10.1", si: "10.3" }], ["2024-01-26", { c: "85",
  ca: "85", e: "121", f: "93", fa: "93", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }],
  ["2022-03-14", { c: "37", ca: "37", e: "79", f: "47", fa: "47", s: "15.4", si: "15.4" }], ["2024-09-16", { c: "76", ca: "76", e: "79", f: "\
103", fa: "103", s: "18", si: "18" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "3.6", fa: "4", s: "1.3", si: "1" }], ["2022-03-14", {
  c: "1", ca: "18", e: "12", f: "25", fa: "25", s: "15.4", si: "15.4" }], ["2020-01-15", { c: "35", ca: "59", e: "79", f: "30", fa: "54", s: "\
8", si: "8" }], ["2015-07-29", { c: "21", ca: "25", e: "12", f: "22", fa: "22", s: "5.1", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "\
12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "3.6", fa: "4", s: "1.3", si: "1" }], ["2015-07-29",
  { c: "21", ca: "25", e: "12", f: "22", fa: "22", s: "5.1", si: "4" }], ["2015-07-29", { c: "25", ca: "25", e: "12", f: "13", fa: "14", s: "\
7", si: "7" }], ["2016-09-20", { c: "30", ca: "30", e: "12", f: "49", fa: "49", s: "8", si: "8" }], ["2015-07-29", { c: "21", ca: "25", e: "\
12", f: "9", fa: "18", s: "5.1", si: "4.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29",
  { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2016-09-20", { c: "30", ca: "30", e: "12", f: "4", fa: "4", s: "10", si: "\
10" }], ["2020-01-15", { c: "16", ca: "18", e: "79", f: "10", fa: "10", s: "6", si: "6" }], ["2015-07-29", { c: "\u226415", ca: "18", e: "12",
  f: "10", fa: "10", s: "\u22644", si: "\u22643.2" }], ["2018-04-12", { c: "39", ca: "42", e: "14", f: "31", fa: "31", s: "11.1", si: "11.3" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1.5", fa: "4", s: "4", si: "3.2" }], ["2020-09-16", { c: "67", ca: "67", e: "79", f: "68",
  fa: "68", s: "14", si: "14" }], ["2021-09-20", { c: "67", ca: "67", e: "79", f: "68", fa: "68", s: "15", si: "15" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3",
  si: "1" }], ["2017-02-01", { c: "56", ca: "56", e: "12", f: "50", fa: "50", s: "9.1", si: "9.3" }], ["2015-07-29", { c: "4", ca: "18", e: "\
12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "14", s: "1", si: "3" }], ["2015-07-29",
  { c: "10", ca: "18", e: "12", f: "4", fa: "4", s: "5.1", si: "5" }], ["2015-07-29", { c: "10", ca: "18", e: "12", f: "29", fa: "29", s: "5\
.1", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2022-03-14", { c: "54", ca: "54", e: "79",
  f: "38", fa: "38", s: "15.4", si: "15.4" }], ["2017-09-19", { c: "50", ca: "51", e: "15", f: "44", fa: "44", s: "11", si: "11" }], ["2015-\
07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "26", ca: "28", e: "12", f: "16", fa: "16", s: "\
7", si: "7" }], ["2023-06-06", { c: "110", ca: "110", e: "110", f: "114", fa: "114", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18",
  e: "12", f: "1.5", fa: "4", s: "2", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1.5", fa: "4", s: "2", si: "1" }], ["2024-\
09-16", { c: "99", ca: "99", e: "99", f: "28", fa: "28", s: "18", si: "18" }], ["2023-04-11", { c: "99", ca: "99", e: "99", f: "112", fa: "1\
12", s: "16.4", si: "16.4" }], ["2023-12-11", { c: "99", ca: "99", e: "99", f: "113", fa: "113", s: "17.2", si: "17.2" }], ["2023-04-11", { c: "\
99", ca: "99", e: "99", f: "112", fa: "112", s: "16.4", si: "16.4" }], ["2023-12-11", { c: "118", ca: "118", e: "118", f: "97", fa: "97", s: "\
17.2", si: "17.2" }], ["2020-01-15", { c: "51", ca: "51", e: "79", f: "43", fa: "43", s: "11", si: "11" }], ["2020-01-15", { c: "57", ca: "5\
7", e: "79", f: "53", fa: "53", s: "11.1", si: "11.3" }], ["2022-03-14", { c: "99", ca: "99", e: "99", f: "97", fa: "97", s: "15.4", si: "15\
.4" }], ["2020-01-15", { c: "49", ca: "49", e: "79", f: "47", fa: "47", s: "9", si: "9" }], ["2015-07-29", { c: "27", ca: "27", e: "12", f: "\
1", fa: "4", s: "7", si: "7" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2015-09-22", { c: "4", ca: "\
18", e: "12", f: "41", fa: "41", s: "5", si: "4.2" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1.5", fa: "4", s: "4", si: "4" }], ["\
2024-03-05", { c: "105", ca: "105", e: "105", f: "106", fa: "106", s: "17.4", si: "17.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2016-03-08", { c: "42", ca: "42", e: "13", f: "45", fa: "45", s: "9", si: "9" }], ["2023-09\
-18", { c: "117", ca: "117", e: "117", f: "63", fa: "63", s: "17", si: "17" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "71", fa: "7\
9", s: "13.1", si: "13" }], ["2020-01-15", { c: "55", ca: "55", e: "79", f: "49", fa: "49", s: "12.1", si: "12.2" }], ["2023-11-02", { c: "1\
19", ca: "119", e: "119", f: "54", fa: "54", s: "13.1", si: "13.4" }], ["2017-03-27", { c: "41", ca: "41", e: "12", f: "22", fa: "22", s: "1\
0.1", si: "10.3" }], ["2025-03-31", { c: "121", ca: "121", e: "121", f: "127", fa: "127", s: "18.4", si: "18.4" }], ["2015-07-29", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1",
  si: "1" }], ["2023-05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "15", si: "15" }], ["2023-02-14", { c: "58", ca: "58",
  e: "79", f: "110", fa: "110", s: "10", si: "10" }], ["2023-05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "16.2", si: "1\
6.2" }], ["2022-02-03", { c: "98", ca: "98", e: "98", f: "96", fa: "96", s: "13", si: "13" }], ["2020-01-15", { c: "53", ca: "53", e: "79", f: "\
31", fa: "31", s: "11.1", si: "11.3" }], ["2017-03-07", { c: "50", ca: "50", e: "12", f: "52", fa: "52", s: "9", si: "9" }], ["2020-07-28", {
  c: "50", ca: "50", e: "12", f: "71", fa: "79", s: "9", si: "9" }], ["2025-08-19", { c: "137", ca: "137", e: "137", f: "142", fa: "142", s: "\
17", si: "17" }], ["2017-04-19", { c: "26", ca: "26", e: "12", f: "53", fa: "53", s: "7", si: "7" }], ["2023-05-09", { c: "80", ca: "80", e: "\
80", f: "113", fa: "113", s: "16.4", si: "16.4" }], ["2020-11-17", { c: "69", ca: "69", e: "79", f: "83", fa: "83", s: "12.1", si: "12.2" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "4", fa: "4", s: "3", si: "1" }], ["2018-12-11", { c: "40", ca: "40", e: "18", f: "51", fa: "\
64", s: "10.1", si: "10.3" }], ["2023-03-27", { c: "73", ca: "73", e: "79", f: "101", fa: "101", s: "16.4", si: "16.4" }], ["2022-03-14", { c: "\
52", ca: "52", e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }], ["2022-09-12", { c: "105", ca: "105", e: "105", f: "101", fa: "101", s: "\
16", si: "16" }], ["2023-09-18", { c: "83", ca: "83", e: "83", f: "107", fa: "107", s: "17", si: "17" }], ["2022-03-14", { c: "52", ca: "52",
  e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }], ["2022-03-14", { c: "52", ca: "52", e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }],
  ["2022-03-14", { c: "52", ca: "52", e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }], ["2022-07-26", { c: "52", ca: "52", e: "79", f: "\
103", fa: "103", s: "15.4", si: "15.4" }], ["2023-02-14", { c: "105", ca: "105", e: "105", f: "110", fa: "110", s: "16", si: "16" }], ["2015\
-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "4", fa: "4", s: "\
\u22644", si: "\u22643.2" }], ["2025-03-04", { c: "51", ca: "51", e: "12", f: "136", fa: "136", s: "5.1", si: "5" }], ["2024-09-16", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "18", si: "18" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }],
  ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "3.2" }], ["2023-12-11", { c: "85", ca: "85", e: "85", f: "68",
  fa: "68", s: "17.2", si: "17.2" }], ["2023-09-18", { c: "91", ca: "91", e: "91", f: "33", fa: "33", s: "17", si: "17" }], ["2015-07-29", {
  c: "2", ca: "18", e: "12", f: "1", fa: "25", s: "3", si: "1" }], ["2023-12-11", { c: "59", ca: "59", e: "79", f: "98", fa: "98", s: "17.2",
  si: "17.2" }], ["2020-01-15", { c: "60", ca: "60", e: "79", f: "60", fa: "60", s: "13", si: "13" }], ["2016-08-02", { c: "25", ca: "25", e: "\
14", f: "23", fa: "23", s: "7", si: "7" }], ["2020-01-15", { c: "46", ca: "46", e: "79", f: "31", fa: "31", s: "10.1", si: "10.3" }], ["2015\
-09-30", { c: "28", ca: "28", e: "12", f: "22", fa: "22", s: "9", si: "9" }], ["2020-01-15", { c: "61", ca: "61", e: "79", f: "55", fa: "55",
  s: "11", si: "11" }], ["2015-07-29", { c: "16", ca: "18", e: "12", f: "4", fa: "4", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18",
  e: "12", f: "1.5", fa: "4", s: "4", si: "3.2" }], ["2017-04-05", { c: "49", ca: "49", e: "15", f: "31", fa: "31", s: "9.1", si: "9.3" }], [
  "2017-10-24", { c: "62", ca: "62", e: "14", f: "22", fa: "22", s: "10", si: "10" }], ["2015-07-29", { c: "\u22644", ca: "18", e: "12", f: "\
\u22642", fa: "4", s: "\u22643.1", si: "\u22642" }], ["2015-07-29", { c: "7", ca: "18", e: "12", f: "6", fa: "6", s: "5.1", si: "5" }], ["20\
15-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-02-20", { c: "111", ca: "111", e: "111", f: "123", fa: "\
123", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "4", fa: "4", s: "4", si: "5" }], ["2020-01-15", { c: "10", ca: "\
18", e: "79", f: "4", fa: "4", s: "5", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "60", ca: "60", e: "79",
  f: "55", fa: "55", s: "11.1", si: "11.3" }], ["2020-01-15", { c: "12", ca: "18", e: "79", f: "49", fa: "49", s: "6", si: "6" }], ["2024-09\
-03", { c: "120", ca: "120", e: "120", f: "130", fa: "130", s: "17.2", si: "17.2" }], ["2023-09-18", { c: "31", ca: "31", e: "12", f: "6", fa: "\
6", s: "17", si: "4.2" }], ["2015-07-29", { c: "15", ca: "18", e: "12", f: "1", fa: "4", s: "6", si: "6" }], ["2022-03-14", { c: "37", ca: "\
37", e: "79", f: "98", fa: "98", s: "15.4", si: "15.4" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "49", fa: "49", s: "16.4", si: "\
16.4" }], ["2023-08-01", { c: "17", ca: "18", e: "79", f: "116", fa: "116", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "58", ca: "58", e: "79", f: "53", fa: "53", s: "13", si: "13" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["\u22642017-04-05", { c: "1", ca: "18", e: "\u226415", f: "3", fa: "4", s: "\u22644",
  si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "\
12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "61", ca: "61", e: "79", f: "33", fa: "33", s: "11", si: "11" }], ["2020-01-15",
  { c: "1", ca: "18", e: "79", f: "1", fa: "4", s: "4", si: "3.2" }], ["2016-03-21", { c: "31", ca: "31", e: "12", f: "12", fa: "14", s: "9.\
1", si: "9.3" }], ["2019-09-19", { c: "14", ca: "18", e: "18", f: "20", fa: "20", s: "10.1", si: "13" }], ["2015-07-29", { c: "3", ca: "18",
  e: "12", f: "3.5", fa: "4", s: "4", si: "3.2" }], ["2022-05-03", { c: "98", ca: "98", e: "98", f: "100", fa: "100", s: "13.1", si: "13.4" }],
  ["2020-01-15", { c: "43", ca: "43", e: "79", f: "46", fa: "46", s: "11.1", si: "11.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15",
  { c: "1", ca: "18", e: "79", f: "1.5", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "3.1", si: "2" }], ["2019-03-25", { c: "42", ca: "42", e: "13", f: "38", fa: "38", s: "12.1", si: "12.2" }], ["2021-11-02", { c: "77",
  ca: "77", e: "79", f: "94", fa: "94", s: "13.1", si: "13.4" }], ["2021-09-20", { c: "93", ca: "93", e: "93", f: "91", fa: "91", s: "15", si: "\
15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1",
  fa: "4", s: "1", si: "1" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "118", fa: "118", s: "15.4", si: "15.4" }], ["2017-03-27",
  { c: "52", ca: "52", e: "14", f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2018-04-30", { c: "38", ca: "38", e: "17", f: "47", fa: "35",
  s: "9", si: "9" }], ["2021-09-20", { c: "56", ca: "56", e: "79", f: "51", fa: "51", s: "15", si: "15" }], ["2020-09-16", { c: "63", ca: "6\
3", e: "17", f: "47", fa: "36", s: "14", si: "14" }], ["2020-02-07", { c: "40", ca: "40", e: "80", f: "58", fa: "28", s: "9", si: "9" }], ["\
2016-06-07", { c: "34", ca: "34", e: "12", f: "47", fa: "47", s: "9.1", si: "9.3" }], ["2017-03-27", { c: "42", ca: "42", e: "14", f: "39", fa: "\
39", s: "10.1", si: "10.3" }], ["2023-03-27", { c: "80", ca: "80", e: "80", f: "90", fa: "90", s: "16.4", si: "16.4" }], ["2024-10-29", { c: "\
103", ca: "103", e: "103", f: "132", fa: "132", s: "17.2", si: "17.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u2264\
4", si: "\u22643.2" }], ["2015-07-29", { c: "8", ca: "18", e: "12", f: "4", fa: "4", s: "5.1", si: "5" }], ["2020-01-15", { c: "38", ca: "38",
  e: "79", f: "28", fa: "28", s: "10.1", si: "10.3" }], ["2021-04-26", { c: "89", ca: "89", e: "89", f: "82", fa: "82", s: "14.1", si: "14.5" }],
  ["2016-09-07", { c: "53", ca: "53", e: "12", f: "35", fa: "35", s: "9.1", si: "9.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1",
  fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2021-11-02", { c: "46", ca: "\
46", e: "79", f: "94", fa: "94", s: "11", si: "11" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["20\
15-09-30", { c: "29", ca: "29", e: "12", f: "20", fa: "20", s: "9", si: "9" }], ["2021-04-26", { c: "84", ca: "84", e: "84", f: "63", fa: "6\
3", s: "14.1", si: "14.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2025-04-04", { c: "135", ca: "\
135", e: "135", f: "129", fa: "129", s: "18.2", si: "18.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "24", fa: "24", s: "3.1", si: "\
2" }], ["2022-03-14", { c: "86", ca: "86", e: "86", f: "85", fa: "85", s: "15.4", si: "15.4" }], ["2020-01-15", { c: "60", ca: "60", e: "79",
  f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2020-01-15", { c: "60", ca: "60", e: "79", f: "58", fa: "58", s: "11.1", si: "11.3" }], ["2\
016-09-20", { c: "36", ca: "36", e: "14", f: "39", fa: "39", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1", si: "1" }], ["2021-09-07", { c: "56", ca: "56", e: "79", f: "92", fa: "92", s: "11", si: "11" }], ["2017-04-05", { c: "48", ca: "\
48", e: "15", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "33", ca: "33", e: "79", f: "32", fa: "32", s: "9", si: "9" }],
  ["2020-01-15", { c: "35", ca: "35", e: "79", f: "41", fa: "41", s: "10", si: "10" }], ["2020-03-24", { c: "79", ca: "79", e: "17", f: "62",
  fa: "62", s: "13.1", si: "13.4" }], ["2022-11-15", { c: "101", ca: "101", e: "101", f: "107", fa: "107", s: "15.4", si: "15.4" }], ["2015-\
07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1",
  si: "1" }], ["2024-07-25", { c: "127", ca: "127", e: "127", f: "118", fa: "118", s: "17", si: "17" }], ["2015-07-29", { c: "1", ca: "18", e: "\
12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-01-06", { c: "97", ca: "97", e: "97", f: "34", fa: "34", s: "9", si: "9" }], ["2023-03-27",
  { c: "97", ca: "97", e: "97", f: "111", fa: "111", s: "16.4", si: "16.4" }], ["2023-03-27", { c: "97", ca: "97", e: "97", f: "111", fa: "1\
11", s: "16.4", si: "16.4" }], ["2023-03-27", { c: "97", ca: "97", e: "97", f: "111", fa: "111", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-03-13", { c: "111", ca: "111", e: "111", f: "34", fa: "34", s: "9.1", si: "\
9.3" }], ["2020-01-15", { c: "52", ca: "52", e: "79", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "63", ca: "63", e: "79",
  f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "34", ca: "34", e: "79", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-\
01-15", { c: "52", ca: "52", e: "79", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2018-09-05", { c: "62", ca: "62", e: "17", f: "62", fa: "\
62", s: "11", si: "11" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-09-12", { c: "89", ca: "8\
9", e: "79", f: "89", fa: "89", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["202\
3-03-27", { c: "77", ca: "77", e: "79", f: "98", fa: "98", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "10", ca: "18", e: "12", f: "4", fa: "\
4", s: "5", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-27", { c: "35", ca: "35",
  e: "12", f: "29", fa: "32", s: "10.1", si: "10.3" }], ["2016-09-20", { c: "39", ca: "39", e: "13", f: "26", fa: "26", s: "10", si: "10" }],
  ["2015-07-29", { c: "5", ca: "18", e: "12", f: "3.5", fa: "4", s: "5", si: "\u22643" }], ["2015-07-29", { c: "11", ca: "18", e: "12", f: "\
3.5", fa: "4", s: "5.1", si: "5" }], ["2024-09-16", { c: "125", ca: "125", e: "125", f: "128", fa: "128", s: "18", si: "18" }], ["2020-01-15",
  { c: "71", ca: "71", e: "79", f: "65", fa: "65", s: "12.1", si: "12.2" }], ["2024-06-11", { c: "111", ca: "111", e: "111", f: "127", fa: "\
127", s: "16.2", si: "16.2" }], ["2015-07-29", { c: "26", ca: "26", e: "12", f: "3.6", fa: "4", s: "7", si: "7" }], ["2017-10-17", { c: "57",
  ca: "57", e: "16", f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2022-10-27", { c: "107", ca: "107", e: "107", f: "66", fa: "66", s: "16",
  si: "16" }], ["2022-03-14", { c: "37", ca: "37", e: "15", f: "48", fa: "48", s: "15.4", si: "15.4" }], ["2023-12-19", { c: "105", ca: "105",
  e: "105", f: "121", fa: "121", s: "15.4", si: "15.4" }], ["2020-03-24", { c: "74", ca: "74", e: "79", f: "67", fa: "67", s: "13.1", si: "1\
3.4" }], ["2015-07-29", { c: "16", ca: "18", e: "12", f: "11", fa: "14", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }],
  ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4" }], ["2020-01-15", { c: "54", ca: "54", e: "79", f: "63", fa: "\
63", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2020-01-15", { c: "65", ca: "6\
5", e: "79", f: "52", fa: "52", s: "12.1", si: "12.2" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "4", fa: "4", s: "7", si: "7" }], [
  "2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4",
  s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-09-30", { c: "41", ca: "41", e: "\
12", f: "36", fa: "36", s: "9", si: "9" }], ["2024-09-16", { c: "87", ca: "87", e: "87", f: "88", fa: "88", s: "18", si: "18" }], ["2022-04-\
28", { c: "101", ca: "101", e: "101", f: "96", fa: "96", s: "15", si: "15" }], ["2023-09-18", { c: "106", ca: "106", e: "106", f: "98", fa: "\
98", s: "17", si: "17" }], ["2023-09-18", { c: "88", ca: "55", e: "88", f: "43", fa: "43", s: "17", si: "17" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-10-03", { c: "106", ca: "106", e: "106", f: "97", fa: "97", s: "15.4", si: "15.4" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "5", ca: "18", e: "12",
  f: "17", fa: "17", s: "5", si: "4" }], ["2020-01-15", { c: "20", ca: "25", e: "79", f: "25", fa: "25", s: "6", si: "6" }], ["2015-07-29", {
  c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-04-13", { c: "81", ca: "81", e: "81", f: "26", fa: "26", s: "13.1",
  si: "13.4" }], ["2021-10-05", { c: "41", ca: "41", e: "79", f: "93", fa: "93", s: "10", si: "10" }], ["2023-09-18", { c: "113", ca: "113",
  e: "113", f: "89", fa: "89", s: "17", si: "17" }], ["2020-01-15", { c: "66", ca: "66", e: "79", f: "50", fa: "50", s: "11.1", si: "11.3" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1", si: "1" }], ["2023-03-27", { c: "89", ca: "89", e: "89", f: "108", fa: "108", s: "16.4", si: "16.4" }], ["2020-01-15", { c: "39",
  ca: "39", e: "79", f: "51", fa: "51", s: "10", si: "10" }], ["2021-09-20", { c: "58", ca: "58", e: "79", f: "51", fa: "51", s: "15", si: "\
15" }], ["2022-08-05", { c: "104", ca: "104", e: "104", f: "72", fa: "79", s: "14.1", si: "14.5" }], ["2023-04-11", { c: "102", ca: "102", e: "\
102", f: "112", fa: "112", s: "15.5", si: "15.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015\
-11-12", { c: "1", ca: "18", e: "13", f: "19", fa: "19", s: "1.2", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\
1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12",
  f: "3.6", fa: "4", s: "3", si: "1" }], ["2021-04-26", { c: "20", ca: "25", e: "12", f: "57", fa: "57", s: "14.1", si: "5" }], ["2015-07-29",
  { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "3" }], ["2020-01-15", { c: "1", ca: "18", e: "79", f: "6", fa: "6", s: "3.1", si: "\
2" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "3", fa: "4", s: "4", si: "3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "7", ca: "18", e: "\
12", f: "29", fa: "29", s: "5.1", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29",
  { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-16", { c: "4", ca: "57", e: "12", f: "23", fa: "52", s: "3.1",
  si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2021-12-07", { c: "66",
  ca: "66", e: "79", f: "95", fa: "79", s: "12.1", si: "12.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644",
  si: "\u22643.2" }], ["2018-12-11", { c: "41", ca: "41", e: "12", f: "64", fa: "64", s: "9", si: "9" }], ["2019-03-25", { c: "58", ca: "58",
  e: "16", f: "55", fa: "55", s: "12.1", si: "12.2" }], ["2017-09-28", { c: "24", ca: "25", e: "12", f: "29", fa: "56", s: "10", si: "10" }],
  ["2021-04-26", { c: "81", ca: "81", e: "81", f: "86", fa: "86", s: "14.1", si: "14.5" }], ["2025-03-04", { c: "129", ca: "129", e: "129", f: "\
136", fa: "136", s: "16.4", si: "16.4" }], ["2021-04-26", { c: "72", ca: "72", e: "79", f: "78", fa: "79", s: "14.1", si: "14.5" }], ["2020-\
09-16", { c: "74", ca: "74", e: "79", f: "75", fa: "79", s: "14", si: "14" }], ["2019-09-19", { c: "63", ca: "63", e: "18", f: "58", fa: "58",
  s: "13", si: "13" }], ["2020-09-16", { c: "71", ca: "71", e: "79", f: "76", fa: "79", s: "14", si: "14" }], ["2024-04-16", { c: "87", ca: "\
87", e: "87", f: "125", fa: "125", s: "14.1", si: "14.5" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "82", fa: "82", s: "14", si: "1\
4" }], ["2018-04-12", { c: "55", ca: "55", e: "15", f: "52", fa: "52", s: "11.1", si: "11.3" }], ["2020-01-15", { c: "41", ca: "41", e: "79",
  f: "36", fa: "36", s: "8", si: "8" }], ["2025-03-31", { c: "122", ca: "122", e: "122", f: "131", fa: "131", s: "18.4", si: "18.4" }], ["20\
15-07-29", { c: "38", ca: "38", e: "12", f: "13", fa: "14", s: "7", si: "7" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "1", fa: "4",
  s: "5", si: "4.2" }], ["2018-05-09", { c: "61", ca: "61", e: "16", f: "60", fa: "60", s: "11", si: "11" }], ["2023-06-06", { c: "80", ca: "\
80", e: "80", f: "114", fa: "114", s: "15", si: "15" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "4" }], [
  "2025-04-29", { c: "123", ca: "123", e: "123", f: "138", fa: "138", s: "17.2", si: "17.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "6", fa: "6", s: "1.2", si: "1" }], ["2023-05-\
09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "15", si: "15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4",
  s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1",
  si: "1" }], ["2020-01-15", { c: "48", ca: "48", e: "79", f: "50", fa: "50", s: "11", si: "11" }], ["2016-09-20", { c: "49", ca: "49", e: "\
14", f: "44", fa: "44", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-11-21",
  { c: "109", ca: "109", e: "109", f: "120", fa: "120", s: "16.4", si: "16.4" }], ["2024-05-13", { c: "123", ca: "123", e: "123", f: "120", fa: "\
120", s: "17.5", si: "17.5" }], ["2020-07-28", { c: "83", ca: "83", e: "83", f: "69", fa: "79", s: "13", si: "13" }], ["2015-07-29", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-12-11", { c: "113", ca: "113", e: "113", f: "112", fa: "112", s: "17.2", si: "\
17.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "46", ca: "46",
  e: "79", f: "39", fa: "39", s: "11.1", si: "11.3" }], ["2021-01-26", { c: "50", ca: "50", e: "79", f: "85", fa: "85", s: "11.1", si: "11.3" }],
  ["2020-01-15", { c: "65", ca: "65", e: "79", f: "50", fa: "50", s: "9", si: "9" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-12-19", { c: "\
77", ca: "77", e: "79", f: "121", fa: "121", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "6", s: "4",
  si: "3.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-09-16", { c: "85", ca: "85", e: "85",
  f: "79", fa: "79", s: "14", si: "14" }], ["2021-09-20", { c: "89", ca: "89", e: "89", f: "66", fa: "66", s: "15", si: "15" }], ["2015-07-2\
9", { c: "26", ca: "26", e: "12", f: "21", fa: "21", s: "7", si: "7" }], ["2015-07-29", { c: "38", ca: "38", e: "12", f: "13", fa: "14", s: "\
8", si: "8" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "7", ca: "18", e: "12",
  f: "4", fa: "4", s: "5.1", si: "5" }], ["2020-01-15", { c: "24", ca: "25", e: "79", f: "35", fa: "35", s: "7", si: "7" }], ["2023-12-07", {
  c: "120", ca: "120", e: "120", f: "53", fa: "53", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "9", ca: "18", e: "12", f: "6", fa: "6", s: "\
5.1", si: "5" }], ["2023-01-12", { c: "109", ca: "109", e: "109", f: "4", fa: "4", s: "5.1", si: "5" }], ["2022-04-28", { c: "101", ca: "101",
  e: "101", f: "63", fa: "63", s: "15.4", si: "15.4" }], ["2017-09-19", { c: "53", ca: "53", e: "12", f: "36", fa: "36", s: "11", si: "11" }],
  ["2020-02-04", { c: "80", ca: "80", e: "12", f: "42", fa: "42", s: "8", si: "12.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1",
  fa: "4", s: "3", si: "1" }], ["2023-03-27", { c: "104", ca: "104", e: "104", f: "102", fa: "102", s: "16.4", si: "16.4" }], ["2021-04-26",
  { c: "49", ca: "49", e: "79", f: "25", fa: "25", s: "14.1", si: "14" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\
3", si: "1" }], ["2023-03-27", { c: "60", ca: "60", e: "18", f: "57", fa: "57", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18",
  e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2018-10-02", { c: "6", ca: "18", e: "18", f: "56", fa: "56", s: "6", si: "10.3" }], ["2020\
-07-28", { c: "79", ca: "79", e: "79", f: "75", fa: "79", s: "13.1", si: "13.4" }], ["2020-01-15", { c: "46", ca: "46", e: "79", f: "66", fa: "\
66", s: "11", si: "11" }], ["2015-07-29", { c: "18", ca: "18", e: "12", f: "1", fa: "4", s: "1.3", si: "1" }], ["2020-01-15", { c: "41", ca: "\
41", e: "79", f: "32", fa: "32", s: "8", si: "8" }], ["2020-01-15", { c: "\u226479", ca: "\u226479", e: "79", f: "\u226423", fa: "\u226423",
  s: "\u22649.1", si: "\u22649.3" }], ["2022-09-02", { c: "105", ca: "105", e: "105", f: "103", fa: "103", s: "15.6", si: "15.6" }], ["2023-\
09-18", { c: "66", ca: "66", e: "79", f: "115", fa: "115", s: "17", si: "17" }], ["2022-09-12", { c: "55", ca: "55", e: "79", f: "72", fa: "\
79", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-07", { c: "50", ca: "5\
0", e: "12", f: "52", fa: "52", s: "9", si: "9" }], ["2015-07-29", { c: "26", ca: "26", e: "12", f: "14", fa: "14", s: "7", si: "7" }], ["20\
15-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\
1", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2021-10-25", { c: "57", ca: "57", e: "1\
2", f: "58", fa: "58", s: "15", si: "15.1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-12-11",
  { c: "120", ca: "120", e: "120", f: "117", fa: "117", s: "17.2", si: "17.2" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "84", fa: "\
84", s: "9", si: "9" }], ["2023-03-27", { c: "20", ca: "42", e: "14", f: "22", fa: "22", s: "7", si: "16.4" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "3.5", fa: "4", s: "3.1", si: "2" }], ["2023-05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "9", si: "9" }],
  ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "4", s: "3.1", si: "2" }], ["2020-09-16", { c: "85", ca: "85", e: "85", f: "79",
  fa: "79", s: "14", si: "14" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-07-28", { c: "75",
  ca: "75", e: "79", f: "70", fa: "79", s: "13", si: "13" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }],
  ["2020-01-15", { c: "32", ca: "32", e: "79", f: "36", fa: "36", s: "10", si: "10" }], ["2022-03-14", { c: "93", ca: "93", e: "93", f: "92",
  fa: "92", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "\
32", ca: "32", e: "79", f: "36", fa: "36", s: "10", si: "10" }], ["2015-07-29", { c: "24", ca: "25", e: "12", f: "24", fa: "24", s: "8", si: "\
8" }], ["2021-04-26", { c: "80", ca: "80", e: "80", f: "71", fa: "79", s: "14.1", si: "14.5" }], ["2015-07-29", { c: "10", ca: "18", e: "12",
  f: "10", fa: "10", s: "8", si: "8" }], ["2015-07-29", { c: "10", ca: "18", e: "12", f: "6", fa: "6", s: "8", si: "8" }], ["2015-07-29", { c: "\
29", ca: "29", e: "12", f: "24", fa: "24", s: "8", si: "8" }], ["2016-08-02", { c: "27", ca: "27", e: "14", f: "29", fa: "29", s: "8", si: "\
8" }], ["2018-04-30", { c: "24", ca: "25", e: "17", f: "25", fa: "25", s: "8", si: "9" }], ["2021-04-26", { c: "35", ca: "35", e: "12", f: "\
25", fa: "25", s: "14.1", si: "14.5" }], ["2023-03-27", { c: "69", ca: "69", e: "79", f: "105", fa: "105", s: "16.4", si: "16.4" }], ["2023-\
05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1.5",
  fa: "4", s: "4", si: "3.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "2", si: "1" }], ["\u22642020-03-24", { c: "\
\u226480", ca: "\u226480", e: "\u226480", f: "1.5", fa: "4", s: "\u226413.1", si: "\u226413.4" }], ["2020-01-15", { c: "66", ca: "66", e: "7\
9", f: "58", fa: "58", s: "11.1", si: "11.3" }], ["2023-03-27", { c: "108", ca: "109", e: "108", f: "111", fa: "111", s: "16.4", si: "16.4" }],
  ["2023-03-27", { c: "94", ca: "94", e: "94", f: "88", fa: "88", s: "16.4", si: "16.4" }], ["2017-04-05", { c: "1", ca: "18", e: "15", f: "\
1.5", fa: "4", s: "1.2", si: "1" }], ["\u22642018-10-02", { c: "10", ca: "18", e: "\u226418", f: "4", fa: "4", s: "7", si: "7" }], ["2023-09\
-18", { c: "113", ca: "113", e: "113", f: "66", fa: "66", s: "17", si: "17" }], ["2022-09-12", { c: "90", ca: "90", e: "90", f: "81", fa: "8\
1", s: "16", si: "16" }], ["2020-03-24", { c: "68", ca: "68", e: "79", f: "61", fa: "61", s: "13.1", si: "13.4" }], ["2018-10-02", { c: "23",
  ca: "25", e: "18", f: "49", fa: "49", s: "7", si: "7" }], ["2022-09-12", { c: "63", ca: "63", e: "18", f: "59", fa: "59", s: "16", si: "16" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1", si: "1" }], ["2019-01-29", { c: "50", ca: "50", e: "12", f: "65", fa: "65", s: "10", si: "10" }], ["2024-12-11", { c: "15", ca: "\
18", e: "79", f: "95", fa: "95", s: "18.2", si: "18.2" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "1.5", fa: "4", s: "5", si: "4" }],
  ["2015-07-29", { c: "33", ca: "33", e: "12", f: "18", fa: "18", s: "7", si: "7" }], ["2023-03-27", { c: "94", ca: "94", e: "94", f: "99", fa: "\
99", s: "16.4", si: "16.4" }], ["2015-09-16", { c: "6", ca: "18", e: "12", f: "7", fa: "7", s: "8", si: "9" }], ["2022-09-12", { c: "44", ca: "\
44", e: "79", f: "46", fa: "46", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["20\
16-03-21", { c: "38", ca: "38", e: "13", f: "38", fa: "38", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "57", ca: "57", e: "79", f: "51", fa: "\
51", s: "10.1", si: "10.3" }], ["2020-01-15", { c: "47", ca: "47", e: "79", f: "51", fa: "51", s: "9", si: "9" }], ["2015-07-29", { c: "2", ca: "\
18", e: "12", f: "3.6", fa: "4", s: "4", si: "3.2" }], ["2020-07-28", { c: "55", ca: "55", e: "12", f: "59", fa: "79", s: "13", si: "13" }],
  ["2025-01-27", { c: "116", ca: "116", e: "116", f: "125", fa: "125", s: "17", si: "18.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "3", fa: "4", s: "4", si: "3.2" }], ["2015-07-29", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "76", ca: "76", e: "79", f: "67", fa: "67", s: "\
12.1", si: "13" }], ["2022-05-31", { c: "96", ca: "96", e: "96", f: "101", fa: "101", s: "14.1", si: "14.5" }], ["2020-01-15", { c: "74", ca: "\
74", e: "79", f: "63", fa: "64", s: "10.1", si: "10.3" }], ["2023-12-11", { c: "73", ca: "73", e: "79", f: "78", fa: "79", s: "17.2", si: "1\
7.2" }], ["2023-12-11", { c: "86", ca: "86", e: "86", f: "101", fa: "101", s: "17.2", si: "17.2" }], ["2023-06-06", { c: "1", ca: "18", e: "\
12", f: "1", fa: "114", s: "1.1", si: "1" }], ["2025-05-01", { c: "136", ca: "136", e: "136", f: "97", fa: "97", s: "15.4", si: "15.4" }], [
  "2019-09-19", { c: "63", ca: "63", e: "12", f: "6", fa: "6", s: "13", si: "13" }], ["2015-07-29", { c: "6", ca: "18", e: "12", f: "6", fa: "\
6", s: "6", si: "7" }], ["2015-07-29", { c: "32", ca: "32", e: "12", f: "29", fa: "29", s: "8", si: "8" }], ["2020-07-28", { c: "76", ca: "7\
6", e: "79", f: "71", fa: "79", s: "13", si: "13" }], ["2020-09-16", { c: "85", ca: "85", e: "85", f: "79", fa: "79", s: "14", si: "14" }], [
  "2018-10-02", { c: "63", ca: "63", e: "18", f: "58", fa: "58", s: "11.1", si: "11.3" }], ["2025-01-07", { c: "128", ca: "128", e: "128", f: "\
134", fa: "134", s: "18.2", si: "18.2" }], ["2024-03-05", { c: "119", ca: "119", e: "119", f: "121", fa: "121", s: "17.4", si: "17.4" }], ["\
2016-09-20", { c: "49", ca: "49", e: "12", f: "18", fa: "18", s: "10", si: "10" }], ["2023-03-27", { c: "50", ca: "50", e: "17", f: "44", fa: "\
48", s: "16", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2020-03-24", { c: "63", ca: "\
63", e: "79", f: "49", fa: "49", s: "13.1", si: "13.4" }], ["2021-04-26", { c: "87", ca: "87", e: "87", f: "70", fa: "79", s: "14.1", si: "1\
4.5" }], ["2020-07-28", { c: "1", ca: "18", e: "13", f: "78", fa: "79", s: "4", si: "3.2" }], ["2021-09-20", { c: "85", ca: "85", e: "85", f: "\
87", fa: "87", s: "15", si: "15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2025-05-01", { c: "1\
36", ca: "136", e: "136", f: "134", fa: "134", s: "18.2", si: "18.2" }], ["2024-07-09", { c: "85", ca: "85", e: "85", f: "128", fa: "128", s: "\
16.4", si: "16.4" }], ["2024-09-16", { c: "125", ca: "125", e: "125", f: "128", fa: "128", s: "18", si: "18" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.6", fa: "4", s: "5", si: "4" }], ["2015\
-07-29", { c: "24", ca: "25", e: "12", f: "23", fa: "23", s: "7", si: "7" }], ["2023-03-27", { c: "69", ca: "69", e: "79", f: "99", fa: "99",
  s: "16.4", si: "16.4" }], ["2024-10-29", { c: "83", ca: "83", e: "83", f: "132", fa: "132", s: "15.4", si: "15.4" }], ["2025-05-27", { c: "\
134", ca: "134", e: "134", f: "139", fa: "139", s: "18.4", si: "18.4" }], ["2024-07-09", { c: "111", ca: "111", e: "111", f: "128", fa: "128",
  s: "16.4", si: "16.4" }], ["2020-07-28", { c: "64", ca: "64", e: "79", f: "69", fa: "79", s: "13.1", si: "13.4" }], ["2022-09-12", { c: "6\
8", ca: "68", e: "79", f: "62", fa: "62", s: "16", si: "16" }], ["2018-10-23", { c: "1", ca: "18", e: "12", f: "63", fa: "63", s: "3", si: "\
1" }], ["2023-03-27", { c: "54", ca: "54", e: "17", f: "45", fa: "45", s: "16.4", si: "16.4" }], ["2017-09-19", { c: "29", ca: "29", e: "12",
  f: "35", fa: "35", s: "11", si: "11" }], ["2020-07-27", { c: "84", ca: "84", e: "84", f: "67", fa: "67", s: "9.1", si: "9.3" }], ["2020-01\
-15", { c: "65", ca: "65", e: "79", f: "52", fa: "52", s: "12.1", si: "12.2" }], ["2023-11-21", { c: "111", ca: "111", e: "111", f: "120", fa: "\
120", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-05-17", { c: "125", ca: "\
125", e: "125", f: "118", fa: "118", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "38", fa: "38", s: "5", si: "4\
.2" }], ["2024-12-11", { c: "128", ca: "128", e: "128", f: "38", fa: "38", s: "18.2", si: "18.2" }], ["2024-12-11", { c: "84", ca: "84", e: "\
84", f: "38", fa: "38", s: "18.2", si: "18.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }],
  ["2020-01-15", { c: "69", ca: "69", e: "79", f: "65", fa: "65", s: "11.1", si: "11.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "27", ca: "27", e: "79", f: "32", fa: "32", s: "7", si: "7" }], ["2015-07\
-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-03-27", { c: "38", ca: "39", e: "79", f: "43", fa: "43", s: "\
16.4", si: "16.4" }], ["2025-03-31", { c: "84", ca: "84", e: "84", f: "126", fa: "126", s: "16.4", si: "18.4" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "113", fa: "113", s: "17", si: "17" }],
  ["2022-03-14", { c: "61", ca: "61", e: "79", f: "36", fa: "36", s: "15.4", si: "15.4" }], ["2020-09-16", { c: "61", ca: "61", e: "79", f: "\
36", fa: "36", s: "14", si: "14" }], ["2020-01-15", { c: "1", ca: "18", e: "79", f: "1", fa: "4", s: "3", si: "1" }], ["2020-01-15", { c: "6\
9", ca: "69", e: "79", f: "68", fa: "68", s: "11", si: "11" }], ["2024-10-01", { c: "80", ca: "80", e: "80", f: "131", fa: "131", s: "16.1",
  si: "16.1" }], ["2024-12-11", { c: "94", ca: "94", e: "94", f: "97", fa: "97", s: "18.2", si: "18.2" }], ["2024-12-11", { c: "121", ca: "1\
21", e: "121", f: "64", fa: "64", s: "18.2", si: "18.2" }], ["2023-10-13", { c: "118", ca: "118", e: "118", f: "118", fa: "118", s: "17", si: "\
17" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4",
  fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-07", { c: "11", ca: "\
18", e: "12", f: "52", fa: "52", s: "5.1", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["20\
20-01-15", { c: "6", ca: "18", e: "79", f: "6", fa: "45", s: "5", si: "5" }], ["2023-03-27", { c: "65", ca: "65", e: "79", f: "61", fa: "61",
  s: "16.4", si: "16.4" }], ["2018-04-30", { c: "45", ca: "45", e: "17", f: "44", fa: "44", s: "11.1", si: "11.3" }], ["2015-07-29", { c: "3\
8", ca: "38", e: "12", f: "13", fa: "14", s: "8", si: "8" }], ["2024-06-11", { c: "122", ca: "122", e: "122", f: "127", fa: "127", s: "17", si: "\
17" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "5" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3\
.5", fa: "4", s: "4", si: "5" }], ["2020-01-15", { c: "53", ca: "53", e: "79", f: "63", fa: "63", s: "10", si: "10" }], ["2020-07-28", { c: "\
73", ca: "73", e: "79", f: "72", fa: "79", s: "13.1", si: "13.4" }], ["2020-01-15", { c: "37", ca: "37", e: "79", f: "62", fa: "62", s: "10.\
1", si: "10.3" }], ["2020-01-15", { c: "37", ca: "37", e: "79", f: "54", fa: "54", s: "10.1", si: "10.3" }], ["2021-12-13", { c: "68", ca: "\
89", e: "79", f: "79", fa: "79", s: "15.2", si: "15.2" }], ["2025-04-04", { c: "135", ca: "135", e: "135", f: "136", fa: "136", s: "18.4", si: "\
18.4" }], ["2020-01-15", { c: "53", ca: "53", e: "79", f: "63", fa: "63", s: "10", si: "10" }], ["2023-03-27", { c: "92", ca: "92", e: "92",
  f: "92", fa: "92", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }],
  ["2020-01-15", { c: "19", ca: "25", e: "79", f: "4", fa: "4", s: "6", si: "6" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "\
4", s: "3.1", si: "2" }], ["2020-01-15", { c: "18", ca: "18", e: "79", f: "55", fa: "55", s: "7", si: "7" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2018-09-05", { c: "33", ca: "33", e: "14", f: "49", fa: "62", s: "7", si: "7" }], ["201\
7-11-28", { c: "9", ca: "47", e: "12", f: "2", fa: "57", s: "5.1", si: "5" }], ["2020-01-15", { c: "60", ca: "60", e: "79", f: "55", fa: "55",
  s: "11.1", si: "11.3" }], ["2017-03-27", { c: "38", ca: "38", e: "13", f: "38", fa: "38", s: "10.1", si: "10.3" }], ["2020-01-15", { c: "7\
0", ca: "70", e: "79", f: "3", fa: "4", s: "10.1", si: "10.3" }], ["2024-08-06", { c: "117", ca: "117", e: "117", f: "129", fa: "129", s: "1\
7.5", si: "17.5" }], ["2024-05-17", { c: "125", ca: "125", e: "125", f: "126", fa: "126", s: "17.4", si: "17.4" }], ["2015-07-29", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-09-16", { c: "77", ca: "77", e: "79", f: "65", fa: "65", s: "14", si: "14" }],
  ["2019-09-19", { c: "56", ca: "56", e: "16", f: "59", fa: "59", s: "13", si: "13" }], ["2023-12-05", { c: "119", ca: "120", e: "85", f: "6\
5", fa: "65", s: "11.1", si: "11.3" }], ["2023-09-18", { c: "61", ca: "61", e: "79", f: "57", fa: "57", s: "17", si: "17" }], ["2022-06-28",
  { c: "67", ca: "67", e: "79", f: "102", fa: "102", s: "14.1", si: "14.5" }], ["2022-03-14", { c: "92", ca: "92", e: "92", f: "90", fa: "90",
  s: "15.4", si: "15.4" }], ["2015-09-30", { c: "41", ca: "41", e: "12", f: "29", fa: "29", s: "9", si: "9" }], ["2015-09-30", { c: "41", ca: "\
41", e: "12", f: "40", fa: "40", s: "9", si: "9" }], ["2020-01-15", { c: "73", ca: "73", e: "79", f: "67", fa: "67", s: "13", si: "13" }], [
  "2016-09-20", { c: "34", ca: "34", e: "12", f: "31", fa: "31", s: "10", si: "10" }], ["2017-04-05", { c: "57", ca: "57", e: "15", f: "48",
  fa: "48", s: "10", si: "10" }], ["2015-09-30", { c: "41", ca: "41", e: "12", f: "34", fa: "34", s: "9", si: "9" }], ["2015-09-30", { c: "4\
1", ca: "36", e: "12", f: "24", fa: "24", s: "9", si: "9" }], ["2020-08-27", { c: "85", ca: "85", e: "85", f: "77", fa: "79", s: "13.1", si: "\
13.4" }], ["2015-09-30", { c: "41", ca: "36", e: "12", f: "17", fa: "17", s: "9", si: "9" }], ["2020-01-15", { c: "66", ca: "66", e: "79", f: "\
61", fa: "61", s: "12", si: "12" }], ["2023-10-24", { c: "111", ca: "111", e: "111", f: "119", fa: "119", s: "16.4", si: "16.4" }], ["2015-0\
7-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644",
  si: "\u22643.2" }], ["2022-03-14", { c: "98", ca: "98", e: "98", f: "94", fa: "94", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-0\
7-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2023-09-15", { c: "117", ca: "117", e: "117", f: "7\
1", fa: "79", s: "16", si: "16" }], ["2015-09-30", { c: "28", ca: "28", e: "12", f: "22", fa: "22", s: "9", si: "9" }], ["2016-09-20", { c: "\
2", ca: "18", e: "12", f: "49", fa: "49", s: "4", si: "3.2" }], ["2020-01-15", { c: "1", ca: "18", e: "79", f: "3", fa: "4", s: "3", si: "2" }],
  ["2015-07-29", { c: "5", ca: "18", e: "12", f: "3", fa: "4", s: "6", si: "6" }], ["2015-09-30", { c: "38", ca: "38", e: "12", f: "36", fa: "\
36", s: "9", si: "9" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2021-08-10", { c: "42", ca: "42",
  e: "79", f: "91", fa: "91", s: "13.1", si: "13.4" }], ["2018-10-02", { c: "1", ca: "18", e: "18", f: "1.5", fa: "4", s: "3.1", si: "2" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1.3", si: "2" }], ["2024-12-11", { c: "89", ca: "89", e: "89", f: "131", fa: "131", s: "18.2", si: "18.2" }], ["2015-11-12", { c: "2\
6", ca: "26", e: "13", f: "22", fa: "22", s: "8", si: "8" }], ["2020-01-15", { c: "62", ca: "62", e: "79", f: "53", fa: "53", s: "11", si: "\
11" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-09-12", { c: "47", ca: "47", e: "12", f: "49",
  fa: "49", s: "16", si: "16" }], ["2022-03-14", { c: "48", ca: "48", e: "79", f: "48", fa: "48", s: "15.4", si: "15.4" }], ["2015-07-29", {
  c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-03-03", { c: "99", ca: "99", e: "99", f: "46", fa: "46", s: "7", si: "\
7" }], ["2020-01-15", { c: "38", ca: "38", e: "79", f: "19", fa: "19", s: "10.1", si: "10.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12",
  f: "1", fa: "4", s: "1", si: "1" }], ["2020-09-16", { c: "48", ca: "48", e: "79", f: "41", fa: "41", s: "14", si: "14" }], ["2015-07-29", {
  c: "1", ca: "18", e: "12", f: "7", fa: "7", s: "1.3", si: "1" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "3.5", fa: "4", s: "1.1",
  si: "1" }], ["2017-04-05", { c: "4", ca: "18", e: "15", f: "49", fa: "49", s: "3", si: "2" }], ["2015-07-29", { c: "23", ca: "25", e: "12",
  f: "31", fa: "31", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-11-19", { c: "\
87", ca: "87", e: "87", f: "70", fa: "79", s: "12.1", si: "12.2" }], ["2020-07-28", { c: "33", ca: "33", e: "12", f: "74", fa: "79", s: "12.\
1", si: "12.2" }], ["2024-03-19", { c: "114", ca: "114", e: "114", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2024-05-13", { c: "114",
  ca: "114", e: "114", f: "121", fa: "121", s: "17.5", si: "17.5" }], ["2024-10-17", { c: "130", ca: "130", e: "130", f: "124", fa: "124", s: "\
17.4", si: "17.4" }], ["2024-03-19", { c: "114", ca: "114", e: "114", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2024-10-17", { c: "13\
0", ca: "130", e: "130", f: "121", fa: "121", s: "17.5", si: "17.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644",
  si: "\u22643" }], ["2017-10-24", { c: "62", ca: "62", e: "14", f: "22", fa: "22", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18",
  e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }],
  ["2021-09-20", { c: "89", ca: "89", e: "89", f: "89", fa: "89", s: "15", si: "15" }], ["2019-09-19", { c: "36", ca: "36", e: "12", f: "52",
  fa: "52", s: "13", si: "9.3" }], ["2024-03-05", { c: "114", ca: "114", e: "114", f: "122", fa: "122", s: "17.4", si: "17.4" }], ["2024-04-\
16", { c: "118", ca: "118", e: "118", f: "125", fa: "125", s: "13.1", si: "13.4" }], ["2015-09-30", { c: "36", ca: "36", e: "12", f: "16", fa: "\
16", s: "9", si: "9" }], ["2022-03-14", { c: "36", ca: "36", e: "12", f: "16", fa: "16", s: "15.4", si: "15.4" }], ["2024-08-06", { c: "117",
  ca: "117", e: "117", f: "129", fa: "129", s: "17.4", si: "17.4" }], ["2015-09-30", { c: "26", ca: "26", e: "12", f: "16", fa: "16", s: "9",
  si: "9" }], ["2023-03-14", { c: "19", ca: "25", e: "79", f: "111", fa: "111", s: "6", si: "6" }], ["2023-03-13", { c: "111", ca: "111", e: "\
111", f: "108", fa: "108", s: "15.4", si: "15.4" }], ["2023-07-21", { c: "115", ca: "115", e: "115", f: "70", fa: "79", s: "15", si: "15" }],
  ["2016-09-20", { c: "45", ca: "45", e: "12", f: "38", fa: "38", s: "10", si: "10" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "37",
  fa: "37", s: "10", si: "10" }], ["2015-07-29", { c: "7", ca: "18", e: "12", f: "4", fa: "4", s: "5.1", si: "4.2" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2025-09-05", { c: "140", ca: "140", e: "140", f: "133", fa: "133", s: "18.2", si: "\
18.2" }], ["2015-09-30", { c: "44", ca: "44", e: "12", f: "40", fa: "40", s: "9", si: "9" }], ["2016-03-21", { c: "41", ca: "41", e: "13", f: "\
27", fa: "27", s: "9.1", si: "9.3" }], ["2023-09-18", { c: "113", ca: "113", e: "113", f: "102", fa: "102", s: "17", si: "17" }], ["2018-04-\
30", { c: "44", ca: "44", e: "17", f: "48", fa: "48", s: "10.1", si: "10.3" }], ["2015-07-29", { c: "32", ca: "32", e: "12", f: "19", fa: "1\
9", s: "7", si: "7" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "115", fa: "115", s: "17", si: "17" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "2", si: "1" }], ["2023-11-21", { c: "72", ca: "72", e: "79", f: "120", fa: "120", s: "16.4", si: "16.4" }],
  ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "5" }], ["2023-11-02", { c: "119", ca: "119", e: "119", f: "88",
  fa: "88", s: "16.5", si: "16.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-\
07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-04-18", { c: "124", ca: "124", e: "124", f: "120", fa: "120",
  s: "17.4", si: "17.4" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "3.1", si: "3" }], ["2022-12-05", { c: "108", ca: "\
108", e: "108", f: "101", fa: "101", s: "15.4", si: "15.4" }], ["2017-10-17", { c: "26", ca: "26", e: "16", f: "19", fa: "19", s: "7", si: "\
7" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1.3", si: "1" }], ["2021-08-10", { c: "61", ca: "61", e: "79", f: "9\
1", fa: "68", s: "13", si: "13" }], ["2017-10-17", { c: "57", ca: "57", e: "16", f: "52", fa: "52", s: "11", si: "11" }], ["2021-04-26", { c: "\
85", ca: "85", e: "85", f: "78", fa: "79", s: "14.1", si: "14.5" }], ["2021-10-25", { c: "75", ca: "75", e: "79", f: "78", fa: "79", s: "15.\
1", si: "15.1" }], ["2022-05-03", { c: "95", ca: "95", e: "95", f: "100", fa: "100", s: "15.2", si: "15.2" }], ["2024-03-05", { c: "114", ca: "\
114", e: "114", f: "112", fa: "112", s: "17.4", si: "17.4" }], ["2024-12-11", { c: "119", ca: "119", e: "119", f: "120", fa: "120", s: "18.2",
  si: "18.2" }], ["2020-10-20", { c: "86", ca: "86", e: "86", f: "78", fa: "79", s: "13.1", si: "13.4" }], ["2020-03-24", { c: "69", ca: "69",
  e: "79", f: "62", fa: "62", s: "13.1", si: "13.4" }], ["2021-10-25", { c: "75", ca: "75", e: "18", f: "64", fa: "64", s: "15.1", si: "15.1" }],
  ["2021-11-19", { c: "96", ca: "96", e: "96", f: "79", fa: "79", s: "15.1", si: "15.1" }], ["2021-04-26", { c: "69", ca: "69", e: "18", f: "\
62", fa: "62", s: "14.1", si: "14.5" }], ["2023-03-27", { c: "91", ca: "91", e: "91", f: "89", fa: "89", s: "16.4", si: "16.4" }], ["2024-12\
-11", { c: "112", ca: "112", e: "112", f: "121", fa: "121", s: "18.2", si: "18.2" }], ["2021-12-13", { c: "74", ca: "88", e: "79", f: "79", fa: "\
79", s: "15.2", si: "15.2" }], ["2024-09-16", { c: "119", ca: "119", e: "119", f: "120", fa: "120", s: "18", si: "18" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "4", si: "3.2" }], ["2021-04-26", { c: "84", ca: "84", e: "84", f: "79", fa: "79", s: "14.1", si: "\
14.5" }], ["2015-07-29", { c: "36", ca: "36", e: "12", f: "6", fa: "6", s: "8", si: "8" }], ["2015-09-30", { c: "36", ca: "36", e: "12", f: "\
34", fa: "34", s: "9", si: "9" }], ["2020-09-16", { c: "84", ca: "84", e: "84", f: "75", fa: "79", s: "14", si: "14" }], ["2021-04-26", { c: "\
35", ca: "35", e: "12", f: "25", fa: "25", s: "14.1", si: "14.5" }], ["2015-07-29", { c: "37", ca: "37", e: "12", f: "34", fa: "34", s: "11",
  si: "11" }], ["2022-03-14", { c: "69", ca: "69", e: "79", f: "96", fa: "96", s: "15.4", si: "15.4" }], ["2021-09-07", { c: "67", ca: "70",
  e: "18", f: "60", fa: "92", s: "13", si: "13" }], ["2023-10-24", { c: "85", ca: "85", e: "85", f: "119", fa: "119", s: "16", si: "16" }], [
  "2015-07-29", { c: "9", ca: "25", e: "12", f: "4", fa: "4", s: "5.1", si: "8" }], ["2021-09-20", { c: "63", ca: "63", e: "17", f: "30", fa: "\
30", s: "14", si: "15" }], ["2024-10-29", { c: "104", ca: "104", e: "104", f: "132", fa: "132", s: "16.4", si: "16.4" }], ["2020-01-15", { c: "\
47", ca: "47", e: "79", f: "53", fa: "53", s: "12", si: "12" }], ["2017-04-19", { c: "33", ca: "33", e: "12", f: "53", fa: "53", s: "9.1", si: "\
9.3" }], ["2020-09-16", { c: "47", ca: "47", e: "79", f: "56", fa: "56", s: "14", si: "14" }], ["2015-07-29", { c: "26", ca: "26", e: "12", f: "\
22", fa: "22", s: "8", si: "8" }], ["2018-04-30", { c: "26", ca: "26", e: "17", f: "22", fa: "22", s: "8", si: "8" }], ["2022-12-13", { c: "\
100", ca: "100", e: "100", f: "108", fa: "108", s: "16", si: "16" }], ["2021-09-20", { c: "56", ca: "58", e: "79", f: "51", fa: "51", s: "15",
  si: "15" }], ["2024-10-29", { c: "104", ca: "104", e: "104", f: "132", fa: "132", s: "16.4", si: "16.4" }], ["2020-09-16", { c: "9", ca: "\
18", e: "18", f: "65", fa: "65", s: "14", si: "14" }], ["2020-01-15", { c: "56", ca: "56", e: "79", f: "22", fa: "24", s: "11", si: "11" }],
  ["2023-05-09", { c: "76", ca: "76", e: "79", f: "113", fa: "113", s: "15.4", si: "15.4" }], ["2020-01-15", { c: "58", ca: "58", e: "79", f: "\
44", fa: "44", s: "11", si: "11" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "11", fa: "14", s: "5", si: "4.2" }], ["2015-07-29", { c: "\
23", ca: "25", e: "12", f: "31", fa: "31", s: "6", si: "8" }], ["2020-01-15", { c: "23", ca: "25", e: "79", f: "31", fa: "31", s: "6", si: "\
8" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "82", fa: "82", s: "14", si: "14" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "1", si: "1" }], ["2024-03-19", { c: "114", ca: "114", e: "114", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2015-07-29",
  { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "36", ca: "36", e: "79", f: "36", fa: "36", s: "9.1",
  si: "9.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-09-30", { c: "44", ca: "44", e: "12",
  f: "15", fa: "15", s: "9", si: "9" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-27", { c: "\
48", ca: "48", e: "12", f: "41", fa: "41", s: "10.1", si: "10.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "\
1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "3", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "1", ca: "18",
  e: "12", f: "3", fa: "4", s: "1", si: "1" }], ["2024-05-14", { c: "1", ca: "18", e: "12", f: "126", fa: "126", s: "3.1", si: "3" }]];
  1757772428821 < (/* @__PURE__ */ new Date()).setMonth((/* @__PURE__ */ new Date()).getMonth() - 2) && console.warn("[baseline-browser-mapp\
ing] The data in this module is over two months old.  To ensure accurate Baseline data, please update: `npm i baseline-browser-mapping@lates\
t -D`");
  var J$e = z$e, X$e = { w: "WebKit", g: "Gecko", p: "Presto", b: "Blink" }, Y$e = { r: "retired", c: "current", b: "beta", n: "nightly", p: "\
planned", u: "unknown", e: "esr" }, xW = /* @__PURE__ */ n((e) => {
    let t = {};
    return Object.entries(e).forEach(([r, i]) => {
      if (i.releases) {
        t[r] || (t[r] = { releases: {} });
        let s = t[r].releases;
        i.releases.forEach((a) => {
          s[a[0]] = { version: a[0], release_date: a[1] == "u" ? "unknown" : a[1], status: Y$e[a[2]], engine: a[3] ? X$e[a[3]] : void 0, engine_version: a[4] };
        });
      }
    }), t;
  }, "b"), G$e = (() => {
    let e = [];
    return J$e.forEach((t) => {
      var r;
      e.push({ status: { baseline_low_date: t[0], support: (r = t[1], { chrome: r.c, chrome_android: r.ca, edge: r.e, firefox: r.f, firefox_android: r.
      fa, safari: r.s, safari_ios: r.si }) } });
    }), e;
  })(), EW = xW(H$e), Z$e = xW(K$e), SW = ["chrome", "chrome_android", "edge", "firefox", "firefox_android", "safari", "safari_ios"], TW = Object.
  entries(EW).filter(([e]) => SW.includes(e)), Q$e = ["webview_android", "samsunginternet_android", "opera_android", "opera"], eVe = [...Object.
  entries(EW).filter(([e]) => Q$e.includes(e)), ...Object.entries(Z$e)], DW = ["current", "esr", "retired", "unknown", "beta", "nightly"], CW = !1,
  wW = /* @__PURE__ */ n((e) => {
    e.includeDownstreamBrowsers === !1 && e.includeKaiOS === !0 && (console.log(new Error("KaiOS is a downstream browser and can only be inc\
luded if you include other downstream browsers. Please ensure you use `includeDownstreamBrowsers: true`.")), process.exit(1));
  }, "p"), vW = /* @__PURE__ */ n((e) => e && e.startsWith("\u2264") ? e.slice(1) : e, "v"), Pi = /* @__PURE__ */ n((e, t) => {
    if (e === t) return 0;
    let [r = 0, i = 0] = e.split(".", 2).map(Number), [s = 0, a = 0] = t.split(".", 2).map(Number);
    if (isNaN(r) || isNaN(i)) throw new Error(`Invalid version: ${e}`);
    if (isNaN(s) || isNaN(a)) throw new Error(`Invalid version: ${t}`);
    return r !== s ? r > s ? 1 : -1 : i !== a ? i > a ? 1 : -1 : 0;
  }, "_"), tVe = /* @__PURE__ */ n((e) => {
    let t = [];
    return e.forEach((r) => {
      let i = TW.find((s) => s[0] === r.browser);
      i && Object.entries(i[1].releases).filter(([, s]) => DW.includes(s.status)).sort((s, a) => Pi(s[0], a[0])).forEach(([s, a]) => !!DW.includes(
      a.status) && Pi(s, r.version) === 1 && (t.push({ browser: r.browser, version: s, release_date: a.release_date ? a.release_date : "unkn\
own" }), !0));
    }), t;
  }, "h"), rVe = /* @__PURE__ */ n((e, t = !1) => {
    if (e.getFullYear() < 2015 && !CW && console.warn(new Error("There are no browser versions compatible with Baseline before 2015.  You ma\
y receive unexpected results.")), e.getFullYear() < 2002) throw new Error("None of the browsers in the core set were released before 2002.  \
Please use a date after 2002.");
    if (e.getFullYear() > (/* @__PURE__ */ new Date()).getFullYear()) throw new Error("There are no browser versions compatible with Baselin\
e in the future");
    let r = ((s) => G$e.filter((a) => a.status.baseline_low_date && new Date(a.status.baseline_low_date) <= s).map((a) => ({ baseline_low_date: a.
    status.baseline_low_date, support: a.status.support })))(e), i = ((s) => {
      let a = {};
      return Object.entries(TW).forEach(([, o]) => {
        a[o[0]] = { browser: o[0], version: "0", release_date: "" };
      }), s.forEach((o) => {
        Object.entries(o.support).forEach((u) => {
          let l = u[0], c = vW(u[1]);
          a[l] && Pi(c, vW(a[l].version)) === 1 && (a[l] = { browser: l, version: c, release_date: o.baseline_low_date });
        });
      }), Object.values(a);
    })(r);
    return t ? [...i, ...tVe(i)].sort((s, a) => s.browser < a.browser ? -1 : s.browser > a.browser ? 1 : Pi(s.version, a.version)) : i;
  }, "m"), AW = /* @__PURE__ */ n((e = [], t = !0, r = !1) => {
    let i = /* @__PURE__ */ n((u) => {
      var l;
      return e && e.length > 0 ? (l = e.filter((c) => c.browser === u).sort((c, f) => Pi(c.version, f.version))[0]) === null || l === void 0 ?
      void 0 : l.version : void 0;
    }, "r"), s = i("chrome"), a = i("firefox");
    if (!s && !a) throw new Error("There are no browser versions compatible with Baseline before Chrome and Firefox");
    let o = [];
    return eVe.filter(([u]) => !(u === "kai_os" && !r)).forEach(([u, l]) => {
      var c;
      if (!l.releases) return;
      let f = Object.entries(l.releases).filter(([, m]) => {
        let { engine: h, engine_version: d } = m;
        return !(!h || !d) && (h === "Blink" && s ? Pi(d, s) >= 0 : !(h !== "Gecko" || !a) && Pi(d, a) >= 0);
      }).sort((m, h) => Pi(m[0], h[0]));
      for (let m = 0; m < f.length; m++) {
        let h = f[m];
        if (h) {
          let [d, y] = h, p = { browser: u, version: d, release_date: (c = y.release_date) !== null && c !== void 0 ? c : "unknown" };
          if (y.engine && y.engine_version && (p.engine = y.engine, p.engine_version = y.engine_version), o.push(p), !t) break;
        }
      }
    }), o;
  }, "y");
  function Tp(e) {
    var t, r, i, s, a;
    let o = e ?? {}, u = { listAllCompatibleVersions: (t = o.listAllCompatibleVersions) !== null && t !== void 0 && t, includeDownstreamBrowsers: (r =
    o.includeDownstreamBrowsers) !== null && r !== void 0 && r, widelyAvailableOnDate: (i = o.widelyAvailableOnDate) !== null && i !== void 0 ?
    i : void 0, targetYear: (s = o.targetYear) !== null && s !== void 0 ? s : void 0, includeKaiOS: (a = o.includeKaiOS) !== null && a !== void 0 &&
    a }, l = /* @__PURE__ */ new Date();
    wW(u), u.widelyAvailableOnDate || u.targetYear ? u.targetYear && u.widelyAvailableOnDate ? (console.log(new Error("You cannot use target\
Year and widelyAvailableOnDate at the same time.  Please remove one of these options and try again.")), process.exit(1)) : u.widelyAvailableOnDate ?
    l = new Date(u.widelyAvailableOnDate) : u.targetYear && (l = /* @__PURE__ */ new Date(`${u.targetYear}-12-31`)) : l = /* @__PURE__ */ new Date(),
    (u.widelyAvailableOnDate || u.targetYear === void 0) && l.setMonth(l.getMonth() - 30);
    let c = rVe(l, u.listAllCompatibleVersions);
    return u.includeDownstreamBrowsers === !1 ? c : [...c, ...AW(c, u.listAllCompatibleVersions, u.includeKaiOS)];
  }
  n(Tp, "O");
  MA.getAllVersions = function(e) {
    var t, r, i, s;
    CW = !0;
    let a = e ?? {}, o = { outputFormat: (t = a.outputFormat) !== null && t !== void 0 ? t : "array", includeDownstreamBrowsers: (r = a.includeDownstreamBrowsers) !==
    null && r !== void 0 && r, useSupports: (i = a.useSupports) !== null && i !== void 0 && i, includeKaiOS: (s = a.includeKaiOS) !== null &&
    s !== void 0 && s };
    wW(o);
    let u = (/* @__PURE__ */ new Date()).getFullYear() + 1, l = [...Array(u).keys()].slice(2002), c = {};
    l.forEach((b) => {
      c[b] = {}, Tp({ targetYear: b }).forEach((D) => {
        c[b] && (c[b][D.browser] = D);
      });
    });
    let f = Tp({}), m = {};
    f.forEach((b) => {
      m[b.browser] = b;
    });
    let h = /* @__PURE__ */ new Date();
    h.setMonth(h.getMonth() + 30);
    let d = Tp({ widelyAvailableOnDate: h.toISOString().slice(0, 10) }), y = {};
    d.forEach((b) => {
      y[b.browser] = b;
    });
    let p = Tp({ targetYear: 2002, listAllCompatibleVersions: !0 }), g = [];
    if (SW.forEach((b) => {
      var D, x, T, w;
      let B = p.filter((V) => V.browser == b).sort((V, Y) => Pi(V.version, Y.version)), k = (x = (D = m[b]) === null || D === void 0 ? void 0 :
      D.version) !== null && x !== void 0 ? x : "0", q = (w = (T = y[b]) === null || T === void 0 ? void 0 : T.version) !== null && w !== void 0 ?
      w : "0";
      l.forEach((V) => {
        var Y;
        if (c[V]) {
          let G = ((Y = c[V][b]) !== null && Y !== void 0 ? Y : { version: "0" }).version, ye = B.findIndex((te) => Pi(te.version, G) === 0);
          (V === u - 1 ? B : B.slice(0, ye)).forEach((te) => {
            let re = Pi(te.version, k) >= 0, ve = Pi(te.version, q) >= 0, je = Object.assign(Object.assign({}, te), { year: V <= 2015 ? "pre\
_baseline" : V - 1 });
            o.useSupports ? (re && (je.supports = "widely"), ve && (je.supports = "newly")) : je = Object.assign(Object.assign({}, je), { wa_compatible: re }),
            g.push(je);
          }), B = B.slice(ye, B.length);
        }
      });
    }), o.includeDownstreamBrowsers && AW(g, !0, o.includeKaiOS).forEach((b) => {
      let D = g.find((x) => x.browser === "chrome" && x.version === b.engine_version);
      D && (o.useSupports ? g.push(Object.assign(Object.assign({}, b), { year: D.year, supports: D.supports })) : g.push(Object.assign(Object.
      assign({}, b), { year: D.year, wa_compatible: D.wa_compatible })));
    }), g.sort((b, D) => {
      if (b.year === "pre_baseline" && D.year !== "pre_baseline") return -1;
      if (D.year === "pre_baseline" && b.year !== "pre_baseline") return 1;
      if (b.year !== "pre_baseline" && D.year !== "pre_baseline") {
        if (b.year < D.year) return -1;
        if (b.year > D.year) return 1;
      }
      return b.browser < D.browser ? -1 : b.browser > D.browser ? 1 : Pi(b.version, D.version);
    }), o.outputFormat === "object") {
      let b = {};
      return g.forEach((D) => {
        b[D.browser] || (b[D.browser] = {});
        let x = { year: D.year, release_date: D.release_date, engine: D.engine, engine_version: D.engine_version };
        b[D.browser][D.version] = o.useSupports ? D.supports ? Object.assign(Object.assign({}, x), { supports: D.supports }) : x : Object.assign(
        Object.assign({}, x), { wa_compatible: D.wa_compatible });
      }), b ?? {};
    }
    if (o.outputFormat === "csv") {
      let b = `"browser","version","year","${o.useSupports ? "supports" : "wa_compatible"}","release_date","engine","engine_version"`;
      return g.forEach((D) => {
        var x, T, w, B;
        let k = { browser: D.browser, version: D.version, year: D.year, release_date: (x = D.release_date) !== null && x !== void 0 ? x : "N\
ULL", engine: (T = D.engine) !== null && T !== void 0 ? T : "NULL", engine_version: (w = D.engine_version) !== null && w !== void 0 ? w : "N\
ULL" };
        k = o.useSupports ? Object.assign(Object.assign({}, k), { supports: (B = D.supports) !== null && B !== void 0 ? B : "" }) : Object.assign(
        Object.assign({}, k), { wa_compatible: D.wa_compatible }), b += `
"${k.browser}","${k.version}","${k.year}","${o.useSupports ? k.supports : k.wa_compatible}","${k.release_date}","${k.engine}","${k.engine_version}\
"`;
      }), b;
    }
    return g;
  }, MA.getCompatibleVersions = Tp;
});

// ../node_modules/node-releases/data/processed/envs.json
var PW = E((q2t, iVe) => {
  iVe.exports = [{ name: "nodejs", version: "0.2.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.3.8.0" }, { name: "nodejs", version: "\
0.3.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.5.1.0" }, { name: "nodejs", version: "0.4.0", date: "2011-08-26", lts: !1, security: !1,
  v8: "3.1.2.0" }, { name: "nodejs", version: "0.5.0", date: "2011-08-26", lts: !1, security: !1, v8: "3.1.8.25" }, { name: "nodejs", version: "\
0.6.0", date: "2011-11-04", lts: !1, security: !1, v8: "3.6.6.6" }, { name: "nodejs", version: "0.7.0", date: "2012-01-17", lts: !1, security: !1,
  v8: "3.8.6.0" }, { name: "nodejs", version: "0.8.0", date: "2012-06-22", lts: !1, security: !1, v8: "3.11.10.10" }, { name: "nodejs", version: "\
0.9.0", date: "2012-07-20", lts: !1, security: !1, v8: "3.11.10.15" }, { name: "nodejs", version: "0.10.0", date: "2013-03-11", lts: !1, security: !1,
  v8: "3.14.5.8" }, { name: "nodejs", version: "0.11.0", date: "2013-03-28", lts: !1, security: !1, v8: "3.17.13.0" }, { name: "nodejs", version: "\
0.12.0", date: "2015-02-06", lts: !1, security: !1, v8: "3.28.73.0" }, { name: "nodejs", version: "4.0.0", date: "2015-09-08", lts: !1, security: !1,
  v8: "4.5.103.30" }, { name: "nodejs", version: "4.1.0", date: "2015-09-17", lts: !1, security: !1, v8: "4.5.103.33" }, { name: "nodejs", version: "\
4.2.0", date: "2015-10-12", lts: "Argon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.3.0", date: "2016-02-09", lts: "Ar\
gon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.4.0", date: "2016-03-08", lts: "Argon", security: !1, v8: "4.5.103.35" },
  { name: "nodejs", version: "4.5.0", date: "2016-08-16", lts: "Argon", security: !1, v8: "4.5.103.37" }, { name: "nodejs", version: "4.6.0",
  date: "2016-09-27", lts: "Argon", security: !0, v8: "4.5.103.37" }, { name: "nodejs", version: "4.7.0", date: "2016-12-06", lts: "Argon", security: !1,
  v8: "4.5.103.43" }, { name: "nodejs", version: "4.8.0", date: "2017-02-21", lts: "Argon", security: !1, v8: "4.5.103.45" }, { name: "nodej\
s", version: "4.9.0", date: "2018-03-28", lts: "Argon", security: !0, v8: "4.5.103.53" }, { name: "nodejs", version: "5.0.0", date: "2015-10\
-29", lts: !1, security: !1, v8: "4.6.85.28" }, { name: "nodejs", version: "5.1.0", date: "2015-11-17", lts: !1, security: !1, v8: "4.6.85.3\
1" }, { name: "nodejs", version: "5.2.0", date: "2015-12-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.3.0", date: "\
2015-12-15", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.4.0", date: "2016-01-06", lts: !1, security: !1, v8: "4\
.6.85.31" }, { name: "nodejs", version: "5.5.0", date: "2016-01-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5\
.6.0", date: "2016-02-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.7.0", date: "2016-02-23", lts: !1, security: !1,
  v8: "4.6.85.31" }, { name: "nodejs", version: "5.8.0", date: "2016-03-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "\
5.9.0", date: "2016-03-16", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.10.0", date: "2016-04-01", lts: !1, security: !1,
  v8: "4.6.85.31" }, { name: "nodejs", version: "5.11.0", date: "2016-04-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "\
5.12.0", date: "2016-06-23", lts: !1, security: !1, v8: "4.6.85.32" }, { name: "nodejs", version: "6.0.0", date: "2016-04-26", lts: !1, security: !1,
  v8: "5.0.71.35" }, { name: "nodejs", version: "6.1.0", date: "2016-05-05", lts: !1, security: !1, v8: "5.0.71.35" }, { name: "nodejs", version: "\
6.2.0", date: "2016-05-17", lts: !1, security: !1, v8: "5.0.71.47" }, { name: "nodejs", version: "6.3.0", date: "2016-07-06", lts: !1, security: !1,
  v8: "5.0.71.52" }, { name: "nodejs", version: "6.4.0", date: "2016-08-12", lts: !1, security: !1, v8: "5.0.71.60" }, { name: "nodejs", version: "\
6.5.0", date: "2016-08-26", lts: !1, security: !1, v8: "5.1.281.81" }, { name: "nodejs", version: "6.6.0", date: "2016-09-14", lts: !1, security: !1,
  v8: "5.1.281.83" }, { name: "nodejs", version: "6.7.0", date: "2016-09-27", lts: !1, security: !0, v8: "5.1.281.83" }, { name: "nodejs", version: "\
6.8.0", date: "2016-10-12", lts: !1, security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.9.0", date: "2016-10-18", lts: "Boron",
  security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.10.0", date: "2017-02-21", lts: "Boron", security: !1, v8: "5.1.281.93" },
  { name: "nodejs", version: "6.11.0", date: "2017-06-06", lts: "Boron", security: !1, v8: "5.1.281.102" }, { name: "nodejs", version: "6.12\
.0", date: "2017-11-06", lts: "Boron", security: !1, v8: "5.1.281.108" }, { name: "nodejs", version: "6.13.0", date: "2018-02-10", lts: "Bor\
on", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.14.0", date: "2018-03-28", lts: "Boron", security: !0, v8: "5.1.281.11\
1" }, { name: "nodejs", version: "6.15.0", date: "2018-11-27", lts: "Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "\
6.16.0", date: "2018-12-26", lts: "Boron", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.17.0", date: "2019-02-28", lts: "\
Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "7.0.0", date: "2016-10-25", lts: !1, security: !1, v8: "5.4.500.36" },
  { name: "nodejs", version: "7.1.0", date: "2016-11-08", lts: !1, security: !1, v8: "5.4.500.36" }, { name: "nodejs", version: "7.2.0", date: "\
2016-11-22", lts: !1, security: !1, v8: "5.4.500.43" }, { name: "nodejs", version: "7.3.0", date: "2016-12-20", lts: !1, security: !1, v8: "\
5.4.500.45" }, { name: "nodejs", version: "7.4.0", date: "2017-01-04", lts: !1, security: !1, v8: "5.4.500.45" }, { name: "nodejs", version: "\
7.5.0", date: "2017-01-31", lts: !1, security: !1, v8: "5.4.500.48" }, { name: "nodejs", version: "7.6.0", date: "2017-02-21", lts: !1, security: !1,
  v8: "5.5.372.40" }, { name: "nodejs", version: "7.7.0", date: "2017-02-28", lts: !1, security: !1, v8: "5.5.372.41" }, { name: "nodejs", version: "\
7.8.0", date: "2017-03-29", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "7.9.0", date: "2017-04-11", lts: !1, security: !1,
  v8: "5.5.372.43" }, { name: "nodejs", version: "7.10.0", date: "2017-05-02", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "\
8.0.0", date: "2017-05-30", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "8.1.0", date: "2017-06-08", lts: !1, security: !1,
  v8: "5.8.283.41" }, { name: "nodejs", version: "8.2.0", date: "2017-07-19", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "\
8.3.0", date: "2017-08-08", lts: !1, security: !1, v8: "6.0.286.52" }, { name: "nodejs", version: "8.4.0", date: "2017-08-15", lts: !1, security: !1,
  v8: "6.0.286.52" }, { name: "nodejs", version: "8.5.0", date: "2017-09-12", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "\
8.6.0", date: "2017-09-26", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "8.7.0", date: "2017-10-11", lts: !1, security: !1,
  v8: "6.1.534.42" }, { name: "nodejs", version: "8.8.0", date: "2017-10-24", lts: !1, security: !1, v8: "6.1.534.42" }, { name: "nodejs", version: "\
8.9.0", date: "2017-10-31", lts: "Carbon", security: !1, v8: "6.1.534.46" }, { name: "nodejs", version: "8.10.0", date: "2018-03-06", lts: "\
Carbon", security: !1, v8: "6.2.414.50" }, { name: "nodejs", version: "8.11.0", date: "2018-03-28", lts: "Carbon", security: !0, v8: "6.2.41\
4.50" }, { name: "nodejs", version: "8.12.0", date: "2018-09-10", lts: "Carbon", security: !1, v8: "6.2.414.66" }, { name: "nodejs", version: "\
8.13.0", date: "2018-11-20", lts: "Carbon", security: !1, v8: "6.2.414.72" }, { name: "nodejs", version: "8.14.0", date: "2018-11-27", lts: "\
Carbon", security: !0, v8: "6.2.414.72" }, { name: "nodejs", version: "8.15.0", date: "2018-12-26", lts: "Carbon", security: !1, v8: "6.2.41\
4.75" }, { name: "nodejs", version: "8.16.0", date: "2019-04-16", lts: "Carbon", security: !1, v8: "6.2.414.77" }, { name: "nodejs", version: "\
8.17.0", date: "2019-12-17", lts: "Carbon", security: !0, v8: "6.2.414.78" }, { name: "nodejs", version: "9.0.0", date: "2017-10-31", lts: !1,
  security: !1, v8: "6.2.414.32" }, { name: "nodejs", version: "9.1.0", date: "2017-11-07", lts: !1, security: !1, v8: "6.2.414.32" }, { name: "\
nodejs", version: "9.2.0", date: "2017-11-14", lts: !1, security: !1, v8: "6.2.414.44" }, { name: "nodejs", version: "9.3.0", date: "2017-12\
-12", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.4.0", date: "2018-01-10", lts: !1, security: !1, v8: "6.2.414\
.46" }, { name: "nodejs", version: "9.5.0", date: "2018-01-31", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.6.0",
  date: "2018-02-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.7.0", date: "2018-03-01", lts: !1, security: !1,
  v8: "6.2.414.46" }, { name: "nodejs", version: "9.8.0", date: "2018-03-07", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "\
9.9.0", date: "2018-03-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.10.0", date: "2018-03-28", lts: !1, security: !0,
  v8: "6.2.414.46" }, { name: "nodejs", version: "9.11.0", date: "2018-04-04", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "\
10.0.0", date: "2018-04-24", lts: !1, security: !1, v8: "6.6.346.24" }, { name: "nodejs", version: "10.1.0", date: "2018-05-08", lts: !1, security: !1,
  v8: "6.6.346.27" }, { name: "nodejs", version: "10.2.0", date: "2018-05-23", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "\
10.3.0", date: "2018-05-29", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "10.4.0", date: "2018-06-06", lts: !1, security: !1,
  v8: "6.7.288.43" }, { name: "nodejs", version: "10.5.0", date: "2018-06-20", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "\
10.6.0", date: "2018-07-04", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "10.7.0", date: "2018-07-18", lts: !1, security: !1,
  v8: "6.7.288.49" }, { name: "nodejs", version: "10.8.0", date: "2018-08-01", lts: !1, security: !1, v8: "6.7.288.49" }, { name: "nodejs", version: "\
10.9.0", date: "2018-08-15", lts: !1, security: !1, v8: "6.8.275.24" }, { name: "nodejs", version: "10.10.0", date: "2018-09-06", lts: !1, security: !1,
  v8: "6.8.275.30" }, { name: "nodejs", version: "10.11.0", date: "2018-09-19", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs",
  version: "10.12.0", date: "2018-10-10", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.13.0", date: "2018-10-30",
  lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.14.0", date: "2018-11-27", lts: "Dubnium", security: !0, v8: "\
6.8.275.32" }, { name: "nodejs", version: "10.15.0", date: "2018-12-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs",
  version: "10.16.0", date: "2019-05-28", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.17.0", date: "201\
9-10-22", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.18.0", date: "2019-12-17", lts: "Dubnium", security: !0,
  v8: "6.8.275.32" }, { name: "nodejs", version: "10.19.0", date: "2020-02-05", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "n\
odejs", version: "10.20.0", date: "2020-03-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.21.0", date: "\
2020-06-02", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "10.22.0", date: "2020-07-21", lts: "Dubnium", security: !1,
  v8: "6.8.275.32" }, { name: "nodejs", version: "10.23.0", date: "2020-10-27", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "n\
odejs", version: "10.24.0", date: "2021-02-23", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "11.0.0", date: "\
2018-10-23", lts: !1, security: !1, v8: "7.0.276.28" }, { name: "nodejs", version: "11.1.0", date: "2018-10-30", lts: !1, security: !1, v8: "\
7.0.276.32" }, { name: "nodejs", version: "11.2.0", date: "2018-11-15", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.3.0", date: "2018-11-27", lts: !1, security: !0, v8: "7.0.276.38" }, { name: "nodejs", version: "11.4.0", date: "2018-12-07", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.5.0", date: "2018-12-18", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.6.0", date: "2018-12-26", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.7.0", date: "2019-01-17", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.8.0", date: "2019-01-24", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.9.0", date: "2019-01-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.10.0", date: "2019-02-14", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.11.0", date: "2019-03-05", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs",
  version: "11.12.0", date: "2019-03-14", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.13.0", date: "2019-03-28",
  lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.14.0", date: "2019-04-10", lts: !1, security: !1, v8: "7.0.276.3\
8" }, { name: "nodejs", version: "11.15.0", date: "2019-04-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "12.0.\
0", date: "2019-04-23", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "12.1.0", date: "2019-04-29", lts: !1, security: !1,
  v8: "7.4.288.21" }, { name: "nodejs", version: "12.2.0", date: "2019-05-07", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "\
12.3.0", date: "2019-05-21", lts: !1, security: !1, v8: "7.4.288.27" }, { name: "nodejs", version: "12.4.0", date: "2019-06-04", lts: !1, security: !1,
  v8: "7.4.288.27" }, { name: "nodejs", version: "12.5.0", date: "2019-06-26", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "\
12.6.0", date: "2019-07-03", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "12.7.0", date: "2019-07-23", lts: !1, security: !1,
  v8: "7.5.288.22" }, { name: "nodejs", version: "12.8.0", date: "2019-08-06", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "\
12.9.0", date: "2019-08-20", lts: !1, security: !1, v8: "7.6.303.29" }, { name: "nodejs", version: "12.10.0", date: "2019-09-04", lts: !1, security: !1,
  v8: "7.6.303.29" }, { name: "nodejs", version: "12.11.0", date: "2019-09-25", lts: !1, security: !1, v8: "7.7.299.11" }, { name: "nodejs",
  version: "12.12.0", date: "2019-10-11", lts: !1, security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.13.0", date: "2019-10-21",
  lts: "Erbium", security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.14.0", date: "2019-12-17", lts: "Erbium", security: !0, v8: "\
7.7.299.13" }, { name: "nodejs", version: "12.15.0", date: "2020-02-05", lts: "Erbium", security: !0, v8: "7.7.299.13" }, { name: "nodejs", version: "\
12.16.0", date: "2020-02-11", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.17.0", date: "2020-05-26", lts: "\
Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.18.0", date: "2020-06-02", lts: "Erbium", security: !0, v8: "7.8.2\
79.23" }, { name: "nodejs", version: "12.19.0", date: "2020-10-06", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "\
12.20.0", date: "2020-11-24", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.21.0", date: "2021-02-23", lts: "\
Erbium", security: !0, v8: "7.8.279.23" }, { name: "nodejs", version: "12.22.0", date: "2021-03-30", lts: "Erbium", security: !1, v8: "7.8.2\
79.23" }, { name: "nodejs", version: "13.0.0", date: "2019-10-22", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13\
.1.0", date: "2019-11-05", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13.2.0", date: "2019-11-21", lts: !1, security: !1,
  v8: "7.9.317.23" }, { name: "nodejs", version: "13.3.0", date: "2019-12-03", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.4.0", date: "2019-12-17", lts: !1, security: !0, v8: "7.9.317.25" }, { name: "nodejs", version: "13.5.0", date: "2019-12-18", lts: !1, security: !1,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.6.0", date: "2020-01-07", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.7.0", date: "2020-01-21", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.8.0", date: "2020-02-05", lts: !1, security: !0,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.9.0", date: "2020-02-18", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.10.0", date: "2020-03-04", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.11.0", date: "2020-03-12", lts: !1, security: !1,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.12.0", date: "2020-03-26", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs",
  version: "13.13.0", date: "2020-04-14", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.14.0", date: "2020-04-29",
  lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "14.0.0", date: "2020-04-21", lts: !1, security: !1, v8: "8.1.307.30" },
  { name: "nodejs", version: "14.1.0", date: "2020-04-29", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.2.0", date: "\
2020-05-05", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.3.0", date: "2020-05-19", lts: !1, security: !1, v8: "\
8.1.307.31" }, { name: "nodejs", version: "14.4.0", date: "2020-06-02", lts: !1, security: !0, v8: "8.1.307.31" }, { name: "nodejs", version: "\
14.5.0", date: "2020-06-30", lts: !1, security: !1, v8: "8.3.110.9" }, { name: "nodejs", version: "14.6.0", date: "2020-07-20", lts: !1, security: !1,
  v8: "8.4.371.19" }, { name: "nodejs", version: "14.7.0", date: "2020-07-29", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "\
14.8.0", date: "2020-08-11", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.9.0", date: "2020-08-27", lts: !1, security: !1,
  v8: "8.4.371.19" }, { name: "nodejs", version: "14.10.0", date: "2020-09-08", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs",
  version: "14.11.0", date: "2020-09-15", lts: !1, security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.12.0", date: "2020-09-22",
  lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.13.0", date: "2020-09-29", lts: !1, security: !1, v8: "8.4.371.1\
9" }, { name: "nodejs", version: "14.14.0", date: "2020-10-15", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.15\
.0", date: "2020-10-27", lts: "Fermium", security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.16.0", date: "2021-02-23", lts: "F\
ermium", security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.17.0", date: "2021-05-11", lts: "Fermium", security: !1, v8: "8.4.\
371.23" }, { name: "nodejs", version: "14.18.0", date: "2021-09-28", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "\
14.19.0", date: "2022-02-01", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "14.20.0", date: "2022-07-07", lts: "\
Fermium", security: !0, v8: "8.4.371.23" }, { name: "nodejs", version: "14.21.0", date: "2022-11-01", lts: "Fermium", security: !1, v8: "8.4\
.371.23" }, { name: "nodejs", version: "15.0.0", date: "2020-10-20", lts: !1, security: !1, v8: "8.6.395.16" }, { name: "nodejs", version: "\
15.1.0", date: "2020-11-04", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.2.0", date: "2020-11-10", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.3.0", date: "2020-11-24", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.4.0", date: "2020-12-09", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.5.0", date: "2020-12-22", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.6.0", date: "2021-01-14", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.7.0", date: "2021-01-25", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.8.0", date: "2021-02-02", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.9.0", date: "2021-02-18", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.10.0", date: "2021-02-23", lts: !1, security: !0, v8: "8.6.395.17" }, { name: "nodejs", version: "15.11.0", date: "2021-03-03", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.12.0", date: "2021-03-17", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs",
  version: "15.13.0", date: "2021-03-31", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.14.0", date: "2021-04-06",
  lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "16.0.0", date: "2021-04-20", lts: !1, security: !1, v8: "9.0.257.17" },
  { name: "nodejs", version: "16.1.0", date: "2021-05-04", lts: !1, security: !1, v8: "9.0.257.24" }, { name: "nodejs", version: "16.2.0", date: "\
2021-05-19", lts: !1, security: !1, v8: "9.0.257.25" }, { name: "nodejs", version: "16.3.0", date: "2021-06-03", lts: !1, security: !1, v8: "\
9.0.257.25" }, { name: "nodejs", version: "16.4.0", date: "2021-06-23", lts: !1, security: !1, v8: "9.1.269.36" }, { name: "nodejs", version: "\
16.5.0", date: "2021-07-14", lts: !1, security: !1, v8: "9.1.269.38" }, { name: "nodejs", version: "16.6.0", date: "2021-07-29", lts: !1, security: !0,
  v8: "9.2.230.21" }, { name: "nodejs", version: "16.7.0", date: "2021-08-18", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "\
16.8.0", date: "2021-08-25", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "16.9.0", date: "2021-09-07", lts: !1, security: !1,
  v8: "9.3.345.16" }, { name: "nodejs", version: "16.10.0", date: "2021-09-22", lts: !1, security: !1, v8: "9.3.345.19" }, { name: "nodejs",
  version: "16.11.0", date: "2021-10-08", lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.12.0", date: "2021-10-20",
  lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.13.0", date: "2021-10-26", lts: "Gallium", security: !1, v8: "9.\
4.146.19" }, { name: "nodejs", version: "16.14.0", date: "2022-02-08", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "\
16.15.0", date: "2022-04-26", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "16.16.0", date: "2022-07-07", lts: "\
Gallium", security: !0, v8: "9.4.146.24" }, { name: "nodejs", version: "16.17.0", date: "2022-08-16", lts: "Gallium", security: !1, v8: "9.4\
.146.26" }, { name: "nodejs", version: "16.18.0", date: "2022-10-12", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "\
16.19.0", date: "2022-12-13", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "16.20.0", date: "2023-03-28", lts: "\
Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "17.0.0", date: "2021-10-19", lts: !1, security: !1, v8: "9.5.172.21" },
  { name: "nodejs", version: "17.1.0", date: "2021-11-09", lts: !1, security: !1, v8: "9.5.172.25" }, { name: "nodejs", version: "17.2.0", date: "\
2021-11-30", lts: !1, security: !1, v8: "9.6.180.14" }, { name: "nodejs", version: "17.3.0", date: "2021-12-17", lts: !1, security: !1, v8: "\
9.6.180.15" }, { name: "nodejs", version: "17.4.0", date: "2022-01-18", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "\
17.5.0", date: "2022-02-10", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.6.0", date: "2022-02-22", lts: !1, security: !1,
  v8: "9.6.180.15" }, { name: "nodejs", version: "17.7.0", date: "2022-03-09", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "\
17.8.0", date: "2022-03-22", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.9.0", date: "2022-04-07", lts: !1, security: !1,
  v8: "9.6.180.15" }, { name: "nodejs", version: "18.0.0", date: "2022-04-18", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "\
18.1.0", date: "2022-05-03", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "18.2.0", date: "2022-05-17", lts: !1, security: !1,
  v8: "10.1.124.8" }, { name: "nodejs", version: "18.3.0", date: "2022-06-02", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "\
18.4.0", date: "2022-06-16", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "18.5.0", date: "2022-07-06", lts: !1, security: !0,
  v8: "10.2.154.4" }, { name: "nodejs", version: "18.6.0", date: "2022-07-13", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs",
  version: "18.7.0", date: "2022-07-26", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.8.0", date: "2022-08-24",
  lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.9.0", date: "2022-09-07", lts: !1, security: !1, v8: "10.2.154.\
15" }, { name: "nodejs", version: "18.10.0", date: "2022-09-28", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.\
11.0", date: "2022-10-13", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.12.0", date: "2022-10-25", lts: "Hydro\
gen", security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.13.0", date: "2023-01-05", lts: "Hydrogen", security: !1, v8: "10.2.\
154.23" }, { name: "nodejs", version: "18.14.0", date: "2023-02-01", lts: "Hydrogen", security: !1, v8: "10.2.154.23" }, { name: "nodejs", version: "\
18.15.0", date: "2023-03-05", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.16.0", date: "2023-04-12", lts: "\
Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.17.0", date: "2023-07-18", lts: "Hydrogen", security: !1, v8: "\
10.2.154.26" }, { name: "nodejs", version: "18.18.0", date: "2023-09-18", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodej\
s", version: "18.19.0", date: "2023-11-29", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.20.0", date: "\
2024-03-26", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "19.0.0", date: "2022-10-17", lts: !1, security: !1,
  v8: "10.7.193.13" }, { name: "nodejs", version: "19.1.0", date: "2022-11-14", lts: !1, security: !1, v8: "10.7.193.20" }, { name: "nodejs",
  version: "19.2.0", date: "2022-11-29", lts: !1, security: !1, v8: "10.8.168.20" }, { name: "nodejs", version: "19.3.0", date: "2022-12-14",
  lts: !1, security: !1, v8: "10.8.168.21" }, { name: "nodejs", version: "19.4.0", date: "2023-01-05", lts: !1, security: !1, v8: "10.8.168.\
25" }, { name: "nodejs", version: "19.5.0", date: "2023-01-24", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.6\
.0", date: "2023-02-01", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.7.0", date: "2023-02-21", lts: !1, security: !1,
  v8: "10.8.168.25" }, { name: "nodejs", version: "19.8.0", date: "2023-03-14", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs",
  version: "19.9.0", date: "2023-04-10", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "20.0.0", date: "2023-04-17",
  lts: !1, security: !1, v8: "11.3.244.4" }, { name: "nodejs", version: "20.1.0", date: "2023-05-03", lts: !1, security: !1, v8: "11.3.244.8" },
  { name: "nodejs", version: "20.2.0", date: "2023-05-16", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.3.0", date: "\
2023-06-08", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.4.0", date: "2023-07-04", lts: !1, security: !1, v8: "\
11.3.244.8" }, { name: "nodejs", version: "20.5.0", date: "2023-07-19", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "\
20.6.0", date: "2023-08-23", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.7.0", date: "2023-09-18", lts: !1, security: !1,
  v8: "11.3.244.8" }, { name: "nodejs", version: "20.8.0", date: "2023-09-28", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "\
20.9.0", date: "2023-10-24", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.10.0", date: "2023-11-22", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.11.0", date: "2024-01-09", lts: "Iron", security: !1, v8: "11.3.244.\
8" }, { name: "nodejs", version: "20.12.0", date: "2024-03-26", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "2\
0.13.0", date: "2024-05-07", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.14.0", date: "2024-05-28", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.15.0", date: "2024-06-20", lts: "Iron", security: !1, v8: "11.3.244.\
8" }, { name: "nodejs", version: "20.16.0", date: "2024-07-24", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "2\
0.17.0", date: "2024-08-21", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.18.0", date: "2024-10-03", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.19.0", date: "2025-03-13", lts: "Iron", security: !1, v8: "11.3.244.\
8" }, { name: "nodejs", version: "21.0.0", date: "2023-10-17", lts: !1, security: !1, v8: "11.8.172.13" }, { name: "nodejs", version: "21.1.\
0", date: "2023-10-24", lts: !1, security: !1, v8: "11.8.172.15" }, { name: "nodejs", version: "21.2.0", date: "2023-11-14", lts: !1, security: !1,
  v8: "11.8.172.17" }, { name: "nodejs", version: "21.3.0", date: "2023-11-30", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs",
  version: "21.4.0", date: "2023-12-05", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.5.0", date: "2023-12-19",
  lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.6.0", date: "2024-01-14", lts: !1, security: !1, v8: "11.8.172.\
17" }, { name: "nodejs", version: "21.7.0", date: "2024-03-06", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "22.0\
.0", date: "2024-04-24", lts: !1, security: !1, v8: "12.4.254.14" }, { name: "nodejs", version: "22.1.0", date: "2024-05-02", lts: !1, security: !1,
  v8: "12.4.254.14" }, { name: "nodejs", version: "22.2.0", date: "2024-05-15", lts: !1, security: !1, v8: "12.4.254.14" }, { name: "nodejs",
  version: "22.3.0", date: "2024-06-11", lts: !1, security: !1, v8: "12.4.254.20" }, { name: "nodejs", version: "22.4.0", date: "2024-07-02",
  lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.5.0", date: "2024-07-17", lts: !1, security: !1, v8: "12.4.254.\
21" }, { name: "nodejs", version: "22.6.0", date: "2024-08-06", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.7\
.0", date: "2024-08-21", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.8.0", date: "2024-09-03", lts: !1, security: !1,
  v8: "12.4.254.21" }, { name: "nodejs", version: "22.9.0", date: "2024-09-17", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs",
  version: "22.10.0", date: "2024-10-16", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.11.0", date: "2024-10-2\
9", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.12.0", date: "2024-12-02", lts: "Jod", security: !1, v8: "\
12.4.254.21" }, { name: "nodejs", version: "22.13.0", date: "2025-01-06", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "\
22.14.0", date: "2025-02-11", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.15.0", date: "2025-04-22", lts: "\
Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.16.0", date: "2025-05-20", lts: "Jod", security: !1, v8: "12.4.254.2\
1" }, { name: "nodejs", version: "22.17.0", date: "2025-06-24", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "2\
2.18.0", date: "2025-07-31", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.19.0", date: "2025-08-28", lts: "\
Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "23.0.0", date: "2024-10-16", lts: !1, security: !1, v8: "12.9.202.26" },
  { name: "nodejs", version: "23.1.0", date: "2024-10-24", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.2.0", date: "\
2024-11-11", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.3.0", date: "2024-11-20", lts: !1, security: !1, v8: "\
12.9.202.28" }, { name: "nodejs", version: "23.4.0", date: "2024-12-10", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "\
23.5.0", date: "2024-12-19", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.6.0", date: "2025-01-07", lts: !1, security: !1,
  v8: "12.9.202.28" }, { name: "nodejs", version: "23.7.0", date: "2025-01-30", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs",
  version: "23.8.0", date: "2025-02-13", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.9.0", date: "2025-02-26",
  lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.10.0", date: "2025-03-13", lts: !1, security: !1, v8: "12.9.202\
.28" }, { name: "nodejs", version: "23.11.0", date: "2025-04-01", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "24\
.0.0", date: "2025-05-06", lts: !1, security: !1, v8: "13.6.233.8" }, { name: "nodejs", version: "24.1.0", date: "2025-05-20", lts: !1, security: !1,
  v8: "13.6.233.10" }, { name: "nodejs", version: "24.2.0", date: "2025-06-09", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs",
  version: "24.3.0", date: "2025-06-24", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.4.0", date: "2025-07-09",
  lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.5.0", date: "2025-07-31", lts: !1, security: !1, v8: "13.6.233.\
10" }, { name: "nodejs", version: "24.6.0", date: "2025-08-14", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.7\
.0", date: "2025-08-27", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.8.0", date: "2025-09-10", lts: !1, security: !1,
  v8: "13.6.233.10" }];
});

// ../node_modules/caniuse-lite/data/browsers.js
var IW = E((U2t, FW) => {
  FW.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "\
op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
});

// ../node_modules/caniuse-lite/dist/unpacker/browsers.js
var B1 = E(($2t, OW) => {
  OW.exports.browsers = IW();
});

// ../node_modules/caniuse-lite/data/browserVersions.js
var BW = E((V2t, kW) => {
  kW.exports = { 0: "117", 1: "118", 2: "119", 3: "120", 4: "121", 5: "122", 6: "20", 7: "21", 8: "22", 9: "23", A: "10", B: "11", C: "12", D: "\
7", E: "8", F: "9", G: "15", H: "80", I: "139", J: "4", K: "6", L: "13", M: "14", N: "16", O: "17", P: "18", Q: "79", R: "81", S: "83", T: "\
84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "99", j: "\
100", k: "101", l: "102", m: "103", n: "104", o: "105", p: "106", q: "107", r: "108", s: "109", t: "110", u: "111", v: "112", w: "113", x: "\
114", y: "115", z: "116", AB: "24", BB: "25", CB: "26", DB: "27", EB: "28", FB: "123", GB: "124", HB: "125", IB: "126", JB: "127", KB: "128",
  LB: "129", MB: "130", NB: "131", OB: "132", PB: "133", QB: "134", RB: "135", SB: "136", TB: "137", UB: "138", VB: "140", WB: "5", XB: "19",
  YB: "29", ZB: "30", aB: "31", bB: "32", cB: "33", dB: "34", eB: "35", fB: "36", gB: "37", hB: "38", iB: "39", jB: "40", kB: "41", lB: "42",
  mB: "43", nB: "44", oB: "45", pB: "46", qB: "47", rB: "48", sB: "49", tB: "50", uB: "51", vB: "52", wB: "53", xB: "54", yB: "55", zB: "56",
  "0B": "57", "1B": "58", "2B": "60", "3B": "62", "4B": "63", "5B": "64", "6B": "65", "7B": "66", "8B": "67", "9B": "68", AC: "69", BC: "70",
  CC: "71", DC: "72", EC: "73", FC: "74", GC: "75", HC: "76", IC: "77", JC: "78", KC: "142", LC: "11.1", MC: "12.1", NC: "15.5", OC: "16.0",
  PC: "17.0", QC: "18.0", RC: "3", SC: "59", TC: "61", UC: "82", VC: "141", WC: "143", XC: "3.2", YC: "10.1", ZC: "15.2-15.3", aC: "15.4", bC: "\
16.1", cC: "16.2", dC: "16.3", eC: "16.4", fC: "16.5", gC: "17.1", hC: "17.2", iC: "17.3", jC: "17.4", kC: "17.5", lC: "18.1", mC: "18.2", nC: "\
18.3", oC: "18.4", pC: "18.5-18.6", qC: "26.0", rC: "26.1", sC: "11.5", tC: "4.2-4.3", uC: "5.5", vC: "2", wC: "144", xC: "145", yC: "3.5", zC: "\
3.6", "0C": "3.1", "1C": "5.1", "2C": "6.1", "3C": "7.1", "4C": "9.1", "5C": "13.1", "6C": "14.1", "7C": "15.1", "8C": "15.6", "9C": "16.6",
  AD: "17.6", BD: "TP", CD: "9.5-9.6", DD: "10.0-10.1", ED: "10.5", FD: "10.6", GD: "11.6", HD: "4.0-4.1", ID: "5.0-5.1", JD: "6.0-6.1", KD: "\
7.0-7.1", LD: "8.1-8.4", MD: "9.0-9.2", ND: "9.3", OD: "10.0-10.2", PD: "10.3", QD: "11.0-11.2", RD: "11.3-11.4", SD: "12.0-12.1", TD: "12.2\
-12.5", UD: "13.0-13.1", VD: "13.2", WD: "13.3", XD: "13.4-13.7", YD: "14.0-14.4", ZD: "14.5-14.8", aD: "15.0-15.1", bD: "15.6-15.8", cD: "1\
6.6-16.7", dD: "17.6-17.7", eD: "all", fD: "2.1", gD: "2.2", hD: "2.3", iD: "4.1", jD: "4.4", kD: "4.4.3-4.4.4", lD: "5.0-5.4", mD: "6.2-6.4",
  nD: "7.2-7.4", oD: "8.2", pD: "9.2", qD: "11.1-11.2", rD: "12.0", sD: "13.0", tD: "14.0", uD: "15.0", vD: "19.0", wD: "14.9", xD: "13.52",
  yD: "2.5", zD: "3.0-3.1" };
});

// ../node_modules/caniuse-lite/dist/unpacker/browserVersions.js
var RA = E((W2t, NW) => {
  NW.exports.browserVersions = BW();
});

// ../node_modules/caniuse-lite/data/agents.js
var RW = E((H2t, MW) => {
  MW.exports = { A: { A: { K: 0, D: 0, E: 0.0379299, F: 0.0303439, A: 758598e-8, B: 0.675152, uC: 0 }, B: "ms", C: ["", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "uC", "K", "D", "E", "F", "A", "B", "", "",
  ""], E: "IE", F: { uC: 962323200, K: 998870400, D: 1161129600, E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { 0: 0,
  1: 0, 2: 0, 3: 0.031456, 4: 3932e-6, 5: 0.011796, C: 0, L: 0, M: 0, G: 0, N: 0, O: 0, P: 3932e-6, Q: 0, H: 0, R: 0, S: 0, T: 0, U: 0, V: 0,
  W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0.011796, c: 0, d: 0, e: 0, f: 3932e-6, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 0,
  r: 0, s: 0.03932, t: 0, u: 0, v: 0, w: 7864e-6, x: 0.023592, y: 3932e-6, z: 0, FB: 3932e-6, GB: 7864e-6, HB: 3932e-6, IB: 0.011796, JB: 0.011796,
  KB: 7864e-6, LB: 7864e-6, MB: 0.011796, NB: 0.031456, OB: 0.011796, PB: 0.015728, QB: 0.043252, RB: 0.023592, SB: 0.027524, TB: 0.043252, UB: 1.44698,
  I: 2.72094, VB: 7864e-6 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "L", "M", "G", "N", "O", "P", "Q", "H", "R", "S", "T", "U", "V", "W",
  "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y",
  "z", "0", "1", "2", "3", "4", "5", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "I", "V\
B", "", "", ""], E: "Edge", F: { 0: 1694649600, 1: 1697155200, 2: 1698969600, 3: 1701993600, 4: 1706227200, 5: 1708732800, C: 1438128e3, L: 1447286400,
  M: 1470096e3, G: 1491868800, N: 1508198400, O: 1525046400, P: 1542067200, Q: 1579046400, H: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600,
  U: 1598486400, V: 1602201600, W: 1605830400, X: 161136e4, Y: 1614816e3, Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600,
  e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, i: 1646265600, j: 1649635200, k: 1651190400, l: 1653955200, m: 1655942400, n: 1659657600,
  o: 1661990400, p: 1664755200, q: 1666915200, r: 1670198400, s: 1673481600, t: 1675900800, u: 1678665600, v: 1680825600, w: 1683158400, x: 1685664e3,
  y: 1689897600, z: 1692576e3, FB: 1711152e3, GB: 1713398400, HB: 1715990400, IB: 1718841600, JB: 1721865600, KB: 1724371200, LB: 1726704e3,
  MB: 1729123200, NB: 1731542400, OB: 1737417600, PB: 1740614400, QB: 1741219200, RB: 1743984e3, SB: 1746316800, TB: 1748476800, UB: 1750896e3,
  I: 1754611200, VB: 1756944e3 }, D: { C: "ms", L: "ms", M: "ms", G: "ms", N: "ms", O: "ms", P: "ms" } }, C: { A: { 0: 0, 1: 0.121892, 2: 0,
  3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, vC: 0, RC: 0, J: 0, WB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0.031456, C: 0, L: 0, M: 0, G: 0, N: 0,
  O: 0, P: 0, XB: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0,
  lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, vB: 0.027524, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 0, "1B": 0, SC: 3932e-6,
  "2B": 0, TC: 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0, "8B": 0, "9B": 0, AC: 0, BC: 0, CC: 0, DC: 0, EC: 0, FC: 0, GC: 0, HC: 0, IC: 0,
  JC: 7864e-6, Q: 0, H: 0, R: 0, UC: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0,
  j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 0, r: 0, s: 0, t: 0, u: 0, v: 0, w: 0, x: 0, y: 0.169076, z: 0, FB: 0, GB: 0, HB: 3932e-6, IB: 0,
  JB: 0, KB: 0.07864, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0.015728, QB: 7864e-6, RB: 0.011796, SB: 0.011796, TB: 7864e-6, UB: 0.011796, I: 0.01966,
  VB: 0.047184, VC: 0.868972, KC: 0.404996, WC: 0, wC: 0, xC: 0, yC: 0, zC: 0 }, B: "moz", C: ["vC", "RC", "yC", "zC", "J", "WB", "K", "D", "\
E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "XB", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "YB", "ZB", "aB", "bB", "cB", "\
dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B",
  "1B", "SC", "2B", "TC", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "Q", "H", "R",
  "UC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s",
  "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "\
RB", "SB", "TB", "UB", "I", "VB", "VC", "KC", "WC", "wC", "xC"], E: "Firefox", F: { 0: 1693267200, 1: 1695686400, 2: 1698105600, 3: 1700524800,
  4: 1702944e3, 5: 1705968e3, 6: 1361232e3, 7: 1364860800, 8: 1368489600, 9: 1372118400, vC: 1161648e3, RC: 1213660800, yC: 124632e4, zC: 1264032e3,
  J: 1300752e3, WB: 1308614400, K: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800, L: 1335225600,
  M: 1338854400, G: 1342483200, N: 1346112e3, O: 1349740800, P: 1353628800, XB: 1357603200, AB: 1375747200, BB: 1379376e3, CB: 1386633600, DB: 1391472e3,
  EB: 1395100800, YB: 1398729600, ZB: 1402358400, aB: 1405987200, bB: 1409616e3, cB: 1413244800, dB: 1417392e3, eB: 1421107200, fB: 1424736e3,
  gB: 1428278400, hB: 1431475200, iB: 1435881600, jB: 1439251200, kB: 144288e4, lB: 1446508800, mB: 1450137600, nB: 1453852800, oB: 1457395200,
  pB: 1461628800, qB: 1465257600, rB: 1470096e3, sB: 1474329600, tB: 1479168e3, uB: 1485216e3, vB: 1488844800, wB: 149256e4, xB: 1497312e3, yB: 1502150400,
  zB: 1506556800, "0B": 1510617600, "1B": 1516665600, SC: 1520985600, "2B": 1525824e3, TC: 1529971200, "3B": 1536105600, "4B": 1540252800, "\
5B": 1544486400, "6B": 154872e4, "7B": 1552953600, "8B": 1558396800, "9B": 1562630400, AC: 1567468800, BC: 1571788800, CC: 1575331200, DC: 1578355200,
  EC: 1581379200, FC: 1583798400, GC: 1586304e3, HC: 1588636800, IC: 1591056e3, JC: 1593475200, Q: 1595894400, H: 1598313600, R: 1600732800,
  UC: 1603152e3, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600,
  b: 1630972800, c: 1633392e3, d: 1635811200, e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536e3, k: 1653955200,
  l: 1656374400, m: 1658793600, n: 1661212800, o: 1663632e3, p: 1666051200, q: 1668470400, r: 1670889600, s: 1673913600, t: 1676332800, u: 1678752e3,
  v: 1681171200, w: 1683590400, x: 1686009600, y: 1688428800, z: 1690848e3, FB: 1708387200, GB: 1710806400, HB: 1713225600, IB: 1715644800, JB: 1718064e3,
  KB: 1720483200, LB: 1722902400, MB: 1725321600, NB: 1727740800, OB: 173016e4, PB: 1732579200, QB: 1736208e3, RB: 1738627200, SB: 1741046400,
  TB: 1743465600, UB: 1745884800, I: 1748304e3, VB: 1750723200, VC: 1753142400, KC: 1755561600, WC: null, wC: null, xC: null } }, D: { A: { 0: 0.11796,
  1: 0.05898, 2: 0.051116, 3: 0.106164, 4: 0.043252, 5: 0.070776, 6: 0, 7: 0, 8: 0, 9: 0, J: 0, WB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0,
  L: 0, M: 0, G: 0, N: 0, O: 0, P: 0, XB: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0,
  hB: 0, iB: 7864e-6, jB: 7864e-6, kB: 7864e-6, lB: 7864e-6, mB: 7864e-6, nB: 7864e-6, oB: 0.011796, pB: 7864e-6, qB: 0.011796, rB: 0.01966,
  sB: 0.01966, tB: 7864e-6, uB: 7864e-6, vB: 0.011796, wB: 7864e-6, xB: 7864e-6, yB: 7864e-6, zB: 0.015728, "0B": 7864e-6, "1B": 0.011796, SC: 7864e-6,
  "2B": 7864e-6, TC: 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0.023592, "8B": 0, "9B": 3932e-6, AC: 7864e-6, BC: 7864e-6, CC: 0, DC: 0, EC: 0,
  FC: 3932e-6, GC: 3932e-6, HC: 3932e-6, IC: 0, JC: 7864e-6, Q: 0.070776, H: 7864e-6, R: 0.035388, S: 0.043252, T: 0, U: 7864e-6, V: 0.011796,
  W: 0.03932, X: 7864e-6, Y: 3932e-6, Z: 7864e-6, a: 0.01966, b: 0.011796, c: 0.011796, d: 3932e-6, e: 0, f: 7864e-6, g: 0.015728, h: 0.043252,
  i: 0.015728, j: 0.011796, k: 0.01966, l: 0.015728, m: 0.090436, n: 0.031456, o: 0.813924, p: 7864e-6, q: 0.011796, r: 0.031456, s: 0.723488,
  t: 7864e-6, u: 0.027524, v: 2.94114, w: 0.011796, x: 0.047184, y: 0.082572, z: 0.066844, FB: 0.074708, GB: 0.062912, HB: 0.428588, IB: 0.467908,
  JB: 0.035388, KB: 0.07864, LB: 0.03932, MB: 0.106164, NB: 0.25558, OB: 0.17694, PB: 0.070776, QB: 0.35388, RB: 0.129756, SB: 0.161212, TB: 0.542616,
  UB: 7.16804, I: 7.30566, VB: 0.01966, VC: 7864e-6, KC: 0, WC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "J", "WB", "K", "D", "E", "\
F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "XB", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "YB", "ZB", "aB", "bB", "cB", "dB",
  "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "\
1B", "SC", "2B", "TC", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "Q", "H", "R", "\
S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "\
u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB",
  "TB", "UB", "I", "VB", "VC", "KC", "WC"], E: "Chrome", F: { 0: 1694476800, 1: 1696896e3, 2: 1698710400, 3: 1701993600, 4: 1705968e3, 5: 1708387200,
  6: 133704e4, 7: 1340668800, 8: 1343692800, 9: 1348531200, J: 1264377600, WB: 1274745600, K: 1283385600, D: 1287619200, E: 1291248e3, F: 1296777600,
  A: 1299542400, B: 1303862400, C: 1307404800, L: 1312243200, M: 1316131200, G: 1316131200, N: 1319500800, O: 1323734400, P: 1328659200, XB: 1332892800,
  AB: 1352246400, BB: 1357862400, CB: 1361404800, DB: 1364428800, EB: 1369094400, YB: 1374105600, ZB: 1376956800, aB: 1384214400, bB: 1389657600,
  cB: 1392940800, dB: 1397001600, eB: 1400544e3, fB: 1405468800, gB: 1409011200, hB: 141264e4, iB: 1416268800, jB: 1421798400, kB: 1425513600,
  lB: 1429401600, mB: 143208e4, nB: 1437523200, oB: 1441152e3, pB: 1444780800, qB: 1449014400, rB: 1453248e3, sB: 1456963200, tB: 1460592e3,
  uB: 1464134400, vB: 1469059200, wB: 1472601600, xB: 1476230400, yB: 1480550400, zB: 1485302400, "0B": 1489017600, "1B": 149256e4, SC: 1496707200,
  "2B": 1500940800, TC: 1504569600, "3B": 1508198400, "4B": 1512518400, "5B": 1516752e3, "6B": 1520294400, "7B": 1523923200, "8B": 1527552e3,
  "9B": 1532390400, AC: 1536019200, BC: 1539648e3, CC: 1543968e3, DC: 154872e4, EC: 1552348800, FC: 1555977600, GC: 1559606400, HC: 1564444800,
  IC: 1568073600, JC: 1571702400, Q: 1575936e3, H: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200,
  X: 1611014400, Y: 1614556800, Z: 1618272e3, a: 1621987200, b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800,
  h: 1643673600, i: 1646092800, j: 1648512e3, k: 1650931200, l: 1653350400, m: 1655769600, n: 1659398400, o: 1661817600, p: 1664236800, q: 1666656e3,
  r: 166968e4, s: 1673308800, t: 1675728e3, u: 1678147200, v: 1680566400, w: 1682985600, x: 1685404800, y: 1689724800, z: 1692057600, FB: 1710806400,
  GB: 1713225600, HB: 1715644800, IB: 1718064e3, JB: 1721174400, KB: 1724112e3, LB: 1726531200, MB: 1728950400, NB: 1731369600, OB: 1736812800,
  PB: 1738627200, QB: 1741046400, RB: 1743465600, SB: 1745884800, TB: 1748304e3, UB: 1750723200, I: 1754352e3, VB: 1756771200, VC: null, KC: null,
  WC: null } }, E: { A: { J: 0, WB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0, L: 0, M: 0.011796, G: 0, "0C": 0, XC: 0, "1C": 0, "2C": 0, "\
3C": 0, "4C": 0, YC: 0, LC: 3932e-6, MC: 3932e-6, "5C": 0.027524, "6C": 0.027524, "7C": 0.023592, ZC: 0, aC: 7864e-6, NC: 7864e-6, "8C": 0.106164,
  OC: 0.01966, bC: 0.015728, cC: 0.011796, dC: 0.023592, eC: 7864e-6, fC: 0.015728, "9C": 0.153348, PC: 3932e-6, gC: 0.106164, hC: 0.011796,
  iC: 0.011796, jC: 0.023592, kC: 0.043252, AD: 0.141552, QC: 0.015728, lC: 0.031456, mC: 0.015728, nC: 0.066844, oC: 0.043252, pC: 0.585868,
  qC: 0.01966, rC: 0, BD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "0C", "XC", "J", "WB", "1C", "K", "2C", "D", "3C", "E", "F", "4C", "A", "YC", "B", "LC", "C", "MC", "L", "5C", "M", "6C", "G", "7C", "ZC",
  "aC", "NC", "8C", "OC", "bC", "cC", "dC", "eC", "fC", "9C", "PC", "gC", "hC", "iC", "jC", "kC", "AD", "QC", "lC", "mC", "nC", "oC", "pC", "\
qC", "rC", "BD", ""], E: "Safari", F: { "0C": 1205798400, XC: 1226534400, J: 1244419200, WB: 1275868800, "1C": 131112e4, K: 1343174400, "2C": 13824e5,
  D: 13824e5, "3C": 1410998400, E: 1413417600, F: 1443657600, "4C": 1458518400, A: 1474329600, YC: 1490572800, B: 1505779200, LC: 1522281600,
  C: 1537142400, MC: 1553472e3, L: 1568851200, "5C": 1585008e3, M: 1600214400, "6C": 1619395200, G: 1632096e3, "7C": 1635292800, ZC: 1639353600,
  aC: 1647216e3, NC: 1652745600, "8C": 1658275200, OC: 1662940800, bC: 1666569600, cC: 1670889600, dC: 1674432e3, eC: 1679875200, fC: 1684368e3,
  "9C": 1690156800, PC: 1695686400, gC: 1698192e3, hC: 1702252800, iC: 1705881600, jC: 1709596800, kC: 1715558400, AD: 1722211200, QC: 1726444800,
  lC: 1730073600, mC: 1733875200, nC: 1737936e3, oC: 1743379200, pC: 1747008e3, qC: 1757894400, rC: null, BD: null } }, F: { A: { 0: 0, 1: 0,
  2: 0.011796, 3: 0.636984, 4: 3932e-6, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, F: 0, B: 0, C: 0, G: 0, N: 0, O: 0, P: 0, XB: 0, AB: 0, BB: 0, CB: 0, DB: 0,
  EB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 7864e-6,
  qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 0, "1B": 0, "2B": 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0,
  "8B": 0, "9B": 0, AC: 0, BC: 0, CC: 0, DC: 0, EC: 0, FC: 0, GC: 0, HC: 0, IC: 0, JC: 0, Q: 0, H: 0, R: 0, UC: 0, S: 0, T: 0, U: 0, V: 0, W: 0,
  X: 0, Y: 0, Z: 0.051116, a: 0.01966, b: 0, c: 0, d: 0, e: 0.027524, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 0,
  r: 0, s: 0, t: 0, u: 0, v: 0, w: 0, x: 0, y: 0, z: 0, CD: 0, DD: 0, ED: 0, FD: 0, LC: 0, sC: 0, GD: 0, MC: 0 }, B: "webkit", C: ["", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "CD", "DD", "ED", "FD", "B", "LC", "s\
C", "GD", "C", "MC", "G", "N", "O", "P", "XB", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "\
fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B",
  "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "Q", "H", "R", "UC", "S", "T", "U", "\
V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "\
x", "y", "z", "0", "1", "2", "3", "4", "5", "", ""], E: "Opera", F: { 0: 1739404800, 1: 1744675200, 2: 1747094400, 3: 1751414400, 4: 1756339200,
  5: null, 6: 1393891200, 7: 1399334400, 8: 1401753600, 9: 1405987200, F: 1150761600, CD: 1223424e3, DD: 1251763200, ED: 1267488e3, FD: 1277942400,
  B: 1292457600, LC: 1302566400, sC: 1309219200, GD: 1323129600, C: 1323129600, MC: 1352073600, G: 1372723200, N: 1377561600, O: 1381104e3, P: 1386288e3,
  XB: 1390867200, AB: 1409616e3, BB: 1413331200, CB: 1417132800, DB: 1422316800, EB: 1425945600, YB: 1430179200, ZB: 1433808e3, aB: 1438646400,
  bB: 1442448e3, cB: 1445904e3, dB: 1449100800, eB: 1454371200, fB: 1457308800, gB: 146232e4, hB: 1465344e3, iB: 1470096e3, jB: 1474329600, kB: 1477267200,
  lB: 1481587200, mB: 1486425600, nB: 1490054400, oB: 1494374400, pB: 1498003200, qB: 1502236800, rB: 1506470400, sB: 1510099200, tB: 1515024e3,
  uB: 1517961600, vB: 1521676800, wB: 1525910400, xB: 1530144e3, yB: 1534982400, zB: 1537833600, "0B": 1543363200, "1B": 1548201600, "2B": 1554768e3,
  "3B": 1561593600, "4B": 1566259200, "5B": 1570406400, "6B": 1573689600, "7B": 1578441600, "8B": 1583971200, "9B": 1587513600, AC: 1592956800,
  BC: 1595894400, CC: 1600128e3, DC: 1603238400, EC: 161352e4, FC: 1612224e3, GC: 1616544e3, HC: 1619568e3, IC: 1623715200, JC: 1627948800, Q: 1631577600,
  H: 1633392e3, R: 1635984e3, UC: 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3,
  Z: 1660780800, a: 1663113600, b: 1668816e3, c: 1668643200, d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800, i: 1684195200,
  j: 1687219200, k: 1690329600, l: 1692748800, m: 1696204800, n: 169992e4, o: 169992e4, p: 1702944e3, q: 1707264e3, r: 1710115200, s: 1711497600,
  t: 1716336e3, u: 1719273600, v: 1721088e3, w: 1724284800, x: 1727222400, y: 1732665600, z: 1736294400 }, D: { F: "o", B: "o", C: "o", CD: "\
o", DD: "o", ED: "o", FD: "o", LC: "o", sC: "o", GD: "o", MC: "o" } }, G: { A: { E: 0, XC: 0, HD: 0, tC: 24628e-7, ID: 0, JD: 6157e-6, KD: 49256e-7,
  LD: 0, MD: 0, ND: 0.012314, OD: 12314e-7, PD: 0.0221652, QD: 0.472858, RD: 73884e-7, SD: 24628e-7, TD: 0.0714212, UD: 0, VD: 36942e-7, WD: 24628e-7,
  XD: 0.012314, YD: 0.024628, ZD: 0.0258594, aD: 0.0221652, ZC: 0.0197024, aC: 0.0221652, NC: 0.024628, bD: 0.322627, OC: 0.0394048, bC: 0.0812724,
  cC: 0.0418676, dC: 0.0775782, eC: 0.0172396, fC: 0.0320164, cD: 0.416213, PC: 0.0233966, gC: 0.0406362, hC: 0.0295536, iC: 0.0455618, jC: 0.067727,
  kC: 0.147768, dD: 0.364494, QC: 0.092355, lC: 0.187173, mC: 0.104669, nC: 0.357106, oC: 0.205644, pC: 8.76141, qC: 0.0480246, rC: 0 }, B: "\
webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "XC", "HD", "tC", "ID", "J\
D", "KD", "E", "LD", "MD", "ND", "OD", "PD", "QD", "RD", "SD", "TD", "UD", "VD", "WD", "XD", "YD", "ZD", "aD", "ZC", "aC", "NC", "bD", "OC",
  "bC", "cC", "dC", "eC", "fC", "cD", "PC", "gC", "hC", "iC", "jC", "kC", "dD", "QC", "lC", "mC", "nC", "oC", "pC", "qC", "rC", "", ""], E: "\
Safari on iOS", F: { XC: 1270252800, HD: 1283904e3, tC: 1299628800, ID: 1331078400, JD: 1359331200, KD: 1394409600, E: 1410912e3, LD: 1413763200,
  MD: 1442361600, ND: 1458518400, OD: 1473724800, PD: 1490572800, QD: 1505779200, RD: 1522281600, SD: 1537142400, TD: 1553472e3, UD: 1568851200,
  VD: 1572220800, WD: 1580169600, XD: 1585008e3, YD: 1600214400, ZD: 1619395200, aD: 1632096e3, ZC: 1639353600, aC: 1647216e3, NC: 1652659200,
  bD: 1658275200, OC: 1662940800, bC: 1666569600, cC: 1670889600, dC: 1674432e3, eC: 1679875200, fC: 1684368e3, cD: 1690156800, PC: 1694995200,
  gC: 1698192e3, hC: 1702252800, iC: 1705881600, jC: 1709596800, kC: 1715558400, dD: 1722211200, QC: 1726444800, lC: 1730073600, mC: 1733875200,
  nC: 1737936e3, oC: 1743379200, pC: 1747008e3, qC: 1757894400, rC: null } }, H: { A: { eD: 0.05 }, B: "o", C: ["", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "eD", "", "", ""], E: "\
Opera Mini", F: { eD: 1426464e3 } }, I: { A: { RC: 0, J: 0, I: 1.02412, fD: 0, gD: 0, hD: 0, iD: 102566e-9, tC: 205132e-9, jD: 0, kD: 717963e-9 },
  B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "fD", "gD",
  "hD", "RC", "J", "iD", "tC", "jD", "kD", "I", "", "", ""], E: "Android Browser", F: { fD: 1256515200, gD: 1274313600, hD: 1291593600, RC: 1298332800,
  J: 1318896e3, iD: 1341792e3, tC: 1374624e3, jD: 1386547200, kD: 1401667200, I: 1754352e3 } }, J: { A: { D: 0, A: 0 }, B: "webkit", C: ["",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "D", "A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, H: 0.999937, LC: 0, sC: 0,
  MC: 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "A", "B", "LC", "sC", "C", "MC", "H", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, LC: 1314835200, sC: 1318291200,
  C: 1330300800, MC: 1349740800, H: 1709769600 }, D: { H: "webkit" } }, L: { A: { I: 46.0235 }, B: "webkit", C: ["", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "", "", ""], E: "\
Chrome for Android", F: { I: 1754352e3 } }, M: { A: { KC: 0.327726 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "KC", "", "", ""], E: "Firefox for Android", F: { KC: 1755648e3 } },
  N: { A: { A: 0, B: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { NC: 0.819315 },
  B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "NC", "", "", ""], E: "UC Browser for Android", F: { NC: 1710115200 }, D: { NC: "webkit" } }, P: { A: { 6: 0, 7: 0.0108655,
  8: 0.0108655, 9: 0.0217309, J: 0, AB: 0.0217309, BB: 0.0325964, CB: 0.0543273, DB: 0.0760583, EB: 1.77107, lD: 0, mD: 0, nD: 0.0217309, oD: 0,
  pD: 0, YC: 0, qD: 0, rD: 0, sD: 0, tD: 0, uD: 0, OC: 0, PC: 0, QC: 0, vD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "J", "lD", "mD", "nD", "oD", "pD", "YC", "qD", "rD", "sD", "tD", "uD", "OC", "PC", "QC", "vD", "6", "7", "8", "9", "AB", "BB", "CB",
  "DB", "EB", "", "", ""], E: "Samsung Internet", F: { 6: 1677369600, 7: 1684454400, 8: 1689292800, 9: 1697587200, J: 1461024e3, lD: 1481846400,
  mD: 1509408e3, nD: 1528329600, oD: 1546128e3, pD: 1554163200, YC: 1567900800, qD: 1582588800, rD: 1593475200, sD: 1605657600, tD: 1618531200,
  uD: 1629072e3, OC: 1640736e3, PC: 1651708800, QC: 1659657600, vD: 1667260800, AB: 1711497600, BB: 1715126400, CB: 1717718400, DB: 1725667200,
  EB: 1746057600 } }, Q: { A: { wD: 0.176001 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "wD", "", "", ""], E: "QQ Browser", F: { wD: 1710288e3 } }, R: { A: {
  xD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "xD", "", "", ""], E: "Baidu Browser", F: { xD: 1710201600 } }, S: { A: { yD: 0.012138, zD: 0 }, B: "moz",
  C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "yD", "zD", "", "", ""], E: "KaiOS Browser", F: { yD: 1527811200, zD: 1631664e3 } } };
});

// ../node_modules/caniuse-lite/dist/unpacker/agents.js
var UW = E((K2t, qW) => {
  "use strict";
  var sVe = B1().browsers, LA = RA().browserVersions, LW = RW();
  function jW(e) {
    return Object.keys(e).reduce((t, r) => (t[LA[r]] = e[r], t), {});
  }
  n(jW, "unpackBrowserVersions");
  qW.exports.agents = Object.keys(LW).reduce((e, t) => {
    let r = LW[t];
    return e[sVe[t]] = Object.keys(r).reduce((i, s) => (s === "A" ? i.usage_global = jW(r[s]) : s === "C" ? i.versions = r[s].reduce((a, o) => (o ===
    "" ? a.push(null) : a.push(LA[o]), a), []) : s === "D" ? i.prefix_exceptions = jW(r[s]) : s === "E" ? i.browser = r[s] : s === "F" ? i.release_date =
    Object.keys(r[s]).reduce(
      (a, o) => (a[LA[o]] = r[s][o], a),
      {}
    ) : i.prefix = r[s], i), {}), e;
  }, {});
});

// ../node_modules/electron-to-chromium/versions.js
var VW = E((J2t, $W) => {
  $W.exports = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "9.4": "83",
    "10.0": "85",
    "10.1": "85",
    "10.2": "85",
    "10.3": "85",
    "10.4": "85",
    "11.0": "87",
    "11.1": "87",
    "11.2": "87",
    "11.3": "87",
    "11.4": "87",
    "11.5": "87",
    "12.0": "89",
    "12.1": "89",
    "12.2": "89",
    "13.0": "91",
    "13.1": "91",
    "13.2": "91",
    "13.3": "91",
    "13.4": "91",
    "13.5": "91",
    "13.6": "91",
    "14.0": "93",
    "14.1": "93",
    "14.2": "93",
    "15.0": "94",
    "15.1": "94",
    "15.2": "94",
    "15.3": "94",
    "15.4": "94",
    "15.5": "94",
    "16.0": "96",
    "16.1": "96",
    "16.2": "96",
    "17.0": "98",
    "17.1": "98",
    "17.2": "98",
    "17.3": "98",
    "17.4": "98",
    "18.0": "100",
    "18.1": "100",
    "18.2": "100",
    "18.3": "100",
    "19.0": "102",
    "19.1": "102",
    "20.0": "104",
    "20.1": "104",
    "20.2": "104",
    "20.3": "104",
    "21.0": "106",
    "21.1": "106",
    "21.2": "106",
    "21.3": "106",
    "21.4": "106",
    "22.0": "108",
    "22.1": "108",
    "22.2": "108",
    "22.3": "108",
    "23.0": "110",
    "23.1": "110",
    "23.2": "110",
    "23.3": "110",
    "24.0": "112",
    "24.1": "112",
    "24.2": "112",
    "24.3": "112",
    "24.4": "112",
    "24.5": "112",
    "24.6": "112",
    "24.7": "112",
    "24.8": "112",
    "25.0": "114",
    "25.1": "114",
    "25.2": "114",
    "25.3": "114",
    "25.4": "114",
    "25.5": "114",
    "25.6": "114",
    "25.7": "114",
    "25.8": "114",
    "25.9": "114",
    "26.0": "116",
    "26.1": "116",
    "26.2": "116",
    "26.3": "116",
    "26.4": "116",
    "26.5": "116",
    "26.6": "116",
    "27.0": "118",
    "27.1": "118",
    "27.2": "118",
    "27.3": "118",
    "28.0": "120",
    "28.1": "120",
    "28.2": "120",
    "28.3": "120",
    "29.0": "122",
    "29.1": "122",
    "29.2": "122",
    "29.3": "122",
    "29.4": "122",
    "30.0": "124",
    "30.1": "124",
    "30.2": "124",
    "30.3": "124",
    "30.4": "124",
    "30.5": "124",
    "31.0": "126",
    "31.1": "126",
    "31.2": "126",
    "31.3": "126",
    "31.4": "126",
    "31.5": "126",
    "31.6": "126",
    "31.7": "126",
    "32.0": "128",
    "32.1": "128",
    "32.2": "128",
    "32.3": "128",
    "33.0": "130",
    "33.1": "130",
    "33.2": "130",
    "33.3": "130",
    "33.4": "130",
    "34.0": "132",
    "34.1": "132",
    "34.2": "132",
    "34.3": "132",
    "34.4": "132",
    "34.5": "132",
    "35.0": "134",
    "35.1": "134",
    "35.2": "134",
    "35.3": "134",
    "35.4": "134",
    "35.5": "134",
    "35.6": "134",
    "35.7": "134",
    "36.0": "136",
    "36.1": "136",
    "36.2": "136",
    "36.3": "136",
    "36.4": "136",
    "36.5": "136",
    "36.6": "136",
    "36.7": "136",
    "36.8": "136",
    "36.9": "136",
    "37.0": "138",
    "37.1": "138",
    "37.2": "138",
    "37.3": "138",
    "37.4": "138",
    "37.5": "138",
    "38.0": "140",
    "38.1": "140",
    "39.0": "141"
  };
});

// ../node_modules/node-releases/data/release-schedule/release-schedule.json
var WW = E((X2t, nVe) => {
  nVe.exports = { "v0.8": { start: "2012-06-25", end: "2014-07-31" }, "v0.10": { start: "2013-03-11", end: "2016-10-31" }, "v0.12": { start: "\
2015-02-06", end: "2016-12-31" }, v4: { start: "2015-09-08", lts: "2015-10-12", maintenance: "2017-04-01", end: "2018-04-30", codename: "Arg\
on" }, v5: { start: "2015-10-29", maintenance: "2016-04-30", end: "2016-06-30" }, v6: { start: "2016-04-26", lts: "2016-10-18", maintenance: "\
2018-04-30", end: "2019-04-30", codename: "Boron" }, v7: { start: "2016-10-25", maintenance: "2017-04-30", end: "2017-06-30" }, v8: { start: "\
2017-05-30", lts: "2017-10-31", maintenance: "2019-01-01", end: "2019-12-31", codename: "Carbon" }, v9: { start: "2017-10-01", maintenance: "\
2018-04-01", end: "2018-06-30" }, v10: { start: "2018-04-24", lts: "2018-10-30", maintenance: "2020-05-19", end: "2021-04-30", codename: "Du\
bnium" }, v11: { start: "2018-10-23", maintenance: "2019-04-22", end: "2019-06-01" }, v12: { start: "2019-04-23", lts: "2019-10-21", maintenance: "\
2020-11-30", end: "2022-04-30", codename: "Erbium" }, v13: { start: "2019-10-22", maintenance: "2020-04-01", end: "2020-06-01" }, v14: { start: "\
2020-04-21", lts: "2020-10-27", maintenance: "2021-10-19", end: "2023-04-30", codename: "Fermium" }, v15: { start: "2020-10-20", maintenance: "\
2021-04-01", end: "2021-06-01" }, v16: { start: "2021-04-20", lts: "2021-10-26", maintenance: "2022-10-18", end: "2023-09-11", codename: "Ga\
llium" }, v17: { start: "2021-10-19", maintenance: "2022-04-01", end: "2022-06-01" }, v18: { start: "2022-04-19", lts: "2022-10-25", maintenance: "\
2023-10-18", end: "2025-04-30", codename: "Hydrogen" }, v19: { start: "2022-10-18", maintenance: "2023-04-01", end: "2023-06-01" }, v20: { start: "\
2023-04-18", lts: "2023-10-24", maintenance: "2024-10-22", end: "2026-04-30", codename: "Iron" }, v21: { start: "2023-10-17", maintenance: "\
2024-04-01", end: "2024-06-01" }, v22: { start: "2024-04-24", lts: "2024-10-29", maintenance: "2025-10-21", end: "2027-04-30", codename: "Jo\
d" }, v23: { start: "2024-10-16", maintenance: "2025-04-01", end: "2025-06-01" }, v24: { start: "2025-05-06", lts: "2025-10-28", maintenance: "\
2026-10-20", end: "2028-04-30", codename: "" }, v25: { start: "2025-10-15", maintenance: "2026-04-01", end: "2026-06-01" }, v26: { start: "2\
026-04-22", lts: "2026-10-28", maintenance: "2027-10-20", end: "2029-04-30", codename: "" } };
});

// ../node_modules/browserslist/error.js
var qA = E((Y2t, HW) => {
  function jA(e) {
    this.name = "BrowserslistError", this.message = e, this.browserslist = !0, Error.captureStackTrace && Error.captureStackTrace(this, jA);
  }
  n(jA, "BrowserslistError");
  jA.prototype = Error.prototype;
  HW.exports = jA;
});

// ../node_modules/caniuse-lite/dist/lib/statuses.js
var zW = E((Z2t, KW) => {
  KW.exports = {
    1: "ls",
    // WHATWG Living Standard
    2: "rec",
    // W3C Recommendation
    3: "pr",
    // W3C Proposed Recommendation
    4: "cr",
    // W3C Candidate Recommendation
    5: "wd",
    // W3C Working Draft
    6: "other",
    // Non-W3C, but reputable
    7: "unoff"
    // Unofficial, Editor's Draft or W3C "Note"
  };
});

// ../node_modules/caniuse-lite/dist/lib/supported.js
var XW = E((Q2t, JW) => {
  JW.exports = {
    y: 1,
    n: 2,
    a: 4,
    p: 8,
    u: 16,
    x: 32,
    d: 64
  };
});

// ../node_modules/caniuse-lite/dist/unpacker/feature.js
var ZW = E((eDt, UA) => {
  "use strict";
  var aVe = zW(), YW = XW(), oVe = B1().browsers, uVe = RA().browserVersions, lVe = Math.log(2);
  function cVe(e) {
    let t = Object.keys(YW).reduce((s, a) => (e & YW[a] && s.push(a), s), []), r = e >> 7, i = [];
    for (; r; ) {
      let s = Math.floor(Math.log(r) / lVe) + 1;
      i.unshift(`#${s}`), r -= Math.pow(2, s - 1);
    }
    return t.concat(i).join(" ");
  }
  n(cVe, "unpackSupport");
  function GW(e) {
    let t = {
      status: aVe[e.B],
      title: e.C,
      shown: e.D
    };
    return t.stats = Object.keys(e.A).reduce((r, i) => {
      let s = e.A[i];
      return r[oVe[i]] = Object.keys(s).reduce(
        (a, o) => {
          let u = s[o].split(" "), l = cVe(o);
          return u.forEach((c) => a[uVe[c]] = l), a;
        },
        {}
      ), r;
    }, {}), t;
  }
  n(GW, "unpackFeature");
  UA.exports = GW;
  UA.exports.default = GW;
});

// ../node_modules/caniuse-lite/dist/unpacker/region.js
var eH = E((rDt, $A) => {
  "use strict";
  var fVe = B1().browsers;
  function QW(e) {
    return Object.keys(e).reduce((t, r) => {
      let i = e[r];
      return t[fVe[r]] = Object.keys(i).reduce((s, a) => {
        let o = i[a];
        return a === "_" ? o.split(" ").forEach((u) => s[u] = null) : s[a] = o, s;
      }, {}), t;
    }, {});
  }
  n(QW, "unpackRegion");
  $A.exports = QW;
  $A.exports.default = QW;
});

// ../node_modules/browserslist/node.js
var pH = E((sDt, Cp) => {
  var dVe = ZW().default, pVe = eH().default, pc = require("fs"), Cs = require("path"), Wr = qA(), tH = /^\s*\[(.+)]\s*$/, hVe = /^browserslist-config-/,
  mVe = /@[^/]+(?:\/[^/]+)?\/browserslist-config(?:-|$|\/)/, rH = "Browserslist config should be a string or an array of strings with browse\
r queries", yVe = "unknown", lH = "directory", cH = "file", VA = !1, iH = {}, sH = {}, N1 = {};
  function nH(e) {
    var t = " Use `dangerousExtend` option to disable.";
    if (!hVe.test(e) && !mVe.test(e))
      throw new Wr(
        "Browserslist config needs `browserslist-config-` prefix. " + t
      );
    if (e.replace(/^@[^/]+\//, "").indexOf(".") !== -1)
      throw new Wr(
        "`.` not allowed in Browserslist config name. " + t
      );
    if (e.indexOf("node_modules") !== -1)
      throw new Wr(
        "`node_modules` not allowed in Browserslist config." + t
      );
  }
  n(nH, "checkExtend");
  function fH(e) {
    var t;
    try {
      t = pc.existsSync(e) && pc.statSync(e);
    } catch (r) {
      if (r.code !== "ENOENT" && r.code !== "EACCES" && r.code !== "ERR_ACCESS_DENIED")
        throw r;
    }
    return t && t.isDirectory() ? lH : t && t.isFile() ? cH : yVe;
  }
  n(fH, "getPathType");
  function Yn(e) {
    return fH(e) === cH;
  }
  n(Yn, "isFile");
  function gVe(e) {
    return fH(e) === lH;
  }
  n(gVe, "isDirectory");
  function aH(e, t, r) {
    var i = Cs.resolve(e), s = [], a;
    do {
      if (!bVe(i))
        break;
      if (r && i in r) {
        a = r[i];
        break;
      }
      if (s.push(i), !!gVe(i)) {
        var o = t(i);
        if (typeof o < "u") {
          a = o;
          break;
        }
      }
    } while (i !== (i = Cs.dirname(i)));
    return r && !process.env.BROWSERSLIST_DISABLE_CACHE && s.forEach(function(u) {
      r[u] = a;
    }), a;
  }
  n(aH, "eachParent");
  function bVe(e) {
    if (!process.env.BROWSERSLIST_ROOT_PATH) return !0;
    var t = Cs.resolve(process.env.BROWSERSLIST_ROOT_PATH);
    return Cs.relative(t, e).substring(0, 2) !== "..";
  }
  n(bVe, "pathInRoot");
  function DVe(e) {
    if (Array.isArray(e)) {
      for (var t = 0; t < e.length; t++)
        if (typeof e[t] != "string")
          throw new Wr(rH);
    } else if (typeof e != "string")
      throw new Wr(rH);
  }
  n(DVe, "check");
  function WA(e, t) {
    if (typeof e != "object") return e;
    var r;
    if (typeof t.env == "string" ? r = t.env : process.env.BROWSERSLIST_ENV ? r = process.env.BROWSERSLIST_ENV : process.env.NODE_ENV ? r = process.
    env.NODE_ENV : r = "production", t.throwOnMissing && r && r !== "defaults" && !e[r])
      throw new Wr(
        "Missing config for Browserslist environment `" + r + "`"
      );
    return e[r] || e.defaults;
  }
  n(WA, "pickEnv");
  function dH(e) {
    var t = pc.readFileSync(e).toString().replace(/^\uFEFF/m, ""), r;
    if (t.indexOf('"browserslist"') >= 0)
      r = JSON.parse(t).browserslist;
    else if (t.indexOf('"browserlist"') >= 0) {
      var i = JSON.parse(t);
      if (i.browserlist && !i.browserslist)
        throw new Wr(
          "`browserlist` key instead of `browserslist` in " + e
        );
    }
    (Array.isArray(r) || typeof r == "string") && (r = { defaults: r });
    for (var s in r)
      DVe(r[s]);
    return r;
  }
  n(dH, "parsePackage");
  function oH(e) {
    if (e in N1)
      return N1[e];
    var t = Cs.basename(e) === "package.json", r = t ? dH(e) : Cp.exports.readConfig(e);
    return process.env.BROWSERSLIST_DISABLE_CACHE || (N1[e] = r), r;
  }
  n(oH, "parsePackageOrReadConfig");
  function vVe(e) {
    var t = 0;
    for (var r in e) {
      var i = e[r].releaseDate || {};
      for (var s in i)
        t < i[s] && (t = i[s]);
    }
    return t * 1e3;
  }
  n(vVe, "latestReleaseTime");
  function xVe(e) {
    var t = /* @__PURE__ */ new Date(), r = new Date(e), i = t.getFullYear() - r.getFullYear(), s = t.getMonth() - r.getMonth();
    return i * 12 + s;
  }
  n(xVe, "getMonthsPassed");
  function uH(e, t) {
    if (e || (e = {}), t && "dataByBrowser" in t && (t = t.dataByBrowser), typeof t == "object") {
      var r = {};
      for (var i in t) {
        var s = Object.keys(t[i]);
        if (s.length === 1 && e[i] && e[i].versions.length === 1) {
          var a = e[i].versions[0];
          r[i] = {}, r[i][a] = t[i][s[0]];
        } else
          r[i] = t[i];
      }
      return r;
    }
  }
  n(uH, "normalizeStats");
  function EVe(e, t) {
    for (var r in e) {
      var i = e[r];
      if ("0" in i) {
        var s = t[r].versions;
        i[s[s.length - 1]] = i[0], delete i[0];
      }
    }
  }
  n(EVe, "normalizeUsageData");
  Cp.exports = {
    loadQueries: /* @__PURE__ */ n(function(t, r) {
      !t.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && nH(r);
      var i = require(require.resolve(r, { paths: [".", t.path] }));
      if (typeof i == "object" && i !== null && i.__esModule && (i = i.default), i) {
        if (Array.isArray(i))
          return i;
        if (typeof i == "object")
          return i.defaults || (i.defaults = []), WA(i, t, r);
      }
      throw new Wr(
        "`" + r + "` config exports not an array of queries or an object of envs"
      );
    }, "loadQueries"),
    loadStat: /* @__PURE__ */ n(function(t, r, i) {
      !t.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && nH(r);
      var s = require(
        // Use forward slashes for module paths, also on Windows.
        require.resolve(Cs.posix.join(r, "browserslist-stats.json"), {
          paths: ["."]
        })
      );
      return uH(i, s);
    }, "loadStat"),
    getStat: /* @__PURE__ */ n(function(t, r) {
      var i;
      if (t.stats ? i = t.stats : process.env.BROWSERSLIST_STATS ? i = process.env.BROWSERSLIST_STATS : t.path && Cs.resolve && pc.existsSync &&
      (i = aH(
        t.path,
        function(s) {
          var a = Cs.join(s, "browserslist-stats.json");
          return Yn(a) ? a : void 0;
        },
        iH
      )), typeof i == "string")
        try {
          i = JSON.parse(pc.readFileSync(i));
        } catch {
          throw new Wr("Can't read " + i);
        }
      return uH(r, i);
    }, "getStat"),
    loadConfig: /* @__PURE__ */ n(function(t) {
      if (process.env.BROWSERSLIST)
        return process.env.BROWSERSLIST;
      if (t.config || process.env.BROWSERSLIST_CONFIG) {
        var r = t.config || process.env.BROWSERSLIST_CONFIG;
        return WA(oH(r), t);
      } else return t.path ? WA(Cp.exports.findConfig(t.path), t) : void 0;
    }, "loadConfig"),
    loadCountry: /* @__PURE__ */ n(function(t, r, i) {
      var s = r.replace(/[^\w-]/g, "");
      if (!t[s]) {
        var a;
        try {
          a = require("caniuse-lite/data/regions/" + s + ".js");
        } catch {
          throw new Wr("Unknown region name `" + s + "`.");
        }
        var o = pVe(a);
        EVe(o, i), t[r] = {};
        for (var u in o)
          for (var l in o[u])
            t[r][u + " " + l] = o[u][l];
      }
    }, "loadCountry"),
    loadFeature: /* @__PURE__ */ n(function(t, r) {
      if (r = r.replace(/[^\w-]/g, ""), !t[r]) {
        var i;
        try {
          i = require("caniuse-lite/data/features/" + r + ".js");
        } catch {
          throw new Wr("Unknown feature name `" + r + "`.");
        }
        var s = dVe(i).stats;
        t[r] = {};
        for (var a in s) {
          t[r][a] = {};
          for (var o in s[a])
            t[r][a][o] = s[a][o];
        }
      }
    }, "loadFeature"),
    parseConfig: /* @__PURE__ */ n(function(t) {
      var r = { defaults: [] }, i = ["defaults"];
      return t.toString().replace(/#[^\n]*/g, "").split(/\n|,/).map(function(s) {
        return s.trim();
      }).filter(function(s) {
        return s !== "";
      }).forEach(function(s) {
        tH.test(s) ? (i = s.match(tH)[1].trim().split(" "), i.forEach(function(a) {
          if (r[a])
            throw new Wr(
              "Duplicate section " + a + " in Browserslist config"
            );
          r[a] = [];
        })) : i.forEach(function(a) {
          r[a].push(s);
        });
      }), r;
    }, "parseConfig"),
    readConfig: /* @__PURE__ */ n(function(t) {
      if (!Yn(t))
        throw new Wr("Can't read " + t + " config");
      return Cp.exports.parseConfig(pc.readFileSync(t));
    }, "readConfig"),
    findConfigFile: /* @__PURE__ */ n(function(t) {
      return aH(
        t,
        function(r) {
          var i = Cs.join(r, "browserslist"), s = Cs.join(r, "package.json"), a = Cs.join(r, ".browserslistrc"), o;
          if (Yn(s))
            try {
              o = dH(s);
            } catch (u) {
              if (u.name === "BrowserslistError") throw u;
              console.warn(
                "[Browserslist] Could not parse " + s + ". Ignoring it."
              );
            }
          if (Yn(i) && o)
            throw new Wr(
              r + " contains both browserslist and package.json with browsers"
            );
          if (Yn(a) && o)
            throw new Wr(
              r + " contains both .browserslistrc and package.json with browsers"
            );
          if (Yn(i) && Yn(a))
            throw new Wr(
              r + " contains both .browserslistrc and browserslist"
            );
          if (Yn(i))
            return i;
          if (Yn(a))
            return a;
          if (o)
            return s;
        },
        sH
      );
    }, "findConfigFile"),
    findConfig: /* @__PURE__ */ n(function(t) {
      var r = this.findConfigFile(t);
      return r ? oH(r) : void 0;
    }, "findConfig"),
    clearCaches: /* @__PURE__ */ n(function() {
      VA = !1, iH = {}, sH = {}, N1 = {}, this.cache = {};
    }, "clearCaches"),
    oldDataWarning: /* @__PURE__ */ n(function(t) {
      if (!VA && (VA = !0, !process.env.BROWSERSLIST_IGNORE_OLD_DATA)) {
        var r = vVe(t), i = xVe(r);
        if (r !== 0 && i >= 6) {
          var s = i + " " + (i > 1 ? "months" : "month");
          console.warn(
            "Browserslist: browsers data (caniuse-lite) is " + s + ` old. Please run:
  npx update-browserslist-db@latest
  Why you should do it regularly: https://github.com/browserslist/update-db#readme`
          );
        }
      }
    }, "oldDataWarning"),
    currentNode: /* @__PURE__ */ n(function() {
      return "node " + process.versions.node;
    }, "currentNode"),
    env: process.env
  };
});

// ../node_modules/browserslist/parse.js
var bH = E((aDt, gH) => {
  var hH = /^\s+and\s+(.*)/i, mH = /^(?:,\s*|\s+or\s+)(.*)/i;
  function yH(e) {
    return Array.isArray(e) ? e.reduce(function(t, r) {
      return t.concat(yH(r));
    }, []) : [e];
  }
  n(yH, "flatten");
  function SVe(e, t) {
    for (var r = e.length, i = 1; i <= r; i++) {
      var s = e.substr(-i, i);
      if (t(s, i, r))
        return e.slice(0, -i);
    }
    return "";
  }
  n(SVe, "find");
  function HA(e, t) {
    var r = { query: t };
    t.indexOf("not ") === 0 && (r.not = !0, t = t.slice(4));
    for (var i in e) {
      var s = e[i], a = t.match(s.regexp);
      if (a) {
        r.type = i;
        for (var o = 0; o < s.matches.length; o++)
          r[s.matches[o]] = a[o + 1];
        return r;
      }
    }
    return r.type = "unknown", r;
  }
  n(HA, "matchQuery");
  function TVe(e, t, r) {
    var i;
    return SVe(t, function(s, a, o) {
      return hH.test(s) ? (i = HA(e, s.match(hH)[1]), i.compose = "and", r.unshift(i), !0) : mH.test(s) ? (i = HA(e, s.match(mH)[1]), i.compose =
      "or", r.unshift(i), !0) : a === o ? (i = HA(e, s.trim()), i.compose = "or", r.unshift(i), !0) : !1;
    });
  }
  n(TVe, "matchBlock");
  gH.exports = /* @__PURE__ */ n(function(t, r) {
    return Array.isArray(r) || (r = [r]), yH(
      r.map(function(i) {
        var s = [];
        do
          i = TVe(t, i, s);
        while (i);
        return s;
      })
    );
  }, "parse");
});

// ../node_modules/browserslist/index.js
var NH = E((uDt, BH) => {
  var M1 = _W(), CVe = PW(), Gn = UW().agents, ws = VW(), KA = WW(), $1 = require("path"), li = qA(), Er = pH(), wVe = bH(), AVe = 365.259641 *
  24 * 60 * 60 * 1e3, wH = "37", _Ve = 14;
  function AH(e, t) {
    return (e + ".").indexOf(t + ".") === 0;
  }
  n(AH, "isVersionsMatch");
  function PVe(e) {
    var t = e.slice(1);
    return De.nodeVersions.some(function(r) {
      return AH(r, t);
    });
  }
  n(PVe, "isEolReleased");
  function DH(e) {
    return e.filter(function(t) {
      return typeof t == "string";
    });
  }
  n(DH, "normalize");
  function R1(e) {
    var t = e;
    return e.split(".").length === 3 && (t = e.split(".").slice(0, -1).join(".")), t;
  }
  n(R1, "normalizeElectron");
  function Ja(e) {
    return /* @__PURE__ */ n(function(r) {
      return e + " " + r;
    }, "mapName");
  }
  n(Ja, "nameMapper");
  function ZA(e) {
    return parseInt(e.split(".")[0]);
  }
  n(ZA, "getMajor");
  function L1(e, t) {
    if (e.length === 0) return [];
    var r = _H(e.map(ZA)), i = r[r.length - t];
    if (!i)
      return e;
    for (var s = [], a = e.length - 1; a >= 0 && !(i > ZA(e[a])); a--)
      s.unshift(e[a]);
    return s;
  }
  n(L1, "getMajorVersions");
  function _H(e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.indexOf(e[r]) === -1 && t.push(e[r]);
    return t;
  }
  n(_H, "uniq");
  function V1(e, t, r) {
    for (var i in r)
      e[t + " " + i] = r[i];
  }
  n(V1, "fillUsage");
  function vH(e, t) {
    if (t = parseFloat(t), e === ">")
      return function(i) {
        return r(i) > t;
      };
    return e === ">=" ? function(i) {
      return r(i) >= t;
    } : e === "<" ? function(i) {
      return parseFloat(i) < t;
    } : function(i) {
      return parseFloat(i) <= t;
    };
    function r(i) {
      return parseFloat(i.split("-")[1] || i);
    }
  }
  n(vH, "generateFilter");
  function FVe(e, t) {
    return t = t.split(".").map(Xa), t[1] = t[1] || 0, t[2] = t[2] || 0, e === ">" ? function(r) {
      return r = r.split(".").map(Xa), wp(r, t) > 0;
    } : e === ">=" ? function(r) {
      return r = r.split(".").map(Xa), wp(r, t) >= 0;
    } : e === "<" ? function(r) {
      return r = r.split(".").map(Xa), wp(t, r) > 0;
    } : function(r) {
      return r = r.split(".").map(Xa), wp(t, r) >= 0;
    };
  }
  n(FVe, "generateSemverFilter");
  function Xa(e) {
    return parseInt(e);
  }
  n(Xa, "parseSimpleInt");
  function U1(e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
  }
  n(U1, "compare");
  function wp(e, t) {
    return U1(parseInt(e[0]), parseInt(t[0])) || U1(parseInt(e[1] || "0"), parseInt(t[1] || "0")) || U1(parseInt(e[2] || "0"), parseInt(t[2] ||
    "0"));
  }
  n(wp, "compareSemver");
  function xH(e, t) {
    switch (t = t.split(".").map(Xa), typeof t[1] > "u" && (t[1] = "x"), e) {
      case "<=":
        return function(r) {
          return r = r.split(".").map(Xa), EH(r, t) <= 0;
        };
      case ">=":
      default:
        return function(r) {
          return r = r.split(".").map(Xa), EH(r, t) >= 0;
        };
    }
  }
  n(xH, "semverFilterLoose");
  function EH(e, t) {
    return e[0] !== t[0] ? e[0] < t[0] ? -1 : 1 : t[1] === "x" ? 0 : e[1] !== t[1] ? e[1] < t[1] ? -1 : 1 : 0;
  }
  n(EH, "compareSemverLoose");
  function IVe(e, t) {
    return e.versions.indexOf(t) !== -1 ? t : De.versionAliases[e.name][t] ? De.versionAliases[e.name][t] : !1;
  }
  n(IVe, "resolveVersion");
  function j1(e, t) {
    var r = IVe(e, t);
    return r || (e.versions.length === 1 ? e.versions[0] : !1);
  }
  n(j1, "normalizeVersion");
  function PH(e, t) {
    return e = e / 1e3, Object.keys(Gn).reduce(function(r, i) {
      var s = Ya(i, t);
      if (!s) return r;
      var a = Object.keys(s.releaseDate).filter(function(o) {
        var u = s.releaseDate[o];
        return u !== null && u >= e;
      });
      return r.concat(a.map(Ja(s.name)));
    }, []);
  }
  n(PH, "filterByYear");
  function SH(e) {
    return {
      name: e.name,
      versions: e.versions,
      released: e.released,
      releaseDate: e.releaseDate
    };
  }
  n(SH, "cloneData");
  function Ya(e, t) {
    if (e = e.toLowerCase(), e = De.aliases[e] || e, t.mobileToDesktop && De.desktopNames[e]) {
      var r = De.data[De.desktopNames[e]];
      if (e === "android")
        return kVe(SH(De.data[e]), r);
      var i = SH(r);
      return i.name = e, i;
    }
    return De.data[e];
  }
  n(Ya, "byName");
  function TH(e, t) {
    var r = t.indexOf(wH);
    return e.filter(function(i) {
      return /^(?:[2-4]\.|[34]$)/.test(i);
    }).concat(t.slice(r));
  }
  n(TH, "normalizeAndroidVersions");
  function OVe(e) {
    var t = {};
    for (var r in e)
      t[r] = e[r];
    return t;
  }
  n(OVe, "copyObject");
  function kVe(e, t) {
    return e.released = TH(e.released, t.released), e.versions = TH(e.versions, t.versions), e.releaseDate = OVe(e.releaseDate), e.released.
    forEach(function(r) {
      e.releaseDate[r] === void 0 && (e.releaseDate[r] = t.releaseDate[r]);
    }), e;
  }
  n(kVe, "normalizeAndroidData");
  function hc(e, t) {
    var r = Ya(e, t);
    if (!r) throw new li("Unknown browser " + e);
    return r;
  }
  n(hc, "checkName");
  function BVe(e) {
    return new li(
      "Unknown browser query `" + e + "`. Maybe you are using old Browserslist or made typo in query."
    );
  }
  n(BVe, "unknownQuery");
  function q1(e, t, r, i) {
    var s = 1;
    switch (t) {
      case "android":
        if (i.mobileToDesktop) return e;
        var a = De.data.chrome.released;
        s = a.length - a.indexOf(wH);
        break;
      case "op_mob":
        var o = De.data.op_mob.released.slice(-1)[0];
        s = ZA(o) - _Ve + 1;
        break;
      default:
        return e;
    }
    return r <= s ? e.slice(-1) : e.slice(s - 1 - r);
  }
  n(q1, "filterJumps");
  function CH(e, t) {
    return typeof e == "string" && (e.indexOf("y") >= 0 || t && e.indexOf("a") >= 0);
  }
  n(CH, "isSupported");
  function mu(e, t) {
    return QA(e).reduce(function(r, i, s) {
      if (i.not && s === 0)
        throw new li(
          "Write any browsers query (for instance, `defaults`) before `" + i.query + "`"
        );
      var a = e_[i.type], o = a.select.call(De, t, i).map(function(l) {
        var c = l.split(" ");
        return c[1] === "0" ? c[0] + " " + Ya(c[0], t).versions[0] : l;
      });
      if (i.compose === "and")
        return i.not ? r.filter(function(l) {
          return o.indexOf(l) === -1;
        }) : r.filter(function(l) {
          return o.indexOf(l) !== -1;
        });
      if (i.not) {
        var u = {};
        return o.forEach(function(l) {
          u[l] = !0;
        }), r.filter(function(l) {
          return !u[l];
        });
      }
      return r.concat(o);
    }, []);
  }
  n(mu, "resolve");
  function FH(e) {
    return typeof e > "u" && (e = {}), typeof e.path > "u" && (e.path = $1.resolve ? $1.resolve(".") : "."), e;
  }
  n(FH, "prepareOpts");
  function IH(e, t) {
    if (typeof e > "u" || e === null) {
      var r = De.loadConfig(t);
      r ? e = r : e = De.defaults;
    }
    return e;
  }
  n(IH, "prepareQueries");
  function OH(e) {
    if (!(typeof e == "string" || Array.isArray(e)))
      throw new li(
        "Browser queries must be an array or string. Got " + typeof e + "."
      );
  }
  n(OH, "checkQueries");
  var zA = {}, JA = {};
  function De(e, t) {
    t = FH(t), e = IH(e, t), OH(e);
    var r = QA(e).some(function(l) {
      return e_[l.type].needsPath;
    }), i = {
      ignoreUnknownVersions: t.ignoreUnknownVersions,
      dangerousExtend: t.dangerousExtend,
      mobileToDesktop: t.mobileToDesktop,
      env: t.env
    };
    r && (i.path = t.path), Er.oldDataWarning(De.data);
    var s = Er.getStat(t, De.data);
    if (s) {
      i.customUsage = {};
      for (var a in s)
        V1(i.customUsage, a, s[a]);
    }
    var o = JSON.stringify([e, i]);
    if (zA[o]) return zA[o];
    var u = _H(mu(e, i)).sort(function(l, c) {
      if (l = l.split(" "), c = c.split(" "), l[0] === c[0]) {
        var f = l[1].split("-")[0], m = c[1].split("-")[0];
        return wp(m.split("."), f.split("."));
      } else
        return U1(l[0], c[0]);
    });
    return Er.env.BROWSERSLIST_DISABLE_CACHE || (zA[o] = u), u;
  }
  n(De, "browserslist");
  function QA(e) {
    var t = JSON.stringify(e);
    if (t in JA) return JA[t];
    var r = wVe(e_, e);
    return Er.env.BROWSERSLIST_DISABLE_CACHE || (JA[t] = r), r;
  }
  n(QA, "parseQueries");
  function kH(e, t) {
    var r = Er.loadStat(e, t, De.data);
    if (r) {
      e.customUsage = {};
      for (var i in r)
        V1(e.customUsage, i, r[i]);
    }
    if (!e.customUsage)
      throw new li("Custom usage statistics was not provided");
    return e.customUsage;
  }
  n(kH, "loadCustomUsage");
  De.parse = function(e, t) {
    return t = FH(t), e = IH(e, t), OH(e), QA(e);
  };
  De.cache = {};
  De.data = {};
  De.usage = {
    global: {},
    custom: null
  };
  De.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
  De.aliases = {
    fx: "firefox",
    ff: "firefox",
    ios: "ios_saf",
    explorer: "ie",
    blackberry: "bb",
    explorermobile: "ie_mob",
    operamini: "op_mini",
    operamobile: "op_mob",
    chromeandroid: "and_chr",
    firefoxandroid: "and_ff",
    ucandroid: "and_uc",
    qqandroid: "and_qq"
  };
  De.desktopNames = {
    and_chr: "chrome",
    and_ff: "firefox",
    ie_mob: "ie",
    android: "chrome"
    // has extra processing logic
  };
  De.versionAliases = {};
  De.clearCaches = Er.clearCaches;
  De.parseConfig = Er.parseConfig;
  De.readConfig = Er.readConfig;
  De.findConfigFile = Er.findConfigFile;
  De.findConfig = Er.findConfig;
  De.loadConfig = Er.loadConfig;
  De.coverage = function(e, t) {
    var r;
    if (typeof t > "u")
      r = De.usage.global;
    else if (t === "my stats") {
      var i = {};
      i.path = $1.resolve ? $1.resolve(".") : ".";
      var s = Er.getStat(i);
      if (!s)
        throw new li("Custom usage statistics was not provided");
      r = {};
      for (var a in s)
        V1(r, a, s[a]);
    } else if (typeof t == "string")
      t.length > 2 ? t = t.toLowerCase() : t = t.toUpperCase(), Er.loadCountry(De.usage, t, De.data), r = De.usage[t];
    else {
      "dataByBrowser" in t && (t = t.dataByBrowser), r = {};
      for (var o in t)
        for (var u in t[o])
          r[o + " " + u] = t[o][u];
    }
    return e.reduce(function(l, c) {
      var f = r[c];
      return f === void 0 && (f = r[c.replace(/ \S+$/, " 0")]), l + (f || 0);
    }, 0);
  };
  function XA(e, t) {
    var r = De.nodeVersions.filter(function(i) {
      return AH(i, t.version);
    });
    if (r.length === 0) {
      if (e.ignoreUnknownVersions)
        return [];
      throw new li(
        "Unknown version " + t.version + " of Node.js"
      );
    }
    return ["node " + r[r.length - 1]];
  }
  n(XA, "nodeQuery");
  function YA(e, t) {
    var r = parseInt(t.year), i = parseInt(t.month || "01") - 1, s = parseInt(t.day || "01");
    return PH(Date.UTC(r, i, s, 0, 0, 0), e);
  }
  n(YA, "sinceQuery");
  function NVe(e) {
    var t = {
      chrome: "chrome",
      chrome_android: "and_chr",
      edge: "edge",
      firefox: "firefox",
      firefox_android: "and_ff",
      safari: "safari",
      safari_ios: "ios_saf",
      webview_android: "android",
      samsunginternet_android: "samsung",
      opera_android: "op_mob",
      opera: "opera",
      qq_android: "and_qq",
      uc_android: "and_uc",
      kai_os: "kaios"
    };
    return e.filter(function(r) {
      return Object.keys(t).indexOf(r.browser) !== -1;
    }).map(function(r) {
      return t[r.browser] + " >= " + r.version;
    });
  }
  n(NVe, "bbmTransform");
  function GA(e, t) {
    var r = parseFloat(t.coverage), i = De.usage.global;
    if (t.place)
      if (t.place.match(/^my\s+stats$/i)) {
        if (!e.customUsage)
          throw new li("Custom usage statistics was not provided");
        i = e.customUsage;
      } else {
        var s;
        t.place.length === 2 ? s = t.place.toUpperCase() : s = t.place.toLowerCase(), Er.loadCountry(De.usage, s, De.data), i = De.usage[s];
      }
    else t.config && (i = kH(e, t.config));
    for (var a = Object.keys(i).sort(function(f, m) {
      return i[m] - i[f];
    }), o = 0, u = [], l, c = 0; c < a.length && (l = a[c], !(i[l] === 0 || (o += i[l], u.push(l), o >= r))); c++)
      ;
    return u;
  }
  n(GA, "coverQuery");
  var e_ = {
    last_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        return Object.keys(Gn).reduce(function(r, i) {
          var s = Ya(i, e);
          if (!s) return r;
          var a = L1(s.released, t.versions);
          return a = a.map(Ja(s.name)), a = q1(a, s.name, t.versions, e), r.concat(a);
        }, []);
      }, "select")
    },
    last_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+versions?$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        return Object.keys(Gn).reduce(function(r, i) {
          var s = Ya(i, e);
          if (!s) return r;
          var a = s.released.slice(-t.versions);
          return a = a.map(Ja(s.name)), a = q1(a, s.name, t.versions, e), r.concat(a);
        }, []);
      }, "select")
    },
    last_electron_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = L1(Object.keys(ws), t.versions);
        return r.map(function(i) {
          return "chrome " + ws[i];
        });
      }, "select")
    },
    last_node_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        return L1(De.nodeVersions, t.versions).map(
          function(r) {
            return "node " + r;
          }
        );
      }, "select")
    },
    last_browser_major_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = hc(t.browser, e), i = L1(r.released, t.versions), s = i.map(Ja(r.name));
        return s = q1(s, r.name, t.versions, e), s;
      }, "select")
    },
    last_electron_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        return Object.keys(ws).slice(-t.versions).map(function(r) {
          return "chrome " + ws[r];
        });
      }, "select")
    },
    last_node_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        return De.nodeVersions.slice(-t.versions).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    last_browser_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = hc(t.browser, e), i = r.released.slice(-t.versions).map(Ja(r.name));
        return i = q1(i, r.name, t.versions, e), i;
      }, "select")
    },
    unreleased_versions: {
      matches: [],
      regexp: /^unreleased\s+versions$/i,
      select: /* @__PURE__ */ n(function(e) {
        return Object.keys(Gn).reduce(function(t, r) {
          var i = Ya(r, e);
          if (!i) return t;
          var s = i.versions.filter(function(a) {
            return i.released.indexOf(a) === -1;
          });
          return s = s.map(Ja(i.name)), t.concat(s);
        }, []);
      }, "select")
    },
    unreleased_electron_versions: {
      matches: [],
      regexp: /^unreleased\s+electron\s+versions?$/i,
      select: /* @__PURE__ */ n(function() {
        return [];
      }, "select")
    },
    unreleased_browser_versions: {
      matches: ["browser"],
      regexp: /^unreleased\s+(\w+)\s+versions?$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = hc(t.browser, e);
        return r.versions.filter(function(i) {
          return r.released.indexOf(i) === -1;
        }).map(Ja(r.name));
      }, "select")
    },
    last_years: {
      matches: ["years"],
      regexp: /^last\s+((\d+\.)?\d+)\s+years?$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        return PH(Date.now() - AVe * t.years, e);
      }, "select")
    },
    since_y: {
      matches: ["year"],
      regexp: /^since (\d+)$/i,
      select: YA
    },
    since_y_m: {
      matches: ["year", "month"],
      regexp: /^since (\d+)-(\d+)$/i,
      select: YA
    },
    since_y_m_d: {
      matches: ["year", "month", "day"],
      regexp: /^since (\d+)-(\d+)-(\d+)$/i,
      select: YA
    },
    baseline: {
      matches: ["year", "availability", "date", "downstream", "kaios"],
      // Matches:
      //   baseline 2024
      //   baseline newly available
      //   baseline widely available
      //   baseline widely available on 2024-06-01
      //   ...with downstream
      //   ...including kaios
      regexp: /^baseline\s+(?:(\d+)|(newly|widely)\s+available(?:\s+on\s+(\d{4}-\d{2}-\d{2}))?)?(\s+with\s+downstream)?(\s+including\s+kaios)?$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        var r, i = !!t.downstream, s = !!t.kaios;
        if (t.availability === "newly" && t.date)
          throw new li(
            'Using newly available with a date is not supported, please use "widely available on YYYY-MM-DD" and add 30 months to the date y\
ou specified.'
          );
        if (t.year)
          r = M1.getCompatibleVersions({
            targetYear: t.year,
            includeDownstreamBrowsers: i,
            includeKaiOS: s
          });
        else if (t.date)
          r = M1.getCompatibleVersions({
            widelyAvailableOnDate: t.date,
            includeDownstreamBrowsers: i,
            includeKaiOS: s
          });
        else if (t.availability === "newly") {
          var a = (/* @__PURE__ */ new Date()).setMonth((/* @__PURE__ */ new Date()).getMonth() + 30);
          r = M1.getCompatibleVersions({
            widelyAvailableOnDate: a,
            includeDownstreamBrowsers: i,
            includeKaiOS: s
          });
        } else
          r = M1.getCompatibleVersions({
            includeDownstreamBrowsers: i,
            includeKaiOS: s
          });
        return mu(NVe(r), e);
      }, "select")
    },
    popularity: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = parseFloat(t.popularity), i = De.usage.global;
        return Object.keys(i).reduce(function(s, a) {
          return t.sign === ">" ? i[a] > r && s.push(a) : t.sign === "<" ? i[a] < r && s.push(a) : t.sign === "<=" ? i[a] <= r && s.push(a) :
          i[a] >= r && s.push(a), s;
        }, []);
      }, "select")
    },
    popularity_in_my_stats: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = parseFloat(t.popularity);
        if (!e.customUsage)
          throw new li("Custom usage statistics was not provided");
        var i = e.customUsage;
        return Object.keys(i).reduce(function(s, a) {
          var o = i[a];
          return o == null || (t.sign === ">" ? o > r && s.push(a) : t.sign === "<" ? o < r && s.push(a) : t.sign === "<=" ? o <= r && s.push(
          a) : o >= r && s.push(a)), s;
        }, []);
      }, "select")
    },
    popularity_in_config_stats: {
      matches: ["sign", "popularity", "config"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = parseFloat(t.popularity), i = kH(e, t.config);
        return Object.keys(i).reduce(function(s, a) {
          var o = i[a];
          return o == null || (t.sign === ">" ? o > r && s.push(a) : t.sign === "<" ? o < r && s.push(a) : t.sign === "<=" ? o <= r && s.push(
          a) : o >= r && s.push(a)), s;
        }, []);
      }, "select")
    },
    popularity_in_place: {
      matches: ["sign", "popularity", "place"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = parseFloat(t.popularity), i = t.place;
        i.length === 2 ? i = i.toUpperCase() : i = i.toLowerCase(), Er.loadCountry(De.usage, i, De.data);
        var s = De.usage[i];
        return Object.keys(s).reduce(function(a, o) {
          var u = s[o];
          return u == null || (t.sign === ">" ? u > r && a.push(o) : t.sign === "<" ? u < r && a.push(o) : t.sign === "<=" ? u <= r && a.push(
          o) : u >= r && a.push(o)), a;
        }, []);
      }, "select")
    },
    cover: {
      matches: ["coverage"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
      select: GA
    },
    cover_in: {
      matches: ["coverage", "place"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
      select: GA
    },
    cover_config: {
      matches: ["coverage", "config"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/i,
      select: GA
    },
    supports: {
      matches: ["supportType", "feature"],
      regexp: /^(?:(fully|partially)\s+)?supports\s+([\w-]+)$/,
      select: /* @__PURE__ */ n(function(e, t) {
        Er.loadFeature(De.cache, t.feature);
        var r = t.supportType !== "fully", i = De.cache[t.feature], s = [];
        for (var a in i) {
          for (var o = Ya(a, e), u = o.released.length - 1; u >= 0 && !(o.released[u] in i[a]); )
            u--;
          var l = e.mobileToDesktop && a in De.desktopNames && CH(i[a][o.released[u]], r);
          o.versions.forEach(function(c) {
            var f = i[a][c];
            f === void 0 && l && (f = i[De.desktopNames[a]][c]), CH(f, r) && s.push(a + " " + c);
          });
        }
        return s;
      }, "select")
    },
    electron_range: {
      matches: ["from", "to"],
      regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = R1(t.from), i = R1(t.to), s = parseFloat(t.from), a = parseFloat(t.to);
        if (!ws[r])
          throw new li("Unknown version " + s + " of electron");
        if (!ws[i])
          throw new li("Unknown version " + a + " of electron");
        return Object.keys(ws).filter(function(o) {
          var u = parseFloat(o);
          return u >= s && u <= a;
        }).map(function(o) {
          return "chrome " + ws[o];
        });
      }, "select")
    },
    node_range: {
      matches: ["from", "to"],
      regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        return De.nodeVersions.filter(xH(">=", t.from)).filter(xH("<=", t.to)).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    browser_range: {
      matches: ["browser", "from", "to"],
      regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = hc(t.browser, e), i = parseFloat(j1(r, t.from) || t.from), s = parseFloat(j1(r, t.to) || t.to);
        function a(o) {
          var u = parseFloat(o);
          return u >= i && u <= s;
        }
        return n(a, "filter"), r.released.filter(a).map(Ja(r.name));
      }, "select")
    },
    electron_ray: {
      matches: ["sign", "version"],
      regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = R1(t.version);
        return Object.keys(ws).filter(vH(t.sign, r)).map(function(i) {
          return "chrome " + ws[i];
        });
      }, "select")
    },
    node_ray: {
      matches: ["sign", "version"],
      regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        return De.nodeVersions.filter(FVe(t.sign, t.version)).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    browser_ray: {
      matches: ["browser", "sign", "version"],
      regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = t.version, i = hc(t.browser, e), s = De.versionAliases[i.name][r];
        return s && (r = s), i.released.filter(vH(t.sign, r)).map(function(a) {
          return i.name + " " + a;
        });
      }, "select")
    },
    firefox_esr: {
      matches: [],
      regexp: /^(firefox|ff|fx)\s+esr$/i,
      select: /* @__PURE__ */ n(function() {
        return ["firefox 140"];
      }, "select")
    },
    opera_mini_all: {
      matches: [],
      regexp: /(operamini|op_mini)\s+all/i,
      select: /* @__PURE__ */ n(function() {
        return ["op_mini all"];
      }, "select")
    },
    electron_version: {
      matches: ["version"],
      regexp: /^electron\s+([\d.]+)$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = R1(t.version), i = ws[r];
        if (!i)
          throw new li(
            "Unknown version " + t.version + " of electron"
          );
        return ["chrome " + i];
      }, "select")
    },
    node_major_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+)$/i,
      select: XA
    },
    node_minor_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+)$/i,
      select: XA
    },
    node_patch_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
      select: XA
    },
    current_node: {
      matches: [],
      regexp: /^current\s+node$/i,
      select: /* @__PURE__ */ n(function(e) {
        return [Er.currentNode(mu, e)];
      }, "select")
    },
    maintained_node: {
      matches: [],
      regexp: /^maintained\s+node\s+versions$/i,
      select: /* @__PURE__ */ n(function(e) {
        var t = Date.now(), r = Object.keys(KA).filter(function(i) {
          return t < Date.parse(KA[i].end) && t > Date.parse(KA[i].start) && PVe(i);
        }).map(function(i) {
          return "node " + i.slice(1);
        });
        return mu(r, e);
      }, "select")
    },
    phantomjs_1_9: {
      matches: [],
      regexp: /^phantomjs\s+1.9$/i,
      select: /* @__PURE__ */ n(function() {
        return ["safari 5"];
      }, "select")
    },
    phantomjs_2_1: {
      matches: [],
      regexp: /^phantomjs\s+2.1$/i,
      select: /* @__PURE__ */ n(function() {
        return ["safari 6"];
      }, "select")
    },
    browser_version: {
      matches: ["browser", "version"],
      regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        var r = t.version;
        /^tp$/i.test(r) && (r = "TP");
        var i = hc(t.browser, e), s = j1(i, r);
        if (s)
          r = s;
        else if (r.indexOf(".") === -1 ? s = r + ".0" : s = r.replace(/\.0$/, ""), s = j1(i, s), s)
          r = s;
        else {
          if (e.ignoreUnknownVersions)
            return [];
          throw new li(
            "Unknown version " + r + " of " + t.browser
          );
        }
        return [i.name + " " + r];
      }, "select")
    },
    browserslist_config: {
      matches: [],
      regexp: /^browserslist config$/i,
      needsPath: !0,
      select: /* @__PURE__ */ n(function(e) {
        return De(void 0, e);
      }, "select")
    },
    extends: {
      matches: ["config"],
      regexp: /^extends (.+)$/i,
      needsPath: !0,
      select: /* @__PURE__ */ n(function(e, t) {
        return mu(Er.loadQueries(e, t.config), e);
      }, "select")
    },
    defaults: {
      matches: [],
      regexp: /^defaults$/i,
      select: /* @__PURE__ */ n(function(e) {
        return mu(De.defaults, e);
      }, "select")
    },
    dead: {
      matches: [],
      regexp: /^dead$/i,
      select: /* @__PURE__ */ n(function(e) {
        var t = [
          "Baidu >= 0",
          "ie <= 11",
          "ie_mob <= 11",
          "bb <= 10",
          "op_mob <= 12.1",
          "samsung 4"
        ];
        return mu(t, e);
      }, "select")
    },
    unknown: {
      matches: [],
      regexp: /^(\w+)$/i,
      select: /* @__PURE__ */ n(function(e, t) {
        throw Ya(t.query, e) ? new li(
          "Specify versions in Browserslist query for browser " + t.query
        ) : BVe(t.query);
      }, "select")
    }
  };
  (function() {
    for (var e in Gn) {
      var t = Gn[e];
      De.data[e] = {
        name: e,
        versions: DH(Gn[e].versions),
        released: DH(Gn[e].versions.slice(0, -3)),
        releaseDate: Gn[e].release_date
      }, V1(De.usage.global, e, t.usage_global), De.versionAliases[e] = {};
      for (var r = 0; r < t.versions.length; r++) {
        var i = t.versions[r];
        if (i && i.indexOf("-") !== -1)
          for (var s = i.split("-"), a = 0; a < s.length; a++)
            De.versionAliases[e][s[a]] = i;
      }
    }
    De.nodeVersions = CVe.map(function(o) {
      return o.version;
    });
  })();
  BH.exports = De;
});

// ../node_modules/@babel/helper-validator-option/lib/find-suggestion.js
var r_ = E((t_) => {
  "use strict";
  Object.defineProperty(t_, "__esModule", {
    value: !0
  });
  t_.findSuggestion = RVe;
  var {
    min: MH
  } = Math;
  function MVe(e, t) {
    let r = [], i = [], s, a, o = e.length, u = t.length;
    if (!o)
      return u;
    if (!u)
      return o;
    for (a = 0; a <= u; a++)
      r[a] = a;
    for (s = 1; s <= o; s++) {
      for (i = [s], a = 1; a <= u; a++)
        i[a] = e[s - 1] === t[a - 1] ? r[a - 1] : MH(r[a - 1], r[a], i[a - 1]) + 1;
      r = i;
    }
    return i[u];
  }
  n(MVe, "levenshtein");
  function RVe(e, t) {
    let r = t.map((i) => MVe(i, e));
    return t[r.indexOf(MH(...r))];
  }
  n(RVe, "findSuggestion");
});

// ../node_modules/@babel/helper-validator-option/lib/validator.js
var RH = E((W1) => {
  "use strict";
  Object.defineProperty(W1, "__esModule", {
    value: !0
  });
  W1.OptionValidator = void 0;
  var LVe = r_(), i_ = class {
    static {
      n(this, "OptionValidator");
    }
    constructor(t) {
      this.descriptor = t;
    }
    validateTopLevelOptions(t, r) {
      let i = Object.keys(r);
      for (let s of Object.keys(t))
        if (!i.includes(s))
          throw new Error(this.formatMessage(`'${s}' is not a valid top-level option.
- Did you mean '${(0, LVe.findSuggestion)(s, i)}'?`));
    }
    validateBooleanOption(t, r, i) {
      return r === void 0 ? i : (this.invariant(typeof r == "boolean", `'${t}' option must be a boolean.`), r);
    }
    validateStringOption(t, r, i) {
      return r === void 0 ? i : (this.invariant(typeof r == "string", `'${t}' option must be a string.`), r);
    }
    invariant(t, r) {
      if (!t)
        throw new Error(this.formatMessage(r));
    }
    formatMessage(t) {
      return `${this.descriptor}: ${t}`;
    }
  };
  W1.OptionValidator = i_;
});

// ../node_modules/@babel/helper-validator-option/lib/index.js
var K1 = E((H1) => {
  "use strict";
  Object.defineProperty(H1, "__esModule", {
    value: !0
  });
  Object.defineProperty(H1, "OptionValidator", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jVe.OptionValidator;
    }, "get")
  });
  Object.defineProperty(H1, "findSuggestion", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return qVe.findSuggestion;
    }, "get")
  });
  var jVe = RH(), qVe = r_();
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/iterator.js
var jH = E((yDt, LH) => {
  "use strict";
  LH.exports = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  };
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/yallist.js
var UH = E((gDt, qH) => {
  "use strict";
  qH.exports = ut;
  ut.Node = yu;
  ut.create = ut;
  function ut(e) {
    var t = this;
    if (t instanceof ut || (t = new ut()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
      e.forEach(function(s) {
        t.push(s);
      });
    else if (arguments.length > 0)
      for (var r = 0, i = arguments.length; r < i; r++)
        t.push(arguments[r]);
    return t;
  }
  n(ut, "Yallist");
  ut.prototype.removeNode = function(e) {
    if (e.list !== this)
      throw new Error("removing node which does not belong to this list");
    var t = e.next, r = e.prev;
    return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.
    next = null, e.prev = null, e.list = null, t;
  };
  ut.prototype.unshiftNode = function(e) {
    if (e !== this.head) {
      e.list && e.list.removeNode(e);
      var t = this.head;
      e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
    }
  };
  ut.prototype.pushNode = function(e) {
    if (e !== this.tail) {
      e.list && e.list.removeNode(e);
      var t = this.tail;
      e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
    }
  };
  ut.prototype.push = function() {
    for (var e = 0, t = arguments.length; e < t; e++)
      $Ve(this, arguments[e]);
    return this.length;
  };
  ut.prototype.unshift = function() {
    for (var e = 0, t = arguments.length; e < t; e++)
      VVe(this, arguments[e]);
    return this.length;
  };
  ut.prototype.pop = function() {
    if (this.tail) {
      var e = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
    }
  };
  ut.prototype.shift = function() {
    if (this.head) {
      var e = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
    }
  };
  ut.prototype.forEach = function(e, t) {
    t = t || this;
    for (var r = this.head, i = 0; r !== null; i++)
      e.call(t, r.value, i, this), r = r.next;
  };
  ut.prototype.forEachReverse = function(e, t) {
    t = t || this;
    for (var r = this.tail, i = this.length - 1; r !== null; i--)
      e.call(t, r.value, i, this), r = r.prev;
  };
  ut.prototype.get = function(e) {
    for (var t = 0, r = this.head; r !== null && t < e; t++)
      r = r.next;
    if (t === e && r !== null)
      return r.value;
  };
  ut.prototype.getReverse = function(e) {
    for (var t = 0, r = this.tail; r !== null && t < e; t++)
      r = r.prev;
    if (t === e && r !== null)
      return r.value;
  };
  ut.prototype.map = function(e, t) {
    t = t || this;
    for (var r = new ut(), i = this.head; i !== null; )
      r.push(e.call(t, i.value, this)), i = i.next;
    return r;
  };
  ut.prototype.mapReverse = function(e, t) {
    t = t || this;
    for (var r = new ut(), i = this.tail; i !== null; )
      r.push(e.call(t, i.value, this)), i = i.prev;
    return r;
  };
  ut.prototype.reduce = function(e, t) {
    var r, i = this.head;
    if (arguments.length > 1)
      r = t;
    else if (this.head)
      i = this.head.next, r = this.head.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var s = 0; i !== null; s++)
      r = e(r, i.value, s), i = i.next;
    return r;
  };
  ut.prototype.reduceReverse = function(e, t) {
    var r, i = this.tail;
    if (arguments.length > 1)
      r = t;
    else if (this.tail)
      i = this.tail.prev, r = this.tail.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var s = this.length - 1; i !== null; s--)
      r = e(r, i.value, s), i = i.prev;
    return r;
  };
  ut.prototype.toArray = function() {
    for (var e = new Array(this.length), t = 0, r = this.head; r !== null; t++)
      e[t] = r.value, r = r.next;
    return e;
  };
  ut.prototype.toArrayReverse = function() {
    for (var e = new Array(this.length), t = 0, r = this.tail; r !== null; t++)
      e[t] = r.value, r = r.prev;
    return e;
  };
  ut.prototype.slice = function(e, t) {
    t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
    var r = new ut();
    if (t < e || t < 0)
      return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var i = 0, s = this.head; s !== null && i < e; i++)
      s = s.next;
    for (; s !== null && i < t; i++, s = s.next)
      r.push(s.value);
    return r;
  };
  ut.prototype.sliceReverse = function(e, t) {
    t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
    var r = new ut();
    if (t < e || t < 0)
      return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var i = this.length, s = this.tail; s !== null && i > t; i--)
      s = s.prev;
    for (; s !== null && i > e; i--, s = s.prev)
      r.push(s.value);
    return r;
  };
  ut.prototype.splice = function(e, t) {
    e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
    for (var r = 0, i = this.head; i !== null && r < e; r++)
      i = i.next;
    for (var s = [], r = 0; i && r < t; r++)
      s.push(i.value), i = this.removeNode(i);
    i === null && (i = this.tail), i !== this.head && i !== this.tail && (i = i.prev);
    for (var r = 2; r < arguments.length; r++)
      i = UVe(this, i, arguments[r]);
    return s;
  };
  ut.prototype.reverse = function() {
    for (var e = this.head, t = this.tail, r = e; r !== null; r = r.prev) {
      var i = r.prev;
      r.prev = r.next, r.next = i;
    }
    return this.head = t, this.tail = e, this;
  };
  function UVe(e, t, r) {
    var i = t === e.head ? new yu(r, null, t, e) : new yu(r, t, t.next, e);
    return i.next === null && (e.tail = i), i.prev === null && (e.head = i), e.length++, i;
  }
  n(UVe, "insert");
  function $Ve(e, t) {
    e.tail = new yu(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
  }
  n($Ve, "push");
  function VVe(e, t) {
    e.head = new yu(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
  }
  n(VVe, "unshift");
  function yu(e, t, r, i) {
    if (!(this instanceof yu))
      return new yu(e, t, r, i);
    this.list = i, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
  }
  n(yu, "Node");
  try {
    jH()(ut);
  } catch {
  }
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/lru-cache/index.js
var KH = E((DDt, HH) => {
  "use strict";
  var WVe = UH(), gu = Symbol("max"), Qn = Symbol("length"), mc = Symbol("lengthCalculator"), _p = Symbol("allowStale"), bu = Symbol("maxAge"),
  Zn = Symbol("dispose"), $H = Symbol("noDisposeOnSet"), Sr = Symbol("lruList"), As = Symbol("cache"), WH = Symbol("updateAgeOnGet"), s_ = /* @__PURE__ */ n(
  () => 1, "naiveLength"), a_ = class {
    static {
      n(this, "LRUCache");
    }
    constructor(t) {
      if (typeof t == "number" && (t = { max: t }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
        throw new TypeError("max must be a non-negative number");
      let r = this[gu] = t.max || 1 / 0, i = t.length || s_;
      if (this[mc] = typeof i != "function" ? s_ : i, this[_p] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
        throw new TypeError("maxAge must be a number");
      this[bu] = t.maxAge || 0, this[Zn] = t.dispose, this[$H] = t.noDisposeOnSet || !1, this[WH] = t.updateAgeOnGet || !1, this.reset();
    }
    // resize the cache when the max changes.
    set max(t) {
      if (typeof t != "number" || t < 0)
        throw new TypeError("max must be a non-negative number");
      this[gu] = t || 1 / 0, Ap(this);
    }
    get max() {
      return this[gu];
    }
    set allowStale(t) {
      this[_p] = !!t;
    }
    get allowStale() {
      return this[_p];
    }
    set maxAge(t) {
      if (typeof t != "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[bu] = t, Ap(this);
    }
    get maxAge() {
      return this[bu];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(t) {
      typeof t != "function" && (t = s_), t !== this[mc] && (this[mc] = t, this[Qn] = 0, this[Sr].forEach((r) => {
        r.length = this[mc](r.value, r.key), this[Qn] += r.length;
      })), Ap(this);
    }
    get lengthCalculator() {
      return this[mc];
    }
    get length() {
      return this[Qn];
    }
    get itemCount() {
      return this[Sr].length;
    }
    rforEach(t, r) {
      r = r || this;
      for (let i = this[Sr].tail; i !== null; ) {
        let s = i.prev;
        VH(this, t, i, r), i = s;
      }
    }
    forEach(t, r) {
      r = r || this;
      for (let i = this[Sr].head; i !== null; ) {
        let s = i.next;
        VH(this, t, i, r), i = s;
      }
    }
    keys() {
      return this[Sr].toArray().map((t) => t.key);
    }
    values() {
      return this[Sr].toArray().map((t) => t.value);
    }
    reset() {
      this[Zn] && this[Sr] && this[Sr].length && this[Sr].forEach((t) => this[Zn](t.key, t.value)), this[As] = /* @__PURE__ */ new Map(), this[Sr] =
      new WVe(), this[Qn] = 0;
    }
    dump() {
      return this[Sr].map((t) => z1(this, t) ? !1 : {
        k: t.key,
        v: t.value,
        e: t.now + (t.maxAge || 0)
      }).toArray().filter((t) => t);
    }
    dumpLru() {
      return this[Sr];
    }
    set(t, r, i) {
      if (i = i || this[bu], i && typeof i != "number")
        throw new TypeError("maxAge must be a number");
      let s = i ? Date.now() : 0, a = this[mc](r, t);
      if (this[As].has(t)) {
        if (a > this[gu])
          return yc(this, this[As].get(t)), !1;
        let l = this[As].get(t).value;
        return this[Zn] && (this[$H] || this[Zn](t, l.value)), l.now = s, l.maxAge = i, l.value = r, this[Qn] += a - l.length, l.length = a,
        this.get(t), Ap(this), !0;
      }
      let o = new o_(t, r, a, s, i);
      return o.length > this[gu] ? (this[Zn] && this[Zn](t, r), !1) : (this[Qn] += o.length, this[Sr].unshift(o), this[As].set(t, this[Sr].head),
      Ap(this), !0);
    }
    has(t) {
      if (!this[As].has(t)) return !1;
      let r = this[As].get(t).value;
      return !z1(this, r);
    }
    get(t) {
      return n_(this, t, !0);
    }
    peek(t) {
      return n_(this, t, !1);
    }
    pop() {
      let t = this[Sr].tail;
      return t ? (yc(this, t), t.value) : null;
    }
    del(t) {
      yc(this, this[As].get(t));
    }
    load(t) {
      this.reset();
      let r = Date.now();
      for (let i = t.length - 1; i >= 0; i--) {
        let s = t[i], a = s.e || 0;
        if (a === 0)
          this.set(s.k, s.v);
        else {
          let o = a - r;
          o > 0 && this.set(s.k, s.v, o);
        }
      }
    }
    prune() {
      this[As].forEach((t, r) => n_(this, r, !1));
    }
  }, n_ = /* @__PURE__ */ n((e, t, r) => {
    let i = e[As].get(t);
    if (i) {
      let s = i.value;
      if (z1(e, s)) {
        if (yc(e, i), !e[_p])
          return;
      } else
        r && (e[WH] && (i.value.now = Date.now()), e[Sr].unshiftNode(i));
      return s.value;
    }
  }, "get"), z1 = /* @__PURE__ */ n((e, t) => {
    if (!t || !t.maxAge && !e[bu])
      return !1;
    let r = Date.now() - t.now;
    return t.maxAge ? r > t.maxAge : e[bu] && r > e[bu];
  }, "isStale"), Ap = /* @__PURE__ */ n((e) => {
    if (e[Qn] > e[gu])
      for (let t = e[Sr].tail; e[Qn] > e[gu] && t !== null; ) {
        let r = t.prev;
        yc(e, t), t = r;
      }
  }, "trim"), yc = /* @__PURE__ */ n((e, t) => {
    if (t) {
      let r = t.value;
      e[Zn] && e[Zn](r.key, r.value), e[Qn] -= r.length, e[As].delete(r.key), e[Sr].removeNode(t);
    }
  }, "del"), o_ = class {
    static {
      n(this, "Entry");
    }
    constructor(t, r, i, s, a) {
      this.key = t, this.value = r, this.length = i, this.now = s, this.maxAge = a || 0;
    }
  }, VH = /* @__PURE__ */ n((e, t, r, i) => {
    let s = r.value;
    z1(e, s) && (yc(e, r), e[_p] || (s = void 0)), s && t.call(i, s.value, s.key, e);
  }, "forEachStep");
  HH.exports = a_;
});

// ../node_modules/@babel/helper-compilation-targets/lib/targets.js
var J1 = E((gc) => {
  "use strict";
  Object.defineProperty(gc, "__esModule", {
    value: !0
  });
  gc.unreleasedLabels = gc.browserNameMap = void 0;
  var xDt = gc.unreleasedLabels = {
    safari: "tp"
  }, EDt = gc.browserNameMap = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    deno: "deno",
    op_mob: "opera_mobile",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
  };
});

// ../node_modules/@babel/helper-compilation-targets/lib/utils.js
var X1 = E((Ga) => {
  "use strict";
  Object.defineProperty(Ga, "__esModule", {
    value: !0
  });
  Ga.getHighestUnreleased = YVe;
  Ga.getLowestImplementedVersion = GVe;
  Ga.getLowestUnreleased = YH;
  Ga.isUnreleasedVersion = XVe;
  Ga.semverMin = XH;
  Ga.semverify = JVe;
  var zH = require("semver"), HVe = K1(), JH = J1(), KVe = /^(?:\d+|\d(?:\d?[^\d\n\r\u2028\u2029]\d+|\d{2,}(?:[^\d\n\r\u2028\u2029]\d+)?))$/,
  zVe = new HVe.OptionValidator("@babel/helper-compilation-targets");
  function XH(e, t) {
    return e && zH.lt(e, t) ? e : t;
  }
  n(XH, "semverMin");
  function JVe(e) {
    if (typeof e == "string" && zH.valid(e))
      return e;
    zVe.invariant(typeof e == "number" || typeof e == "string" && KVe.test(e), `'${e}' is not a valid version`), e = e.toString();
    let t = 0, r = 0;
    for (; (t = e.indexOf(".", t + 1)) > 0; )
      r++;
    return e + ".0".repeat(2 - r);
  }
  n(JVe, "semverify");
  function XVe(e, t) {
    let r = JH.unreleasedLabels[t];
    return !!r && r === e.toString().toLowerCase();
  }
  n(XVe, "isUnreleasedVersion");
  function YH(e, t, r) {
    let i = JH.unreleasedLabels[r];
    return e === i ? t : t === i ? e : XH(e, t);
  }
  n(YH, "getLowestUnreleased");
  function YVe(e, t, r) {
    return YH(e, t, r) === e ? t : e;
  }
  n(YVe, "getHighestUnreleased");
  function GVe(e, t) {
    let r = e[t];
    return !r && t === "android" ? e.chrome : r;
  }
  n(GVe, "getLowestImplementedVersion");
});

// ../node_modules/@babel/helper-compilation-targets/lib/options.js
var GH = E((Y1) => {
  "use strict";
  Object.defineProperty(Y1, "__esModule", {
    value: !0
  });
  Y1.TargetNames = void 0;
  var wDt = Y1.TargetNames = {
    node: "node",
    deno: "deno",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung",
    rhino: "rhino",
    opera_mobile: "opera_mobile"
  };
});

// ../node_modules/@babel/helper-compilation-targets/lib/pretty.js
var u_ = E((G1) => {
  "use strict";
  Object.defineProperty(G1, "__esModule", {
    value: !0
  });
  G1.prettifyTargets = eWe;
  G1.prettifyVersion = ZH;
  var ZVe = require("semver"), QVe = J1();
  function ZH(e) {
    if (typeof e != "string")
      return e;
    let {
      major: t,
      minor: r,
      patch: i
    } = ZVe.parse(e), s = [t];
    return (r || i) && s.push(r), i && s.push(i), s.join(".");
  }
  n(ZH, "prettifyVersion");
  function eWe(e) {
    return Object.keys(e).reduce((t, r) => {
      let i = e[r], s = QVe.unreleasedLabels[r];
      return typeof i == "string" && s !== i && (i = ZH(i)), t[r] = i, t;
    }, {});
  }
  n(eWe, "prettifyTargets");
});

// ../node_modules/@babel/helper-compilation-targets/lib/debug.js
var eK = E((l_) => {
  "use strict";
  Object.defineProperty(l_, "__esModule", {
    value: !0
  });
  l_.getInclusionReasons = rWe;
  var tWe = require("semver"), QH = u_(), Z1 = X1();
  function rWe(e, t, r) {
    let i = r[e] || {};
    return Object.keys(t).reduce((s, a) => {
      let o = (0, Z1.getLowestImplementedVersion)(i, a), u = t[a];
      if (!o)
        s[a] = (0, QH.prettifyVersion)(u);
      else {
        let l = (0, Z1.isUnreleasedVersion)(o, a);
        !(0, Z1.isUnreleasedVersion)(u, a) && (l || tWe.lt(u.toString(), (0, Z1.semverify)(o))) && (s[a] = (0, QH.prettifyVersion)(u));
      }
      return s;
    }, {});
  }
  n(rWe, "getInclusionReasons");
});

// ../node_modules/@babel/compat-data/data/plugins.json
var tK = E((ODt, iWe) => {
  iWe.exports = {
    "transform-explicit-resource-management": {
      chrome: "134",
      edge: "134",
      firefox: "141",
      node: "24",
      electron: "35.0"
    },
    "transform-duplicate-named-capturing-groups-regex": {
      chrome: "126",
      opera: "112",
      edge: "126",
      firefox: "129",
      safari: "17.4",
      node: "23",
      ios: "17.4",
      electron: "31.0"
    },
    "transform-regexp-modifiers": {
      chrome: "125",
      opera: "111",
      edge: "125",
      firefox: "132",
      node: "23",
      samsung: "27",
      electron: "31.0"
    },
    "transform-unicode-sets-regex": {
      chrome: "112",
      opera: "98",
      edge: "112",
      firefox: "116",
      safari: "17",
      node: "20",
      deno: "1.32",
      ios: "17",
      samsung: "23",
      opera_mobile: "75",
      electron: "24.0"
    },
    "bugfix/transform-v8-static-class-fields-redefine-readonly": {
      chrome: "98",
      opera: "84",
      edge: "98",
      firefox: "75",
      safari: "15",
      node: "12",
      deno: "1.18",
      ios: "15",
      samsung: "11",
      opera_mobile: "52",
      electron: "17.0"
    },
    "bugfix/transform-firefox-class-in-computed-class-key": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "126",
      safari: "16",
      node: "12",
      deno: "1",
      ios: "16",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "bugfix/transform-safari-class-field-initializer-scope": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "69",
      safari: "16",
      node: "12",
      deno: "1",
      ios: "16",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "transform-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "proposal-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "transform-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "proposal-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "transform-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "proposal-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "transform-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      rhino: "1.8",
      opera_mobile: "57",
      electron: "8.0"
    },
    "proposal-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      rhino: "1.8",
      opera_mobile: "57",
      electron: "8.0"
    },
    "transform-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-parameters": {
      chrome: "49",
      opera: "36",
      edge: "18",
      firefox: "52",
      safari: "16.3",
      node: "6",
      deno: "1",
      ios: "16.3",
      samsung: "5",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "proposal-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "proposal-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "transform-dotall-regex": {
      chrome: "62",
      opera: "49",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "8.10",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      rhino: "1.7.15",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-named-capturing-groups-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-async-to-generator": {
      chrome: "55",
      opera: "42",
      edge: "15",
      firefox: "52",
      safari: "11",
      node: "7.6",
      deno: "1",
      ios: "11",
      samsung: "6",
      opera_mobile: "42",
      electron: "1.6"
    },
    "transform-exponentiation-operator": {
      chrome: "52",
      opera: "39",
      edge: "14",
      firefox: "52",
      safari: "10.1",
      node: "7",
      deno: "1",
      ios: "10.3",
      samsung: "6",
      rhino: "1.7.14",
      opera_mobile: "41",
      electron: "1.3"
    },
    "transform-template-literals": {
      chrome: "41",
      opera: "28",
      edge: "13",
      firefox: "34",
      safari: "13",
      node: "4",
      deno: "1",
      ios: "13",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-literals": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.15",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-function-name": {
      chrome: "51",
      opera: "38",
      edge: "79",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-arrow-functions": {
      chrome: "47",
      opera: "34",
      edge: "13",
      firefox: "43",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      rhino: "1.7.13",
      opera_mobile: "34",
      electron: "0.36"
    },
    "transform-block-scoped-functions": {
      chrome: "41",
      opera: "28",
      edge: "12",
      firefox: "46",
      safari: "10",
      node: "4",
      deno: "1",
      ie: "11",
      ios: "10",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-classes": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-object-super": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-shorthand-properties": {
      chrome: "43",
      opera: "30",
      edge: "12",
      firefox: "33",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.14",
      opera_mobile: "30",
      electron: "0.27"
    },
    "transform-duplicate-keys": {
      chrome: "42",
      opera: "29",
      edge: "12",
      firefox: "34",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "3.4",
      opera_mobile: "29",
      electron: "0.25"
    },
    "transform-computed-properties": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "34",
      safari: "7.1",
      node: "4",
      deno: "1",
      ios: "8",
      samsung: "4",
      rhino: "1.8",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-for-of": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-sticky-regex": {
      chrome: "49",
      opera: "36",
      edge: "13",
      firefox: "3",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      rhino: "1.7.15",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-unicode-escapes": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.15",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-unicode-regex": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "46",
      safari: "12",
      node: "6",
      deno: "1",
      ios: "12",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-spread": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-destructuring": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-block-scoping": {
      chrome: "50",
      opera: "37",
      edge: "14",
      firefox: "53",
      safari: "11",
      node: "6",
      deno: "1",
      ios: "11",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-typeof-symbol": {
      chrome: "48",
      opera: "35",
      edge: "12",
      firefox: "36",
      safari: "9",
      node: "6",
      deno: "1",
      ios: "9",
      samsung: "5",
      rhino: "1.8",
      opera_mobile: "35",
      electron: "0.37"
    },
    "transform-new-target": {
      chrome: "46",
      opera: "33",
      edge: "14",
      firefox: "41",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-regenerator": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "53",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-member-expression-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-property-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-reserved-words": {
      chrome: "13",
      opera: "10.50",
      edge: "12",
      firefox: "2",
      safari: "3.1",
      node: "0.6",
      deno: "1",
      ie: "9",
      android: "4.4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "10.1",
      electron: "0.20"
    },
    "transform-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2.0",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    },
    "proposal-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2.0",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    }
  };
});

// ../node_modules/@babel/compat-data/plugins.js
var iK = E((kDt, rK) => {
  rK.exports = tK();
});

// ../node_modules/@babel/helper-compilation-targets/lib/filter-items.js
var oK = E((Pp) => {
  "use strict";
  Object.defineProperty(Pp, "__esModule", {
    value: !0
  });
  Pp.default = nWe;
  Pp.isRequired = aK;
  Pp.targetsSupported = nK;
  var sK = require("semver"), Q1 = X1(), sWe = iK();
  function nK(e, t) {
    let r = Object.keys(e);
    return r.length === 0 ? !1 : r.filter((s) => {
      let a = (0, Q1.getLowestImplementedVersion)(t, s);
      if (!a)
        return !0;
      let o = e[s];
      if ((0, Q1.isUnreleasedVersion)(o, s))
        return !1;
      if ((0, Q1.isUnreleasedVersion)(a, s))
        return !0;
      if (!sK.valid(o.toString()))
        throw new Error(`Invalid version passed for target "${s}": "${o}". Versions must be in semver format (major.minor.patch)`);
      return sK.gt((0, Q1.semverify)(a), o.toString());
    }).length === 0;
  }
  n(nK, "targetsSupported");
  function aK(e, t, {
    compatData: r = sWe,
    includes: i,
    excludes: s
  } = {}) {
    return s != null && s.has(e) ? !1 : i != null && i.has(e) ? !0 : !nK(t, r[e]);
  }
  n(aK, "isRequired");
  function nWe(e, t, r, i, s, a, o) {
    let u = /* @__PURE__ */ new Set(), l = {
      compatData: e,
      includes: t,
      excludes: r
    };
    for (let c in e)
      if (aK(c, i, l))
        u.add(c);
      else if (o) {
        let f = o.get(c);
        f && u.add(f);
      }
    return s?.forEach((c) => !r.has(c) && u.add(c)), a?.forEach((c) => !t.has(c) && u.delete(c)), u;
  }
  n(nWe, "filterItems");
});

// ../node_modules/@babel/compat-data/data/native-modules.json
var uK = E((MDt, aWe) => {
  aWe.exports = {
    "es6.module": {
      chrome: "61",
      and_chr: "61",
      edge: "16",
      firefox: "60",
      and_ff: "60",
      node: "13.2.0",
      opera: "48",
      op_mob: "45",
      safari: "10.1",
      ios: "10.3",
      samsung: "8.2",
      android: "61",
      electron: "2.0",
      ios_saf: "10.3"
    }
  };
});

// ../node_modules/@babel/compat-data/native-modules.js
var cK = E((RDt, lK) => {
  lK.exports = uK();
});

// ../node_modules/@babel/helper-compilation-targets/lib/index.js
var h_ = E((on) => {
  "use strict";
  Object.defineProperty(on, "__esModule", {
    value: !0
  });
  Object.defineProperty(on, "TargetNames", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return d_.TargetNames;
    }, "get")
  });
  on.default = vWe;
  Object.defineProperty(on, "filterItems", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hK.default;
    }, "get")
  });
  Object.defineProperty(on, "getInclusionReasons", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return lWe.getInclusionReasons;
    }, "get")
  });
  on.isBrowsersQueryValid = mK;
  Object.defineProperty(on, "isRequired", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return hK.isRequired;
    }, "get")
  });
  Object.defineProperty(on, "prettifyTargets", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return uWe.prettifyTargets;
    }, "get")
  });
  Object.defineProperty(on, "unreleasedLabels", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return pK.unreleasedLabels;
    }, "get")
  });
  var f_ = NH(), dK = K1(), oWe = KH(), _s = X1(), pK = J1(), d_ = GH(), uWe = u_(), lWe = eK(), hK = oK(), cWe = cK(), c_ = cWe["es6.module"],
  p_ = new dK.OptionValidator("@babel/helper-compilation-targets");
  function fWe(e) {
    let t = Object.keys(d_.TargetNames);
    for (let r of Object.keys(e))
      if (!(r in d_.TargetNames))
        throw new Error(p_.formatMessage(`'${r}' is not a valid target
- Did you mean '${(0, dK.findSuggestion)(r, t)}'?`));
    return e;
  }
  n(fWe, "validateTargetNames");
  function mK(e) {
    return typeof e == "string" || Array.isArray(e) && e.every((t) => typeof t == "string");
  }
  n(mK, "isBrowsersQueryValid");
  function dWe(e) {
    return p_.invariant(e === void 0 || mK(e), `'${String(e)}' is not a valid browserslist query`), e;
  }
  n(dWe, "validateBrowsers");
  function pWe(e) {
    return e.reduce((t, r) => {
      let [i, s] = r.split(" "), a = pK.browserNameMap[i];
      if (!a)
        return t;
      try {
        let o = s.split("-")[0].toLowerCase(), u = (0, _s.isUnreleasedVersion)(o, a);
        if (!t[a])
          return t[a] = u ? o : (0, _s.semverify)(o), t;
        let l = t[a], c = (0, _s.isUnreleasedVersion)(l, a);
        if (c && u)
          t[a] = (0, _s.getLowestUnreleased)(l, o, a);
        else if (c)
          t[a] = (0, _s.semverify)(o);
        else if (!c && !u) {
          let f = (0, _s.semverify)(o);
          t[a] = (0, _s.semverMin)(l, f);
        }
      } catch {
      }
      return t;
    }, {});
  }
  n(pWe, "getLowestVersions");
  function hWe(e) {
    e.length && (console.warn(`Warning, the following targets are using a decimal version:
`), e.forEach(({
      target: t,
      value: r
    }) => console.warn(`  ${t}: ${r}`)), console.warn(`
We recommend using a string for minor/patch versions to avoid numbers like 6.10
getting parsed as 6.1, which can lead to unexpected behavior.
`));
  }
  n(hWe, "outputDecimalWarning");
  function yK(e, t) {
    try {
      return (0, _s.semverify)(t);
    } catch {
      throw new Error(p_.formatMessage(`'${t}' is not a valid value for 'targets.${e}'.`));
    }
  }
  n(yK, "semverifyTarget");
  function mWe(e) {
    return ["node", e === !0 || e === "current" ? process.versions.node.split("-")[0] : yK("node", e)];
  }
  n(mWe, "nodeTargetParser");
  function yWe(e, t) {
    let r = (0, _s.isUnreleasedVersion)(t, e) ? t.toLowerCase() : yK(e, t);
    return [e, r];
  }
  n(yWe, "defaultTargetParser");
  function gWe(e) {
    let t = Object.assign({}, e);
    return delete t.esmodules, delete t.browsers, t;
  }
  n(gWe, "generateTargets");
  function bWe(e, t) {
    let r = f_(e, {
      mobileToDesktop: !0,
      env: t
    });
    return pWe(r);
  }
  n(bWe, "resolveTargets");
  var fK = new oWe({
    max: 64
  });
  function DWe(e, t) {
    let r = typeof e == "string" ? e : e.join() + t, i = fK.get(r);
    return i || (i = bWe(e, t), fK.set(r, i)), Object.assign({}, i);
  }
  n(DWe, "resolveTargetsCached");
  function vWe(e = {}, t = {}) {
    var r, i;
    let {
      browsers: s,
      esmodules: a
    } = e, {
      configPath: o = ".",
      onBrowserslistConfigFound: u
    } = t;
    dWe(s);
    let l = gWe(e), c = fWe(l), m = !!s || Object.keys(c).length > 0, h = !t.ignoreBrowserslistConfig && !m;
    if (!s && h) {
      if (s = process.env.BROWSERSLIST, !s) {
        let p = t.configFile || process.env.BROWSERSLIST_CONFIG || f_.findConfigFile(o);
        p != null && (u?.(p), s = f_.loadConfig({
          config: p,
          env: t.browserslistEnv
        }));
      }
      s == null && (s = []);
    }
    if (a && (a !== "intersect" || !((r = s) != null && r.length)) && (s = Object.keys(c_).map((p) => `${p} >= ${c_[p]}`).join(", "), a = !1),
    (i = s) != null && i.length) {
      let p = DWe(s, t.browserslistEnv);
      if (a === "intersect")
        for (let g of Object.keys(p))
          if (g !== "deno" && g !== "ie") {
            let b = c_[g === "opera_mobile" ? "op_mob" : g];
            if (b) {
              let D = p[g];
              p[g] = (0, _s.getHighestUnreleased)(D, (0, _s.semverify)(b), g);
            } else
              delete p[g];
          } else
            delete p[g];
      c = Object.assign(p, c);
    }
    let d = {}, y = [];
    for (let p of Object.keys(c).sort()) {
      let g = c[p];
      typeof g == "number" && g % 1 !== 0 && y.push({
        target: p,
        value: g
      });
      let [b, D] = p === "node" ? mWe(g) : yWe(p, g);
      D && (d[b] = D);
    }
    return hWe(y), d;
  }
  n(vWe, "getTargets");
});

// ../node_modules/@babel/core/lib/config/resolve-targets.js
var m_ = E((eg) => {
  "use strict";
  Object.defineProperty(eg, "__esModule", {
    value: !0
  });
  eg.resolveBrowserslistConfigFile = xWe;
  eg.resolveTargets = EWe;
  function gK() {
    let e = require("path");
    return gK = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(gK, "_path");
  function bK() {
    let e = h_();
    return bK = /* @__PURE__ */ n(function() {
      return e;
    }, "_helperCompilationTargets"), e;
  }
  n(bK, "_helperCompilationTargets");
  function xWe(e, t) {
    return gK().resolve(t, e);
  }
  n(xWe, "resolveBrowserslistConfigFile");
  function EWe(e, t) {
    let r = e.targets, i;
    typeof r == "string" || Array.isArray(r) ? i = {
      browsers: r
    } : r && ("esmodules" in r ? i = Object.assign({}, r, {
      esmodules: "intersect"
    }) : i = r);
    let {
      browserslistConfigFile: s
    } = e, a, o = !1;
    return typeof s == "string" ? a = s : o = s === !1, (0, bK().default)(i, {
      ignoreBrowserslistConfig: o,
      configFile: a,
      configPath: t,
      browserslistEnv: e.browserslistEnv
    });
  }
  n(EWe, "resolveTargets");
});

// ../node_modules/@babel/core/lib/config/config-descriptors.js
var y_ = E((Ip) => {
  "use strict";
  Object.defineProperty(Ip, "__esModule", {
    value: !0
  });
  Ip.createCachedDescriptors = wWe;
  Ip.createDescriptor = _K;
  Ip.createUncachedDescriptors = AWe;
  function EK() {
    let e = _i();
    return EK = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n(EK, "_gensync");
  var DK = bW(), vK = kp(), SWe = Op(), Fp = fu(), TWe = m_();
  function CWe(e, t) {
    var r, i, s, a;
    return e.name === t.name && e.value === t.value && e.options === t.options && e.dirname === t.dirname && e.alias === t.alias && e.ownPass ===
    t.ownPass && ((r = e.file) == null ? void 0 : r.request) === ((i = t.file) == null ? void 0 : i.request) && ((s = e.file) == null ? void 0 :
    s.resolved) === ((a = t.file) == null ? void 0 : a.resolved);
  }
  n(CWe, "isEqualDescriptor");
  function* xK(e) {
    return e;
  }
  n(xK, "handlerOf");
  function SK(e, t) {
    return typeof e.browserslistConfigFile == "string" && (e.browserslistConfigFile = (0, TWe.resolveBrowserslistConfigFile)(e.browserslistConfigFile,
    t)), e;
  }
  n(SK, "optionsWithResolvedBrowserslistConfigFile");
  function wWe(e, t, r) {
    let {
      plugins: i,
      presets: s,
      passPerPreset: a
    } = t;
    return {
      options: SK(t, e),
      plugins: i ? () => IWe(i, e)(r) : () => xK([]),
      presets: s ? () => PWe(s, e)(r)(!!a) : () => xK([])
    };
  }
  n(wWe, "createCachedDescriptors");
  function AWe(e, t, r) {
    return {
      options: SK(t, e),
      plugins: (0, DK.once)(() => wK(t.plugins || [], e, r)),
      presets: (0, DK.once)(() => CK(t.presets || [], e, r, !!t.passPerPreset))
    };
  }
  n(AWe, "createUncachedDescriptors");
  var _We = /* @__PURE__ */ new WeakMap(), PWe = (0, Fp.makeWeakCacheSync)((e, t) => {
    let r = t.using((i) => i);
    return (0, Fp.makeStrongCacheSync)((i) => (0, Fp.makeStrongCache)(function* (s) {
      return (yield* CK(e, r, i, s)).map((o) => TK(_We, o));
    }));
  }), FWe = /* @__PURE__ */ new WeakMap(), IWe = (0, Fp.makeWeakCacheSync)((e, t) => {
    let r = t.using((i) => i);
    return (0, Fp.makeStrongCache)(function* (i) {
      return (yield* wK(e, r, i)).map((a) => TK(FWe, a));
    });
  }), OWe = {};
  function TK(e, t) {
    let {
      value: r,
      options: i = OWe
    } = t;
    if (i === !1) return t;
    let s = e.get(r);
    s || (s = /* @__PURE__ */ new WeakMap(), e.set(r, s));
    let a = s.get(i);
    if (a || (a = [], s.set(i, a)), !a.includes(t)) {
      let o = a.filter((u) => CWe(u, t));
      if (o.length > 0)
        return o[0];
      a.push(t);
    }
    return t;
  }
  n(TK, "loadCachedDescriptor");
  function* CK(e, t, r, i) {
    return yield* AK("preset", e, t, r, i);
  }
  n(CK, "createPresetDescriptors");
  function* wK(e, t, r) {
    return yield* AK("plugin", e, t, r);
  }
  n(wK, "createPluginDescriptors");
  function* AK(e, t, r, i, s) {
    let a = yield* EK().all(t.map((o, u) => _K(o, r, {
      type: e,
      alias: `${i}$${u}`,
      ownPass: !!s
    })));
    return kWe(a), a;
  }
  n(AK, "createDescriptors");
  function* _K(e, t, {
    type: r,
    alias: i,
    ownPass: s
  }) {
    let a = (0, SWe.getItemDescriptor)(e);
    if (a)
      return a;
    let o, u, l = e;
    Array.isArray(l) && (l.length === 3 ? [l, u, o] = l : [l, u] = l);
    let c, f = null;
    if (typeof l == "string") {
      if (typeof r != "string")
        throw new Error("To resolve a string-based item, the type of item must be given");
      let m = r === "plugin" ? vK.loadPlugin : vK.loadPreset, h = l;
      ({
        filepath: f,
        value: l
      } = yield* m(l, t)), c = {
        request: h,
        resolved: f
      };
    }
    if (!l)
      throw new Error(`Unexpected falsy value: ${String(l)}`);
    if (typeof l == "object" && l.__esModule)
      if (l.default)
        l = l.default;
      else
        throw new Error("Must export a default export when using ES6 modules.");
    if (typeof l != "object" && typeof l != "function")
      throw new Error(`Unsupported format: ${typeof l}. Expected an object or a function.`);
    if (f !== null && typeof l == "object" && l)
      throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${f}`);
    return {
      name: o,
      alias: f || i,
      value: l,
      options: u,
      dirname: t,
      ownPass: s,
      file: c
    };
  }
  n(_K, "createDescriptor");
  function kWe(e) {
    let t = /* @__PURE__ */ new Map();
    for (let r of e) {
      if (typeof r.value != "function") continue;
      let i = t.get(r.value);
      if (i || (i = /* @__PURE__ */ new Set(), t.set(r.value, i)), i.has(r.name)) {
        let s = e.filter((a) => a.value === r.value);
        throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separat\
e names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detec\
ted are:", `${JSON.stringify(s, null, 2)}`].join(`
`));
      }
      i.add(r.name);
    }
  }
  n(kWe, "assertNoDuplicates");
});

// ../node_modules/@babel/core/lib/config/item.js
var Op = E((Bp) => {
  "use strict";
  Object.defineProperty(Bp, "__esModule", {
    value: !0
  });
  Bp.createConfigItem = NWe;
  Bp.createItemFromDescriptor = FK;
  Bp.getItemDescriptor = MWe;
  function PK() {
    let e = require("path");
    return PK = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(PK, "_path");
  var BWe = y_();
  function FK(e) {
    return new tg(e);
  }
  n(FK, "createItemFromDescriptor");
  function* NWe(e, {
    dirname: t = ".",
    type: r
  } = {}) {
    let i = yield* (0, BWe.createDescriptor)(e, PK().resolve(t), {
      type: r,
      alias: "programmatic item"
    });
    return FK(i);
  }
  n(NWe, "createConfigItem");
  var g_ = Symbol.for("@babel/core@7 - ConfigItem");
  function MWe(e) {
    if (e != null && e[g_])
      return e._descriptor;
  }
  n(MWe, "getItemDescriptor");
  var tg = class {
    static {
      n(this, "ConfigItem");
    }
    constructor(t) {
      this._descriptor = void 0, this[g_] = !0, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.
      file = void 0, this._descriptor = t, Object.defineProperty(this, "_descriptor", {
        enumerable: !1
      }), Object.defineProperty(this, g_, {
        enumerable: !1
      }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name =
      this._descriptor.name, this.file = this._descriptor.file ? {
        request: this._descriptor.file.request,
        resolved: this._descriptor.file.resolved
      } : void 0, Object.freeze(this);
    }
  };
  Object.freeze(tg.prototype);
});

// ../node_modules/@babel/core/lib/config/validation/removed.js
var IK = E((rg) => {
  "use strict";
  Object.defineProperty(rg, "__esModule", {
    value: !0
  });
  rg.default = void 0;
  var KDt = rg.default = {
    auxiliaryComment: {
      message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
    },
    blacklist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    breakConfig: {
      message: "This is not a necessary option in Babel 6"
    },
    experimental: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    externalHelpers: {
      message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
    },
    extra: {
      message: ""
    },
    jsxPragma: {
      message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
    },
    loose: {
      message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
    },
    metadataUsedHelpers: {
      message: "Not required anymore as this is enabled by default"
    },
    modules: {
      message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
    },
    nonStandard: {
      message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.i\
o/docs/plugins/preset-react/"
    },
    optional: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    sourceMapName: {
      message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file\
` themselves."
    },
    stage: {
      message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
    },
    whitelist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    resolveModuleSource: {
      version: 6,
      message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
    },
    metadata: {
      version: 6,
      message: "Generated plugin metadata is always included in the output result"
    },
    sourceMapTarget: {
      version: 6,
      message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.fi\
le` themselves."
    }
  };
});

// ../node_modules/@babel/core/lib/config/validation/option-assertions.js
var v_ = E((Zt) => {
  "use strict";
  Object.defineProperty(Zt, "__esModule", {
    value: !0
  });
  Zt.access = Fi;
  Zt.assertArray = D_;
  Zt.assertAssumptions = tHe;
  Zt.assertBabelrcSearch = YWe;
  Zt.assertBoolean = b_;
  Zt.assertCallerMetadata = $We;
  Zt.assertCompact = qWe;
  Zt.assertConfigApplicableTest = JWe;
  Zt.assertConfigFileSearch = XWe;
  Zt.assertFunction = HWe;
  Zt.assertIgnoreList = KWe;
  Zt.assertInputSourceMap = VWe;
  Zt.assertObject = BK;
  Zt.assertPluginList = GWe;
  Zt.assertRootMode = LWe;
  Zt.assertSourceMaps = jWe;
  Zt.assertSourceType = UWe;
  Zt.assertString = WWe;
  Zt.assertTargets = QWe;
  Zt.msg = tt;
  function Np() {
    let e = h_();
    return Np = /* @__PURE__ */ n(function() {
      return e;
    }, "_helperCompilationTargets"), e;
  }
  n(Np, "_helperCompilationTargets");
  var RWe = Mp();
  function tt(e) {
    switch (e.type) {
      case "root":
        return "";
      case "env":
        return `${tt(e.parent)}.env["${e.name}"]`;
      case "overrides":
        return `${tt(e.parent)}.overrides[${e.index}]`;
      case "option":
        return `${tt(e.parent)}.${e.name}`;
      case "access":
        return `${tt(e.parent)}[${JSON.stringify(e.name)}]`;
      default:
        throw new Error(`Assertion failure: Unknown type ${e.type}`);
    }
  }
  n(tt, "msg");
  function Fi(e, t) {
    return {
      type: "access",
      name: t,
      parent: e
    };
  }
  n(Fi, "access");
  function LWe(e, t) {
    if (t !== void 0 && t !== "root" && t !== "upward" && t !== "upward-optional")
      throw new Error(`${tt(e)} must be a "root", "upward", "upward-optional" or undefined`);
    return t;
  }
  n(LWe, "assertRootMode");
  function jWe(e, t) {
    if (t !== void 0 && typeof t != "boolean" && t !== "inline" && t !== "both")
      throw new Error(`${tt(e)} must be a boolean, "inline", "both", or undefined`);
    return t;
  }
  n(jWe, "assertSourceMaps");
  function qWe(e, t) {
    if (t !== void 0 && typeof t != "boolean" && t !== "auto")
      throw new Error(`${tt(e)} must be a boolean, "auto", or undefined`);
    return t;
  }
  n(qWe, "assertCompact");
  function UWe(e, t) {
    if (t !== void 0 && t !== "module" && t !== "commonjs" && t !== "script" && t !== "unambiguous")
      throw new Error(`${tt(e)} must be "module", "commonjs", "script", "unambiguous", or undefined`);
    return t;
  }
  n(UWe, "assertSourceType");
  function $We(e, t) {
    let r = BK(e, t);
    if (r) {
      if (typeof r.name != "string")
        throw new Error(`${tt(e)} set but does not contain "name" property string`);
      for (let i of Object.keys(r)) {
        let s = Fi(e, i), a = r[i];
        if (a != null && typeof a != "boolean" && typeof a != "string" && typeof a != "number")
          throw new Error(`${tt(s)} must be null, undefined, a boolean, a string, or a number.`);
      }
    }
    return t;
  }
  n($We, "assertCallerMetadata");
  function VWe(e, t) {
    if (t !== void 0 && typeof t != "boolean" && (typeof t != "object" || !t))
      throw new Error(`${tt(e)} must be a boolean, object, or undefined`);
    return t;
  }
  n(VWe, "assertInputSourceMap");
  function WWe(e, t) {
    if (t !== void 0 && typeof t != "string")
      throw new Error(`${tt(e)} must be a string, or undefined`);
    return t;
  }
  n(WWe, "assertString");
  function HWe(e, t) {
    if (t !== void 0 && typeof t != "function")
      throw new Error(`${tt(e)} must be a function, or undefined`);
    return t;
  }
  n(HWe, "assertFunction");
  function b_(e, t) {
    if (t !== void 0 && typeof t != "boolean")
      throw new Error(`${tt(e)} must be a boolean, or undefined`);
    return t;
  }
  n(b_, "assertBoolean");
  function BK(e, t) {
    if (t !== void 0 && (typeof t != "object" || Array.isArray(t) || !t))
      throw new Error(`${tt(e)} must be an object, or undefined`);
    return t;
  }
  n(BK, "assertObject");
  function D_(e, t) {
    if (t != null && !Array.isArray(t))
      throw new Error(`${tt(e)} must be an array, or undefined`);
    return t;
  }
  n(D_, "assertArray");
  function KWe(e, t) {
    let r = D_(e, t);
    return r?.forEach((i, s) => zWe(Fi(e, s), i)), r;
  }
  n(KWe, "assertIgnoreList");
  function zWe(e, t) {
    if (typeof t != "string" && typeof t != "function" && !(t instanceof RegExp))
      throw new Error(`${tt(e)} must be an array of string/Function/RegExp values, or undefined`);
    return t;
  }
  n(zWe, "assertIgnoreItem");
  function JWe(e, t) {
    if (t === void 0)
      return t;
    if (Array.isArray(t))
      t.forEach((r, i) => {
        if (!ig(r))
          throw new Error(`${tt(Fi(e, i))} must be a string/Function/RegExp.`);
      });
    else if (!ig(t))
      throw new Error(`${tt(e)} must be a string/Function/RegExp, or an array of those`);
    return t;
  }
  n(JWe, "assertConfigApplicableTest");
  function ig(e) {
    return typeof e == "string" || typeof e == "function" || e instanceof RegExp;
  }
  n(ig, "checkValidTest");
  function XWe(e, t) {
    if (t !== void 0 && typeof t != "boolean" && typeof t != "string")
      throw new Error(`${tt(e)} must be a undefined, a boolean, a string, got ${JSON.stringify(t)}`);
    return t;
  }
  n(XWe, "assertConfigFileSearch");
  function YWe(e, t) {
    if (t === void 0 || typeof t == "boolean")
      return t;
    if (Array.isArray(t))
      t.forEach((r, i) => {
        if (!ig(r))
          throw new Error(`${tt(Fi(e, i))} must be a string/Function/RegExp.`);
      });
    else if (!ig(t))
      throw new Error(`${tt(e)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(t)}`);
    return t;
  }
  n(YWe, "assertBabelrcSearch");
  function GWe(e, t) {
    let r = D_(e, t);
    return r && r.forEach((i, s) => ZWe(Fi(e, s), i)), r;
  }
  n(GWe, "assertPluginList");
  function ZWe(e, t) {
    if (Array.isArray(t)) {
      if (t.length === 0)
        throw new Error(`${tt(e)} must include an object`);
      if (t.length > 3)
        throw new Error(`${tt(e)} may only be a two-tuple or three-tuple`);
      if (OK(Fi(e, 0), t[0]), t.length > 1) {
        let r = t[1];
        if (r !== void 0 && r !== !1 && (typeof r != "object" || Array.isArray(r) || r === null))
          throw new Error(`${tt(Fi(e, 1))} must be an object, false, or undefined`);
      }
      if (t.length === 3) {
        let r = t[2];
        if (r !== void 0 && typeof r != "string")
          throw new Error(`${tt(Fi(e, 2))} must be a string, or undefined`);
      }
    } else
      OK(e, t);
    return t;
  }
  n(ZWe, "assertPluginItem");
  function OK(e, t) {
    if ((typeof t != "object" || !t) && typeof t != "string" && typeof t != "function")
      throw new Error(`${tt(e)} must be a string, object, function`);
    return t;
  }
  n(OK, "assertPluginTarget");
  function QWe(e, t) {
    if ((0, Np().isBrowsersQueryValid)(t)) return t;
    if (typeof t != "object" || !t || Array.isArray(t))
      throw new Error(`${tt(e)} must be a string, an array of strings or an object`);
    let r = Fi(e, "browsers"), i = Fi(e, "esmodules");
    kK(r, t.browsers), b_(i, t.esmodules);
    for (let s of Object.keys(t)) {
      let a = t[s], o = Fi(e, s);
      if (s === "esmodules") b_(o, a);
      else if (s === "browsers") kK(o, a);
      else if (hasOwnProperty.call(Np().TargetNames, s))
        eHe(o, a);
      else {
        let u = Object.keys(Np().TargetNames).join(", ");
        throw new Error(`${tt(o)} is not a valid target. Supported targets are ${u}`);
      }
    }
    return t;
  }
  n(QWe, "assertTargets");
  function kK(e, t) {
    if (t !== void 0 && !(0, Np().isBrowsersQueryValid)(t))
      throw new Error(`${tt(e)} must be undefined, a string or an array of strings`);
  }
  n(kK, "assertBrowsersList");
  function eHe(e, t) {
    if (!(typeof t == "number" && Math.round(t) === t) && typeof t != "string")
      throw new Error(`${tt(e)} must be a string or an integer number`);
  }
  n(eHe, "assertBrowserVersion");
  function tHe(e, t) {
    if (t === void 0) return;
    if (typeof t != "object" || t === null)
      throw new Error(`${tt(e)} must be an object or undefined.`);
    let r = e;
    do
      r = r.parent;
    while (r.type !== "root");
    let i = r.source === "preset";
    for (let s of Object.keys(t)) {
      let a = Fi(e, s);
      if (!RWe.assumptionsNames.has(s))
        throw new Error(`${tt(a)} is not a supported assumption.`);
      if (typeof t[s] != "boolean")
        throw new Error(`${tt(a)} must be a boolean.`);
      if (i && t[s] === !1)
        throw new Error(`${tt(a)} cannot be set to 'false' inside presets.`);
    }
    return t;
  }
  n(tHe, "assertAssumptions");
});

// ../node_modules/@babel/core/lib/config/validation/options.js
var Mp = E((bc) => {
  "use strict";
  Object.defineProperty(bc, "__esModule", {
    value: !0
  });
  bc.assumptionsNames = void 0;
  bc.checkNoUnwrappedItemOptionPairs = lHe;
  bc.validate = sHe;
  var NK = IK(), be = v_(), rHe = du(), MK = {
    cwd: be.assertString,
    root: be.assertString,
    rootMode: be.assertRootMode,
    configFile: be.assertConfigFileSearch,
    caller: be.assertCallerMetadata,
    filename: be.assertString,
    filenameRelative: be.assertString,
    code: be.assertBoolean,
    ast: be.assertBoolean,
    cloneInputAst: be.assertBoolean,
    envName: be.assertString
  }, RK = {
    babelrc: be.assertBoolean,
    babelrcRoots: be.assertBabelrcSearch
  }, LK = {
    extends: be.assertString,
    ignore: be.assertIgnoreList,
    only: be.assertIgnoreList,
    targets: be.assertTargets,
    browserslistConfigFile: be.assertConfigFileSearch,
    browserslistEnv: be.assertString
  }, jK = {
    inputSourceMap: be.assertInputSourceMap,
    presets: be.assertPluginList,
    plugins: be.assertPluginList,
    passPerPreset: be.assertBoolean,
    assumptions: be.assertAssumptions,
    env: oHe,
    overrides: uHe,
    test: be.assertConfigApplicableTest,
    include: be.assertConfigApplicableTest,
    exclude: be.assertConfigApplicableTest,
    retainLines: be.assertBoolean,
    comments: be.assertBoolean,
    shouldPrintComment: be.assertFunction,
    compact: be.assertCompact,
    minified: be.assertBoolean,
    auxiliaryCommentBefore: be.assertString,
    auxiliaryCommentAfter: be.assertString,
    sourceType: be.assertSourceType,
    wrapPluginVisitorMethod: be.assertFunction,
    highlightCode: be.assertBoolean,
    sourceMaps: be.assertSourceMaps,
    sourceMap: be.assertSourceMaps,
    sourceFileName: be.assertString,
    sourceRoot: be.assertString,
    parserOpts: be.assertObject,
    generatorOpts: be.assertObject
  };
  Object.assign(jK, {
    getModuleId: be.assertFunction,
    moduleRoot: be.assertString,
    moduleIds: be.assertBoolean,
    moduleId: be.assertString
  });
  var iHe = ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitive\
Hint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUnini\
tializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods",
  "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"], YDt = bc.
  assumptionsNames = new Set(iHe);
  function qK(e) {
    return e.type === "root" ? e.source : qK(e.parent);
  }
  n(qK, "getSource");
  function sHe(e, t, r) {
    try {
      return x_({
        type: "root",
        source: e
      }, t);
    } catch (i) {
      let s = new rHe.default(i.message, r);
      throw i.code && (s.code = i.code), s;
    }
  }
  n(sHe, "validate");
  function x_(e, t) {
    let r = qK(e);
    return aHe(t), Object.keys(t).forEach((i) => {
      let s = {
        type: "option",
        name: i,
        parent: e
      };
      if (r === "preset" && LK[i])
        throw new Error(`${(0, be.msg)(s)} is not allowed in preset options`);
      if (r !== "arguments" && MK[i])
        throw new Error(`${(0, be.msg)(s)} is only allowed in root programmatic options`);
      if (r !== "arguments" && r !== "configfile" && RK[i])
        throw r === "babelrcfile" || r === "extendsfile" ? new Error(`${(0, be.msg)(s)} is not allowed in .babelrc or "extends"ed files, onl\
y in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, be.msg)(s)} is only allowed in root programmatic\
 options, or babel.config.js/config file options`);
      (jK[i] || LK[i] || RK[i] || MK[i] || nHe)(s, t[i]);
    }), t;
  }
  n(x_, "validateNested");
  function nHe(e) {
    let t = e.name;
    if (NK.default[t]) {
      let {
        message: r,
        version: i = 5
      } = NK.default[t];
      throw new Error(`Using removed Babel ${i} option: ${(0, be.msg)(e)} - ${r}`);
    } else {
      let r = new Error(`Unknown option: ${(0, be.msg)(e)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information ab\
out options.`);
      throw r.code = "BABEL_UNKNOWN_OPTION", r;
    }
  }
  n(nHe, "throwUnknownError");
  function aHe(e) {
    if (hasOwnProperty.call(e, "sourceMap") && hasOwnProperty.call(e, "sourceMaps"))
      throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
  }
  n(aHe, "assertNoDuplicateSourcemap");
  function oHe(e, t) {
    if (e.parent.type === "env")
      throw new Error(`${(0, be.msg)(e)} is not allowed inside of another .env block`);
    let r = e.parent, i = (0, be.assertObject)(e, t);
    if (i)
      for (let s of Object.keys(i)) {
        let a = (0, be.assertObject)((0, be.access)(e, s), i[s]);
        if (!a) continue;
        x_({
          type: "env",
          name: s,
          parent: r
        }, a);
      }
    return i;
  }
  n(oHe, "assertEnvSet");
  function uHe(e, t) {
    if (e.parent.type === "env")
      throw new Error(`${(0, be.msg)(e)} is not allowed inside an .env block`);
    if (e.parent.type === "overrides")
      throw new Error(`${(0, be.msg)(e)} is not allowed inside an .overrides block`);
    let r = e.parent, i = (0, be.assertArray)(e, t);
    if (i)
      for (let [s, a] of i.entries()) {
        let o = (0, be.access)(e, s), u = (0, be.assertObject)(o, a);
        if (!u) throw new Error(`${(0, be.msg)(o)} must be an object`);
        x_({
          type: "overrides",
          index: s,
          parent: r
        }, u);
      }
    return i;
  }
  n(uHe, "assertOverridesList");
  function lHe(e, t, r, i) {
    if (t === 0) return;
    let s = e[t - 1], a = e[t];
    s.file && s.options === void 0 && typeof a.value == "object" && (i.message += `
- Maybe you meant to use
"${r}s": [
  ["${s.file.request}", ${JSON.stringify(a.value, void 0, 2)}]
]
To be a valid ${r}, its name and options should be wrapped in a pair of brackets`);
  }
  n(lHe, "checkNoUnwrappedItemOptionPairs");
});

// ../node_modules/@babel/core/lib/config/pattern-to-regex.js
var w_ = E((C_) => {
  "use strict";
  Object.defineProperty(C_, "__esModule", {
    value: !0
  });
  C_.default = dHe;
  function sg() {
    let e = require("path");
    return sg = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(sg, "_path");
  var Rp = `\\${sg().sep}`, E_ = `(?:${Rp}|$)`, S_ = `[^${Rp}]+`, T_ = `(?:${S_}${Rp})`, $K = `(?:${S_}${E_})`, cHe = `${T_}*?`, fHe = `${T_}\
*?${$K}?`;
  function UK(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  }
  n(UK, "escapeRegExp");
  function dHe(e, t) {
    let r = sg().resolve(t, e).split(sg().sep);
    return new RegExp(["^", ...r.map((i, s) => {
      let a = s === r.length - 1;
      return i === "**" ? a ? fHe : cHe : i === "*" ? a ? $K : T_ : i.indexOf("*.") === 0 ? S_ + UK(i.slice(1)) + (a ? E_ : Rp) : UK(i) + (a ?
      E_ : Rp);
    })].join(""));
  }
  n(dHe, "pathToPattern");
});

// ../node_modules/@babel/core/lib/config/printer.js
var HK = E((Dc) => {
  "use strict";
  Object.defineProperty(Dc, "__esModule", {
    value: !0
  });
  Dc.ConfigPrinter = Dc.ChainFormatter = void 0;
  function WK() {
    let e = _i();
    return WK = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n(WK, "_gensync");
  var pHe = Dc.ChainFormatter = {
    Programmatic: 0,
    Config: 1
  }, A_ = {
    title(e, t, r) {
      let i = "";
      return e === pHe.Programmatic ? (i = "programmatic options", t && (i += " from " + t)) : i = "config " + r, i;
    },
    loc(e, t) {
      let r = "";
      return e != null && (r += `.overrides[${e}]`), t != null && (r += `.env["${t}"]`), r;
    },
    *optionsAndDescriptors(e) {
      let t = Object.assign({}, e.options);
      delete t.overrides, delete t.env;
      let r = [...yield* e.plugins()];
      r.length && (t.plugins = r.map((s) => VK(s)));
      let i = [...yield* e.presets()];
      return i.length && (t.presets = [...i].map((s) => VK(s))), JSON.stringify(t, void 0, 2);
    }
  };
  function VK(e) {
    var t;
    let r = (t = e.file) == null ? void 0 : t.request;
    return r == null && (typeof e.value == "object" ? r = e.value : typeof e.value == "function" && (r = `[Function: ${e.value.toString().slice(
    0, 50)} ... ]`)), r == null && (r = "[Unknown]"), e.options === void 0 ? r : e.name == null ? [r, e.options] : [r, e.options, e.name];
  }
  n(VK, "descriptorToConfig");
  var __ = class e {
    static {
      n(this, "ConfigPrinter");
    }
    constructor() {
      this._stack = [];
    }
    configure(t, r, {
      callerName: i,
      filepath: s
    }) {
      return t ? (a, o, u) => {
        this._stack.push({
          type: r,
          callerName: i,
          filepath: s,
          content: a,
          index: o,
          envName: u
        });
      } : () => {
      };
    }
    static *format(t) {
      let r = A_.title(t.type, t.callerName, t.filepath), i = A_.loc(t.index, t.envName);
      i && (r += ` ${i}`);
      let s = yield* A_.optionsAndDescriptors(t.content);
      return `${r}
${s}`;
    }
    *output() {
      return this._stack.length === 0 ? "" : (yield* WK().all(this._stack.map((r) => e.format(r)))).join(`

`);
    }
  };
  Dc.ConfigPrinter = __;
});

// ../node_modules/@babel/core/lib/config/config-chain.js
var L_ = E((xc) => {
  "use strict";
  Object.defineProperty(xc, "__esModule", {
    value: !0
  });
  xc.buildPresetChain = yHe;
  xc.buildPresetChainWalker = void 0;
  xc.buildRootChain = EHe;
  function JK() {
    let e = require("path");
    return JK = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(JK, "_path");
  function XK() {
    let e = zo();
    return XK = /* @__PURE__ */ n(function() {
      return e;
    }, "_debug"), e;
  }
  n(XK, "_debug");
  var O_ = Mp(), YK = w_(), jp = HK(), hHe = Kn(), mHe = du(), Lp = kp(), hr = fu(), Zi = y_(), KK = XK()("babel:config:config-chain");
  function* yHe(e, t) {
    let r = yield* gHe(e, t);
    return r ? {
      plugins: og(r.plugins),
      presets: og(r.presets),
      options: r.options.map((i) => GK(i)),
      files: /* @__PURE__ */ new Set()
    } : null;
  }
  n(yHe, "buildPresetChain");
  var gHe = xc.buildPresetChainWalker = R_({
    root: /* @__PURE__ */ n((e) => bHe(e), "root"),
    env: /* @__PURE__ */ n((e, t) => DHe(e)(t), "env"),
    overrides: /* @__PURE__ */ n((e, t) => vHe(e)(t), "overrides"),
    overridesEnv: /* @__PURE__ */ n((e, t, r) => xHe(e)(t)(r), "overridesEnv"),
    createLogger: /* @__PURE__ */ n(() => () => {
    }, "createLogger")
  }), bHe = (0, hr.makeWeakCacheSync)((e) => k_(e, e.alias, Zi.createUncachedDescriptors)), DHe = (0, hr.makeWeakCacheSync)((e) => (0, hr.makeStrongCacheSync)(
  (t) => B_(e, e.alias, Zi.createUncachedDescriptors, t))), vHe = (0, hr.makeWeakCacheSync)((e) => (0, hr.makeStrongCacheSync)((t) => N_(e, e.
  alias, Zi.createUncachedDescriptors, t))), xHe = (0, hr.makeWeakCacheSync)((e) => (0, hr.makeStrongCacheSync)((t) => (0, hr.makeStrongCacheSync)(
  (r) => M_(e, e.alias, Zi.createUncachedDescriptors, t, r))));
  function* EHe(e, t) {
    let r, i, s = new jp.ConfigPrinter(), a = yield* AHe({
      options: e,
      dirname: t.cwd
    }, t, void 0, s);
    if (!a) return null;
    let o = yield* s.output(), u;
    typeof e.configFile == "string" ? u = yield* (0, Lp.loadConfig)(e.configFile, t.cwd, t.envName, t.caller) : e.configFile !== !1 && (u = yield* (0, Lp.
    findRootConfig)(t.root, t.envName, t.caller));
    let {
      babelrc: l,
      babelrcRoots: c
    } = e, f = t.cwd, m = ag(), h = new jp.ConfigPrinter();
    if (u) {
      let D = THe(u), x = yield* F_(D, t, void 0, h);
      if (!x) return null;
      r = yield* h.output(), l === void 0 && (l = D.options.babelrc), c === void 0 && (f = D.dirname, c = D.options.babelrcRoots), vc(m, x);
    }
    let d, y, p = !1, g = ag();
    if ((l === !0 || l === void 0) && typeof t.filename == "string") {
      let D = yield* (0, Lp.findPackageData)(t.filename);
      if (D && SHe(t, D, c, f)) {
        if ({
          ignore: d,
          config: y
        } = yield* (0, Lp.findRelativeConfig)(D, t.envName, t.caller), d && g.files.add(d.filepath), d && ZK(t, d.ignore, null, d.dirname) &&
        (p = !0), y && !p) {
          let x = CHe(y), T = new jp.ConfigPrinter(), w = yield* F_(x, t, void 0, T);
          w ? (i = yield* T.output(), vc(g, w)) : p = !0;
        }
        y && p && g.files.add(y.filepath);
      }
    }
    t.showConfig && console.log(`Babel configs on "${t.filename}" (ascending priority):
` + [r, i, o].filter((D) => !!D).join(`

`) + `
-----End Babel configs-----`);
    let b = vc(vc(vc(ag(), m), g), a);
    return {
      plugins: p ? [] : og(b.plugins),
      presets: p ? [] : og(b.presets),
      options: p ? [] : b.options.map((D) => GK(D)),
      fileHandling: p ? "ignored" : "transpile",
      ignore: d || void 0,
      babelrc: y || void 0,
      config: u || void 0,
      files: b.files
    };
  }
  n(EHe, "buildRootChain");
  function SHe(e, t, r, i) {
    if (typeof r == "boolean") return r;
    let s = e.root;
    if (r === void 0)
      return t.directories.includes(s);
    let a = r;
    return Array.isArray(a) || (a = [a]), a = a.map((o) => typeof o == "string" ? JK().resolve(i, o) : o), a.length === 1 && a[0] === s ? t.
    directories.includes(s) : a.some((o) => (typeof o == "string" && (o = (0, YK.default)(o, i)), t.directories.some((u) => QK(o, i, u, e))));
  }
  n(SHe, "babelrcLoadEnabled");
  var THe = (0, hr.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, O_.validate)("configfile", e.options, e.filepath)
  })), CHe = (0, hr.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, O_.validate)("babelrcfile", e.options, e.filepath)
  })), wHe = (0, hr.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, O_.validate)("extendsfile", e.options, e.filepath)
  })), AHe = R_({
    root: /* @__PURE__ */ n((e) => k_(e, "base", Zi.createCachedDescriptors), "root"),
    env: /* @__PURE__ */ n((e, t) => B_(e, "base", Zi.createCachedDescriptors, t), "env"),
    overrides: /* @__PURE__ */ n((e, t) => N_(e, "base", Zi.createCachedDescriptors, t), "overrides"),
    overridesEnv: /* @__PURE__ */ n((e, t, r) => M_(e, "base", Zi.createCachedDescriptors, t, r), "overridesEnv"),
    createLogger: /* @__PURE__ */ n((e, t, r) => BHe(e, t, r), "createLogger")
  }), _He = R_({
    root: /* @__PURE__ */ n((e) => PHe(e), "root"),
    env: /* @__PURE__ */ n((e, t) => FHe(e)(t), "env"),
    overrides: /* @__PURE__ */ n((e, t) => IHe(e)(t), "overrides"),
    overridesEnv: /* @__PURE__ */ n((e, t, r) => OHe(e)(t)(r), "overridesEnv"),
    createLogger: /* @__PURE__ */ n((e, t, r) => kHe(e.filepath, t, r), "createLogger")
  });
  function* F_(e, t, r, i) {
    let s = yield* _He(e, t, r, i);
    return s?.files.add(e.filepath), s;
  }
  n(F_, "loadFileChain");
  var PHe = (0, hr.makeWeakCacheSync)((e) => k_(e, e.filepath, Zi.createUncachedDescriptors)), FHe = (0, hr.makeWeakCacheSync)((e) => (0, hr.
  makeStrongCacheSync)((t) => B_(e, e.filepath, Zi.createUncachedDescriptors, t))), IHe = (0, hr.makeWeakCacheSync)((e) => (0, hr.makeStrongCacheSync)(
  (t) => N_(e, e.filepath, Zi.createUncachedDescriptors, t))), OHe = (0, hr.makeWeakCacheSync)((e) => (0, hr.makeStrongCacheSync)((t) => (0, hr.
  makeStrongCacheSync)((r) => M_(e, e.filepath, Zi.createUncachedDescriptors, t, r))));
  function kHe(e, t, r) {
    return r ? r.configure(t.showConfig, jp.ChainFormatter.Config, {
      filepath: e
    }) : () => {
    };
  }
  n(kHe, "buildFileLogger");
  function k_({
    dirname: e,
    options: t
  }, r, i) {
    return i(e, t, r);
  }
  n(k_, "buildRootDescriptors");
  function BHe(e, t, r) {
    var i;
    return r ? r.configure(t.showConfig, jp.ChainFormatter.Programmatic, {
      callerName: (i = t.caller) == null ? void 0 : i.name
    }) : () => {
    };
  }
  n(BHe, "buildProgrammaticLogger");
  function B_({
    dirname: e,
    options: t
  }, r, i, s) {
    var a;
    let o = (a = t.env) == null ? void 0 : a[s];
    return o ? i(e, o, `${r}.env["${s}"]`) : null;
  }
  n(B_, "buildEnvDescriptors");
  function N_({
    dirname: e,
    options: t
  }, r, i, s) {
    var a;
    let o = (a = t.overrides) == null ? void 0 : a[s];
    if (!o) throw new Error("Assertion failure - missing override");
    return i(e, o, `${r}.overrides[${s}]`);
  }
  n(N_, "buildOverrideDescriptors");
  function M_({
    dirname: e,
    options: t
  }, r, i, s, a) {
    var o, u;
    let l = (o = t.overrides) == null ? void 0 : o[s];
    if (!l) throw new Error("Assertion failure - missing override");
    let c = (u = l.env) == null ? void 0 : u[a];
    return c ? i(e, c, `${r}.overrides[${s}].env["${a}"]`) : null;
  }
  n(M_, "buildOverrideEnvDescriptors");
  function R_({
    root: e,
    env: t,
    overrides: r,
    overridesEnv: i,
    createLogger: s
  }) {
    return /* @__PURE__ */ n(function* (o, u, l = /* @__PURE__ */ new Set(), c) {
      let {
        dirname: f
      } = o, m = [], h = e(o);
      if (ng(h, f, u, o.filepath)) {
        m.push({
          config: h,
          envName: void 0,
          index: void 0
        });
        let p = t(o, u.envName);
        p && ng(p, f, u, o.filepath) && m.push({
          config: p,
          envName: u.envName,
          index: void 0
        }), (h.options.overrides || []).forEach((g, b) => {
          let D = r(o, b);
          if (ng(D, f, u, o.filepath)) {
            m.push({
              config: D,
              index: b,
              envName: void 0
            });
            let x = i(o, b, u.envName);
            x && ng(x, f, u, o.filepath) && m.push({
              config: x,
              index: b,
              envName: u.envName
            });
          }
        });
      }
      if (m.some(({
        config: {
          options: {
            ignore: p,
            only: g
          }
        }
      }) => ZK(u, p, g, f)))
        return null;
      let d = ag(), y = s(o, u, c);
      for (let {
        config: p,
        index: g,
        envName: b
      } of m) {
        if (!(yield* NHe(d, p.options, f, u, l, c)))
          return null;
        y(p, g, b), yield* MHe(d, p);
      }
      return d;
    }, "chainWalker");
  }
  n(R_, "makeChainWalker");
  function* NHe(e, t, r, i, s, a) {
    if (t.extends === void 0) return !0;
    let o = yield* (0, Lp.loadConfig)(t.extends, r, i.envName, i.caller);
    if (s.has(o))
      throw new Error(`Configuration cycle detected loading ${o.filepath}.
File already loaded following the config chain:
` + Array.from(s, (l) => ` - ${l.filepath}`).join(`
`));
    s.add(o);
    let u = yield* F_(wHe(o), i, s, a);
    return s.delete(o), u ? (vc(e, u), !0) : !1;
  }
  n(NHe, "mergeExtendsChain");
  function vc(e, t) {
    e.options.push(...t.options), e.plugins.push(...t.plugins), e.presets.push(...t.presets);
    for (let r of t.files)
      e.files.add(r);
    return e;
  }
  n(vc, "mergeChain");
  function* MHe(e, {
    options: t,
    plugins: r,
    presets: i
  }) {
    return e.options.push(t), e.plugins.push(...yield* r()), e.presets.push(...yield* i()), e;
  }
  n(MHe, "mergeChainOpts");
  function ag() {
    return {
      options: [],
      presets: [],
      plugins: [],
      files: /* @__PURE__ */ new Set()
    };
  }
  n(ag, "emptyChain");
  function GK(e) {
    let t = Object.assign({}, e);
    return delete t.extends, delete t.env, delete t.overrides, delete t.plugins, delete t.presets, delete t.passPerPreset, delete t.ignore, delete t.
    only, delete t.test, delete t.include, delete t.exclude, hasOwnProperty.call(t, "sourceMap") && (t.sourceMaps = t.sourceMap, delete t.sourceMap),
    t;
  }
  n(GK, "normalizeOptions");
  function og(e) {
    let t = /* @__PURE__ */ new Map(), r = [];
    for (let i of e)
      if (typeof i.value == "function") {
        let s = i.value, a = t.get(s);
        a || (a = /* @__PURE__ */ new Map(), t.set(s, a));
        let o = a.get(i.name);
        o ? o.value = i : (o = {
          value: i
        }, r.push(o), i.ownPass || a.set(i.name, o));
      } else
        r.push({
          value: i
        });
    return r.reduce((i, s) => (i.push(s.value), i), []);
  }
  n(og, "dedupDescriptors");
  function ng({
    options: e
  }, t, r, i) {
    return (e.test === void 0 || P_(r, e.test, t, i)) && (e.include === void 0 || P_(r, e.include, t, i)) && (e.exclude === void 0 || !P_(r,
    e.exclude, t, i));
  }
  n(ng, "configIsApplicable");
  function P_(e, t, r, i) {
    let s = Array.isArray(t) ? t : [t];
    return I_(e, s, r, i);
  }
  n(P_, "configFieldIsApplicable");
  function zK(e, t) {
    return t instanceof RegExp ? String(t) : t;
  }
  n(zK, "ignoreListReplacer");
  function ZK(e, t, r, i) {
    if (t && I_(e, t, i)) {
      var s;
      let o = `No config is applied to "${(s = e.filename) != null ? s : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(
      t, zK)}\` from "${i}"`;
      return KK(o), e.showConfig && console.log(o), !0;
    }
    if (r && !I_(e, r, i)) {
      var a;
      let o = `No config is applied to "${(a = e.filename) != null ? a : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(
      r, zK)}\` from "${i}"`;
      return KK(o), e.showConfig && console.log(o), !0;
    }
    return !1;
  }
  n(ZK, "shouldIgnore");
  function I_(e, t, r, i) {
    return t.some((s) => QK(s, r, e.filename, e, i));
  }
  n(I_, "matchesPatterns");
  function QK(e, t, r, i, s) {
    if (typeof e == "function")
      return !!(0, hHe.endHiddenCallStack)(e)(r, {
        dirname: t,
        envName: i.envName,
        caller: i.caller
      });
    if (typeof r != "string")
      throw new mHe.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", s);
    return typeof e == "string" && (e = (0, YK.default)(e, t)), e.test(r);
  }
  n(QK, "matchPattern");
});

// ../node_modules/@babel/core/lib/config/validation/plugins.js
var ez = E((j_) => {
  "use strict";
  Object.defineProperty(j_, "__esModule", {
    value: !0
  });
  j_.validatePluginObject = qHe;
  var ea = v_(), RHe = {
    name: ea.assertString,
    manipulateOptions: ea.assertFunction,
    pre: ea.assertFunction,
    post: ea.assertFunction,
    inherits: ea.assertFunction,
    visitor: LHe,
    parserOverride: ea.assertFunction,
    generatorOverride: ea.assertFunction
  };
  function LHe(e, t) {
    let r = (0, ea.assertObject)(e, t);
    if (r && (Object.keys(r).forEach((i) => {
      i !== "_exploded" && i !== "_verified" && jHe(i, r[i]);
    }), r.enter || r.exit))
      throw new Error(`${(0, ea.msg)(e)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
    return r;
  }
  n(LHe, "assertVisitorMap");
  function jHe(e, t) {
    if (t && typeof t == "object")
      Object.keys(t).forEach((r) => {
        if (r !== "enter" && r !== "exit")
          throw new Error(`.visitor["${e}"] may only have .enter and/or .exit handlers.`);
      });
    else if (typeof t != "function")
      throw new Error(`.visitor["${e}"] must be a function`);
  }
  n(jHe, "assertVisitorHandler");
  function qHe(e) {
    let t = {
      type: "root",
      source: "plugin"
    };
    return Object.keys(e).forEach((r) => {
      let i = RHe[r];
      if (i)
        i({
          type: "option",
          name: r,
          parent: t
        }, e[r]);
      else {
        let s = new Error(`.${r} is not a valid Plugin property`);
        throw s.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", s;
      }
    }), e;
  }
  n(qHe, "validatePluginObject");
});

// ../node_modules/@babel/core/lib/config/helpers/environment.js
var U_ = E((q_) => {
  "use strict";
  Object.defineProperty(q_, "__esModule", {
    value: !0
  });
  q_.getEnv = UHe;
  function UHe(e = "development") {
    return process.env.BABEL_ENV || process.env.NODE_ENV || e;
  }
  n(UHe, "getEnv");
});

// ../node_modules/@babel/core/lib/config/partial.js
var $_ = E((fg) => {
  "use strict";
  Object.defineProperty(fg, "__esModule", {
    value: !0
  });
  fg.default = rz;
  fg.loadPartialConfig = GHe;
  function ug() {
    let e = require("path");
    return ug = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(ug, "_path");
  var $He = k1(), VHe = D1(), tz = Op(), WHe = L_(), HHe = U_(), KHe = Mp(), lg = kp(), zHe = m_(), JHe = ["showIgnoredFiles"];
  function XHe(e, t) {
    if (e == null) return {};
    var r = {};
    for (var i in e) if ({}.hasOwnProperty.call(e, i)) {
      if (t.indexOf(i) !== -1) continue;
      r[i] = e[i];
    }
    return r;
  }
  n(XHe, "_objectWithoutPropertiesLoose");
  function YHe(e, t) {
    switch (t) {
      case "root":
        return e;
      case "upward-optional": {
        let r = (0, lg.findConfigUpwards)(e);
        return r === null ? e : r;
      }
      case "upward": {
        let r = (0, lg.findConfigUpwards)(e);
        if (r !== null) return r;
        throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${e}".\

One of the following config files must be in the directory tree: "${lg.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
          code: "BABEL_ROOT_NOT_FOUND",
          dirname: e
        });
      }
      default:
        throw new Error("Assertion failure - unknown rootMode value.");
    }
  }
  n(YHe, "resolveRootMode");
  function* rz(e) {
    if (e != null && (typeof e != "object" || Array.isArray(e)))
      throw new Error("Babel options must be an object, null, or undefined");
    let t = e ? (0, KHe.validate)("arguments", e) : {}, {
      envName: r = (0, HHe.getEnv)(),
      cwd: i = ".",
      root: s = ".",
      rootMode: a = "root",
      caller: o,
      cloneInputAst: u = !0
    } = t, l = ug().resolve(i), c = YHe(ug().resolve(l, s), a), f = typeof t.filename == "string" ? ug().resolve(i, t.filename) : void 0, m = yield* (0, lg.
    resolveShowConfigPath)(l), h = {
      filename: f,
      cwd: l,
      root: c,
      envName: r,
      caller: o,
      showConfig: m === f
    }, d = yield* (0, WHe.buildRootChain)(t, h);
    if (!d) return null;
    let y = {
      assumptions: {}
    };
    return d.options.forEach((g) => {
      (0, VHe.mergeOptions)(y, g);
    }), {
      options: Object.assign({}, y, {
        targets: (0, zHe.resolveTargets)(y, c),
        cloneInputAst: u,
        babelrc: !1,
        configFile: !1,
        browserslistConfigFile: !1,
        passPerPreset: !1,
        envName: h.envName,
        cwd: h.cwd,
        root: h.root,
        rootMode: "root",
        filename: typeof h.filename == "string" ? h.filename : void 0,
        plugins: d.plugins.map((g) => (0, tz.createItemFromDescriptor)(g)),
        presets: d.presets.map((g) => (0, tz.createItemFromDescriptor)(g))
      }),
      context: h,
      fileHandling: d.fileHandling,
      ignore: d.ignore,
      babelrc: d.babelrc,
      config: d.config,
      files: d.files
    };
  }
  n(rz, "loadPrivatePartialConfig");
  function* GHe(e) {
    let t = !1;
    if (typeof e == "object" && e !== null && !Array.isArray(e)) {
      var r = e;
      ({
        showIgnoredFiles: t
      } = r), e = XHe(r, JHe);
    }
    let i = yield* rz(e);
    if (!i) return null;
    let {
      options: s,
      babelrc: a,
      ignore: o,
      config: u,
      fileHandling: l,
      files: c
    } = i;
    return l === "ignored" && !t ? null : ((s.plugins || []).forEach((f) => {
      if (f.value instanceof $He.default)
        throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
    }), new cg(s, a ? a.filepath : void 0, o ? o.filepath : void 0, u ? u.filepath : void 0, l, c));
  }
  n(GHe, "loadPartialConfig");
  var cg = class {
    static {
      n(this, "PartialConfig");
    }
    constructor(t, r, i, s, a, o) {
      this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files =
      void 0, this.options = t, this.babelignore = i, this.babelrc = r, this.config = s, this.fileHandling = a, this.files = o, Object.freeze(
      this);
    }
    hasFilesystemConfig() {
      return this.babelrc !== void 0 || this.config !== void 0;
    }
  };
  Object.freeze(cg.prototype);
});

// ../node_modules/@babel/core/lib/config/full.js
var fz = E((dg) => {
  "use strict";
  Object.defineProperty(dg, "__esModule", {
    value: !0
  });
  dg.default = void 0;
  function az() {
    let e = _i();
    return az = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n(az, "_gensync");
  var H_ = Ka(), iz = D1(), ZHe = Gt(), oz = k1(), QHe = Op(), eKe = L_(), J_ = I1();
  function K_() {
    let e = ir();
    return K_ = /* @__PURE__ */ n(function() {
      return e;
    }, "_traverse"), e;
  }
  n(K_, "_traverse");
  var X_ = fu(), z_ = Mp(), tKe = ez(), uz = kA(), rKe = $_(), iKe = du(), fvt = dg.default = az()(/* @__PURE__ */ n(function* (t) {
    var r;
    let i = yield* (0, rKe.default)(t);
    if (!i)
      return null;
    let {
      options: s,
      context: a,
      fileHandling: o
    } = i;
    if (o === "ignored")
      return null;
    let u = {}, {
      plugins: l,
      presets: c
    } = s;
    if (!l || !c)
      throw new Error("Assertion failure - plugins and presets exist");
    let f = Object.assign({}, a, {
      targets: s.targets
    }), m = /* @__PURE__ */ n((T) => {
      let w = (0, QHe.getItemDescriptor)(T);
      if (!w)
        throw new Error("Assertion failure - must be config item");
      return w;
    }, "toDescriptor"), h = c.map(m), d = l.map(m), y = [[]], p = [], g = [];
    if (yield* sz(a, /* @__PURE__ */ n(function* T(w, B) {
      let k = [];
      for (let V = 0; V < w.length; V++) {
        let Y = w[V];
        if (Y.options !== !1) {
          try {
            var q = yield* lKe(Y, f);
          } catch (G) {
            throw G.code === "BABEL_UNKNOWN_OPTION" && (0, z_.checkNoUnwrappedItemOptionPairs)(w, V, "preset", G), G;
          }
          g.push(q.externalDependencies), Y.ownPass ? k.push({
            preset: q.chain,
            pass: []
          }) : k.unshift({
            preset: q.chain,
            pass: B
          });
        }
      }
      if (k.length > 0) {
        y.splice(1, 0, ...k.map((V) => V.pass).filter((V) => V !== B));
        for (let {
          preset: V,
          pass: Y
        } of k) {
          if (!V || (Y.push(...V.plugins), yield* T(V.presets, Y))) return !0;
          V.options.forEach((ye) => {
            (0, iz.mergeOptions)(u, ye);
          });
        }
      }
    }, "recursePresetDescriptors"))(h, y[0])) return null;
    let D = u;
    (0, iz.mergeOptions)(D, s);
    let x = Object.assign({}, f, {
      assumptions: (r = D.assumptions) != null ? r : {}
    });
    return yield* sz(a, /* @__PURE__ */ n(function* () {
      y[0].unshift(...d);
      for (let B of y) {
        let k = [];
        p.push(k);
        for (let q = 0; q < B.length; q++) {
          let V = B[q];
          if (V.options !== !1) {
            try {
              var w = yield* cz(V, x);
            } catch (Y) {
              throw Y.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, z_.checkNoUnwrappedItemOptionPairs)(B, q, "plugin", Y), Y;
            }
            k.push(w), g.push(w.externalDependencies);
          }
        }
      }
    }, "loadPluginDescriptors"))(), D.plugins = p[0], D.presets = p.slice(1).filter((T) => T.length > 0).map((T) => ({
      plugins: T
    })), D.passPerPreset = D.presets.length > 0, {
      options: D,
      passes: p,
      externalDependencies: (0, J_.finalize)(g)
    };
  }, "loadFullConfig"));
  function sz(e, t) {
    return function* (r, i) {
      try {
        return yield* t(r, i);
      } catch (a) {
        if (!/^\[BABEL\]/.test(a.message)) {
          var s;
          a.message = `[BABEL] ${(s = e.filename) != null ? s : "unknown file"}: ${a.message}`;
        }
        throw a;
      }
    };
  }
  n(sz, "enhanceError");
  var lz = /* @__PURE__ */ n((e) => (0, X_.makeWeakCache)(function* ({
    value: t,
    options: r,
    dirname: i,
    alias: s
  }, a) {
    if (r === !1) throw new Error("Assertion failure");
    r = r || {};
    let o = [], u = t;
    if (typeof t == "function") {
      let l = (0, H_.maybeAsync)(t, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), c = Object.assign(
      {}, ZHe, e(a, o));
      try {
        u = yield* l(c, r, i);
      } catch (f) {
        throw s && (f.message += ` (While processing: ${JSON.stringify(s)})`), f;
      }
    }
    if (!u || typeof u != "object")
      throw new Error("Plugin/Preset did not return an object.");
    if ((0, H_.isThenable)(u))
      throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you\
're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". \
(While processing: ${JSON.stringify(s)})`);
    if (o.length > 0 && (!a.configured() || a.mode() === "forever")) {
      let l = `A plugin/preset has external untracked dependencies (${o[0]}), but the cache `;
      throw a.configured() ? l += " has been configured to never be invalidated. " : l += "has not been configured to be invalidated when th\
e external dependencies change. ", l += `Plugins/presets should configure their cache to be invalidated when the external dependencies chang\
e, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(s)})`, new Error(l);
    }
    return {
      value: u,
      options: r,
      dirname: i,
      alias: s,
      externalDependencies: (0, J_.finalize)(o)
    };
  }), "makeDescriptorLoader"), sKe = lz(uz.makePluginAPI), nKe = lz(uz.makePresetAPI), aKe = (0, X_.makeWeakCache)(function* ({
    value: e,
    options: t,
    dirname: r,
    alias: i,
    externalDependencies: s
  }, a) {
    let o = (0, tKe.validatePluginObject)(e), u = Object.assign({}, o);
    if (u.visitor && (u.visitor = K_().default.explode(Object.assign({}, u.visitor))), u.inherits) {
      let l = {
        name: void 0,
        alias: `${i}$inherits`,
        value: u.inherits,
        options: t,
        dirname: r
      }, c = yield* (0, H_.forwardAsync)(cz, (f) => a.invalidate((m) => f(l, m)));
      u.pre = W_(c.pre, u.pre), u.post = W_(c.post, u.post), u.manipulateOptions = W_(c.manipulateOptions, u.manipulateOptions), u.visitor =
      K_().default.visitors.merge([c.visitor || {}, u.visitor || {}]), c.externalDependencies.length > 0 && (s.length === 0 ? s = c.externalDependencies :
      s = (0, J_.finalize)([s, c.externalDependencies]));
    }
    return new oz.default(u, t, i, s);
  });
  function* cz(e, t) {
    if (e.value instanceof oz.default) {
      if (e.options)
        throw new Error("Passed options to an existing Plugin instance will not work.");
      return e.value;
    }
    return yield* aKe(yield* sKe(e, t), t);
  }
  n(cz, "loadPluginDescriptor");
  var V_ = /* @__PURE__ */ n((e) => e && typeof e != "function", "needsFilename"), nz = /* @__PURE__ */ n((e, t) => {
    if (V_(e.test) || V_(e.include) || V_(e.exclude)) {
      let r = t.name ? `"${t.name}"` : "/* your preset */";
      throw new iKe.default([`Preset ${r} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, {\
 filename: 'file.ts', presets: [${r}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
    }
  }, "validateIfOptionNeedsFilename"), oKe = /* @__PURE__ */ n((e, t, r) => {
    if (!t.filename) {
      var i;
      let {
        options: s
      } = e;
      nz(s, r), (i = s.overrides) == null || i.forEach((a) => nz(a, r));
    }
  }, "validatePreset"), uKe = (0, X_.makeWeakCacheSync)(({
    value: e,
    dirname: t,
    alias: r,
    externalDependencies: i
  }) => ({
    options: (0, z_.validate)("preset", e),
    alias: r,
    dirname: t,
    externalDependencies: i
  }));
  function* lKe(e, t) {
    let r = uKe(yield* nKe(e, t));
    return oKe(r, t, e), {
      chain: yield* (0, eKe.buildPresetChain)(r, t),
      externalDependencies: r.externalDependencies
    };
  }
  n(lKe, "loadPresetDescriptor");
  function W_(e, t) {
    return e ? t ? function(...r) {
      let i = e.apply(this, r);
      return i && typeof i.then == "function" ? i.then(() => t.apply(this, r)) : t.apply(this, r);
    } : e : t;
  }
  n(W_, "chainMaybeAsync");
});

// ../node_modules/@babel/core/lib/config/index.js
var Ec = E((es) => {
  "use strict";
  Object.defineProperty(es, "__esModule", {
    value: !0
  });
  es.createConfigItem = bKe;
  es.createConfigItemAsync = gKe;
  es.createConfigItemSync = mz;
  Object.defineProperty(es, "default", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return dz.default;
    }, "get")
  });
  es.loadOptions = yKe;
  es.loadOptionsAsync = mKe;
  es.loadOptionsSync = hz;
  es.loadPartialConfig = pKe;
  es.loadPartialConfigAsync = dKe;
  es.loadPartialConfigSync = pz;
  function yg() {
    let e = _i();
    return yg = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n(yg, "_gensync");
  var dz = fz(), cKe = $_(), fKe = Op(), Qi = Kn(), pg = yg()(cKe.loadPartialConfig);
  function dKe(...e) {
    return (0, Qi.beginHiddenCallStack)(pg.async)(...e);
  }
  n(dKe, "loadPartialConfigAsync");
  function pz(...e) {
    return (0, Qi.beginHiddenCallStack)(pg.sync)(...e);
  }
  n(pz, "loadPartialConfigSync");
  function pKe(e, t) {
    if (t !== void 0)
      (0, Qi.beginHiddenCallStack)(pg.errback)(e, t);
    else if (typeof e == "function")
      (0, Qi.beginHiddenCallStack)(pg.errback)(void 0, e);
    else
      return pz(e);
  }
  n(pKe, "loadPartialConfig");
  function* hKe(e) {
    var t;
    let r = yield* (0, dz.default)(e);
    return (t = r?.options) != null ? t : null;
  }
  n(hKe, "loadOptionsImpl");
  var hg = yg()(hKe);
  function mKe(...e) {
    return (0, Qi.beginHiddenCallStack)(hg.async)(...e);
  }
  n(mKe, "loadOptionsAsync");
  function hz(...e) {
    return (0, Qi.beginHiddenCallStack)(hg.sync)(...e);
  }
  n(hz, "loadOptionsSync");
  function yKe(e, t) {
    if (t !== void 0)
      (0, Qi.beginHiddenCallStack)(hg.errback)(e, t);
    else if (typeof e == "function")
      (0, Qi.beginHiddenCallStack)(hg.errback)(void 0, e);
    else
      return hz(e);
  }
  n(yKe, "loadOptions");
  var mg = yg()(fKe.createConfigItem);
  function gKe(...e) {
    return (0, Qi.beginHiddenCallStack)(mg.async)(...e);
  }
  n(gKe, "createConfigItemAsync");
  function mz(...e) {
    return (0, Qi.beginHiddenCallStack)(mg.sync)(...e);
  }
  n(mz, "createConfigItemSync");
  function bKe(e, t, r) {
    if (r !== void 0)
      (0, Qi.beginHiddenCallStack)(mg.errback)(e, t, r);
    else if (typeof t == "function")
      (0, Qi.beginHiddenCallStack)(mg.errback)(e, void 0, r);
    else
      return mz(e, t);
  }
  n(bKe, "createConfigItem");
});

// ../node_modules/@babel/core/lib/transformation/plugin-pass.js
var yz = E((gg) => {
  "use strict";
  Object.defineProperty(gg, "__esModule", {
    value: !0
  });
  gg.default = void 0;
  var qp = class {
    static {
      n(this, "PluginPass");
    }
    constructor(t, r, i, s) {
      this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0,
      this.isAsync = void 0, this.key = r, this.file = t, this.opts = i || {}, this.cwd = t.opts.cwd, this.filename = t.opts.filename, this.
      isAsync = s;
    }
    set(t, r) {
      this._map.set(t, r);
    }
    get(t) {
      return this._map.get(t);
    }
    availableHelper(t, r) {
      return this.file.availableHelper(t, r);
    }
    addHelper(t) {
      return this.file.addHelper(t);
    }
    buildCodeFrameError(t, r, i) {
      return this.file.buildCodeFrameError(t, r, i);
    }
  };
  gg.default = qp;
  qp.prototype.getModuleName = /* @__PURE__ */ n(function() {
    return this.file.getModuleName();
  }, "getModuleName"), qp.prototype.addImport = /* @__PURE__ */ n(function() {
    this.file.addImport();
  }, "addImport");
});

// ../node_modules/@babel/core/lib/transformation/block-hoist-plugin.js
var xz = E((G_) => {
  "use strict";
  Object.defineProperty(G_, "__esModule", {
    value: !0
  });
  G_.default = vKe;
  function Dz() {
    let e = ir();
    return Dz = /* @__PURE__ */ n(function() {
      return e;
    }, "_traverse"), e;
  }
  n(Dz, "_traverse");
  var DKe = k1(), Y_, gz = {
    name: "internal.blockHoist",
    visitor: {
      Block: {
        exit({
          node: e
        }) {
          e.body = bz(e.body);
        }
      },
      SwitchCase: {
        exit({
          node: e
        }) {
          e.consequent = bz(e.consequent);
        }
      }
    }
  };
  function bz(e) {
    let t = Math.pow(2, 30) - 1, r = !1;
    for (let i = 0; i < e.length; i++) {
      let s = e[i], a = vz(s);
      if (a > t) {
        r = !0;
        break;
      }
      t = a;
    }
    return r ? xKe(e.slice()) : e;
  }
  n(bz, "performHoisting");
  function vKe() {
    return Y_ || (Y_ = new DKe.default(Object.assign({}, gz, {
      visitor: Dz().default.explode(gz.visitor)
    }), {})), Y_;
  }
  n(vKe, "loadBlockHoistPlugin");
  function vz(e) {
    let t = e?._blockHoist;
    return t == null ? 1 : t === !0 ? 2 : t;
  }
  n(vz, "priority");
  function xKe(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let s = 0; s < e.length; s++) {
      let a = e[s], o = vz(a);
      (t[o] || (t[o] = [])).push(a);
    }
    let r = Object.keys(t).map((s) => +s).sort((s, a) => a - s), i = 0;
    for (let s of r) {
      let a = t[s];
      for (let o of a)
        e[i++] = o;
    }
    return e;
  }
  n(xKe, "stableSort");
});

// ../node_modules/@babel/core/lib/transformation/normalize-opts.js
var Q_ = E((Z_) => {
  "use strict";
  Object.defineProperty(Z_, "__esModule", {
    value: !0
  });
  Z_.default = EKe;
  function bg() {
    let e = require("path");
    return bg = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(bg, "_path");
  function EKe(e) {
    let {
      filename: t,
      cwd: r,
      filenameRelative: i = typeof t == "string" ? bg().relative(r, t) : "unknown",
      sourceType: s = "module",
      inputSourceMap: a,
      sourceMaps: o = !!a,
      sourceRoot: u = e.options.moduleRoot,
      sourceFileName: l = bg().basename(i),
      comments: c = !0,
      compact: f = "auto"
    } = e.options, m = e.options, h = Object.assign({}, m, {
      parserOpts: Object.assign({
        sourceType: bg().extname(i) === ".mjs" ? "module" : s,
        sourceFileName: t,
        plugins: []
      }, m.parserOpts),
      generatorOpts: Object.assign({
        filename: t,
        auxiliaryCommentBefore: m.auxiliaryCommentBefore,
        auxiliaryCommentAfter: m.auxiliaryCommentAfter,
        retainLines: m.retainLines,
        comments: c,
        shouldPrintComment: m.shouldPrintComment,
        compact: f,
        minified: m.minified,
        sourceMaps: !!o,
        sourceRoot: u,
        sourceFileName: l
      }, m.generatorOpts)
    });
    for (let d of e.passes)
      for (let y of d)
        y.manipulateOptions && y.manipulateOptions(h, h.parserOpts);
    return h;
  }
  n(EKe, "normalizeOptions");
});

// ../node_modules/convert-source-map/index.js
var e3 = E((Qt) => {
  "use strict";
  Object.defineProperty(Qt, "commentRegex", {
    get: /* @__PURE__ */ n(function() {
      return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
    }, "getCommentRegex")
  });
  Object.defineProperty(Qt, "mapFileCommentRegex", {
    get: /* @__PURE__ */ n(function() {
      return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
    }, "getMapFileCommentRegex")
  });
  var Dg;
  typeof Buffer < "u" ? typeof Buffer.from == "function" ? Dg = SKe : Dg = TKe : Dg = CKe;
  function SKe(e) {
    return Buffer.from(e, "base64").toString();
  }
  n(SKe, "decodeBase64WithBufferFrom");
  function TKe(e) {
    if (typeof value == "number")
      throw new TypeError("The value to decode must not be of type number.");
    return new Buffer(e, "base64").toString();
  }
  n(TKe, "decodeBase64WithNewBuffer");
  function CKe(e) {
    return decodeURIComponent(escape(atob(e)));
  }
  n(CKe, "decodeBase64WithAtob");
  function wKe(e) {
    return e.split(",").pop();
  }
  n(wKe, "stripComment");
  function AKe(e, t) {
    var r = Qt.mapFileCommentRegex.exec(e), i = r[1] || r[2];
    try {
      var e = t(i);
      return e != null && typeof e.catch == "function" ? e.catch(s) : e;
    } catch (a) {
      s(a);
    }
    function s(a) {
      throw new Error("An error occurred while trying to read the map file at " + i + `
` + a.stack);
    }
    n(s, "throwError");
  }
  n(AKe, "readFromFileMap");
  function Hr(e, t) {
    t = t || {}, t.hasComment && (e = wKe(e)), t.encoding === "base64" ? e = Dg(e) : t.encoding === "uri" && (e = decodeURIComponent(e)), (t.
    isJSON || t.encoding) && (e = JSON.parse(e)), this.sourcemap = e;
  }
  n(Hr, "Converter");
  Hr.prototype.toJSON = function(e) {
    return JSON.stringify(this.sourcemap, null, e);
  };
  typeof Buffer < "u" ? typeof Buffer.from == "function" ? Hr.prototype.toBase64 = _Ke : Hr.prototype.toBase64 = PKe : Hr.prototype.toBase64 =
  FKe;
  function _Ke() {
    var e = this.toJSON();
    return Buffer.from(e, "utf8").toString("base64");
  }
  n(_Ke, "encodeBase64WithBufferFrom");
  function PKe() {
    var e = this.toJSON();
    if (typeof e == "number")
      throw new TypeError("The json to encode must not be of type number.");
    return new Buffer(e, "utf8").toString("base64");
  }
  n(PKe, "encodeBase64WithNewBuffer");
  function FKe() {
    var e = this.toJSON();
    return btoa(unescape(encodeURIComponent(e)));
  }
  n(FKe, "encodeBase64WithBtoa");
  Hr.prototype.toURI = function() {
    var e = this.toJSON();
    return encodeURIComponent(e);
  };
  Hr.prototype.toComment = function(e) {
    var t, r, i;
    return e != null && e.encoding === "uri" ? (t = "", r = this.toURI()) : (t = ";base64", r = this.toBase64()), i = "sourceMappingURL=data\
:application/json;charset=utf-8" + t + "," + r, e != null && e.multiline ? "/*# " + i + " */" : "//# " + i;
  };
  Hr.prototype.toObject = function() {
    return JSON.parse(this.toJSON());
  };
  Hr.prototype.addProperty = function(e, t) {
    if (this.sourcemap.hasOwnProperty(e)) throw new Error('property "' + e + '" already exists on the sourcemap, use set property instead');
    return this.setProperty(e, t);
  };
  Hr.prototype.setProperty = function(e, t) {
    return this.sourcemap[e] = t, this;
  };
  Hr.prototype.getProperty = function(e) {
    return this.sourcemap[e];
  };
  Qt.fromObject = function(e) {
    return new Hr(e);
  };
  Qt.fromJSON = function(e) {
    return new Hr(e, { isJSON: !0 });
  };
  Qt.fromURI = function(e) {
    return new Hr(e, { encoding: "uri" });
  };
  Qt.fromBase64 = function(e) {
    return new Hr(e, { encoding: "base64" });
  };
  Qt.fromComment = function(e) {
    var t, r;
    return e = e.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), t = Qt.commentRegex.exec(e), r = t && t[4] || "uri", new Hr(e, { encoding: r,
    hasComment: !0 });
  };
  function Ez(e) {
    return new Hr(e, { isJSON: !0 });
  }
  n(Ez, "makeConverter");
  Qt.fromMapFileComment = function(e, t) {
    if (typeof t == "string")
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://githu\
b.com/thlorenz/convert-source-map#upgrading"
      );
    var r = AKe(e, t);
    return r != null && typeof r.then == "function" ? r.then(Ez) : Ez(r);
  };
  Qt.fromSource = function(e) {
    var t = e.match(Qt.commentRegex);
    return t ? Qt.fromComment(t.pop()) : null;
  };
  Qt.fromMapFileSource = function(e, t) {
    if (typeof t == "string")
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github\
.com/thlorenz/convert-source-map#upgrading"
      );
    var r = e.match(Qt.mapFileCommentRegex);
    return r ? Qt.fromMapFileComment(r.pop(), t) : null;
  };
  Qt.removeComments = function(e) {
    return e.replace(Qt.commentRegex, "");
  };
  Qt.removeMapFileComments = function(e) {
    return e.replace(Qt.mapFileCommentRegex, "");
  };
  Qt.generateMapFileComment = function(e, t) {
    var r = "sourceMappingURL=" + e;
    return t && t.multiline ? "/*# " + r + " */" : "//# " + r;
  };
});

// ../node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js
var Cz = E((t3) => {
  "use strict";
  Object.defineProperty(t3, "__esModule", {
    value: !0
  });
  t3.default = IKe;
  var Tz = {
    asyncDoExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-async-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
      }
    },
    decimal: {
      syntax: {
        name: "@babel/plugin-syntax-decimal",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
      }
    },
    decorators: {
      syntax: {
        name: "@babel/plugin-syntax-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
      },
      transform: {
        name: "@babel/plugin-proposal-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
      }
    },
    doExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
      }
    },
    exportDefaultFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
      },
      transform: {
        name: "@babel/plugin-proposal-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
      }
    },
    flow: {
      syntax: {
        name: "@babel/plugin-syntax-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
      },
      transform: {
        name: "@babel/preset-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
      }
    },
    functionBind: {
      syntax: {
        name: "@babel/plugin-syntax-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
      },
      transform: {
        name: "@babel/plugin-proposal-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
      }
    },
    functionSent: {
      syntax: {
        name: "@babel/plugin-syntax-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
      },
      transform: {
        name: "@babel/plugin-proposal-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
      }
    },
    jsx: {
      syntax: {
        name: "@babel/plugin-syntax-jsx",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
      },
      transform: {
        name: "@babel/preset-react",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
      }
    },
    pipelineOperator: {
      syntax: {
        name: "@babel/plugin-syntax-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
      },
      transform: {
        name: "@babel/plugin-proposal-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
      }
    },
    recordAndTuple: {
      syntax: {
        name: "@babel/plugin-syntax-record-and-tuple",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
      }
    },
    throwExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
      }
    },
    typescript: {
      syntax: {
        name: "@babel/plugin-syntax-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
      },
      transform: {
        name: "@babel/preset-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
      }
    }
  };
  Object.assign(Tz, {
    asyncGenerators: {
      syntax: {
        name: "@babel/plugin-syntax-async-generators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
      },
      transform: {
        name: "@babel/plugin-transform-async-generator-functions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
      }
    },
    classProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
      }
    },
    classPrivateProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
      }
    },
    classPrivateMethods: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-private-methods",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
      }
    },
    classStaticBlock: {
      syntax: {
        name: "@babel/plugin-syntax-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
      },
      transform: {
        name: "@babel/plugin-transform-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
      }
    },
    dynamicImport: {
      syntax: {
        name: "@babel/plugin-syntax-dynamic-import",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
      }
    },
    exportNamespaceFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
      },
      transform: {
        name: "@babel/plugin-transform-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
      }
    },
    importAssertions: {
      syntax: {
        name: "@babel/plugin-syntax-import-assertions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
      }
    },
    importAttributes: {
      syntax: {
        name: "@babel/plugin-syntax-import-attributes",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
      }
    },
    importMeta: {
      syntax: {
        name: "@babel/plugin-syntax-import-meta",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
      }
    },
    logicalAssignment: {
      syntax: {
        name: "@babel/plugin-syntax-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
      },
      transform: {
        name: "@babel/plugin-transform-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
      }
    },
    moduleStringNames: {
      syntax: {
        name: "@babel/plugin-syntax-module-string-names",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
      }
    },
    numericSeparator: {
      syntax: {
        name: "@babel/plugin-syntax-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
      },
      transform: {
        name: "@babel/plugin-transform-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
      }
    },
    nullishCoalescingOperator: {
      syntax: {
        name: "@babel/plugin-syntax-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
      },
      transform: {
        name: "@babel/plugin-transform-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
      }
    },
    objectRestSpread: {
      syntax: {
        name: "@babel/plugin-syntax-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
      },
      transform: {
        name: "@babel/plugin-transform-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
      }
    },
    optionalCatchBinding: {
      syntax: {
        name: "@babel/plugin-syntax-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
      },
      transform: {
        name: "@babel/plugin-transform-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
      }
    },
    optionalChaining: {
      syntax: {
        name: "@babel/plugin-syntax-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
      },
      transform: {
        name: "@babel/plugin-transform-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
      }
    },
    privateIn: {
      syntax: {
        name: "@babel/plugin-syntax-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
      },
      transform: {
        name: "@babel/plugin-transform-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
      }
    },
    regexpUnicodeSets: {
      syntax: {
        name: "@babel/plugin-syntax-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
      },
      transform: {
        name: "@babel/plugin-transform-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
      }
    }
  });
  var Sz = /* @__PURE__ */ n(({
    name: e,
    url: t
  }) => `${e} (${t})`, "getNameURLCombination");
  function IKe(e, t, r, i) {
    let s = `Support for the experimental syntax '${e}' isn't currently enabled (${t.line}:${t.column + 1}):

` + r, a = Tz[e];
    if (a) {
      let {
        syntax: u,
        transform: l
      } = a;
      if (u) {
        let c = Sz(u);
        if (l) {
          let f = Sz(l), m = l.name.startsWith("@babel/plugin") ? "plugins" : "presets";
          s += `

Add ${f} to the '${m}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${c} to the 'plugins' section to enable parsing.`;
        } else
          s += `

Add ${c} to the 'plugins' section of your Babel config to enable parsing.`;
      }
    }
    return s += `

If you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${i === "unknown" ? "<name of the input file>" : i} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.
`, s;
  }
  n(IKe, "generateMissingPluginMessage");
});

// ../node_modules/@babel/core/lib/parser/index.js
var s3 = E((i3) => {
  "use strict";
  Object.defineProperty(i3, "__esModule", {
    value: !0
  });
  i3.default = kKe;
  function r3() {
    let e = Ho();
    return r3 = /* @__PURE__ */ n(function() {
      return e;
    }, "_parser"), e;
  }
  n(r3, "_parser");
  function wz() {
    let e = Wd();
    return wz = /* @__PURE__ */ n(function() {
      return e;
    }, "_codeFrame"), e;
  }
  n(wz, "_codeFrame");
  var OKe = Cz();
  function* kKe(e, {
    parserOpts: t,
    highlightCode: r = !0,
    filename: i = "unknown"
  }, s) {
    try {
      let a = [];
      for (let o of e)
        for (let u of o) {
          let {
            parserOverride: l
          } = u;
          if (l) {
            let c = l(s, t, r3().parse);
            c !== void 0 && a.push(c);
          }
        }
      if (a.length === 0)
        return (0, r3().parse)(s, t);
      if (a.length === 1) {
        if (yield* [], typeof a[0].then == "function")
          throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're us\
ing a published plugin, you may need to upgrade your @babel/core version.");
        return a[0];
      }
      throw new Error("More than one plugin attempted to override parsing.");
    } catch (a) {
      a.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (a.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
      let {
        loc: o,
        missingPlugin: u
      } = a;
      if (o) {
        let l = (0, wz().codeFrameColumns)(s, {
          start: {
            line: o.line,
            column: o.column + 1
          }
        }, {
          highlightCode: r
        });
        u ? a.message = `${i}: ` + (0, OKe.default)(u[0], o, l, i) : a.message = `${i}: ${a.message}

` + l, a.code = "BABEL_PARSE_ERROR";
      }
      throw a;
    }
  }
  n(kKe, "parser");
});

// ../node_modules/@babel/core/lib/transformation/util/clone-deep.js
var Az = E((o3) => {
  "use strict";
  Object.defineProperty(o3, "__esModule", {
    value: !0
  });
  o3.default = BKe;
  var vg = /* @__PURE__ */ new Set(), n3 = 0;
  function a3(e, t, r) {
    if (e !== null) {
      if (r) {
        if (t.has(e)) return t.get(e);
      } else if (++n3 > 250) {
        if (vg.has(e))
          throw n3 = 0, vg.clear(), new Error("Babel-deepClone: Cycles are not allowed in AST");
        vg.add(e);
      }
      let i;
      if (Array.isArray(e)) {
        i = new Array(e.length), r && t.set(e, i);
        for (let s = 0; s < e.length; s++)
          i[s] = typeof e[s] != "object" ? e[s] : a3(e[s], t, r);
      } else {
        i = {}, r && t.set(e, i);
        let s = Object.keys(e);
        for (let a = 0; a < s.length; a++) {
          let o = s[a];
          i[o] = typeof e[o] != "object" ? e[o] : a3(e[o], t, r || o === "leadingComments" || o === "innerComments" || o === "trailingCommen\
ts" || o === "extra");
        }
      }
      return r || n3-- > 250 && vg.delete(e), i;
    }
    return e;
  }
  n(a3, "deepClone");
  function BKe(e) {
    if (typeof e != "object") return e;
    try {
      return a3(e, /* @__PURE__ */ new Map(), !0);
    } catch {
      return structuredClone(e);
    }
  }
  n(BKe, "_default");
});

// ../node_modules/@babel/core/lib/transformation/normalize-file.js
var kz = E((f3) => {
  "use strict";
  Object.defineProperty(f3, "__esModule", {
    value: !0
  });
  f3.default = UKe;
  function Fz() {
    let e = require("fs");
    return Fz = /* @__PURE__ */ n(function() {
      return e;
    }, "_fs"), e;
  }
  n(Fz, "_fs");
  function c3() {
    let e = require("path");
    return c3 = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(c3, "_path");
  function Iz() {
    let e = zo();
    return Iz = /* @__PURE__ */ n(function() {
      return e;
    }, "_debug"), e;
  }
  n(Iz, "_debug");
  function Oz() {
    let e = Pe();
    return Oz = /* @__PURE__ */ n(function() {
      return e;
    }, "_t"), e;
  }
  n(Oz, "_t");
  function xg() {
    let e = e3();
    return xg = /* @__PURE__ */ n(function() {
      return e;
    }, "_convertSourceMap"), e;
  }
  n(xg, "_convertSourceMap");
  var NKe = aA(), MKe = s3(), RKe = Az(), {
    file: LKe,
    traverseFast: jKe
  } = Oz(), u3 = Iz()("babel:transform:file"), qKe = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,.*$/,
  _z = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
  function* UKe(e, t, r, i) {
    if (r = `${r || ""}`, i) {
      if (i.type === "Program")
        i = LKe(i, [], []);
      else if (i.type !== "File")
        throw new Error("AST root must be a Program or File node");
      t.cloneInputAst && (i = (0, RKe.default)(i));
    } else
      i = yield* (0, MKe.default)(e, t, r);
    let s = null;
    if (t.inputSourceMap !== !1) {
      if (typeof t.inputSourceMap == "object" && (s = xg().fromObject(t.inputSourceMap)), !s) {
        let a = Pz(qKe, i);
        if (a)
          try {
            s = xg().fromComment("//" + a);
          } catch {
            u3("discarding unknown inline input sourcemap");
          }
      }
      if (!s) {
        let a = Pz(_z, i);
        if (typeof t.filename == "string" && a)
          try {
            let o = _z.exec(a), u = Fz().readFileSync(c3().resolve(c3().dirname(t.filename), o[1]), "utf8");
            s = xg().fromJSON(u);
          } catch (o) {
            u3("discarding unknown file input sourcemap", o);
          }
        else a && u3("discarding un-loadable file input sourcemap");
      }
    }
    return new NKe.default(t, {
      code: r,
      ast: i,
      inputMap: s
    });
  }
  n(UKe, "normalizeFile");
  function l3(e, t, r) {
    return t && (t = t.filter(({
      value: i
    }) => e.test(i) ? (r = i, !1) : !0)), [t, r];
  }
  n(l3, "extractCommentsFromList");
  function Pz(e, t) {
    let r = null;
    return jKe(t, (i) => {
      [i.leadingComments, r] = l3(e, i.leadingComments, r), [i.innerComments, r] = l3(e, i.innerComments, r), [i.trailingComments, r] = l3(e,
      i.trailingComments, r);
    }), r;
  }
  n(Pz, "extractComments");
});

// ../node_modules/@jridgewell/remapping/dist/remapping.mjs
var qz = {};
hh(qz, {
  default: () => JKe
});
function Nz(e, t, r, i, s, a) {
  return { source: e, line: t, column: r, name: i, content: s, ignore: a };
}
function Mz(e, t, r, i, s) {
  return {
    map: e,
    sources: t,
    source: r,
    content: i,
    ignore: s
  };
}
function Rz(e, t) {
  return Mz(e, t, "", null, !1);
}
function VKe(e, t, r) {
  return Mz(null, $Ke, e, t, r);
}
function WKe(e) {
  let t = new Cy({ file: e.map.file }), { sources: r, map: i } = e, s = i.names, a = bs(i);
  for (let o = 0; o < a.length; o++) {
    let u = a[o];
    for (let l = 0; l < u.length; l++) {
      let c = u[l], f = c[0], m = Bz;
      if (c.length !== 1) {
        let D = r[c[1]];
        if (m = Lz(
          D,
          c[2],
          c[3],
          c.length === 5 ? s[c[4]] : ""
        ), m == null) continue;
      }
      let { column: h, line: d, name: y, content: p, source: g, ignore: b } = m;
      kC(t, o, f, g, d, h, y), g && p != null && BC(t, g, p), b && NC(t, g, !0);
    }
  }
  return t;
}
function Lz(e, t, r, i) {
  if (!e.map)
    return Nz(e.source, t, r, i, e.content, e.ignore);
  let s = PC(e.map, t, r);
  return s == null ? null : s.length === 1 ? Bz : Lz(
    e.sources[s[1]],
    s[2],
    s[3],
    s.length === 5 ? e.map.names[s[4]] : i
  );
}
function HKe(e) {
  return Array.isArray(e) ? e : [e];
}
function KKe(e, t) {
  let r = HKe(e).map((a) => new Ln(a, "")), i = r.pop();
  for (let a = 0; a < r.length; a++)
    if (r[a].sources.length > 1)
      throw new Error(
        `Transformation map ${a} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`
      );
  let s = jz(i, t, "", 0);
  for (let a = r.length - 1; a >= 0; a--)
    s = Rz(r[a], [s]);
  return s;
}
function jz(e, t, r, i) {
  let { resolvedSources: s, sourcesContent: a, ignoreList: o } = e, u = i + 1, l = s.map((c, f) => {
    let m = {
      importer: r,
      depth: u,
      source: c || "",
      content: void 0,
      ignore: void 0
    }, h = t(m.source, m), { source: d, content: y, ignore: p } = m;
    if (h) return jz(new Ln(h, d), t, d, u);
    let g = y !== void 0 ? y : a ? a[f] : null, b = p !== void 0 ? p : o ? o.includes(f) : !1;
    return VKe(d, g, b);
  });
  return Rz(e, l);
}
function JKe(e, t, r) {
  let i = typeof r == "object" ? r : { excludeContent: !!r, decodedMappings: !1 }, s = KKe(e, t);
  return new zKe(WKe(s), i);
}
var Bz, $Ke, zKe, Uz = ph(() => {
  tp();
  Ay();
  tp();
  Ay();
  Bz = /* @__PURE__ */ Nz("", -1, -1, "", null, !1), $Ke = [];
  n(Nz, "SegmentObject");
  n(Mz, "Source");
  n(Rz, "MapSource");
  n(VKe, "OriginalSource");
  n(WKe, "traceMappings");
  n(Lz, "originalPositionFor");
  n(HKe, "asArray");
  n(KKe, "buildSourceMapTree");
  n(jz, "build");
  zKe = class {
    static {
      n(this, "SourceMap");
    }
    constructor(e, t) {
      let r = t.decodedMappings ? wy(e) : MC(e);
      this.version = r.version, this.file = r.file, this.mappings = r.mappings, this.names = r.names, this.ignoreList = r.ignoreList, this.sourceRoot =
      r.sourceRoot, this.sources = r.sources, t.excludeContent || (this.sourcesContent = r.sourcesContent);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  n(JKe, "remapping");
});

// ../node_modules/@babel/core/lib/transformation/file/merge-map.js
var Wz = E((d3) => {
  "use strict";
  Object.defineProperty(d3, "__esModule", {
    value: !0
  });
  d3.default = XKe;
  function Vz() {
    let e = (Uz(), mh(qz));
    return Vz = /* @__PURE__ */ n(function() {
      return e;
    }, "_remapping"), e;
  }
  n(Vz, "_remapping");
  function XKe(e, t, r) {
    let i = r.replace(/\\/g, "/"), s = !1, a = Vz()($z(t), (o, u) => o === i && !s ? (s = !0, u.source = "", $z(e)) : null);
    return typeof e.sourceRoot == "string" && (a.sourceRoot = e.sourceRoot), Object.assign({}, a);
  }
  n(XKe, "mergeSourceMap");
  function $z(e) {
    return Object.assign({}, e, {
      sourceRoot: null
    });
  }
  n($z, "rootless");
});

// ../node_modules/@babel/core/lib/transformation/file/generate.js
var Kz = E((h3) => {
  "use strict";
  Object.defineProperty(h3, "__esModule", {
    value: !0
  });
  h3.default = GKe;
  function Hz() {
    let e = e3();
    return Hz = /* @__PURE__ */ n(function() {
      return e;
    }, "_convertSourceMap"), e;
  }
  n(Hz, "_convertSourceMap");
  function p3() {
    let e = op();
    return p3 = /* @__PURE__ */ n(function() {
      return e;
    }, "_generator"), e;
  }
  n(p3, "_generator");
  var YKe = Wz();
  function GKe(e, t) {
    let {
      opts: r,
      ast: i,
      code: s,
      inputMap: a
    } = t, {
      generatorOpts: o
    } = r;
    o.inputSourceMap = a?.toObject();
    let u = [];
    for (let m of e)
      for (let h of m) {
        let {
          generatorOverride: d
        } = h;
        if (d) {
          let y = d(i, o, s, p3().default);
          y !== void 0 && u.push(y);
        }
      }
    let l;
    if (u.length === 0)
      l = (0, p3().default)(i, o, s);
    else if (u.length === 1) {
      if (l = u[0], typeof l.then == "function")
        throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're usi\
ng a published plugin, you may need to upgrade your @babel/core version.");
    } else
      throw new Error("More than one plugin attempted to override codegen.");
    let {
      code: c,
      decodedMap: f = l.map
    } = l;
    return l.__mergedMap ? f = Object.assign({}, l.map) : f && (a ? f = (0, YKe.default)(a.toObject(), f, o.sourceFileName) : f = l.map), (r.
    sourceMaps === "inline" || r.sourceMaps === "both") && (c += `
` + Hz().fromObject(f).toComment()), r.sourceMaps === "inline" && (f = null), {
      outputCode: c,
      outputMap: f
    };
  }
  n(GKe, "generateCode");
});

// ../node_modules/@babel/core/lib/transformation/index.js
var Eg = E((g3) => {
  "use strict";
  Object.defineProperty(g3, "__esModule", {
    value: !0
  });
  g3.run = sze;
  function y3() {
    let e = ir();
    return y3 = /* @__PURE__ */ n(function() {
      return e;
    }, "_traverse"), e;
  }
  n(y3, "_traverse");
  var ZKe = yz(), QKe = xz(), eze = Q_(), tze = kz(), rze = Kz(), ize = I1(), m3 = Ka();
  function* sze(e, t, r) {
    let i = yield* (0, tze.default)(e.passes, (0, eze.default)(e), t, r), s = i.opts;
    try {
      yield* nze(i, e.passes);
    } catch (c) {
      var a;
      throw c.message = `${(a = s.filename) != null ? a : "unknown file"}: ${c.message}`, c.code || (c.code = "BABEL_TRANSFORM_ERROR"), c;
    }
    let o, u;
    try {
      s.code !== !1 && ({
        outputCode: o,
        outputMap: u
      } = (0, rze.default)(e.passes, i));
    } catch (c) {
      var l;
      throw c.message = `${(l = s.filename) != null ? l : "unknown file"}: ${c.message}`, c.code || (c.code = "BABEL_GENERATE_ERROR"), c;
    }
    return {
      metadata: i.metadata,
      options: s,
      ast: s.ast === !0 ? i.ast : null,
      code: o === void 0 ? null : o,
      map: u === void 0 ? null : u,
      sourceType: i.ast.program.sourceType,
      externalDependencies: (0, ize.flattenToSet)(e.externalDependencies)
    };
  }
  n(sze, "run");
  function* nze(e, t) {
    let r = yield* (0, m3.isAsync)();
    for (let i of t) {
      let s = [], a = [], o = [];
      for (let l of i.concat([(0, QKe.default)()])) {
        let c = new ZKe.default(e, l.key, l.options, r);
        s.push([l, c]), a.push(c), o.push(l.visitor);
      }
      for (let [l, c] of s)
        l.pre && (yield* (0, m3.maybeAsync)(l.pre, "You appear to be using an async plugin/preset, but Babel has been called synchronously").
        call(c, e));
      let u = y3().default.visitors.merge(o, a, e.opts.wrapPluginVisitorMethod);
      (0, y3().default)(e.ast, u, e.scope);
      for (let [l, c] of s)
        l.post && (yield* (0, m3.maybeAsync)(l.post, "You appear to be using an async plugin/preset, but Babel has been called synchronously").
        call(c, e));
    }
  }
  n(nze, "transformFile");
});

// ../node_modules/@babel/core/lib/transform-file.js
var D3 = E((Up) => {
  "use strict";
  Object.defineProperty(Up, "__esModule", {
    value: !0
  });
  Up.transformFile = lze;
  Up.transformFileAsync = fze;
  Up.transformFileSync = cze;
  function zz() {
    let e = _i();
    return zz = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n(zz, "_gensync");
  var aze = Ec(), oze = Eg(), uze = x1(), b3 = zz()(function* (e, t) {
    let r = Object.assign({}, t, {
      filename: e
    }), i = yield* (0, aze.default)(r);
    if (i === null) return null;
    let s = yield* uze.readFile(e, "utf8");
    return yield* (0, oze.run)(i, s);
  });
  function lze(...e) {
    b3.errback(...e);
  }
  n(lze, "transformFile");
  function cze(...e) {
    return b3.sync(...e);
  }
  n(cze, "transformFileSync");
  function fze(...e) {
    return b3.async(...e);
  }
  n(fze, "transformFileAsync");
});

// ../node_modules/@babel/core/lib/config/files/import.cjs
var Xz = E((Kvt, Jz) => {
  Jz.exports = /* @__PURE__ */ n(function(t) {
    return import(t);
  }, "import_");
});

// ../node_modules/@babel/preset-typescript/package.json
var Yz = E((Jvt, dze) => {
  dze.exports = {
    name: "@babel/preset-typescript",
    version: "7.27.0",
    description: "Babel preset for TypeScript.",
    repository: {
      type: "git",
      url: "https://github.com/babel/babel.git",
      directory: "packages/babel-preset-typescript"
    },
    license: "MIT",
    publishConfig: {
      access: "public"
    },
    main: "./lib/index.js",
    keywords: [
      "babel-preset",
      "typescript"
    ],
    dependencies: {
      "@babel/helper-plugin-utils": "^7.26.5",
      "@babel/helper-validator-option": "^7.25.9",
      "@babel/plugin-syntax-jsx": "^7.25.9",
      "@babel/plugin-transform-modules-commonjs": "^7.26.3",
      "@babel/plugin-transform-typescript": "^7.27.0"
    },
    peerDependencies: {
      "@babel/core": "^7.0.0-0"
    },
    devDependencies: {
      "@babel/core": "^7.26.10",
      "@babel/helper-plugin-test-runner": "^7.25.9"
    },
    homepage: "https://babel.dev/docs/en/next/babel-preset-typescript",
    bugs: "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen",
    engines: {
      node: ">=6.9.0"
    },
    author: "The Babel Team (https://babel.dev/team)",
    type: "commonjs"
  };
});

// ../node_modules/@babel/helper-plugin-utils/lib/index.js
var Sc = E(($p) => {
  "use strict";
  Object.defineProperty($p, "__esModule", {
    value: !0
  });
  $p.declare = Gz;
  $p.declarePreset = void 0;
  var v3 = {
    assertVersion: /* @__PURE__ */ n((e) => (t) => {
      hze(t, e.version);
    }, "assertVersion")
  };
  Object.assign(v3, {
    targets: /* @__PURE__ */ n(() => () => ({}), "targets"),
    assumption: /* @__PURE__ */ n(() => () => {
    }, "assumption"),
    addExternalDependency: /* @__PURE__ */ n(() => () => {
    }, "addExternalDependency")
  });
  function Gz(e) {
    return (t, r, i) => {
      let s;
      for (let a of Object.keys(v3))
        t[a] || (s ?? (s = pze(t)), s[a] = v3[a](s));
      return e(s ?? t, r || {}, i);
    };
  }
  n(Gz, "declare");
  var Xvt = $p.declarePreset = Gz;
  function pze(e) {
    let t = null;
    return typeof e.version == "string" && /^7\./.test(e.version) && (t = Object.getPrototypeOf(e), t && (!hasOwnProperty.call(t, "version") ||
    !hasOwnProperty.call(t, "transform") || !hasOwnProperty.call(t, "template") || !hasOwnProperty.call(t, "types")) && (t = null)), Object.
    assign({}, t, e);
  }
  n(pze, "copyApiObject");
  function hze(e, t) {
    if (typeof e == "number") {
      if (!Number.isInteger(e))
        throw new Error("Expected string or integer value.");
      e = `^${e}.0.0-0`;
    }
    if (typeof e != "string")
      throw new Error("Expected string or integer value.");
    let r = Error.stackTraceLimit;
    typeof r == "number" && r < 25 && (Error.stackTraceLimit = 25);
    let i;
    throw t.slice(0, 2) === "7." ? i = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t}". You'll need to update your @b\
abel/core version.`) : i = new Error(`Requires Babel "${e}", but was loaded with "${t}". If you are sure you have a compatible version of @b\
abel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for\
 the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof r == "number" && (Error.stackTraceLimit =
    r), Object.assign(i, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: t,
      range: e
    });
  }
  n(hze, "throwVersionError");
});

// ../node_modules/@babel/plugin-syntax-typescript/lib/index.js
var Zz = E((Sg) => {
  "use strict";
  Object.defineProperty(Sg, "__esModule", {
    value: !0
  });
  Sg.default = void 0;
  var mze = Sc();
  x3 = /* @__PURE__ */ n(function(e, t) {
    let r = [];
    e.forEach((i, s) => {
      (Array.isArray(i) ? i[0] : i) === t && r.unshift(s);
    });
    for (let i of r)
      e.splice(i, 1);
  }, "removePlugin");
  var x3, Zvt = Sg.default = (0, mze.declare)((e, t) => {
    e.assertVersion(7);
    let {
      disallowAmbiguousJSXLike: r,
      dts: i
    } = t;
    var {
      isTSX: s
    } = t;
    return {
      name: "syntax-typescript",
      manipulateOptions(a, o) {
        {
          let {
            plugins: u
          } = o;
          x3(u, "flow"), x3(u, "jsx"), u.push("objectRestSpread", "classProperties"), s && u.push("jsx");
        }
        o.plugins.push(["typescript", {
          disallowAmbiguousJSXLike: r,
          dts: i
        }]);
      }
    };
  });
});

// ../node_modules/@babel/helper-member-expression-to-functions/lib/index.js
var w3 = E((C3) => {
  "use strict";
  Object.defineProperty(C3, "__esModule", { value: !0 });
  var yze = Pe();
  function gze(e) {
    if (e && e.__esModule) return e;
    var t = /* @__PURE__ */ Object.create(null);
    return e && Object.keys(e).forEach(function(r) {
      if (r !== "default") {
        var i = Object.getOwnPropertyDescriptor(e, r);
        Object.defineProperty(t, r, i.get ? i : {
          enumerable: !0,
          get: /* @__PURE__ */ n(function() {
            return e[r];
          }, "get")
        });
      }
    }), t.default = e, Object.freeze(t);
  }
  n(gze, "_interopNamespace");
  var bze = /* @__PURE__ */ gze(yze);
  function S3(e) {
    let t = e, {
      node: r,
      parentPath: i
    } = t;
    if (i.isLogicalExpression()) {
      let {
        operator: s,
        right: a
      } = i.node;
      if (s === "&&" || s === "||" || s === "??" && r === a)
        return S3(i);
    }
    if (i.isSequenceExpression()) {
      let {
        expressions: s
      } = i.node;
      return s[s.length - 1] === r ? S3(i) : !0;
    }
    return i.isConditional({
      test: r
    }) || i.isUnaryExpression({
      operator: "!"
    }) || i.isLoop({
      test: r
    });
  }
  n(S3, "willPathCastToBoolean");
  var {
    LOGICAL_OPERATORS: Dze,
    arrowFunctionExpression: Qz,
    assignmentExpression: Tc,
    binaryExpression: Du,
    booleanLiteral: vze,
    callExpression: wg,
    cloneNode: ts,
    conditionalExpression: xze,
    identifier: sJ,
    isMemberExpression: Eze,
    isOptionalCallExpression: Sze,
    isOptionalMemberExpression: nJ,
    isUpdateExpression: Tze,
    logicalExpression: Cg,
    memberExpression: eJ,
    nullLiteral: Tg,
    optionalCallExpression: Cze,
    optionalMemberExpression: wze,
    sequenceExpression: E3,
    updateExpression: tJ
  } = bze, T3 = class {
    static {
      n(this, "AssignmentMemoiser");
    }
    constructor() {
      this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
    }
    has(t) {
      return this._map.has(t);
    }
    get(t) {
      if (!this.has(t)) return;
      let r = this._map.get(t), {
        value: i
      } = r;
      return r.count--, r.count === 0 ? Tc("=", i, t) : i;
    }
    set(t, r, i) {
      return this._map.set(t, {
        count: i,
        value: r
      });
    }
  };
  function rJ(e, t) {
    let {
      node: r
    } = e;
    if (nJ(r))
      return eJ(t, r.property, r.computed);
    if (e.isOptionalCallExpression()) {
      let i = e.get("callee");
      if (e.node.optional && i.isOptionalMemberExpression()) {
        let s = i.node.object, a = e.scope.maybeGenerateMemoised(s);
        return i.get("object").replaceWith(Tc("=", a, s)), wg(eJ(t, sJ("call")), [a, ...e.node.arguments]);
      }
      return wg(t, e.node.arguments);
    }
    return e.node;
  }
  n(rJ, "toNonOptional");
  function Aze(e) {
    for (; e && !e.isProgram(); ) {
      let {
        parentPath: t,
        container: r,
        listKey: i
      } = e, s = t.node;
      if (i) {
        if (r !== s[i])
          return !0;
      } else if (r !== s) return !0;
      e = t;
    }
    return !1;
  }
  n(Aze, "isInDetachedTree");
  var _ze = {
    memoise() {
    },
    handle(e, t) {
      let {
        node: r,
        parent: i,
        parentPath: s,
        scope: a
      } = e;
      if (e.isOptionalMemberExpression()) {
        if (Aze(e)) return;
        let o = e.find(({
          node: k,
          parent: q
        }) => nJ(q) ? q.optional || q.object !== k : Sze(q) ? k !== e.node && q.optional || q.callee !== k : !0);
        if (a.path.isPattern()) {
          o.replaceWith(wg(Qz([], o.node), []));
          return;
        }
        let u = S3(o), l = o.parentPath;
        if (l.isUpdateExpression({
          argument: r
        }))
          throw e.buildCodeFrameError("can't handle update expression");
        let c = l.isAssignmentExpression({
          left: o.node
        }), f = l.isUnaryExpression({
          operator: "delete"
        });
        if (f && o.isOptionalMemberExpression() && o.get("property").isPrivateName())
          throw e.buildCodeFrameError("can't delete a private class element");
        let m = e;
        for (; ; ) {
          if (m.isOptionalMemberExpression()) {
            if (m.node.optional) break;
            m = m.get("object");
            continue;
          } else if (m.isOptionalCallExpression()) {
            if (m.node.optional) break;
            m = m.get("callee");
            continue;
          }
          throw new Error(`Internal error: unexpected ${m.node.type}`);
        }
        let h = m.isOptionalMemberExpression() ? m.node.object : m.node.callee, d = a.maybeGenerateMemoised(h), y = d ?? h, p = s.isOptionalCallExpression(
        {
          callee: r
        }), g = /* @__PURE__ */ n((k) => p, "isOptionalCall"), b = s.isCallExpression({
          callee: r
        });
        m.replaceWith(rJ(m, y)), g() ? i.optional ? s.replaceWith(this.optionalCall(e, i.arguments)) : s.replaceWith(this.call(e, i.arguments)) :
        b ? e.replaceWith(this.boundGet(e)) : this.delete && s.isUnaryExpression({
          operator: "delete"
        }) ? s.replaceWith(this.delete(e)) : s.isAssignmentExpression() ? iJ(this, e, s) : e.replaceWith(this.get(e));
        let D = e.node;
        for (let k = e; k !== o; ) {
          let q = k.parentPath;
          if (q === o && g() && i.optional) {
            D = q.node;
            break;
          }
          D = rJ(q, D), k = q;
        }
        let x, T = o.parentPath;
        if (Eze(D) && T.isOptionalCallExpression({
          callee: o.node,
          optional: !0
        })) {
          let {
            object: k
          } = D;
          x = e.scope.maybeGenerateMemoised(k), x && (D.object = Tc("=", x, k));
        }
        let w = o;
        (f || c) && (w = T, D = T.node);
        let B = d ? Tc("=", ts(y), ts(h)) : ts(y);
        if (u) {
          let k;
          t ? k = Du("!=", B, Tg()) : k = Cg("&&", Du("!==", B, Tg()), Du("!==", ts(y), a.buildUndefinedNode())), w.replaceWith(Cg("&&", k, D));
        } else {
          let k;
          t ? k = Du("==", B, Tg()) : k = Cg("||", Du("===", B, Tg()), Du("===", ts(y), a.buildUndefinedNode())), w.replaceWith(xze(k, f ? vze(
          !0) : a.buildUndefinedNode(), D));
        }
        if (x) {
          let k = T.node;
          T.replaceWith(Cze(wze(k.callee, sJ("call"), !1, !0), [ts(x), ...k.arguments], !1));
        }
        return;
      }
      if (Tze(i, {
        argument: r
      })) {
        if (this.simpleSet) {
          e.replaceWith(this.simpleSet(e));
          return;
        }
        let {
          operator: o,
          prefix: u
        } = i;
        this.memoise(e, 2);
        let l = a.generateUidIdentifierBasedOnNode(r);
        a.push({
          id: l
        });
        let c = [Tc("=", ts(l), this.get(e))];
        if (u) {
          c.push(tJ(o, ts(l), u));
          let f = E3(c);
          s.replaceWith(this.set(e, f));
          return;
        } else {
          let f = a.generateUidIdentifierBasedOnNode(r);
          a.push({
            id: f
          }), c.push(Tc("=", ts(f), tJ(o, ts(l), u)), ts(l));
          let m = E3(c);
          s.replaceWith(E3([this.set(e, m), ts(f)]));
          return;
        }
      }
      if (s.isAssignmentExpression({
        left: r
      })) {
        iJ(this, e, s);
        return;
      }
      if (s.isCallExpression({
        callee: r
      })) {
        s.replaceWith(this.call(e, s.node.arguments));
        return;
      }
      if (s.isOptionalCallExpression({
        callee: r
      })) {
        if (a.path.isPattern()) {
          s.replaceWith(wg(Qz([], s.node), []));
          return;
        }
        s.replaceWith(this.optionalCall(e, s.node.arguments));
        return;
      }
      if (this.delete && s.isUnaryExpression({
        operator: "delete"
      })) {
        s.replaceWith(this.delete(e));
        return;
      }
      if (s.isForXStatement({
        left: r
      }) || s.isObjectProperty({
        value: r
      }) && s.parentPath.isObjectPattern() || s.isAssignmentPattern({
        left: r
      }) && s.parentPath.isObjectProperty({
        value: i
      }) && s.parentPath.parentPath.isObjectPattern() || s.isArrayPattern() || s.isAssignmentPattern({
        left: r
      }) && s.parentPath.isArrayPattern() || s.isRestElement()) {
        e.replaceWith(this.destructureSet(e));
        return;
      }
      s.isTaggedTemplateExpression() ? e.replaceWith(this.boundGet(e)) : e.replaceWith(this.get(e));
    }
  };
  function iJ(e, t, r) {
    if (e.simpleSet) {
      t.replaceWith(e.simpleSet(t));
      return;
    }
    let {
      operator: i,
      right: s
    } = r.node;
    if (i === "=")
      r.replaceWith(e.set(t, s));
    else {
      let a = i.slice(0, -1);
      Dze.includes(a) ? (e.memoise(t, 1), r.replaceWith(Cg(a, e.get(t), e.set(t, s)))) : (e.memoise(t, 2), r.replaceWith(e.set(t, Du(a, e.get(
      t), s))));
    }
  }
  n(iJ, "handleAssignment");
  function Pze(e, t, r) {
    e.traverse(t, Object.assign({}, _ze, r, {
      memoiser: new T3()
    }));
  }
  n(Pze, "memberExpressionToFunctions");
  C3.default = Pze;
});

// ../node_modules/@babel/helper-optimise-call-expression/lib/index.js
var _3 = E((A3) => {
  "use strict";
  Object.defineProperty(A3, "__esModule", {
    value: !0
  });
  A3.default = kze;
  var Fze = Pe(), {
    callExpression: aJ,
    identifier: Ag,
    isIdentifier: Ize,
    isSpreadElement: Oze,
    memberExpression: oJ,
    optionalCallExpression: uJ,
    optionalMemberExpression: lJ
  } = Fze;
  function kze(e, t, r, i) {
    return r.length === 1 && Oze(r[0]) && Ize(r[0].argument, {
      name: "arguments"
    }) ? i ? uJ(lJ(e, Ag("apply"), !1, !0), [t, r[0].argument], !1) : aJ(oJ(e, Ag("apply")), [t, r[0].argument]) : i ? uJ(lJ(e, Ag("call"), !1,
    !0), [t, ...r], !1) : aJ(oJ(e, Ag("call")), [t, ...r]);
  }
  n(kze, "optimiseCallExpression");
});

// ../node_modules/@babel/helper-replace-supers/lib/index.js
var Pg = E((wc) => {
  "use strict";
  Object.defineProperty(wc, "__esModule", {
    value: !0
  });
  wc.default = void 0;
  var Bze = w3(), _g = _3(), Kr = Gt(), F3 = ir(), {
    assignmentExpression: Nze,
    callExpression: ta,
    cloneNode: Mr,
    identifier: Cc,
    memberExpression: vu,
    sequenceExpression: xu,
    stringLiteral: fJ,
    thisExpression: zr
  } = Kr.types;
  wc.environmentVisitor = F3.visitors.environmentVisitor({}), wc.skipAllButComputedKey = /* @__PURE__ */ n(function(t) {
    t.skip(), t.node.computed && t.context.maybeQueue(t.get("key"));
  }, "skipAllButComputedKey");
  var cJ = F3.visitors.environmentVisitor({
    Super(e, t) {
      let {
        node: r,
        parentPath: i
      } = e;
      i.isMemberExpression({
        object: r
      }) && t.handle(i);
    }
  }), Mze = F3.visitors.environmentVisitor({
    Scopable(e, {
      refName: t
    }) {
      let r = e.scope.getOwnBinding(t);
      r && r.identifier.name === t && e.scope.rename(t);
    }
  }), dJ = {
    memoise(e, t) {
      let {
        scope: r,
        node: i
      } = e, {
        computed: s,
        property: a
      } = i;
      if (!s)
        return;
      let o = r.maybeGenerateMemoised(a);
      o && this.memoiser.set(a, o, t);
    },
    prop(e) {
      let {
        computed: t,
        property: r
      } = e.node;
      return this.memoiser.has(r) ? Mr(this.memoiser.get(r)) : t ? Mr(r) : fJ(r.name);
    },
    _getPrototypeOfExpression() {
      let e = Mr(this.getObjectRef()), t = this.isStatic || this.isPrivateMethod ? e : vu(e, Cc("prototype"));
      return ta(this.file.addHelper("getPrototypeOf"), [t]);
    },
    get(e) {
      let t = Mr(this.getObjectRef());
      return ta(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? xu([zr(), t]) : t, this.prop(e), zr(), ...this.isStatic ||
      this.isPrivateMethod ? [] : [Kr.types.numericLiteral(1)]]);
    },
    _call(e, t, r) {
      let i = Mr(this.getObjectRef()), s;
      t.length === 1 && Kr.types.isSpreadElement(t[0]) && (Kr.types.isIdentifier(t[0].argument) || Kr.types.isArrayExpression(t[0].argument)) ?
      s = t[0].argument : s = Kr.types.arrayExpression(t);
      let a = Kr.types.callExpression(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? xu([zr(), i]) : i, this.prop(e), zr(),
      Kr.types.numericLiteral(2 | (this.isStatic || this.isPrivateMethod ? 0 : 1))]);
      return r ? Kr.types.optionalCallExpression(a, [s], !0) : ta(a, [s]);
    },
    set(e, t) {
      let r = Mr(this.getObjectRef());
      return ta(this.file.addHelper("superPropSet"), [this.isDerivedConstructor ? xu([zr(), r]) : r, this.prop(e), t, zr(), Kr.types.numericLiteral(
      e.isInStrictMode() ? 1 : 0), ...this.isStatic || this.isPrivateMethod ? [] : [Kr.types.numericLiteral(1)]]);
    },
    destructureSet(e) {
      throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.");
    },
    call(e, t) {
      return this._call(e, t, !1);
    },
    optionalCall(e, t) {
      return this._call(e, t, !0);
    },
    delete(e) {
      return e.node.computed ? xu([ta(this.file.addHelper("toPropertyKey"), [Mr(e.node.property)]), Kr.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : Kr.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
    }
  }, Rze = {
    memoise(e, t) {
      let {
        scope: r,
        node: i
      } = e, {
        computed: s,
        property: a
      } = i;
      if (!s)
        return;
      let o = r.maybeGenerateMemoised(a);
      o && this.memoiser.set(a, o, t);
    },
    prop(e) {
      let {
        computed: t,
        property: r
      } = e.node;
      return this.memoiser.has(r) ? Mr(this.memoiser.get(r)) : t ? Mr(r) : fJ(r.name);
    },
    _getPrototypeOfExpression() {
      let e = Mr(this.getObjectRef()), t = this.isStatic || this.isPrivateMethod ? e : vu(e, Cc("prototype"));
      return ta(this.file.addHelper("getPrototypeOf"), [t]);
    },
    get(e) {
      return this._get(e);
    },
    _get(e) {
      let t = this._getPrototypeOfExpression();
      return ta(this.file.addHelper("get"), [this.isDerivedConstructor ? xu([zr(), t]) : t, this.prop(e), zr()]);
    },
    set(e, t) {
      let r = this._getPrototypeOfExpression();
      return ta(this.file.addHelper("set"), [this.isDerivedConstructor ? xu([zr(), r]) : r, this.prop(e), t, zr(), Kr.types.booleanLiteral(e.
      isInStrictMode())]);
    },
    destructureSet(e) {
      throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.");
    },
    call(e, t) {
      return (0, _g.default)(this._get(e), zr(), t, !1);
    },
    optionalCall(e, t) {
      return (0, _g.default)(this._get(e), Mr(zr()), t, !0);
    },
    delete(e) {
      return e.node.computed ? xu([ta(this.file.addHelper("toPropertyKey"), [Mr(e.node.property)]), Kr.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : Kr.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
    }
  }, Lze = Object.assign({}, dJ, {
    prop(e) {
      let {
        property: t
      } = e.node;
      return this.memoiser.has(t) ? Mr(this.memoiser.get(t)) : Mr(t);
    },
    get(e) {
      let {
        isStatic: t,
        getSuperRef: r
      } = this, {
        computed: i
      } = e.node, s = this.prop(e), a;
      if (t) {
        var o;
        a = (o = r()) != null ? o : vu(Cc("Function"), Cc("prototype"));
      } else {
        var u;
        a = vu((u = r()) != null ? u : Cc("Object"), Cc("prototype"));
      }
      return vu(a, s, i);
    },
    set(e, t) {
      let {
        computed: r
      } = e.node, i = this.prop(e);
      return Nze("=", vu(zr(), i, r), t);
    },
    destructureSet(e) {
      let {
        computed: t
      } = e.node, r = this.prop(e);
      return vu(zr(), r, t);
    },
    call(e, t) {
      return (0, _g.default)(this.get(e), zr(), t, !1);
    },
    optionalCall(e, t) {
      return (0, _g.default)(this.get(e), zr(), t, !0);
    }
  }), P3 = class {
    static {
      n(this, "ReplaceSupers");
    }
    constructor(t) {
      var r;
      let i = t.methodPath;
      this.methodPath = i, this.isDerivedConstructor = i.isClassMethod({
        kind: "constructor"
      }) && !!t.superRef, this.isStatic = i.isObjectMethod() || i.node.static || (i.isStaticBlock == null ? void 0 : i.isStaticBlock()), this.
      isPrivateMethod = i.isPrivate() && i.isMethod(), this.file = t.file, this.constantSuper = (r = t.constantSuper) != null ? r : t.isLoose,
      this.opts = t;
    }
    getObjectRef() {
      return Mr(this.opts.objectRef || this.opts.getObjectRef());
    }
    getSuperRef() {
      if (this.opts.superRef) return Mr(this.opts.superRef);
      if (this.opts.getSuperRef)
        return Mr(this.opts.getSuperRef());
    }
    replace() {
      let {
        methodPath: t
      } = this;
      this.opts.refToPreserve && t.traverse(Mze, {
        refName: this.opts.refToPreserve.name
      });
      let r = this.constantSuper ? Lze : this.file.availableHelper("superPropSet") ? dJ : Rze;
      cJ.shouldSkip = (i) => {
        if (i.parentPath === t && (i.parentKey === "decorators" || i.parentKey === "key"))
          return !0;
      }, (0, Bze.default)(t, cJ, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        getSuperRef: this.getSuperRef.bind(this),
        boundGet: r.get
      }, r));
    }
  };
  wc.default = P3;
});

// ../node_modules/@babel/helper-annotate-as-pure/lib/index.js
var O3 = E((I3) => {
  "use strict";
  Object.defineProperty(I3, "__esModule", {
    value: !0
  });
  I3.default = Vze;
  var jze = Pe(), {
    addComment: qze
  } = jze, Uze = "#__PURE__", $ze = /* @__PURE__ */ n(({
    leadingComments: e
  }) => !!e && e.some((t) => /[@#]__PURE__/.test(t.value)), "isPureAnnotated");
  function Vze(e) {
    let t = e.node || e;
    $ze(t) || qze(t, "leading", Uze);
  }
  n(Vze, "annotateAsPure");
});

// ../node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js
var Fg = E((Vp) => {
  "use strict";
  Object.defineProperty(Vp, "__esModule", {
    value: !0
  });
  Vp.isTransparentExprWrapper = k3;
  Vp.skipTransparentExprWrapperNodes = Zze;
  Vp.skipTransparentExprWrappers = Gze;
  var Wze = Pe(), {
    isParenthesizedExpression: Hze,
    isTSAsExpression: Kze,
    isTSNonNullExpression: zze,
    isTSSatisfiesExpression: Jze,
    isTSTypeAssertion: Xze,
    isTypeCastExpression: Yze
  } = Wze;
  function k3(e) {
    return Kze(e) || Jze(e) || Xze(e) || zze(e) || Yze(e) || Hze(e);
  }
  n(k3, "isTransparentExprWrapper");
  function Gze(e) {
    for (; k3(e.node); )
      e = e.get("expression");
    return e;
  }
  n(Gze, "skipTransparentExprWrappers");
  function Zze(e) {
    for (; k3(e); )
      e = e.expression;
    return e;
  }
  n(Zze, "skipTransparentExprWrapperNodes");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js
var N3 = E((B3) => {
  "use strict";
  Object.defineProperty(B3, "__esModule", {
    value: !0
  });
  B3.assertFieldTransformed = Qze;
  function Qze(e) {
    if (e.node.declare)
      throw e.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional clas\
s features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`);
  }
  n(Qze, "assertFieldTransformed");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/fields.js
var q3 = E((Za) => {
  "use strict";
  Object.defineProperty(Za, "__esModule", {
    value: !0
  });
  Za.buildCheckInRHS = kg;
  Za.buildFieldsInitNodes = SJe;
  Za.buildPrivateNamesMap = nJe;
  Za.buildPrivateNamesNodes = aJe;
  Za.privateNameVisitorFactory = j3;
  Za.transformPrivateNamesUsage = dJe;
  var j = Gt(), bJ = ir(), eJe = Pg(), tJe = w3(), pJ = _3(), rJe = O3(), iJe = Fg(), sJe = N3();
  Jr = /* @__PURE__ */ n((e) => e.availableHelper("classPrivateFieldGet2"), "newHelpers");
  var Jr;
  function nJe(e, t, r, i) {
    let s = /* @__PURE__ */ new Map(), a;
    for (let o of r)
      if (o.isPrivate()) {
        let {
          name: u
        } = o.node.key.id, l = s.get(u);
        if (!l) {
          let c = !o.isProperty(), f = o.node.static, m = !1, h;
          !t && Jr(i) && c && !f ? (m = !!a, a ?? (a = o.scope.generateUidIdentifier(`${e}_brand`)), h = a) : h = o.scope.generateUidIdentifier(
          u), l = {
            id: h,
            static: f,
            method: c,
            initAdded: m
          }, s.set(u, l);
        }
        if (o.isClassPrivateMethod())
          if (o.node.kind === "get") {
            let {
              body: c
            } = o.node.body, f;
            c.length === 1 && j.types.isReturnStatement(f = c[0]) && j.types.isCallExpression(f = f.argument) && f.arguments.length === 1 &&
            j.types.isThisExpression(f.arguments[0]) && j.types.isIdentifier(f = f.callee) ? (l.getId = j.types.cloneNode(f), l.getterDeclared =
            !0) : l.getId = o.scope.generateUidIdentifier(`get_${u}`);
          } else if (o.node.kind === "set") {
            let {
              params: c
            } = o.node, {
              body: f
            } = o.node.body, m;
            f.length === 1 && j.types.isExpressionStatement(m = f[0]) && j.types.isCallExpression(m = m.expression) && m.arguments.length ===
            2 && j.types.isThisExpression(m.arguments[0]) && j.types.isIdentifier(m.arguments[1], {
              name: c[0].name
            }) && j.types.isIdentifier(m = m.callee) ? (l.setId = j.types.cloneNode(m), l.setterDeclared = !0) : l.setId = o.scope.generateUidIdentifier(
            `set_${u}`);
          } else o.node.kind === "method" && (l.methodId = o.scope.generateUidIdentifier(u));
        s.set(u, l);
      }
    return s;
  }
  n(nJe, "buildPrivateNamesMap");
  function aJe(e, t, r, i) {
    let s = [], a = /* @__PURE__ */ new Set();
    for (let [o, u] of e) {
      let {
        static: l,
        method: c,
        getId: f,
        setId: m
      } = u, h = f || m, d = j.types.cloneNode(u.id), y;
      if (t)
        y = j.types.callExpression(i.addHelper("classPrivateFieldLooseKey"), [j.types.stringLiteral(o)]);
      else if (r)
        y = j.types.callExpression(j.types.identifier("Symbol"), [j.types.stringLiteral(o)]);
      else if (!l) {
        if (a.has(d.name)) continue;
        a.add(d.name), y = j.types.newExpression(j.types.identifier(c && (!h || Jr(i)) ? "WeakSet" : "WeakMap"), []);
      }
      y && (r || (0, rJe.default)(y), s.push(j.template.statement.ast`var ${d} = ${y}`));
    }
    return s;
  }
  n(aJe, "buildPrivateNamesNodes");
  function j3(e) {
    let t = bJ.visitors.environmentVisitor(Object.assign({}, e)), r = Object.assign({}, e, {
      Class(i) {
        let {
          privateNamesMap: s
        } = this, a = i.get("body.body"), o = new Map(s), u = [];
        for (let l of a) {
          if (!l.isPrivate()) continue;
          let {
            name: c
          } = l.node.key.id;
          o.delete(c), u.push(c);
        }
        u.length && (i.get("body").traverse(t, Object.assign({}, this, {
          redeclared: u
        })), i.traverse(r, Object.assign({}, this, {
          privateNamesMap: o
        })), i.skipKey("body"));
      }
    });
    return r;
  }
  n(j3, "privateNameVisitorFactory");
  var oJe = j3({
    PrivateName(e, {
      noDocumentAll: t
    }) {
      let {
        privateNamesMap: r,
        redeclared: i
      } = this, {
        node: s,
        parentPath: a
      } = e;
      if (!a.isMemberExpression({
        property: s
      }) && !a.isOptionalMemberExpression({
        property: s
      }))
        return;
      let {
        name: o
      } = s.id;
      r.has(o) && (i != null && i.includes(o) || this.handle(a, t));
    }
  });
  function DJ(e, t, r) {
    for (; (i = t) != null && i.hasBinding(e) && !t.bindingIdentifierEquals(e, r); ) {
      var i;
      t.rename(e), t = t.parent;
    }
  }
  n(DJ, "unshadow");
  function kg(e, t, r) {
    return r || !(t.availableHelper != null && t.availableHelper("checkInRHS")) ? e : j.types.callExpression(t.addHelper("checkInRHS"), [e]);
  }
  n(kg, "buildCheckInRHS");
  var uJe = j3({
    BinaryExpression(e, {
      file: t
    }) {
      let {
        operator: r,
        left: i,
        right: s
      } = e.node;
      if (r !== "in" || !j.types.isPrivateName(i)) return;
      let {
        privateFieldsAsProperties: a,
        privateNamesMap: o,
        redeclared: u
      } = this, {
        name: l
      } = i.id;
      if (!o.has(l) || u != null && u.includes(l)) return;
      if (DJ(this.classRef.name, e.scope, this.innerBinding), a) {
        let {
          id: m
        } = o.get(l);
        e.replaceWith(j.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${kg(s, t)}, ${j.types.cloneNode(m)})
      `);
        return;
      }
      let {
        id: c,
        static: f
      } = o.get(l);
      if (f) {
        e.replaceWith(j.template.expression.ast`${kg(s, t)} === ${j.types.cloneNode(this.classRef)}`);
        return;
      }
      e.replaceWith(j.template.expression.ast`${j.types.cloneNode(c)}.has(${kg(s, t)})`);
    }
  });
  function Ig(e, t) {
    return j.types.callExpression(e.addHelper("readOnlyError"), [j.types.stringLiteral(`#${t}`)]);
  }
  n(Ig, "readOnlyError");
  function lJe(e, t) {
    return e.availableHelper("writeOnlyError") ? j.types.callExpression(e.addHelper("writeOnlyError"), [j.types.stringLiteral(`#${t}`)]) : (console.
    warn("@babel/helpers is outdated, update it to silence this warning."), j.types.buildUndefinedNode());
  }
  n(lJe, "writeOnlyError");
  function M3(e, t) {
    return t ? e : j.types.memberExpression(e, j.types.identifier("_"));
  }
  n(M3, "buildStaticPrivateFieldAccess");
  function hJ(e) {
    return function(t) {
      return j.types.inherits(e.apply(this, arguments), t.node);
    };
  }
  n(hJ, "autoInherits");
  var cJe = {
    memoise(e, t) {
      let {
        scope: r
      } = e, {
        object: i
      } = e.node, s = r.maybeGenerateMemoised(i);
      s && this.memoiser.set(i, s, t);
    },
    receiver(e) {
      let {
        object: t
      } = e.node;
      return this.memoiser.has(t) ? j.types.cloneNode(this.memoiser.get(t)) : j.types.cloneNode(t);
    },
    get: hJ(function(e) {
      let {
        classRef: t,
        privateNamesMap: r,
        file: i,
        innerBinding: s,
        noUninitializedPrivateFieldAccess: a
      } = this, o = e.node.property, {
        name: u
      } = o.id, {
        id: l,
        static: c,
        method: f,
        methodId: m,
        getId: h,
        setId: d
      } = r.get(u), y = h || d, p = /* @__PURE__ */ n((g) => j.types.inherits(j.types.cloneNode(g), o), "cloneId");
      if (c) {
        if (DJ(t.name, e.scope, s), !Jr(i)) {
          let D = f && !y ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
          return j.types.callExpression(i.addHelper(D), [this.receiver(e), j.types.cloneNode(t), p(l)]);
        }
        let g = this.receiver(e), b = j.types.isIdentifier(g) && g.name === t.name;
        if (!f)
          return M3(b ? p(l) : j.types.callExpression(i.addHelper("assertClassBrand"), [j.types.cloneNode(t), g, p(l)]), a);
        if (h)
          return b ? j.types.callExpression(p(h), [g]) : j.types.callExpression(i.addHelper("classPrivateGetter"), [j.types.cloneNode(t), g,
          p(h)]);
        if (d) {
          let D = j.types.buildUndefinedNode();
          return b ? D : j.types.sequenceExpression([j.types.callExpression(i.addHelper("assertClassBrand"), [j.types.cloneNode(t), g]), D]);
        }
        return b ? p(l) : j.types.callExpression(i.addHelper("assertClassBrand"), [j.types.cloneNode(t), g, p(l)]);
      }
      return f ? y ? h ? Jr(i) ? j.types.callExpression(i.addHelper("classPrivateGetter"), [j.types.cloneNode(l), this.receiver(e), p(h)]) :
      j.types.callExpression(i.addHelper("classPrivateFieldGet"), [this.receiver(e), p(l)]) : j.types.sequenceExpression([this.receiver(e), lJe(
      i, u)]) : Jr(i) ? j.types.callExpression(i.addHelper("assertClassBrand"), [j.types.cloneNode(l), this.receiver(e), p(m)]) : j.types.callExpression(
      i.addHelper("classPrivateMethodGet"), [this.receiver(e), j.types.cloneNode(l), p(m)]) : Jr(i) ? j.types.callExpression(i.addHelper("cl\
assPrivateFieldGet2"), [p(l), this.receiver(e)]) : j.types.callExpression(i.addHelper("classPrivateFieldGet"), [this.receiver(e), p(l)]);
    }),
    boundGet(e) {
      return this.memoise(e, 1), j.types.callExpression(j.types.memberExpression(this.get(e), j.types.identifier("bind")), [this.receiver(e)]);
    },
    set: hJ(function(e, t) {
      let {
        classRef: r,
        privateNamesMap: i,
        file: s,
        noUninitializedPrivateFieldAccess: a
      } = this, o = e.node.property, {
        name: u
      } = o.id, {
        id: l,
        static: c,
        method: f,
        setId: m,
        getId: h
      } = i.get(u), d = h || m, y = /* @__PURE__ */ n((p) => j.types.inherits(j.types.cloneNode(p), o), "cloneId");
      if (c) {
        if (!Jr(s)) {
          let b = f && !d ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
          return j.types.callExpression(s.addHelper(b), [this.receiver(e), j.types.cloneNode(r), y(l), t]);
        }
        let p = this.receiver(e), g = j.types.isIdentifier(p) && p.name === r.name;
        if (f && !m) {
          let b = Ig(s, u);
          return g ? j.types.sequenceExpression([t, b]) : j.types.sequenceExpression([t, j.types.callExpression(s.addHelper("assertClassBran\
d"), [j.types.cloneNode(r), p]), Ig(s, u)]);
        }
        return m ? g ? j.types.callExpression(j.types.cloneNode(m), [p, t]) : j.types.callExpression(s.addHelper("classPrivateSetter"), [j.types.
        cloneNode(r), y(m), p, t]) : j.types.assignmentExpression("=", M3(y(l), a), g ? t : j.types.callExpression(s.addHelper("assertClassB\
rand"), [j.types.cloneNode(r), p, t]));
      }
      return f ? m ? Jr(s) ? j.types.callExpression(s.addHelper("classPrivateSetter"), [j.types.cloneNode(l), y(m), this.receiver(e), t]) : j.
      types.callExpression(s.addHelper("classPrivateFieldSet"), [this.receiver(e), y(l), t]) : j.types.sequenceExpression([this.receiver(e),
      t, Ig(s, u)]) : Jr(s) ? j.types.callExpression(s.addHelper("classPrivateFieldSet2"), [y(l), this.receiver(e), t]) : j.types.callExpression(
      s.addHelper("classPrivateFieldSet"), [this.receiver(e), y(l), t]);
    }),
    destructureSet(e) {
      let {
        classRef: t,
        privateNamesMap: r,
        file: i,
        noUninitializedPrivateFieldAccess: s
      } = this, a = e.node.property, {
        name: o
      } = a.id, {
        id: u,
        static: l,
        method: c,
        setId: f
      } = r.get(o), m = /* @__PURE__ */ n((p) => j.types.inherits(j.types.cloneNode(p), a), "cloneId");
      if (!Jr(i)) {
        if (l) {
          try {
            var h = i.addHelper("classStaticPrivateFieldDestructureSet");
          } catch {
            throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the late\
st version.");
          }
          return j.types.memberExpression(j.types.callExpression(h, [this.receiver(e), j.types.cloneNode(t), m(u)]), j.types.identifier("val\
ue"));
        }
        return j.types.memberExpression(j.types.callExpression(i.addHelper("classPrivateFieldDestructureSet"), [this.receiver(e), m(u)]), j.
        types.identifier("value"));
      }
      if (c && !f)
        return j.types.memberExpression(j.types.sequenceExpression([e.node.object, Ig(i, o)]), j.types.identifier("_"));
      if (l && !c) {
        let p = this.get(e);
        if (!s || !j.types.isCallExpression(p))
          return p;
        let g = p.arguments.pop();
        return p.arguments.push(j.template.expression.ast`(_) => ${g} = _`), j.types.memberExpression(j.types.callExpression(i.addHelper("to\
Setter"), [p]), j.types.identifier("_"));
      }
      let d = this.set(e, j.types.identifier("_"));
      if (!j.types.isCallExpression(d) || !j.types.isIdentifier(d.arguments[d.arguments.length - 1], {
        name: "_"
      }))
        throw e.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. Please report it at https://github\
.com/babel/babel/issues.");
      let y;
      return j.types.isMemberExpression(d.callee, {
        computed: !1
      }) && j.types.isIdentifier(d.callee.property) && d.callee.property.name === "call" ? y = [d.callee.object, j.types.arrayExpression(d.arguments.
      slice(1, -1)), d.arguments[0]] : y = [d.callee, j.types.arrayExpression(d.arguments.slice(0, -1))], j.types.memberExpression(j.types.callExpression(
      i.addHelper("toSetter"), y), j.types.identifier("_"));
    },
    call(e, t) {
      return this.memoise(e, 1), (0, pJ.default)(this.get(e), this.receiver(e), t, !1);
    },
    optionalCall(e, t) {
      return this.memoise(e, 1), (0, pJ.default)(this.get(e), this.receiver(e), t, !0);
    },
    delete() {
      throw new Error("Internal Babel error: deleting private elements is a parsing error.");
    }
  }, fJe = {
    get(e) {
      let {
        privateNamesMap: t,
        file: r
      } = this, {
        object: i
      } = e.node, {
        name: s
      } = e.node.property.id;
      return j.template.expression`BASE(REF, PROP)[PROP]`({
        BASE: r.addHelper("classPrivateFieldLooseBase"),
        REF: j.types.cloneNode(i),
        PROP: j.types.cloneNode(t.get(s).id)
      });
    },
    set() {
      throw new Error("private name handler with loose = true don't need set()");
    },
    boundGet(e) {
      return j.types.callExpression(j.types.memberExpression(this.get(e), j.types.identifier("bind")), [j.types.cloneNode(e.node.object)]);
    },
    simpleSet(e) {
      return this.get(e);
    },
    destructureSet(e) {
      return this.get(e);
    },
    call(e, t) {
      return j.types.callExpression(this.get(e), t);
    },
    optionalCall(e, t) {
      return j.types.optionalCallExpression(this.get(e), t, !0);
    },
    delete() {
      throw new Error("Internal Babel error: deleting private elements is a parsing error.");
    }
  };
  function dJe(e, t, r, {
    privateFieldsAsProperties: i,
    noUninitializedPrivateFieldAccess: s,
    noDocumentAll: a,
    innerBinding: o
  }, u) {
    if (!r.size) return;
    let l = t.get("body"), c = i ? fJe : cJe;
    (0, tJe.default)(l, oJe, Object.assign({
      privateNamesMap: r,
      classRef: e,
      file: u
    }, c, {
      noDocumentAll: a,
      noUninitializedPrivateFieldAccess: s,
      innerBinding: o
    })), l.traverse(uJe, {
      privateNamesMap: r,
      classRef: e,
      file: u,
      privateFieldsAsProperties: i,
      innerBinding: o
    });
  }
  n(dJe, "transformPrivateNamesUsage");
  function mJ(e, t, r) {
    let {
      id: i
    } = r.get(t.node.key.id.name), s = t.node.value || t.scope.buildUndefinedNode();
    return Tr(j.template.statement.ast`
      Object.defineProperty(${e}, ${j.types.cloneNode(i)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${s}
      });
    `, t);
  }
  n(mJ, "buildPrivateFieldInitLoose");
  function pJe(e, t, r, i) {
    let {
      id: s
    } = r.get(t.node.key.id.name), a = t.node.value || t.scope.buildUndefinedNode();
    if (!i.availableHelper("classPrivateFieldInitSpec"))
      return Tr(j.template.statement.ast`${j.types.cloneNode(s)}.set(${e}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${a},
        })`, t);
    let o = i.addHelper("classPrivateFieldInitSpec");
    return L3(Tr(j.types.expressionStatement(j.types.callExpression(o, [j.types.thisExpression(), L3(j.types.cloneNode(s), t.node.key), Jr(i) ?
    a : j.template.expression.ast`{ writable: true, value: ${a} }`])), t), t.node);
  }
  n(pJe, "buildPrivateInstanceFieldInitSpec");
  function hJe(e, t, r) {
    let i = t.get(e.node.key.id.name), s = r ? e.node.value : j.template.expression.ast`{
        _: ${e.node.value || j.types.buildUndefinedNode()}
      }`;
    return Tr(j.types.variableDeclaration("var", [j.types.variableDeclarator(j.types.cloneNode(i.id), s)]), e);
  }
  n(hJe, "buildPrivateStaticFieldInitSpec");
  R3 = /* @__PURE__ */ n(function(e, t) {
    let r = t.get(e.node.key.id.name), {
      id: i,
      getId: s,
      setId: a,
      initAdded: o
    } = r, u = s || a;
    if (!e.isProperty() && (o || !u)) return;
    if (u)
      return t.set(e.node.key.id.name, Object.assign({}, r, {
        initAdded: !0
      })), Tr(j.template.statement.ast`
          var ${j.types.cloneNode(i)} = {
            // configurable is false by default
            // enumerable is false by default
            // writable is false by default
            get: ${s ? s.name : e.scope.buildUndefinedNode()},
            set: ${a ? a.name : e.scope.buildUndefinedNode()}
          }
        `, e);
    let l = e.node.value || e.scope.buildUndefinedNode();
    return Tr(j.template.statement.ast`
        var ${j.types.cloneNode(i)} = {
          // configurable is false by default
          // enumerable is false by default
          writable: true,
          value: ${l}
        };
      `, e);
  }, "buildPrivateStaticFieldInitSpecOld");
  var R3;
  function mJe(e, t, r) {
    let i = r.get(t.node.key.id.name), {
      methodId: s,
      id: a,
      getId: o,
      setId: u,
      initAdded: l
    } = i;
    if (l) return;
    if (s)
      return Tr(j.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${s.name}
        });
      `, t);
    if (o || u)
      return r.set(t.node.key.id.name, Object.assign({}, i, {
        initAdded: !0
      })), Tr(j.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${o ? o.name : t.scope.buildUndefinedNode()},
          set: ${u ? u.name : t.scope.buildUndefinedNode()}
        });
      `, t);
  }
  n(mJe, "buildPrivateMethodInitLoose");
  function yJe(e, t, r, i) {
    let s = r.get(t.node.key.id.name);
    if (!s.initAdded)
      return !Jr(i) && (s.getId || s.setId) ? gJe(e, t, r, i) : bJe(e, t, r, i);
  }
  n(yJe, "buildPrivateInstanceMethodInitSpec");
  function gJe(e, t, r, i) {
    let s = r.get(t.node.key.id.name), {
      id: a,
      getId: o,
      setId: u
    } = s;
    if (r.set(t.node.key.id.name, Object.assign({}, s, {
      initAdded: !0
    })), !i.availableHelper("classPrivateFieldInitSpec"))
      return Tr(j.template.statement.ast`
          ${a}.set(${e}, {
            get: ${o ? o.name : t.scope.buildUndefinedNode()},
            set: ${u ? u.name : t.scope.buildUndefinedNode()}
          });
        `, t);
    let l = i.addHelper("classPrivateFieldInitSpec");
    return L3(Tr(j.template.statement.ast`${l}(
      ${j.types.thisExpression()},
      ${j.types.cloneNode(a)},
      {
        get: ${o ? o.name : t.scope.buildUndefinedNode()},
        set: ${u ? u.name : t.scope.buildUndefinedNode()}
      },
    )`, t), t.node);
  }
  n(gJe, "buildPrivateAccessorInitialization");
  function bJe(e, t, r, i) {
    let s = r.get(t.node.key.id.name), {
      id: a
    } = s;
    if (!i.availableHelper("classPrivateMethodInitSpec"))
      return Tr(j.template.statement.ast`${a}.add(${e})`, t);
    let o = i.addHelper("classPrivateMethodInitSpec");
    return Tr(j.template.statement.ast`${o}(
      ${j.types.thisExpression()},
      ${j.types.cloneNode(a)}
    )`, t);
  }
  n(bJe, "buildPrivateInstanceMethodInitialization");
  function yJ(e, t) {
    let {
      key: r,
      computed: i
    } = t.node, s = t.node.value || t.scope.buildUndefinedNode();
    return Tr(j.types.expressionStatement(j.types.assignmentExpression("=", j.types.memberExpression(e, r, i || j.types.isLiteral(r)), s)), t);
  }
  n(yJ, "buildPublicFieldInitLoose");
  function gJ(e, t, r) {
    let {
      key: i,
      computed: s
    } = t.node, a = t.node.value || t.scope.buildUndefinedNode();
    return Tr(j.types.expressionStatement(j.types.callExpression(r.addHelper("defineProperty"), [e, s || j.types.isLiteral(i) ? i : j.types.
    stringLiteral(i.name), a])), t);
  }
  n(gJ, "buildPublicFieldInitSpec");
  function DJe(e, t, r, i) {
    let s = i.get(t.node.key.id.name), {
      id: a,
      methodId: o,
      getId: u,
      setId: l,
      initAdded: c
    } = s;
    return c ? void 0 : u || l ? (i.set(t.node.key.id.name, Object.assign({}, s, {
      initAdded: !0
    })), Tr(j.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${u ? u.name : t.scope.buildUndefinedNode()},
          set: ${l ? l.name : t.scope.buildUndefinedNode()}
        })
      `, t)) : Tr(j.template.statement.ast`
      Object.defineProperty(${e}, ${a}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${o.name}
      });
    `, t);
  }
  n(DJe, "buildPrivateStaticMethodInitLoose");
  function Og(e, t, r, i = !1) {
    let s = r.get(t.node.key.id.name), {
      id: a,
      methodId: o,
      getId: u,
      setId: l,
      getterDeclared: c,
      setterDeclared: f,
      static: m
    } = s, {
      params: h,
      body: d,
      generator: y,
      async: p
    } = t.node, g = u && h.length === 0, b = l && h.length > 0;
    if (g && c || b && f)
      return r.set(t.node.key.id.name, Object.assign({}, s, {
        initAdded: !0
      })), null;
    if (Jr(e) && (g || b) && !i) {
      let x = t.get("body").scope, T = x.generateUidIdentifier("this"), w = {
        thisRef: T,
        argumentsPath: []
      };
      if (t.traverse(vJ, w), w.argumentsPath.length) {
        let B = x.generateUidIdentifier("arguments");
        x.push({
          id: B,
          init: j.template.expression.ast`[].slice.call(arguments, 1)`
        });
        for (let k of w.argumentsPath)
          k.replaceWith(j.types.cloneNode(B));
      }
      h.unshift(j.types.cloneNode(T));
    }
    let D = o;
    return g ? (r.set(t.node.key.id.name, Object.assign({}, s, {
      getterDeclared: !0,
      initAdded: !0
    })), D = u) : b ? (r.set(t.node.key.id.name, Object.assign({}, s, {
      setterDeclared: !0,
      initAdded: !0
    })), D = l) : m && !i && (D = a), Tr(j.types.functionDeclaration(j.types.cloneNode(D), h, d, y, p), t);
  }
  n(Og, "buildPrivateMethodDeclaration");
  var vJ = bJ.visitors.environmentVisitor({
    Identifier(e, t) {
      t.argumentsPath && e.node.name === "arguments" && t.argumentsPath.push(e);
    },
    UnaryExpression(e) {
      let {
        node: t
      } = e;
      if (t.operator === "delete") {
        let r = (0, iJe.skipTransparentExprWrapperNodes)(t.argument);
        j.types.isThisExpression(r) && e.replaceWith(j.types.booleanLiteral(!0));
      }
    },
    ThisExpression(e, t) {
      t.needsClassRef = !0, e.replaceWith(j.types.cloneNode(t.thisRef));
    },
    MetaProperty(e) {
      let {
        node: t,
        scope: r
      } = e;
      t.meta.name === "new" && t.property.name === "target" && e.replaceWith(r.buildUndefinedNode());
    }
  }), vJe = {
    ReferencedIdentifier(e, t) {
      e.scope.bindingIdentifierEquals(e.node.name, t.innerBinding) && (t.needsClassRef = !0, e.node.name = t.thisRef.name);
    }
  };
  function xJe(e, t, r) {
    var i;
    let s = {
      thisRef: t,
      needsClassRef: !1,
      innerBinding: r
    };
    return e.isMethod() || e.traverse(vJ, s), r != null && (i = s.thisRef) != null && i.name && s.thisRef.name !== r.name && e.traverse(vJe,
    s), s.needsClassRef;
  }
  n(xJe, "replaceThisContext");
  function EJe({
    key: e,
    computed: t
  }) {
    return e.type === "Identifier" ? !t && (e.name === "name" || e.name === "length") : e.type === "StringLiteral" ? e.value === "name" || e.
    value === "length" : !1;
  }
  n(EJe, "isNameOrLength");
  function Tr(e, t) {
    return j.types.inheritLeadingComments(e, t.node), j.types.inheritInnerComments(e, t.node), e;
  }
  n(Tr, "inheritPropComments");
  function L3(e, t) {
    return e.start = t.start, e.end = t.end, e.loc = t.loc, e;
  }
  n(L3, "inheritLoc");
  function SJe(e, t, r, i, s, a, o, u, l, c) {
    let f = 0, m, h = [], d = [], y = !1, p = [], g = null, b = j.types.isIdentifier(t) ? () => t : () => (m ?? (m = r[0].scope.generateUidIdentifierBasedOnNode(
    t)), m), D = e ?? r[0].scope.generateUidIdentifier(c?.name || "Class");
    e ?? (e = j.types.cloneNode(c));
    for (let x of r) {
      x.isClassProperty() && sJe.assertFieldTransformed(x);
      let T = !(j.types.isStaticBlock != null && j.types.isStaticBlock(x.node)) && x.node.static, w = !T, B = x.isPrivate(), k = !B, q = x.isProperty(),
      V = !q, Y = x.isStaticBlock == null ? void 0 : x.isStaticBlock();
      switch (T && (f |= 1), (T || V && B || Y) && (new eJe.default({
        methodPath: x,
        constantSuper: l,
        file: s,
        refToPreserve: c,
        getSuperRef: b,
        getObjectRef() {
          return f |= 2, T || Y ? D : j.types.memberExpression(D, j.types.identifier("prototype"));
        }
      }).replace(), xJe(x, D, c) && (f |= 2)), y = !1, !0) {
        case Y: {
          let G = x.node.body;
          G.length === 1 && j.types.isExpressionStatement(G[0]) ? h.push(Tr(G[0], x)) : h.push(j.types.inheritsComments(j.template.statement.
          ast`(() => { ${G} })()`, x.node));
          break;
        }
        case (T && B && q && o):
          h.push(mJ(j.types.cloneNode(e), x, i));
          break;
        case (T && B && q && !o):
          Jr(s) ? h.push(hJe(x, i, u)) : h.push(R3(x, i));
          break;
        case (T && k && q && a):
          if (!EJe(x.node)) {
            h.push(yJ(j.types.cloneNode(e), x));
            break;
          }
        case (T && k && q && !a):
          h.push(gJ(j.types.cloneNode(e), x, s));
          break;
        case (w && B && q && o):
          d.push(mJ(j.types.thisExpression(), x, i));
          break;
        case (w && B && q && !o):
          d.push(pJe(j.types.thisExpression(), x, i, s));
          break;
        case (w && B && V && o):
          d.unshift(mJe(j.types.thisExpression(), x, i)), p.push(Og(s, x, i, o));
          break;
        case (w && B && V && !o):
          d.unshift(yJe(j.types.thisExpression(), x, i, s)), p.push(Og(s, x, i, o));
          break;
        case (T && B && V && !o):
          Jr(s) || h.unshift(R3(x, i)), p.push(Og(s, x, i, o));
          break;
        case (T && B && V && o):
          h.unshift(DJe(j.types.cloneNode(e), x, s, i)), p.push(Og(s, x, i, o));
          break;
        case (w && k && q && a):
          d.push(yJ(j.types.thisExpression(), x));
          break;
        case (w && k && q && !a):
          y = !0, d.push(gJ(j.types.thisExpression(), x, s));
          break;
        default:
          throw new Error("Unreachable.");
      }
    }
    return f & 2 && c != null && (g = j.types.expressionStatement(j.types.assignmentExpression("=", j.types.cloneNode(D), j.types.cloneNode(
    c)))), {
      staticNodes: h.filter(Boolean),
      instanceNodes: d.filter(Boolean),
      lastInstanceNodeReturnsThis: y,
      pureStaticNodes: p.filter(Boolean),
      classBindingNode: g,
      wrapClass(x) {
        for (let T of r)
          T.node.leadingComments = null, T.remove();
        return m && (x.scope.push({
          id: j.types.cloneNode(m)
        }), x.set("superClass", j.types.assignmentExpression("=", m, x.node.superClass))), f !== 0 && (x.isClassExpression() ? (x.scope.push(
        {
          id: e
        }), x.replaceWith(j.types.assignmentExpression("=", j.types.cloneNode(e), x.node))) : (c == null && (x.node.id = e), g != null && x.
        scope.push({
          id: D
        }))), x;
      }
    };
  }
  n(SJe, "buildFieldsInitNodes");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/misc.js
var U3 = E((Wp) => {
  "use strict";
  Object.defineProperty(Wp, "__esModule", {
    value: !0
  });
  Wp.extractComputedKeys = PJe;
  Wp.injectInitialization = _Je;
  Wp.memoiseComputedKey = EJ;
  var er = Gt(), TJe = ir(), CJe = TJe.visitors.environmentVisitor({
    Super(e) {
      let {
        node: t,
        parentPath: r
      } = e;
      r.isCallExpression({
        callee: t
      }) && this.push(r);
    }
  }), wJe = {
    "TSTypeAnnotation|TypeAnnotation"(e) {
      e.skip();
    },
    ReferencedIdentifier(e, {
      scope: t
    }) {
      t.hasOwnBinding(e.node.name) && (t.rename(e.node.name), e.skip());
    }
  };
  function xJ(e, t) {
    if (t.classBinding && t.classBinding === e.scope.getBinding(e.node.name)) {
      let r = t.file.addHelper("classNameTDZError"), i = er.types.callExpression(r, [er.types.stringLiteral(e.node.name)]);
      e.replaceWith(er.types.sequenceExpression([i, e.node])), e.skip();
    }
  }
  n(xJ, "handleClassTDZ");
  var AJe = {
    ReferencedIdentifier: xJ,
    "TSTypeAnnotation|TypeAnnotation"(e) {
      e.skip();
    }
  };
  function _Je(e, t, r, i, s) {
    if (!r.length) return;
    let a = !!e.node.superClass;
    if (!t) {
      let o = er.types.classMethod("constructor", er.types.identifier("constructor"), [], er.types.blockStatement([]));
      a && (o.params = [er.types.restElement(er.types.identifier("args"))], o.body.body.push(er.template.statement.ast`super(...args)`)), [t] =
      e.get("body").unshiftContainer("body", o);
    }
    if (i && i(wJe, {
      scope: t.scope
    }), a) {
      let o = [];
      t.traverse(CJe, o);
      let u = !0;
      for (let l of o)
        if (u ? u = !1 : r = r.map((c) => er.types.cloneNode(c)), l.parentPath.isExpressionStatement())
          l.insertAfter(r);
        else {
          let c = [l.node, ...r.map((f) => er.types.toExpression(f))];
          s || c.push(er.types.thisExpression()), l.replaceWith(er.types.sequenceExpression(c));
        }
    } else
      t.get("body").unshiftContainer("body", r);
  }
  n(_Je, "injectInitialization");
  function EJ(e, t, r) {
    if (er.types.isIdentifier(e) && t.hasUid(e.name))
      return;
    if (er.types.isAssignmentExpression(e, {
      operator: "="
    }) && er.types.isIdentifier(e.left) && t.hasUid(e.left.name))
      return er.types.cloneNode(e);
    {
      let a = er.types.identifier(r);
      return t.push({
        id: a,
        kind: "let"
      }), er.types.assignmentExpression("=", er.types.cloneNode(a), e);
    }
  }
  n(EJ, "memoiseComputedKey");
  function PJe(e, t, r) {
    let {
      scope: i
    } = e, s = [], a = {
      classBinding: e.node.id && i.getBinding(e.node.id.name),
      file: r
    };
    for (let o of t) {
      let u = o.get("key");
      u.isReferencedIdentifier() ? xJ(u, a) : u.traverse(AJe, a);
      let l = o.node;
      if (!u.isConstantExpression()) {
        let c = EJ(u.node, i, i.generateUidBasedOnNode(u.node));
        c && (s.push(er.types.expressionStatement(c)), l.key = er.types.cloneNode(c.left));
      }
    }
    return s;
  }
  n(PJe, "extractComputedKeys");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js
var X3 = E((Ac) => {
  "use strict";
  Object.defineProperty(Ac, "__esModule", {
    value: !0
  });
  Ac.buildNamedEvaluationVisitor = RJ;
  Ac.default = uXe;
  Ac.hasDecorators = FJe;
  Ac.hasOwnDecorators = K3;
  var O = Gt(), SJ = Pg(), Qa = Fg(), kJ = q3(), Bg = U3();
  function K3(e) {
    var t;
    return !!((t = e.decorators) != null && t.length);
  }
  n(K3, "hasOwnDecorators");
  function FJe(e) {
    return K3(e) || e.body.body.some(K3);
  }
  n(FJe, "hasDecorators");
  function BJ(e, t = e.length - 1) {
    if (t === -1) {
      e.unshift(65);
      return;
    }
    let r = e[t];
    r === 90 ? e[t] = 97 : r === 122 ? (e[t] = 65, BJ(e, t - 1)) : e[t] = r + 1;
  }
  n(BJ, "incrementId");
  function IJe(e) {
    let t = [], r = /* @__PURE__ */ new Set();
    return e.traverse({
      PrivateName(i) {
        r.add(i.node.id.name);
      }
    }), () => {
      let i;
      do
        BJ(t), i = String.fromCharCode(...t);
      while (r.has(i));
      return O.types.privateName(O.types.identifier(i));
    };
  }
  n(IJe, "createPrivateUidGeneratorForClass");
  function OJe(e) {
    let t;
    return () => (t || (t = IJe(e)), t());
  }
  n(OJe, "createLazyPrivateUidGeneratorForClass");
  function kJe(e, t) {
    let r = e.node.id, i = e.scope;
    if (e.type === "ClassDeclaration") {
      let s = r.name, a = i.generateUidIdentifierBasedOnNode(r), o = O.types.identifier(s);
      return i.rename(s, a.name), e.get("id").replaceWith(o), {
        id: O.types.cloneNode(a),
        path: e
      };
    } else {
      let s;
      r ? (t = r.name, s = Ii(i.parent, t), i.rename(t, s.name)) : s = Ii(i.parent, typeof t == "string" ? t : "decorated_class");
      let a = O.types.classExpression(typeof t == "string" ? O.types.identifier(t) : null, e.node.superClass, e.node.body), [o] = e.replaceWith(
      O.types.sequenceExpression([a, s]));
      return {
        id: O.types.cloneNode(s),
        path: o.get("expressions.0")
      };
    }
  }
  n(kJe, "replaceClassWithVar");
  function TJ(e, t, r) {
    return e.type === "PrivateName" ? O.types.classPrivateProperty(e, t, void 0, r) : O.types.classProperty(e, t, void 0, void 0, r);
  }
  n(TJ, "generateClassProperty");
  function $3(e, t) {
    e.node.id || (e.node.id = typeof t == "string" ? O.types.identifier(t) : e.scope.generateUidIdentifier("Class"));
  }
  n($3, "assignIdForAnonymousClass");
  function CJ(e, t, r, i, s, a, o, u) {
    let l = (u === "2023-11" || u === "2023-05") && o ? e : O.types.thisExpression(), c = O.types.blockStatement([O.types.returnStatement(O.
    types.memberExpression(O.types.cloneNode(l), O.types.cloneNode(s)))]), f = O.types.blockStatement([O.types.expressionStatement(O.types.assignmentExpression(
    "=", O.types.memberExpression(O.types.cloneNode(l), O.types.cloneNode(s)), O.types.identifier("v")))]), m, h;
    r.type === "PrivateName" ? (m = O.types.classPrivateMethod("get", r, [], c, o), h = O.types.classPrivateMethod("set", i, [O.types.identifier(
    "v")], f, o)) : (m = O.types.classMethod("get", r, [], c, a, o), h = O.types.classMethod("set", i, [O.types.identifier("v")], f, a, o)),
    t.insertAfter(h), t.insertAfter(m);
  }
  n(CJ, "addProxyAccessorsFor");
  function wJ(e, t) {
    return t !== "2023-11" && t !== "2023-05" && t !== "2023-01" ? [O.template.expression.ast`
        function () {
          return this.${O.types.cloneNode(e)};
        }
      `, O.template.expression.ast`
        function (value) {
          this.${O.types.cloneNode(e)} = value;
        }
      `] : [O.template.expression.ast`
      o => o.${O.types.cloneNode(e)}
    `, O.template.expression.ast`
      (o, v) => o.${O.types.cloneNode(e)} = v
    `];
  }
  n(wJ, "extractProxyAccessorsFor");
  function J3(e) {
    if (e = (0, Qa.skipTransparentExprWrappers)(e), e.isSequenceExpression()) {
      let t = e.get("expressions");
      return J3(t[t.length - 1]);
    }
    return e;
  }
  n(J3, "getComputedKeyLastElement");
  function BJe(e) {
    let t = J3(e);
    if (t.isConstantExpression())
      return O.types.cloneNode(e.node);
    if (t.isIdentifier() && e.scope.hasUid(t.node.name))
      return O.types.cloneNode(e.node);
    if (t.isAssignmentExpression() && t.get("left").isIdentifier())
      return O.types.cloneNode(t.node.left);
    throw new Error(`Internal Error: the computed key ${e.toString()} has not yet been memoised.`);
  }
  n(BJe, "getComputedKeyMemoiser");
  function Hp(e, t) {
    let r = t.get("key");
    r.isSequenceExpression() ? e.push(...r.node.expressions) : e.push(r.node), r.replaceWith(to(e));
  }
  n(Hp, "prependExpressionsToComputedKey");
  function NJe(e, t) {
    let r = t.get("key"), i = J3(r);
    if (i.isConstantExpression())
      Hp(e, t);
    else {
      let s = r.scope.parent, a = (0, Bg.memoiseComputedKey)(i.node, s, s.generateUid("computedKey"));
      if (!a)
        Hp(e, t);
      else {
        let o = [...e, O.types.cloneNode(a.left)], u = i.parentPath;
        u.isSequenceExpression() ? u.pushContainer("expressions", o) : i.replaceWith(to([O.types.cloneNode(a), ...o]));
      }
    }
  }
  n(NJe, "appendExpressionsToComputedKey");
  function V3(e, t) {
    let r = t.get("value");
    r.node ? e.push(r.node) : e.length > 0 && (e[e.length - 1] = O.types.unaryExpression("void", e[e.length - 1])), r.replaceWith(to(e));
  }
  n(V3, "prependExpressionsToFieldInitializer");
  function MJe(e, t) {
    t.unshiftContainer("body", O.types.expressionStatement(to(e)));
  }
  n(MJe, "prependExpressionsToStaticBlock");
  function RJe(e, t) {
    t.node.body.body.unshift(O.types.expressionStatement(to(e)));
  }
  n(RJe, "prependExpressionsToConstructor");
  function AJ(e, t) {
    return O.types.isCallExpression(e) && O.types.isIdentifier(e.callee, {
      name: t.name
    });
  }
  n(AJ, "isProtoInitCallExpression");
  function LJe(e, t) {
    if (t) {
      if (e.length >= 2 && AJ(e[1], t)) {
        let r = O.types.callExpression(O.types.cloneNode(t), [e[0]]);
        e.splice(0, 2, r);
      }
      e.length >= 2 && O.types.isThisExpression(e[e.length - 1]) && AJ(e[e.length - 2], t) && e.splice(e.length - 1, 1);
    }
    return to(e);
  }
  n(LJe, "optimizeSuperCallAndExpressions");
  function jJe(e, t, r) {
    t.traverse({
      CallExpression: {
        exit(i) {
          if (!i.get("callee").isSuper()) return;
          let s = [i.node, ...e.map((a) => O.types.cloneNode(a))];
          i.isCompletionRecord() && s.push(O.types.thisExpression()), i.replaceWith(LJe(s, r)), i.skip();
        }
      },
      ClassMethod(i) {
        i.node.kind === "constructor" && i.skip();
      }
    });
  }
  n(jJe, "insertExpressionsAfterSuperCallAndOptimize");
  function _J(e, t) {
    let r = [O.types.expressionStatement(to(e))];
    return t && r.unshift(O.types.expressionStatement(O.types.callExpression(O.types.super(), [O.types.spreadElement(O.types.identifier("arg\
s"))]))), O.types.classMethod("constructor", O.types.identifier("constructor"), t ? [O.types.restElement(O.types.identifier("args"))] : [], O.
    types.blockStatement(r));
  }
  n(_J, "createConstructorFromExpressions");
  function PJ(e) {
    return O.types.staticBlock([O.types.expressionStatement(to(e))]);
  }
  n(PJ, "createStaticBlockFromExpressions");
  var Eu = 0, eo = 1, qJe = 2, NJ = 3, Ng = 4, UJe = 5, $Je = 8, VJe = 16;
  function WJe(e) {
    switch (e.node.type) {
      case "ClassProperty":
      case "ClassPrivateProperty":
        return Eu;
      case "ClassAccessorProperty":
        return eo;
      case "ClassMethod":
      case "ClassPrivateMethod":
        return e.node.kind === "get" ? NJ : e.node.kind === "set" ? Ng : qJe;
    }
  }
  n(WJe, "getElementKind");
  function HJe(e) {
    return [...e.filter((t) => t.isStatic && t.kind >= eo && t.kind <= Ng), ...e.filter((t) => !t.isStatic && t.kind >= eo && t.kind <= Ng),
    ...e.filter((t) => t.isStatic && t.kind === Eu), ...e.filter((t) => !t.isStatic && t.kind === Eu)];
  }
  n(HJe, "toSortedDecoratorInfo");
  function FJ(e, t, r) {
    let i = e.length, s = t.some(Boolean), a = [];
    for (let o = 0; o < i; o++)
      (r === "2023-11" || r === "2023-05") && s && a.push(t[o] || O.types.unaryExpression("void", O.types.numericLiteral(0))), a.push(e[o].expression);
    return {
      haveThis: s,
      decs: a
    };
  }
  n(FJ, "generateDecorationList");
  function KJe(e, t) {
    return O.types.arrayExpression(e.map((r) => {
      let i = r.kind;
      return r.isStatic && (i += t === "2023-11" || t === "2023-05" ? $Je : UJe), r.decoratorsHaveThis && (i += VJe), O.types.arrayExpression(
      [r.decoratorsArray, O.types.numericLiteral(i), r.name, ...r.privateMethods || []]);
    }));
  }
  n(KJe, "generateDecorationExprs");
  function zJe(e) {
    let t = [];
    for (let r of e) {
      let {
        locals: i
      } = r;
      Array.isArray(i) ? t.push(...i) : i !== void 0 && t.push(i);
    }
    return t;
  }
  n(zJe, "extractElementLocalAssignments");
  function JJe(e, t, r, i, s, a) {
    t.insertAfter(O.types.classPrivateMethod("get", O.types.cloneNode(r), [], O.types.blockStatement([O.types.returnStatement(O.types.callExpression(
    O.types.cloneNode(i), e === "2023-11" && a ? [] : [O.types.thisExpression()]))]), a)), t.insertAfter(O.types.classPrivateMethod("set", O.
    types.cloneNode(r), [O.types.identifier("v")], O.types.blockStatement([O.types.expressionStatement(O.types.callExpression(O.types.cloneNode(
    s), e === "2023-11" && a ? [O.types.identifier("v")] : [O.types.thisExpression(), O.types.identifier("v")]))]), a));
  }
  n(JJe, "addCallAccessorsFor");
  function XJe(e, t, r, i) {
    let s, a;
    e.node.kind === "set" ? (s = [O.types.identifier("v")], a = [O.types.expressionStatement(O.types.callExpression(r, [O.types.thisExpression(),
    O.types.identifier("v")]))]) : (s = [], a = [O.types.returnStatement(O.types.callExpression(r, [O.types.thisExpression()]))]), e.replaceWith(
    O.types.classPrivateMethod(e.node.kind, O.types.cloneNode(t), s, O.types.blockStatement(a), i));
  }
  n(XJe, "movePrivateAccessor");
  function IJ(e) {
    let {
      type: t
    } = e;
    return t !== "TSDeclareMethod" && t !== "TSIndexSignature" && t !== "StaticBlock";
  }
  n(IJ, "isClassDecoratableElementPath");
  function YJe(e) {
    return O.types.callExpression(O.types.arrowFunctionExpression([], O.types.blockStatement(e.body)), []);
  }
  n(YJe, "staticBlockToIIFE");
  function GJe(e) {
    return O.types.functionExpression(null, [], O.types.blockStatement(e.body));
  }
  n(GJe, "staticBlockToFunctionClosure");
  function ZJe(e) {
    return O.types.functionExpression(null, [], O.types.blockStatement([O.types.returnStatement(e)]));
  }
  n(ZJe, "fieldInitializerToClosure");
  function to(e) {
    return e.length === 0 ? O.types.unaryExpression("void", O.types.numericLiteral(0)) : e.length === 1 ? e[0] : O.types.sequenceExpression(
    e);
  }
  n(to, "maybeSequenceExpression");
  function OJ(e) {
    let {
      params: t,
      body: r,
      generator: i,
      async: s
    } = e;
    return O.types.functionExpression(void 0, t, r, i, s);
  }
  n(OJ, "createFunctionExpressionFromPrivateMethod");
  function MJ(e, t) {
    return O.types.callExpression(e.addHelper("setFunctionName"), [O.types.thisExpression(), t]);
  }
  n(MJ, "createSetFunctionNameCall");
  function z3(e, t) {
    return O.types.callExpression(e.addHelper("toPropertyKey"), [t]);
  }
  n(z3, "createToPropertyKeyCall");
  function W3(e) {
    return O.types.arrowFunctionExpression([O.types.identifier("_")], O.types.binaryExpression("in", O.types.cloneNode(e), O.types.identifier(
    "_")));
  }
  n(W3, "createPrivateBrandCheckClosure");
  function QJe(e) {
    try {
      return O.types.traverseFast(e, (t) => {
        if (O.types.isPrivateName(t))
          throw null;
      }), !1;
    } catch {
      return !0;
    }
  }
  n(QJe, "usesPrivateField");
  function eXe(e) {
    let {
      node: t
    } = e;
    t.computed = !0, O.types.isIdentifier(t.key) && (t.key = O.types.stringLiteral(t.key.name));
  }
  n(eXe, "convertToComputedKey");
  function H3(e, t) {
    let r = !1;
    if (t.length > 0) {
      let i = (0, kJ.privateNameVisitorFactory)({
        PrivateName(a, o) {
          o.privateNamesMap.has(a.node.id.name) && (r = !0, a.stop());
        }
      }), s = /* @__PURE__ */ new Map();
      for (let a of t)
        s.set(a, null);
      e.traverse(i, {
        privateNamesMap: s
      });
    }
    return r;
  }
  n(H3, "hasInstancePrivateAccess");
  function tXe(e, t) {
    let r = (0, kJ.privateNameVisitorFactory)({
      PrivateName(s, a) {
        if (!a.privateNamesMap.has(s.node.id.name)) return;
        let o = s.parentPath, u = o.parentPath;
        if (u.node.type === "AssignmentExpression" && u.node.left === o.node || u.node.type === "UpdateExpression" || u.node.type === "RestE\
lement" || u.node.type === "ArrayPattern" || u.node.type === "ObjectProperty" && u.node.value === o.node && u.parentPath.type === "ObjectPat\
tern" || u.node.type === "ForOfStatement" && u.node.left === o.node)
          throw s.buildCodeFrameError(`Decorated private methods are read-only, but "#${s.node.id.name}" is updated via this expression.`);
      }
    }), i = /* @__PURE__ */ new Map();
    for (let s of t)
      i.set(s, null);
    e.traverse(r, {
      privateNamesMap: i
    });
  }
  n(tXe, "checkPrivateMethodUpdateError");
  function rXe(e, t, r, i, s, a, o) {
    var u;
    let l = e.get("body.body"), c = e.node.decorators, f = !1, m = !1, h = !1, d = OJe(e), y = [], p = e.scope.parent, g = /* @__PURE__ */ n(
    (pe, oe, Re) => {
      let bt = Ii(p, oe);
      return Re.push(O.types.assignmentExpression("=", bt, pe)), O.types.cloneNode(bt);
    }, "memoiseExpression"), b, D, x = (u = e.node.id) == null ? void 0 : u.name, T = typeof s == "object" ? s : void 0, w = /* @__PURE__ */ n(
    (pe) => {
      try {
        return O.types.traverseFast(pe, (oe) => {
          if (O.types.isThisExpression(oe) || O.types.isSuper(oe) || O.types.isYieldExpression(oe) || O.types.isAwaitExpression(oe) || O.types.
          isIdentifier(oe, {
            name: "arguments"
          }) || x && O.types.isIdentifier(oe, {
            name: x
          }) || O.types.isMetaProperty(oe) && oe.meta.name !== "import")
            throw null;
        }), !1;
      } catch {
        return !0;
      }
    }, "usesFunctionContextOrYieldAwait"), B = [];
    for (let pe of l) {
      if (!IJ(pe))
        continue;
      let oe = pe.node;
      if (!oe.static && O.types.isPrivateName(oe.key) && B.push(oe.key.id.name), Kp(oe)) {
        switch (oe.type) {
          case "ClassProperty":
            a.ClassProperty(pe, t);
            break;
          case "ClassPrivateProperty":
            a.ClassPrivateProperty(pe, t);
            break;
          case "ClassAccessorProperty":
            if (a.ClassAccessorProperty(pe, t), o === "2023-11")
              break;
          default:
            oe.static ? D ?? (D = Ii(p, "initStatic")) : b ?? (b = Ii(p, "initProto"));
            break;
        }
        f = !0, h || (h = oe.decorators.some(w));
      } else if (oe.type === "ClassAccessorProperty") {
        a.ClassAccessorProperty(pe, t);
        let {
          key: Re,
          value: bt,
          static: Kt,
          computed: xt
        } = oe, fr = d(), os = TJ(fr, bt, Kt), rr = pe.get("key"), [mr] = pe.replaceWith(os), Gr, yr;
        xt && !rr.isConstantExpression() ? (Gr = (0, Bg.memoiseComputedKey)(z3(t, Re), p, p.generateUid("computedKey")), yr = O.types.cloneNode(
        Gr.left)) : (Gr = O.types.cloneNode(Re), yr = O.types.cloneNode(Re)), $3(e, s), CJ(e.node.id, mr, Gr, yr, fr, xt, Kt, o);
      }
      "computed" in pe.node && pe.node.computed && (m || (m = !p.isStatic(pe.node.key)));
    }
    if (!c && !f) {
      !e.node.id && typeof s == "string" && (e.node.id = O.types.identifier(s)), T && e.node.body.body.unshift(PJ([MJ(t, T)]));
      return;
    }
    let k = [], q, V = /* @__PURE__ */ new Set(), Y, G, ye = null;
    function te(pe) {
      let oe = !1, Re = !1, bt = [];
      for (let Kt of pe) {
        let {
          expression: xt
        } = Kt, fr;
        (o === "2023-11" || o === "2023-05") && O.types.isMemberExpression(xt) && (O.types.isSuper(xt.object) ? fr = O.types.thisExpression() :
        p.isStatic(xt.object) ? fr = O.types.cloneNode(xt.object) : (ye ?? (ye = Ii(p, "obj")), fr = O.types.assignmentExpression("=", O.types.
        cloneNode(ye), xt.object), xt.object = O.types.cloneNode(ye))), bt.push(fr), oe || (oe = !p.isStatic(xt)), Re || (Re = w(Kt));
      }
      return {
        hasSideEffects: oe,
        usesFnContext: Re,
        decoratorsThis: bt
      };
    }
    n(te, "handleDecorators");
    let re = m || h || o !== "2023-11", ve = !1, je = 0, Be = [], se, Ne = [];
    if (c) {
      Y = Ii(p, "initClass"), ve = e.isClassDeclaration(), {
        id: G,
        path: e
      } = kJe(e, s), e.node.decorators = null;
      let pe = c.some(QJe), {
        hasSideEffects: oe,
        usesFnContext: Re,
        decoratorsThis: bt
      } = te(c), {
        haveThis: Kt,
        decs: xt
      } = FJ(c, bt, o);
      if (je = Kt ? 1 : 0, Be = xt, (Re || oe && re || pe) && (se = g(O.types.arrayExpression(Be), "classDecs", y)), !f)
        for (let fr of e.get("body.body")) {
          let {
            node: os
          } = fr;
          if ("computed" in os && os.computed)
            if (fr.isClassProperty({
              static: !0
            })) {
              if (!fr.get("key").isConstantExpression()) {
                let mr = os.key, Gr = (0, Bg.memoiseComputedKey)(mr, p, p.generateUid("computedKey"));
                Gr != null && (os.key = O.types.cloneNode(Gr.left), Ne.push(Gr));
              }
            } else Ne.length > 0 && (Hp(Ne, fr), Ne = []);
        }
    } else
      $3(e, s), G = O.types.cloneNode(e.node.id);
    let ke, Cr = !1, Ae = [], _e = [];
    if (f) {
      if (b) {
        let pe = O.types.callExpression(O.types.cloneNode(b), [O.types.thisExpression()]);
        Ae.push(pe);
      }
      for (let pe of l) {
        if (!IJ(pe)) {
          _e.length > 0 && pe.isStaticBlock() && (MJe(_e, pe), _e = []);
          continue;
        }
        let {
          node: oe
        } = pe, Re = oe.decorators, bt = !!(Re != null && Re.length), Kt = "computed" in oe && oe.computed, xt = "computedKey";
        oe.key.type === "PrivateName" ? xt = oe.key.id.name : !Kt && oe.key.type === "Identifier" && (xt = oe.key.name);
        let fr, os;
        if (bt) {
          let {
            hasSideEffects: ci,
            usesFnContext: wr,
            decoratorsThis: Di
          } = te(Re), {
            decs: vi,
            haveThis: Mi
          } = FJ(Re, Di, o);
          os = Mi, fr = vi.length === 1 ? vi[0] : O.types.arrayExpression(vi), (wr || ci && re) && (fr = g(fr, xt + "Decs", Ne));
        }
        if (Kt && !pe.get("key").isConstantExpression()) {
          let ci = oe.key, wr = (0, Bg.memoiseComputedKey)(bt ? z3(t, ci) : ci, p, p.generateUid("computedKey"));
          wr != null && (c && pe.isClassProperty({
            static: !0
          }) ? (oe.key = O.types.cloneNode(wr.left), Ne.push(wr)) : oe.key = wr);
        }
        let {
          key: rr,
          static: mr
        } = oe, Gr = rr.type === "PrivateName", yr = WJe(pe);
        Gr && !mr && (bt && (Cr = !0), (O.types.isClassPrivateProperty(oe) || !ke) && (ke = rr)), pe.isClassMethod({
          kind: "constructor"
        }) && (q = pe);
        let ca;
        if (bt) {
          let ci, wr;
          if (Kt ? wr = BJe(pe.get("key")) : rr.type === "PrivateName" ? wr = O.types.stringLiteral(rr.id.name) : rr.type === "Identifier" ?
          wr = O.types.stringLiteral(rr.name) : wr = O.types.cloneNode(rr), yr === eo) {
            let {
              value: Di
            } = pe.node, vi = o === "2023-11" && mr ? [] : [O.types.thisExpression()];
            Di && vi.push(O.types.cloneNode(Di));
            let Mi = d(), Jc = Ii(p, `init_${xt}`), bb = O.types.callExpression(O.types.cloneNode(Jc), vi), Db = TJ(Mi, bb, mr), [ch] = pe.replaceWith(
            Db);
            if (Gr) {
              ci = wJ(Mi, o);
              let fh = Ii(p, `get_${xt}`), dh = Ii(p, `set_${xt}`);
              JJe(o, ch, rr, fh, dh, mr), ca = [Jc, fh, dh];
            } else
              $3(e, s), CJ(e.node.id, ch, O.types.cloneNode(rr), O.types.isAssignmentExpression(rr) ? O.types.cloneNode(rr.left) : O.types.cloneNode(
              rr), Mi, Kt, mr, o), ca = [Jc];
          } else if (yr === Eu) {
            let Di = Ii(p, `init_${xt}`), vi = pe.get("value"), Mi = o === "2023-11" && mr ? [] : [O.types.thisExpression()];
            vi.node && Mi.push(vi.node), vi.replaceWith(O.types.callExpression(O.types.cloneNode(Di), Mi)), ca = [Di], Gr && (ci = wJ(rr, o));
          } else if (Gr) {
            let Di = Ii(p, `call_${xt}`);
            if (ca = [Di], new SJ.default({
              constantSuper: r,
              methodPath: pe,
              objectRef: G,
              superRef: e.node.superClass,
              file: t.file,
              refToPreserve: G
            }).replace(), ci = [OJ(pe.node)], yr === NJ || yr === Ng)
              XJe(pe, O.types.cloneNode(rr), O.types.cloneNode(Di), mr);
            else {
              let Mi = pe.node;
              e.node.body.body.unshift(O.types.classPrivateProperty(rr, O.types.cloneNode(Di), [], Mi.static)), V.add(rr.id.name), pe.remove();
            }
          }
          k.push({
            kind: yr,
            decoratorsArray: fr,
            decoratorsHaveThis: os,
            name: wr,
            isStatic: mr,
            privateMethods: ci,
            locals: ca
          }), pe.node && (pe.node.decorators = null);
        }
        if (Kt && Ne.length > 0 && (c && pe.isClassProperty({
          static: !0
        }) || (Hp(Ne, yr === eo ? pe.getNextSibling() : pe), Ne = [])), Ae.length > 0 && !mr && (yr === Eu || yr === eo) && (V3(Ae, pe), Ae =
        []), _e.length > 0 && mr && (yr === Eu || yr === eo) && (V3(_e, pe), _e = []), bt && o === "2023-11" && (yr === Eu || yr === eo)) {
          let ci = Ii(p, `init_extra_${xt}`);
          ca.push(ci);
          let wr = O.types.callExpression(O.types.cloneNode(ci), mr ? [] : [O.types.thisExpression()]);
          mr ? _e.push(wr) : Ae.push(wr);
        }
      }
    }
    if (Ne.length > 0) {
      let pe = e.get("body.body"), oe;
      for (let Re = pe.length - 1; Re >= 0; Re--) {
        let bt = pe[Re], Kt = bt.node;
        if (Kt.computed) {
          if (c && O.types.isClassProperty(Kt, {
            static: !0
          }))
            continue;
          oe = bt;
          break;
        }
      }
      oe != null && (NJe(Ne, oe), Ne = []);
    }
    if (Ae.length > 0) {
      let pe = !!e.node.superClass;
      q ? pe ? jJe(Ae, q, b) : RJe(Ae, q) : e.node.body.body.unshift(_J(Ae, pe)), Ae = [];
    }
    _e.length > 0 && (e.node.body.body.push(PJ(_e)), _e = []);
    let Me = HJe(k), Nt = KJe(o === "2023-11" ? k : Me, o), tr = zJe(Me);
    b && tr.push(b), D && tr.push(D);
    let Yr = [], Ni = !1, pn = Y && O.types.callExpression(O.types.cloneNode(Y), []), co = e, Os = e.node, ks = [];
    if (c) {
      Yr.push(G, Y);
      let pe = [];
      if (e.get("body.body").forEach((oe) => {
        if (oe.isStaticBlock()) {
          if (H3(oe, B)) {
            let Re = g(GJe(oe.node), "staticBlock", ks);
            _e.push(O.types.callExpression(O.types.memberExpression(Re, O.types.identifier("call")), [O.types.thisExpression()]));
          } else
            _e.push(YJe(oe.node));
          oe.remove();
          return;
        }
        if ((oe.isClassProperty() || oe.isClassPrivateProperty()) && oe.node.static) {
          let Re = oe.get("value");
          if (H3(Re, B)) {
            let bt = g(ZJe(Re.node), "fieldValue", ks);
            Re.replaceWith(O.types.callExpression(O.types.memberExpression(bt, O.types.identifier("call")), [O.types.thisExpression()]));
          }
          _e.length > 0 && (V3(_e, oe), _e = []), oe.node.static = !1, pe.push(oe.node), oe.remove();
        } else if (oe.isClassPrivateMethod({
          static: !0
        })) {
          if (H3(oe, B)) {
            new SJ.default({
              constantSuper: r,
              methodPath: oe,
              objectRef: G,
              superRef: e.node.superClass,
              file: t.file,
              refToPreserve: G
            }).replace();
            let bt = g(OJ(oe.node), oe.get("key.id").node.name, ks);
            i ? (oe.node.params = [O.types.restElement(O.types.identifier("arg"))], oe.node.body = O.types.blockStatement([O.types.returnStatement(
            O.types.callExpression(O.types.memberExpression(bt, O.types.identifier("apply")), [O.types.thisExpression(), O.types.identifier(
            "arg")]))])) : (oe.node.params = oe.node.params.map((Kt, xt) => O.types.isRestElement(Kt) ? O.types.restElement(O.types.identifier(
            "arg")) : O.types.identifier("_" + xt)), oe.node.body = O.types.blockStatement([O.types.returnStatement(O.types.callExpression(O.
            types.memberExpression(bt, O.types.identifier("apply")), [O.types.thisExpression(), O.types.identifier("arguments")]))]));
          }
          oe.node.static = !1, pe.push(oe.node), oe.remove();
        }
      }), pe.length > 0 || _e.length > 0) {
        let oe = O.template.expression.ast`
        class extends ${t.addHelper("identity")} {}
      `;
        oe.body.body = [O.types.classProperty(O.types.toExpression(Os), void 0, void 0, void 0, !0, !0), ...pe];
        let Re = [], bt = O.types.newExpression(oe, []);
        _e.length > 0 && Re.push(..._e), pn && (Ni = !0, Re.push(pn)), Re.length > 0 ? (Re.unshift(O.types.callExpression(O.types.super(), [
        O.types.cloneNode(G)])), oe.body.body.push(_J(Re, !1))) : bt.arguments.push(O.types.cloneNode(G));
        let [Kt] = e.replaceWith(bt);
        co = Kt.get("callee").get("body").get("body.0.key");
      }
    }
    !Ni && pn && e.node.body.body.push(O.types.staticBlock([O.types.expressionStatement(pn)]));
    let {
      superClass: Bs
    } = Os;
    if (Bs && (o === "2023-11" || o === "2023-05")) {
      let pe = e.scope.maybeGenerateMemoised(Bs);
      pe && (Os.superClass = O.types.assignmentExpression("=", pe, Bs), Bs = pe);
    }
    let fo = O.types.staticBlock([]);
    Os.body.body.unshift(fo);
    let Vu = fo.body;
    if (Ne.length > 0) {
      let pe = co.get("body.body"), oe;
      for (let Re of pe)
        if ((Re.isClassProperty() || Re.isClassMethod()) && Re.node.kind !== "constructor") {
          oe = Re;
          break;
        }
      oe != null ? (eXe(oe), Hp(Ne, oe)) : (Os.body.body.unshift(O.types.classProperty(O.types.sequenceExpression([...Ne, O.types.stringLiteral(
      "_")]), void 0, void 0, void 0, !0, !0)), Vu.push(O.types.expressionStatement(O.types.unaryExpression("delete", O.types.memberExpression(
      O.types.thisExpression(), O.types.identifier("_")))))), Ne = [];
    }
    if (Vu.push(O.types.expressionStatement(iXe(tr, Yr, Nt, se ?? O.types.arrayExpression(Be), O.types.numericLiteral(je), Cr ? ke : null, T,
    O.types.cloneNode(Bs), t, o))), D && Vu.push(O.types.expressionStatement(O.types.callExpression(O.types.cloneNode(D), [O.types.thisExpression()]))),
    ks.length > 0 && Vu.push(...ks.map((pe) => O.types.expressionStatement(pe))), e.insertBefore(y.map((pe) => O.types.expressionStatement(pe))),
    ve)
      if (!p.getBinding(G.name).constantViolations.length)
        e.insertBefore(O.types.variableDeclaration("let", [O.types.variableDeclarator(O.types.cloneNode(G))]));
      else {
        let oe = p.generateUidIdentifier("t" + G.name), Re = G;
        e.replaceWithMultiple([O.types.variableDeclaration("let", [O.types.variableDeclarator(O.types.cloneNode(Re)), O.types.variableDeclarator(
        oe)]), O.types.blockStatement([O.types.variableDeclaration("let", [O.types.variableDeclarator(O.types.cloneNode(G))]), e.node, O.types.
        expressionStatement(O.types.assignmentExpression("=", O.types.cloneNode(oe), O.types.cloneNode(G)))]), O.types.expressionStatement(O.
        types.assignmentExpression("=", O.types.cloneNode(Re), O.types.cloneNode(oe)))]);
      }
    return V.size > 0 && tXe(e, V), e.scope.crawl(), e;
  }
  n(rXe, "transformClass");
  function iXe(e, t, r, i, s, a, o, u, l, c) {
    let f, m, h = [o ? MJ(l, o) : O.types.thisExpression(), i, r];
    {
      if (c !== "2023-11" && h.splice(1, 2, r, i), c === "2021-12" || c === "2022-03" && !l.availableHelper("applyDecs2203R"))
        return f = O.types.arrayPattern([...e, ...t]), m = O.types.callExpression(l.addHelper(c === "2021-12" ? "applyDecs" : "applyDecs2203"),
        h), O.types.assignmentExpression("=", f, m);
      c === "2022-03" ? m = O.types.callExpression(l.addHelper("applyDecs2203R"), h) : c === "2023-01" ? (a && h.push(W3(a)), m = O.types.callExpression(
      l.addHelper("applyDecs2301"), h)) : c === "2023-05" && ((a || u || s.value !== 0) && h.push(s), a ? h.push(W3(a)) : u && h.push(O.types.
      unaryExpression("void", O.types.numericLiteral(0))), u && h.push(u), m = O.types.callExpression(l.addHelper("applyDecs2305"), h));
    }
    return c === "2023-11" && ((a || u || s.value !== 0) && h.push(s), a ? h.push(W3(a)) : u && h.push(O.types.unaryExpression("void", O.types.
    numericLiteral(0))), u && h.push(u), m = O.types.callExpression(l.addHelper("applyDecs2311"), h)), e.length > 0 ? t.length > 0 ? f = O.types.
    objectPattern([O.types.objectProperty(O.types.identifier("e"), O.types.arrayPattern(e)), O.types.objectProperty(O.types.identifier("c"),
    O.types.arrayPattern(t))]) : (f = O.types.arrayPattern(e), m = O.types.memberExpression(m, O.types.identifier("e"), !1, !1)) : (f = O.types.
    arrayPattern(t), m = O.types.memberExpression(m, O.types.identifier("c"), !1, !1)), O.types.assignmentExpression("=", f, m);
  }
  n(iXe, "createLocalsAssignment");
  function sXe(e) {
    return e.type === "Identifier" ? e.name === "__proto__" : e.value === "__proto__";
  }
  n(sXe, "isProtoKey");
  function Kp(e) {
    return e.decorators && e.decorators.length > 0;
  }
  n(Kp, "isDecorated");
  function nXe(e) {
    switch (e.type) {
      case "ClassAccessorProperty":
        return !0;
      case "ClassMethod":
      case "ClassProperty":
      case "ClassPrivateMethod":
      case "ClassPrivateProperty":
        return Kp(e);
      default:
        return !1;
    }
  }
  n(nXe, "shouldTransformElement");
  function aXe(e) {
    return Kp(e) || e.body.body.some(nXe);
  }
  n(aXe, "shouldTransformClass");
  function RJ(e, t) {
    function r(i, s, a) {
      switch (s.type) {
        case "StringLiteral":
          return O.types.stringLiteral(s.value);
        case "NumericLiteral":
        case "BigIntLiteral": {
          let o = s.value + "";
          return i.get("key").replaceWith(O.types.stringLiteral(o)), O.types.stringLiteral(o);
        }
        default: {
          let o = i.scope.maybeGenerateMemoised(s);
          return i.get("key").replaceWith(O.types.assignmentExpression("=", o, z3(a, s))), O.types.cloneNode(o);
        }
      }
    }
    return n(r, "handleComputedProperty"), {
      VariableDeclarator(i, s) {
        let a = i.node.id;
        if (a.type === "Identifier") {
          let o = (0, Qa.skipTransparentExprWrappers)(i.get("init"));
          if (e(o)) {
            let u = a.name;
            t(o, s, u);
          }
        }
      },
      AssignmentExpression(i, s) {
        let a = i.node.left;
        if (a.type === "Identifier") {
          let o = (0, Qa.skipTransparentExprWrappers)(i.get("right"));
          if (e(o))
            switch (i.node.operator) {
              case "=":
              case "&&=":
              case "||=":
              case "??=":
                t(o, s, a.name);
            }
        }
      },
      AssignmentPattern(i, s) {
        let a = i.node.left;
        if (a.type === "Identifier") {
          let o = (0, Qa.skipTransparentExprWrappers)(i.get("right"));
          if (e(o)) {
            let u = a.name;
            t(o, s, u);
          }
        }
      },
      ObjectExpression(i, s) {
        for (let a of i.get("properties")) {
          if (!a.isObjectProperty()) continue;
          let {
            node: o
          } = a, u = o.key, l = (0, Qa.skipTransparentExprWrappers)(a.get("value"));
          if (e(l)) {
            if (o.computed) {
              let c = r(a, u, s);
              t(l, s, c);
            } else if (!sXe(u))
              if (u.type === "Identifier")
                t(l, s, u.name);
              else {
                let c = O.types.stringLiteral(u.value + "");
                t(l, s, c);
              }
          }
        }
      },
      ClassPrivateProperty(i, s) {
        let {
          node: a
        } = i, o = (0, Qa.skipTransparentExprWrappers)(i.get("value"));
        if (e(o)) {
          let u = O.types.stringLiteral("#" + a.key.id.name);
          t(o, s, u);
        }
      },
      ClassAccessorProperty(i, s) {
        let {
          node: a
        } = i, o = a.key, u = (0, Qa.skipTransparentExprWrappers)(i.get("value"));
        if (e(u))
          if (a.computed) {
            let l = r(i, o, s);
            t(u, s, l);
          } else if (o.type === "Identifier")
            t(u, s, o.name);
          else if (o.type === "PrivateName") {
            let l = O.types.stringLiteral("#" + o.id.name);
            t(u, s, l);
          } else {
            let l = O.types.stringLiteral(o.value + "");
            t(u, s, l);
          }
      },
      ClassProperty(i, s) {
        let {
          node: a
        } = i, o = a.key, u = (0, Qa.skipTransparentExprWrappers)(i.get("value"));
        if (e(u))
          if (a.computed) {
            let l = r(i, o, s);
            t(u, s, l);
          } else if (o.type === "Identifier")
            t(u, s, o.name);
          else {
            let l = O.types.stringLiteral(o.value + "");
            t(u, s, l);
          }
      }
    };
  }
  n(RJ, "buildNamedEvaluationVisitor");
  function oXe(e) {
    return e.isClassExpression({
      id: null
    }) && aXe(e.node);
  }
  n(oXe, "isDecoratedAnonymousClassExpression");
  function Ii(e, t) {
    let r = e.generateUidIdentifier(t);
    return e.push({
      id: r,
      kind: "let"
    }), O.types.cloneNode(r);
  }
  n(Ii, "generateLetUidIdentifier");
  function uXe({
    assertVersion: e,
    assumption: t
  }, {
    loose: r
  }, i, s) {
    var a, o;
    e(i === "2023-11" || i === "2023-05" || i === "2023-01" ? "^7.21.0" : i === "2021-12" ? "^7.16.0" : "^7.19.0");
    let u = /* @__PURE__ */ new WeakSet(), l = (a = t("constantSuper")) != null ? a : r, c = (o = t("ignoreFunctionLength")) != null ? o : r,
    f = RJ(oXe, m);
    function m(h, d, y) {
      var p;
      if (u.has(h)) return;
      let {
        node: g
      } = h;
      y ?? (y = (p = g.id) == null ? void 0 : p.name);
      let b = rXe(h, d, l, c, y, f, i);
      if (b) {
        u.add(b);
        return;
      }
      u.add(h);
    }
    return n(m, "visitClass"), {
      name: "proposal-decorators",
      inherits: s,
      visitor: Object.assign({
        ExportDefaultDeclaration(h, d) {
          let {
            declaration: y
          } = h.node;
          if (y?.type === "ClassDeclaration" && Kp(y)) {
            let g = !y.id;
            {
              var p;
              (p = h.splitExportDeclaration) != null || (h.splitExportDeclaration = ir().NodePath.prototype.splitExportDeclaration);
            }
            let b = h.splitExportDeclaration();
            g && m(b, d, O.types.stringLiteral("default"));
          }
        },
        ExportNamedDeclaration(h) {
          let {
            declaration: d
          } = h.node;
          if (d?.type === "ClassDeclaration" && Kp(d)) {
            {
              var y;
              (y = h.splitExportDeclaration) != null || (h.splitExportDeclaration = ir().NodePath.prototype.splitExportDeclaration);
            }
            h.splitExportDeclaration();
          }
        },
        Class(h, d) {
          m(h, d, void 0);
        }
      }, f)
    };
  }
  n(uXe, "_default");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js
var jJ = E((Y3) => {
  "use strict";
  Object.defineProperty(Y3, "__esModule", {
    value: !0
  });
  Y3.buildDecoratedClass = hXe;
  var vt = Gt(), lXe = Pg();
  function _c(e, t) {
    return t ? vt.types.objectProperty(vt.types.identifier(e), t) : null;
  }
  n(_c, "prop");
  function cXe(e, t) {
    return vt.types.objectMethod("method", vt.types.identifier(e), [], vt.types.blockStatement(t));
  }
  n(cXe, "method");
  function LJ(e) {
    let t;
    return e.decorators && e.decorators.length > 0 && (t = vt.types.arrayExpression(e.decorators.map((r) => r.expression))), e.decorators = void 0,
    t;
  }
  n(LJ, "takeDecorators");
  function fXe(e) {
    return e.computed ? e.key : vt.types.isIdentifier(e.key) ? vt.types.stringLiteral(e.key.name) : vt.types.stringLiteral(String(e.key.value));
  }
  n(fXe, "getKey");
  function dXe(e, t, r, i) {
    let s = i.isClassMethod();
    if (i.isPrivate())
      throw i.buildCodeFrameError(`Private ${s ? "methods" : "fields"} in decorated classes are not supported yet.`);
    if (i.node.type === "ClassAccessorProperty")
      throw i.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-1\
2" } instead.');
    if (i.node.type === "StaticBlock")
      throw i.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } i\
nstead.');
    let {
      node: a,
      scope: o
    } = i;
    i.isTSDeclareMethod() || new lXe.default({
      methodPath: i,
      objectRef: t,
      superRef: r,
      file: e,
      refToPreserve: t
    }).replace();
    let u = [_c("kind", vt.types.stringLiteral(vt.types.isClassMethod(a) ? a.kind : "field")), _c("decorators", LJ(a)), _c("static", a.static &&
    vt.types.booleanLiteral(!0)), _c("key", fXe(a))].filter(Boolean);
    if (s) {
      {
        var l;
        (l = i.ensureFunctionName) != null || (i.ensureFunctionName = ir().NodePath.prototype.ensureFunctionName);
      }
      i.ensureFunctionName(!1), u.push(_c("value", vt.types.toExpression(i.node)));
    } else vt.types.isClassProperty(a) && a.value ? u.push(cXe("value", vt.template.statements.ast`return ${a.value}`)) : u.push(_c("value",
    o.buildUndefinedNode()));
    return i.remove(), vt.types.objectExpression(u);
  }
  n(dXe, "extractElementDescriptor");
  function pXe(e) {
    return e.addHelper("decorate");
  }
  n(pXe, "addDecorateHelper");
  function hXe(e, t, r, i) {
    let {
      node: s,
      scope: a
    } = t, o = a.generateUidIdentifier("initialize"), u = s.id && t.isDeclaration(), l = t.isInStrictMode(), {
      superClass: c
    } = s;
    s.type = "ClassDeclaration", s.id || (s.id = vt.types.cloneNode(e));
    let f;
    c && (f = a.generateUidIdentifierBasedOnNode(s.superClass, "super"), s.superClass = f);
    let m = LJ(s), h = vt.types.arrayExpression(r.filter((g) => !g.node.abstract && g.node.type !== "TSIndexSignature").map((g) => dXe(i, s.
    id, f, g))), d = vt.template.expression.ast`
    ${pXe(i)}(
      ${m || vt.types.nullLiteral()},
      function (${o}, ${c ? vt.types.cloneNode(f) : null}) {
        ${s}
        return { F: ${vt.types.cloneNode(s.id)}, d: ${h} };
      },
      ${c}
    )
  `;
    l || d.arguments[1].body.directives.push(vt.types.directive(vt.types.directiveLiteral("use strict")));
    let y = d, p = "arguments.1.body.body.0";
    return u && (y = vt.template.statement.ast`let ${e} = ${d}`, p = "declarations.0.init." + p), {
      instanceNodes: [vt.template.statement.ast`
        ${vt.types.cloneNode(o)}(this)
      `],
      wrapClass(g) {
        return g.replaceWith(y), g.get(p);
      }
    };
  }
  n(hXe, "buildDecoratedClass");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/features.js
var VJ = E((Su) => {
  "use strict";
  Object.defineProperty(Su, "__esModule", {
    value: !0
  });
  Su.FEATURES = void 0;
  Su.enableFeature = mXe;
  Su.isLoose = Q3;
  Su.shouldTransform = yXe;
  var qJ = X3(), ra = Su.FEATURES = Object.freeze({
    fields: 2,
    privateMethods: 4,
    decorators: 8,
    privateIn: 16,
    staticBlocks: 32
  }), UJ = /* @__PURE__ */ new Map([[ra.fields, "@babel/plugin-transform-class-properties"], [ra.privateMethods, "@babel/plugin-transform-pr\
ivate-methods"], [ra.privateIn, "@babel/plugin-transform-private-property-in-object"]]), G3 = "@babel/plugin-class-features/featuresKey", zp = "\
@babel/plugin-class-features/looseKey";
  ro = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
  var ro;
  Z3 = /* @__PURE__ */ n(function(e, t) {
    return !!(e.get(ro) & t);
  }, "canIgnoreLoose");
  var Z3;
  function mXe(e, t, r) {
    (!ia(e, t) || Z3(e, t)) && (e.set(G3, e.get(G3) | t), r === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-\
an-error" ? (Mg(e, t, !0), e.set(ro, e.get(ro) | t)) : r === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-\
error" ? (Mg(e, t, !1), e.set(ro, e.get(ro) | t)) : Mg(e, t, r));
    let i;
    for (let [a, o] of UJ) {
      if (!ia(e, a) || Z3(e, a)) continue;
      let u = Q3(e, a);
      if (i === !u)
        throw new Error(`'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-p\
rivate-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).

` + $J(e));
      i = u;
      var s = o;
    }
    if (i !== void 0)
      for (let [a, o] of UJ)
        ia(e, a) && Q3(e, a) !== i && (Mg(e, a, i), console.warn(`Though the "loose" option was set to "${!i}" in your @babel/preset-env con\
fig, it will not be used for ${o} since the "loose" mode option was set to "${i}" for ${s}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-\
transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${o}", { "loose": ${i} }]
to the "plugins" section of your Babel config.

` + $J(e)));
  }
  n(mXe, "enableFeature");
  function $J(e) {
    let {
      filename: t
    } = e.opts;
    return (!t || t === "unknown") && (t = "[name of the input file]"), `If you already set the same 'loose' mode for these plugins in your \
config, it's possible that they are enabled multiple times with different options.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${t} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.`;
  }
  n($J, "getBabelShowConfigForHint");
  function ia(e, t) {
    return !!(e.get(G3) & t);
  }
  n(ia, "hasFeature");
  function Q3(e, t) {
    return !!(e.get(zp) & t);
  }
  n(Q3, "isLoose");
  function Mg(e, t, r) {
    r ? e.set(zp, e.get(zp) | t) : e.set(zp, e.get(zp) & ~t), e.set(ro, e.get(ro) & ~t);
  }
  n(Mg, "setLoose");
  function yXe(e, t) {
    let r = null, i = null, s = null, a = null, o = null;
    (0, qJ.hasOwnDecorators)(e.node) && (r = e.get("decorators.0"));
    for (let u of e.get("body.body"))
      !r && (0, qJ.hasOwnDecorators)(u.node) && (r = u.get("decorators.0")), !i && u.isClassProperty() && (i = u), !s && u.isClassPrivateProperty() &&
      (s = u), !a && u.isClassPrivateMethod != null && u.isClassPrivateMethod() && (a = u), !o && u.isStaticBlock != null && u.isStaticBlock() &&
      (o = u);
    if (r && s)
      throw s.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
    if (r && a)
      throw a.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
    if (r && !ia(t, ra.decorators))
      throw e.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-\
properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-transform-class-properties", { "loose": true }]`);
    if (a && !ia(t, ra.privateMethods))
      throw a.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your confi\
guration.");
    if ((i || s) && !ia(t, ra.fields) && !ia(t, ra.privateMethods))
      throw e.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration\
.");
    if (o && !ia(t, ra.staticBlocks))
      throw e.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your conf\
iguration.");
    return !!(r || a || o || (i || s) && ia(t, ra.fields));
  }
  n(yXe, "shouldTransform");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/index.js
var WJ = E((io) => {
  "use strict";
  Object.defineProperty(io, "__esModule", {
    value: !0
  });
  Object.defineProperty(io, "FEATURES", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Pc.FEATURES;
    }, "get")
  });
  Object.defineProperty(io, "buildCheckInRHS", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Jp.buildCheckInRHS;
    }, "get")
  });
  Object.defineProperty(io, "buildNamedEvaluationVisitor", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Rg.buildNamedEvaluationVisitor;
    }, "get")
  });
  io.createClassFeaturePlugin = vXe;
  Object.defineProperty(io, "enableFeature", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Pc.enableFeature;
    }, "get")
  });
  Object.defineProperty(io, "injectInitialization", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return tP.injectInitialization;
    }, "get")
  });
  var eP = Gt(), gXe = require("semver"), Jp = q3(), Rg = X3(), bXe = jJ(), tP = U3(), Pc = VJ(), DXe = N3(), Tu = "@babel/plugin-class-feat\
ures/version";
  function vXe({
    name: e,
    feature: t,
    loose: r,
    manipulateOptions: i,
    api: s,
    inherits: a,
    decoratorVersion: o
  }) {
    var u;
    if (t & Pc.FEATURES.decorators && (o === "2023-11" || o === "2023-05" || o === "2023-01" || o === "2022-03" || o === "2021-12"))
      return (0, Rg.default)(s, {
        loose: r
      }, o, a);
    s ?? (s = {
      assumption: /* @__PURE__ */ n(() => {
      }, "assumption")
    });
    let l = s.assumption("setPublicClassFields"), c = s.assumption("privateFieldsAsSymbols"), f = s.assumption("privateFieldsAsProperties"),
    m = (u = s.assumption("noUninitializedPrivateFieldAccess")) != null ? u : !1, h = s.assumption("constantSuper"), d = s.assumption("noDoc\
umentAll");
    if (f && c)
      throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
    let y = f || c;
    if (r === !0) {
      let p = [];
      l !== void 0 && p.push('"setPublicClassFields"'), f !== void 0 && p.push('"privateFieldsAsProperties"'), c !== void 0 && p.push('"priv\
ateFieldsAsSymbols"'), p.length !== 0 && console.warn(`[${e}]: You are using the "loose: true" option and you are explicitly setting a value\
 for the ${p.join(" and ")} assumption${p.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class featur\
es plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
    }
    return {
      name: e,
      manipulateOptions: i,
      inherits: a,
      pre(p) {
        if ((0, Pc.enableFeature)(p, t, r), typeof p.get(Tu) == "number") {
          p.set(Tu, "7.28.3");
          return;
        }
        (!p.get(Tu) || gXe.lt(p.get(Tu), "7.28.3")) && p.set(Tu, "7.28.3");
      },
      visitor: {
        Class(p, {
          file: g
        }) {
          if (g.get(Tu) !== "7.28.3" || !(0, Pc.shouldTransform)(p, g)) return;
          let b = p.isClassDeclaration();
          b && (0, DXe.assertFieldTransformed)(p);
          let D = (0, Pc.isLoose)(g, t), x, T = (0, Rg.hasDecorators)(p.node), w = [], B = [], k = [], q = /* @__PURE__ */ new Set(), V = p.
          get("body");
          for (let Me of V.get("body")) {
            if ((Me.isClassProperty() || Me.isClassMethod()) && Me.node.computed && k.push(Me), Me.isPrivate()) {
              let {
                name: Nt
              } = Me.node.key.id, tr = `get ${Nt}`, Yr = `set ${Nt}`;
              if (Me.isClassPrivateMethod()) {
                if (Me.node.kind === "get") {
                  if (q.has(tr) || q.has(Nt) && !q.has(Yr))
                    throw Me.buildCodeFrameError("Duplicate private field");
                  q.add(tr).add(Nt);
                } else if (Me.node.kind === "set") {
                  if (q.has(Yr) || q.has(Nt) && !q.has(tr))
                    throw Me.buildCodeFrameError("Duplicate private field");
                  q.add(Yr).add(Nt);
                }
              } else {
                if (q.has(Nt) && !q.has(tr) && !q.has(Yr) || q.has(Nt) && (q.has(tr) || q.has(Yr)))
                  throw Me.buildCodeFrameError("Duplicate private field");
                q.add(Nt);
              }
            }
            Me.isClassMethod({
              kind: "constructor"
            }) ? x = Me : (B.push(Me), (Me.isProperty() || Me.isPrivate() || Me.isStaticBlock != null && Me.isStaticBlock()) && w.push(Me));
          }
          if (!w.length && !T) return;
          let Y = p.node.id, G;
          if (!Y || !b) {
            {
              var ye;
              (ye = p.ensureFunctionName) != null || (p.ensureFunctionName = ir().NodePath.prototype.ensureFunctionName);
            }
            p.ensureFunctionName(!1), G = p.scope.generateUidIdentifier(Y?.name || "Class");
          }
          let te = G ?? eP.types.cloneNode(Y), re = (0, Jp.buildPrivateNamesMap)(te.name, y ?? D, w, g), ve = (0, Jp.buildPrivateNamesNodes)(
          re, f ?? D, c ?? !1, g);
          (0, Jp.transformPrivateNamesUsage)(te, p, re, {
            privateFieldsAsProperties: y ?? D,
            noUninitializedPrivateFieldAccess: m,
            noDocumentAll: d,
            innerBinding: Y
          }, g);
          let je, Be, se, Ne, ke, Cr, Ae;
          T ? (Be = ke = je = [], {
            instanceNodes: se,
            wrapClass: Ae
          } = (0, bXe.buildDecoratedClass)(te, p, B, g)) : (je = (0, tP.extractComputedKeys)(p, k, g), {
            staticNodes: Be,
            pureStaticNodes: ke,
            instanceNodes: se,
            lastInstanceNodeReturnsThis: Ne,
            classBindingNode: Cr,
            wrapClass: Ae
          } = (0, Jp.buildFieldsInitNodes)(G, p.node.superClass, w, re, g, l ?? D, y ?? D, m, h ?? D, Y)), se.length > 0 && (0, tP.injectInitialization)(
          p, x, se, (Me, Nt) => {
            if (!T)
              for (let tr of w)
                eP.types.isStaticBlock != null && eP.types.isStaticBlock(tr.node) || tr.node.static || tr.traverse(Me, Nt);
          }, Ne);
          let _e = Ae(p);
          _e.insertBefore([...ve, ...je]), Be.length > 0 && _e.insertAfter(Be), ke.length > 0 && _e.find((Me) => Me.isStatement() || Me.isDeclaration()).
          insertAfter(ke), Cr != null && b && _e.insertAfter(Cr);
        },
        ExportDefaultDeclaration(p, {
          file: g
        }) {
          {
            if (g.get(Tu) !== "7.28.3") return;
            let D = p.get("declaration");
            if (D.isClassDeclaration() && (0, Rg.hasDecorators)(D.node))
              if (D.node.id) {
                {
                  var b;
                  (b = p.splitExportDeclaration) != null || (p.splitExportDeclaration = ir().NodePath.prototype.splitExportDeclaration);
                }
                p.splitExportDeclaration();
              } else
                D.node.type = "ClassExpression";
          }
        }
      }
    };
  }
  n(vXe, "createClassFeaturePlugin");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/enum.js
var iP = E((Xp) => {
  "use strict";
  Object.defineProperty(Xp, "__esModule", {
    value: !0
  });
  Xp.default = CXe;
  Xp.isSyntacticallyString = Lg;
  Xp.translateEnumValues = KJ;
  var Fc = Gt(), xXe = require("assert"), EXe = O3(), SXe = Fg(), rP = /* @__PURE__ */ new WeakMap(), TXe = Fc.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);
  function CXe(e, t) {
    let {
      node: r,
      parentPath: i
    } = e;
    if (r.declare) {
      e.remove();
      return;
    }
    let s = r.id.name, {
      fill: a,
      data: o,
      isPure: u
    } = PXe(e, t, r.id);
    switch (i.type) {
      case "BlockStatement":
      case "ExportNamedDeclaration":
      case "Program": {
        let c = t.isProgram(e.parent), f = l(i), m = t.objectExpression([]);
        (f || c) && (m = t.logicalExpression("||", t.cloneNode(a.ID), m));
        let h = TXe(Object.assign({}, a, {
          INIT: m
        }));
        u && (0, EXe.default)(h), f ? (i.isExportDeclaration() ? i : e).replaceWith(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(
        r.id), h))) : e.scope.registerDeclaration(e.replaceWith(t.variableDeclaration(c ? "var" : "let", [t.variableDeclarator(r.id, h)]))[0]),
        rP.set(e.scope.getBindingIdentifier(s), o);
        break;
      }
      default:
        throw new Error(`Unexpected enum parent '${e.parent.type}`);
    }
    function l(c) {
      return c.isExportDeclaration() ? l(c.parentPath) : c.getData(s) ? !0 : (c.setData(s, !0), !1);
    }
    n(l, "seen");
  }
  n(CXe, "transpileEnum");
  var wXe = Fc.template.statement(`
  ENUM["NAME"] = VALUE;
`), AXe = Fc.template.statement(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`), _Xe = /* @__PURE__ */ n((e, t) => (e ? wXe : AXe)(t), "buildEnumMember");
  function PXe(e, t, r) {
    let {
      enumValues: i,
      data: s,
      isPure: a
    } = KJ(e, t), o = e.get("members"), u = [];
    for (let l = 0; l < o.length; l++) {
      let [c, f] = i[l];
      u.push(t.inheritsComments(_Xe(Lg(f), {
        ENUM: t.cloneNode(r),
        NAME: c,
        VALUE: f
      }), o[l].node));
    }
    return {
      fill: {
        ID: t.cloneNode(r),
        ASSIGNMENTS: u
      },
      data: s,
      isPure: a
    };
  }
  n(PXe, "enumFill");
  function Lg(e) {
    switch (e = (0, SXe.skipTransparentExprWrapperNodes)(e), e.type) {
      case "BinaryExpression": {
        let t = e.left, r = e.right;
        return e.operator === "+" && (Lg(t) || Lg(r));
      }
      case "TemplateLiteral":
      case "StringLiteral":
        return !0;
    }
    return !1;
  }
  n(Lg, "isSyntacticallyString");
  function HJ(e, t) {
    let {
      seen: r,
      path: i,
      t: s
    } = t, a = e.node.name;
    if (r.has(a)) {
      for (let o = e.scope; o !== i.scope; o = o.parent)
        if (o.hasOwnBinding(a))
          return;
      e.replaceWith(s.memberExpression(s.cloneNode(i.node.id), s.cloneNode(e.node))), e.skip();
    }
  }
  n(HJ, "ReferencedIdentifier");
  var FXe = {
    ReferencedIdentifier: HJ
  };
  function KJ(e, t) {
    var r;
    let i = e.scope.getBindingIdentifier(e.node.id.name), s = (r = rP.get(i)) != null ? r : /* @__PURE__ */ new Map(), a = -1, o, u = !0, c = e.
    get("members").map((f) => {
      let m = f.node, h = t.isIdentifier(m.id) ? m.id.name : m.id.value, d = f.get("initializer"), y = m.initializer, p;
      if (y)
        a = zJ(d, s), a !== void 0 ? (s.set(h, a), xXe(typeof a == "number" || typeof a == "string"), a === 1 / 0 || Number.isNaN(a) ? p = t.
        identifier(String(a)) : a === -1 / 0 ? p = t.unaryExpression("-", t.identifier("Infinity")) : p = t.valueToNode(a)) : (u && (u = d.isPure()),
        d.isReferencedIdentifier() ? HJ(d, {
          t,
          seen: s,
          path: e
        }) : d.traverse(FXe, {
          t,
          seen: s,
          path: e
        }), p = d.node, s.set(h, void 0));
      else if (typeof a == "number")
        a += 1, p = t.numericLiteral(a), s.set(h, a);
      else {
        if (typeof a == "string")
          throw e.buildCodeFrameError("Enum member must have initializer.");
        {
          let g = t.memberExpression(t.cloneNode(e.node.id), t.stringLiteral(o), !0);
          p = t.binaryExpression("+", t.numericLiteral(1), g), s.set(h, void 0);
        }
      }
      return o = h, [h, p];
    });
    return {
      isPure: u,
      data: s,
      enumValues: c
    };
  }
  n(KJ, "translateEnumValues");
  function zJ(e, t, r = /* @__PURE__ */ new Set()) {
    return i(e);
    function i(u) {
      let l = u.node;
      switch (l.type) {
        case "MemberExpression":
          return s(u, t, r);
        case "StringLiteral":
          return l.value;
        case "UnaryExpression":
          return a(u);
        case "BinaryExpression":
          return o(u);
        case "NumericLiteral":
          return l.value;
        case "ParenthesizedExpression":
          return i(u.get("expression"));
        case "Identifier":
          return s(u, t, r);
        case "TemplateLiteral": {
          if (l.quasis.length === 1)
            return l.quasis[0].value.cooked;
          let c = u.get("expressions"), f = l.quasis, m = "";
          for (let h = 0; h < f.length; h++)
            if (m += f[h].value.cooked, h + 1 < f.length) {
              let d = s(c[h], t, r);
              if (d === void 0) return;
              m += d;
            }
          return m;
        }
        default:
          return;
      }
    }
    function s(u, l, c) {
      if (u.isMemberExpression()) {
        let f = u.node, m = f.object, h = f.property;
        if (!Fc.types.isIdentifier(m) || (f.computed ? !Fc.types.isStringLiteral(h) : !Fc.types.isIdentifier(h)))
          return;
        let d = u.scope.getBindingIdentifier(m.name), y = rP.get(d);
        return y ? y.get(h.computed ? h.value : h.name) : void 0;
      } else if (u.isIdentifier()) {
        let f = u.node.name;
        if (["Infinity", "NaN"].includes(f))
          return Number(f);
        let m = l?.get(f);
        return m !== void 0 ? m : l != null && l.has(f) || c.has(u.node) ? void 0 : (c.add(u.node), m = zJ(u.resolve(), l, c), m);
      }
    }
    function a(u) {
      let l = i(u.get("argument"));
      if (l !== void 0)
        switch (u.node.operator) {
          case "+":
            return l;
          case "-":
            return -l;
          case "~":
            return ~l;
          default:
            return;
        }
    }
    function o(u) {
      let l = i(u.get("left"));
      if (l === void 0)
        return;
      let c = i(u.get("right"));
      if (c !== void 0)
        switch (u.node.operator) {
          case "|":
            return l | c;
          case "&":
            return l & c;
          case ">>":
            return l >> c;
          case ">>>":
            return l >>> c;
          case "<<":
            return l << c;
          case "^":
            return l ^ c;
          case "*":
            return l * c;
          case "/":
            return l / c;
          case "+":
            return l + c;
          case "-":
            return l - c;
          case "%":
            return l % c;
          case "**":
            return Math.pow(l, c);
          default:
            return;
        }
    }
  }
  n(zJ, "computeConstantValue");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/const-enum.js
var sP = E((Yp) => {
  "use strict";
  Object.defineProperty(Yp, "__esModule", {
    value: !0
  });
  Yp.EXPORTED_CONST_ENUMS_IN_NAMESPACE = void 0;
  Yp.default = kXe;
  var IXe = iP(), OXe = Yp.EXPORTED_CONST_ENUMS_IN_NAMESPACE = /* @__PURE__ */ new WeakSet();
  function kXe(e, t) {
    let {
      name: r
    } = e.node.id, i = e.parentPath.isExportNamedDeclaration(), s = i;
    !s && t.isProgram(e.parent) && (s = e.parent.body.some((u) => t.isExportNamedDeclaration(u) && u.exportKind !== "type" && !u.source && u.
    specifiers.some((l) => t.isExportSpecifier(l) && l.exportKind !== "type" && l.local.name === r)));
    let {
      enumValues: a
    } = (0, IXe.translateEnumValues)(e, t);
    if (s || OXe.has(e.node)) {
      let u = t.objectExpression(a.map(([l, c]) => t.objectProperty(t.isValidIdentifier(l) ? t.identifier(l) : t.stringLiteral(l), c)));
      e.scope.hasOwnBinding(r) ? (i ? e.parentPath : e).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("\
Object"), t.identifier("assign")), [e.node.id, u]))) : (e.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(e.node.id, u)])), e.
      scope.registerDeclaration(e));
      return;
    }
    let o = new Map(a);
    e.scope.path.traverse({
      Scope(u) {
        u.scope.hasOwnBinding(r) && u.skip();
      },
      MemberExpression(u) {
        if (!t.isIdentifier(u.node.object, {
          name: r
        })) return;
        let l;
        if (u.node.computed)
          if (t.isStringLiteral(u.node.property))
            l = u.node.property.value;
          else
            return;
        else if (t.isIdentifier(u.node.property))
          l = u.node.property.name;
        else
          return;
        o.has(l) && u.replaceWith(t.cloneNode(o.get(l)));
      }
    }), e.remove();
  }
  n(kXe, "transpileConstEnum");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/global-types.js
var nP = E((Ic) => {
  "use strict";
  Object.defineProperty(Ic, "__esModule", {
    value: !0
  });
  Ic.GLOBAL_TYPES = void 0;
  Ic.isGlobalType = BXe;
  Ic.registerGlobalType = NXe;
  var JJ = Ic.GLOBAL_TYPES = /* @__PURE__ */ new WeakMap();
  function BXe({
    scope: e
  }, t) {
    return e.hasBinding(t) ? !1 : JJ.get(e).has(t) ? !0 : (console.warn(`The exported identifier "${t}" is not declared in Babel's scope tra\
cker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${t}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), !1);
  }
  n(BXe, "isGlobalType");
  function NXe(e, t) {
    JJ.get(e).add(t);
  }
  n(NXe, "registerGlobalType");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/namespace.js
var YJ = E((jg) => {
  "use strict";
  Object.defineProperty(jg, "__esModule", {
    value: !0
  });
  jg.default = LXe;
  jg.getFirstIdentifier = lP;
  var lt = Gt(), MXe = nP(), RXe = sP();
  function lP(e) {
    return lt.types.isIdentifier(e) ? e : lP(e.left);
  }
  n(lP, "getFirstIdentifier");
  function LXe(e, t) {
    if (e.node.declare || e.node.id.type === "StringLiteral") {
      e.remove();
      return;
    }
    if (!t)
      throw e.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimen\
tally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    let r = lP(e.node.id).name, i = uP(e, e.node);
    if (i === null) {
      let s = e.findParent((a) => a.isProgram());
      (0, MXe.registerGlobalType)(s.scope, r), e.remove();
    } else e.scope.hasOwnBinding(r) ? e.replaceWith(i) : e.scope.registerDeclaration(e.replaceWithMultiple([aP(r), i])[0]);
  }
  n(LXe, "transpileNamespace");
  function aP(e) {
    return lt.types.variableDeclaration("let", [lt.types.variableDeclarator(lt.types.identifier(e))]);
  }
  n(aP, "getDeclaration");
  function oP(e, t) {
    return lt.types.memberExpression(lt.types.identifier(e), lt.types.identifier(t));
  }
  n(oP, "getMemberExpression");
  function jXe(e, t, r) {
    if (e.kind !== "const")
      throw r.file.buildCodeFrameError(e, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babelj\
s.io/docs/en/babel-plugin-transform-typescript");
    let {
      declarations: i
    } = e;
    if (i.every((o) => lt.types.isIdentifier(o.id))) {
      for (let o of i)
        o.init = lt.types.assignmentExpression("=", oP(t, o.id.name), o.init);
      return [e];
    }
    let s = lt.types.getBindingIdentifiers(e), a = [];
    for (let o in s)
      a.push(lt.types.assignmentExpression("=", oP(t, o), lt.types.cloneNode(s[o])));
    return [e, lt.types.expressionStatement(lt.types.sequenceExpression(a))];
  }
  n(jXe, "handleVariableDeclaration");
  function XJ(e, t) {
    return e.hub.buildError(t, "Ambient modules cannot be nested in other modules or namespaces.", Error);
  }
  n(XJ, "buildNestedAmbientModuleError");
  function uP(e, t, r) {
    let i = /* @__PURE__ */ new Set(), s = t.id, a = e.scope.generateUid(s.name), o = t.body, u = t.id, l;
    l = lt.types.isTSModuleBlock(o) ? o.body : [lt.types.exportNamedDeclaration(o)];
    let c = !0;
    for (let m = 0; m < l.length; m++) {
      let h = l[m];
      switch (h.type) {
        case "TSModuleDeclaration": {
          if (!lt.types.isIdentifier(h.id))
            throw XJ(e, h);
          let d = uP(e, h);
          if (d !== null) {
            c = !1;
            let y = h.id.name;
            i.has(y) ? l[m] = d : (i.add(y), l.splice(m++, 1, aP(y), d));
          }
          continue;
        }
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          c = !1, i.add(h.id.name);
          continue;
        case "VariableDeclaration": {
          c = !1;
          for (let d in lt.types.getBindingIdentifiers(h))
            i.add(d);
          continue;
        }
        default:
          c && (c = lt.types.isTypeScript(h));
          continue;
        case "ExportNamedDeclaration":
      }
      if (!("declare" in h.declaration && h.declaration.declare))
        switch (h.declaration.type) {
          case "TSEnumDeclaration":
            RXe.EXPORTED_CONST_ENUMS_IN_NAMESPACE.add(h.declaration);
          case "FunctionDeclaration":
          case "ClassDeclaration": {
            c = !1;
            let d = h.declaration.id.name;
            i.add(d), l.splice(m++, 1, h.declaration, lt.types.expressionStatement(lt.types.assignmentExpression("=", oP(a, d), lt.types.identifier(
            d))));
            break;
          }
          case "VariableDeclaration": {
            c = !1;
            let d = jXe(h.declaration, a, e.hub);
            l.splice(m, d.length, ...d), m += d.length - 1;
            break;
          }
          case "TSModuleDeclaration": {
            if (!lt.types.isIdentifier(h.declaration.id))
              throw XJ(e, h.declaration);
            let d = uP(e, h.declaration, lt.types.identifier(a));
            if (d !== null) {
              c = !1;
              let y = h.declaration.id.name;
              i.has(y) ? l[m] = d : (i.add(y), l.splice(m++, 1, aP(y), d));
            } else
              l.splice(m, 1), m--;
          }
        }
    }
    if (c) return null;
    let f = lt.types.objectExpression([]);
    if (r) {
      let m = lt.types.memberExpression(r, s);
      f = lt.template.expression.ast`
      ${lt.types.cloneNode(m)} ||
        (${lt.types.cloneNode(m)} = ${f})
    `;
    }
    return lt.template.statement.ast`
    (function (${lt.types.identifier(a)}) {
      ${l}
    })(${s} || (${lt.types.cloneNode(s)} = ${f}));
  `;
  }
  n(uP, "handleNested");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/index.js
var eX = E((Ug) => {
  "use strict";
  Object.defineProperty(Ug, "__esModule", {
    value: !0
  });
  Ug.default = void 0;
  var qXe = Sc(), UXe = Zz(), $Xe = WJ(), VXe = sP(), WXe = iP(), sa = nP(), GJ = YJ();
  function HXe(e) {
    switch (e.parent.type) {
      case "TSTypeReference":
      case "TSExpressionWithTypeArguments":
      case "TSExpressionWithTypeArguments":
      case "TSTypeQuery":
        return !0;
      case "TSQualifiedName":
        return e.parentPath.findParent((t) => t.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
      case "ExportSpecifier":
        return e.parent.exportKind === "type" || e.parentPath.parent.exportKind === "type";
      default:
        return !1;
    }
  }
  n(HXe, "isInType");
  var rs = /* @__PURE__ */ new WeakMap(), ZJ = /* @__PURE__ */ new WeakSet();
  function qg(e) {
    let t = e.getBindingIdentifiers();
    for (let r of Object.keys(t)) {
      let i = e.scope.getBinding(r);
      i && i.identifier === t[r] && i.scope.removeBinding(r);
    }
    e.opts.noScope = !0, e.remove(), e.opts.noScope = !1;
  }
  n(qg, "safeRemove");
  function QJ(e, t, r, i, s = "") {
    if (t.file.get("@babel/plugin-transform-modules-*") !== "commonjs")
      throw e.buildCodeFrameError(`\`${r}\` is only supported when compiling modules to CommonJS.
Please consider using \`${i}\`${s}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
  }
  n(QJ, "assertCjsTransformEnabled");
  var kxt = Ug.default = (0, qXe.declare)((e, t) => {
    let {
      types: r,
      template: i
    } = e;
    e.assertVersion(7);
    let s = /\*?\s*@jsx((?:Frag)?)\s+(\S+)/, {
      allowNamespaces: a = !0,
      jsxPragma: o = "React.createElement",
      jsxPragmaFrag: u = "React.Fragment",
      onlyRemoveTypeImports: l = !1,
      optimizeConstEnums: c = !1
    } = t;
    var {
      allowDeclareFields: f = !1
    } = t;
    let m = {
      field(p) {
        let {
          node: g
        } = p;
        if (!f && g.declare)
          throw p.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transfor\
m-typescript or @babel/preset-typescript is enabled.");
        if (g.declare) {
          if (g.value)
            throw p.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
          g.decorators || p.remove();
        } else if (g.definite) {
          if (g.value)
            throw p.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
          !f && !g.decorators && !r.isClassPrivateProperty(g) && p.remove();
        } else (g.abstract || !f && !g.value && !g.decorators && !r.isClassPrivateProperty(g)) && p.remove();
        g.accessibility && (g.accessibility = null), g.abstract && (g.abstract = null), g.readonly && (g.readonly = null), g.optional && (g.
        optional = null), g.typeAnnotation && (g.typeAnnotation = null), g.definite && (g.definite = null), g.declare && (g.declare = null),
        g.override && (g.override = null);
      },
      method({
        node: p
      }) {
        p.accessibility && (p.accessibility = null), p.abstract && (p.abstract = null), p.optional && (p.optional = null), p.override && (p.
        override = null);
      },
      constructor(p, g) {
        p.node.accessibility && (p.node.accessibility = null);
        let b = [], {
          scope: D
        } = p;
        for (let x of p.get("params")) {
          let T = x.node;
          if (T.type === "TSParameterProperty") {
            let w = T.parameter;
            if (ZJ.has(w)) continue;
            ZJ.add(w);
            let B;
            if (r.isIdentifier(w))
              B = w;
            else if (r.isAssignmentPattern(w) && r.isIdentifier(w.left))
              B = w.left;
            else
              throw x.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
            b.push(i.statement.ast`
              this.${r.cloneNode(B)} = ${r.cloneNode(B)}
            `), x.replaceWith(x.get("parameter")), D.registerBinding("param", x);
          }
        }
        (0, $Xe.injectInitialization)(g, p, b);
      }
    };
    return {
      name: "transform-typescript",
      inherits: UXe.default,
      visitor: {
        Pattern: d,
        Identifier: d,
        RestElement: d,
        Program: {
          enter(p, g) {
            let {
              file: b
            } = g, D = null, x = null, T = p.scope;
            if (sa.GLOBAL_TYPES.has(T) || sa.GLOBAL_TYPES.set(T, /* @__PURE__ */ new Set()), b.ast.comments)
              for (let k of b.ast.comments) {
                let q = s.exec(k.value);
                q && (q[1] ? x = q[2] : D = q[2]);
              }
            let w = D || o;
            w && ([w] = w.split("."));
            let B = x || u;
            B && ([B] = B.split("."));
            for (let k of p.get("body")) {
              if (k.isImportDeclaration()) {
                if (rs.has(g.file.ast.program) || rs.set(g.file.ast.program, !0), k.node.importKind === "type") {
                  for (let G of k.node.specifiers)
                    (0, sa.registerGlobalType)(T, G.local.name);
                  k.remove();
                  continue;
                }
                let q = /* @__PURE__ */ new Set(), V = k.node.specifiers.length, Y = /* @__PURE__ */ n(() => V > 0 && V === q.size, "isAllSp\
ecifiersElided");
                for (let G of k.node.specifiers)
                  if (G.type === "ImportSpecifier" && G.importKind === "type") {
                    (0, sa.registerGlobalType)(T, G.local.name);
                    let ye = k.scope.getBinding(G.local.name);
                    ye && q.add(ye.path);
                  }
                if (l)
                  rs.set(p.node, !1);
                else {
                  if (k.node.specifiers.length === 0) {
                    rs.set(p.node, !1);
                    continue;
                  }
                  for (let G of k.node.specifiers) {
                    let ye = k.scope.getBinding(G.local.name);
                    ye && !q.has(ye.path) && (y({
                      binding: ye,
                      programPath: p,
                      pragmaImportName: w,
                      pragmaFragImportName: B
                    }) ? q.add(ye.path) : rs.set(p.node, !1));
                  }
                }
                if (Y() && !l)
                  k.remove();
                else
                  for (let G of q)
                    G.remove();
                continue;
              }
              if (!l && k.isTSImportEqualsDeclaration()) {
                let {
                  id: q
                } = k.node, V = k.scope.getBinding(q.name);
                if (V && !k.node.isExport && y({
                  binding: V,
                  programPath: p,
                  pragmaImportName: w,
                  pragmaFragImportName: B
                })) {
                  k.remove();
                  continue;
                }
              }
              if (k.isExportDeclaration() && (k = k.get("declaration")), k.isVariableDeclaration({
                declare: !0
              }))
                for (let q of Object.keys(k.getBindingIdentifiers()))
                  (0, sa.registerGlobalType)(T, q);
              else (k.isTSTypeAliasDeclaration() || k.isTSDeclareFunction() && k.get("id").isIdentifier() || k.isTSInterfaceDeclaration() ||
              k.isClassDeclaration({
                declare: !0
              }) || k.isTSEnumDeclaration({
                declare: !0
              }) || k.isTSModuleDeclaration({
                declare: !0
              }) && k.get("id").isIdentifier()) && (0, sa.registerGlobalType)(T, k.node.id.name);
            }
          },
          exit(p) {
            p.node.sourceType === "module" && rs.get(p.node) && p.pushContainer("body", r.exportNamedDeclaration());
          }
        },
        ExportNamedDeclaration(p, g) {
          if (rs.has(g.file.ast.program) || rs.set(g.file.ast.program, !0), p.node.exportKind === "type") {
            p.remove();
            return;
          }
          if (p.node.source && p.node.specifiers.length > 0 && p.node.specifiers.every((b) => b.type === "ExportSpecifier" && b.exportKind ===
          "type")) {
            p.remove();
            return;
          }
          if (!p.node.source && p.node.specifiers.length > 0 && p.node.specifiers.every((b) => r.isExportSpecifier(b) && (0, sa.isGlobalType)(
          p, b.local.name))) {
            p.remove();
            return;
          }
          if (r.isTSModuleDeclaration(p.node.declaration)) {
            let b = p.node.declaration;
            if (!r.isStringLiteral(b.id)) {
              let D = (0, GJ.getFirstIdentifier)(b.id);
              if (p.scope.hasOwnBinding(D.name))
                p.replaceWith(b);
              else {
                let [x] = p.replaceWithMultiple([r.exportNamedDeclaration(r.variableDeclaration("let", [r.variableDeclarator(r.cloneNode(D))])),
                b]);
                p.scope.registerDeclaration(x);
              }
            }
          }
          rs.set(g.file.ast.program, !1);
        },
        ExportAllDeclaration(p) {
          p.node.exportKind === "type" && p.remove();
        },
        ExportSpecifier(p) {
          (!p.parent.source && (0, sa.isGlobalType)(p, p.node.local.name) || p.node.exportKind === "type") && p.remove();
        },
        ExportDefaultDeclaration(p, g) {
          if (rs.has(g.file.ast.program) || rs.set(g.file.ast.program, !0), r.isIdentifier(p.node.declaration) && (0, sa.isGlobalType)(p, p.
          node.declaration.name)) {
            p.remove();
            return;
          }
          rs.set(g.file.ast.program, !1);
        },
        TSDeclareFunction(p) {
          qg(p);
        },
        TSDeclareMethod(p) {
          qg(p);
        },
        VariableDeclaration(p) {
          p.node.declare && qg(p);
        },
        VariableDeclarator({
          node: p
        }) {
          p.definite && (p.definite = null);
        },
        TSIndexSignature(p) {
          p.remove();
        },
        ClassDeclaration(p) {
          let {
            node: g
          } = p;
          g.declare && qg(p);
        },
        Class(p) {
          let {
            node: g
          } = p;
          g.typeParameters && (g.typeParameters = null), g.superTypeParameters && (g.superTypeParameters = null), g.implements && (g.implements =
          null), g.abstract && (g.abstract = null), p.get("body.body").forEach((b) => {
            b.isClassMethod() || b.isClassPrivateMethod() ? b.node.kind === "constructor" ? m.constructor(b, p) : m.method(b) : (b.isClassProperty() ||
            b.isClassPrivateProperty() || b.isClassAccessorProperty()) && m.field(b);
          });
        },
        Function(p) {
          let {
            node: g
          } = p;
          g.typeParameters && (g.typeParameters = null), g.returnType && (g.returnType = null);
          let b = g.params;
          b.length > 0 && r.isIdentifier(b[0], {
            name: "this"
          }) && b.shift();
        },
        TSModuleDeclaration(p) {
          (0, GJ.default)(p, a);
        },
        TSInterfaceDeclaration(p) {
          p.remove();
        },
        TSTypeAliasDeclaration(p) {
          p.remove();
        },
        TSEnumDeclaration(p) {
          c && p.node.const ? (0, VXe.default)(p, r) : (0, WXe.default)(p, r);
        },
        TSImportEqualsDeclaration(p, g) {
          let {
            id: b,
            moduleReference: D
          } = p.node, x, T;
          r.isTSExternalModuleReference(D) ? (QJ(p, g, `import ${b.name} = require(...);`, `import ${b.name} from '...';`, " alongside Types\
cript's --allowSyntheticDefaultImports option"), x = r.callExpression(r.identifier("require"), [D.expression]), T = "const") : (x = h(D), T =
          "var");
          let w = r.variableDeclaration(T, [r.variableDeclarator(b, x)]);
          p.replaceWith(p.node.isExport ? r.exportNamedDeclaration(w) : w), p.scope.registerDeclaration(p);
        },
        TSExportAssignment(p, g) {
          QJ(p, g, "export = <value>;", "export default <value>;"), p.replaceWith(i.statement.ast`module.exports = ${p.node.expression}`);
        },
        TSTypeAssertion(p) {
          p.replaceWith(p.node.expression);
        },
        [`TSAsExpression${r.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""}`](p) {
          let {
            node: g
          } = p;
          do
            g = g.expression;
          while (r.isTSAsExpression(g) || r.isTSSatisfiesExpression != null && r.isTSSatisfiesExpression(g));
          p.replaceWith(g);
        },
        [e.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](p) {
          p.replaceWith(p.node.expression);
        },
        CallExpression(p) {
          p.node.typeParameters = null;
        },
        OptionalCallExpression(p) {
          p.node.typeParameters = null;
        },
        NewExpression(p) {
          p.node.typeParameters = null;
        },
        JSXOpeningElement(p) {
          p.node.typeParameters = null;
        },
        TaggedTemplateExpression(p) {
          p.node.typeParameters = null;
        }
      }
    };
    function h(p) {
      return r.isTSQualifiedName(p) ? r.memberExpression(h(p.left), p.right) : p;
    }
    function d({
      node: p
    }) {
      p.typeAnnotation && (p.typeAnnotation = null), r.isIdentifier(p) && p.optional && (p.optional = null);
    }
    function y({
      binding: p,
      programPath: g,
      pragmaImportName: b,
      pragmaFragImportName: D
    }) {
      for (let T of p.referencePaths)
        if (!HXe(T))
          return !1;
      if (p.identifier.name !== b && p.identifier.name !== D)
        return !0;
      let x = !1;
      return g.traverse({
        "JSXElement|JSXFragment"(T) {
          x = !0, T.stop();
        }
      }), !x;
    }
  });
});

// ../node_modules/@babel/plugin-syntax-jsx/lib/index.js
var tX = E(($g) => {
  "use strict";
  Object.defineProperty($g, "__esModule", {
    value: !0
  });
  $g.default = void 0;
  var KXe = Sc(), Mxt = $g.default = (0, KXe.declare)((e) => (e.assertVersion(7), {
    name: "syntax-jsx",
    manipulateOptions(t, r) {
      r.plugins.some((i) => (Array.isArray(i) ? i[0] : i) === "typescript") || r.plugins.push("jsx");
    }
  }));
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js
var sX = E((cP) => {
  "use strict";
  Object.defineProperty(cP, "__esModule", {
    value: !0
  });
  cP.transformDynamicImport = XXe;
  var rX = Gt(), zXe = bp(), iX = /* @__PURE__ */ n((e) => rX.template.expression.ast`require(${e})`, "requireNoInterop"), JXe = /* @__PURE__ */ n(
  (e, t) => rX.types.callExpression(t.addHelper("interopRequireWildcard"), [iX(e)]), "requireInterop");
  function XXe(e, t, r) {
    let i = t ? iX : JXe;
    e.replaceWith((0, zXe.buildDynamicImport)(e.node, !0, !1, (s) => i(s, r)));
  }
  n(XXe, "transformDynamicImport");
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js
var aX = E((Vg) => {
  "use strict";
  Object.defineProperty(Vg, "__esModule", {
    value: !0
  });
  Vg.lazyImportsHook = void 0;
  var nX = Gt(), YXe = bp(), GXe = /* @__PURE__ */ n((e) => ({
    name: "@babel/plugin-transform-modules-commonjs/lazy",
    version: "7.27.1",
    getWrapperPayload(t, r) {
      if ((0, YXe.isSideEffectImport)(r) || r.reexportAll)
        return null;
      if (e === !0)
        return t.includes(".") ? null : "lazy/function";
      if (Array.isArray(e))
        return e.includes(t) ? "lazy/function" : null;
      if (typeof e == "function")
        return e(t) ? "lazy/function" : null;
    },
    buildRequireWrapper(t, r, i, s) {
      if (i === "lazy/function")
        return s ? nX.template.statement.ast`
        function ${t}() {
          const data = ${r};
          ${t} = function(){ return data; };
          return data;
        }
      ` : !1;
    },
    wrapReference(t, r) {
      if (r === "lazy/function") return nX.types.callExpression(t, []);
    }
  }), "lazyImportsHook");
  Vg.lazyImportsHook = GXe;
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js
var oX = E((Wg) => {
  "use strict";
  Object.defineProperty(Wg, "__esModule", {
    value: !0
  });
  Wg.defineCommonJSHook = ZXe;
  Wg.makeInvokers = QXe;
  var dP = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
  function ZXe(e, t) {
    let r = e.get(dP);
    r || e.set(dP, r = []), r.push(t);
  }
  n(ZXe, "defineCommonJSHook");
  function fP(e, t) {
    if (e)
      for (let r of e) {
        let i = t(r);
        if (i != null) return i;
      }
  }
  n(fP, "findMap");
  function QXe(e) {
    let t = e.get(dP);
    return {
      getWrapperPayload(...r) {
        return fP(t, (i) => i.getWrapperPayload == null ? void 0 : i.getWrapperPayload(...r));
      },
      wrapReference(...r) {
        return fP(t, (i) => i.wrapReference == null ? void 0 : i.wrapReference(...r));
      },
      buildRequireWrapper(...r) {
        return fP(t, (i) => i.buildRequireWrapper == null ? void 0 : i.buildRequireWrapper(...r));
      }
    };
  }
  n(QXe, "makeInvokers");
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js
var uX = E((Gp) => {
  "use strict";
  Object.defineProperty(Gp, "__esModule", {
    value: !0
  });
  Gp.default = void 0;
  Object.defineProperty(Gp, "defineCommonJSHook", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return pP.defineCommonJSHook;
    }, "get")
  });
  var eYe = Sc(), Cu = bp(), Ps = Gt(), tYe = sX(), rYe = aX(), pP = oX(), Wxt = Gp.default = (0, eYe.declare)((e, t) => {
    var r, i, s;
    e.assertVersion(7);
    let {
      strictNamespace: a = !1,
      mjsStrictNamespace: o = a,
      allowTopLevelThis: u,
      strict: l,
      strictMode: c,
      noInterop: f,
      importInterop: m,
      lazy: h = !1,
      allowCommonJSExports: d = !0,
      loose: y = !1
    } = t, p = (r = e.assumption("constantReexports")) != null ? r : y, g = (i = e.assumption("enumerableModuleMeta")) != null ? i : y, b = (s =
    e.assumption("noIncompleteNsImportDetection")) != null ? s : !1;
    if (typeof h != "boolean" && typeof h != "function" && (!Array.isArray(h) || !h.every((T) => typeof T == "string")))
      throw new Error(".lazy must be a boolean, array of strings, or a function");
    if (typeof a != "boolean")
      throw new Error(".strictNamespace must be a boolean, or undefined");
    if (typeof o != "boolean")
      throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
    let D = /* @__PURE__ */ n((T) => Ps.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${T}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, "getAssertion"), x = {
      ReferencedIdentifier(T) {
        let w = T.node.name;
        if (w !== "module" && w !== "exports") return;
        let B = T.scope.getBinding(w);
        this.scope.getBinding(w) !== B || T.parentPath.isObjectProperty({
          value: T.node
        }) && T.parentPath.parentPath.isObjectPattern() || T.parentPath.isAssignmentExpression({
          left: T.node
        }) || T.isAssignmentExpression({
          left: T.node
        }) || T.replaceWith(D(w));
      },
      UpdateExpression(T) {
        let w = T.get("argument");
        if (!w.isIdentifier()) return;
        let B = w.node.name;
        if (B !== "module" && B !== "exports") return;
        let k = T.scope.getBinding(B);
        this.scope.getBinding(B) === k && T.replaceWith(Ps.types.assignmentExpression(T.node.operator[0] + "=", w.node, D(B)));
      },
      AssignmentExpression(T) {
        let w = T.get("left");
        if (w.isIdentifier()) {
          let B = w.node.name;
          if (B !== "module" && B !== "exports") return;
          let k = T.scope.getBinding(B);
          if (this.scope.getBinding(B) !== k) return;
          let V = T.get("right");
          V.replaceWith(Ps.types.sequenceExpression([V.node, D(B)]));
        } else if (w.isPattern()) {
          let B = w.getOuterBindingIdentifiers(), k = Object.keys(B).find((q) => q !== "module" && q !== "exports" ? !1 : this.scope.getBinding(
          q) === T.scope.getBinding(q));
          if (k) {
            let q = T.get("right");
            q.replaceWith(Ps.types.sequenceExpression([q.node, D(k)]));
          }
        }
      }
    };
    return {
      name: "transform-modules-commonjs",
      pre() {
        this.file.set("@babel/plugin-transform-modules-*", "commonjs"), h && (0, pP.defineCommonJSHook)(this.file, (0, rYe.lazyImportsHook)(
        h));
      },
      visitor: {
        ["CallExpression" + (e.types.importExpression ? "|ImportExpression" : "")](T) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import") || T.isCallExpression() && !Ps.types.isImport(T.node.callee)) return;
          let {
            scope: w
          } = T;
          do
            w.rename("require");
          while (w = w.parent);
          (0, tYe.transformDynamicImport)(T, f, this.file);
        },
        Program: {
          exit(T, w) {
            if (!(0, Cu.isModule)(T)) return;
            T.scope.rename("exports"), T.scope.rename("module"), T.scope.rename("require"), T.scope.rename("__filename"), T.scope.rename("__\
dirname"), d || T.traverse(x, {
              scope: T.scope
            });
            let B = (0, Cu.getModuleName)(this.file.opts, t);
            B && (B = Ps.types.stringLiteral(B));
            let k = (0, pP.makeInvokers)(this.file), {
              meta: q,
              headers: V
            } = (0, Cu.rewriteModuleStatementsAndPrepareHeader)(T, {
              exportName: "exports",
              constantReexports: p,
              enumerableModuleMeta: g,
              strict: l,
              strictMode: c,
              allowTopLevelThis: u,
              noInterop: f,
              importInterop: m,
              wrapReference: k.wrapReference,
              getWrapperPayload: k.getWrapperPayload,
              esNamespaceOnly: typeof w.filename == "string" && /\.mjs$/.test(w.filename) ? o : a,
              noIncompleteNsImportDetection: b,
              filename: this.file.opts.filename
            });
            for (let [Y, G] of q.source) {
              let ye = Ps.types.callExpression(Ps.types.identifier("require"), [Ps.types.stringLiteral(Y)]), te;
              if ((0, Cu.isSideEffectImport)(G)) {
                if (h && G.wrap === "function")
                  throw new Error("Assertion failure");
                te = Ps.types.expressionStatement(ye);
              } else {
                let re = (0, Cu.wrapInterop)(T, ye, G.interop) || ye;
                if (G.wrap) {
                  let ve = k.buildRequireWrapper(G.name, re, G.wrap, G.referenced);
                  if (ve === !1) continue;
                  te = ve;
                }
                te ?? (te = Ps.template.statement.ast`
                var ${G.name} = ${re};
              `);
              }
              te.loc = G.loc, V.push(te), V.push(...(0, Cu.buildNamespaceInitStatements)(q, G, p, k.wrapReference));
            }
            (0, Cu.ensureStatementsHoisted)(V), T.unshiftContainer("body", V), T.get("body").forEach((Y) => {
              V.includes(Y.node) && Y.isVariableDeclaration() && Y.scope.registerDeclaration(Y);
            });
          }
        }
      }
    };
  });
});

// ../node_modules/@babel/preset-typescript/lib/index.js
var dX = E((hP) => {
  "use strict";
  Object.defineProperty(hP, "__esModule", { value: !0 });
  var cX = Sc(), iYe = eX();
  tX();
  var sYe = uX(), nYe = K1();
  function fX(e) {
    return e && e.__esModule ? e : { default: e };
  }
  n(fX, "_interopDefault");
  var lX = /* @__PURE__ */ fX(iYe), aYe = /* @__PURE__ */ fX(sYe), na = new nYe.OptionValidator("@babel/preset-typescript");
  function oYe(e = {}) {
    let {
      allowNamespaces: t = !0,
      jsxPragma: r,
      onlyRemoveTypeImports: i
    } = e, s = {
      ignoreExtensions: "ignoreExtensions",
      allowNamespaces: "allowNamespaces",
      disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
      jsxPragma: "jsxPragma",
      jsxPragmaFrag: "jsxPragmaFrag",
      onlyRemoveTypeImports: "onlyRemoveTypeImports",
      optimizeConstEnums: "optimizeConstEnums",
      rewriteImportExtensions: "rewriteImportExtensions",
      allExtensions: "allExtensions",
      isTSX: "isTSX"
    }, a = na.validateStringOption(s.jsxPragmaFrag, e.jsxPragmaFrag, "React.Fragment");
    {
      var o = na.validateBooleanOption(s.allExtensions, e.allExtensions, !1), u = na.validateBooleanOption(s.isTSX, e.isTSX, !1);
      u && na.invariant(o, "isTSX:true requires allExtensions:true");
    }
    let l = na.validateBooleanOption(s.ignoreExtensions, e.ignoreExtensions, !1), c = na.validateBooleanOption(s.disallowAmbiguousJSXLike, e.
    disallowAmbiguousJSXLike, !1);
    c && na.invariant(o, "disallowAmbiguousJSXLike:true requires allExtensions:true");
    let f = na.validateBooleanOption(s.optimizeConstEnums, e.optimizeConstEnums, !1), m = na.validateBooleanOption(s.rewriteImportExtensions,
    e.rewriteImportExtensions, !1), h = {
      ignoreExtensions: l,
      allowNamespaces: t,
      disallowAmbiguousJSXLike: c,
      jsxPragma: r,
      jsxPragmaFrag: a,
      onlyRemoveTypeImports: i,
      optimizeConstEnums: f,
      rewriteImportExtensions: m
    };
    return h.allExtensions = o, h.isTSX = u, h;
  }
  n(oYe, "normalizeOptions");
  var uYe = cX.declare(function({
    types: e,
    template: t
  }) {
    function r(i, s, a) {
      if (i) {
        if (e.isStringLiteral(i)) {
          /^\.\.?\//.test(i.value) && (i.value = i.value.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+)?)\.([cm]?)ts$/i, function(o, u, l, c, f) {
            return u ? ".js" : l && (!c || !f) ? o : l + c + "." + f.toLowerCase() + "js";
          }));
          return;
        }
        a.availableHelper("tsRewriteRelativeImportExtensions") ? s.replaceWith(e.callExpression(a.addHelper("tsRewriteRelativeImportExtensio\
ns"), [i])) : s.replaceWith(t.expression.ast`(${i} + "").replace(/([\\/].*\.[mc]?)tsx?$/, "$1js")`);
      }
    }
    return n(r, "maybeReplace"), {
      name: "preset-typescript/plugin-rewrite-ts-imports",
      visitor: {
        "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"(i, s) {
          let a = i.node;
          (e.isImportDeclaration(a) ? a.importKind : a.exportKind) === "value" && r(a.source, i.get("source"), s);
        },
        CallExpression(i, s) {
          e.isImport(i.node.callee) && r(i.node.arguments[0], i.get("arguments.0"), s);
        },
        ImportExpression(i, s) {
          r(i.node.source, i.get("source"), s);
        }
      }
    };
  }), lYe = cX.declarePreset((e, t) => {
    e.assertVersion(7);
    let {
      allExtensions: r,
      ignoreExtensions: i,
      allowNamespaces: s,
      disallowAmbiguousJSXLike: a,
      isTSX: o,
      jsxPragma: u,
      jsxPragmaFrag: l,
      onlyRemoveTypeImports: c,
      optimizeConstEnums: f,
      rewriteImportExtensions: m
    } = oYe(t), h = /* @__PURE__ */ n((p) => ({
      allowDeclareFields: t.allowDeclareFields,
      allowNamespaces: s,
      disallowAmbiguousJSXLike: p,
      jsxPragma: u,
      jsxPragmaFrag: l,
      onlyRemoveTypeImports: c,
      optimizeConstEnums: f
    }), "pluginOptions"), d = /* @__PURE__ */ n((p, g) => [[lX.default, Object.assign({
      isTSX: p
    }, h(g))]], "getPlugins");
    return {
      plugins: m ? [uYe] : [],
      overrides: r || i ? [{
        plugins: d(o, a)
      }] : [{
        test: /\.ts$/,
        plugins: d(!1, !1)
      }, {
        test: /\.mts$/,
        sourceType: "module",
        plugins: d(!1, !0)
      }, {
        test: /\.cts$/,
        sourceType: "unambiguous",
        plugins: [[aYe.default, {
          allowTopLevelThis: !0
        }], [lX.default, h(!0)]]
      }, {
        test: /\.tsx$/,
        plugins: d(!0, !1)
      }]
    };
  });
  hP.default = lYe;
});

// ../node_modules/@babel/core/lib/config/files/module-types.js
var xP = E((Zp) => {
  "use strict";
  Object.defineProperty(Zp, "__esModule", {
    value: !0
  });
  Zp.default = pYe;
  Zp.supportsESM = void 0;
  var mP = Ka();
  function DP() {
    let e = require("path");
    return DP = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(DP, "_path");
  function gX() {
    let e = require("url");
    return gX = /* @__PURE__ */ n(function() {
      return e;
    }, "_url"), e;
  }
  n(gX, "_url");
  require("module");
  function vP() {
    let e = require("semver");
    return vP = /* @__PURE__ */ n(function() {
      return e;
    }, "_semver"), e;
  }
  n(vP, "_semver");
  function bX() {
    let e = zo();
    return bX = /* @__PURE__ */ n(function() {
      return e;
    }, "_debug"), e;
  }
  n(bX, "_debug");
  var DX = Kn(), Oc = du(), cYe = D3();
  function pX(e, t, r, i, s, a, o) {
    try {
      var u = e[a](o), l = u.value;
    } catch (c) {
      return void r(c);
    }
    u.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(pX, "asyncGeneratorStep");
  function fYe(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var a = e.apply(t, r);
        function o(l) {
          pX(a, i, s, o, u, "next", l);
        }
        n(o, "_next");
        function u(l) {
          pX(a, i, s, o, u, "throw", l);
        }
        n(u, "_throw"), o(void 0);
      });
    };
  }
  n(fYe, "_asyncToGenerator");
  var dYe = bX()("babel:config:loading:files:module-types");
  try {
    bP = Xz();
  } catch {
  }
  var bP, Xxt = Zp.supportsESM = vP().satisfies(process.versions.node, "^12.17 || >=13.2"), yP = /* @__PURE__ */ new Set();
  function Hg(e) {
    if (yP.has(e))
      return dYe("Auto-ignoring usage of config %o.", e), {};
    let t;
    try {
      yP.add(e), t = (0, DX.endHiddenCallStack)(require)(e);
    } finally {
      yP.delete(e);
    }
    return t != null && (t.__esModule || t[Symbol.toStringTag] === "Module") ? t.default || (arguments[1] ? t : void 0) : t;
  }
  n(Hg, "loadCjsDefault");
  var hX = (0, DX.endHiddenCallStack)(function() {
    var e = fYe(function* (r) {
      let i = (0, gX().pathToFileURL)(r).toString() + "?import";
      {
        if (!bP)
          throw new Oc.default(`Internal error: Native ECMAScript modules aren't supported by this platform.
`, r);
        return yield bP(i);
      }
    });
    function t(r) {
      return e.apply(this, arguments);
    }
    return n(t, "loadMjsFromPath"), t;
  }()), vX = /* @__PURE__ */ n((e) => `You are using a ${e} config file, but Babel only supports transpiling .cts configs. Either:
- Use a .cts config file
- Update to Node.js 23.6.0, which has native TypeScript support
- Install tsx to transpile ${e} files on the fly`, "tsNotSupportedError"), mX = {
    ".js": "unknown",
    ".mjs": "esm",
    ".cjs": "cjs",
    ".ts": "unknown",
    ".mts": "esm",
    ".cts": "cjs"
  }, yX = /* @__PURE__ */ new Set();
  function* pYe(e, t, r, i) {
    let s, a = DP().extname(e), o = a === ".ts" || a === ".cts" || a === ".mts", u = mX[hasOwnProperty.call(mX, a) ? a : ".js"];
    switch (`${t} ${u}`) {
      case "require cjs":
      case "auto cjs":
        return o ? gP(e, a, () => Hg(e)) : Hg(e, arguments[2]);
      case "auto unknown":
      case "require unknown":
      case "require esm":
        try {
          return o ? gP(e, a, () => Hg(e)) : Hg(e, arguments[2]);
        } catch (c) {
          if (c.code === "ERR_REQUIRE_ASYNC_MODULE" || c.code === "ERR_REQUIRE_CYCLE_MODULE" && yX.has(e)) {
            if (yX.add(e), !(s ?? (s = yield* (0, mP.isAsync)())))
              throw new Oc.default(i, e);
          } else if (!(c.code === "ERR_REQUIRE_ESM" || u === "esm"))
            throw c;
        }
      case "auto esm":
        if (s ?? (s = yield* (0, mP.isAsync)())) {
          let c = o ? gP(e, a, () => hX(e)) : hX(e);
          return (yield* (0, mP.waitFor)(c)).default;
        }
        throw o ? new Oc.default(vX(a), e) : new Oc.default(r, e);
      default:
        throw new Error("Internal Babel error: unreachable code.");
    }
  }
  n(pYe, "loadCodeDefault");
  function gP(e, t, r) {
    if (process.features.typescript || require.extensions[".ts"] || require.extensions[".cts"] || require.extensions[".mts"])
      return r();
    if (t !== ".cts")
      throw new Oc.default(vX(t), e);
    let i = {
      babelrc: !1,
      configFile: !1,
      sourceType: "unambiguous",
      sourceMaps: "inline",
      sourceFileName: DP().basename(e),
      presets: [[hYe(e), Object.assign({
        onlyRemoveTypeImports: !0,
        optimizeConstEnums: !0
      }, {
        allowDeclareFields: !0
      })]]
    }, s = /* @__PURE__ */ n(function(a, o) {
      if (s && o.endsWith(".cts"))
        try {
          return a._compile((0, cYe.transformFileSync)(o, Object.assign({}, i, {
            filename: o
          })).code, o);
        } catch (u) {
          let l = Yz();
          throw vP().lt(l.version, "7.21.4") && console.error("`.cts` configuration file failed to load, please try to update `@babel/preset\
-typescript`."), u;
        }
      return require.extensions[".js"](a, o);
    }, "handler");
    require.extensions[t] = s;
    try {
      return r();
    } finally {
      require.extensions[t] === s && delete require.extensions[t], s = void 0;
    }
  }
  n(gP, "ensureTsSupport");
  function hYe(e) {
    try {
      return dX();
    } catch (t) {
      if (t.code !== "MODULE_NOT_FOUND") throw t;
      let r = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please i\
nstall it!";
      throw process.versions.pnp && (r += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`), new Oc.default(r, e);
    }
  }
  n(hYe, "getTSPreset");
});

// ../node_modules/@babel/core/lib/config/files/configuration.js
var FX = E((aa) => {
  "use strict";
  Object.defineProperty(aa, "__esModule", {
    value: !0
  });
  aa.ROOT_CONFIG_FILENAMES = void 0;
  aa.findConfigUpwards = PYe;
  aa.findRelativeConfig = FYe;
  aa.findRootConfig = IYe;
  aa.loadConfig = OYe;
  aa.resolveShowConfigPath = kYe;
  function EX() {
    let e = zo();
    return EX = /* @__PURE__ */ n(function() {
      return e;
    }, "_debug"), e;
  }
  n(EX, "_debug");
  function EP() {
    let e = require("fs");
    return EP = /* @__PURE__ */ n(function() {
      return e;
    }, "_fs"), e;
  }
  n(EP, "_fs");
  function Oi() {
    let e = require("path");
    return Oi = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(Oi, "_path");
  function SX() {
    let e = dW();
    return SX = /* @__PURE__ */ n(function() {
      return e;
    }, "_json"), e;
  }
  n(SX, "_json");
  function TX() {
    let e = _i();
    return TX = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n(TX, "_gensync");
  var CX = fu(), mYe = kA(), wX = xA(), yYe = xP(), gYe = w_(), Fs = du(), bYe = x1();
  require("module");
  var DYe = Kn(), vYe = Ka(), SP = EX()("babel:config:loading:files:configuration"), AX = aa.ROOT_CONFIG_FILENAMES = ["babel.config.js", "ba\
bel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config.cts", "babel.config.ts", "babel.config.mts"], xYe = [".babelrc", ".b\
abelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"], EYe = ".babelignore", SYe = (0, CX.makeWeakCache)(/* @__PURE__ */ n(
  function* (t, r) {
    return yield* [], {
      options: (0, DYe.endHiddenCallStack)(t)((0, mYe.makeConfigAPI)(r)),
      cacheNeedsConfiguration: !r.configured()
    };
  }, "runConfig"));
  function* TYe(e, t) {
    if (!EP().existsSync(e)) return null;
    let r = yield* (0, yYe.default)(e, (yield* (0, vYe.isAsync)()) ? "auto" : "require", "You appear to be using a native ECMAScript module \
configuration file, which is only supported when running Babel asynchronously or when using the Node.js `--experimental-require-module` flag\
.", "You appear to be using a configuration file that contains top-level await, which is only supported when running Babel asynchronously."),
    i = !1;
    if (typeof r == "function" && ({
      options: r,
      cacheNeedsConfiguration: i
    } = yield* SYe(r, t)), !r || typeof r != "object" || Array.isArray(r))
      throw new Fs.default("Configuration should be an exported JavaScript object.", e);
    if (typeof r.then == "function")
      throw r.catch == null || r.catch(() => {
      }), new Fs.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add su\
pport for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synch\
ronously return your config.", e);
    return i && BYe(e), CYe(r, e);
  }
  n(TYe, "readConfigCode");
  var xX = /* @__PURE__ */ new WeakMap();
  function CYe(e, t) {
    let r = xX.get(e);
    r || xX.set(e, r = /* @__PURE__ */ new Map());
    let i = r.get(t);
    return i || (i = {
      filepath: t,
      dirname: Oi().dirname(t),
      options: e
    }, r.set(t, i)), i;
  }
  n(CYe, "buildConfigFileObject");
  var wYe = (0, CX.makeWeakCacheSync)((e) => {
    let t = e.options.babel;
    if (t === void 0) return null;
    if (typeof t != "object" || Array.isArray(t) || t === null)
      throw new Fs.default(".babel property must be an object", e.filepath);
    return {
      filepath: e.filepath,
      dirname: e.dirname,
      options: t
    };
  }), AYe = (0, wX.makeStaticFileCache)((e, t) => {
    let r;
    try {
      r = SX().parse(t);
    } catch (i) {
      throw new Fs.default(`Error while parsing config - ${i.message}`, e);
    }
    if (!r) throw new Fs.default("No config detected", e);
    if (typeof r != "object")
      throw new Fs.default(`Config returned typeof ${typeof r}`, e);
    if (Array.isArray(r))
      throw new Fs.default("Expected config object but found array", e);
    return delete r.$schema, {
      filepath: e,
      dirname: Oi().dirname(e),
      options: r
    };
  }), _Ye = (0, wX.makeStaticFileCache)((e, t) => {
    let r = Oi().dirname(e), i = t.split(`
`).map((s) => s.replace(/#.*$/, "").trim()).filter(Boolean);
    for (let s of i)
      if (s[0] === "!")
        throw new Fs.default("Negation of file paths is not supported.", e);
    return {
      filepath: e,
      dirname: Oi().dirname(e),
      ignore: i.map((s) => (0, gYe.default)(s, r))
    };
  });
  function PYe(e) {
    let t = e;
    for (; ; ) {
      for (let i of AX)
        if (EP().existsSync(Oi().join(t, i)))
          return t;
      let r = Oi().dirname(t);
      if (t === r) break;
      t = r;
    }
    return null;
  }
  n(PYe, "findConfigUpwards");
  function* FYe(e, t, r) {
    let i = null, s = null, a = Oi().dirname(e.filepath);
    for (let u of e.directories) {
      if (!i) {
        var o;
        i = yield* _X(xYe, u, t, r, ((o = e.pkg) == null ? void 0 : o.dirname) === u ? wYe(e.pkg) : null);
      }
      if (!s) {
        let l = Oi().join(u, EYe);
        s = yield* _Ye(l), s && SP("Found ignore %o from %o.", s.filepath, a);
      }
    }
    return {
      config: i,
      ignore: s
    };
  }
  n(FYe, "findRelativeConfig");
  function IYe(e, t, r) {
    return _X(AX, e, t, r);
  }
  n(IYe, "findRootConfig");
  function* _X(e, t, r, i, s = null) {
    let o = (yield* TX().all(e.map((u) => PX(Oi().join(t, u), r, i)))).reduce((u, l) => {
      if (l && u)
        throw new Fs.default(`Multiple configuration files found. Please remove one:
 - ${Oi().basename(u.filepath)}
 - ${l.filepath}
from ${t}`);
      return l || u;
    }, s);
    return o && SP("Found configuration %o from %o.", o.filepath, t), o;
  }
  n(_X, "loadOneConfig");
  function* OYe(e, t, r, i) {
    let s = (((o, u) => (o = o.split("."), u = u.split("."), +o[0] > +u[0] || o[0] == u[0] && +o[1] >= +u[1]))(process.versions.node, "8.9") ?
    require.resolve : (o, {
      paths: [u]
    }, l = require("module")) => {
      let c = l._findPath(o, l._nodeModulePaths(u).concat(u));
      if (c) return c;
      throw c = new Error(`Cannot resolve module '${o}'`), c.code = "MODULE_NOT_FOUND", c;
    })(e, {
      paths: [t]
    }), a = yield* PX(s, r, i);
    if (!a)
      throw new Fs.default("Config file contains no configuration data", s);
    return SP("Loaded config %o from %o.", e, t), a;
  }
  n(OYe, "loadConfig");
  function PX(e, t, r) {
    switch (Oi().extname(e)) {
      case ".js":
      case ".cjs":
      case ".mjs":
      case ".ts":
      case ".cts":
      case ".mts":
        return TYe(e, {
          envName: t,
          caller: r
        });
      default:
        return AYe(e);
    }
  }
  n(PX, "readConfig");
  function* kYe(e) {
    let t = process.env.BABEL_SHOW_CONFIG_FOR;
    if (t != null) {
      let r = Oi().resolve(e, t);
      if (!(yield* bYe.stat(r)).isFile())
        throw new Error(`${r}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
      return r;
    }
    return null;
  }
  n(kYe, "resolveShowConfigPath");
  function BYe(e) {
    throw new Fs.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, e);
  }
  n(BYe, "throwConfigError");
});

// ../node_modules/@babel/core/lib/vendor/import-meta-resolve.js
var tY = E((Gg) => {
  "use strict";
  Object.defineProperty(Gg, "__esModule", {
    value: !0
  });
  Gg.moduleResolve = eY;
  Gg.resolve = CGe;
  function un() {
    let e = require("assert");
    return un = /* @__PURE__ */ n(function() {
      return e;
    }, "_assert"), e;
  }
  n(un, "_assert");
  function rh() {
    let e = WX(require("fs"), !0);
    return rh = /* @__PURE__ */ n(function() {
      return e;
    }, "_fs"), e;
  }
  n(rh, "_fs");
  function so() {
    let e = require("process");
    return so = /* @__PURE__ */ n(function() {
      return e;
    }, "_process"), e;
  }
  n(so, "_process");
  function xe() {
    let e = require("url");
    return xe = /* @__PURE__ */ n(function() {
      return e;
    }, "_url"), e;
  }
  n(xe, "_url");
  function Jg() {
    let e = require("path");
    return Jg = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(Jg, "_path");
  function Xg() {
    let e = require("module");
    return Xg = /* @__PURE__ */ n(function() {
      return e;
    }, "_module"), e;
  }
  n(Xg, "_module");
  function VX() {
    let e = require("v8");
    return VX = /* @__PURE__ */ n(function() {
      return e;
    }, "_v"), e;
  }
  n(VX, "_v");
  function th() {
    let e = require("util");
    return th = /* @__PURE__ */ n(function() {
      return e;
    }, "_util"), e;
  }
  n(th, "_util");
  function WX(e, t) {
    if (typeof WeakMap == "function") var r = /* @__PURE__ */ new WeakMap(), i = /* @__PURE__ */ new WeakMap();
    return (WX = /* @__PURE__ */ n(function(s, a) {
      if (!a && s && s.__esModule) return s;
      var o, u, l = { __proto__: null, default: s };
      if (s === null || typeof s != "object" && typeof s != "function") return l;
      if (o = a ? i : r) {
        if (o.has(s)) return o.get(s);
        o.set(s, l);
      }
      for (let c in s) c !== "default" && {}.hasOwnProperty.call(s, c) && ((u = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(
      s, c)) && (u.get || u.set) ? o(l, c, u) : l[c] = s[c]);
      return l;
    }, "_interopRequireWildcard"))(e, t);
  }
  n(WX, "_interopRequireWildcard");
  var NYe = {}.hasOwnProperty, MYe = /^([A-Z][a-z\d]*)+$/, RYe = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Functio\
n", "Object", "boolean", "bigint", "symbol"]), Rr = {};
  function TP(e, t = "and") {
    return e.length < 3 ? e.join(` ${t} `) : `${e.slice(0, -1).join(", ")}, ${t} ${e[e.length - 1]}`;
  }
  n(TP, "formatList");
  var HX = /* @__PURE__ */ new Map(), LYe = "__node_internal_", IX;
  Rr.ERR_INVALID_ARG_TYPE = is("ERR_INVALID_ARG_TYPE", (e, t, r) => {
    un()(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let i = "The ";
    if (e.endsWith(" argument"))
      i += `${e} `;
    else {
      let u = e.includes(".") ? "property" : "argument";
      i += `"${e}" ${u} `;
    }
    i += "must be ";
    let s = [], a = [], o = [];
    for (let u of t)
      un()(typeof u == "string", "All expected entries have to be of type string"), RYe.has(u) ? s.push(u.toLowerCase()) : MYe.exec(u) === null ?
      (un()(u !== "object", 'The value "object" should be written as "Object"'), o.push(u)) : a.push(u);
    if (a.length > 0) {
      let u = s.indexOf("object");
      u !== -1 && (s.slice(u, 1), a.push("Object"));
    }
    return s.length > 0 && (i += `${s.length > 1 ? "one of type" : "of type"} ${TP(s, "or")}`, (a.length > 0 || o.length > 0) && (i += " or ")),
    a.length > 0 && (i += `an instance of ${TP(a, "or")}`, o.length > 0 && (i += " or ")), o.length > 0 && (o.length > 1 ? i += `one of ${TP(
    o, "or")}` : (o[0].toLowerCase() !== o[0] && (i += "an "), i += `${o[0]}`)), i += `. Received ${VYe(r)}`, i;
  }, TypeError);
  Rr.ERR_INVALID_MODULE_SPECIFIER = is("ERR_INVALID_MODULE_SPECIFIER", (e, t, r = void 0) => `Invalid module "${e}" ${t}${r ? ` imported fro\
m ${r}` : ""}`, TypeError);
  Rr.ERR_INVALID_PACKAGE_CONFIG = is("ERR_INVALID_PACKAGE_CONFIG", (e, t, r) => `Invalid package config ${e}${t ? ` while importing ${t}` : ""}${r ?
  `. ${r}` : ""}`, Error);
  Rr.ERR_INVALID_PACKAGE_TARGET = is("ERR_INVALID_PACKAGE_TARGET", (e, t, r, i = !1, s = void 0) => {
    let a = typeof r == "string" && !i && r.length > 0 && !r.startsWith("./");
    return t === "." ? (un()(i === !1), `Invalid "exports" main target ${JSON.stringify(r)} defined in the package config ${e}package.json${s ?
    ` imported from ${s}` : ""}${a ? '; targets must start with "./"' : ""}`) : `Invalid "${i ? "imports" : "exports"}" target ${JSON.stringify(
    r)} defined for '${t}' in the package config ${e}package.json${s ? ` imported from ${s}` : ""}${a ? '; targets must start with "./"' : ""}`;
  }, Error);
  Rr.ERR_MODULE_NOT_FOUND = is("ERR_MODULE_NOT_FOUND", (e, t, r = !1) => `Cannot find ${r ? "module" : "package"} '${e}' imported from ${t}`,
  Error);
  Rr.ERR_NETWORK_IMPORT_DISALLOWED = is("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
  Rr.ERR_PACKAGE_IMPORT_NOT_DEFINED = is("ERR_PACKAGE_IMPORT_NOT_DEFINED", (e, t, r) => `Package import specifier "${e}" is not defined${t ?
  ` in package ${t}package.json` : ""} imported from ${r}`, TypeError);
  Rr.ERR_PACKAGE_PATH_NOT_EXPORTED = is("ERR_PACKAGE_PATH_NOT_EXPORTED", (e, t, r = void 0) => t === "." ? `No "exports" main defined in ${e}\
package.json${r ? ` imported from ${r}` : ""}` : `Package subpath '${t}' is not defined by "exports" in ${e}package.json${r ? ` imported fro\
m ${r}` : ""}`, Error);
  Rr.ERR_UNSUPPORTED_DIR_IMPORT = is("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported fro\
m %s", Error);
  Rr.ERR_UNSUPPORTED_RESOLVE_REQUEST = is("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid rel\
ative URL or base scheme is not hierarchical.', TypeError);
  Rr.ERR_UNKNOWN_FILE_EXTENSION = is("ERR_UNKNOWN_FILE_EXTENSION", (e, t) => `Unknown file extension "${e}" for ${t}`, TypeError);
  Rr.ERR_INVALID_ARG_VALUE = is("ERR_INVALID_ARG_VALUE", (e, t, r = "is invalid") => {
    let i = (0, th().inspect)(t);
    return i.length > 128 && (i = `${i.slice(0, 128)}...`), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${i}`;
  }, TypeError);
  function is(e, t, r) {
    return HX.set(e, t), jYe(r, e);
  }
  n(is, "createError");
  function jYe(e, t) {
    return r;
    function r(...i) {
      let s = Error.stackTraceLimit;
      _P() && (Error.stackTraceLimit = 0);
      let a = new e();
      _P() && (Error.stackTraceLimit = s);
      let o = $Ye(t, i, a);
      return Object.defineProperties(a, {
        message: {
          value: o,
          enumerable: !1,
          writable: !0,
          configurable: !0
        },
        toString: {
          value() {
            return `${this.name} [${t}]: ${this.message}`;
          },
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), UYe(a), a.code = t, a;
    }
  }
  n(jYe, "makeNodeErrorWithCode");
  function _P() {
    try {
      if (VX().startupSnapshot.isBuildingSnapshot())
        return !1;
    } catch {
    }
    let e = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
    return e === void 0 ? Object.isExtensible(Error) : NYe.call(e, "writable") && e.writable !== void 0 ? e.writable : e.set !== void 0;
  }
  n(_P, "isErrorStackTraceLimitWritable");
  function qYe(e) {
    let t = LYe + e.name;
    return Object.defineProperty(e, "name", {
      value: t
    }), e;
  }
  n(qYe, "hideStackFrames");
  var UYe = qYe(function(e) {
    let t = _P();
    return t && (IX = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(e), t && (Error.stackTraceLimit =
    IX), e;
  });
  function $Ye(e, t, r) {
    let i = HX.get(e);
    if (un()(i !== void 0, "expected `message` to be found"), typeof i == "function")
      return un()(i.length <= t.length, `Code: ${e}; The provided arguments length (${t.length}) does not match the required ones (${i.length}\
).`), Reflect.apply(i, r, t);
    let s = /%[dfijoOs]/g, a = 0;
    for (; s.exec(i) !== null; ) a++;
    return un()(a === t.length, `Code: ${e}; The provided arguments length (${t.length}) does not match the required ones (${a}).`), t.length ===
    0 ? i : (t.unshift(i), Reflect.apply(th().format, null, t));
  }
  n($Ye, "getMessage");
  function VYe(e) {
    if (e == null)
      return String(e);
    if (typeof e == "function" && e.name)
      return `function ${e.name}`;
    if (typeof e == "object")
      return e.constructor && e.constructor.name ? `an instance of ${e.constructor.name}` : `${(0, th().inspect)(e, {
        depth: -1
      })}`;
    let t = (0, th().inspect)(e, {
      colors: !1
    });
    return t.length > 28 && (t = `${t.slice(0, 25)}...`), `type ${typeof e} (${t})`;
  }
  n(VYe, "determineSpecificType");
  var Qp = {}.hasOwnProperty, {
    ERR_INVALID_PACKAGE_CONFIG: WYe
  } = Rr, OX = /* @__PURE__ */ new Map();
  function KX(e, {
    base: t,
    specifier: r
  }) {
    let i = OX.get(e);
    if (i)
      return i;
    let s;
    try {
      s = rh().default.readFileSync(Jg().toNamespacedPath(e), "utf8");
    } catch (o) {
      let u = o;
      if (u.code !== "ENOENT")
        throw u;
    }
    let a = {
      exists: !1,
      pjsonPath: e,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    if (s !== void 0) {
      let o;
      try {
        o = JSON.parse(s);
      } catch (u) {
        let l = u, c = new WYe(e, (t ? `"${r}" from ` : "") + (0, xe().fileURLToPath)(t || r), l.message);
        throw c.cause = l, c;
      }
      a.exists = !0, Qp.call(o, "name") && typeof o.name == "string" && (a.name = o.name), Qp.call(o, "main") && typeof o.main == "string" &&
      (a.main = o.main), Qp.call(o, "exports") && (a.exports = o.exports), Qp.call(o, "imports") && (a.imports = o.imports), Qp.call(o, "typ\
e") && (o.type === "commonjs" || o.type === "module") && (a.type = o.type);
    }
    return OX.set(e, a), a;
  }
  n(KX, "read");
  function PP(e) {
    let t = new URL("package.json", e);
    for (; !t.pathname.endsWith("node_modules/package.json"); ) {
      let s = KX((0, xe().fileURLToPath)(t), {
        specifier: e
      });
      if (s.exists)
        return s;
      let a = t;
      if (t = new URL("../package.json", t), t.pathname === a.pathname)
        break;
    }
    return {
      pjsonPath: (0, xe().fileURLToPath)(t),
      exists: !1,
      type: "none"
    };
  }
  n(PP, "getPackageScopeConfig");
  function kX(e) {
    return PP(e).type;
  }
  n(kX, "getPackageType");
  var {
    ERR_UNKNOWN_FILE_EXTENSION: HYe
  } = Rr, KYe = {}.hasOwnProperty, zYe = {
    __proto__: null,
    ".cjs": "commonjs",
    ".js": "module",
    ".json": "json",
    ".mjs": "module"
  };
  function JYe(e) {
    return e && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(e) ? "module" : e === "application/json" ? "json" : null;
  }
  n(JYe, "mimeToFormat");
  var BX = {
    __proto__: null,
    "data:": XYe,
    "file:": GYe,
    "http:": NX,
    "https:": NX,
    "node:"() {
      return "builtin";
    }
  };
  function XYe(e) {
    let {
      1: t
    } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(e.pathname) || [null, null, null];
    return JYe(t);
  }
  n(XYe, "getDataProtocolModuleFormat");
  function YYe(e) {
    let t = e.pathname, r = t.length;
    for (; r--; ) {
      let i = t.codePointAt(r);
      if (i === 47)
        return "";
      if (i === 46)
        return t.codePointAt(r - 1) === 47 ? "" : t.slice(r);
    }
    return "";
  }
  n(YYe, "extname");
  function GYe(e, t, r) {
    let i = YYe(e);
    if (i === ".js") {
      let o = kX(e);
      return o !== "none" ? o : "commonjs";
    }
    if (i === "") {
      let o = kX(e);
      return o === "none" || o === "commonjs" ? "commonjs" : "module";
    }
    let s = zYe[i];
    if (s) return s;
    if (r)
      return;
    let a = (0, xe().fileURLToPath)(e);
    throw new HYe(i, a);
  }
  n(GYe, "getFileProtocolModuleFormat");
  function NX() {
  }
  n(NX, "getHttpProtocolModuleFormat");
  function zX(e, t) {
    let r = e.protocol;
    return KYe.call(BX, r) && BX[r](e, t, !0) || null;
  }
  n(zX, "defaultGetFormatWithoutErrors");
  var {
    ERR_INVALID_ARG_VALUE: ZYe
  } = Rr, JX = Object.freeze(["node", "import"]), QYe = new Set(JX);
  function eGe() {
    return JX;
  }
  n(eGe, "getDefaultConditions");
  function tGe() {
    return QYe;
  }
  n(tGe, "getDefaultConditionsSet");
  function rGe(e) {
    if (e !== void 0 && e !== eGe()) {
      if (!Array.isArray(e))
        throw new ZYe("conditions", e, "expected an array");
      return new Set(e);
    }
    return tGe();
  }
  n(rGe, "getConditionsSet");
  var Kg = RegExp.prototype[Symbol.replace], {
    ERR_NETWORK_IMPORT_DISALLOWED: CP,
    ERR_INVALID_MODULE_SPECIFIER: Yg,
    ERR_INVALID_PACKAGE_CONFIG: XX,
    ERR_INVALID_PACKAGE_TARGET: iGe,
    ERR_MODULE_NOT_FOUND: FP,
    ERR_PACKAGE_IMPORT_NOT_DEFINED: sGe,
    ERR_PACKAGE_PATH_NOT_EXPORTED: nGe,
    ERR_UNSUPPORTED_DIR_IMPORT: aGe,
    ERR_UNSUPPORTED_RESOLVE_REQUEST: MX
  } = Rr, YX = {}.hasOwnProperty, RX = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i,
  LX = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i,
  oGe = /^\.|%|\\/, zg = /\*/g, uGe = /%2f|%5c/i, jX = /* @__PURE__ */ new Set(), lGe = /[/\\]{2}/;
  function qX(e, t, r, i, s, a, o) {
    if (so().noDeprecation)
      return;
    let u = (0, xe().fileURLToPath)(i), l = lGe.exec(o ? e : t) !== null;
    so().emitWarning(`Use of deprecated ${l ? "double slash" : "leading or trailing slash matching"} resolving "${e}" for module request "${t}\
" ${t === r ? "" : `matched to "${r}" `}in the "${s ? "imports" : "exports"}" field module resolution of the package at ${u}${a ? ` imported\
 from ${(0, xe().fileURLToPath)(a)}` : ""}.`, "DeprecationWarning", "DEP0166");
  }
  n(qX, "emitInvalidSegmentDeprecation");
  function UX(e, t, r, i) {
    if (so().noDeprecation || zX(e, {
      parentURL: r.href
    }) !== "module") return;
    let a = (0, xe().fileURLToPath)(e.href), o = (0, xe().fileURLToPath)(new (xe()).URL(".", t)), u = (0, xe().fileURLToPath)(r);
    i ? Jg().resolve(o, i) !== a && so().emitWarning(`Package ${o} has a "main" field set to "${i}", excluding the full filename and extensi\
on to the resolved file at "${a.slice(o.length)}", imported from ${u}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : so().emitWarning(`No \
"main" or "exports" field defined in the package.json for ${o} resolving the main entry point "${a.slice(o.length)}", imported from ${u}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
  }
  n(UX, "emitLegacyIndexDeprecation");
  function GX(e) {
    try {
      return (0, rh().statSync)(e);
    } catch {
    }
  }
  n(GX, "tryStatSync");
  function wP(e) {
    let t = (0, rh().statSync)(e, {
      throwIfNoEntry: !1
    }), r = t ? t.isFile() : void 0;
    return r ?? !1;
  }
  n(wP, "fileExists");
  function cGe(e, t, r) {
    let i;
    if (t.main !== void 0) {
      if (i = new (xe()).URL(t.main, e), wP(i)) return i;
      let o = [`./${t.main}.js`, `./${t.main}.json`, `./${t.main}.node`, `./${t.main}/index.js`, `./${t.main}/index.json`, `./${t.main}/inde\
x.node`], u = -1;
      for (; ++u < o.length && (i = new (xe()).URL(o[u], e), !wP(i)); )
        i = void 0;
      if (i)
        return UX(i, e, r, t.main), i;
    }
    let s = ["./index.js", "./index.json", "./index.node"], a = -1;
    for (; ++a < s.length && (i = new (xe()).URL(s[a], e), !wP(i)); )
      i = void 0;
    if (i)
      return UX(i, e, r, t.main), i;
    throw new FP((0, xe().fileURLToPath)(new (xe()).URL(".", e)), (0, xe().fileURLToPath)(r));
  }
  n(cGe, "legacyMainResolve");
  function fGe(e, t, r) {
    if (uGe.exec(e.pathname) !== null)
      throw new Yg(e.pathname, 'must not include encoded "/" or "\\" characters', (0, xe().fileURLToPath)(t));
    let i;
    try {
      i = (0, xe().fileURLToPath)(e);
    } catch (a) {
      let o = a;
      throw Object.defineProperty(o, "input", {
        value: String(e)
      }), Object.defineProperty(o, "module", {
        value: String(t)
      }), o;
    }
    let s = GX(i.endsWith("/") ? i.slice(-1) : i);
    if (s && s.isDirectory()) {
      let a = new aGe(i, (0, xe().fileURLToPath)(t));
      throw a.url = String(e), a;
    }
    if (!s || !s.isFile()) {
      let a = new FP(i || e.pathname, t && (0, xe().fileURLToPath)(t), !0);
      throw a.url = String(e), a;
    }
    if (!r) {
      let a = (0, rh().realpathSync)(i), {
        search: o,
        hash: u
      } = e;
      e = (0, xe().pathToFileURL)(a + (i.endsWith(Jg().sep) ? "/" : "")), e.search = o, e.hash = u;
    }
    return e;
  }
  n(fGe, "finalizeResolution");
  function dGe(e, t, r) {
    return new sGe(e, t && (0, xe().fileURLToPath)(new (xe()).URL(".", t)), (0, xe().fileURLToPath)(r));
  }
  n(dGe, "importNotDefined");
  function AP(e, t, r) {
    return new nGe((0, xe().fileURLToPath)(new (xe()).URL(".", t)), e, r && (0, xe().fileURLToPath)(r));
  }
  n(AP, "exportsNotFound");
  function pGe(e, t, r, i, s) {
    let a = `request is not a valid match in pattern "${t}" for the "${i ? "imports" : "exports"}" resolution of ${(0, xe().fileURLToPath)(r)}`;
    throw new Yg(e, a, s && (0, xe().fileURLToPath)(s));
  }
  n(pGe, "throwInvalidSubpath");
  function eh(e, t, r, i, s) {
    return t = typeof t == "object" && t !== null ? JSON.stringify(t, null, "") : `${t}`, new iGe((0, xe().fileURLToPath)(new (xe()).URL(".",
    r)), e, t, i, s && (0, xe().fileURLToPath)(s));
  }
  n(eh, "invalidPackageTarget");
  function hGe(e, t, r, i, s, a, o, u, l) {
    if (t !== "" && !a && e[e.length - 1] !== "/") throw eh(r, e, i, o, s);
    if (!e.startsWith("./")) {
      if (o && !e.startsWith("../") && !e.startsWith("/")) {
        let h = !1;
        try {
          new (xe()).URL(e), h = !0;
        } catch {
        }
        if (!h) {
          let d = a ? Kg.call(zg, e, () => t) : e + t;
          return QX(d, i, l);
        }
      }
      throw eh(r, e, i, o, s);
    }
    if (RX.exec(e.slice(2)) !== null)
      if (LX.exec(e.slice(2)) === null) {
        if (!u) {
          let h = a ? r.replace("*", () => t) : r + t, d = a ? Kg.call(zg, e, () => t) : e;
          qX(d, h, r, i, o, s, !0);
        }
      } else
        throw eh(r, e, i, o, s);
    let c = new (xe()).URL(e, i), f = c.pathname, m = new (xe()).URL(".", i).pathname;
    if (!f.startsWith(m)) throw eh(r, e, i, o, s);
    if (t === "") return c;
    if (RX.exec(t) !== null) {
      let h = a ? r.replace("*", () => t) : r + t;
      if (LX.exec(t) === null) {
        if (!u) {
          let d = a ? Kg.call(zg, e, () => t) : e;
          qX(d, h, r, i, o, s, !1);
        }
      } else
        pGe(h, r, i, o, s);
    }
    return a ? new (xe()).URL(Kg.call(zg, c.href, () => t)) : new (xe()).URL(t, c);
  }
  n(hGe, "resolvePackageTargetString");
  function mGe(e) {
    let t = Number(e);
    return `${t}` !== e ? !1 : t >= 0 && t < 4294967295;
  }
  n(mGe, "isArrayIndex");
  function kc(e, t, r, i, s, a, o, u, l) {
    if (typeof t == "string")
      return hGe(t, r, i, e, s, a, o, u, l);
    if (Array.isArray(t)) {
      let c = t;
      if (c.length === 0) return null;
      let f, m = -1;
      for (; ++m < c.length; ) {
        let h = c[m], d;
        try {
          d = kc(e, h, r, i, s, a, o, u, l);
        } catch (y) {
          let p = y;
          if (f = p, p.code === "ERR_INVALID_PACKAGE_TARGET") continue;
          throw y;
        }
        if (d !== void 0) {
          if (d === null) {
            f = null;
            continue;
          }
          return d;
        }
      }
      if (f == null)
        return null;
      throw f;
    }
    if (typeof t == "object" && t !== null) {
      let c = Object.getOwnPropertyNames(t), f = -1;
      for (; ++f < c.length; ) {
        let m = c[f];
        if (mGe(m))
          throw new XX((0, xe().fileURLToPath)(e), s, '"exports" cannot contain numeric property keys.');
      }
      for (f = -1; ++f < c.length; ) {
        let m = c[f];
        if (m === "default" || l && l.has(m)) {
          let h = t[m], d = kc(e, h, r, i, s, a, o, u, l);
          if (d === void 0) continue;
          return d;
        }
      }
      return null;
    }
    if (t === null)
      return null;
    throw eh(i, t, e, o, s);
  }
  n(kc, "resolvePackageTarget");
  function yGe(e, t, r) {
    if (typeof e == "string" || Array.isArray(e)) return !0;
    if (typeof e != "object" || e === null) return !1;
    let i = Object.getOwnPropertyNames(e), s = !1, a = 0, o = -1;
    for (; ++o < i.length; ) {
      let u = i[o], l = u === "" || u[0] !== ".";
      if (a++ === 0)
        s = l;
      else if (s !== l)
        throw new XX((0, xe().fileURLToPath)(t), r, `"exports" cannot contain some keys starting with '.' and some not. The exports object m\
ust either be an object of package subpath keys or an object of main entry condition name keys only.`);
    }
    return s;
  }
  n(yGe, "isConditionalExportsMainSugar");
  function gGe(e, t, r) {
    if (so().noDeprecation)
      return;
    let i = (0, xe().fileURLToPath)(t);
    jX.has(i + "|" + e) || (jX.add(i + "|" + e), so().emitWarning(`Use of deprecated trailing slash pattern mapping "${e}" in the "exports" \
field module resolution of the package at ${i}${r ? ` imported from ${(0, xe().fileURLToPath)(r)}` : ""}. Mapping specifiers ending in "/" i\
s no longer supported.`, "DeprecationWarning", "DEP0155"));
  }
  n(gGe, "emitTrailingSlashPatternDeprecation");
  function $X(e, t, r, i, s) {
    let a = r.exports;
    if (yGe(a, e, i) && (a = {
      ".": a
    }), YX.call(a, t) && !t.includes("*") && !t.endsWith("/")) {
      let f = a[t], m = kc(e, f, "", t, i, !1, !1, !1, s);
      if (m == null)
        throw AP(t, e, i);
      return m;
    }
    let o = "", u = "", l = Object.getOwnPropertyNames(a), c = -1;
    for (; ++c < l.length; ) {
      let f = l[c], m = f.indexOf("*");
      if (m !== -1 && t.startsWith(f.slice(0, m))) {
        t.endsWith("/") && gGe(t, e, i);
        let h = f.slice(m + 1);
        t.length >= f.length && t.endsWith(h) && ZX(o, f) === 1 && f.lastIndexOf("*") === m && (o = f, u = t.slice(m, t.length - h.length));
      }
    }
    if (o) {
      let f = a[o], m = kc(e, f, u, o, i, !0, !1, t.endsWith("/"), s);
      if (m == null)
        throw AP(t, e, i);
      return m;
    }
    throw AP(t, e, i);
  }
  n($X, "packageExportsResolve");
  function ZX(e, t) {
    let r = e.indexOf("*"), i = t.indexOf("*"), s = r === -1 ? e.length : r + 1, a = i === -1 ? t.length : i + 1;
    return s > a ? -1 : a > s || r === -1 ? 1 : i === -1 || e.length > t.length ? -1 : t.length > e.length ? 1 : 0;
  }
  n(ZX, "patternKeyCompare");
  function bGe(e, t, r) {
    if (e === "#" || e.startsWith("#/") || e.endsWith("/")) {
      let a = "is not a valid internal imports specifier name";
      throw new Yg(e, a, (0, xe().fileURLToPath)(t));
    }
    let i, s = PP(t);
    if (s.exists) {
      i = (0, xe().pathToFileURL)(s.pjsonPath);
      let a = s.imports;
      if (a)
        if (YX.call(a, e) && !e.includes("*")) {
          let o = kc(i, a[e], "", e, t, !1, !0, !1, r);
          if (o != null)
            return o;
        } else {
          let o = "", u = "", l = Object.getOwnPropertyNames(a), c = -1;
          for (; ++c < l.length; ) {
            let f = l[c], m = f.indexOf("*");
            if (m !== -1 && e.startsWith(f.slice(0, -1))) {
              let h = f.slice(m + 1);
              e.length >= f.length && e.endsWith(h) && ZX(o, f) === 1 && f.lastIndexOf("*") === m && (o = f, u = e.slice(m, e.length - h.length));
            }
          }
          if (o) {
            let f = a[o], m = kc(i, f, u, o, t, !0, !0, !1, r);
            if (m != null)
              return m;
          }
        }
    }
    throw dGe(e, i, t);
  }
  n(bGe, "packageImportsResolve");
  function DGe(e, t) {
    let r = e.indexOf("/"), i = !0, s = !1;
    e[0] === "@" && (s = !0, r === -1 || e.length === 0 ? i = !1 : r = e.indexOf("/", r + 1));
    let a = r === -1 ? e : e.slice(0, r);
    if (oGe.exec(a) !== null && (i = !1), !i)
      throw new Yg(e, "is not a valid package name", (0, xe().fileURLToPath)(t));
    let o = "." + (r === -1 ? "" : e.slice(r));
    return {
      packageName: a,
      packageSubpath: o,
      isScoped: s
    };
  }
  n(DGe, "parsePackageName");
  function QX(e, t, r) {
    if (Xg().builtinModules.includes(e))
      return new (xe()).URL("node:" + e);
    let {
      packageName: i,
      packageSubpath: s,
      isScoped: a
    } = DGe(e, t), o = PP(t);
    if (o.exists) {
      let f = (0, xe().pathToFileURL)(o.pjsonPath);
      if (o.name === i && o.exports !== void 0 && o.exports !== null)
        return $X(f, s, o, t, r);
    }
    let u = new (xe()).URL("./node_modules/" + i + "/package.json", t), l = (0, xe().fileURLToPath)(u), c;
    do {
      let f = GX(l.slice(0, -13));
      if (!f || !f.isDirectory()) {
        c = l, u = new (xe()).URL((a ? "../../../../node_modules/" : "../../../node_modules/") + i + "/package.json", u), l = (0, xe().fileURLToPath)(
        u);
        continue;
      }
      let m = KX(l, {
        base: t,
        specifier: e
      });
      return m.exports !== void 0 && m.exports !== null ? $X(u, s, m, t, r) : s === "." ? cGe(u, m, t) : new (xe()).URL(s, u);
    } while (l.length !== c.length);
    throw new FP(i, (0, xe().fileURLToPath)(t), !1);
  }
  n(QX, "packageResolve");
  function vGe(e) {
    return e[0] === "." && (e.length === 1 || e[1] === "/" || e[1] === "." && (e.length === 2 || e[2] === "/"));
  }
  n(vGe, "isRelativeSpecifier");
  function IP(e) {
    return e === "" ? !1 : e[0] === "/" ? !0 : vGe(e);
  }
  n(IP, "shouldBeTreatedAsRelativeOrAbsolutePath");
  function eY(e, t, r, i) {
    let s = t.protocol, o = s === "data:" || s === "http:" || s === "https:", u;
    if (IP(e))
      try {
        u = new (xe()).URL(e, t);
      } catch (l) {
        let c = new MX(e, t);
        throw c.cause = l, c;
      }
    else if (s === "file:" && e[0] === "#")
      u = bGe(e, t, r);
    else
      try {
        u = new (xe()).URL(e);
      } catch (l) {
        if (o && !Xg().builtinModules.includes(e)) {
          let c = new MX(e, t);
          throw c.cause = l, c;
        }
        u = QX(e, t, r);
      }
    return un()(u !== void 0, "expected to be defined"), u.protocol !== "file:" ? u : fGe(u, t, i);
  }
  n(eY, "moduleResolve");
  function xGe(e, t, r) {
    if (r) {
      let i = r.protocol;
      if (i === "http:" || i === "https:") {
        if (IP(e)) {
          let s = t?.protocol;
          if (s && s !== "https:" && s !== "http:")
            throw new CP(e, r, "remote imports cannot import from a local location.");
          return {
            url: t?.href || ""
          };
        }
        throw Xg().builtinModules.includes(e) ? new CP(e, r, "remote imports cannot import from a local location.") : new CP(e, r, "only rel\
ative and absolute specifiers are supported.");
      }
    }
  }
  n(xGe, "checkIfDisallowedImport");
  function EGe(e) {
    return !!(e && typeof e == "object" && "href" in e && typeof e.href == "string" && "protocol" in e && typeof e.protocol == "string" && e.
    href && e.protocol);
  }
  n(EGe, "isURL");
  function SGe(e) {
    if (e !== void 0 && typeof e != "string" && !EGe(e))
      throw new Rr.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], e);
  }
  n(SGe, "throwIfInvalidParentURL");
  function TGe(e, t = {}) {
    let {
      parentURL: r
    } = t;
    un()(r !== void 0, "expected `parentURL` to be defined"), SGe(r);
    let i;
    if (r)
      try {
        i = new (xe()).URL(r);
      } catch {
      }
    let s, a;
    try {
      if (s = IP(e) ? new (xe()).URL(e, i) : new (xe()).URL(e), a = s.protocol, a === "data:")
        return {
          url: s.href,
          format: null
        };
    } catch {
    }
    let o = xGe(e, s, i);
    if (o) return o;
    if (a === void 0 && s && (a = s.protocol), a === "node:")
      return {
        url: e
      };
    if (s && s.protocol === "node:") return {
      url: e
    };
    let u = rGe(t.conditions), l = eY(e, new (xe()).URL(r), u, !1);
    return {
      url: l.href,
      format: zX(l, {
        parentURL: r
      })
    };
  }
  n(TGe, "defaultResolve");
  function CGe(e, t) {
    if (!t)
      throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
    try {
      return TGe(e, {
        parentURL: t
      }).url;
    } catch (r) {
      let i = r;
      if ((i.code === "ERR_UNSUPPORTED_DIR_IMPORT" || i.code === "ERR_MODULE_NOT_FOUND") && typeof i.url == "string")
        return i.url;
      throw r;
    }
  }
  n(CGe, "resolve");
});

// ../node_modules/@babel/core/lib/config/files/plugins.js
var cY = E((no) => {
  "use strict";
  Object.defineProperty(no, "__esModule", {
    value: !0
  });
  no.loadPlugin = RGe;
  no.loadPreset = LGe;
  no.resolvePreset = no.resolvePlugin = void 0;
  function iY() {
    let e = zo();
    return iY = /* @__PURE__ */ n(function() {
      return e;
    }, "_debug"), e;
  }
  n(iY, "_debug");
  function BP() {
    let e = require("path");
    return BP = /* @__PURE__ */ n(function() {
      return e;
    }, "_path"), e;
  }
  n(BP, "_path");
  var NP = Ka(), sY = xP();
  function kP() {
    let e = require("url");
    return kP = /* @__PURE__ */ n(function() {
      return e;
    }, "_url"), e;
  }
  n(kP, "_url");
  var wGe = tY();
  require("module");
  function nY() {
    let e = require("fs");
    return nY = /* @__PURE__ */ n(function() {
      return e;
    }, "_fs"), e;
  }
  n(nY, "_fs");
  var aY = iY()("babel:config:loading:files:plugins"), AGe = /^module:/, _Ge = /^(?!@|module:|[^/]+\/|babel-plugin-)/, PGe = /^(?!@|module:|[^/]+\/|babel-preset-)/,
  FGe = /^(@babel\/)(?!plugin-|[^/]+\/)/, IGe = /^(@babel\/)(?!preset-|[^/]+\/)/, OGe = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/,
  kGe = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, BGe = /^(@(?!babel$)[^/]+)$/, NGe = no.resolvePlugin = uY.bind(null,
  "plugin"), MGe = no.resolvePreset = uY.bind(null, "preset");
  function* RGe(e, t) {
    let {
      filepath: r,
      loader: i
    } = NGe(e, t, yield* (0, NP.isAsync)()), s = yield* lY("plugin", i, r);
    return aY("Loaded plugin %o from %o.", e, t), {
      filepath: r,
      value: s
    };
  }
  n(RGe, "loadPlugin");
  function* LGe(e, t) {
    let {
      filepath: r,
      loader: i
    } = MGe(e, t, yield* (0, NP.isAsync)()), s = yield* lY("preset", i, r);
    return aY("Loaded preset %o from %o.", e, t), {
      filepath: r,
      value: s
    };
  }
  n(LGe, "loadPreset");
  function OP(e, t) {
    if (BP().isAbsolute(t)) return t;
    let r = e === "preset";
    return t.replace(r ? PGe : _Ge, `babel-${e}-`).replace(r ? IGe : FGe, `$1${e}-`).replace(r ? kGe : OGe, `$1babel-${e}-`).replace(BGe, `$\
1/babel-${e}`).replace(AGe, "");
  }
  n(OP, "standardizeName");
  function* oY(e, t) {
    let r = OP(e, t), {
      error: i,
      value: s
    } = yield r;
    if (!i) return s;
    if (i.code !== "MODULE_NOT_FOUND") throw i;
    r !== t && !(yield t).error && (i.message += `
- If you want to resolve "${t}", use "module:${t}"`), (yield OP(e, "@babel/" + t)).error || (i.message += `
- Did you mean "@babel/${t}"?`);
    let a = e === "preset" ? "plugin" : "preset";
    if ((yield OP(a, t)).error || (i.message += `
- Did you accidentally pass a ${a} as a ${e}?`), e === "plugin") {
      let o = r.replace("-proposal-", "-transform-");
      o !== r && !(yield o).error && (i.message += `
- Did you mean "${o}"?`);
    }
    throw i.message += `

Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`, i;
  }
  n(oY, "resolveAlternativesHelper");
  function jGe(e, t) {
    try {
      return t ? {
        error: null,
        value: (((r, i) => (r = r.split("."), i = i.split("."), +r[0] > +i[0] || r[0] == i[0] && +r[1] >= +i[1]))(process.versions.node, "8.\
9") ? require.resolve : (r, {
          paths: [i]
        }, s = require("module")) => {
          let a = s._findPath(r, s._nodeModulePaths(i).concat(i));
          if (a) return a;
          throw a = new Error(`Cannot resolve module '${r}'`), a.code = "MODULE_NOT_FOUND", a;
        })(e, {
          paths: [t]
        })
      } : {
        error: null,
        value: require.resolve(e)
      };
    } catch (r) {
      return {
        error: r,
        value: null
      };
    }
  }
  n(jGe, "tryRequireResolve");
  function qGe(e, t) {
    try {
      return {
        error: null,
        value: (0, wGe.resolve)(e, t)
      };
    } catch (r) {
      return {
        error: r,
        value: null
      };
    }
  }
  n(qGe, "tryImportMetaResolve");
  function rY(e, t, r) {
    let i = oY(e, t), s = i.next();
    for (; !s.done; )
      s = i.next(jGe(s.value, r));
    return {
      loader: "require",
      filepath: s.value
    };
  }
  n(rY, "resolveStandardizedNameForRequire");
  function UGe(e, t, r) {
    let i = (0, kP().pathToFileURL)(BP().join(r, "./babel-virtual-resolve-base.js")).href, s = oY(e, t), a = s.next();
    for (; !a.done; )
      a = s.next(qGe(a.value, i));
    return {
      loader: "auto",
      filepath: (0, kP().fileURLToPath)(a.value)
    };
  }
  n(UGe, "resolveStandardizedNameForImport");
  function uY(e, t, r, i) {
    if (!sY.supportsESM || !i)
      return rY(e, t, r);
    try {
      let s = UGe(e, t, r);
      if (!(0, nY().existsSync)(s.filepath))
        throw Object.assign(new Error(`Could not resolve "${t}" in file ${r}.`), {
          type: "MODULE_NOT_FOUND"
        });
      return s;
    } catch (s) {
      try {
        return rY(e, t, r);
      } catch (a) {
        throw s.type === "MODULE_NOT_FOUND" ? s : a.type === "MODULE_NOT_FOUND" ? a : s;
      }
    }
  }
  n(uY, "resolveStandardizedName");
  Zg = /* @__PURE__ */ new Set();
  var Zg;
  function* lY(e, t, r) {
    if (!(yield* (0, NP.isAsync)()) && Zg.has(r))
      throw new Error(`Reentrant ${e} detected trying to load "${r}". This module is not ignored and is trying to load itself while compilin\
g itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
    try {
      return Zg.add(r), yield* (0, sY.default)(r, t, `You appear to be using a native ECMAScript module ${e}, which is only supported when r\
unning Babel asynchronously or when using the Node.js \`--experimental-require-module\` flag.`, `You appear to be using a ${e} that contains\
 top-level await, which is only supported when running Babel asynchronously.`, !0);
    } catch (i) {
      throw i.message = `[BABEL]: ${i.message} (While processing: ${r})`, i;
    } finally {
      Zg.delete(r);
    }
  }
  n(lY, "requireModule");
});

// ../node_modules/@babel/core/lib/config/files/index.js
var kp = E((ki) => {
  "use strict";
  Object.defineProperty(ki, "__esModule", {
    value: !0
  });
  Object.defineProperty(ki, "ROOT_CONFIG_FILENAMES", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Bc.ROOT_CONFIG_FILENAMES;
    }, "get")
  });
  Object.defineProperty(ki, "findConfigUpwards", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Bc.findConfigUpwards;
    }, "get")
  });
  Object.defineProperty(ki, "findPackageData", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return $Ge.findPackageData;
    }, "get")
  });
  Object.defineProperty(ki, "findRelativeConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Bc.findRelativeConfig;
    }, "get")
  });
  Object.defineProperty(ki, "findRootConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Bc.findRootConfig;
    }, "get")
  });
  Object.defineProperty(ki, "loadConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Bc.loadConfig;
    }, "get")
  });
  Object.defineProperty(ki, "loadPlugin", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qg.loadPlugin;
    }, "get")
  });
  Object.defineProperty(ki, "loadPreset", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qg.loadPreset;
    }, "get")
  });
  Object.defineProperty(ki, "resolvePlugin", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qg.resolvePlugin;
    }, "get")
  });
  Object.defineProperty(ki, "resolvePreset", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Qg.resolvePreset;
    }, "get")
  });
  Object.defineProperty(ki, "resolveShowConfigPath", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return Bc.resolveShowConfigPath;
    }, "get")
  });
  var $Ge = tW(), Bc = FX(), Qg = cY();
});

// ../node_modules/@babel/core/lib/transform.js
var dY = E((Nc) => {
  "use strict";
  Object.defineProperty(Nc, "__esModule", {
    value: !0
  });
  Nc.transform = void 0;
  Nc.transformAsync = KGe;
  Nc.transformSync = HGe;
  function fY() {
    let e = _i();
    return fY = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n(fY, "_gensync");
  var VGe = Ec(), WGe = Eg(), eb = Kn(), tb = fY()(/* @__PURE__ */ n(function* (t, r) {
    let i = yield* (0, VGe.default)(r);
    return i === null ? null : yield* (0, WGe.run)(i, t);
  }, "transform")), aEt = Nc.transform = /* @__PURE__ */ n(function(t, r, i) {
    let s, a;
    if (typeof r == "function" ? (a = r, s = void 0) : (s = r, a = i), a === void 0)
      return (0, eb.beginHiddenCallStack)(tb.sync)(t, s);
    (0, eb.beginHiddenCallStack)(tb.errback)(t, s, a);
  }, "transform");
  function HGe(...e) {
    return (0, eb.beginHiddenCallStack)(tb.sync)(...e);
  }
  n(HGe, "transformSync");
  function KGe(...e) {
    return (0, eb.beginHiddenCallStack)(tb.async)(...e);
  }
  n(KGe, "transformAsync");
});

// ../node_modules/@babel/core/lib/transform-ast.js
var hY = E((Mc) => {
  "use strict";
  Object.defineProperty(Mc, "__esModule", {
    value: !0
  });
  Mc.transformFromAst = void 0;
  Mc.transformFromAstAsync = YGe;
  Mc.transformFromAstSync = XGe;
  function pY() {
    let e = _i();
    return pY = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n(pY, "_gensync");
  var zGe = Ec(), JGe = Eg(), rb = Kn(), ib = pY()(function* (e, t, r) {
    let i = yield* (0, zGe.default)(r);
    if (i === null) return null;
    if (!e) throw new Error("No AST given");
    return yield* (0, JGe.run)(i, t, e);
  }), lEt = Mc.transformFromAst = /* @__PURE__ */ n(function(t, r, i, s) {
    let a, o;
    if (typeof i == "function" ? (o = i, a = void 0) : (a = i, o = s), o === void 0)
      return (0, rb.beginHiddenCallStack)(ib.sync)(t, r, a);
    (0, rb.beginHiddenCallStack)(ib.errback)(t, r, a, o);
  }, "transformFromAst");
  function XGe(...e) {
    return (0, rb.beginHiddenCallStack)(ib.sync)(...e);
  }
  n(XGe, "transformFromAstSync");
  function YGe(...e) {
    return (0, rb.beginHiddenCallStack)(ib.async)(...e);
  }
  n(YGe, "transformFromAstAsync");
});

// ../node_modules/@babel/core/lib/parse.js
var yY = E((Rc) => {
  "use strict";
  Object.defineProperty(Rc, "__esModule", {
    value: !0
  });
  Rc.parse = void 0;
  Rc.parseAsync = tZe;
  Rc.parseSync = eZe;
  function mY() {
    let e = _i();
    return mY = /* @__PURE__ */ n(function() {
      return e;
    }, "_gensync"), e;
  }
  n(mY, "_gensync");
  var GGe = Ec(), ZGe = s3(), QGe = Q_(), sb = Kn(), nb = mY()(/* @__PURE__ */ n(function* (t, r) {
    let i = yield* (0, GGe.default)(r);
    return i === null ? null : yield* (0, ZGe.default)(i.passes, (0, QGe.default)(i), t);
  }, "parse")), dEt = Rc.parse = /* @__PURE__ */ n(function(t, r, i) {
    if (typeof r == "function" && (i = r, r = void 0), i === void 0)
      return (0, sb.beginHiddenCallStack)(nb.sync)(t, r);
    (0, sb.beginHiddenCallStack)(nb.errback)(t, r, i);
  }, "parse");
  function eZe(...e) {
    return (0, sb.beginHiddenCallStack)(nb.sync)(...e);
  }
  n(eZe, "parseSync");
  function tZe(...e) {
    return (0, sb.beginHiddenCallStack)(nb.async)(...e);
  }
  n(tZe, "parseAsync");
});

// ../node_modules/@babel/core/lib/index.js
var Gt = E((Ve) => {
  "use strict";
  Object.defineProperty(Ve, "__esModule", {
    value: !0
  });
  Ve.DEFAULT_EXTENSIONS = void 0;
  Object.defineProperty(Ve, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return rZe.default;
    }, "get")
  });
  Object.defineProperty(Ve, "buildExternalHelpers", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return iZe.default;
    }, "get")
  });
  Object.defineProperty(Ve, "createConfigItem", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ln.createConfigItem;
    }, "get")
  });
  Object.defineProperty(Ve, "createConfigItemAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ln.createConfigItemAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "createConfigItemSync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ln.createConfigItemSync;
    }, "get")
  });
  Object.defineProperty(Ve, "getEnv", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return sZe.getEnv;
    }, "get")
  });
  Object.defineProperty(Ve, "loadOptions", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ln.loadOptions;
    }, "get")
  });
  Object.defineProperty(Ve, "loadOptionsAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ln.loadOptionsAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "loadOptionsSync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ln.loadOptionsSync;
    }, "get")
  });
  Object.defineProperty(Ve, "loadPartialConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ln.loadPartialConfig;
    }, "get")
  });
  Object.defineProperty(Ve, "loadPartialConfigAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ln.loadPartialConfigAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "loadPartialConfigSync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return ln.loadPartialConfigSync;
    }, "get")
  });
  Object.defineProperty(Ve, "parse", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jP.parse;
    }, "get")
  });
  Object.defineProperty(Ve, "parseAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jP.parseAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "parseSync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return jP.parseSync;
    }, "get")
  });
  Ve.resolvePreset = Ve.resolvePlugin = void 0;
  Object.defineProperty(Ve, "template", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return xY().default;
    }, "get")
  });
  Object.defineProperty(Ve, "tokTypes", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return DY().tokTypes;
    }, "get")
  });
  Object.defineProperty(Ve, "transform", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return MP.transform;
    }, "get")
  });
  Object.defineProperty(Ve, "transformAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return MP.transformAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFile", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return RP.transformFile;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFileAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return RP.transformFileAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFileSync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return RP.transformFileSync;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFromAst", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return LP.transformFromAst;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFromAstAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return LP.transformFromAstAsync;
    }, "get")
  });
  Object.defineProperty(Ve, "transformFromAstSync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return LP.transformFromAstSync;
    }, "get")
  });
  Object.defineProperty(Ve, "transformSync", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return MP.transformSync;
    }, "get")
  });
  Object.defineProperty(Ve, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return vY().default;
    }, "get")
  });
  Ve.version = Ve.types = void 0;
  var rZe = aA(), iZe = _V(), gY = kp(), sZe = U_();
  function bY() {
    let e = Pe();
    return bY = /* @__PURE__ */ n(function() {
      return e;
    }, "_types"), e;
  }
  n(bY, "_types");
  Object.defineProperty(Ve, "types", {
    enumerable: !0,
    get: /* @__PURE__ */ n(function() {
      return bY();
    }, "get")
  });
  function DY() {
    let e = Ho();
    return DY = /* @__PURE__ */ n(function() {
      return e;
    }, "_parser"), e;
  }
  n(DY, "_parser");
  function vY() {
    let e = ir();
    return vY = /* @__PURE__ */ n(function() {
      return e;
    }, "_traverse"), e;
  }
  n(vY, "_traverse");
  function xY() {
    let e = zd();
    return xY = /* @__PURE__ */ n(function() {
      return e;
    }, "_template"), e;
  }
  n(xY, "_template");
  var ln = Ec(), MP = dY(), RP = D3(), LP = hY(), jP = yY(), mEt = Ve.version = "7.28.4", nZe = /* @__PURE__ */ n((e, t) => gY.resolvePlugin(
  e, t, !1).filepath, "resolvePlugin");
  Ve.resolvePlugin = nZe;
  var aZe = /* @__PURE__ */ n((e, t) => gY.resolvePreset(e, t, !1).filepath, "resolvePreset");
  Ve.resolvePreset = aZe;
  var yEt = Ve.DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
  Ve.OptionManager = class {
    static {
      n(this, "OptionManager");
    }
    init(t) {
      return (0, ln.loadOptionsSync)(t);
    }
  }, Ve.Plugin = /* @__PURE__ */ n(function(t) {
    throw new Error(`The (${t}) Babel 5 plugin is being run with an unsupported Babel version.`);
  }, "Plugin");
});

// ../node_modules/zod/lib/helpers/util.js
var ih = E((_t) => {
  "use strict";
  Object.defineProperty(_t, "__esModule", { value: !0 });
  _t.getParsedType = _t.ZodParsedType = _t.objectUtil = _t.util = void 0;
  var zP;
  (function(e) {
    e.assertEqual = (s) => s;
    function t(s) {
    }
    n(t, "assertIs"), e.assertIs = t;
    function r(s) {
      throw new Error();
    }
    n(r, "assertNever"), e.assertNever = r, e.arrayToEnum = (s) => {
      let a = {};
      for (let o of s)
        a[o] = o;
      return a;
    }, e.getValidEnumValues = (s) => {
      let a = e.objectKeys(s).filter((u) => typeof s[s[u]] != "number"), o = {};
      for (let u of a)
        o[u] = s[u];
      return e.objectValues(o);
    }, e.objectValues = (s) => e.objectKeys(s).map(function(a) {
      return s[a];
    }), e.objectKeys = typeof Object.keys == "function" ? (s) => Object.keys(s) : (s) => {
      let a = [];
      for (let o in s)
        Object.prototype.hasOwnProperty.call(s, o) && a.push(o);
      return a;
    }, e.find = (s, a) => {
      for (let o of s)
        if (a(o))
          return o;
    }, e.isInteger = typeof Number.isInteger == "function" ? (s) => Number.isInteger(s) : (s) => typeof s == "number" && isFinite(s) && Math.
    floor(s) === s;
    function i(s, a = " | ") {
      return s.map((o) => typeof o == "string" ? `'${o}'` : o).join(a);
    }
    n(i, "joinValues"), e.joinValues = i, e.jsonStringifyReplacer = (s, a) => typeof a == "bigint" ? a.toString() : a;
  })(zP || (_t.util = zP = {}));
  var FY;
  (function(e) {
    e.mergeShapes = (t, r) => ({
      ...t,
      ...r
      // second overwrites first
    });
  })(FY || (_t.objectUtil = FY = {}));
  _t.ZodParsedType = zP.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var mZe = /* @__PURE__ */ n((e) => {
    switch (typeof e) {
      case "undefined":
        return _t.ZodParsedType.undefined;
      case "string":
        return _t.ZodParsedType.string;
      case "number":
        return isNaN(e) ? _t.ZodParsedType.nan : _t.ZodParsedType.number;
      case "boolean":
        return _t.ZodParsedType.boolean;
      case "function":
        return _t.ZodParsedType.function;
      case "bigint":
        return _t.ZodParsedType.bigint;
      case "symbol":
        return _t.ZodParsedType.symbol;
      case "object":
        return Array.isArray(e) ? _t.ZodParsedType.array : e === null ? _t.ZodParsedType.null : e.then && typeof e.then == "function" && e.catch &&
        typeof e.catch == "function" ? _t.ZodParsedType.promise : typeof Map < "u" && e instanceof Map ? _t.ZodParsedType.map : typeof Set <
        "u" && e instanceof Set ? _t.ZodParsedType.set : typeof Date < "u" && e instanceof Date ? _t.ZodParsedType.date : _t.ZodParsedType.object;
      default:
        return _t.ZodParsedType.unknown;
    }
  }, "getParsedType");
  _t.getParsedType = mZe;
});

// ../node_modules/zod/lib/ZodError.js
var ub = E((ao) => {
  "use strict";
  Object.defineProperty(ao, "__esModule", { value: !0 });
  ao.ZodError = ao.quotelessJson = ao.ZodIssueCode = void 0;
  var IY = ih();
  ao.ZodIssueCode = IY.util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var yZe = /* @__PURE__ */ n((e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"), "quotelessJson");
  ao.quotelessJson = yZe;
  var sh = class e extends Error {
    static {
      n(this, "ZodError");
    }
    get errors() {
      return this.issues;
    }
    constructor(t) {
      super(), this.issues = [], this.addIssue = (i) => {
        this.issues = [...this.issues, i];
      }, this.addIssues = (i = []) => {
        this.issues = [...this.issues, ...i];
      };
      let r = new.target.prototype;
      Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodError", this.issues = t;
    }
    format(t) {
      let r = t || function(a) {
        return a.message;
      }, i = { _errors: [] }, s = /* @__PURE__ */ n((a) => {
        for (let o of a.issues)
          if (o.code === "invalid_union")
            o.unionErrors.map(s);
          else if (o.code === "invalid_return_type")
            s(o.returnTypeError);
          else if (o.code === "invalid_arguments")
            s(o.argumentsError);
          else if (o.path.length === 0)
            i._errors.push(r(o));
          else {
            let u = i, l = 0;
            for (; l < o.path.length; ) {
              let c = o.path[l];
              l === o.path.length - 1 ? (u[c] = u[c] || { _errors: [] }, u[c]._errors.push(r(o))) : u[c] = u[c] || { _errors: [] }, u = u[c],
              l++;
            }
          }
      }, "processError");
      return s(this), i;
    }
    static assert(t) {
      if (!(t instanceof e))
        throw new Error(`Not a ZodError: ${t}`);
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, IY.util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(t = (r) => r.message) {
      let r = {}, i = [];
      for (let s of this.issues)
        s.path.length > 0 ? (r[s.path[0]] = r[s.path[0]] || [], r[s.path[0]].push(t(s))) : i.push(t(s));
      return { formErrors: i, fieldErrors: r };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ao.ZodError = sh;
  sh.create = (e) => new sh(e);
});

// ../node_modules/zod/lib/locales/en.js
var XP = E((JP) => {
  "use strict";
  Object.defineProperty(JP, "__esModule", { value: !0 });
  var wu = ih(), Xr = ub(), gZe = /* @__PURE__ */ n((e, t) => {
    let r;
    switch (e.code) {
      case Xr.ZodIssueCode.invalid_type:
        e.received === wu.ZodParsedType.undefined ? r = "Required" : r = `Expected ${e.expected}, received ${e.received}`;
        break;
      case Xr.ZodIssueCode.invalid_literal:
        r = `Invalid literal value, expected ${JSON.stringify(e.expected, wu.util.jsonStringifyReplacer)}`;
        break;
      case Xr.ZodIssueCode.unrecognized_keys:
        r = `Unrecognized key(s) in object: ${wu.util.joinValues(e.keys, ", ")}`;
        break;
      case Xr.ZodIssueCode.invalid_union:
        r = "Invalid input";
        break;
      case Xr.ZodIssueCode.invalid_union_discriminator:
        r = `Invalid discriminator value. Expected ${wu.util.joinValues(e.options)}`;
        break;
      case Xr.ZodIssueCode.invalid_enum_value:
        r = `Invalid enum value. Expected ${wu.util.joinValues(e.options)}, received '${e.received}'`;
        break;
      case Xr.ZodIssueCode.invalid_arguments:
        r = "Invalid function arguments";
        break;
      case Xr.ZodIssueCode.invalid_return_type:
        r = "Invalid function return type";
        break;
      case Xr.ZodIssueCode.invalid_date:
        r = "Invalid date";
        break;
      case Xr.ZodIssueCode.invalid_string:
        typeof e.validation == "object" ? "includes" in e.validation ? (r = `Invalid input: must include "${e.validation.includes}"`, typeof e.
        validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${e.validation.position}`)) : "start\
sWith" in e.validation ? r = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? r = `Invalid input\
: must end with "${e.validation.endsWith}"` : wu.util.assertNever(e.validation) : e.validation !== "regex" ? r = `Invalid ${e.validation}` :
        r = "Invalid";
        break;
      case Xr.ZodIssueCode.too_small:
        e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` :
        e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` :
        e.type === "number" ? r = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater tha\
n "}${e.minimum}` : e.type === "date" ? r = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "gre\
ater than "}${new Date(Number(e.minimum))}` : r = "Invalid input";
        break;
      case Xr.ZodIssueCode.too_big:
        e.type === "array" ? r = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` :
        e.type === "string" ? r = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` :
        e.type === "number" ? r = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` :
        e.type === "bigint" ? r = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` :
        e.type === "date" ? r = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(
        Number(e.maximum))}` : r = "Invalid input";
        break;
      case Xr.ZodIssueCode.custom:
        r = "Invalid input";
        break;
      case Xr.ZodIssueCode.invalid_intersection_types:
        r = "Intersection results could not be merged";
        break;
      case Xr.ZodIssueCode.not_multiple_of:
        r = `Number must be a multiple of ${e.multipleOf}`;
        break;
      case Xr.ZodIssueCode.not_finite:
        r = "Number must be finite";
        break;
      default:
        r = t.defaultError, wu.util.assertNever(e);
    }
    return { message: r };
  }, "errorMap");
  JP.default = gZe;
});

// ../node_modules/zod/lib/errors.js
var lb = E((cn) => {
  "use strict";
  var bZe = cn && cn.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(cn, "__esModule", { value: !0 });
  cn.getErrorMap = cn.setErrorMap = cn.defaultErrorMap = void 0;
  var OY = bZe(XP());
  cn.defaultErrorMap = OY.default;
  var kY = OY.default;
  function DZe(e) {
    kY = e;
  }
  n(DZe, "setErrorMap");
  cn.setErrorMap = DZe;
  function vZe() {
    return kY;
  }
  n(vZe, "getErrorMap");
  cn.getErrorMap = vZe;
});

// ../node_modules/zod/lib/helpers/parseUtil.js
var GP = E((mt) => {
  "use strict";
  var xZe = mt && mt.__importDefault || function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  Object.defineProperty(mt, "__esModule", { value: !0 });
  mt.isAsync = mt.isValid = mt.isDirty = mt.isAborted = mt.OK = mt.DIRTY = mt.INVALID = mt.ParseStatus = mt.addIssueToContext = mt.EMPTY_PATH =
  mt.makeIssue = void 0;
  var EZe = lb(), BY = xZe(XP()), SZe = /* @__PURE__ */ n((e) => {
    let { data: t, path: r, errorMaps: i, issueData: s } = e, a = [...r, ...s.path || []], o = {
      ...s,
      path: a
    };
    if (s.message !== void 0)
      return {
        ...s,
        path: a,
        message: s.message
      };
    let u = "", l = i.filter((c) => !!c).slice().reverse();
    for (let c of l)
      u = c(o, { data: t, defaultError: u }).message;
    return {
      ...s,
      path: a,
      message: u
    };
  }, "makeIssue");
  mt.makeIssue = SZe;
  mt.EMPTY_PATH = [];
  function TZe(e, t) {
    let r = (0, EZe.getErrorMap)(), i = (0, mt.makeIssue)({
      issueData: t,
      data: e.data,
      path: e.path,
      errorMaps: [
        e.common.contextualErrorMap,
        // contextual error map is first priority
        e.schemaErrorMap,
        // then schema-bound map if available
        r,
        // then global override map
        r === BY.default ? void 0 : BY.default
        // then global default map
      ].filter((s) => !!s)
    });
    e.common.issues.push(i);
  }
  n(TZe, "addIssueToContext");
  mt.addIssueToContext = TZe;
  var YP = class e {
    static {
      n(this, "ParseStatus");
    }
    constructor() {
      this.value = "valid";
    }
    dirty() {
      this.value === "valid" && (this.value = "dirty");
    }
    abort() {
      this.value !== "aborted" && (this.value = "aborted");
    }
    static mergeArray(t, r) {
      let i = [];
      for (let s of r) {
        if (s.status === "aborted")
          return mt.INVALID;
        s.status === "dirty" && t.dirty(), i.push(s.value);
      }
      return { status: t.value, value: i };
    }
    static async mergeObjectAsync(t, r) {
      let i = [];
      for (let s of r) {
        let a = await s.key, o = await s.value;
        i.push({
          key: a,
          value: o
        });
      }
      return e.mergeObjectSync(t, i);
    }
    static mergeObjectSync(t, r) {
      let i = {};
      for (let s of r) {
        let { key: a, value: o } = s;
        if (a.status === "aborted" || o.status === "aborted")
          return mt.INVALID;
        a.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || s.alwaysSet) &&
        (i[a.value] = o.value);
      }
      return { status: t.value, value: i };
    }
  };
  mt.ParseStatus = YP;
  mt.INVALID = Object.freeze({
    status: "aborted"
  });
  var CZe = /* @__PURE__ */ n((e) => ({ status: "dirty", value: e }), "DIRTY");
  mt.DIRTY = CZe;
  var wZe = /* @__PURE__ */ n((e) => ({ status: "valid", value: e }), "OK");
  mt.OK = wZe;
  var AZe = /* @__PURE__ */ n((e) => e.status === "aborted", "isAborted");
  mt.isAborted = AZe;
  var _Ze = /* @__PURE__ */ n((e) => e.status === "dirty", "isDirty");
  mt.isDirty = _Ze;
  var PZe = /* @__PURE__ */ n((e) => e.status === "valid", "isValid");
  mt.isValid = PZe;
  var FZe = /* @__PURE__ */ n((e) => typeof Promise < "u" && e instanceof Promise, "isAsync");
  mt.isAsync = FZe;
});

// ../node_modules/zod/lib/helpers/typeAliases.js
var MY = E((NY) => {
  "use strict";
  Object.defineProperty(NY, "__esModule", { value: !0 });
});

// ../node_modules/zod/lib/helpers/errorUtil.js
var LY = E((cb) => {
  "use strict";
  Object.defineProperty(cb, "__esModule", { value: !0 });
  cb.errorUtil = void 0;
  var RY;
  (function(e) {
    e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t?.message;
  })(RY || (cb.errorUtil = RY = {}));
});

// ../node_modules/zod/lib/types.js
var GY = E(($) => {
  "use strict";
  var db = $ && $.__classPrivateFieldGet || function(e, t, r, i) {
    if (r === "a" && !i) throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did n\
ot declare it");
    return r === "m" ? i : r === "a" ? i.call(e) : i ? i.value : t.get(e);
  }, UY = $ && $.__classPrivateFieldSet || function(e, t, r, i, s) {
    if (i === "m") throw new TypeError("Private method is not writable");
    if (i === "a" && !s) throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !s : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did no\
t declare it");
    return i === "a" ? s.call(e, r) : s ? s.value = r : t.set(e, r), r;
  }, nh, ah;
  Object.defineProperty($, "__esModule", { value: !0 });
  $.boolean = $.bigint = $.array = $.any = $.coerce = $.ZodFirstPartyTypeKind = $.late = $.ZodSchema = $.Schema = $.custom = $.ZodReadonly =
  $.ZodPipeline = $.ZodBranded = $.BRAND = $.ZodNaN = $.ZodCatch = $.ZodDefault = $.ZodNullable = $.ZodOptional = $.ZodTransformer = $.ZodEffects =
  $.ZodPromise = $.ZodNativeEnum = $.ZodEnum = $.ZodLiteral = $.ZodLazy = $.ZodFunction = $.ZodSet = $.ZodMap = $.ZodRecord = $.ZodTuple = $.
  ZodIntersection = $.ZodDiscriminatedUnion = $.ZodUnion = $.ZodObject = $.ZodArray = $.ZodVoid = $.ZodNever = $.ZodUnknown = $.ZodAny = $.ZodNull =
  $.ZodUndefined = $.ZodSymbol = $.ZodDate = $.ZodBoolean = $.ZodBigInt = $.ZodNumber = $.ZodString = $.datetimeRegex = $.ZodType = void 0;
  $.NEVER = $.void = $.unknown = $.union = $.undefined = $.tuple = $.transformer = $.symbol = $.string = $.strictObject = $.set = $.record =
  $.promise = $.preprocess = $.pipeline = $.ostring = $.optional = $.onumber = $.oboolean = $.object = $.number = $.nullable = $.null = $.never =
  $.nativeEnum = $.nan = $.map = $.literal = $.lazy = $.intersection = $.instanceof = $.function = $.enum = $.effect = $.discriminatedUnion =
  $.date = void 0;
  var fb = lb(), Se = LY(), W = GP(), ce = ih(), ue = ub(), ns = class {
    static {
      n(this, "ParseInputLazyPath");
    }
    constructor(t, r, i, s) {
      this._cachedPath = [], this.parent = t, this.data = r, this._path = i, this._key = s;
    }
    get path() {
      return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.
      push(...this._path, this._key)), this._cachedPath;
    }
  }, jY = /* @__PURE__ */ n((e, t) => {
    if ((0, W.isValid)(t))
      return { success: !0, data: t.value };
    if (!e.common.issues.length)
      throw new Error("Validation failed but no issues detected.");
    return {
      success: !1,
      get error() {
        if (this._error)
          return this._error;
        let r = new ue.ZodError(e.common.issues);
        return this._error = r, this._error;
      }
    };
  }, "handleResult");
  function qe(e) {
    if (!e)
      return {};
    let { errorMap: t, invalid_type_error: r, required_error: i, description: s } = e;
    if (t && (r || i))
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return t ? { errorMap: t, description: s } : { errorMap: /* @__PURE__ */ n((o, u) => {
      var l, c;
      let { message: f } = e;
      return o.code === "invalid_enum_value" ? { message: f ?? u.defaultError } : typeof u.data > "u" ? { message: (l = f ?? i) !== null && l !==
      void 0 ? l : u.defaultError } : o.code !== "invalid_type" ? { message: u.defaultError } : { message: (c = f ?? r) !== null && c !== void 0 ?
      c : u.defaultError };
    }, "customMap"), description: s };
  }
  n(qe, "processCreateParams");
  var Ue = class {
    static {
      n(this, "ZodType");
    }
    get description() {
      return this._def.description;
    }
    _getType(t) {
      return (0, ce.getParsedType)(t.data);
    }
    _getOrReturnCtx(t, r) {
      return r || {
        common: t.parent.common,
        data: t.data,
        parsedType: (0, ce.getParsedType)(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      };
    }
    _processInputParams(t) {
      return {
        status: new W.ParseStatus(),
        ctx: {
          common: t.parent.common,
          data: t.data,
          parsedType: (0, ce.getParsedType)(t.data),
          schemaErrorMap: this._def.errorMap,
          path: t.path,
          parent: t.parent
        }
      };
    }
    _parseSync(t) {
      let r = this._parse(t);
      if ((0, W.isAsync)(r))
        throw new Error("Synchronous parse encountered promise.");
      return r;
    }
    _parseAsync(t) {
      let r = this._parse(t);
      return Promise.resolve(r);
    }
    parse(t, r) {
      let i = this.safeParse(t, r);
      if (i.success)
        return i.data;
      throw i.error;
    }
    safeParse(t, r) {
      var i;
      let s = {
        common: {
          issues: [],
          async: (i = r?.async) !== null && i !== void 0 ? i : !1,
          contextualErrorMap: r?.errorMap
        },
        path: r?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: (0, ce.getParsedType)(t)
      }, a = this._parseSync({ data: t, path: s.path, parent: s });
      return jY(s, a);
    }
    "~validate"(t) {
      var r, i;
      let s = {
        common: {
          issues: [],
          async: !!this["~standard"].async
        },
        path: [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: (0, ce.getParsedType)(t)
      };
      if (!this["~standard"].async)
        try {
          let a = this._parseSync({ data: t, path: [], parent: s });
          return (0, W.isValid)(a) ? {
            value: a.value
          } : {
            issues: s.common.issues
          };
        } catch (a) {
          !((i = (r = a?.message) === null || r === void 0 ? void 0 : r.toLowerCase()) === null || i === void 0) && i.includes("encountered") &&
          (this["~standard"].async = !0), s.common = {
            issues: [],
            async: !0
          };
        }
      return this._parseAsync({ data: t, path: [], parent: s }).then((a) => (0, W.isValid)(a) ? {
        value: a.value
      } : {
        issues: s.common.issues
      });
    }
    async parseAsync(t, r) {
      let i = await this.safeParseAsync(t, r);
      if (i.success)
        return i.data;
      throw i.error;
    }
    async safeParseAsync(t, r) {
      let i = {
        common: {
          issues: [],
          contextualErrorMap: r?.errorMap,
          async: !0
        },
        path: r?.path || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: (0, ce.getParsedType)(t)
      }, s = this._parse({ data: t, path: i.path, parent: i }), a = await ((0, W.isAsync)(s) ? s : Promise.resolve(s));
      return jY(i, a);
    }
    refine(t, r) {
      let i = /* @__PURE__ */ n((s) => typeof r == "string" || typeof r > "u" ? { message: r } : typeof r == "function" ? r(s) : r, "getIssu\
eProperties");
      return this._refinement((s, a) => {
        let o = t(s), u = /* @__PURE__ */ n(() => a.addIssue({
          code: ue.ZodIssueCode.custom,
          ...i(s)
        }), "setError");
        return typeof Promise < "u" && o instanceof Promise ? o.then((l) => l ? !0 : (u(), !1)) : o ? !0 : (u(), !1);
      });
    }
    refinement(t, r) {
      return this._refinement((i, s) => t(i) ? !0 : (s.addIssue(typeof r == "function" ? r(i, s) : r), !1));
    }
    _refinement(t) {
      return new Bi({
        schema: this,
        typeName: Oe.ZodEffects,
        effect: { type: "refinement", refinement: t }
      });
    }
    superRefine(t) {
      return this._refinement(t);
    }
    constructor(t) {
      this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync =
      this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.
      bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.
      bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.
      promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(
      this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe =
      this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.
      bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: /* @__PURE__ */ n((r) => this["~validate"](r), "validate")
      };
    }
    optional() {
      return ss.create(this, this._def);
    }
    nullable() {
      return dn.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return la.create(this);
    }
    promise() {
      return lo.create(this, this._def);
    }
    or(t) {
      return ku.create([this, t], this._def);
    }
    and(t) {
      return Bu.create(this, t, this._def);
    }
    transform(t) {
      return new Bi({
        ...qe(this._def),
        schema: this,
        typeName: Oe.ZodEffects,
        effect: { type: "transform", transform: t }
      });
    }
    default(t) {
      let r = typeof t == "function" ? t : () => t;
      return new ju({
        ...qe(this._def),
        innerType: this,
        defaultValue: r,
        typeName: Oe.ZodDefault
      });
    }
    brand() {
      return new oh({
        typeName: Oe.ZodBranded,
        type: this,
        ...qe(this._def)
      });
    }
    catch(t) {
      let r = typeof t == "function" ? t : () => t;
      return new qu({
        ...qe(this._def),
        innerType: this,
        catchValue: r,
        typeName: Oe.ZodCatch
      });
    }
    describe(t) {
      let r = this.constructor;
      return new r({
        ...this._def,
        description: t
      });
    }
    pipe(t) {
      return uh.create(this, t);
    }
    readonly() {
      return Uu.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  $.ZodType = Ue;
  $.Schema = Ue;
  $.ZodSchema = Ue;
  var IZe = /^c[^\s-]{8,}$/i, OZe = /^[0-9a-z]+$/, kZe = /^[0-9A-HJKMNP-TV-Z]{26}$/i, BZe = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  NZe = /^[a-z0-9_-]{21}$/i, MZe = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, RZe = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  LZe = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, jZe = "^(\\p{Extended_Pictographic}|\\p{Emoji_Co\
mponent})+$", ZP, qZe = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  UZe = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  $Ze = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
  VZe = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  WZe = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, HZe = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  $Y = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469\
]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", KZe = new RegExp(`^${$Y}$`);
  function VY(e) {
    let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
  }
  n(VY, "timeRegexSource");
  function zZe(e) {
    return new RegExp(`^${VY(e)}$`);
  }
  n(zZe, "timeRegex");
  function WY(e) {
    let t = `${$Y}T${VY(e)}`, r = [];
    return r.push(e.local ? "Z?" : "Z"), e.offset && r.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${r.join("|")})`, new RegExp(`^${t}$`);
  }
  n(WY, "datetimeRegex");
  $.datetimeRegex = WY;
  function JZe(e, t) {
    return !!((t === "v4" || !t) && qZe.test(e) || (t === "v6" || !t) && $Ze.test(e));
  }
  n(JZe, "isValidIP");
  function XZe(e, t) {
    if (!MZe.test(e))
      return !1;
    try {
      let [r] = e.split("."), i = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="), s = JSON.parse(atob(
      i));
      return !(typeof s != "object" || s === null || !s.typ || !s.alg || t && s.alg !== t);
    } catch {
      return !1;
    }
  }
  n(XZe, "isValidJWT");
  function YZe(e, t) {
    return !!((t === "v4" || !t) && UZe.test(e) || (t === "v6" || !t) && VZe.test(e));
  }
  n(YZe, "isValidCidr");
  var oo = class e extends Ue {
    static {
      n(this, "ZodString");
    }
    _parse(t) {
      if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== ce.ZodParsedType.string) {
        let a = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(a, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.string,
          received: a.parsedType
        }), W.INVALID;
      }
      let i = new W.ParseStatus(), s;
      for (let a of this._def.checks)
        if (a.kind === "min")
          t.data.length < a.value && (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
            code: ue.ZodIssueCode.too_small,
            minimum: a.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: a.message
          }), i.dirty());
        else if (a.kind === "max")
          t.data.length > a.value && (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
            code: ue.ZodIssueCode.too_big,
            maximum: a.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: a.message
          }), i.dirty());
        else if (a.kind === "length") {
          let o = t.data.length > a.value, u = t.data.length < a.value;
          (o || u) && (s = this._getOrReturnCtx(t, s), o ? (0, W.addIssueToContext)(s, {
            code: ue.ZodIssueCode.too_big,
            maximum: a.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: a.message
          }) : u && (0, W.addIssueToContext)(s, {
            code: ue.ZodIssueCode.too_small,
            minimum: a.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: a.message
          }), i.dirty());
        } else if (a.kind === "email")
          LZe.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
            validation: "email",
            code: ue.ZodIssueCode.invalid_string,
            message: a.message
          }), i.dirty());
        else if (a.kind === "emoji")
          ZP || (ZP = new RegExp(jZe, "u")), ZP.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
            validation: "emoji",
            code: ue.ZodIssueCode.invalid_string,
            message: a.message
          }), i.dirty());
        else if (a.kind === "uuid")
          BZe.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
            validation: "uuid",
            code: ue.ZodIssueCode.invalid_string,
            message: a.message
          }), i.dirty());
        else if (a.kind === "nanoid")
          NZe.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
            validation: "nanoid",
            code: ue.ZodIssueCode.invalid_string,
            message: a.message
          }), i.dirty());
        else if (a.kind === "cuid")
          IZe.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
            validation: "cuid",
            code: ue.ZodIssueCode.invalid_string,
            message: a.message
          }), i.dirty());
        else if (a.kind === "cuid2")
          OZe.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
            validation: "cuid2",
            code: ue.ZodIssueCode.invalid_string,
            message: a.message
          }), i.dirty());
        else if (a.kind === "ulid")
          kZe.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
            validation: "ulid",
            code: ue.ZodIssueCode.invalid_string,
            message: a.message
          }), i.dirty());
        else if (a.kind === "url")
          try {
            new URL(t.data);
          } catch {
            s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
              validation: "url",
              code: ue.ZodIssueCode.invalid_string,
              message: a.message
            }), i.dirty();
          }
        else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(
        s, {
          validation: "regex",
          code: ue.ZodIssueCode.invalid_string,
          message: a.message
        }), i.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (s = this.
        _getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          code: ue.ZodIssueCode.invalid_string,
          validation: { includes: a.value, position: a.position },
          message: a.message
        }), i.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() :
        a.kind === "startsWith" ? t.data.startsWith(a.value) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          code: ue.ZodIssueCode.invalid_string,
          validation: { startsWith: a.value },
          message: a.message
        }), i.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          code: ue.ZodIssueCode.invalid_string,
          validation: { endsWith: a.value },
          message: a.message
        }), i.dirty()) : a.kind === "datetime" ? WY(a).test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          code: ue.ZodIssueCode.invalid_string,
          validation: "datetime",
          message: a.message
        }), i.dirty()) : a.kind === "date" ? KZe.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          code: ue.ZodIssueCode.invalid_string,
          validation: "date",
          message: a.message
        }), i.dirty()) : a.kind === "time" ? zZe(a).test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          code: ue.ZodIssueCode.invalid_string,
          validation: "time",
          message: a.message
        }), i.dirty()) : a.kind === "duration" ? RZe.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          validation: "duration",
          code: ue.ZodIssueCode.invalid_string,
          message: a.message
        }), i.dirty()) : a.kind === "ip" ? JZe(t.data, a.version) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          validation: "ip",
          code: ue.ZodIssueCode.invalid_string,
          message: a.message
        }), i.dirty()) : a.kind === "jwt" ? XZe(t.data, a.alg) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          validation: "jwt",
          code: ue.ZodIssueCode.invalid_string,
          message: a.message
        }), i.dirty()) : a.kind === "cidr" ? YZe(t.data, a.version) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          validation: "cidr",
          code: ue.ZodIssueCode.invalid_string,
          message: a.message
        }), i.dirty()) : a.kind === "base64" ? WZe.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          validation: "base64",
          code: ue.ZodIssueCode.invalid_string,
          message: a.message
        }), i.dirty()) : a.kind === "base64url" ? HZe.test(t.data) || (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          validation: "base64url",
          code: ue.ZodIssueCode.invalid_string,
          message: a.message
        }), i.dirty()) : ce.util.assertNever(a);
      return { status: i.value, value: t.data };
    }
    _regex(t, r, i) {
      return this.refinement((s) => t.test(s), {
        validation: r,
        code: ue.ZodIssueCode.invalid_string,
        ...Se.errorUtil.errToObj(i)
      });
    }
    _addCheck(t) {
      return new e({
        ...this._def,
        checks: [...this._def.checks, t]
      });
    }
    email(t) {
      return this._addCheck({ kind: "email", ...Se.errorUtil.errToObj(t) });
    }
    url(t) {
      return this._addCheck({ kind: "url", ...Se.errorUtil.errToObj(t) });
    }
    emoji(t) {
      return this._addCheck({ kind: "emoji", ...Se.errorUtil.errToObj(t) });
    }
    uuid(t) {
      return this._addCheck({ kind: "uuid", ...Se.errorUtil.errToObj(t) });
    }
    nanoid(t) {
      return this._addCheck({ kind: "nanoid", ...Se.errorUtil.errToObj(t) });
    }
    cuid(t) {
      return this._addCheck({ kind: "cuid", ...Se.errorUtil.errToObj(t) });
    }
    cuid2(t) {
      return this._addCheck({ kind: "cuid2", ...Se.errorUtil.errToObj(t) });
    }
    ulid(t) {
      return this._addCheck({ kind: "ulid", ...Se.errorUtil.errToObj(t) });
    }
    base64(t) {
      return this._addCheck({ kind: "base64", ...Se.errorUtil.errToObj(t) });
    }
    base64url(t) {
      return this._addCheck({
        kind: "base64url",
        ...Se.errorUtil.errToObj(t)
      });
    }
    jwt(t) {
      return this._addCheck({ kind: "jwt", ...Se.errorUtil.errToObj(t) });
    }
    ip(t) {
      return this._addCheck({ kind: "ip", ...Se.errorUtil.errToObj(t) });
    }
    cidr(t) {
      return this._addCheck({ kind: "cidr", ...Se.errorUtil.errToObj(t) });
    }
    datetime(t) {
      var r, i;
      return typeof t == "string" ? this._addCheck({
        kind: "datetime",
        precision: null,
        offset: !1,
        local: !1,
        message: t
      }) : this._addCheck({
        kind: "datetime",
        precision: typeof t?.precision > "u" ? null : t?.precision,
        offset: (r = t?.offset) !== null && r !== void 0 ? r : !1,
        local: (i = t?.local) !== null && i !== void 0 ? i : !1,
        ...Se.errorUtil.errToObj(t?.message)
      });
    }
    date(t) {
      return this._addCheck({ kind: "date", message: t });
    }
    time(t) {
      return typeof t == "string" ? this._addCheck({
        kind: "time",
        precision: null,
        message: t
      }) : this._addCheck({
        kind: "time",
        precision: typeof t?.precision > "u" ? null : t?.precision,
        ...Se.errorUtil.errToObj(t?.message)
      });
    }
    duration(t) {
      return this._addCheck({ kind: "duration", ...Se.errorUtil.errToObj(t) });
    }
    regex(t, r) {
      return this._addCheck({
        kind: "regex",
        regex: t,
        ...Se.errorUtil.errToObj(r)
      });
    }
    includes(t, r) {
      return this._addCheck({
        kind: "includes",
        value: t,
        position: r?.position,
        ...Se.errorUtil.errToObj(r?.message)
      });
    }
    startsWith(t, r) {
      return this._addCheck({
        kind: "startsWith",
        value: t,
        ...Se.errorUtil.errToObj(r)
      });
    }
    endsWith(t, r) {
      return this._addCheck({
        kind: "endsWith",
        value: t,
        ...Se.errorUtil.errToObj(r)
      });
    }
    min(t, r) {
      return this._addCheck({
        kind: "min",
        value: t,
        ...Se.errorUtil.errToObj(r)
      });
    }
    max(t, r) {
      return this._addCheck({
        kind: "max",
        value: t,
        ...Se.errorUtil.errToObj(r)
      });
    }
    length(t, r) {
      return this._addCheck({
        kind: "length",
        value: t,
        ...Se.errorUtil.errToObj(r)
      });
    }
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(t) {
      return this.min(1, Se.errorUtil.errToObj(t));
    }
    trim() {
      return new e({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new e({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new e({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((t) => t.kind === "datetime");
    }
    get isDate() {
      return !!this._def.checks.find((t) => t.kind === "date");
    }
    get isTime() {
      return !!this._def.checks.find((t) => t.kind === "time");
    }
    get isDuration() {
      return !!this._def.checks.find((t) => t.kind === "duration");
    }
    get isEmail() {
      return !!this._def.checks.find((t) => t.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((t) => t.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((t) => t.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((t) => t.kind === "uuid");
    }
    get isNANOID() {
      return !!this._def.checks.find((t) => t.kind === "nanoid");
    }
    get isCUID() {
      return !!this._def.checks.find((t) => t.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((t) => t.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((t) => t.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((t) => t.kind === "ip");
    }
    get isCIDR() {
      return !!this._def.checks.find((t) => t.kind === "cidr");
    }
    get isBase64() {
      return !!this._def.checks.find((t) => t.kind === "base64");
    }
    get isBase64url() {
      return !!this._def.checks.find((t) => t.kind === "base64url");
    }
    get minLength() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t;
    }
    get maxLength() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t;
    }
  };
  $.ZodString = oo;
  oo.create = (e) => {
    var t;
    return new oo({
      checks: [],
      typeName: Oe.ZodString,
      coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
      ...qe(e)
    });
  };
  function GZe(e, t) {
    let r = (e.toString().split(".")[1] || "").length, i = (t.toString().split(".")[1] || "").length, s = r > i ? r : i, a = parseInt(e.toFixed(
    s).replace(".", "")), o = parseInt(t.toFixed(s).replace(".", ""));
    return a % o / Math.pow(10, s);
  }
  n(GZe, "floatSafeRemainder");
  var Au = class e extends Ue {
    static {
      n(this, "ZodNumber");
    }
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
    }
    _parse(t) {
      if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== ce.ZodParsedType.number) {
        let a = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(a, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.number,
          received: a.parsedType
        }), W.INVALID;
      }
      let i, s = new W.ParseStatus();
      for (let a of this._def.checks)
        a.kind === "int" ? ce.util.isInteger(t.data) || (i = this._getOrReturnCtx(t, i), (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.invalid_type,
          expected: "integer",
          received: "float",
          message: a.message
        }), s.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (i = this._getOrReturnCtx(t, i), (0, W.addIssueToContext)(
        i, {
          code: ue.ZodIssueCode.too_small,
          minimum: a.value,
          type: "number",
          inclusive: a.inclusive,
          exact: !1,
          message: a.message
        }), s.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (i = this._getOrReturnCtx(t, i), (0, W.addIssueToContext)(
        i, {
          code: ue.ZodIssueCode.too_big,
          maximum: a.value,
          type: "number",
          inclusive: a.inclusive,
          exact: !1,
          message: a.message
        }), s.dirty()) : a.kind === "multipleOf" ? GZe(t.data, a.value) !== 0 && (i = this._getOrReturnCtx(t, i), (0, W.addIssueToContext)(i,
        {
          code: ue.ZodIssueCode.not_multiple_of,
          multipleOf: a.value,
          message: a.message
        }), s.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (i = this._getOrReturnCtx(t, i), (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.not_finite,
          message: a.message
        }), s.dirty()) : ce.util.assertNever(a);
      return { status: s.value, value: t.data };
    }
    gte(t, r) {
      return this.setLimit("min", t, !0, Se.errorUtil.toString(r));
    }
    gt(t, r) {
      return this.setLimit("min", t, !1, Se.errorUtil.toString(r));
    }
    lte(t, r) {
      return this.setLimit("max", t, !0, Se.errorUtil.toString(r));
    }
    lt(t, r) {
      return this.setLimit("max", t, !1, Se.errorUtil.toString(r));
    }
    setLimit(t, r, i, s) {
      return new e({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: t,
            value: r,
            inclusive: i,
            message: Se.errorUtil.toString(s)
          }
        ]
      });
    }
    _addCheck(t) {
      return new e({
        ...this._def,
        checks: [...this._def.checks, t]
      });
    }
    int(t) {
      return this._addCheck({
        kind: "int",
        message: Se.errorUtil.toString(t)
      });
    }
    positive(t) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !1,
        message: Se.errorUtil.toString(t)
      });
    }
    negative(t) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !1,
        message: Se.errorUtil.toString(t)
      });
    }
    nonpositive(t) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: !0,
        message: Se.errorUtil.toString(t)
      });
    }
    nonnegative(t) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: !0,
        message: Se.errorUtil.toString(t)
      });
    }
    multipleOf(t, r) {
      return this._addCheck({
        kind: "multipleOf",
        value: t,
        message: Se.errorUtil.toString(r)
      });
    }
    finite(t) {
      return this._addCheck({
        kind: "finite",
        message: Se.errorUtil.toString(t)
      });
    }
    safe(t) {
      return this._addCheck({
        kind: "min",
        inclusive: !0,
        value: Number.MIN_SAFE_INTEGER,
        message: Se.errorUtil.toString(t)
      })._addCheck({
        kind: "max",
        inclusive: !0,
        value: Number.MAX_SAFE_INTEGER,
        message: Se.errorUtil.toString(t)
      });
    }
    get minValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t;
    }
    get maxValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t;
    }
    get isInt() {
      return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && ce.util.isInteger(t.value));
    }
    get isFinite() {
      let t = null, r = null;
      for (let i of this._def.checks) {
        if (i.kind === "finite" || i.kind === "int" || i.kind === "multipleOf")
          return !0;
        i.kind === "min" ? (r === null || i.value > r) && (r = i.value) : i.kind === "max" && (t === null || i.value < t) && (t = i.value);
      }
      return Number.isFinite(r) && Number.isFinite(t);
    }
  };
  $.ZodNumber = Au;
  Au.create = (e) => new Au({
    checks: [],
    typeName: Oe.ZodNumber,
    coerce: e?.coerce || !1,
    ...qe(e)
  });
  var _u = class e extends Ue {
    static {
      n(this, "ZodBigInt");
    }
    constructor() {
      super(...arguments), this.min = this.gte, this.max = this.lte;
    }
    _parse(t) {
      if (this._def.coerce)
        try {
          t.data = BigInt(t.data);
        } catch {
          return this._getInvalidInput(t);
        }
      if (this._getType(t) !== ce.ZodParsedType.bigint)
        return this._getInvalidInput(t);
      let i, s = new W.ParseStatus();
      for (let a of this._def.checks)
        a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (i = this._getOrReturnCtx(t, i), (0, W.addIssueToContext)(
        i, {
          code: ue.ZodIssueCode.too_small,
          type: "bigint",
          minimum: a.value,
          inclusive: a.inclusive,
          message: a.message
        }), s.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (i = this._getOrReturnCtx(t, i), (0, W.addIssueToContext)(
        i, {
          code: ue.ZodIssueCode.too_big,
          type: "bigint",
          maximum: a.value,
          inclusive: a.inclusive,
          message: a.message
        }), s.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (i = this._getOrReturnCtx(t, i), (0, W.addIssueToContext)(
        i, {
          code: ue.ZodIssueCode.not_multiple_of,
          multipleOf: a.value,
          message: a.message
        }), s.dirty()) : ce.util.assertNever(a);
      return { status: s.value, value: t.data };
    }
    _getInvalidInput(t) {
      let r = this._getOrReturnCtx(t);
      return (0, W.addIssueToContext)(r, {
        code: ue.ZodIssueCode.invalid_type,
        expected: ce.ZodParsedType.bigint,
        received: r.parsedType
      }), W.INVALID;
    }
    gte(t, r) {
      return this.setLimit("min", t, !0, Se.errorUtil.toString(r));
    }
    gt(t, r) {
      return this.setLimit("min", t, !1, Se.errorUtil.toString(r));
    }
    lte(t, r) {
      return this.setLimit("max", t, !0, Se.errorUtil.toString(r));
    }
    lt(t, r) {
      return this.setLimit("max", t, !1, Se.errorUtil.toString(r));
    }
    setLimit(t, r, i, s) {
      return new e({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind: t,
            value: r,
            inclusive: i,
            message: Se.errorUtil.toString(s)
          }
        ]
      });
    }
    _addCheck(t) {
      return new e({
        ...this._def,
        checks: [...this._def.checks, t]
      });
    }
    positive(t) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !1,
        message: Se.errorUtil.toString(t)
      });
    }
    negative(t) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !1,
        message: Se.errorUtil.toString(t)
      });
    }
    nonpositive(t) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: !0,
        message: Se.errorUtil.toString(t)
      });
    }
    nonnegative(t) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: !0,
        message: Se.errorUtil.toString(t)
      });
    }
    multipleOf(t, r) {
      return this._addCheck({
        kind: "multipleOf",
        value: t,
        message: Se.errorUtil.toString(r)
      });
    }
    get minValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t;
    }
    get maxValue() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t;
    }
  };
  $.ZodBigInt = _u;
  _u.create = (e) => {
    var t;
    return new _u({
      checks: [],
      typeName: Oe.ZodBigInt,
      coerce: (t = e?.coerce) !== null && t !== void 0 ? t : !1,
      ...qe(e)
    });
  };
  var Pu = class extends Ue {
    static {
      n(this, "ZodBoolean");
    }
    _parse(t) {
      if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== ce.ZodParsedType.boolean) {
        let i = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.boolean,
          received: i.parsedType
        }), W.INVALID;
      }
      return (0, W.OK)(t.data);
    }
  };
  $.ZodBoolean = Pu;
  Pu.create = (e) => new Pu({
    typeName: Oe.ZodBoolean,
    coerce: e?.coerce || !1,
    ...qe(e)
  });
  var Fu = class e extends Ue {
    static {
      n(this, "ZodDate");
    }
    _parse(t) {
      if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== ce.ZodParsedType.date) {
        let a = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(a, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.date,
          received: a.parsedType
        }), W.INVALID;
      }
      if (isNaN(t.data.getTime())) {
        let a = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(a, {
          code: ue.ZodIssueCode.invalid_date
        }), W.INVALID;
      }
      let i = new W.ParseStatus(), s;
      for (let a of this._def.checks)
        a.kind === "min" ? t.data.getTime() < a.value && (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          code: ue.ZodIssueCode.too_small,
          message: a.message,
          inclusive: !0,
          exact: !1,
          minimum: a.value,
          type: "date"
        }), i.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (s = this._getOrReturnCtx(t, s), (0, W.addIssueToContext)(s, {
          code: ue.ZodIssueCode.too_big,
          message: a.message,
          inclusive: !0,
          exact: !1,
          maximum: a.value,
          type: "date"
        }), i.dirty()) : ce.util.assertNever(a);
      return {
        status: i.value,
        value: new Date(t.data.getTime())
      };
    }
    _addCheck(t) {
      return new e({
        ...this._def,
        checks: [...this._def.checks, t]
      });
    }
    min(t, r) {
      return this._addCheck({
        kind: "min",
        value: t.getTime(),
        message: Se.errorUtil.toString(r)
      });
    }
    max(t, r) {
      return this._addCheck({
        kind: "max",
        value: t.getTime(),
        message: Se.errorUtil.toString(r)
      });
    }
    get minDate() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "min" && (t === null || r.value > t) && (t = r.value);
      return t != null ? new Date(t) : null;
    }
    get maxDate() {
      let t = null;
      for (let r of this._def.checks)
        r.kind === "max" && (t === null || r.value < t) && (t = r.value);
      return t != null ? new Date(t) : null;
    }
  };
  $.ZodDate = Fu;
  Fu.create = (e) => new Fu({
    checks: [],
    coerce: e?.coerce || !1,
    typeName: Oe.ZodDate,
    ...qe(e)
  });
  var Uc = class extends Ue {
    static {
      n(this, "ZodSymbol");
    }
    _parse(t) {
      if (this._getType(t) !== ce.ZodParsedType.symbol) {
        let i = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.symbol,
          received: i.parsedType
        }), W.INVALID;
      }
      return (0, W.OK)(t.data);
    }
  };
  $.ZodSymbol = Uc;
  Uc.create = (e) => new Uc({
    typeName: Oe.ZodSymbol,
    ...qe(e)
  });
  var Iu = class extends Ue {
    static {
      n(this, "ZodUndefined");
    }
    _parse(t) {
      if (this._getType(t) !== ce.ZodParsedType.undefined) {
        let i = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.undefined,
          received: i.parsedType
        }), W.INVALID;
      }
      return (0, W.OK)(t.data);
    }
  };
  $.ZodUndefined = Iu;
  Iu.create = (e) => new Iu({
    typeName: Oe.ZodUndefined,
    ...qe(e)
  });
  var Ou = class extends Ue {
    static {
      n(this, "ZodNull");
    }
    _parse(t) {
      if (this._getType(t) !== ce.ZodParsedType.null) {
        let i = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.null,
          received: i.parsedType
        }), W.INVALID;
      }
      return (0, W.OK)(t.data);
    }
  };
  $.ZodNull = Ou;
  Ou.create = (e) => new Ou({
    typeName: Oe.ZodNull,
    ...qe(e)
  });
  var uo = class extends Ue {
    static {
      n(this, "ZodAny");
    }
    constructor() {
      super(...arguments), this._any = !0;
    }
    _parse(t) {
      return (0, W.OK)(t.data);
    }
  };
  $.ZodAny = uo;
  uo.create = (e) => new uo({
    typeName: Oe.ZodAny,
    ...qe(e)
  });
  var ua = class extends Ue {
    static {
      n(this, "ZodUnknown");
    }
    constructor() {
      super(...arguments), this._unknown = !0;
    }
    _parse(t) {
      return (0, W.OK)(t.data);
    }
  };
  $.ZodUnknown = ua;
  ua.create = (e) => new ua({
    typeName: Oe.ZodUnknown,
    ...qe(e)
  });
  var Is = class extends Ue {
    static {
      n(this, "ZodNever");
    }
    _parse(t) {
      let r = this._getOrReturnCtx(t);
      return (0, W.addIssueToContext)(r, {
        code: ue.ZodIssueCode.invalid_type,
        expected: ce.ZodParsedType.never,
        received: r.parsedType
      }), W.INVALID;
    }
  };
  $.ZodNever = Is;
  Is.create = (e) => new Is({
    typeName: Oe.ZodNever,
    ...qe(e)
  });
  var $c = class extends Ue {
    static {
      n(this, "ZodVoid");
    }
    _parse(t) {
      if (this._getType(t) !== ce.ZodParsedType.undefined) {
        let i = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.void,
          received: i.parsedType
        }), W.INVALID;
      }
      return (0, W.OK)(t.data);
    }
  };
  $.ZodVoid = $c;
  $c.create = (e) => new $c({
    typeName: Oe.ZodVoid,
    ...qe(e)
  });
  var la = class e extends Ue {
    static {
      n(this, "ZodArray");
    }
    _parse(t) {
      let { ctx: r, status: i } = this._processInputParams(t), s = this._def;
      if (r.parsedType !== ce.ZodParsedType.array)
        return (0, W.addIssueToContext)(r, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.array,
          received: r.parsedType
        }), W.INVALID;
      if (s.exactLength !== null) {
        let o = r.data.length > s.exactLength.value, u = r.data.length < s.exactLength.value;
        (o || u) && ((0, W.addIssueToContext)(r, {
          code: o ? ue.ZodIssueCode.too_big : ue.ZodIssueCode.too_small,
          minimum: u ? s.exactLength.value : void 0,
          maximum: o ? s.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: s.exactLength.message
        }), i.dirty());
      }
      if (s.minLength !== null && r.data.length < s.minLength.value && ((0, W.addIssueToContext)(r, {
        code: ue.ZodIssueCode.too_small,
        minimum: s.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: s.minLength.message
      }), i.dirty()), s.maxLength !== null && r.data.length > s.maxLength.value && ((0, W.addIssueToContext)(r, {
        code: ue.ZodIssueCode.too_big,
        maximum: s.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: s.maxLength.message
      }), i.dirty()), r.common.async)
        return Promise.all([...r.data].map((o, u) => s.type._parseAsync(new ns(r, o, r.path, u)))).then((o) => W.ParseStatus.mergeArray(i, o));
      let a = [...r.data].map((o, u) => s.type._parseSync(new ns(r, o, r.path, u)));
      return W.ParseStatus.mergeArray(i, a);
    }
    get element() {
      return this._def.type;
    }
    min(t, r) {
      return new e({
        ...this._def,
        minLength: { value: t, message: Se.errorUtil.toString(r) }
      });
    }
    max(t, r) {
      return new e({
        ...this._def,
        maxLength: { value: t, message: Se.errorUtil.toString(r) }
      });
    }
    length(t, r) {
      return new e({
        ...this._def,
        exactLength: { value: t, message: Se.errorUtil.toString(r) }
      });
    }
    nonempty(t) {
      return this.min(1, t);
    }
  };
  $.ZodArray = la;
  la.create = (e, t) => new la({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: Oe.ZodArray,
    ...qe(t)
  });
  function qc(e) {
    if (e instanceof gi) {
      let t = {};
      for (let r in e.shape) {
        let i = e.shape[r];
        t[r] = ss.create(qc(i));
      }
      return new gi({
        ...e._def,
        shape: /* @__PURE__ */ n(() => t, "shape")
      });
    } else return e instanceof la ? new la({
      ...e._def,
      type: qc(e.element)
    }) : e instanceof ss ? ss.create(qc(e.unwrap())) : e instanceof dn ? dn.create(qc(e.unwrap())) : e instanceof fn ? fn.create(e.items.map(
    (t) => qc(t))) : e;
  }
  n(qc, "deepPartialify");
  var gi = class e extends Ue {
    static {
      n(this, "ZodObject");
    }
    constructor() {
      super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      let t = this._def.shape(), r = ce.util.objectKeys(t);
      return this._cached = { shape: t, keys: r };
    }
    _parse(t) {
      if (this._getType(t) !== ce.ZodParsedType.object) {
        let c = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(c, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.object,
          received: c.parsedType
        }), W.INVALID;
      }
      let { status: i, ctx: s } = this._processInputParams(t), { shape: a, keys: o } = this._getCached(), u = [];
      if (!(this._def.catchall instanceof Is && this._def.unknownKeys === "strip"))
        for (let c in s.data)
          o.includes(c) || u.push(c);
      let l = [];
      for (let c of o) {
        let f = a[c], m = s.data[c];
        l.push({
          key: { status: "valid", value: c },
          value: f._parse(new ns(s, m, s.path, c)),
          alwaysSet: c in s.data
        });
      }
      if (this._def.catchall instanceof Is) {
        let c = this._def.unknownKeys;
        if (c === "passthrough")
          for (let f of u)
            l.push({
              key: { status: "valid", value: f },
              value: { status: "valid", value: s.data[f] }
            });
        else if (c === "strict")
          u.length > 0 && ((0, W.addIssueToContext)(s, {
            code: ue.ZodIssueCode.unrecognized_keys,
            keys: u
          }), i.dirty());
        else if (c !== "strip")
          throw new Error("Internal ZodObject error: invalid unknownKeys value.");
      } else {
        let c = this._def.catchall;
        for (let f of u) {
          let m = s.data[f];
          l.push({
            key: { status: "valid", value: f },
            value: c._parse(
              new ns(s, m, s.path, f)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: f in s.data
          });
        }
      }
      return s.common.async ? Promise.resolve().then(async () => {
        let c = [];
        for (let f of l) {
          let m = await f.key, h = await f.value;
          c.push({
            key: m,
            value: h,
            alwaysSet: f.alwaysSet
          });
        }
        return c;
      }).then((c) => W.ParseStatus.mergeObjectSync(i, c)) : W.ParseStatus.mergeObjectSync(i, l);
    }
    get shape() {
      return this._def.shape();
    }
    strict(t) {
      return Se.errorUtil.errToObj, new e({
        ...this._def,
        unknownKeys: "strict",
        ...t !== void 0 ? {
          errorMap: /* @__PURE__ */ n((r, i) => {
            var s, a, o, u;
            let l = (o = (a = (s = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(s, r, i).message) !== null && o !== void 0 ?
            o : i.defaultError;
            return r.code === "unrecognized_keys" ? {
              message: (u = Se.errorUtil.errToObj(t).message) !== null && u !== void 0 ? u : l
            } : {
              message: l
            };
          }, "errorMap")
        } : {}
      });
    }
    strip() {
      return new e({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new e({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(t) {
      return new e({
        ...this._def,
        shape: /* @__PURE__ */ n(() => ({
          ...this._def.shape(),
          ...t
        }), "shape")
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(t) {
      return new e({
        unknownKeys: t._def.unknownKeys,
        catchall: t._def.catchall,
        shape: /* @__PURE__ */ n(() => ({
          ...this._def.shape(),
          ...t._def.shape()
        }), "shape"),
        typeName: Oe.ZodObject
      });
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(t, r) {
      return this.augment({ [t]: r });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(t) {
      return new e({
        ...this._def,
        catchall: t
      });
    }
    pick(t) {
      let r = {};
      return ce.util.objectKeys(t).forEach((i) => {
        t[i] && this.shape[i] && (r[i] = this.shape[i]);
      }), new e({
        ...this._def,
        shape: /* @__PURE__ */ n(() => r, "shape")
      });
    }
    omit(t) {
      let r = {};
      return ce.util.objectKeys(this.shape).forEach((i) => {
        t[i] || (r[i] = this.shape[i]);
      }), new e({
        ...this._def,
        shape: /* @__PURE__ */ n(() => r, "shape")
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return qc(this);
    }
    partial(t) {
      let r = {};
      return ce.util.objectKeys(this.shape).forEach((i) => {
        let s = this.shape[i];
        t && !t[i] ? r[i] = s : r[i] = s.optional();
      }), new e({
        ...this._def,
        shape: /* @__PURE__ */ n(() => r, "shape")
      });
    }
    required(t) {
      let r = {};
      return ce.util.objectKeys(this.shape).forEach((i) => {
        if (t && !t[i])
          r[i] = this.shape[i];
        else {
          let a = this.shape[i];
          for (; a instanceof ss; )
            a = a._def.innerType;
          r[i] = a;
        }
      }), new e({
        ...this._def,
        shape: /* @__PURE__ */ n(() => r, "shape")
      });
    }
    keyof() {
      return HY(ce.util.objectKeys(this.shape));
    }
  };
  $.ZodObject = gi;
  gi.create = (e, t) => new gi({
    shape: /* @__PURE__ */ n(() => e, "shape"),
    unknownKeys: "strip",
    catchall: Is.create(),
    typeName: Oe.ZodObject,
    ...qe(t)
  });
  gi.strictCreate = (e, t) => new gi({
    shape: /* @__PURE__ */ n(() => e, "shape"),
    unknownKeys: "strict",
    catchall: Is.create(),
    typeName: Oe.ZodObject,
    ...qe(t)
  });
  gi.lazycreate = (e, t) => new gi({
    shape: e,
    unknownKeys: "strip",
    catchall: Is.create(),
    typeName: Oe.ZodObject,
    ...qe(t)
  });
  var ku = class extends Ue {
    static {
      n(this, "ZodUnion");
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t), i = this._def.options;
      function s(a) {
        for (let u of a)
          if (u.result.status === "valid")
            return u.result;
        for (let u of a)
          if (u.result.status === "dirty")
            return r.common.issues.push(...u.ctx.common.issues), u.result;
        let o = a.map((u) => new ue.ZodError(u.ctx.common.issues));
        return (0, W.addIssueToContext)(r, {
          code: ue.ZodIssueCode.invalid_union,
          unionErrors: o
        }), W.INVALID;
      }
      if (n(s, "handleResults"), r.common.async)
        return Promise.all(i.map(async (a) => {
          let o = {
            ...r,
            common: {
              ...r.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await a._parseAsync({
              data: r.data,
              path: r.path,
              parent: o
            }),
            ctx: o
          };
        })).then(s);
      {
        let a, o = [];
        for (let l of i) {
          let c = {
            ...r,
            common: {
              ...r.common,
              issues: []
            },
            parent: null
          }, f = l._parseSync({
            data: r.data,
            path: r.path,
            parent: c
          });
          if (f.status === "valid")
            return f;
          f.status === "dirty" && !a && (a = { result: f, ctx: c }), c.common.issues.length && o.push(c.common.issues);
        }
        if (a)
          return r.common.issues.push(...a.ctx.common.issues), a.result;
        let u = o.map((l) => new ue.ZodError(l));
        return (0, W.addIssueToContext)(r, {
          code: ue.ZodIssueCode.invalid_union,
          unionErrors: u
        }), W.INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  $.ZodUnion = ku;
  ku.create = (e, t) => new ku({
    options: e,
    typeName: Oe.ZodUnion,
    ...qe(t)
  });
  var oa = /* @__PURE__ */ n((e) => e instanceof Nu ? oa(e.schema) : e instanceof Bi ? oa(e.innerType()) : e instanceof Mu ? [e.value] : e instanceof
  Ru ? e.options : e instanceof Lu ? ce.util.objectValues(e.enum) : e instanceof ju ? oa(e._def.innerType) : e instanceof Iu ? [void 0] : e instanceof
  Ou ? [null] : e instanceof ss ? [void 0, ...oa(e.unwrap())] : e instanceof dn ? [null, ...oa(e.unwrap())] : e instanceof oh || e instanceof
  Uu ? oa(e.unwrap()) : e instanceof qu ? oa(e._def.innerType) : [], "getDiscriminator"), pb = class e extends Ue {
    static {
      n(this, "ZodDiscriminatedUnion");
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t);
      if (r.parsedType !== ce.ZodParsedType.object)
        return (0, W.addIssueToContext)(r, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.object,
          received: r.parsedType
        }), W.INVALID;
      let i = this.discriminator, s = r.data[i], a = this.optionsMap.get(s);
      return a ? r.common.async ? a._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }) : a._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      }) : ((0, W.addIssueToContext)(r, {
        code: ue.ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [i]
      }), W.INVALID);
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(t, r, i) {
      let s = /* @__PURE__ */ new Map();
      for (let a of r) {
        let o = oa(a.shape[t]);
        if (!o.length)
          throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
        for (let u of o) {
          if (s.has(u))
            throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(u)}`);
          s.set(u, a);
        }
      }
      return new e({
        typeName: Oe.ZodDiscriminatedUnion,
        discriminator: t,
        options: r,
        optionsMap: s,
        ...qe(i)
      });
    }
  };
  $.ZodDiscriminatedUnion = pb;
  function QP(e, t) {
    let r = (0, ce.getParsedType)(e), i = (0, ce.getParsedType)(t);
    if (e === t)
      return { valid: !0, data: e };
    if (r === ce.ZodParsedType.object && i === ce.ZodParsedType.object) {
      let s = ce.util.objectKeys(t), a = ce.util.objectKeys(e).filter((u) => s.indexOf(u) !== -1), o = { ...e, ...t };
      for (let u of a) {
        let l = QP(e[u], t[u]);
        if (!l.valid)
          return { valid: !1 };
        o[u] = l.data;
      }
      return { valid: !0, data: o };
    } else if (r === ce.ZodParsedType.array && i === ce.ZodParsedType.array) {
      if (e.length !== t.length)
        return { valid: !1 };
      let s = [];
      for (let a = 0; a < e.length; a++) {
        let o = e[a], u = t[a], l = QP(o, u);
        if (!l.valid)
          return { valid: !1 };
        s.push(l.data);
      }
      return { valid: !0, data: s };
    } else return r === ce.ZodParsedType.date && i === ce.ZodParsedType.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
  }
  n(QP, "mergeValues");
  var Bu = class extends Ue {
    static {
      n(this, "ZodIntersection");
    }
    _parse(t) {
      let { status: r, ctx: i } = this._processInputParams(t), s = /* @__PURE__ */ n((a, o) => {
        if ((0, W.isAborted)(a) || (0, W.isAborted)(o))
          return W.INVALID;
        let u = QP(a.value, o.value);
        return u.valid ? (((0, W.isDirty)(a) || (0, W.isDirty)(o)) && r.dirty(), { status: r.value, value: u.data }) : ((0, W.addIssueToContext)(
        i, {
          code: ue.ZodIssueCode.invalid_intersection_types
        }), W.INVALID);
      }, "handleParsed");
      return i.common.async ? Promise.all([
        this._def.left._parseAsync({
          data: i.data,
          path: i.path,
          parent: i
        }),
        this._def.right._parseAsync({
          data: i.data,
          path: i.path,
          parent: i
        })
      ]).then(([a, o]) => s(a, o)) : s(this._def.left._parseSync({
        data: i.data,
        path: i.path,
        parent: i
      }), this._def.right._parseSync({
        data: i.data,
        path: i.path,
        parent: i
      }));
    }
  };
  $.ZodIntersection = Bu;
  Bu.create = (e, t, r) => new Bu({
    left: e,
    right: t,
    typeName: Oe.ZodIntersection,
    ...qe(r)
  });
  var fn = class e extends Ue {
    static {
      n(this, "ZodTuple");
    }
    _parse(t) {
      let { status: r, ctx: i } = this._processInputParams(t);
      if (i.parsedType !== ce.ZodParsedType.array)
        return (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.array,
          received: i.parsedType
        }), W.INVALID;
      if (i.data.length < this._def.items.length)
        return (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), W.INVALID;
      !this._def.rest && i.data.length > this._def.items.length && ((0, W.addIssueToContext)(i, {
        code: ue.ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), r.dirty());
      let a = [...i.data].map((o, u) => {
        let l = this._def.items[u] || this._def.rest;
        return l ? l._parse(new ns(i, o, i.path, u)) : null;
      }).filter((o) => !!o);
      return i.common.async ? Promise.all(a).then((o) => W.ParseStatus.mergeArray(r, o)) : W.ParseStatus.mergeArray(r, a);
    }
    get items() {
      return this._def.items;
    }
    rest(t) {
      return new e({
        ...this._def,
        rest: t
      });
    }
  };
  $.ZodTuple = fn;
  fn.create = (e, t) => {
    if (!Array.isArray(e))
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new fn({
      items: e,
      typeName: Oe.ZodTuple,
      rest: null,
      ...qe(t)
    });
  };
  var hb = class e extends Ue {
    static {
      n(this, "ZodRecord");
    }
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(t) {
      let { status: r, ctx: i } = this._processInputParams(t);
      if (i.parsedType !== ce.ZodParsedType.object)
        return (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.object,
          received: i.parsedType
        }), W.INVALID;
      let s = [], a = this._def.keyType, o = this._def.valueType;
      for (let u in i.data)
        s.push({
          key: a._parse(new ns(i, u, i.path, u)),
          value: o._parse(new ns(i, i.data[u], i.path, u)),
          alwaysSet: u in i.data
        });
      return i.common.async ? W.ParseStatus.mergeObjectAsync(r, s) : W.ParseStatus.mergeObjectSync(r, s);
    }
    get element() {
      return this._def.valueType;
    }
    static create(t, r, i) {
      return r instanceof Ue ? new e({
        keyType: t,
        valueType: r,
        typeName: Oe.ZodRecord,
        ...qe(i)
      }) : new e({
        keyType: oo.create(),
        valueType: t,
        typeName: Oe.ZodRecord,
        ...qe(r)
      });
    }
  };
  $.ZodRecord = hb;
  var Vc = class extends Ue {
    static {
      n(this, "ZodMap");
    }
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(t) {
      let { status: r, ctx: i } = this._processInputParams(t);
      if (i.parsedType !== ce.ZodParsedType.map)
        return (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.map,
          received: i.parsedType
        }), W.INVALID;
      let s = this._def.keyType, a = this._def.valueType, o = [...i.data.entries()].map(([u, l], c) => ({
        key: s._parse(new ns(i, u, i.path, [c, "key"])),
        value: a._parse(new ns(i, l, i.path, [c, "value"]))
      }));
      if (i.common.async) {
        let u = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (let l of o) {
            let c = await l.key, f = await l.value;
            if (c.status === "aborted" || f.status === "aborted")
              return W.INVALID;
            (c.status === "dirty" || f.status === "dirty") && r.dirty(), u.set(c.value, f.value);
          }
          return { status: r.value, value: u };
        });
      } else {
        let u = /* @__PURE__ */ new Map();
        for (let l of o) {
          let c = l.key, f = l.value;
          if (c.status === "aborted" || f.status === "aborted")
            return W.INVALID;
          (c.status === "dirty" || f.status === "dirty") && r.dirty(), u.set(c.value, f.value);
        }
        return { status: r.value, value: u };
      }
    }
  };
  $.ZodMap = Vc;
  Vc.create = (e, t, r) => new Vc({
    valueType: t,
    keyType: e,
    typeName: Oe.ZodMap,
    ...qe(r)
  });
  var Wc = class e extends Ue {
    static {
      n(this, "ZodSet");
    }
    _parse(t) {
      let { status: r, ctx: i } = this._processInputParams(t);
      if (i.parsedType !== ce.ZodParsedType.set)
        return (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.set,
          received: i.parsedType
        }), W.INVALID;
      let s = this._def;
      s.minSize !== null && i.data.size < s.minSize.value && ((0, W.addIssueToContext)(i, {
        code: ue.ZodIssueCode.too_small,
        minimum: s.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: s.minSize.message
      }), r.dirty()), s.maxSize !== null && i.data.size > s.maxSize.value && ((0, W.addIssueToContext)(i, {
        code: ue.ZodIssueCode.too_big,
        maximum: s.maxSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: s.maxSize.message
      }), r.dirty());
      let a = this._def.valueType;
      function o(l) {
        let c = /* @__PURE__ */ new Set();
        for (let f of l) {
          if (f.status === "aborted")
            return W.INVALID;
          f.status === "dirty" && r.dirty(), c.add(f.value);
        }
        return { status: r.value, value: c };
      }
      n(o, "finalizeSet");
      let u = [...i.data.values()].map((l, c) => a._parse(new ns(i, l, i.path, c)));
      return i.common.async ? Promise.all(u).then((l) => o(l)) : o(u);
    }
    min(t, r) {
      return new e({
        ...this._def,
        minSize: { value: t, message: Se.errorUtil.toString(r) }
      });
    }
    max(t, r) {
      return new e({
        ...this._def,
        maxSize: { value: t, message: Se.errorUtil.toString(r) }
      });
    }
    size(t, r) {
      return this.min(t, r).max(t, r);
    }
    nonempty(t) {
      return this.min(1, t);
    }
  };
  $.ZodSet = Wc;
  Wc.create = (e, t) => new Wc({
    valueType: e,
    minSize: null,
    maxSize: null,
    typeName: Oe.ZodSet,
    ...qe(t)
  });
  var mb = class e extends Ue {
    static {
      n(this, "ZodFunction");
    }
    constructor() {
      super(...arguments), this.validate = this.implement;
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t);
      if (r.parsedType !== ce.ZodParsedType.function)
        return (0, W.addIssueToContext)(r, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.function,
          received: r.parsedType
        }), W.INVALID;
      function i(u, l) {
        return (0, W.makeIssue)({
          data: u,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            (0, fb.getErrorMap)(),
            fb.defaultErrorMap
          ].filter((c) => !!c),
          issueData: {
            code: ue.ZodIssueCode.invalid_arguments,
            argumentsError: l
          }
        });
      }
      n(i, "makeArgsIssue");
      function s(u, l) {
        return (0, W.makeIssue)({
          data: u,
          path: r.path,
          errorMaps: [
            r.common.contextualErrorMap,
            r.schemaErrorMap,
            (0, fb.getErrorMap)(),
            fb.defaultErrorMap
          ].filter((c) => !!c),
          issueData: {
            code: ue.ZodIssueCode.invalid_return_type,
            returnTypeError: l
          }
        });
      }
      n(s, "makeReturnsIssue");
      let a = { errorMap: r.common.contextualErrorMap }, o = r.data;
      if (this._def.returns instanceof lo) {
        let u = this;
        return (0, W.OK)(async function(...l) {
          let c = new ue.ZodError([]), f = await u._def.args.parseAsync(l, a).catch((d) => {
            throw c.addIssue(i(l, d)), c;
          }), m = await Reflect.apply(o, this, f);
          return await u._def.returns._def.type.parseAsync(m, a).catch((d) => {
            throw c.addIssue(s(m, d)), c;
          });
        });
      } else {
        let u = this;
        return (0, W.OK)(function(...l) {
          let c = u._def.args.safeParse(l, a);
          if (!c.success)
            throw new ue.ZodError([i(l, c.error)]);
          let f = Reflect.apply(o, this, c.data), m = u._def.returns.safeParse(f, a);
          if (!m.success)
            throw new ue.ZodError([s(f, m.error)]);
          return m.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...t) {
      return new e({
        ...this._def,
        args: fn.create(t).rest(ua.create())
      });
    }
    returns(t) {
      return new e({
        ...this._def,
        returns: t
      });
    }
    implement(t) {
      return this.parse(t);
    }
    strictImplement(t) {
      return this.parse(t);
    }
    static create(t, r, i) {
      return new e({
        args: t || fn.create([]).rest(ua.create()),
        returns: r || ua.create(),
        typeName: Oe.ZodFunction,
        ...qe(i)
      });
    }
  };
  $.ZodFunction = mb;
  var Nu = class extends Ue {
    static {
      n(this, "ZodLazy");
    }
    get schema() {
      return this._def.getter();
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t);
      return this._def.getter()._parse({ data: r.data, path: r.path, parent: r });
    }
  };
  $.ZodLazy = Nu;
  Nu.create = (e, t) => new Nu({
    getter: e,
    typeName: Oe.ZodLazy,
    ...qe(t)
  });
  var Mu = class extends Ue {
    static {
      n(this, "ZodLiteral");
    }
    _parse(t) {
      if (t.data !== this._def.value) {
        let r = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(r, {
          received: r.data,
          code: ue.ZodIssueCode.invalid_literal,
          expected: this._def.value
        }), W.INVALID;
      }
      return { status: "valid", value: t.data };
    }
    get value() {
      return this._def.value;
    }
  };
  $.ZodLiteral = Mu;
  Mu.create = (e, t) => new Mu({
    value: e,
    typeName: Oe.ZodLiteral,
    ...qe(t)
  });
  function HY(e, t) {
    return new Ru({
      values: e,
      typeName: Oe.ZodEnum,
      ...qe(t)
    });
  }
  n(HY, "createZodEnum");
  var Ru = class e extends Ue {
    static {
      n(this, "ZodEnum");
    }
    constructor() {
      super(...arguments), nh.set(this, void 0);
    }
    _parse(t) {
      if (typeof t.data != "string") {
        let r = this._getOrReturnCtx(t), i = this._def.values;
        return (0, W.addIssueToContext)(r, {
          expected: ce.util.joinValues(i),
          received: r.parsedType,
          code: ue.ZodIssueCode.invalid_type
        }), W.INVALID;
      }
      if (db(this, nh, "f") || UY(this, nh, new Set(this._def.values), "f"), !db(this, nh, "f").has(t.data)) {
        let r = this._getOrReturnCtx(t), i = this._def.values;
        return (0, W.addIssueToContext)(r, {
          received: r.data,
          code: ue.ZodIssueCode.invalid_enum_value,
          options: i
        }), W.INVALID;
      }
      return (0, W.OK)(t.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      let t = {};
      for (let r of this._def.values)
        t[r] = r;
      return t;
    }
    get Values() {
      let t = {};
      for (let r of this._def.values)
        t[r] = r;
      return t;
    }
    get Enum() {
      let t = {};
      for (let r of this._def.values)
        t[r] = r;
      return t;
    }
    extract(t, r = this._def) {
      return e.create(t, {
        ...this._def,
        ...r
      });
    }
    exclude(t, r = this._def) {
      return e.create(this.options.filter((i) => !t.includes(i)), {
        ...this._def,
        ...r
      });
    }
  };
  $.ZodEnum = Ru;
  nh = /* @__PURE__ */ new WeakMap();
  Ru.create = HY;
  var Lu = class extends Ue {
    static {
      n(this, "ZodNativeEnum");
    }
    constructor() {
      super(...arguments), ah.set(this, void 0);
    }
    _parse(t) {
      let r = ce.util.getValidEnumValues(this._def.values), i = this._getOrReturnCtx(t);
      if (i.parsedType !== ce.ZodParsedType.string && i.parsedType !== ce.ZodParsedType.number) {
        let s = ce.util.objectValues(r);
        return (0, W.addIssueToContext)(i, {
          expected: ce.util.joinValues(s),
          received: i.parsedType,
          code: ue.ZodIssueCode.invalid_type
        }), W.INVALID;
      }
      if (db(this, ah, "f") || UY(this, ah, new Set(ce.util.getValidEnumValues(this._def.values)), "f"), !db(this, ah, "f").has(t.data)) {
        let s = ce.util.objectValues(r);
        return (0, W.addIssueToContext)(i, {
          received: i.data,
          code: ue.ZodIssueCode.invalid_enum_value,
          options: s
        }), W.INVALID;
      }
      return (0, W.OK)(t.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  $.ZodNativeEnum = Lu;
  ah = /* @__PURE__ */ new WeakMap();
  Lu.create = (e, t) => new Lu({
    values: e,
    typeName: Oe.ZodNativeEnum,
    ...qe(t)
  });
  var lo = class extends Ue {
    static {
      n(this, "ZodPromise");
    }
    unwrap() {
      return this._def.type;
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t);
      if (r.parsedType !== ce.ZodParsedType.promise && r.common.async === !1)
        return (0, W.addIssueToContext)(r, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.promise,
          received: r.parsedType
        }), W.INVALID;
      let i = r.parsedType === ce.ZodParsedType.promise ? r.data : Promise.resolve(r.data);
      return (0, W.OK)(i.then((s) => this._def.type.parseAsync(s, {
        path: r.path,
        errorMap: r.common.contextualErrorMap
      })));
    }
  };
  $.ZodPromise = lo;
  lo.create = (e, t) => new lo({
    type: e,
    typeName: Oe.ZodPromise,
    ...qe(t)
  });
  var Bi = class extends Ue {
    static {
      n(this, "ZodEffects");
    }
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === Oe.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(t) {
      let { status: r, ctx: i } = this._processInputParams(t), s = this._def.effect || null, a = {
        addIssue: /* @__PURE__ */ n((o) => {
          (0, W.addIssueToContext)(i, o), o.fatal ? r.abort() : r.dirty();
        }, "addIssue"),
        get path() {
          return i.path;
        }
      };
      if (a.addIssue = a.addIssue.bind(a), s.type === "preprocess") {
        let o = s.transform(i.data, a);
        if (i.common.async)
          return Promise.resolve(o).then(async (u) => {
            if (r.value === "aborted")
              return W.INVALID;
            let l = await this._def.schema._parseAsync({
              data: u,
              path: i.path,
              parent: i
            });
            return l.status === "aborted" ? W.INVALID : l.status === "dirty" || r.value === "dirty" ? (0, W.DIRTY)(l.value) : l;
          });
        {
          if (r.value === "aborted")
            return W.INVALID;
          let u = this._def.schema._parseSync({
            data: o,
            path: i.path,
            parent: i
          });
          return u.status === "aborted" ? W.INVALID : u.status === "dirty" || r.value === "dirty" ? (0, W.DIRTY)(u.value) : u;
        }
      }
      if (s.type === "refinement") {
        let o = /* @__PURE__ */ n((u) => {
          let l = s.refinement(u, a);
          if (i.common.async)
            return Promise.resolve(l);
          if (l instanceof Promise)
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          return u;
        }, "executeRefinement");
        if (i.common.async === !1) {
          let u = this._def.schema._parseSync({
            data: i.data,
            path: i.path,
            parent: i
          });
          return u.status === "aborted" ? W.INVALID : (u.status === "dirty" && r.dirty(), o(u.value), { status: r.value, value: u.value });
        } else
          return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((u) => u.status === "aborted" ? W.INVALID : (u.
          status === "dirty" && r.dirty(), o(u.value).then(() => ({ status: r.value, value: u.value }))));
      }
      if (s.type === "transform")
        if (i.common.async === !1) {
          let o = this._def.schema._parseSync({
            data: i.data,
            path: i.path,
            parent: i
          });
          if (!(0, W.isValid)(o))
            return o;
          let u = s.transform(o.value, a);
          if (u instanceof Promise)
            throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
          return { status: r.value, value: u };
        } else
          return this._def.schema._parseAsync({ data: i.data, path: i.path, parent: i }).then((o) => (0, W.isValid)(o) ? Promise.resolve(s.transform(
          o.value, a)).then((u) => ({ status: r.value, value: u })) : o);
      ce.util.assertNever(s);
    }
  };
  $.ZodEffects = Bi;
  $.ZodTransformer = Bi;
  Bi.create = (e, t, r) => new Bi({
    schema: e,
    typeName: Oe.ZodEffects,
    effect: t,
    ...qe(r)
  });
  Bi.createWithPreprocess = (e, t, r) => new Bi({
    schema: t,
    effect: { type: "preprocess", transform: e },
    typeName: Oe.ZodEffects,
    ...qe(r)
  });
  var ss = class extends Ue {
    static {
      n(this, "ZodOptional");
    }
    _parse(t) {
      return this._getType(t) === ce.ZodParsedType.undefined ? (0, W.OK)(void 0) : this._def.innerType._parse(t);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  $.ZodOptional = ss;
  ss.create = (e, t) => new ss({
    innerType: e,
    typeName: Oe.ZodOptional,
    ...qe(t)
  });
  var dn = class extends Ue {
    static {
      n(this, "ZodNullable");
    }
    _parse(t) {
      return this._getType(t) === ce.ZodParsedType.null ? (0, W.OK)(null) : this._def.innerType._parse(t);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  $.ZodNullable = dn;
  dn.create = (e, t) => new dn({
    innerType: e,
    typeName: Oe.ZodNullable,
    ...qe(t)
  });
  var ju = class extends Ue {
    static {
      n(this, "ZodDefault");
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t), i = r.data;
      return r.parsedType === ce.ZodParsedType.undefined && (i = this._def.defaultValue()), this._def.innerType._parse({
        data: i,
        path: r.path,
        parent: r
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  $.ZodDefault = ju;
  ju.create = (e, t) => new ju({
    innerType: e,
    typeName: Oe.ZodDefault,
    defaultValue: typeof t.default == "function" ? t.default : () => t.default,
    ...qe(t)
  });
  var qu = class extends Ue {
    static {
      n(this, "ZodCatch");
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t), i = {
        ...r,
        common: {
          ...r.common,
          issues: []
        }
      }, s = this._def.innerType._parse({
        data: i.data,
        path: i.path,
        parent: {
          ...i
        }
      });
      return (0, W.isAsync)(s) ? s.then((a) => ({
        status: "valid",
        value: a.status === "valid" ? a.value : this._def.catchValue({
          get error() {
            return new ue.ZodError(i.common.issues);
          },
          input: i.data
        })
      })) : {
        status: "valid",
        value: s.status === "valid" ? s.value : this._def.catchValue({
          get error() {
            return new ue.ZodError(i.common.issues);
          },
          input: i.data
        })
      };
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  $.ZodCatch = qu;
  qu.create = (e, t) => new qu({
    innerType: e,
    typeName: Oe.ZodCatch,
    catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
    ...qe(t)
  });
  var Hc = class extends Ue {
    static {
      n(this, "ZodNaN");
    }
    _parse(t) {
      if (this._getType(t) !== ce.ZodParsedType.nan) {
        let i = this._getOrReturnCtx(t);
        return (0, W.addIssueToContext)(i, {
          code: ue.ZodIssueCode.invalid_type,
          expected: ce.ZodParsedType.nan,
          received: i.parsedType
        }), W.INVALID;
      }
      return { status: "valid", value: t.data };
    }
  };
  $.ZodNaN = Hc;
  Hc.create = (e) => new Hc({
    typeName: Oe.ZodNaN,
    ...qe(e)
  });
  $.BRAND = Symbol("zod_brand");
  var oh = class extends Ue {
    static {
      n(this, "ZodBranded");
    }
    _parse(t) {
      let { ctx: r } = this._processInputParams(t), i = r.data;
      return this._def.type._parse({
        data: i,
        path: r.path,
        parent: r
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  $.ZodBranded = oh;
  var uh = class e extends Ue {
    static {
      n(this, "ZodPipeline");
    }
    _parse(t) {
      let { status: r, ctx: i } = this._processInputParams(t);
      if (i.common.async)
        return (/* @__PURE__ */ n(async () => {
          let a = await this._def.in._parseAsync({
            data: i.data,
            path: i.path,
            parent: i
          });
          return a.status === "aborted" ? W.INVALID : a.status === "dirty" ? (r.dirty(), (0, W.DIRTY)(a.value)) : this._def.out._parseAsync(
          {
            data: a.value,
            path: i.path,
            parent: i
          });
        }, "handleAsync"))();
      {
        let s = this._def.in._parseSync({
          data: i.data,
          path: i.path,
          parent: i
        });
        return s.status === "aborted" ? W.INVALID : s.status === "dirty" ? (r.dirty(), {
          status: "dirty",
          value: s.value
        }) : this._def.out._parseSync({
          data: s.value,
          path: i.path,
          parent: i
        });
      }
    }
    static create(t, r) {
      return new e({
        in: t,
        out: r,
        typeName: Oe.ZodPipeline
      });
    }
  };
  $.ZodPipeline = uh;
  var Uu = class extends Ue {
    static {
      n(this, "ZodReadonly");
    }
    _parse(t) {
      let r = this._def.innerType._parse(t), i = /* @__PURE__ */ n((s) => ((0, W.isValid)(s) && (s.value = Object.freeze(s.value)), s), "fre\
eze");
      return (0, W.isAsync)(r) ? r.then((s) => i(s)) : i(r);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  $.ZodReadonly = Uu;
  Uu.create = (e, t) => new Uu({
    innerType: e,
    typeName: Oe.ZodReadonly,
    ...qe(t)
  });
  function qY(e, t) {
    let r = typeof e == "function" ? e(t) : typeof e == "string" ? { message: e } : e;
    return typeof r == "string" ? { message: r } : r;
  }
  n(qY, "cleanParams");
  function KY(e, t = {}, r) {
    return e ? uo.create().superRefine((i, s) => {
      var a, o;
      let u = e(i);
      if (u instanceof Promise)
        return u.then((l) => {
          var c, f;
          if (!l) {
            let m = qY(t, i), h = (f = (c = m.fatal) !== null && c !== void 0 ? c : r) !== null && f !== void 0 ? f : !0;
            s.addIssue({ code: "custom", ...m, fatal: h });
          }
        });
      if (!u) {
        let l = qY(t, i), c = (o = (a = l.fatal) !== null && a !== void 0 ? a : r) !== null && o !== void 0 ? o : !0;
        s.addIssue({ code: "custom", ...l, fatal: c });
      }
    }) : uo.create();
  }
  n(KY, "custom");
  $.custom = KY;
  $.late = {
    object: gi.lazycreate
  };
  var Oe;
  (function(e) {
    e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate =
    "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUn\
known", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion =
    "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap",
    e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects =
    "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefaul\
t", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodRe\
adonly";
  })(Oe || ($.ZodFirstPartyTypeKind = Oe = {}));
  var ZZe = /* @__PURE__ */ n((e, t = {
    message: `Input not instance of ${e.name}`
  }) => KY((r) => r instanceof e, t), "instanceOfType");
  $.instanceof = ZZe;
  var zY = oo.create;
  $.string = zY;
  var JY = Au.create;
  $.number = JY;
  var QZe = Hc.create;
  $.nan = QZe;
  var eQe = _u.create;
  $.bigint = eQe;
  var XY = Pu.create;
  $.boolean = XY;
  var tQe = Fu.create;
  $.date = tQe;
  var rQe = Uc.create;
  $.symbol = rQe;
  var iQe = Iu.create;
  $.undefined = iQe;
  var sQe = Ou.create;
  $.null = sQe;
  var nQe = uo.create;
  $.any = nQe;
  var aQe = ua.create;
  $.unknown = aQe;
  var oQe = Is.create;
  $.never = oQe;
  var uQe = $c.create;
  $.void = uQe;
  var lQe = la.create;
  $.array = lQe;
  var cQe = gi.create;
  $.object = cQe;
  var fQe = gi.strictCreate;
  $.strictObject = fQe;
  var dQe = ku.create;
  $.union = dQe;
  var pQe = pb.create;
  $.discriminatedUnion = pQe;
  var hQe = Bu.create;
  $.intersection = hQe;
  var mQe = fn.create;
  $.tuple = mQe;
  var yQe = hb.create;
  $.record = yQe;
  var gQe = Vc.create;
  $.map = gQe;
  var bQe = Wc.create;
  $.set = bQe;
  var DQe = mb.create;
  $.function = DQe;
  var vQe = Nu.create;
  $.lazy = vQe;
  var xQe = Mu.create;
  $.literal = xQe;
  var EQe = Ru.create;
  $.enum = EQe;
  var SQe = Lu.create;
  $.nativeEnum = SQe;
  var TQe = lo.create;
  $.promise = TQe;
  var YY = Bi.create;
  $.effect = YY;
  $.transformer = YY;
  var CQe = ss.create;
  $.optional = CQe;
  var wQe = dn.create;
  $.nullable = wQe;
  var AQe = Bi.createWithPreprocess;
  $.preprocess = AQe;
  var _Qe = uh.create;
  $.pipeline = _Qe;
  var PQe = /* @__PURE__ */ n(() => zY().optional(), "ostring");
  $.ostring = PQe;
  var FQe = /* @__PURE__ */ n(() => JY().optional(), "onumber");
  $.onumber = FQe;
  var IQe = /* @__PURE__ */ n(() => XY().optional(), "oboolean");
  $.oboolean = IQe;
  $.coerce = {
    string: /* @__PURE__ */ n((e) => oo.create({ ...e, coerce: !0 }), "string"),
    number: /* @__PURE__ */ n((e) => Au.create({ ...e, coerce: !0 }), "number"),
    boolean: /* @__PURE__ */ n((e) => Pu.create({
      ...e,
      coerce: !0
    }), "boolean"),
    bigint: /* @__PURE__ */ n((e) => _u.create({ ...e, coerce: !0 }), "bigint"),
    date: /* @__PURE__ */ n((e) => Fu.create({ ...e, coerce: !0 }), "date")
  };
  $.NEVER = W.INVALID;
});

// ../node_modules/zod/lib/external.js
var e4 = E((as) => {
  "use strict";
  var OQe = as && as.__createBinding || (Object.create ? function(e, t, r, i) {
    i === void 0 && (i = r);
    var s = Object.getOwnPropertyDescriptor(t, r);
    (!s || ("get" in s ? !t.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: /* @__PURE__ */ n(function() {
      return t[r];
    }, "get") }), Object.defineProperty(e, i, s);
  } : function(e, t, r, i) {
    i === void 0 && (i = r), e[i] = t[r];
  }), Kc = as && as.__exportStar || function(e, t) {
    for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && OQe(t, e, r);
  };
  Object.defineProperty(as, "__esModule", { value: !0 });
  Kc(lb(), as);
  Kc(GP(), as);
  Kc(MY(), as);
  Kc(ih(), as);
  Kc(GY(), as);
  Kc(ub(), as);
});

// ../node_modules/zod/lib/index.js
var eG = E((bi) => {
  "use strict";
  var ZY = bi && bi.__createBinding || (Object.create ? function(e, t, r, i) {
    i === void 0 && (i = r);
    var s = Object.getOwnPropertyDescriptor(t, r);
    (!s || ("get" in s ? !t.__esModule : s.writable || s.configurable)) && (s = { enumerable: !0, get: /* @__PURE__ */ n(function() {
      return t[r];
    }, "get") }), Object.defineProperty(e, i, s);
  } : function(e, t, r, i) {
    i === void 0 && (i = r), e[i] = t[r];
  }), kQe = bi && bi.__setModuleDefault || (Object.create ? function(e, t) {
    Object.defineProperty(e, "default", { enumerable: !0, value: t });
  } : function(e, t) {
    e.default = t;
  }), BQe = bi && bi.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (e != null) for (var r in e) r !== "default" && Object.prototype.hasOwnProperty.call(e, r) && ZY(t, e, r);
    return kQe(t, e), t;
  }, NQe = bi && bi.__exportStar || function(e, t) {
    for (var r in e) r !== "default" && !Object.prototype.hasOwnProperty.call(t, r) && ZY(t, e, r);
  };
  Object.defineProperty(bi, "__esModule", { value: !0 });
  bi.z = void 0;
  var QY = BQe(e4());
  bi.z = QY;
  NQe(e4(), bi);
  bi.default = QY;
});

// src/cli/index.ts
var UQe = {};
hh(UQe, {
  ANGULAR_JSON_PATH: () => ld,
  AngularJSON: () => Cx,
  CommunityBuilder: () => Pk,
  CoreBuilder: () => Gv,
  CoreWebpackCompilers: () => _k,
  ProjectType: () => om,
  SUPPORTED_ESLINT_EXTENSIONS: () => AY,
  SUPPORTED_RENDERERS: () => xle,
  Settings: () => lh,
  SupportedLanguage: () => Zv,
  _clearGlobalSettings: () => qQe,
  addToDevDependenciesIfNotPresent: () => Fle,
  adjustTemplate: () => kk,
  builderNameToCoreBuilder: () => Sle,
  cliStoriesTargetPath: () => Ok,
  coerceSemver: () => Nle,
  compilerNameToCoreCompiler: () => Ele,
  compoDocPreviewPrefix: () => qce,
  configureEslintPlugin: () => pZe,
  configureFlatConfig: () => PY,
  copyTemplate: () => Ile,
  copyTemplateFiles: () => Ble,
  detect: () => Kle,
  detectBuilder: () => $le,
  detectFrameworkPreset: () => Rk,
  detectLanguage: () => Hle,
  detectPnp: () => Wle,
  externalFrameworks: () => Yv,
  extractEslintInfo: () => dZe,
  findEslintFile: () => _Y,
  frameworkToDefaultBuilder: () => Ole,
  getBabelDependencies: () => Ple,
  getRendererDir: () => ix,
  getVersionSafe: () => kle,
  globalSettings: () => jQe,
  hasStorybookDependencies: () => Mle,
  installableProjectTypes: () => Cle,
  isNxProject: () => sx,
  isStorybookInstantiated: () => Vle,
  normalizeExtends: () => ab,
  promptForCompoDocs: () => Uce,
  readFileAsJson: () => Ale,
  suggestESLintPlugin: () => hZe,
  supportedTemplates: () => Qv,
  unsupportedTemplate: () => ex,
  writeFileAsJson: () => _le
});
module.exports = mh(UQe);

// src/cli/detect.ts
var rd = require("node:fs"), Bk = require("node:path"), Sa = require("storybook/internal/common"), Nk = require("storybook/internal/node-logger");

// ../node_modules/find-up/index.js
var us = We(require("node:path"), 1);

// ../node_modules/locate-path/index.js
var Sb = We(require("node:process"), 1), Tb = We(require("node:path"), 1), Wu = We(require("node:fs"), 1), r4 = require("node:url");

// ../node_modules/yocto-queue/index.js
var xb = class {
  static {
    n(this, "Node");
  }
  value;
  next;
  constructor(t) {
    this.value = t;
  }
}, Yc = class {
  static {
    n(this, "Queue");
  }
  #e;
  #t;
  #r;
  constructor() {
    this.clear();
  }
  enqueue(t) {
    let r = new xb(t);
    this.#e ? (this.#t.next = r, this.#t = r) : (this.#e = r, this.#t = r), this.#r++;
  }
  dequeue() {
    let t = this.#e;
    if (t)
      return this.#e = this.#e.next, this.#r--, t.value;
  }
  peek() {
    if (this.#e)
      return this.#e.value;
  }
  clear() {
    this.#e = void 0, this.#t = void 0, this.#r = 0;
  }
  get size() {
    return this.#r;
  }
  *[Symbol.iterator]() {
    let t = this.#e;
    for (; t; )
      yield t.value, t = t.next;
  }
  *drain() {
    for (; this.#e; )
      yield this.dequeue();
  }
};

// ../node_modules/locate-path/node_modules/p-limit/index.js
function yh(e) {
  if (!((Number.isInteger(e) || e === Number.POSITIVE_INFINITY) && e > 0))
    throw new TypeError("Expected `concurrency` to be a number from 1 and up");
  let t = new Yc(), r = 0, i = /* @__PURE__ */ n(() => {
    r--, t.size > 0 && t.dequeue()();
  }, "next"), s = /* @__PURE__ */ n(async (u, l, c) => {
    r++;
    let f = (async () => u(...c))();
    l(f);
    try {
      await f;
    } catch {
    }
    i();
  }, "run"), a = /* @__PURE__ */ n((u, l, c) => {
    t.enqueue(s.bind(void 0, u, l, c)), (async () => (await Promise.resolve(), r < e && t.size > 0 && t.dequeue()()))();
  }, "enqueue"), o = /* @__PURE__ */ n((u, ...l) => new Promise((c) => {
    a(u, c, l);
  }), "generator");
  return Object.defineProperties(o, {
    activeCount: {
      get: /* @__PURE__ */ n(() => r, "get")
    },
    pendingCount: {
      get: /* @__PURE__ */ n(() => t.size, "get")
    },
    clearQueue: {
      value: /* @__PURE__ */ n(() => {
        t.clear();
      }, "value")
    }
  }), o;
}
n(yh, "pLimit");

// ../node_modules/locate-path/node_modules/p-locate/index.js
var gh = class extends Error {
  static {
    n(this, "EndError");
  }
  constructor(t) {
    super(), this.value = t;
  }
}, lG = /* @__PURE__ */ n(async (e, t) => t(await e), "testElement"), cG = /* @__PURE__ */ n(async (e) => {
  let t = await Promise.all(e);
  if (t[1] === !0)
    throw new gh(t[0]);
  return !1;
}, "finder");
async function Eb(e, t, {
  concurrency: r = Number.POSITIVE_INFINITY,
  preserveOrder: i = !0
} = {}) {
  let s = yh(r), a = [...e].map((u) => [u, s(lG, u, t)]), o = yh(i ? 1 : Number.POSITIVE_INFINITY);
  try {
    await Promise.all(a.map((u) => o(cG, u)));
  } catch (u) {
    if (u instanceof gh)
      return u.value;
    throw u;
  }
}
n(Eb, "pLocate");

// ../node_modules/locate-path/index.js
var i4 = {
  directory: "isDirectory",
  file: "isFile"
};
function s4(e) {
  if (!Object.hasOwnProperty.call(i4, e))
    throw new Error(`Invalid type specified: ${e}`);
}
n(s4, "checkType");
var n4 = /* @__PURE__ */ n((e, t) => t[i4[e]](), "matchType"), a4 = /* @__PURE__ */ n((e) => e instanceof URL ? (0, r4.fileURLToPath)(e) : e,
"toPath");
async function Cb(e, {
  cwd: t = Sb.default.cwd(),
  type: r = "file",
  allowSymlinks: i = !0,
  concurrency: s,
  preserveOrder: a
} = {}) {
  s4(r), t = a4(t);
  let o = i ? Wu.promises.stat : Wu.promises.lstat;
  return Eb(e, async (u) => {
    try {
      let l = await o(Tb.default.resolve(t, u));
      return n4(r, l);
    } catch {
      return !1;
    }
  }, { concurrency: s, preserveOrder: a });
}
n(Cb, "locatePath");
function wb(e, {
  cwd: t = Sb.default.cwd(),
  type: r = "file",
  allowSymlinks: i = !0
} = {}) {
  s4(r), t = a4(t);
  let s = i ? Wu.default.statSync : Wu.default.lstatSync;
  for (let a of e)
    try {
      let o = s(Tb.default.resolve(t, a), {
        throwIfNoEntry: !1
      });
      if (!o)
        continue;
      if (n4(r, o))
        return a;
    } catch {
    }
}
n(wb, "locatePathSync");

// ../node_modules/find-up/node_modules/unicorn-magic/node.js
var o4 = require("node:url");
function Gc(e) {
  return e instanceof URL ? (0, o4.fileURLToPath)(e) : e;
}
n(Gc, "toPath");

// ../node_modules/find-up/node_modules/path-exists/index.js
var u4 = We(require("node:fs"), 1);

// ../node_modules/find-up/index.js
var l4 = Symbol("findUpStop");
async function fG(e, t = {}) {
  let r = us.default.resolve(Gc(t.cwd) ?? ""), { root: i } = us.default.parse(r), s = us.default.resolve(r, Gc(t.stopAt ?? i)), a = t.limit ??
  Number.POSITIVE_INFINITY, o = [e].flat(), u = /* @__PURE__ */ n(async (c) => {
    if (typeof e != "function")
      return Cb(o, c);
    let f = await e(c.cwd);
    return typeof f == "string" ? Cb([f], c) : f;
  }, "runMatcher"), l = [];
  for (; ; ) {
    let c = await u({ ...t, cwd: r });
    if (c === l4 || (c && l.push(us.default.resolve(r, c)), r === s || l.length >= a))
      break;
    r = us.default.dirname(r);
  }
  return l;
}
n(fG, "findUpMultiple");
function dG(e, t = {}) {
  let r = us.default.resolve(Gc(t.cwd) ?? ""), { root: i } = us.default.parse(r), s = us.default.resolve(r, Gc(t.stopAt) ?? i), a = t.limit ??
  Number.POSITIVE_INFINITY, o = [e].flat(), u = /* @__PURE__ */ n((c) => {
    if (typeof e != "function")
      return wb(o, c);
    let f = e(c.cwd);
    return typeof f == "string" ? wb([f], c) : f;
  }, "runMatcher"), l = [];
  for (; ; ) {
    let c = u({ ...t, cwd: r });
    if (c === l4 || (c && l.push(us.default.resolve(r, c)), r === s || l.length >= a))
      break;
    r = us.default.dirname(r);
  }
  return l;
}
n(dG, "findUpMultipleSync");
async function Ab(e, t = {}) {
  return (await fG(e, { ...t, limit: 1 }))[0];
}
n(Ab, "findUp");
function Hu(e, t = {}) {
  return dG(e, { ...t, limit: 1 })[0];
}
n(Hu, "findUpSync");

// src/cli/detect.ts
var Mk = We(j2(), 1), Tl = We(require("semver"), 1);

// src/cli/helpers.ts
var Zr = require("node:fs"), Po = require("node:fs/promises"), Ks = require("node:path"), lm = require("storybook/internal/common"), Fk = require("storybook/internal/node-logger");
var Ik = We(Mh(), 1), td = require("semver");

// ../node_modules/strip-json-comments/index.js
var U2 = Symbol("singleComment"), U6 = Symbol("multiComment"), vee = /* @__PURE__ */ n(() => "", "stripWithoutWhitespace"), xee = /* @__PURE__ */ n(
(e, t, r) => e.slice(t, r).replace(/\S/g, " "), "stripWithWhitespace"), Eee = /* @__PURE__ */ n((e, t) => {
  let r = t - 1, i = 0;
  for (; e[r] === "\\"; )
    r -= 1, i += 1;
  return !!(i % 2);
}, "isEscaped");
function $2(e, { whitespace: t = !0, trailingCommas: r = !1 } = {}) {
  if (typeof e != "string")
    throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof e}\``);
  let i = t ? xee : vee, s = !1, a = !1, o = 0, u = "", l = "", c = -1;
  for (let f = 0; f < e.length; f++) {
    let m = e[f], h = e[f + 1];
    if (!a && m === '"' && (Eee(e, f) || (s = !s)), !s)
      if (!a && m + h === "//")
        u += e.slice(o, f), o = f, a = U2, f++;
      else if (a === U2 && m + h === `\r
`) {
        f++, a = !1, u += i(e, o, f), o = f;
        continue;
      } else if (a === U2 && m === `
`)
        a = !1, u += i(e, o, f), o = f;
      else if (!a && m + h === "/*") {
        u += e.slice(o, f), o = f, a = U6, f++;
        continue;
      } else if (a === U6 && m + h === "*/") {
        f++, a = !1, u += i(e, o, f + 1), o = f + 1;
        continue;
      } else r && !a && (c !== -1 ? m === "}" || m === "]" ? (u += e.slice(o, f), l += i(u, 0, 1) + u.slice(1), u = "", o = f, c = -1) : m !==
      " " && m !== "	" && m !== "\r" && m !== `
` && (u += e.slice(o, f), o = f, c = -1) : m === "," && (l += u + e.slice(o, f), u = "", o = f, c = f));
  }
  return l + u + (a ? i(e.slice(o)) : e.slice(o));
}
n($2, "stripJsonComments");

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var See = process.env.NODE_ENV === "production", V2 = "Invariant failed";
function cf(e, t) {
  if (!e) {
    if (See)
      throw new Error(V2);
    var r = typeof t == "function" ? t() : t, i = r ? "".concat(V2, ": ").concat(r) : V2;
    throw new Error(i);
  }
}
n(cf, "invariant");

// src/cli/dirs.ts
var ed = require("node:path"), um = require("storybook/internal/common"), tx = We(Tk(), 1), rx = We(Ak(), 1);

// src/cli/project_types.ts
var am = require("semver");
function vle(e, t) {
  return (0, am.validRange)(e) ? (0, am.minVersion)(e)?.major === t : !1;
}
n(vle, "eqMajor");
var Yv = [
  { name: "qwik", packageName: "storybook-framework-qwik" },
  {
    name: "solid",
    packageName: "storybook-solidjs-vite",
    frameworks: ["storybook-solidjs-vite"],
    renderer: "storybook-solidjs-vite"
  },
  {
    name: "nuxt",
    packageName: "@storybook-vue/nuxt",
    frameworks: ["@storybook-vue/nuxt"],
    renderer: "@storybook/vue3"
  }
], xle = [
  "react",
  "react-native",
  "vue3",
  "angular",
  "ember",
  "preact",
  "svelte",
  "qwik",
  "solid"
], om = /* @__PURE__ */ ((k) => (k.UNDETECTED = "UNDETECTED", k.UNSUPPORTED = "UNSUPPORTED", k.REACT = "REACT", k.REACT_SCRIPTS = "REACT_SCR\
IPTS", k.REACT_NATIVE = "REACT_NATIVE", k.REACT_NATIVE_WEB = "REACT_NATIVE_WEB", k.REACT_NATIVE_AND_RNW = "REACT_NATIVE_AND_RNW", k.REACT_PROJECT =
"REACT_PROJECT", k.WEBPACK_REACT = "WEBPACK_REACT", k.NEXTJS = "NEXTJS", k.VUE3 = "VUE3", k.NUXT = "NUXT", k.ANGULAR = "ANGULAR", k.EMBER = "\
EMBER", k.WEB_COMPONENTS = "WEB_COMPONENTS", k.HTML = "HTML", k.QWIK = "QWIK", k.PREACT = "PREACT", k.SVELTE = "SVELTE", k.SVELTEKIT = "SVEL\
TEKIT", k.SERVER = "SERVER", k.NX = "NX", k.SOLID = "SOLID", k))(om || {}), Gv = /* @__PURE__ */ ((r) => (r.Webpack5 = "webpack5", r.Vite = "\
vite", r))(Gv || {}), _k = /* @__PURE__ */ ((r) => (r.Babel = "babel", r.SWC = "swc", r))(_k || {}), Pk = /* @__PURE__ */ ((t) => (t.Rsbuild =
"rsbuild", t))(Pk || {}), Ele = {
  "@storybook/addon-webpack5-compiler-babel": "babel",
  "@storybook/addon-webpack5-compiler-swc": "swc"
}, Sle = {
  "@storybook/builder-webpack5": "webpack5",
  "@storybook/builder-vite": "vite"
}, Zv = /* @__PURE__ */ ((r) => (r.JAVASCRIPT = "javascript", r.TYPESCRIPT = "typescript", r))(Zv || {}), Qv = [
  {
    preset: "NUXT",
    dependencies: ["nuxt"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "VUE3",
    dependencies: {
      // This Vue template works with Vue 3
      vue: /* @__PURE__ */ n((e) => e === "next" || vle(e, 3), "vue")
    },
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.some(Boolean) ?? !1, "matcherFunction")
  },
  {
    preset: "EMBER",
    dependencies: ["ember-cli"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "NEXTJS",
    dependencies: ["next"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "QWIK",
    dependencies: ["@builder.io/qwik"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "REACT_PROJECT",
    peerDependencies: ["react"],
    matcherFunction: /* @__PURE__ */ n(({ peerDependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "REACT_NATIVE",
    dependencies: ["react-native", "react-native-scripts"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.some(Boolean) ?? !1, "matcherFunction")
  },
  {
    preset: "REACT_SCRIPTS",
    // For projects using a custom/forked `react-scripts` package.
    files: ["/node_modules/.bin/react-scripts"],
    // For standard CRA projects
    dependencies: ["react-scripts"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e, files: t }) => (e?.every(Boolean) || t?.every(Boolean)) ?? !1, "matcherFunction")
  },
  {
    preset: "ANGULAR",
    dependencies: ["@angular/core"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "WEB_COMPONENTS",
    dependencies: ["lit-element", "lit-html", "lit"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.some(Boolean) ?? !1, "matcherFunction")
  },
  {
    preset: "PREACT",
    dependencies: ["preact"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    // TODO: This only works because it is before the SVELTE template. could be more explicit
    preset: "SVELTEKIT",
    dependencies: ["@sveltejs/kit"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "SVELTE",
    dependencies: ["svelte"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "SOLID",
    dependencies: ["solid-js"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  // DO NOT MOVE ANY TEMPLATES BELOW THIS LINE
  // React is part of every Template, after Storybook is initialized once
  {
    preset: "WEBPACK_REACT",
    dependencies: ["react", "webpack"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "REACT",
    dependencies: ["react"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  }
], ex = {
  preset: "UNSUPPORTED",
  dependencies: {},
  matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.some(Boolean) ?? !1, "matcherFunction")
}, Tle = [
  "UNDETECTED",
  "UNSUPPORTED",
  "NX"
], Cle = Object.values(om).filter((e) => !Tle.includes(e)).map((e) => e.toLowerCase());

// src/cli/dirs.ts
var wle = /* @__PURE__ */ n(async (e, t) => {
  let r = await (0, um.temporaryDirectory)(), s = um.versions[t] || await e.latestVersion(t), a = rx.default.default || rx.default, o = tx.default.
  default || tx.default, u = a(t, s, {
    registry: await e.getRegistryURL()
  });
  return await o({ url: u, dir: r }), (0, ed.join)(r, "package");
}, "resolveUsingBranchInstall");
async function ix(e, t) {
  let r = Yv.find((o) => o.name === t), i = r?.packageName || r?.renderer || `@storybook/${t}`, s = (0, ed.join)(i, "package.json"), a = [];
  try {
    return (0, ed.dirname)(
      require.resolve(s, {
        paths: [process.cwd()]
      })
    );
  } catch (o) {
    cf(o instanceof Error), a.push(o);
  }
  try {
    return await wle(e, i);
  } catch (o) {
    cf(o instanceof Error), a.push(o);
  }
  throw new Error(`Cannot find ${s}, ${a.map((o) => o.stack).join(`

`)}`);
}
n(ix, "getRendererDir");

// src/cli/helpers.ts
function Ale(e, t) {
  let r = (0, Ks.resolve)(e);
  if (!(0, Zr.existsSync)(r))
    return !1;
  let i = (0, Zr.readFileSync)(r, "utf8"), s = t ? $2(i) : i;
  try {
    return JSON.parse(s);
  } catch (a) {
    throw Fk.logger.error(Ik.default.red(`Invalid json in file: ${r}`)), a;
  }
}
n(Ale, "readFileAsJson");
var _le = /* @__PURE__ */ n((e, t) => {
  let r = (0, Ks.resolve)(e);
  return (0, Zr.existsSync)(r) ? ((0, Zr.writeFileSync)(r, `${JSON.stringify(t, null, 2)}
`), !0) : !1;
}, "writeFileAsJson");
async function Ple(e) {
  let t = [], r = "^8.0.0-0", i = e.getDependencyVersion("babel-core");
  if (i) {
    let s = await e.latestVersion(
      "babel-core",
      i
    );
    s && (0, td.satisfies)(s, "^6.0.0") && (r = "^7.0.0");
  } else if (!e.getDependencyVersion("@babel/core")) {
    let s = await e.getVersion("@babel/core");
    t.push(`@babel/core@${s}`);
  }
  if (!e.getDependencyVersion("babel-loader")) {
    let s = await e.getVersion(
      "babel-loader",
      r
    );
    t.push(`babel-loader@${s}`);
  }
  return t;
}
n(Ple, "getBabelDependencies");
function Fle(e, t, r) {
  !e.dependencies?.[t] && !e.devDependencies?.[t] && (e.devDependencies ? e.devDependencies[t] = r : e.devDependencies = {
    [t]: r
  });
}
n(Fle, "addToDevDependenciesIfNotPresent");
function Ile(e, t = ".") {
  let r = (0, Ks.resolve)(e, "template-csf/");
  if (!(0, Zr.existsSync)(r))
    throw new Error("Couldn't find template dir");
  (0, Zr.cpSync)(r, t, { recursive: !0 });
}
n(Ile, "copyTemplate");
var Ole = {
  angular: "webpack5",
  ember: "webpack5",
  "html-vite": "vite",
  nextjs: "webpack5",
  nuxt: "vite",
  "nextjs-vite": "vite",
  "preact-vite": "vite",
  qwik: "vite",
  "react-native-web-vite": "vite",
  "react-vite": "vite",
  "react-webpack5": "webpack5",
  "server-webpack5": "webpack5",
  solid: "vite",
  "svelte-vite": "vite",
  sveltekit: "vite",
  "vue3-vite": "vite",
  "web-components-vite": "vite",
  // Only to pass type checking, will never be used
  "react-rsbuild": "rsbuild",
  "vue3-rsbuild": "rsbuild"
};
async function kle(e, t) {
  try {
    let r = await e.getInstalledVersion(t);
    return r || (r = e.getAllDependencies()[t] ?? ""), (0, td.coerce)(r, { includePrerelease: !0 })?.toString();
  } catch {
  }
}
n(kle, "getVersionSafe");
var Ok = /* @__PURE__ */ n(async () => (0, Zr.existsSync)("./src") ? "./src/stories" : "./stories", "cliStoriesTargetPath");
async function Ble({
  packageManager: e,
  templateLocation: t,
  language: r,
  destination: i,
  commonAssetsDir: s,
  features: a
}) {
  let o = {
    javascript: "js",
    typescript: "ts"
  }, u = /* @__PURE__ */ n(async () => {
    let f = await ix(e, t), m = (0, Ks.join)(f, "template", "cli"), h = (0, Ks.join)(m, o[r]), d = (0, Ks.join)(m, o.javascript), y = (0, Ks.join)(
    m, o.typescript);
    if ((0, Zr.existsSync)(h))
      return h;
    if ((0, Zr.existsSync)(y))
      return y;
    if ((0, Zr.existsSync)(d))
      return d;
    if ((0, Zr.existsSync)(m))
      return m;
    throw new Error(`Unsupported renderer: ${t} (${f})`);
  }, "templatePath"), l = i ?? await Ok(), c = /* @__PURE__ */ n((f) => a.includes("docs") || !f.endsWith(".mdx"), "filter");
  if (s && await (0, Po.cp)(s, l, { recursive: !0, filter: c }), await (0, Po.cp)(await u(), l, { recursive: !0, filter: c }), s && a.includes(
  "docs")) {
    let f = lm.frameworkToRenderer[t] || "react";
    f === "vue3" && (f = "vue"), await kk((0, Ks.join)(l, "Configure.mdx"), { renderer: f });
  }
}
n(Ble, "copyTemplateFiles");
async function kk(e, t) {
  let r = await (0, Po.readFile)(e, { encoding: "utf8" });
  Object.keys(t).forEach((i) => {
    r = r.replaceAll(`{{${i}}}`, `${t[i]}`);
  }), await (0, Po.writeFile)(e, r);
}
n(kk, "adjustTemplate");
async function sx() {
  return Hu("nx.json", { stopAt: (0, lm.getProjectRoot)() });
}
n(sx, "isNxProject");
function Nle(e) {
  let t = (0, td.coerce)(e);
  return cf(t != null, `Could not coerce ${e} into a semver.`), t;
}
n(Nle, "coerceSemver");
function Mle(e) {
  let t = e.getAllDependencies();
  return Object.keys(t).some((r) => r.includes("storybook"));
}
n(Mle, "hasStorybookDependencies");

// src/cli/detect.ts
var Rle = ["vite.config.ts", "vite.config.js", "vite.config.mjs"], Lle = ["webpack.config.js"], jle = /* @__PURE__ */ n((e, t, r) => {
  let i = e.dependencies?.[t] || e.devDependencies?.[t];
  return i && typeof r == "function" ? r(i) : !!i;
}, "hasDependency"), qle = /* @__PURE__ */ n((e, t, r) => {
  let i = e.peerDependencies?.[t];
  return i && typeof r == "function" ? r(i) : !!i;
}, "hasPeerDependency"), Ule = /* @__PURE__ */ n((e, t) => {
  let r = {
    dependencies: [!1],
    peerDependencies: [!1],
    files: [!1]
  }, { preset: i, files: s, dependencies: a, peerDependencies: o, matcherFunction: u } = t, l = [];
  Array.isArray(a) ? l = a.map((f) => [f, void 0]) : typeof a == "object" && (l = Object.entries(a)), l.length > 0 && (r.dependencies = l.map(
    ([f, m]) => jle(e, f, m)
  ));
  let c = [];
  return Array.isArray(o) ? c = o.map((f) => [f, void 0]) : typeof o == "object" && (c = Object.entries(o)), c.length > 0 && (r.peerDependencies =
  c.map(
    ([f, m]) => qle(e, f, m)
  )), Array.isArray(s) && s.length > 0 && (r.files = s.map((f) => (0, rd.existsSync)(f))), u(r) ? i : null;
}, "getFrameworkPreset");
function Rk(e = {}) {
  let t = [...Qv, ex].find((r) => Ule(e, r) !== null);
  return t ? t.preset : "UNDETECTED";
}
n(Rk, "detectFrameworkPreset");
async function $le(e, t) {
  let r = Hu(Rle, { stopAt: (0, Sa.getProjectRoot)() }), i = Hu(Lle, { stopAt: (0, Sa.getProjectRoot)() }), s = e.getAllDependencies();
  if (r || s.vite && s.webpack === void 0)
    return (0, Sa.commandLog)("Detected Vite project. Setting builder to Vite")(), "vite";
  if (i || (s.webpack || s["@nuxt/webpack-builder"]) && s.vite !== void 0)
    return (0, Sa.commandLog)("Detected webpack project. Setting builder to webpack")(), "webpack5";
  switch (t) {
    case "REACT_NATIVE_AND_RNW":
    case "REACT_NATIVE_WEB":
      return "vite";
    case "REACT_SCRIPTS":
    case "ANGULAR":
    case "REACT_NATIVE":
    // technically react native doesn't use webpack, we just want to set something
    case "NEXTJS":
    case "EMBER":
      return "webpack5";
    case "NUXT":
      return "vite";
    default:
      let { builder: a } = await (0, Mk.default)(
        {
          type: "select",
          name: "builder",
          message: `
We were not able to detect the right builder for your project. Please select one:`,
          choices: [
            { title: "Vite", value: "vite" },
            { title: "Webpack 5", value: "webpack5" }
          ]
        },
        {
          onCancel: /* @__PURE__ */ n(() => {
            throw new Sa.HandledError("Canceled by the user");
          }, "onCancel")
        }
      );
      return a;
  }
}
n($le, "detectBuilder");
function Vle(e = (0, Bk.resolve)(process.cwd(), ".storybook")) {
  return (0, rd.existsSync)(e);
}
n(Vle, "isStorybookInstantiated");
async function Wle() {
  return !!Hu([".pnp.js", ".pnp.cjs"]);
}
n(Wle, "detectPnp");
async function Hle(e) {
  let t = "javascript";
  if ((0, rd.existsSync)("jsconfig.json"))
    return t;
  let r = !!e.getAllDependencies().typescript, i = /* @__PURE__ */ n((c) => e.getModulePackageJSON(c)?.version ?? null, "getModulePackageJSO\
NVersion"), s = i("typescript"), a = i("prettier"), o = i(
    "@babel/plugin-transform-typescript"
  ), u = i("@typescript-eslint/parser"), l = i("eslint-plugin-storybook");
  return r && s ? Tl.default.gte(s, "4.9.0") && (!a || Tl.default.gte(a, "2.8.0")) && (!o || Tl.default.gte(o, "7.20.0")) && (!u || Tl.default.
  gte(u, "5.44.0")) && (!l || Tl.default.gte(l, "0.6.8")) ? t = "typescript" : Nk.logger.warn(
    "Detected TypeScript < 4.9 or incompatible tooling, populating with JavaScript examples"
  ) : (0, rd.existsSync)("tsconfig.json") && (t = "typescript"), t;
}
n(Hle, "detectLanguage");
async function Kle(e, t = {}) {
  try {
    if (await sx())
      return "NX";
    if (t.html)
      return "HTML";
    let { packageJson: r } = e.primaryPackageJson;
    return Rk(r);
  } catch {
    return "UNDETECTED";
  }
}
n(Kle, "detect");

// src/cli/angular/helpers.ts
var Al = require("node:fs"), kB = require("node:path"), BB = require("storybook/internal/node-logger"), NB = require("storybook/internal/server-errors");

// ../node_modules/boxen/index.js
var nd = We(require("node:process"), 1);

// ../node_modules/ansi-regex/index.js
function nx({ onlyFirst: e = !1 } = {}) {
  let r = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u00\
9C))",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|");
  return new RegExp(r, e ? void 0 : "g");
}
n(nx, "ansiRegex");

// ../node_modules/strip-ansi/index.js
var zle = nx();
function Fo(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
  return e.replace(zle, "");
}
n(Fo, "stripAnsi");

// ../node_modules/boxen/node_modules/string-width/index.js
var qk = We(ox(), 1), Uk = We(ux(), 1);
function qi(e, t = {}) {
  if (typeof e != "string" || e.length === 0 || (t = {
    ambiguousIsNarrow: !0,
    ...t
  }, e = Fo(e), e.length === 0))
    return 0;
  e = e.replace((0, Uk.default)(), "  ");
  let r = t.ambiguousIsNarrow ? 1 : 2, i = 0;
  for (let s of e) {
    let a = s.codePointAt(0);
    if (a <= 31 || a >= 127 && a <= 159 || a >= 768 && a <= 879)
      continue;
    switch (qk.default.eastAsianWidth(s)) {
      case "F":
      case "W":
        i += 2;
        break;
      case "A":
        i += r;
        break;
      default:
        i += 1;
    }
  }
  return i;
}
n(qi, "stringWidth");

// ../node_modules/boxen/node_modules/chalk/source/vendor/ansi-styles/index.js
var $k = /* @__PURE__ */ n((e = 0) => (t) => `\x1B[${t + e}m`, "wrapAnsi16"), Vk = /* @__PURE__ */ n((e = 0) => (t) => `\x1B[${38 + e};5;${t}\
m`, "wrapAnsi256"), Wk = /* @__PURE__ */ n((e = 0) => (t, r, i) => `\x1B[${38 + e};2;${t};${r};${i}m`, "wrapAnsi16m"), Mt = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, Dat = Object.keys(Mt.modifier), Jle = Object.keys(Mt.color), Xle = Object.keys(Mt.bgColor), vat = [...Jle, ...Xle];
function Yle() {
  let e = /* @__PURE__ */ new Map();
  for (let [t, r] of Object.entries(Mt)) {
    for (let [i, s] of Object.entries(r))
      Mt[i] = {
        open: `\x1B[${s[0]}m`,
        close: `\x1B[${s[1]}m`
      }, r[i] = Mt[i], e.set(s[0], s[1]);
    Object.defineProperty(Mt, t, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(Mt, "codes", {
    value: e,
    enumerable: !1
  }), Mt.color.close = "\x1B[39m", Mt.bgColor.close = "\x1B[49m", Mt.color.ansi = $k(), Mt.color.ansi256 = Vk(), Mt.color.ansi16m = Wk(), Mt.
  bgColor.ansi = $k(10), Mt.bgColor.ansi256 = Vk(10), Mt.bgColor.ansi16m = Wk(10), Object.defineProperties(Mt, {
    rgbToAnsi256: {
      value(t, r, i) {
        return t === r && r === i ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 *
        Math.round(r / 255 * 5) + Math.round(i / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(t) {
        let r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(t.toString(16));
        if (!r)
          return [0, 0, 0];
        let [i] = r;
        i.length === 3 && (i = [...i].map((a) => a + a).join(""));
        let s = Number.parseInt(i, 16);
        return [
          /* eslint-disable no-bitwise */
          s >> 16 & 255,
          s >> 8 & 255,
          s & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: /* @__PURE__ */ n((t) => Mt.rgbToAnsi256(...Mt.hexToRgb(t)), "value"),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(t) {
        if (t < 8)
          return 30 + t;
        if (t < 16)
          return 90 + (t - 8);
        let r, i, s;
        if (t >= 232)
          r = ((t - 232) * 10 + 8) / 255, i = r, s = r;
        else {
          t -= 16;
          let u = t % 36;
          r = Math.floor(t / 36) / 5, i = Math.floor(u / 6) / 5, s = u % 6 / 5;
        }
        let a = Math.max(r, i, s) * 2;
        if (a === 0)
          return 30;
        let o = 30 + (Math.round(s) << 2 | Math.round(i) << 1 | Math.round(r));
        return a === 2 && (o += 60), o;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: /* @__PURE__ */ n((t, r, i) => Mt.ansi256ToAnsi(Mt.rgbToAnsi256(t, r, i)), "value"),
      enumerable: !1
    },
    hexToAnsi: {
      value: /* @__PURE__ */ n((t) => Mt.ansi256ToAnsi(Mt.hexToAnsi256(t)), "value"),
      enumerable: !1
    }
  }), Mt;
}
n(Yle, "assembleStyles");
var Gle = Yle(), ds = Gle;

// ../node_modules/boxen/node_modules/chalk/source/vendor/supports-color/index.js
var fm = We(require("node:process"), 1), Kk = We(require("node:os"), 1), lx = We(require("node:tty"), 1);
function Ui(e, t = globalThis.Deno ? globalThis.Deno.args : fm.default.argv) {
  let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", i = t.indexOf(r + e), s = t.indexOf("--");
  return i !== -1 && (s === -1 || i < s);
}
n(Ui, "hasFlag");
var { env: Rt } = fm.default, cm;
Ui("no-color") || Ui("no-colors") || Ui("color=false") || Ui("color=never") ? cm = 0 : (Ui("color") || Ui("colors") || Ui("color=true") || Ui(
"color=always")) && (cm = 1);
function Zle() {
  if ("FORCE_COLOR" in Rt)
    return Rt.FORCE_COLOR === "true" ? 1 : Rt.FORCE_COLOR === "false" ? 0 : Rt.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(Rt.FORCE_COLOR,
    10), 3);
}
n(Zle, "envForceColor");
function Qle(e) {
  return e === 0 ? !1 : {
    level: e,
    hasBasic: !0,
    has256: e >= 2,
    has16m: e >= 3
  };
}
n(Qle, "translateLevel");
function ece(e, { streamIsTTY: t, sniffFlags: r = !0 } = {}) {
  let i = Zle();
  i !== void 0 && (cm = i);
  let s = r ? cm : i;
  if (s === 0)
    return 0;
  if (r) {
    if (Ui("color=16m") || Ui("color=full") || Ui("color=truecolor"))
      return 3;
    if (Ui("color=256"))
      return 2;
  }
  if ("TF_BUILD" in Rt && "AGENT_NAME" in Rt)
    return 1;
  if (e && !t && s === void 0)
    return 0;
  let a = s || 0;
  if (Rt.TERM === "dumb")
    return a;
  if (fm.default.platform === "win32") {
    let o = Kk.default.release().split(".");
    return Number(o[0]) >= 10 && Number(o[2]) >= 10586 ? Number(o[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in Rt)
    return ["GITHUB_ACTIONS", "GITEA_ACTIONS", "CIRCLECI"].some((o) => o in Rt) ? 3 : ["TRAVIS", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRON\
E"].some((o) => o in Rt) || Rt.CI_NAME === "codeship" ? 1 : a;
  if ("TEAMCITY_VERSION" in Rt)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Rt.TEAMCITY_VERSION) ? 1 : 0;
  if (Rt.COLORTERM === "truecolor" || Rt.TERM === "xterm-kitty" || Rt.TERM === "xterm-ghostty" || Rt.TERM === "wezterm")
    return 3;
  if ("TERM_PROGRAM" in Rt) {
    let o = Number.parseInt((Rt.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (Rt.TERM_PROGRAM) {
      case "iTerm.app":
        return o >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(Rt.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Rt.TERM) || "COLORTERM" in Rt ?
  1 : a;
}
n(ece, "_supportsColor");
function Hk(e, t = {}) {
  let r = ece(e, {
    streamIsTTY: e && e.isTTY,
    ...t
  });
  return Qle(r);
}
n(Hk, "createSupportsColor");
var tce = {
  stdout: Hk({ isTTY: lx.default.isatty(1) }),
  stderr: Hk({ isTTY: lx.default.isatty(2) })
}, zk = tce;

// ../node_modules/boxen/node_modules/chalk/source/utilities.js
function Jk(e, t, r) {
  let i = e.indexOf(t);
  if (i === -1)
    return e;
  let s = t.length, a = 0, o = "";
  do
    o += e.slice(a, i) + t + r, a = i + s, i = e.indexOf(t, a);
  while (i !== -1);
  return o += e.slice(a), o;
}
n(Jk, "stringReplaceAll");
function Xk(e, t, r, i) {
  let s = 0, a = "";
  do {
    let o = e[i - 1] === "\r";
    a += e.slice(s, o ? i - 1 : i) + t + (o ? `\r
` : `
`) + r, s = i + 1, i = e.indexOf(`
`, s);
  } while (i !== -1);
  return a += e.slice(s), a;
}
n(Xk, "stringEncaseCRLFWithFirstIndex");

// ../node_modules/boxen/node_modules/chalk/source/index.js
var { stdout: Yk, stderr: Gk } = zk, cx = Symbol("GENERATOR"), Cl = Symbol("STYLER"), id = Symbol("IS_EMPTY"), Zk = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], wl = /* @__PURE__ */ Object.create(null), rce = /* @__PURE__ */ n((e, t = {}) => {
  if (t.level && !(Number.isInteger(t.level) && t.level >= 0 && t.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  let r = Yk ? Yk.level : 0;
  e.level = t.level === void 0 ? r : t.level;
}, "applyOptions");
var ice = /* @__PURE__ */ n((e) => {
  let t = /* @__PURE__ */ n((...r) => r.join(" "), "chalk");
  return rce(t, e), Object.setPrototypeOf(t, sd.prototype), t;
}, "chalkFactory");
function sd(e) {
  return ice(e);
}
n(sd, "createChalk");
Object.setPrototypeOf(sd.prototype, Function.prototype);
for (let [e, t] of Object.entries(ds))
  wl[e] = {
    get() {
      let r = dm(this, dx(t.open, t.close, this[Cl]), this[id]);
      return Object.defineProperty(this, e, { value: r }), r;
    }
  };
wl.visible = {
  get() {
    let e = dm(this, this[Cl], !0);
    return Object.defineProperty(this, "visible", { value: e }), e;
  }
};
var fx = /* @__PURE__ */ n((e, t, r, ...i) => e === "rgb" ? t === "ansi16m" ? ds[r].ansi16m(...i) : t === "ansi256" ? ds[r].ansi256(ds.rgbToAnsi256(
...i)) : ds[r].ansi(ds.rgbToAnsi(...i)) : e === "hex" ? fx("rgb", t, r, ...ds.hexToRgb(...i)) : ds[r][e](...i), "getModelAnsi"), sce = ["rgb",
"hex", "ansi256"];
for (let e of sce) {
  wl[e] = {
    get() {
      let { level: r } = this;
      return function(...i) {
        let s = dx(fx(e, Zk[r], "color", ...i), ds.color.close, this[Cl]);
        return dm(this, s, this[id]);
      };
    }
  };
  let t = "bg" + e[0].toUpperCase() + e.slice(1);
  wl[t] = {
    get() {
      let { level: r } = this;
      return function(...i) {
        let s = dx(fx(e, Zk[r], "bgColor", ...i), ds.bgColor.close, this[Cl]);
        return dm(this, s, this[id]);
      };
    }
  };
}
var nce = Object.defineProperties(() => {
}, {
  ...wl,
  level: {
    enumerable: !0,
    get() {
      return this[cx].level;
    },
    set(e) {
      this[cx].level = e;
    }
  }
}), dx = /* @__PURE__ */ n((e, t, r) => {
  let i, s;
  return r === void 0 ? (i = e, s = t) : (i = r.openAll + e, s = t + r.closeAll), {
    open: e,
    close: t,
    openAll: i,
    closeAll: s,
    parent: r
  };
}, "createStyler"), dm = /* @__PURE__ */ n((e, t, r) => {
  let i = /* @__PURE__ */ n((...s) => ace(i, s.length === 1 ? "" + s[0] : s.join(" ")), "builder");
  return Object.setPrototypeOf(i, nce), i[cx] = e, i[Cl] = t, i[id] = r, i;
}, "createBuilder"), ace = /* @__PURE__ */ n((e, t) => {
  if (e.level <= 0 || !t)
    return e[id] ? "" : t;
  let r = e[Cl];
  if (r === void 0)
    return t;
  let { openAll: i, closeAll: s } = r;
  if (t.includes("\x1B"))
    for (; r !== void 0; )
      t = Jk(t, r.close, r.open), r = r.parent;
  let a = t.indexOf(`
`);
  return a !== -1 && (t = Xk(t, s, i, a)), i + t + s;
}, "applyStyle");
Object.defineProperties(sd.prototype, wl);
var oce = sd(), Fat = sd({ level: Gk ? Gk.level : 0 });
var Io = oce;

// ../node_modules/boxen/node_modules/widest-line/index.js
function pm(e) {
  let t = 0;
  for (let r of e.split(`
`))
    t = Math.max(t, qi(r));
  return t;
}
n(pm, "widestLine");

// ../node_modules/boxen/index.js
var FB = We(hx(), 1);

// ../node_modules/boxen/node_modules/camelcase/index.js
var lce = /[\p{Lu}]/u, cce = /[\p{Ll}]/u, tB = /^[\p{Lu}](?![\p{Lu}])/gu, sB = /([\p{Alpha}\p{N}_]|$)/u, mx = /[_.\- ]+/, fce = new RegExp("\
^" + mx.source), rB = new RegExp(mx.source + sB.source, "gu"), iB = new RegExp("\\d+" + sB.source, "gu"), dce = /* @__PURE__ */ n((e, t, r, i) => {
  let s = !1, a = !1, o = !1, u = !1;
  for (let l = 0; l < e.length; l++) {
    let c = e[l];
    u = l > 2 ? e[l - 3] === "-" : !0, s && lce.test(c) ? (e = e.slice(0, l) + "-" + e.slice(l), s = !1, o = a, a = !0, l++) : a && o && cce.
    test(c) && (!u || i) ? (e = e.slice(0, l - 1) + "-" + e.slice(l - 1), o = a, a = !1, s = !0) : (s = t(c) === c && r(c) !== c, o = a, a =
    r(c) === c && t(c) !== c);
  }
  return e;
}, "preserveCamelCase"), pce = /* @__PURE__ */ n((e, t) => (tB.lastIndex = 0, e.replace(tB, (r) => t(r))), "preserveConsecutiveUppercase"), hce = /* @__PURE__ */ n(
(e, t) => (rB.lastIndex = 0, iB.lastIndex = 0, e.replace(rB, (r, i) => t(i)).replace(iB, (r) => t(r))), "postProcess");
function yx(e, t) {
  if (!(typeof e == "string" || Array.isArray(e)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (t = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...t
  }, Array.isArray(e) ? e = e.map((a) => a.trim()).filter((a) => a.length).join("-") : e = e.trim(), e.length === 0)
    return "";
  let r = t.locale === !1 ? (a) => a.toLowerCase() : (a) => a.toLocaleLowerCase(t.locale), i = t.locale === !1 ? (a) => a.toUpperCase() : (a) => a.
  toLocaleUpperCase(t.locale);
  return e.length === 1 ? mx.test(e) ? "" : t.pascalCase ? i(e) : r(e) : (e !== r(e) && (e = dce(e, r, i, t.preserveConsecutiveUppercase)), e =
  e.replace(fce, ""), e = t.preserveConsecutiveUppercase ? pce(e, r) : r(e), t.pascalCase && (e = i(e.charAt(0)) + e.slice(1)), hce(e, i));
}
n(yx, "camelCase");

// ../node_modules/boxen/index.js
var Ex = We(yB(), 1);

// ../node_modules/wrap-ansi/node_modules/string-width/index.js
var gB = We(ox(), 1), bB = We(ux(), 1);
function ko(e, t = {}) {
  if (typeof e != "string" || e.length === 0 || (t = {
    ambiguousIsNarrow: !0,
    ...t
  }, e = Fo(e), e.length === 0))
    return 0;
  e = e.replace((0, bB.default)(), "  ");
  let r = t.ambiguousIsNarrow ? 1 : 2, i = 0;
  for (let s of e) {
    let a = s.codePointAt(0);
    if (a <= 31 || a >= 127 && a <= 159 || a >= 768 && a <= 879)
      continue;
    switch (gB.default.eastAsianWidth(s)) {
      case "F":
      case "W":
        i += 2;
        break;
      case "A":
        i += r;
        break;
      default:
        i += 1;
    }
  }
  return i;
}
n(ko, "stringWidth");

// ../node_modules/wrap-ansi/node_modules/ansi-styles/index.js
var DB = /* @__PURE__ */ n((e = 0) => (t) => `\x1B[${t + e}m`, "wrapAnsi16"), vB = /* @__PURE__ */ n((e = 0) => (t) => `\x1B[${38 + e};5;${t}\
m`, "wrapAnsi256"), xB = /* @__PURE__ */ n((e = 0) => (t, r, i) => `\x1B[${38 + e};2;${t};${r};${i}m`, "wrapAnsi16m"), Lt = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, Zat = Object.keys(Lt.modifier), Ece = Object.keys(Lt.color), Sce = Object.keys(Lt.bgColor), Qat = [...Ece, ...Sce];
function Tce() {
  let e = /* @__PURE__ */ new Map();
  for (let [t, r] of Object.entries(Lt)) {
    for (let [i, s] of Object.entries(r))
      Lt[i] = {
        open: `\x1B[${s[0]}m`,
        close: `\x1B[${s[1]}m`
      }, r[i] = Lt[i], e.set(s[0], s[1]);
    Object.defineProperty(Lt, t, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(Lt, "codes", {
    value: e,
    enumerable: !1
  }), Lt.color.close = "\x1B[39m", Lt.bgColor.close = "\x1B[49m", Lt.color.ansi = DB(), Lt.color.ansi256 = vB(), Lt.color.ansi16m = xB(), Lt.
  bgColor.ansi = DB(10), Lt.bgColor.ansi256 = vB(10), Lt.bgColor.ansi16m = xB(10), Object.defineProperties(Lt, {
    rgbToAnsi256: {
      value: /* @__PURE__ */ n((t, r, i) => t === r && r === i ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 *
      Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(i / 255 * 5), "value"),
      enumerable: !1
    },
    hexToRgb: {
      value: /* @__PURE__ */ n((t) => {
        let r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(t.toString(16));
        if (!r)
          return [0, 0, 0];
        let [i] = r;
        i.length === 3 && (i = [...i].map((a) => a + a).join(""));
        let s = Number.parseInt(i, 16);
        return [
          /* eslint-disable no-bitwise */
          s >> 16 & 255,
          s >> 8 & 255,
          s & 255
          /* eslint-enable no-bitwise */
        ];
      }, "value"),
      enumerable: !1
    },
    hexToAnsi256: {
      value: /* @__PURE__ */ n((t) => Lt.rgbToAnsi256(...Lt.hexToRgb(t)), "value"),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value: /* @__PURE__ */ n((t) => {
        if (t < 8)
          return 30 + t;
        if (t < 16)
          return 90 + (t - 8);
        let r, i, s;
        if (t >= 232)
          r = ((t - 232) * 10 + 8) / 255, i = r, s = r;
        else {
          t -= 16;
          let u = t % 36;
          r = Math.floor(t / 36) / 5, i = Math.floor(u / 6) / 5, s = u % 6 / 5;
        }
        let a = Math.max(r, i, s) * 2;
        if (a === 0)
          return 30;
        let o = 30 + (Math.round(s) << 2 | Math.round(i) << 1 | Math.round(r));
        return a === 2 && (o += 60), o;
      }, "value"),
      enumerable: !1
    },
    rgbToAnsi: {
      value: /* @__PURE__ */ n((t, r, i) => Lt.ansi256ToAnsi(Lt.rgbToAnsi256(t, r, i)), "value"),
      enumerable: !1
    },
    hexToAnsi: {
      value: /* @__PURE__ */ n((t) => Lt.ansi256ToAnsi(Lt.hexToAnsi256(t)), "value"),
      enumerable: !1
    }
  }), Lt;
}
n(Tce, "assembleStyles");
var Cce = Tce(), EB = Cce;

// ../node_modules/wrap-ansi/index.js
var hm = /* @__PURE__ */ new Set([
  "\x1B",
  "\x9B"
]), wce = 39, vx = "\x07", CB = "[", Ace = "]", wB = "m", xx = `${Ace}8;;`, SB = /* @__PURE__ */ n((e) => `${hm.values().next().value}${CB}${e}${wB}`,
"wrapAnsiCode"), TB = /* @__PURE__ */ n((e) => `${hm.values().next().value}${xx}${e}${vx}`, "wrapAnsiHyperlink"), _ce = /* @__PURE__ */ n((e) => e.
split(" ").map((t) => ko(t)), "wordLengths"), Dx = /* @__PURE__ */ n((e, t, r) => {
  let i = [...t], s = !1, a = !1, o = ko(Fo(e[e.length - 1]));
  for (let [u, l] of i.entries()) {
    let c = ko(l);
    if (o + c <= r ? e[e.length - 1] += l : (e.push(l), o = 0), hm.has(l) && (s = !0, a = i.slice(u + 1).join("").startsWith(xx)), s) {
      a ? l === vx && (s = !1, a = !1) : l === wB && (s = !1);
      continue;
    }
    o += c, o === r && u < i.length - 1 && (e.push(""), o = 0);
  }
  !o && e[e.length - 1].length > 0 && e.length > 1 && (e[e.length - 2] += e.pop());
}, "wrapWord"), Pce = /* @__PURE__ */ n((e) => {
  let t = e.split(" "), r = t.length;
  for (; r > 0 && !(ko(t[r - 1]) > 0); )
    r--;
  return r === t.length ? e : t.slice(0, r).join(" ") + t.slice(r).join("");
}, "stringVisibleTrimSpacesRight"), Fce = /* @__PURE__ */ n((e, t, r = {}) => {
  if (r.trim !== !1 && e.trim() === "")
    return "";
  let i = "", s, a, o = _ce(e), u = [""];
  for (let [c, f] of e.split(" ").entries()) {
    r.trim !== !1 && (u[u.length - 1] = u[u.length - 1].trimStart());
    let m = ko(u[u.length - 1]);
    if (c !== 0 && (m >= t && (r.wordWrap === !1 || r.trim === !1) && (u.push(""), m = 0), (m > 0 || r.trim === !1) && (u[u.length - 1] += "\
 ", m++)), r.hard && o[c] > t) {
      let h = t - m, d = 1 + Math.floor((o[c] - h - 1) / t);
      Math.floor((o[c] - 1) / t) < d && u.push(""), Dx(u, f, t);
      continue;
    }
    if (m + o[c] > t && m > 0 && o[c] > 0) {
      if (r.wordWrap === !1 && m < t) {
        Dx(u, f, t);
        continue;
      }
      u.push("");
    }
    if (m + o[c] > t && r.wordWrap === !1) {
      Dx(u, f, t);
      continue;
    }
    u[u.length - 1] += f;
  }
  r.trim !== !1 && (u = u.map((c) => Pce(c)));
  let l = [...u.join(`
`)];
  for (let [c, f] of l.entries()) {
    if (i += f, hm.has(f)) {
      let { groups: h } = new RegExp(`(?:\\${CB}(?<code>\\d+)m|\\${xx}(?<uri>.*)${vx})`).exec(l.slice(c).join("")) || { groups: {} };
      if (h.code !== void 0) {
        let d = Number.parseFloat(h.code);
        s = d === wce ? void 0 : d;
      } else h.uri !== void 0 && (a = h.uri.length === 0 ? void 0 : h.uri);
    }
    let m = EB.codes.get(Number(s));
    l[c + 1] === `
` ? (a && (i += TB("")), s && m && (i += SB(m))) : f === `
` && (s && m && (i += SB(s)), a && (i += TB(a)));
  }
  return i;
}, "exec");
function mm(e, t, r) {
  return String(e).normalize().replace(/\r\n/g, `
`).split(`
`).map((i) => Fce(i, t, r)).join(`
`);
}
n(mm, "wrapAnsi");

// ../node_modules/boxen/index.js
var jce = We(hx(), 1);
var Ca = `
`, Qr = " ", ad = "none", IB = /* @__PURE__ */ n(() => {
  let { env: e, stdout: t, stderr: r } = nd.default;
  return t?.columns ? t.columns : r?.columns ? r.columns : e.COLUMNS ? Number.parseInt(e.COLUMNS, 10) : 80;
}, "terminalColumns"), AB = /* @__PURE__ */ n((e) => typeof e == "number" ? {
  top: e,
  right: e * 3,
  bottom: e,
  left: e * 3
} : {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  ...e
}, "getObject"), od = /* @__PURE__ */ n((e) => e === ad ? 0 : 2, "getBorderWidth"), Ice = /* @__PURE__ */ n((e) => {
  let t = [
    "topLeft",
    "topRight",
    "bottomRight",
    "bottomLeft",
    "left",
    "right",
    "top",
    "bottom"
  ], r;
  if (e === ad) {
    e = {};
    for (let i of t)
      e[i] = "";
  }
  if (typeof e == "string") {
    if (r = FB.default[e], !r)
      throw new TypeError(`Invalid border style: ${e}`);
  } else {
    typeof e?.vertical == "string" && (e.left = e.vertical, e.right = e.vertical), typeof e?.horizontal == "string" && (e.top = e.horizontal,
    e.bottom = e.horizontal);
    for (let i of t)
      if (e[i] === null || typeof e[i] != "string")
        throw new TypeError(`Invalid border style: ${i}`);
    r = e;
  }
  return r;
}, "getBorderChars"), Oce = /* @__PURE__ */ n((e, t, r) => {
  let i = "", s = qi(e);
  switch (r) {
    case "left": {
      i = e + t.slice(s);
      break;
    }
    case "right": {
      i = t.slice(s) + e;
      break;
    }
    default: {
      t = t.slice(s), t.length % 2 === 1 ? (t = t.slice(Math.floor(t.length / 2)), i = t.slice(1) + e + t) : (t = t.slice(t.length / 2), i =
      t + e + t);
      break;
    }
  }
  return i;
}, "makeTitle"), kce = /* @__PURE__ */ n((e, { padding: t, width: r, textAlignment: i, height: s }) => {
  e = (0, Ex.default)(e, { align: i });
  let a = e.split(Ca), o = pm(e), u = r - t.left - t.right;
  if (o > u) {
    let f = [];
    for (let m of a) {
      let h = mm(m, u, { hard: !0 }), y = (0, Ex.default)(h, { align: i }).split(`
`), p = Math.max(...y.map((g) => qi(g)));
      for (let g of y) {
        let b;
        switch (i) {
          case "center": {
            b = Qr.repeat((u - p) / 2) + g;
            break;
          }
          case "right": {
            b = Qr.repeat(u - p) + g;
            break;
          }
          default: {
            b = g;
            break;
          }
        }
        f.push(b);
      }
    }
    a = f;
  }
  i === "center" && o < u ? a = a.map((f) => Qr.repeat((u - o) / 2) + f) : i === "right" && o < u && (a = a.map((f) => Qr.repeat(u - o) + f));
  let l = Qr.repeat(t.left), c = Qr.repeat(t.right);
  return a = a.map((f) => l + f + c), a = a.map((f) => {
    if (r - qi(f) > 0)
      switch (i) {
        case "center":
          return f + Qr.repeat(r - qi(f));
        case "right":
          return f + Qr.repeat(r - qi(f));
        default:
          return f + Qr.repeat(r - qi(f));
      }
    return f;
  }), t.top > 0 && (a = [...Array.from({ length: t.top }).fill(Qr.repeat(r)), ...a]), t.bottom > 0 && (a = [...a, ...Array.from({ length: t.
  bottom }).fill(Qr.repeat(r))]), s && a.length > s ? a = a.slice(0, s) : s && a.length < s && (a = [...a, ...Array.from({ length: s - a.length }).
  fill(Qr.repeat(r))]), a.join(Ca);
}, "makeContentText"), Bce = /* @__PURE__ */ n((e, t, r) => {
  let i = /* @__PURE__ */ n((f) => {
    let m = r.borderColor ? Rce(r.borderColor)(f) : f;
    return r.dimBorder ? Io.dim(m) : m;
  }, "colorizeBorder"), s = /* @__PURE__ */ n((f) => r.backgroundColor ? Lce(r.backgroundColor)(f) : f, "colorizeContent"), a = Ice(r.borderStyle),
  o = IB(), u = Qr.repeat(r.margin.left);
  if (r.float === "center") {
    let f = Math.max((o - t - od(r.borderStyle)) / 2, 0);
    u = Qr.repeat(f);
  } else if (r.float === "right") {
    let f = Math.max(o - t - r.margin.right - od(r.borderStyle), 0);
    u = Qr.repeat(f);
  }
  let l = "";
  r.margin.top && (l += Ca.repeat(r.margin.top)), (r.borderStyle !== ad || r.title) && (l += i(u + a.topLeft + (r.title ? Oce(r.title, a.top.
  repeat(t), r.titleAlignment) : a.top.repeat(t)) + a.topRight) + Ca);
  let c = e.split(Ca);
  return l += c.map((f) => u + i(a.left) + s(f) + i(a.right)).join(Ca), r.borderStyle !== ad && (l += Ca + i(u + a.bottomLeft + a.bottom.repeat(
  t) + a.bottomRight)), r.margin.bottom && (l += Ca.repeat(r.margin.bottom)), l;
}, "boxContent"), Nce = /* @__PURE__ */ n((e) => {
  if (e.fullscreen && nd.default?.stdout) {
    let t = [nd.default.stdout.columns, nd.default.stdout.rows];
    typeof e.fullscreen == "function" && (t = e.fullscreen(...t)), e.width || (e.width = t[0]), e.height || (e.height = t[1]);
  }
  return e.width && (e.width = Math.max(1, e.width - od(e.borderStyle))), e.height && (e.height = Math.max(1, e.height - od(e.borderStyle))),
  e;
}, "sanitizeOptions"), _B = /* @__PURE__ */ n((e, t) => t === ad ? e : ` ${e} `, "formatTitle"), Mce = /* @__PURE__ */ n((e, t) => {
  t = Nce(t);
  let r = t.width !== void 0, i = IB(), s = od(t.borderStyle), a = i - t.margin.left - t.margin.right - s, o = pm(mm(e, i - s, { hard: !0, trim: !1 })) +
  t.padding.left + t.padding.right;
  if (t.title && r ? (t.title = t.title.slice(0, Math.max(0, t.width - 2)), t.title && (t.title = _B(t.title, t.borderStyle))) : t.title && (t.
  title = t.title.slice(0, Math.max(0, a - 2)), t.title && (t.title = _B(t.title, t.borderStyle), qi(t.title) > o && (t.width = qi(t.title)))),
  t.width = t.width ? t.width : o, !r) {
    if (t.margin.left && t.margin.right && t.width > a) {
      let l = (i - t.width - s) / (t.margin.left + t.margin.right);
      t.margin.left = Math.max(0, Math.floor(t.margin.left * l)), t.margin.right = Math.max(0, Math.floor(t.margin.right * l));
    }
    t.width = Math.min(t.width, i - s - t.margin.left - t.margin.right);
  }
  return t.width - (t.padding.left + t.padding.right) <= 0 && (t.padding.left = 0, t.padding.right = 0), t.height && t.height - (t.padding.top +
  t.padding.bottom) <= 0 && (t.padding.top = 0, t.padding.bottom = 0), t;
}, "determineDimensions"), Sx = /* @__PURE__ */ n((e) => e.match(/^#(?:[0-f]{3}){1,2}$/i), "isHex"), PB = /* @__PURE__ */ n((e) => typeof e ==
"string" && (Io[e] ?? Sx(e)), "isColorValid"), Rce = /* @__PURE__ */ n((e) => Sx(e) ? Io.hex(e) : Io[e], "getColorFn"), Lce = /* @__PURE__ */ n(
(e) => Sx(e) ? Io.bgHex(e) : Io[yx(["bg", e])], "getBGColorFn");
function Tx(e, t) {
  if (t = {
    padding: 0,
    borderStyle: "single",
    dimBorder: !1,
    textAlignment: "left",
    float: "left",
    titleAlignment: "left",
    ...t
  }, t.align && (t.textAlignment = t.align), t.borderColor && !PB(t.borderColor))
    throw new Error(`${t.borderColor} is not a valid borderColor`);
  if (t.backgroundColor && !PB(t.backgroundColor))
    throw new Error(`${t.backgroundColor} is not a valid backgroundColor`);
  return t.padding = AB(t.padding), t.margin = AB(t.margin), t = Mce(e, t), e = kce(e, t), Bce(e, t.width, t);
}
n(Tx, "boxen");

// src/cli/angular/helpers.ts
var wx = We(j2(), 1), Ax = We(ym(), 1);
var ld = "angular.json", qce = Ax.dedent`
  import { setCompodocJson } from "@storybook/addon-docs/angular";
  import docJson from "../documentation.json";
  setCompodocJson(docJson);
`.trimStart(), Uce = /* @__PURE__ */ n(async () => {
  BB.logger.plain(
    // Create a text which explains the user why compodoc is necessary
    Tx(
      Ax.dedent`
      Compodoc is a great tool to generate documentation for your Angular projects.
      Storybook can use the documentation generated by Compodoc to extract argument definitions
      and JSDOC comments to display them in the Storybook UI. We highly recommend using Compodoc for
      your Angular projects to get the best experience out of Storybook.
    `,
      { title: "Compodoc", borderStyle: "round", padding: 1, borderColor: "#F1618C" }
    )
  );
  let { useCompoDoc: e } = await (0, wx.default)({
    type: "confirm",
    name: "useCompoDoc",
    message: "Do you want to use Compodoc for documentation?"
  });
  return e;
}, "promptForCompoDocs"), Cx = class {
  static {
    n(this, "AngularJSON");
  }
  constructor() {
    if (!(0, Al.existsSync)(ld))
      throw new NB.MissingAngularJsonError({ path: (0, kB.join)(process.cwd(), ld) });
    let t = (0, Al.readFileSync)(ld, "utf8");
    this.json = JSON.parse(t);
  }
  get projects() {
    return this.json.projects;
  }
  get projectsWithoutStorybook() {
    return Object.keys(this.projects).filter((t) => {
      let { architect: r } = this.projects[t];
      return !r.storybook;
    });
  }
  get hasStorybookBuilder() {
    return Object.keys(this.projects).some((t) => {
      let { architect: r } = this.projects[t];
      return Object.keys(r).some((i) => r[i].builder === "@storybook/angular:start-storybook");
    });
  }
  get rootProject() {
    let t = Object.keys(this.projects).find((r) => {
      let { root: i } = this.projects[r];
      return i === "" || i === ".";
    });
    return t ? this.projects[t] : null;
  }
  getProjectSettingsByName(t) {
    return this.projects[t];
  }
  async getProjectName() {
    if (this.projectsWithoutStorybook.length > 1) {
      let { projectName: t } = await (0, wx.default)({
        type: "select",
        name: "projectName",
        message: "For which project do you want to generate Storybook configuration?",
        choices: this.projectsWithoutStorybook.map((r) => ({
          title: r,
          value: r
        }))
      });
      return t;
    }
    return this.projectsWithoutStorybook[0];
  }
  addStorybookEntries({
    angularProjectName: t,
    storybookFolder: r,
    useCompodoc: i,
    root: s
  }) {
    let { architect: a } = this.projects[t], o = {
      configDir: r,
      browserTarget: `${t}:build`,
      compodoc: i,
      ...i && { compodocArgs: ["-e", "json", "-d", s || "."] }
    };
    a.storybook || (a.storybook = {
      builder: "@storybook/angular:start-storybook",
      options: {
        ...o,
        port: 6006
      }
    }), a["build-storybook"] || (a["build-storybook"] = {
      builder: "@storybook/angular:build-storybook",
      options: {
        ...o,
        outputDir: Object.keys(this.projects).length === 1 ? "storybook-static" : `dist/storybook/${t}`
      }
    });
  }
  write() {
    (0, Al.writeFileSync)(ld, JSON.stringify(this.json, null, 2));
  }
};

// src/cli/eslintPlugin.ts
var jc = require("node:fs/promises"), WP = require("storybook/internal/common"), ob = require("storybook/internal/csf-tools"), Lc = require("storybook/internal/node-logger"),
HP = We(qN(), 1);

// ../node_modules/detect-indent/index.js
var sde = /^(?:( )+|\t+)/, gd = "space", $N = "tab";
function UN(e, t) {
  let r = /* @__PURE__ */ new Map(), i = 0, s, a;
  for (let o of e.split(/\n/g)) {
    if (!o)
      continue;
    let u, l, c, f, m, h = o.match(sde);
    if (h === null)
      i = 0, s = "";
    else {
      if (u = h[0].length, l = h[1] ? gd : $N, t && l === gd && u === 1)
        continue;
      l !== s && (i = 0), s = l, c = 1, f = 0;
      let d = u - i;
      if (i = u, d === 0)
        c = 0, f = 1;
      else {
        let y = d > 0 ? d : -d;
        a = nde(l, y);
      }
      m = r.get(a), m = m === void 0 ? [1, 0] : [m[0] + c, m[1] + f], r.set(a, m);
    }
  }
  return r;
}
n(UN, "makeIndentsMap");
function nde(e, t) {
  return (e === gd ? "s" : "t") + String(t);
}
n(nde, "encodeIndentsKey");
function ade(e) {
  let r = e[0] === "s" ? gd : $N, i = Number(e.slice(1));
  return { type: r, amount: i };
}
n(ade, "decodeIndentsKey");
function ode(e) {
  let t, r = 0, i = 0;
  for (let [s, [a, o]] of e)
    (a > r || a === r && o > i) && (r = a, i = o, t = s);
  return t;
}
n(ode, "getMostUsedKey");
function ude(e, t) {
  return (e === gd ? " " : "	").repeat(t);
}
n(ude, "makeIndentString");
function rE(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  let t = UN(e, !0);
  t.size === 0 && (t = UN(e, !1));
  let r = ode(t), i, s = 0, a = "";
  return r !== void 0 && ({ type: i, amount: s } = ade(r), a = ude(i, s)), {
    amount: s,
    type: i,
    indent: a
  };
}
n(rE, "detectIndent");

// src/cli/eslintPlugin.ts
var CY = We(Mh(), 1), wY = We(ym(), 1);

// src/babel/index.ts
var lZe = We(Gt(), 1), EEt = We(Gt(), 1), cZe = We(Gt(), 1), $P = We(op(), 1), SEt = We(Ho(), 1), VP = We(ir(), 1), Ut = We(Pe(), 1), SY = We(require("recast"), 1);

// src/babel/babelParse.ts
var qP = We(Ho(), 1), UP = We(require("recast"), 1);
function oZe(e, t) {
  let s = /^\s*\/\/\s*@flow/.test(e) ? ["flow"] : ["typescript"], a = {
    ...t,
    plugins: [...t.plugins ?? [], ...s]
  };
  return qP.parse(e, a);
}
n(oZe, "parseWithFlowOrTypescript");
var uZe = {
  sourceType: "module",
  // FIXME: we should get this from the project config somehow?
  plugins: ["jsx", "decorators-legacy", "classProperties"],
  tokens: !0
}, EY = /* @__PURE__ */ n((e) => UP.parse(e, {
  parser: {
    parse(t) {
      return oZe(t, uZe);
    }
  }
}), "babelParse");

// src/babel/index.ts
var TY = VP.default.default || VP.default, TEt = $P.default.default || $P.default;

// src/cli/eslintPlugin.ts
var AY = ["ts", "mts", "cts", "mjs", "js", "cjs", "json"], fZe = ["yaml", "yml"], _Y = /* @__PURE__ */ n(async (e) => {
  let t = ["eslint.config", ".eslintrc"];
  for (let r of t)
    for (let i of fZe)
      if (await Ab(`${r}.${i}`, { cwd: e, stopAt: (0, WP.getProjectRoot)() }))
        throw new Error(`Unsupported ESLint config extension: .${i}`);
  for (let r of t)
    for (let i of AY) {
      let s = await Ab(`${r}.${i}`, { cwd: e, stopAt: (0, WP.getProjectRoot)() });
      if (s)
        return s;
    }
}, "findEslintFile");
function KP(e) {
  return e && (Ut.isTSAsExpression(e) || Ut.isTSSatisfiesExpression(e) ? KP(e.expression) : e);
}
n(KP, "unwrapTSExpression");
var PY = /* @__PURE__ */ n(async (e) => {
  let t = EY(e), r = "", i = null;
  return TY(t, {
    ImportDeclaration(s) {
      if (s.node.source.value === "typescript-eslint") {
        let a = s.node.specifiers.find((o) => Ut.isImportDefaultSpecifier(o));
        a && (r = a.local.name);
      }
    },
    ExportDefaultDeclaration(s) {
      let a = s.node;
      i = KP(a.declaration);
      let o = Ut.memberExpression(
        Ut.memberExpression(Ut.identifier("storybook"), Ut.identifier("configs")),
        Ut.stringLiteral("flat/recommended"),
        !0
      );
      if (Ut.isArrayExpression(i) && i.elements.push(Ut.spreadElement(o)), Ut.isCallExpression(i) && Ut.isMemberExpression(i.callee) && r &&
      Ut.isIdentifier(i.callee.object, { name: r }) && Ut.isIdentifier(i.callee.property, { name: "config" }) && i.arguments.push(o), Ut.isIdentifier(
      i)) {
        let u = s.scope.getBinding(i.name);
        if (u && Ut.isVariableDeclarator(u.path.node)) {
          let l = KP(u.path.node.init);
          Ut.isArrayExpression(l) && l.elements.push(Ut.spreadElement(o));
        }
      }
    },
    Program(s) {
      if (!s.node.body.some(
        (o) => Ut.isImportDeclaration(o) && o.source.value === "eslint-plugin-storybook"
      )) {
        let o = Ut.importDeclaration(
          [Ut.importDefaultSpecifier(Ut.identifier("storybook"))],
          Ut.stringLiteral("eslint-plugin-storybook")
        );
        o.comments = [
          {
            type: "CommentLine",
            value: " For more info, see https://github.com/storybookjs/eslint-plugin-storybook#configuration-flat-config-format"
          }
        ], s.node.body.unshift(o);
      }
    }
  }), SY.print(t).code;
}, "configureFlatConfig");
async function dZe(e) {
  let t, r = e.getAllDependencies(), { packageJson: i } = e.primaryPackageJson, s;
  try {
    s = await _Y(e.instanceDir);
  } catch (u) {
    if (u instanceof Error && u.message.includes("Unsupported ESLint"))
      t = String(u);
    else
      throw u;
  }
  let a = !!r["eslint-plugin-storybook"];
  return {
    hasEslint: !!(r.eslint || s || i.eslintConfig),
    isStorybookPluginInstalled: a,
    eslintConfigFile: s,
    unsupportedExtension: t,
    isFlatConfig: !!(s && s.match(/eslint\.config\.[^/]+/))
  };
}
n(dZe, "extractEslintInfo");
var ab = /* @__PURE__ */ n((e) => {
  if (!e)
    return [];
  if (typeof e == "string")
    return [e];
  if (Array.isArray(e))
    return e;
  throw new Error(`Invalid eslint extends ${e}`);
}, "normalizeExtends");
async function pZe({
  eslintConfigFile: e,
  packageManager: t,
  isFlatConfig: r
}) {
  if (e)
    if (e.endsWith("json")) {
      Lc.logger.debug(`Detected JSON config at ${e}`);
      let i = await (0, jc.readFile)(e, { encoding: "utf8" }), s = HP.default.parse(i);
      if (ab(s.extends).filter(Boolean).includes("plugin:storybook/recommended"))
        return;
      Array.isArray(s.extends) || (s.extends = s.extends ? [s.extends] : []), s.extends.push("plugin:storybook/recommended");
      let o = rE(i).amount || 2;
      await (0, jc.writeFile)(e, HP.default.stringify(s, null, o));
    } else if (r) {
      Lc.logger.debug(`Detected flat config at ${e}`);
      let i = await (0, jc.readFile)(e, { encoding: "utf8" }), s = await PY(i);
      await (0, jc.writeFile)(e, s);
    } else {
      let i = await (0, ob.readConfig)(e), s = ab(i.getFieldValue(["extends"])).filter(Boolean);
      if (s.includes("plugin:storybook/recommended"))
        return;
      i.setFieldValue(["extends"], [...s, "plugin:storybook/recommended"]), await (0, ob.writeConfig)(i);
    }
  else {
    Lc.logger.debug("No ESLint config file found, configuring in package.json instead");
    let { packageJson: i } = t.primaryPackageJson, s = ab(i.eslintConfig?.extends).filter(Boolean);
    t.writePackageJson({
      ...i,
      eslintConfig: {
        ...i.eslintConfig,
        extends: [...s, "plugin:storybook/recommended"]
      }
    });
  }
}
n(pZe, "configureEslintPlugin");
var hZe = /* @__PURE__ */ n(async () => await Lc.prompt.confirm({
  message: wY.dedent`
        We have detected that you're using ESLint. Storybook provides a plugin that gives the best experience with Storybook and helps follow best practices: ${CY.default.
  yellow(
    "https://storybook.js.org/docs/9/configure/integration/eslint-plugin"
  )}

        Would you like to install it?
      `,
  initialValue: !0
}), "suggestESLintPlugin");

// src/cli/globalSettings.ts
var yb = We(require("node:fs/promises"), 1), tG = require("node:os"), gb = require("node:path"), rG = We(ym(), 1), zc = We(eG(), 1);
var MQe = (0, gb.join)((0, tG.homedir)(), ".storybook", "settings.json"), RQe = 1, LQe = zc.z.object({
  version: zc.z.number(),
  // NOTE: every key (and subkey) below must be optional, for forwards compatibility reasons
  // (we can remove keys once they are deprecated)
  userSince: zc.z.number().optional(),
  init: zc.z.object({ skipOnboarding: zc.z.boolean().optional() }).optional()
}), $u;
async function jQe(e = MQe) {
  if ($u)
    return $u;
  try {
    let t = await yb.default.readFile(e, "utf8"), r = LQe.parse(JSON.parse(t));
    $u = new lh(e, r);
  } catch {
    $u = new lh(e, { version: RQe, userSince: Date.now() }), await $u.save();
  }
  return $u;
}
n(jQe, "globalSettings");
function qQe() {
  $u = void 0;
}
n(qQe, "_clearGlobalSettings");
var lh = class {
  static {
    n(this, "Settings");
  }
  /**
   * Create a new Settings instance
   *
   * @param filePath Path to the JSON settings file
   * @param value Loaded value of settings
   */
  constructor(t, r) {
    this.filePath = t, this.value = r;
  }
  /** Save settings to the file */
  async save() {
    try {
      await yb.default.mkdir((0, gb.dirname)(this.filePath), { recursive: !0 }), await yb.default.writeFile(this.filePath, JSON.stringify(this.
      value, null, 2));
    } catch (t) {
      console.warn(rG.dedent`
        Unable to save global settings file to ${this.filePath}
        ${t && `Reason: ${t.message ?? t}`}`);
    }
  }
};
