import ESM_COMPAT_Module from "node:module";
import { fileURLToPath as ESM_COMPAT_fileURLToPath } from 'node:url';
import { dirname as ESM_COMPAT_dirname } from 'node:path';
const __filename = ESM_COMPAT_fileURLToPath(import.meta.url);
const __dirname = ESM_COMPAT_dirname(__filename);
const require = ESM_COMPAT_Module.createRequire(import.meta.url);
var L5 = Object.create;
var Ca = Object.defineProperty;
var j5 = Object.getOwnPropertyDescriptor;
var M5 = Object.getOwnPropertyNames;
var R5 = Object.getPrototypeOf, q5 = Object.prototype.hasOwnProperty;
var i = (e, t) => Ca(e, "name", { value: t, configurable: !0 }), z = /* @__PURE__ */ ((e) => typeof require < "u" ? require : typeof Proxy <
"u" ? new Proxy(e, {
  get: (t, r) => (typeof require < "u" ? require : t)[r]
}) : e)(function(e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
});
var hl = (e, t) => () => (e && (t = e(e = 0)), t);
var D = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), sf = (e, t) => {
  for (var r in t)
    Ca(e, r, { get: t[r], enumerable: !0 });
}, Gb = (e, t, r, s) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let n of M5(t))
      !q5.call(e, n) && n !== r && Ca(e, n, { get: () => t[n], enumerable: !(s = j5(t, n)) || s.enumerable });
  return e;
};
var ms = (e, t, r) => (r = e != null ? L5(R5(e)) : {}, Gb(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? Ca(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), nf = (e) => Gb(Ca({}, "__esModule", { value: !0 }), e);

// ../node_modules/@babel/types/lib/utils/shallowEqual.js
var ml = D((af) => {
  "use strict";
  Object.defineProperty(af, "__esModule", {
    value: !0
  });
  af.default = U5;
  function U5(e, t) {
    let r = Object.keys(t);
    for (let s of r)
      if (e[s] !== t[s])
        return !1;
    return !0;
  }
  i(U5, "shallowEqual");
});

// ../node_modules/@babel/types/lib/utils/deprecationWarning.js
var mi = D((of) => {
  "use strict";
  Object.defineProperty(of, "__esModule", {
    value: !0
  });
  of.default = $5;
  var Xb = /* @__PURE__ */ new Set();
  function $5(e, t, r = "", s = e) {
    if (Xb.has(s)) return;
    Xb.add(s);
    let {
      internal: n,
      trace: a
    } = V5(1, 2);
    n || console.warn(`${r}\`${e}\` has been deprecated, please migrate to \`${t}\`
${a}`);
  }
  i($5, "deprecationWarning");
  function V5(e, t) {
    let {
      stackTraceLimit: r,
      prepareStackTrace: s
    } = Error, n;
    if (Error.stackTraceLimit = 1 + e + t, Error.prepareStackTrace = function(o, l) {
      n = l;
    }, new Error().stack, Error.stackTraceLimit = r, Error.prepareStackTrace = s, !n) return {
      internal: !1,
      trace: ""
    };
    let a = n.slice(1 + e, 1 + e + t);
    return {
      internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
      trace: a.map((o) => `    at ${o}`).join(`
`)
    };
  }
  i(V5, "captureShortStackTrace");
});

// ../node_modules/@babel/types/lib/validators/generated/index.js
var ze = D((S) => {
  "use strict";
  Object.defineProperty(S, "__esModule", {
    value: !0
  });
  S.isAccessor = oO;
  S.isAnyTypeAnnotation = A_;
  S.isArgumentPlaceholder = e7;
  S.isArrayExpression = K5;
  S.isArrayPattern = $6;
  S.isArrayTypeAnnotation = C_;
  S.isArrowFunctionExpression = V6;
  S.isAssignmentExpression = W5;
  S.isAssignmentPattern = U6;
  S.isAwaitExpression = f_;
  S.isBigIntLiteral = h_;
  S.isBinary = _9;
  S.isBinaryExpression = Y5;
  S.isBindExpression = t7;
  S.isBlock = N9;
  S.isBlockParent = O9;
  S.isBlockStatement = X5;
  S.isBooleanLiteral = b6;
  S.isBooleanLiteralTypeAnnotation = D_;
  S.isBooleanTypeAnnotation = w_;
  S.isBreakStatement = z5;
  S.isCallExpression = Q5;
  S.isCatchClause = Z5;
  S.isClass = nO;
  S.isClassAccessorProperty = T_;
  S.isClassBody = K6;
  S.isClassDeclaration = Y6;
  S.isClassExpression = W6;
  S.isClassImplements = I_;
  S.isClassMethod = n_;
  S.isClassPrivateMethod = E_;
  S.isClassPrivateProperty = x_;
  S.isClassProperty = g_;
  S.isCompletionStatement = F9;
  S.isConditional = L9;
  S.isConditionalExpression = e6;
  S.isContinueStatement = t6;
  S.isDebuggerStatement = r6;
  S.isDecimalLiteral = o7;
  S.isDeclaration = W9;
  S.isDeclareClass = O_;
  S.isDeclareExportAllDeclaration = q_;
  S.isDeclareExportDeclaration = R_;
  S.isDeclareFunction = N_;
  S.isDeclareInterface = B_;
  S.isDeclareModule = k_;
  S.isDeclareModuleExports = F_;
  S.isDeclareOpaqueType = j_;
  S.isDeclareTypeAlias = L_;
  S.isDeclareVariable = M_;
  S.isDeclaredPredicate = U_;
  S.isDecorator = r7;
  S.isDirective = J5;
  S.isDirectiveLiteral = G5;
  S.isDoExpression = s7;
  S.isDoWhileStatement = s6;
  S.isEmptyStatement = n6;
  S.isEmptyTypeAnnotation = Q_;
  S.isEnumBody = hO;
  S.isEnumBooleanBody = CI;
  S.isEnumBooleanMember = II;
  S.isEnumDeclaration = AI;
  S.isEnumDefaultedMember = BI;
  S.isEnumMember = mO;
  S.isEnumNumberBody = wI;
  S.isEnumNumberMember = OI;
  S.isEnumStringBody = DI;
  S.isEnumStringMember = NI;
  S.isEnumSymbolBody = _I;
  S.isExistsTypeAnnotation = $_;
  S.isExportAllDeclaration = H6;
  S.isExportDeclaration = iO;
  S.isExportDefaultDeclaration = J6;
  S.isExportDefaultSpecifier = n7;
  S.isExportNamedDeclaration = G6;
  S.isExportNamespaceSpecifier = m_;
  S.isExportSpecifier = X6;
  S.isExpression = D9;
  S.isExpressionStatement = i6;
  S.isExpressionWrapper = R9;
  S.isFile = a6;
  S.isFlow = uO;
  S.isFlowBaseAnnotation = pO;
  S.isFlowDeclaration = fO;
  S.isFlowPredicate = dO;
  S.isFlowType = cO;
  S.isFor = q9;
  S.isForInStatement = o6;
  S.isForOfStatement = z6;
  S.isForStatement = l6;
  S.isForXStatement = U9;
  S.isFunction = $9;
  S.isFunctionDeclaration = u6;
  S.isFunctionExpression = c6;
  S.isFunctionParameter = Y9;
  S.isFunctionParent = V9;
  S.isFunctionTypeAnnotation = V_;
  S.isFunctionTypeParam = K_;
  S.isGenericTypeAnnotation = W_;
  S.isIdentifier = p6;
  S.isIfStatement = f6;
  S.isImmutable = z9;
  S.isImport = d_;
  S.isImportAttribute = P_;
  S.isImportDeclaration = Q6;
  S.isImportDefaultSpecifier = Z6;
  S.isImportExpression = r_;
  S.isImportNamespaceSpecifier = e_;
  S.isImportOrExportDeclaration = zb;
  S.isImportSpecifier = t_;
  S.isIndexedAccessType = kI;
  S.isInferredPredicate = Y_;
  S.isInterfaceDeclaration = J_;
  S.isInterfaceExtends = H_;
  S.isInterfaceTypeAnnotation = G_;
  S.isInterpreterDirective = H5;
  S.isIntersectionTypeAnnotation = X_;
  S.isJSX = yO;
  S.isJSXAttribute = LI;
  S.isJSXClosingElement = jI;
  S.isJSXClosingFragment = XI;
  S.isJSXElement = MI;
  S.isJSXEmptyExpression = RI;
  S.isJSXExpressionContainer = qI;
  S.isJSXFragment = JI;
  S.isJSXIdentifier = $I;
  S.isJSXMemberExpression = VI;
  S.isJSXNamespacedName = KI;
  S.isJSXOpeningElement = WI;
  S.isJSXOpeningFragment = GI;
  S.isJSXSpreadAttribute = YI;
  S.isJSXSpreadChild = UI;
  S.isJSXText = HI;
  S.isLVal = J9;
  S.isLabeledStatement = d6;
  S.isLiteral = X9;
  S.isLogicalExpression = T6;
  S.isLoop = j9;
  S.isMemberExpression = x6;
  S.isMetaProperty = s_;
  S.isMethod = Z9;
  S.isMiscellaneous = bO;
  S.isMixedTypeAnnotation = z_;
  S.isModuleDeclaration = CO;
  S.isModuleExpression = l7;
  S.isModuleSpecifier = aO;
  S.isNewExpression = E6;
  S.isNoop = zI;
  S.isNullLiteral = y6;
  S.isNullLiteralTypeAnnotation = __;
  S.isNullableTypeAnnotation = Z_;
  S.isNumberLiteral = SO;
  S.isNumberLiteralTypeAnnotation = eI;
  S.isNumberTypeAnnotation = tI;
  S.isNumericLiteral = m6;
  S.isObjectExpression = v6;
  S.isObjectMember = eO;
  S.isObjectMethod = P6;
  S.isObjectPattern = i_;
  S.isObjectProperty = A6;
  S.isObjectTypeAnnotation = rI;
  S.isObjectTypeCallProperty = nI;
  S.isObjectTypeIndexer = iI;
  S.isObjectTypeInternalSlot = sI;
  S.isObjectTypeProperty = aI;
  S.isObjectTypeSpreadProperty = oI;
  S.isOpaqueType = lI;
  S.isOptionalCallExpression = b_;
  S.isOptionalIndexedAccessType = FI;
  S.isOptionalMemberExpression = y_;
  S.isParenthesizedExpression = _6;
  S.isPattern = sO;
  S.isPatternLike = H9;
  S.isPipelineBareFunction = p7;
  S.isPipelinePrimaryTopicReference = f7;
  S.isPipelineTopicExpression = c7;
  S.isPlaceholder = QI;
  S.isPrivate = lO;
  S.isPrivateName = S_;
  S.isProgram = S6;
  S.isProperty = tO;
  S.isPureish = K9;
  S.isQualifiedTypeIdentifier = uI;
  S.isRecordExpression = i7;
  S.isRegExpLiteral = g6;
  S.isRegexLiteral = vO;
  S.isRestElement = C6;
  S.isRestProperty = PO;
  S.isReturnStatement = w6;
  S.isScopable = I9;
  S.isSequenceExpression = D6;
  S.isSpreadElement = a_;
  S.isSpreadProperty = AO;
  S.isStandardized = w9;
  S.isStatement = B9;
  S.isStaticBlock = v_;
  S.isStringLiteral = h6;
  S.isStringLiteralTypeAnnotation = cI;
  S.isStringTypeAnnotation = pI;
  S.isSuper = o_;
  S.isSwitchCase = I6;
  S.isSwitchStatement = O6;
  S.isSymbolTypeAnnotation = fI;
  S.isTSAnyKeyword = v7;
  S.isTSArrayType = V7;
  S.isTSAsExpression = u9;
  S.isTSBaseType = EO;
  S.isTSBigIntKeyword = A7;
  S.isTSBooleanKeyword = P7;
  S.isTSCallSignatureDeclaration = g7;
  S.isTSConditionalType = X7;
  S.isTSConstructSignatureDeclaration = T7;
  S.isTSConstructorType = M7;
  S.isTSDeclareFunction = m7;
  S.isTSDeclareMethod = y7;
  S.isTSEntityName = G9;
  S.isTSEnumBody = f9;
  S.isTSEnumDeclaration = d9;
  S.isTSEnumMember = h9;
  S.isTSExportAssignment = E9;
  S.isTSExpressionWithTypeArguments = n9;
  S.isTSExternalModuleReference = T9;
  S.isTSFunctionType = j7;
  S.isTSImportEqualsDeclaration = g9;
  S.isTSImportType = b9;
  S.isTSIndexSignature = S7;
  S.isTSIndexedAccessType = e9;
  S.isTSInferType = z7;
  S.isTSInstantiationExpression = l9;
  S.isTSInterfaceBody = a9;
  S.isTSInterfaceDeclaration = i9;
  S.isTSIntersectionType = G7;
  S.isTSIntrinsicKeyword = C7;
  S.isTSLiteralType = s9;
  S.isTSMappedType = t9;
  S.isTSMethodSignature = E7;
  S.isTSModuleBlock = y9;
  S.isTSModuleDeclaration = m9;
  S.isTSNamedTupleMember = H7;
  S.isTSNamespaceExportDeclaration = S9;
  S.isTSNeverKeyword = w7;
  S.isTSNonNullExpression = x9;
  S.isTSNullKeyword = D7;
  S.isTSNumberKeyword = _7;
  S.isTSObjectKeyword = I7;
  S.isTSOptionalType = W7;
  S.isTSParameterProperty = h7;
  S.isTSParenthesizedType = Q7;
  S.isTSPropertySignature = x7;
  S.isTSQualifiedName = b7;
  S.isTSRestType = Y7;
  S.isTSSatisfiesExpression = c9;
  S.isTSStringKeyword = O7;
  S.isTSSymbolKeyword = N7;
  S.isTSTemplateLiteralType = r9;
  S.isTSThisType = L7;
  S.isTSTupleType = K7;
  S.isTSType = xO;
  S.isTSTypeAliasDeclaration = o9;
  S.isTSTypeAnnotation = v9;
  S.isTSTypeAssertion = p9;
  S.isTSTypeElement = TO;
  S.isTSTypeLiteral = $7;
  S.isTSTypeOperator = Z7;
  S.isTSTypeParameter = C9;
  S.isTSTypeParameterDeclaration = A9;
  S.isTSTypeParameterInstantiation = P9;
  S.isTSTypePredicate = q7;
  S.isTSTypeQuery = U7;
  S.isTSTypeReference = R7;
  S.isTSUndefinedKeyword = B7;
  S.isTSUnionType = J7;
  S.isTSUnknownKeyword = k7;
  S.isTSVoidKeyword = F7;
  S.isTaggedTemplateExpression = l_;
  S.isTemplateElement = u_;
  S.isTemplateLiteral = c_;
  S.isTerminatorless = k9;
  S.isThisExpression = N6;
  S.isThisTypeAnnotation = dI;
  S.isThrowStatement = B6;
  S.isTopicReference = u7;
  S.isTryStatement = k6;
  S.isTupleExpression = a7;
  S.isTupleTypeAnnotation = hI;
  S.isTypeAlias = yI;
  S.isTypeAnnotation = bI;
  S.isTypeCastExpression = gI;
  S.isTypeParameter = TI;
  S.isTypeParameterDeclaration = xI;
  S.isTypeParameterInstantiation = EI;
  S.isTypeScript = gO;
  S.isTypeofTypeAnnotation = mI;
  S.isUnaryExpression = F6;
  S.isUnaryLike = rO;
  S.isUnionTypeAnnotation = SI;
  S.isUpdateExpression = L6;
  S.isUserWhitespacable = Q9;
  S.isV8IntrinsicIdentifier = ZI;
  S.isVariableDeclaration = j6;
  S.isVariableDeclarator = M6;
  S.isVariance = vI;
  S.isVoidPattern = d7;
  S.isVoidTypeAnnotation = PI;
  S.isWhile = M9;
  S.isWhileStatement = R6;
  S.isWithStatement = q6;
  S.isYieldExpression = p_;
  var A = ml(), wa = mi();
  function K5(e, t) {
    return !e || e.type !== "ArrayExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(K5, "isArrayExpression");
  function W5(e, t) {
    return !e || e.type !== "AssignmentExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(W5, "isAssignmentExpression");
  function Y5(e, t) {
    return !e || e.type !== "BinaryExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Y5, "isBinaryExpression");
  function H5(e, t) {
    return !e || e.type !== "InterpreterDirective" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(H5, "isInterpreterDirective");
  function J5(e, t) {
    return !e || e.type !== "Directive" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(J5, "isDirective");
  function G5(e, t) {
    return !e || e.type !== "DirectiveLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(G5, "isDirectiveLiteral");
  function X5(e, t) {
    return !e || e.type !== "BlockStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(X5, "isBlockStatement");
  function z5(e, t) {
    return !e || e.type !== "BreakStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(z5, "isBreakStatement");
  function Q5(e, t) {
    return !e || e.type !== "CallExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Q5, "isCallExpression");
  function Z5(e, t) {
    return !e || e.type !== "CatchClause" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Z5, "isCatchClause");
  function e6(e, t) {
    return !e || e.type !== "ConditionalExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(e6, "isConditionalExpression");
  function t6(e, t) {
    return !e || e.type !== "ContinueStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(t6, "isContinueStatement");
  function r6(e, t) {
    return !e || e.type !== "DebuggerStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(r6, "isDebuggerStatement");
  function s6(e, t) {
    return !e || e.type !== "DoWhileStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(s6, "isDoWhileStatement");
  function n6(e, t) {
    return !e || e.type !== "EmptyStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(n6, "isEmptyStatement");
  function i6(e, t) {
    return !e || e.type !== "ExpressionStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(i6, "isExpressionStatement");
  function a6(e, t) {
    return !e || e.type !== "File" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(a6, "isFile");
  function o6(e, t) {
    return !e || e.type !== "ForInStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(o6, "isForInStatement");
  function l6(e, t) {
    return !e || e.type !== "ForStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(l6, "isForStatement");
  function u6(e, t) {
    return !e || e.type !== "FunctionDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(u6, "isFunctionDeclaration");
  function c6(e, t) {
    return !e || e.type !== "FunctionExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(c6, "isFunctionExpression");
  function p6(e, t) {
    return !e || e.type !== "Identifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(p6, "isIdentifier");
  function f6(e, t) {
    return !e || e.type !== "IfStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(f6, "isIfStatement");
  function d6(e, t) {
    return !e || e.type !== "LabeledStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(d6, "isLabeledStatement");
  function h6(e, t) {
    return !e || e.type !== "StringLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(h6, "isStringLiteral");
  function m6(e, t) {
    return !e || e.type !== "NumericLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(m6, "isNumericLiteral");
  function y6(e, t) {
    return !e || e.type !== "NullLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(y6, "isNullLiteral");
  function b6(e, t) {
    return !e || e.type !== "BooleanLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(b6, "isBooleanLiteral");
  function g6(e, t) {
    return !e || e.type !== "RegExpLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(g6, "isRegExpLiteral");
  function T6(e, t) {
    return !e || e.type !== "LogicalExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(T6, "isLogicalExpression");
  function x6(e, t) {
    return !e || e.type !== "MemberExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(x6, "isMemberExpression");
  function E6(e, t) {
    return !e || e.type !== "NewExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(E6, "isNewExpression");
  function S6(e, t) {
    return !e || e.type !== "Program" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(S6, "isProgram");
  function v6(e, t) {
    return !e || e.type !== "ObjectExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(v6, "isObjectExpression");
  function P6(e, t) {
    return !e || e.type !== "ObjectMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(P6, "isObjectMethod");
  function A6(e, t) {
    return !e || e.type !== "ObjectProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(A6, "isObjectProperty");
  function C6(e, t) {
    return !e || e.type !== "RestElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(C6, "isRestElement");
  function w6(e, t) {
    return !e || e.type !== "ReturnStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(w6, "isReturnStatement");
  function D6(e, t) {
    return !e || e.type !== "SequenceExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(D6, "isSequenceExpression");
  function _6(e, t) {
    return !e || e.type !== "ParenthesizedExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(_6, "isParenthesizedExpression");
  function I6(e, t) {
    return !e || e.type !== "SwitchCase" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(I6, "isSwitchCase");
  function O6(e, t) {
    return !e || e.type !== "SwitchStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(O6, "isSwitchStatement");
  function N6(e, t) {
    return !e || e.type !== "ThisExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(N6, "isThisExpression");
  function B6(e, t) {
    return !e || e.type !== "ThrowStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(B6, "isThrowStatement");
  function k6(e, t) {
    return !e || e.type !== "TryStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(k6, "isTryStatement");
  function F6(e, t) {
    return !e || e.type !== "UnaryExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(F6, "isUnaryExpression");
  function L6(e, t) {
    return !e || e.type !== "UpdateExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(L6, "isUpdateExpression");
  function j6(e, t) {
    return !e || e.type !== "VariableDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(j6, "isVariableDeclaration");
  function M6(e, t) {
    return !e || e.type !== "VariableDeclarator" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(M6, "isVariableDeclarator");
  function R6(e, t) {
    return !e || e.type !== "WhileStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(R6, "isWhileStatement");
  function q6(e, t) {
    return !e || e.type !== "WithStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(q6, "isWithStatement");
  function U6(e, t) {
    return !e || e.type !== "AssignmentPattern" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(U6, "isAssignmentPattern");
  function $6(e, t) {
    return !e || e.type !== "ArrayPattern" ? !1 : t == null || (0, A.default)(e, t);
  }
  i($6, "isArrayPattern");
  function V6(e, t) {
    return !e || e.type !== "ArrowFunctionExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(V6, "isArrowFunctionExpression");
  function K6(e, t) {
    return !e || e.type !== "ClassBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(K6, "isClassBody");
  function W6(e, t) {
    return !e || e.type !== "ClassExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(W6, "isClassExpression");
  function Y6(e, t) {
    return !e || e.type !== "ClassDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Y6, "isClassDeclaration");
  function H6(e, t) {
    return !e || e.type !== "ExportAllDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(H6, "isExportAllDeclaration");
  function J6(e, t) {
    return !e || e.type !== "ExportDefaultDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(J6, "isExportDefaultDeclaration");
  function G6(e, t) {
    return !e || e.type !== "ExportNamedDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(G6, "isExportNamedDeclaration");
  function X6(e, t) {
    return !e || e.type !== "ExportSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(X6, "isExportSpecifier");
  function z6(e, t) {
    return !e || e.type !== "ForOfStatement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(z6, "isForOfStatement");
  function Q6(e, t) {
    return !e || e.type !== "ImportDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Q6, "isImportDeclaration");
  function Z6(e, t) {
    return !e || e.type !== "ImportDefaultSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Z6, "isImportDefaultSpecifier");
  function e_(e, t) {
    return !e || e.type !== "ImportNamespaceSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(e_, "isImportNamespaceSpecifier");
  function t_(e, t) {
    return !e || e.type !== "ImportSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(t_, "isImportSpecifier");
  function r_(e, t) {
    return !e || e.type !== "ImportExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(r_, "isImportExpression");
  function s_(e, t) {
    return !e || e.type !== "MetaProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(s_, "isMetaProperty");
  function n_(e, t) {
    return !e || e.type !== "ClassMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(n_, "isClassMethod");
  function i_(e, t) {
    return !e || e.type !== "ObjectPattern" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(i_, "isObjectPattern");
  function a_(e, t) {
    return !e || e.type !== "SpreadElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(a_, "isSpreadElement");
  function o_(e, t) {
    return !e || e.type !== "Super" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(o_, "isSuper");
  function l_(e, t) {
    return !e || e.type !== "TaggedTemplateExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(l_, "isTaggedTemplateExpression");
  function u_(e, t) {
    return !e || e.type !== "TemplateElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(u_, "isTemplateElement");
  function c_(e, t) {
    return !e || e.type !== "TemplateLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(c_, "isTemplateLiteral");
  function p_(e, t) {
    return !e || e.type !== "YieldExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(p_, "isYieldExpression");
  function f_(e, t) {
    return !e || e.type !== "AwaitExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(f_, "isAwaitExpression");
  function d_(e, t) {
    return !e || e.type !== "Import" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(d_, "isImport");
  function h_(e, t) {
    return !e || e.type !== "BigIntLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(h_, "isBigIntLiteral");
  function m_(e, t) {
    return !e || e.type !== "ExportNamespaceSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(m_, "isExportNamespaceSpecifier");
  function y_(e, t) {
    return !e || e.type !== "OptionalMemberExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(y_, "isOptionalMemberExpression");
  function b_(e, t) {
    return !e || e.type !== "OptionalCallExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(b_, "isOptionalCallExpression");
  function g_(e, t) {
    return !e || e.type !== "ClassProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(g_, "isClassProperty");
  function T_(e, t) {
    return !e || e.type !== "ClassAccessorProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(T_, "isClassAccessorProperty");
  function x_(e, t) {
    return !e || e.type !== "ClassPrivateProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(x_, "isClassPrivateProperty");
  function E_(e, t) {
    return !e || e.type !== "ClassPrivateMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(E_, "isClassPrivateMethod");
  function S_(e, t) {
    return !e || e.type !== "PrivateName" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(S_, "isPrivateName");
  function v_(e, t) {
    return !e || e.type !== "StaticBlock" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(v_, "isStaticBlock");
  function P_(e, t) {
    return !e || e.type !== "ImportAttribute" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(P_, "isImportAttribute");
  function A_(e, t) {
    return !e || e.type !== "AnyTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(A_, "isAnyTypeAnnotation");
  function C_(e, t) {
    return !e || e.type !== "ArrayTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(C_, "isArrayTypeAnnotation");
  function w_(e, t) {
    return !e || e.type !== "BooleanTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(w_, "isBooleanTypeAnnotation");
  function D_(e, t) {
    return !e || e.type !== "BooleanLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(D_, "isBooleanLiteralTypeAnnotation");
  function __(e, t) {
    return !e || e.type !== "NullLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(__, "isNullLiteralTypeAnnotation");
  function I_(e, t) {
    return !e || e.type !== "ClassImplements" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(I_, "isClassImplements");
  function O_(e, t) {
    return !e || e.type !== "DeclareClass" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(O_, "isDeclareClass");
  function N_(e, t) {
    return !e || e.type !== "DeclareFunction" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(N_, "isDeclareFunction");
  function B_(e, t) {
    return !e || e.type !== "DeclareInterface" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(B_, "isDeclareInterface");
  function k_(e, t) {
    return !e || e.type !== "DeclareModule" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(k_, "isDeclareModule");
  function F_(e, t) {
    return !e || e.type !== "DeclareModuleExports" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(F_, "isDeclareModuleExports");
  function L_(e, t) {
    return !e || e.type !== "DeclareTypeAlias" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(L_, "isDeclareTypeAlias");
  function j_(e, t) {
    return !e || e.type !== "DeclareOpaqueType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(j_, "isDeclareOpaqueType");
  function M_(e, t) {
    return !e || e.type !== "DeclareVariable" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(M_, "isDeclareVariable");
  function R_(e, t) {
    return !e || e.type !== "DeclareExportDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(R_, "isDeclareExportDeclaration");
  function q_(e, t) {
    return !e || e.type !== "DeclareExportAllDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(q_, "isDeclareExportAllDeclaration");
  function U_(e, t) {
    return !e || e.type !== "DeclaredPredicate" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(U_, "isDeclaredPredicate");
  function $_(e, t) {
    return !e || e.type !== "ExistsTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i($_, "isExistsTypeAnnotation");
  function V_(e, t) {
    return !e || e.type !== "FunctionTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(V_, "isFunctionTypeAnnotation");
  function K_(e, t) {
    return !e || e.type !== "FunctionTypeParam" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(K_, "isFunctionTypeParam");
  function W_(e, t) {
    return !e || e.type !== "GenericTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(W_, "isGenericTypeAnnotation");
  function Y_(e, t) {
    return !e || e.type !== "InferredPredicate" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Y_, "isInferredPredicate");
  function H_(e, t) {
    return !e || e.type !== "InterfaceExtends" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(H_, "isInterfaceExtends");
  function J_(e, t) {
    return !e || e.type !== "InterfaceDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(J_, "isInterfaceDeclaration");
  function G_(e, t) {
    return !e || e.type !== "InterfaceTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(G_, "isInterfaceTypeAnnotation");
  function X_(e, t) {
    return !e || e.type !== "IntersectionTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(X_, "isIntersectionTypeAnnotation");
  function z_(e, t) {
    return !e || e.type !== "MixedTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(z_, "isMixedTypeAnnotation");
  function Q_(e, t) {
    return !e || e.type !== "EmptyTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Q_, "isEmptyTypeAnnotation");
  function Z_(e, t) {
    return !e || e.type !== "NullableTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Z_, "isNullableTypeAnnotation");
  function eI(e, t) {
    return !e || e.type !== "NumberLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(eI, "isNumberLiteralTypeAnnotation");
  function tI(e, t) {
    return !e || e.type !== "NumberTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(tI, "isNumberTypeAnnotation");
  function rI(e, t) {
    return !e || e.type !== "ObjectTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(rI, "isObjectTypeAnnotation");
  function sI(e, t) {
    return !e || e.type !== "ObjectTypeInternalSlot" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(sI, "isObjectTypeInternalSlot");
  function nI(e, t) {
    return !e || e.type !== "ObjectTypeCallProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(nI, "isObjectTypeCallProperty");
  function iI(e, t) {
    return !e || e.type !== "ObjectTypeIndexer" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(iI, "isObjectTypeIndexer");
  function aI(e, t) {
    return !e || e.type !== "ObjectTypeProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(aI, "isObjectTypeProperty");
  function oI(e, t) {
    return !e || e.type !== "ObjectTypeSpreadProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(oI, "isObjectTypeSpreadProperty");
  function lI(e, t) {
    return !e || e.type !== "OpaqueType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(lI, "isOpaqueType");
  function uI(e, t) {
    return !e || e.type !== "QualifiedTypeIdentifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(uI, "isQualifiedTypeIdentifier");
  function cI(e, t) {
    return !e || e.type !== "StringLiteralTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(cI, "isStringLiteralTypeAnnotation");
  function pI(e, t) {
    return !e || e.type !== "StringTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(pI, "isStringTypeAnnotation");
  function fI(e, t) {
    return !e || e.type !== "SymbolTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(fI, "isSymbolTypeAnnotation");
  function dI(e, t) {
    return !e || e.type !== "ThisTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(dI, "isThisTypeAnnotation");
  function hI(e, t) {
    return !e || e.type !== "TupleTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(hI, "isTupleTypeAnnotation");
  function mI(e, t) {
    return !e || e.type !== "TypeofTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(mI, "isTypeofTypeAnnotation");
  function yI(e, t) {
    return !e || e.type !== "TypeAlias" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(yI, "isTypeAlias");
  function bI(e, t) {
    return !e || e.type !== "TypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(bI, "isTypeAnnotation");
  function gI(e, t) {
    return !e || e.type !== "TypeCastExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(gI, "isTypeCastExpression");
  function TI(e, t) {
    return !e || e.type !== "TypeParameter" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(TI, "isTypeParameter");
  function xI(e, t) {
    return !e || e.type !== "TypeParameterDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(xI, "isTypeParameterDeclaration");
  function EI(e, t) {
    return !e || e.type !== "TypeParameterInstantiation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(EI, "isTypeParameterInstantiation");
  function SI(e, t) {
    return !e || e.type !== "UnionTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(SI, "isUnionTypeAnnotation");
  function vI(e, t) {
    return !e || e.type !== "Variance" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(vI, "isVariance");
  function PI(e, t) {
    return !e || e.type !== "VoidTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(PI, "isVoidTypeAnnotation");
  function AI(e, t) {
    return !e || e.type !== "EnumDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(AI, "isEnumDeclaration");
  function CI(e, t) {
    return !e || e.type !== "EnumBooleanBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(CI, "isEnumBooleanBody");
  function wI(e, t) {
    return !e || e.type !== "EnumNumberBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(wI, "isEnumNumberBody");
  function DI(e, t) {
    return !e || e.type !== "EnumStringBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(DI, "isEnumStringBody");
  function _I(e, t) {
    return !e || e.type !== "EnumSymbolBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(_I, "isEnumSymbolBody");
  function II(e, t) {
    return !e || e.type !== "EnumBooleanMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(II, "isEnumBooleanMember");
  function OI(e, t) {
    return !e || e.type !== "EnumNumberMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(OI, "isEnumNumberMember");
  function NI(e, t) {
    return !e || e.type !== "EnumStringMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(NI, "isEnumStringMember");
  function BI(e, t) {
    return !e || e.type !== "EnumDefaultedMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(BI, "isEnumDefaultedMember");
  function kI(e, t) {
    return !e || e.type !== "IndexedAccessType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(kI, "isIndexedAccessType");
  function FI(e, t) {
    return !e || e.type !== "OptionalIndexedAccessType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(FI, "isOptionalIndexedAccessType");
  function LI(e, t) {
    return !e || e.type !== "JSXAttribute" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(LI, "isJSXAttribute");
  function jI(e, t) {
    return !e || e.type !== "JSXClosingElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(jI, "isJSXClosingElement");
  function MI(e, t) {
    return !e || e.type !== "JSXElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(MI, "isJSXElement");
  function RI(e, t) {
    return !e || e.type !== "JSXEmptyExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(RI, "isJSXEmptyExpression");
  function qI(e, t) {
    return !e || e.type !== "JSXExpressionContainer" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(qI, "isJSXExpressionContainer");
  function UI(e, t) {
    return !e || e.type !== "JSXSpreadChild" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(UI, "isJSXSpreadChild");
  function $I(e, t) {
    return !e || e.type !== "JSXIdentifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i($I, "isJSXIdentifier");
  function VI(e, t) {
    return !e || e.type !== "JSXMemberExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(VI, "isJSXMemberExpression");
  function KI(e, t) {
    return !e || e.type !== "JSXNamespacedName" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(KI, "isJSXNamespacedName");
  function WI(e, t) {
    return !e || e.type !== "JSXOpeningElement" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(WI, "isJSXOpeningElement");
  function YI(e, t) {
    return !e || e.type !== "JSXSpreadAttribute" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(YI, "isJSXSpreadAttribute");
  function HI(e, t) {
    return !e || e.type !== "JSXText" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(HI, "isJSXText");
  function JI(e, t) {
    return !e || e.type !== "JSXFragment" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(JI, "isJSXFragment");
  function GI(e, t) {
    return !e || e.type !== "JSXOpeningFragment" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(GI, "isJSXOpeningFragment");
  function XI(e, t) {
    return !e || e.type !== "JSXClosingFragment" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(XI, "isJSXClosingFragment");
  function zI(e, t) {
    return !e || e.type !== "Noop" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(zI, "isNoop");
  function QI(e, t) {
    return !e || e.type !== "Placeholder" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(QI, "isPlaceholder");
  function ZI(e, t) {
    return !e || e.type !== "V8IntrinsicIdentifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(ZI, "isV8IntrinsicIdentifier");
  function e7(e, t) {
    return !e || e.type !== "ArgumentPlaceholder" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(e7, "isArgumentPlaceholder");
  function t7(e, t) {
    return !e || e.type !== "BindExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(t7, "isBindExpression");
  function r7(e, t) {
    return !e || e.type !== "Decorator" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(r7, "isDecorator");
  function s7(e, t) {
    return !e || e.type !== "DoExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(s7, "isDoExpression");
  function n7(e, t) {
    return !e || e.type !== "ExportDefaultSpecifier" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(n7, "isExportDefaultSpecifier");
  function i7(e, t) {
    return !e || e.type !== "RecordExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(i7, "isRecordExpression");
  function a7(e, t) {
    return !e || e.type !== "TupleExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(a7, "isTupleExpression");
  function o7(e, t) {
    return !e || e.type !== "DecimalLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(o7, "isDecimalLiteral");
  function l7(e, t) {
    return !e || e.type !== "ModuleExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(l7, "isModuleExpression");
  function u7(e, t) {
    return !e || e.type !== "TopicReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(u7, "isTopicReference");
  function c7(e, t) {
    return !e || e.type !== "PipelineTopicExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(c7, "isPipelineTopicExpression");
  function p7(e, t) {
    return !e || e.type !== "PipelineBareFunction" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(p7, "isPipelineBareFunction");
  function f7(e, t) {
    return !e || e.type !== "PipelinePrimaryTopicReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(f7, "isPipelinePrimaryTopicReference");
  function d7(e, t) {
    return !e || e.type !== "VoidPattern" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(d7, "isVoidPattern");
  function h7(e, t) {
    return !e || e.type !== "TSParameterProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(h7, "isTSParameterProperty");
  function m7(e, t) {
    return !e || e.type !== "TSDeclareFunction" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(m7, "isTSDeclareFunction");
  function y7(e, t) {
    return !e || e.type !== "TSDeclareMethod" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(y7, "isTSDeclareMethod");
  function b7(e, t) {
    return !e || e.type !== "TSQualifiedName" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(b7, "isTSQualifiedName");
  function g7(e, t) {
    return !e || e.type !== "TSCallSignatureDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(g7, "isTSCallSignatureDeclaration");
  function T7(e, t) {
    return !e || e.type !== "TSConstructSignatureDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(T7, "isTSConstructSignatureDeclaration");
  function x7(e, t) {
    return !e || e.type !== "TSPropertySignature" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(x7, "isTSPropertySignature");
  function E7(e, t) {
    return !e || e.type !== "TSMethodSignature" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(E7, "isTSMethodSignature");
  function S7(e, t) {
    return !e || e.type !== "TSIndexSignature" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(S7, "isTSIndexSignature");
  function v7(e, t) {
    return !e || e.type !== "TSAnyKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(v7, "isTSAnyKeyword");
  function P7(e, t) {
    return !e || e.type !== "TSBooleanKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(P7, "isTSBooleanKeyword");
  function A7(e, t) {
    return !e || e.type !== "TSBigIntKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(A7, "isTSBigIntKeyword");
  function C7(e, t) {
    return !e || e.type !== "TSIntrinsicKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(C7, "isTSIntrinsicKeyword");
  function w7(e, t) {
    return !e || e.type !== "TSNeverKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(w7, "isTSNeverKeyword");
  function D7(e, t) {
    return !e || e.type !== "TSNullKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(D7, "isTSNullKeyword");
  function _7(e, t) {
    return !e || e.type !== "TSNumberKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(_7, "isTSNumberKeyword");
  function I7(e, t) {
    return !e || e.type !== "TSObjectKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(I7, "isTSObjectKeyword");
  function O7(e, t) {
    return !e || e.type !== "TSStringKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(O7, "isTSStringKeyword");
  function N7(e, t) {
    return !e || e.type !== "TSSymbolKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(N7, "isTSSymbolKeyword");
  function B7(e, t) {
    return !e || e.type !== "TSUndefinedKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(B7, "isTSUndefinedKeyword");
  function k7(e, t) {
    return !e || e.type !== "TSUnknownKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(k7, "isTSUnknownKeyword");
  function F7(e, t) {
    return !e || e.type !== "TSVoidKeyword" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(F7, "isTSVoidKeyword");
  function L7(e, t) {
    return !e || e.type !== "TSThisType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(L7, "isTSThisType");
  function j7(e, t) {
    return !e || e.type !== "TSFunctionType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(j7, "isTSFunctionType");
  function M7(e, t) {
    return !e || e.type !== "TSConstructorType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(M7, "isTSConstructorType");
  function R7(e, t) {
    return !e || e.type !== "TSTypeReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(R7, "isTSTypeReference");
  function q7(e, t) {
    return !e || e.type !== "TSTypePredicate" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(q7, "isTSTypePredicate");
  function U7(e, t) {
    return !e || e.type !== "TSTypeQuery" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(U7, "isTSTypeQuery");
  function $7(e, t) {
    return !e || e.type !== "TSTypeLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i($7, "isTSTypeLiteral");
  function V7(e, t) {
    return !e || e.type !== "TSArrayType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(V7, "isTSArrayType");
  function K7(e, t) {
    return !e || e.type !== "TSTupleType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(K7, "isTSTupleType");
  function W7(e, t) {
    return !e || e.type !== "TSOptionalType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(W7, "isTSOptionalType");
  function Y7(e, t) {
    return !e || e.type !== "TSRestType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Y7, "isTSRestType");
  function H7(e, t) {
    return !e || e.type !== "TSNamedTupleMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(H7, "isTSNamedTupleMember");
  function J7(e, t) {
    return !e || e.type !== "TSUnionType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(J7, "isTSUnionType");
  function G7(e, t) {
    return !e || e.type !== "TSIntersectionType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(G7, "isTSIntersectionType");
  function X7(e, t) {
    return !e || e.type !== "TSConditionalType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(X7, "isTSConditionalType");
  function z7(e, t) {
    return !e || e.type !== "TSInferType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(z7, "isTSInferType");
  function Q7(e, t) {
    return !e || e.type !== "TSParenthesizedType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Q7, "isTSParenthesizedType");
  function Z7(e, t) {
    return !e || e.type !== "TSTypeOperator" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(Z7, "isTSTypeOperator");
  function e9(e, t) {
    return !e || e.type !== "TSIndexedAccessType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(e9, "isTSIndexedAccessType");
  function t9(e, t) {
    return !e || e.type !== "TSMappedType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(t9, "isTSMappedType");
  function r9(e, t) {
    return !e || e.type !== "TSTemplateLiteralType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(r9, "isTSTemplateLiteralType");
  function s9(e, t) {
    return !e || e.type !== "TSLiteralType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(s9, "isTSLiteralType");
  function n9(e, t) {
    return !e || e.type !== "TSExpressionWithTypeArguments" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(n9, "isTSExpressionWithTypeArguments");
  function i9(e, t) {
    return !e || e.type !== "TSInterfaceDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(i9, "isTSInterfaceDeclaration");
  function a9(e, t) {
    return !e || e.type !== "TSInterfaceBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(a9, "isTSInterfaceBody");
  function o9(e, t) {
    return !e || e.type !== "TSTypeAliasDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(o9, "isTSTypeAliasDeclaration");
  function l9(e, t) {
    return !e || e.type !== "TSInstantiationExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(l9, "isTSInstantiationExpression");
  function u9(e, t) {
    return !e || e.type !== "TSAsExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(u9, "isTSAsExpression");
  function c9(e, t) {
    return !e || e.type !== "TSSatisfiesExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(c9, "isTSSatisfiesExpression");
  function p9(e, t) {
    return !e || e.type !== "TSTypeAssertion" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(p9, "isTSTypeAssertion");
  function f9(e, t) {
    return !e || e.type !== "TSEnumBody" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(f9, "isTSEnumBody");
  function d9(e, t) {
    return !e || e.type !== "TSEnumDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(d9, "isTSEnumDeclaration");
  function h9(e, t) {
    return !e || e.type !== "TSEnumMember" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(h9, "isTSEnumMember");
  function m9(e, t) {
    return !e || e.type !== "TSModuleDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(m9, "isTSModuleDeclaration");
  function y9(e, t) {
    return !e || e.type !== "TSModuleBlock" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(y9, "isTSModuleBlock");
  function b9(e, t) {
    return !e || e.type !== "TSImportType" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(b9, "isTSImportType");
  function g9(e, t) {
    return !e || e.type !== "TSImportEqualsDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(g9, "isTSImportEqualsDeclaration");
  function T9(e, t) {
    return !e || e.type !== "TSExternalModuleReference" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(T9, "isTSExternalModuleReference");
  function x9(e, t) {
    return !e || e.type !== "TSNonNullExpression" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(x9, "isTSNonNullExpression");
  function E9(e, t) {
    return !e || e.type !== "TSExportAssignment" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(E9, "isTSExportAssignment");
  function S9(e, t) {
    return !e || e.type !== "TSNamespaceExportDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(S9, "isTSNamespaceExportDeclaration");
  function v9(e, t) {
    return !e || e.type !== "TSTypeAnnotation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(v9, "isTSTypeAnnotation");
  function P9(e, t) {
    return !e || e.type !== "TSTypeParameterInstantiation" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(P9, "isTSTypeParameterInstantiation");
  function A9(e, t) {
    return !e || e.type !== "TSTypeParameterDeclaration" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(A9, "isTSTypeParameterDeclaration");
  function C9(e, t) {
    return !e || e.type !== "TSTypeParameter" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(C9, "isTSTypeParameter");
  function w9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportExpression":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
      case "ImportAttribute":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(w9, "isStandardized");
  function D9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ImportExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(D9, "isExpression");
  function _9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(_9, "isBinary");
  function I9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(I9, "isScopable");
  function O9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(O9, "isBlockParent");
  function N9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if (e.expectedNode === "BlockStatement") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(N9, "isBlock");
  function B9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(B9, "isStatement");
  function k9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(k9, "isTerminatorless");
  function F9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(F9, "isCompletionStatement");
  function L9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(L9, "isConditional");
  function j9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(j9, "isLoop");
  function M9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(M9, "isWhile");
  function R9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(R9, "isExpressionWrapper");
  function q9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(q9, "isFor");
  function U9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(U9, "isForXStatement");
  function $9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i($9, "isFunction");
  function V9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(V9, "isFunctionParent");
  function K9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(K9, "isPureish");
  function W9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
        break;
      case "Placeholder":
        if (e.expectedNode === "Declaration") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(W9, "isDeclaration");
  function Y9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (e.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Y9, "isFunctionParameter");
  function H9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(H9, "isPatternLike");
  function J9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(J9, "isLVal");
  function G9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if (e.expectedNode === "Identifier") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(G9, "isTSEntityName");
  function X9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(X9, "isLiteral");
  function z9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if (e.expectedNode === "StringLiteral") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(z9, "isImmutable");
  function Q9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Q9, "isUserWhitespacable");
  function Z9(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(Z9, "isMethod");
  function eO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(eO, "isObjectMember");
  function tO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(tO, "isProperty");
  function rO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(rO, "isUnaryLike");
  function sO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "VoidPattern":
        break;
      case "Placeholder":
        if (e.expectedNode === "Pattern") break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(sO, "isPattern");
  function nO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(nO, "isClass");
  function zb(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(zb, "isImportOrExportDeclaration");
  function iO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(iO, "isExportDeclaration");
  function aO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(aO, "isModuleSpecifier");
  function oO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassAccessorProperty":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(oO, "isAccessor");
  function lO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(lO, "isPrivate");
  function uO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(uO, "isFlow");
  function cO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(cO, "isFlowType");
  function pO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(pO, "isFlowBaseAnnotation");
  function fO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(fO, "isFlowDeclaration");
  function dO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(dO, "isFlowPredicate");
  function hO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(hO, "isEnumBody");
  function mO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(mO, "isEnumMember");
  function yO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(yO, "isJSX");
  function bO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(bO, "isMiscellaneous");
  function gO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumBody":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(gO, "isTypeScript");
  function TO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(TO, "isTSTypeElement");
  function xO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(xO, "isTSType");
  function EO(e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSTemplateLiteralType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return t == null || (0, A.default)(e, t);
  }
  i(EO, "isTSBaseType");
  function SO(e, t) {
    return (0, wa.default)("isNumberLiteral", "isNumericLiteral"), !e || e.type !== "NumberLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(SO, "isNumberLiteral");
  function vO(e, t) {
    return (0, wa.default)("isRegexLiteral", "isRegExpLiteral"), !e || e.type !== "RegexLiteral" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(vO, "isRegexLiteral");
  function PO(e, t) {
    return (0, wa.default)("isRestProperty", "isRestElement"), !e || e.type !== "RestProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(PO, "isRestProperty");
  function AO(e, t) {
    return (0, wa.default)("isSpreadProperty", "isSpreadElement"), !e || e.type !== "SpreadProperty" ? !1 : t == null || (0, A.default)(e, t);
  }
  i(AO, "isSpreadProperty");
  function CO(e, t) {
    return (0, wa.default)("isModuleDeclaration", "isImportOrExportDeclaration"), zb(e, t);
  }
  i(CO, "isModuleDeclaration");
});

// ../node_modules/@babel/types/lib/validators/matchesPattern.js
var uf = D((lf) => {
  "use strict";
  Object.defineProperty(lf, "__esModule", {
    value: !0
  });
  lf.default = wO;
  var Pn = ze();
  function Qb(e) {
    return (0, Pn.isMemberExpression)(e) || (0, Pn.isMetaProperty)(e);
  }
  i(Qb, "isMemberExpressionLike");
  function wO(e, t, r) {
    if (!Qb(e)) return !1;
    let s = Array.isArray(t) ? t : t.split("."), n = [], a;
    for (a = e; Qb(a); a = (o = a.object) != null ? o : a.meta) {
      var o;
      n.push(a.property);
    }
    if (n.push(a), n.length < s.length || !r && n.length > s.length) return !1;
    for (let l = 0, u = n.length - 1; l < s.length; l++, u--) {
      let c = n[u], p;
      if ((0, Pn.isIdentifier)(c))
        p = c.name;
      else if ((0, Pn.isStringLiteral)(c))
        p = c.value;
      else if ((0, Pn.isThisExpression)(c))
        p = "this";
      else if ((0, Pn.isSuper)(c))
        p = "super";
      else if ((0, Pn.isPrivateName)(c))
        p = "#" + c.id.name;
      else
        return !1;
      if (s[l] !== p) return !1;
    }
    return !0;
  }
  i(wO, "matchesPattern");
});

// ../node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var pf = D((cf) => {
  "use strict";
  Object.defineProperty(cf, "__esModule", {
    value: !0
  });
  cf.default = _O;
  var DO = uf();
  function _O(e, t) {
    let r = e.split(".");
    return (s) => (0, DO.default)(s, r, t);
  }
  i(_O, "buildMatchMemberExpression");
});

// ../node_modules/@babel/types/lib/validators/react/isReactComponent.js
var Zb = D((yl) => {
  "use strict";
  Object.defineProperty(yl, "__esModule", {
    value: !0
  });
  yl.default = void 0;
  var IO = pf(), OO = (0, IO.default)("React.Component"), tTe = yl.default = OO;
});

// ../node_modules/@babel/types/lib/validators/react/isCompatTag.js
var eg = D((ff) => {
  "use strict";
  Object.defineProperty(ff, "__esModule", {
    value: !0
  });
  ff.default = NO;
  function NO(e) {
    return !!e && /^[a-z]/.test(e);
  }
  i(NO, "isCompatTag");
});

// ../node_modules/@babel/types/lib/validators/isType.js
var bl = D((df) => {
  "use strict";
  Object.defineProperty(df, "__esModule", {
    value: !0
  });
  df.default = BO;
  var tg = dr();
  function BO(e, t) {
    if (e === t) return !0;
    if (e == null || tg.ALIAS_KEYS[t]) return !1;
    let r = tg.FLIPPED_ALIAS_KEYS[t];
    return !!(r != null && r.includes(e));
  }
  i(BO, "isType");
});

// ../node_modules/@babel/types/lib/validators/isPlaceholderType.js
var mf = D((hf) => {
  "use strict";
  Object.defineProperty(hf, "__esModule", {
    value: !0
  });
  hf.default = FO;
  var kO = dr();
  function FO(e, t) {
    if (e === t) return !0;
    let r = kO.PLACEHOLDERS_ALIAS[e];
    return !!(r != null && r.includes(t));
  }
  i(FO, "isPlaceholderType");
});

// ../node_modules/@babel/types/lib/validators/is.js
var yi = D((yf) => {
  "use strict";
  Object.defineProperty(yf, "__esModule", {
    value: !0
  });
  yf.default = qO;
  var LO = ml(), jO = bl(), MO = mf(), RO = dr();
  function qO(e, t, r) {
    return t ? (0, jO.default)(t.type, e) ? r === void 0 ? !0 : (0, LO.default)(t, r) : !r && t.type === "Placeholder" && e in RO.FLIPPED_ALIAS_KEYS ?
    (0, MO.default)(t.expectedNode, e) : !1 : !1;
  }
  i(qO, "is");
});

// ../node_modules/@babel/helper-validator-identifier/lib/identifier.js
var ag = D((Da) => {
  "use strict";
  Object.defineProperty(Da, "__esModule", {
    value: !0
  });
  Da.isIdentifierChar = ig;
  Da.isIdentifierName = KO;
  Da.isIdentifierStart = ng;
  var gf = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088F\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5C\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92\
-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDC-\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\
\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00\
-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\
\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7DC\uA7F1-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\
\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  rg = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ADD\u1AE0-\u1AEB\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0\
-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00\
-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", UO = new RegExp("[" + gf + "]"), $O = new RegExp("[" + gf + rg + "]");
  gf = rg = null;
  var sg = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28,
  36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21,
  43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20,
  1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0,
  2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0,
  3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0,
  50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637,
  96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24,
  3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395,
  2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0,
  4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322,
  29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26,
  2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2,
  3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489], VO = [509,
  0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14,
  32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7,
  3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214,
  6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0,
  29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2,
  1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470,
  0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15,
  0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0,
  475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function bf(e, t) {
    let r = 65536;
    for (let s = 0, n = t.length; s < n; s += 2) {
      if (r += t[s], r > e) return !1;
      if (r += t[s + 1], r >= e) return !0;
    }
    return !1;
  }
  i(bf, "isInAstralSet");
  function ng(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && UO.test(String.fromCharCode(e)) :
    bf(e, sg);
  }
  i(ng, "isIdentifierStart");
  function ig(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && $O.test(
    String.fromCharCode(e)) : bf(e, sg) || bf(e, VO);
  }
  i(ig, "isIdentifierChar");
  function KO(e) {
    let t = !0;
    for (let r = 0; r < e.length; r++) {
      let s = e.charCodeAt(r);
      if ((s & 64512) === 55296 && r + 1 < e.length) {
        let n = e.charCodeAt(++r);
        (n & 64512) === 56320 && (s = 65536 + ((s & 1023) << 10) + (n & 1023));
      }
      if (t) {
        if (t = !1, !ng(s))
          return !1;
      } else if (!ig(s))
        return !1;
    }
    return !t;
  }
  i(KO, "isIdentifierName");
});

// ../node_modules/@babel/helper-validator-identifier/lib/keyword.js
var cg = D((An) => {
  "use strict";
  Object.defineProperty(An, "__esModule", {
    value: !0
  });
  An.isKeyword = GO;
  An.isReservedWord = og;
  An.isStrictBindOnlyReservedWord = ug;
  An.isStrictBindReservedWord = JO;
  An.isStrictReservedWord = lg;
  var Tf = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, WO = new Set(Tf.keyword), YO = new Set(Tf.strict), HO = new Set(Tf.strictBind);
  function og(e, t) {
    return t && e === "await" || e === "enum";
  }
  i(og, "isReservedWord");
  function lg(e, t) {
    return og(e, t) || YO.has(e);
  }
  i(lg, "isStrictReservedWord");
  function ug(e) {
    return HO.has(e);
  }
  i(ug, "isStrictBindOnlyReservedWord");
  function JO(e, t) {
    return lg(e, t) || ug(e);
  }
  i(JO, "isStrictBindReservedWord");
  function GO(e) {
    return WO.has(e);
  }
  i(GO, "isKeyword");
});

// ../node_modules/@babel/helper-validator-identifier/lib/index.js
var bi = D((Zr) => {
  "use strict";
  Object.defineProperty(Zr, "__esModule", {
    value: !0
  });
  Object.defineProperty(Zr, "isIdentifierChar", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return xf.isIdentifierChar;
    }, "get")
  });
  Object.defineProperty(Zr, "isIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return xf.isIdentifierName;
    }, "get")
  });
  Object.defineProperty(Zr, "isIdentifierStart", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return xf.isIdentifierStart;
    }, "get")
  });
  Object.defineProperty(Zr, "isKeyword", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return _a.isKeyword;
    }, "get")
  });
  Object.defineProperty(Zr, "isReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return _a.isReservedWord;
    }, "get")
  });
  Object.defineProperty(Zr, "isStrictBindOnlyReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return _a.isStrictBindOnlyReservedWord;
    }, "get")
  });
  Object.defineProperty(Zr, "isStrictBindReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return _a.isStrictBindReservedWord;
    }, "get")
  });
  Object.defineProperty(Zr, "isStrictReservedWord", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return _a.isStrictReservedWord;
    }, "get")
  });
  var xf = ag(), _a = cg();
});

// ../node_modules/@babel/types/lib/validators/isValidIdentifier.js
var gi = D((Sf) => {
  "use strict";
  Object.defineProperty(Sf, "__esModule", {
    value: !0
  });
  Sf.default = XO;
  var Ef = bi();
  function XO(e, t = !0) {
    return typeof e != "string" || t && ((0, Ef.isKeyword)(e) || (0, Ef.isStrictReservedWord)(e, !0)) ? !1 : (0, Ef.isIdentifierName)(e);
  }
  i(XO, "isValidIdentifier");
});

// ../node_modules/@babel/helper-string-parser/lib/index.js
var hg = D((Ia) => {
  "use strict";
  Object.defineProperty(Ia, "__esModule", {
    value: !0
  });
  Ia.readCodePoint = dg;
  Ia.readInt = fg;
  Ia.readStringContents = QO;
  var zO = /* @__PURE__ */ i(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), pg = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, gl = {
    bin: /* @__PURE__ */ i((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ i((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ i((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ i((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function QO(e, t, r, s, n, a) {
    let o = r, l = s, u = n, c = "", p = null, f = r, {
      length: h
    } = t;
    for (; ; ) {
      if (r >= h) {
        a.unterminated(o, l, u), c += t.slice(f, r);
        break;
      }
      let b = t.charCodeAt(r);
      if (ZO(e, b, t, r)) {
        c += t.slice(f, r);
        break;
      }
      if (b === 92) {
        c += t.slice(f, r);
        let T = eN(t, r, s, n, e === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: n
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: n
        } = T, f = r;
      } else b === 8232 || b === 8233 ? (++r, ++n, s = r) : b === 10 || b === 13 ? e === "template" ? (c += t.slice(f, r) + `
`, ++r, b === 13 && t.charCodeAt(r) === 10 && ++r, ++n, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: n,
      containsInvalid: !!p
    };
  }
  i(QO, "readStringContents");
  function ZO(e, t, r, s) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(s + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  i(ZO, "isStringEnd");
  function eN(e, t, r, s, n, a) {
    let o = !n;
    t++;
    let l = /* @__PURE__ */ i((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = e.charCodeAt(t++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = vf(e, t, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = dg(e, t, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(t - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = t - 1, f = /^[0-7]+/.exec(e.slice(c, t + 2))[0], h = parseInt(f, 8);
          h > 255 && (f = f.slice(0, -1), h = parseInt(f, 8)), t += f.length - 1;
          let b = e.charCodeAt(t);
          if (f !== "0" || b === 56 || b === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(h));
        }
        return l(String.fromCharCode(u));
    }
  }
  i(eN, "readEscapedChar");
  function vf(e, t, r, s, n, a, o, l) {
    let u = t, c;
    return {
      n: c,
      pos: t
    } = fg(e, t, r, s, 16, n, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : t = u - 1), {
      code: c,
      pos: t
    };
  }
  i(vf, "readHexChar");
  function fg(e, t, r, s, n, a, o, l, u, c) {
    let p = t, f = n === 16 ? pg.hex : pg.decBinOct, h = n === 16 ? gl.hex : n === 10 ? gl.dec : n === 8 ? gl.oct : gl.bin, b = !1, T = 0;
    for (let d = 0, g = a ?? 1 / 0; d < g; ++d) {
      let E = e.charCodeAt(t), _;
      if (E === 95 && l !== "bail") {
        let N = e.charCodeAt(t - 1), k = e.charCodeAt(t + 1);
        if (l) {
          if (Number.isNaN(k) || !h(k) || f.has(N) || f.has(k)) {
            if (c) return {
              n: null,
              pos: t
            };
            u.unexpectedNumericSeparator(t, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          u.numericSeparatorInEscapeSequence(t, r, s);
        }
        ++t;
        continue;
      }
      if (E >= 97 ? _ = E - 97 + 10 : E >= 65 ? _ = E - 65 + 10 : zO(E) ? _ = E - 48 : _ = 1 / 0, _ >= n) {
        if (_ <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (_ <= 9 && u.invalidDigit(t, r, s, n))
          _ = 0;
        else if (o)
          _ = 0, b = !0;
        else
          break;
      }
      ++t, T = T * n + _;
    }
    return t === p || a != null && t - p !== a || b ? {
      n: null,
      pos: t
    } : {
      n: T,
      pos: t
    };
  }
  i(fg, "readInt");
  function dg(e, t, r, s, n, a) {
    let o = e.charCodeAt(t), l;
    if (o === 123) {
      if (++t, {
        code: l,
        pos: t
      } = vf(e, t, r, s, e.indexOf("}", t) - t, !0, n, a), ++t, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(t, r, s);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: l,
        pos: t
      } = vf(e, t, r, s, 4, !1, n, a));
    return {
      code: l,
      pos: t
    };
  }
  i(dg, "readCodePoint");
});

// ../node_modules/@babel/types/lib/constants/index.js
var Ti = D((ye) => {
  "use strict";
  Object.defineProperty(ye, "__esModule", {
    value: !0
  });
  ye.UPDATE_OPERATORS = ye.UNARY_OPERATORS = ye.STRING_UNARY_OPERATORS = ye.STATEMENT_OR_BLOCK_KEYS = ye.NUMBER_UNARY_OPERATORS = ye.NUMBER_BINARY_OPERATORS =
  ye.LOGICAL_OPERATORS = ye.INHERIT_KEYS = ye.FOR_INIT_KEYS = ye.FLATTENABLE_KEYS = ye.EQUALITY_BINARY_OPERATORS = ye.COMPARISON_BINARY_OPERATORS =
  ye.COMMENT_KEYS = ye.BOOLEAN_UNARY_OPERATORS = ye.BOOLEAN_NUMBER_BINARY_OPERATORS = ye.BOOLEAN_BINARY_OPERATORS = ye.BINARY_OPERATORS = ye.
  ASSIGNMENT_OPERATORS = void 0;
  var ETe = ye.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], STe = ye.FLATTENABLE_KEYS = ["body", "expressions"], vTe = ye.
  FOR_INIT_KEYS = ["left", "init"], PTe = ye.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"], tN = ye.LOGICAL_OPERATORS =
  ["||", "&&", "??"], ATe = ye.UPDATE_OPERATORS = ["++", "--"], rN = ye.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="], sN = ye.EQUALITY_BINARY_OPERATORS =
  ["==", "===", "!=", "!=="], nN = ye.COMPARISON_BINARY_OPERATORS = [...sN, "in", "instanceof"], iN = ye.BOOLEAN_BINARY_OPERATORS = [...nN, ...rN],
  mg = ye.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"], CTe = ye.BINARY_OPERATORS = ["+", ...mg, ...iN,
  "|>"], wTe = ye.ASSIGNMENT_OPERATORS = ["=", "+=", ...mg.map((e) => e + "="), ...tN.map((e) => e + "=")], aN = ye.BOOLEAN_UNARY_OPERATORS =
  ["delete", "!"], oN = ye.NUMBER_UNARY_OPERATORS = ["+", "-", "~"], lN = ye.STRING_UNARY_OPERATORS = ["typeof"], DTe = ye.UNARY_OPERATORS =
  ["void", "throw", ...aN, ...oN, ...lN], _Te = ye.INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  ye.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped"), ye.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local bi\
nding");
});

// ../node_modules/@babel/types/lib/definitions/utils.js
var es = D((Ee) => {
  "use strict";
  Object.defineProperty(Ee, "__esModule", {
    value: !0
  });
  Ee.allExpandedTypes = Ee.VISITOR_KEYS = Ee.NODE_UNION_SHAPES__PRIVATE = Ee.NODE_PARENT_VALIDATIONS = Ee.NODE_FIELDS = Ee.FLIPPED_ALIAS_KEYS =
  Ee.DEPRECATED_KEYS = Ee.BUILDER_KEYS = Ee.ALIAS_KEYS = void 0;
  Ee.arrayOf = bg;
  Ee.arrayOfType = gg;
  Ee.assertEach = Tg;
  Ee.assertNodeOrValueType = SN;
  Ee.assertNodeType = xl;
  Ee.assertOneOf = xN;
  Ee.assertOptionalChainStart = PN;
  Ee.assertShape = vN;
  Ee.assertValueType = wf;
  Ee.chain = xg;
  Ee.default = Eg;
  Ee.defineAliasedType = wN;
  Ee.validate = Cf;
  Ee.validateArrayOfType = TN;
  Ee.validateOptional = bN;
  Ee.validateOptionalType = gN;
  Ee.validateType = yN;
  var yg = yi(), Oa = El(), uN = Ee.VISITOR_KEYS = {}, cN = Ee.ALIAS_KEYS = {}, Pf = Ee.FLIPPED_ALIAS_KEYS = {}, pN = Ee.NODE_FIELDS = {}, fN = Ee.
  BUILDER_KEYS = {}, dN = Ee.DEPRECATED_KEYS = {}, hN = Ee.NODE_PARENT_VALIDATIONS = {}, mN = Ee.NODE_UNION_SHAPES__PRIVATE = {};
  function Tl(e) {
    return Array.isArray(e) ? "array" : e === null ? "null" : typeof e;
  }
  i(Tl, "getType");
  function Cf(e) {
    return {
      validate: e
    };
  }
  i(Cf, "validate");
  function yN(...e) {
    return Cf(xl(...e));
  }
  i(yN, "validateType");
  function bN(e) {
    return {
      validate: e,
      optional: !0
    };
  }
  i(bN, "validateOptional");
  function gN(...e) {
    return {
      validate: xl(...e),
      optional: !0
    };
  }
  i(gN, "validateOptionalType");
  function bg(e) {
    return xg(wf("array"), Tg(e));
  }
  i(bg, "arrayOf");
  function gg(...e) {
    return bg(xl(...e));
  }
  i(gg, "arrayOfType");
  function TN(...e) {
    return Cf(gg(...e));
  }
  i(TN, "validateArrayOfType");
  function Tg(e) {
    let t = process.env.BABEL_TYPES_8_BREAKING ? Oa.validateChild : () => {
    };
    function r(s, n, a) {
      if (!Array.isArray(a)) return;
      let o = 0, l = {
        toString() {
          return `${n}[${o}]`;
        }
      };
      for (; o < a.length; o++) {
        let u = a[o];
        e(s, l, u), t(s, l, u);
      }
    }
    return i(r, "validator"), r.each = e, r;
  }
  i(Tg, "assertEach");
  function xN(...e) {
    function t(r, s, n) {
      if (!e.includes(n))
        throw new TypeError(`Property ${s} expected value to be one of ${JSON.stringify(e)} but got ${JSON.stringify(n)}`);
    }
    return i(t, "validate"), t.oneOf = e, t;
  }
  i(xN, "assertOneOf");
  var EN = Ee.allExpandedTypes = [];
  function xl(...e) {
    let t = /* @__PURE__ */ new Set();
    EN.push({
      types: e,
      set: t
    });
    function r(s, n, a) {
      let o = a?.type;
      if (o != null) {
        if (t.has(o)) {
          (0, Oa.validateChild)(s, n, a);
          return;
        }
        if (o === "Placeholder") {
          for (let l of e)
            if ((0, yg.default)(l, a)) {
              (0, Oa.validateChild)(s, n, a);
              return;
            }
        }
      }
      throw new TypeError(`Property ${n} of ${s.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(o)}`);
    }
    return i(r, "validate"), r.oneOfNodeTypes = e, r;
  }
  i(xl, "assertNodeType");
  function SN(...e) {
    function t(r, s, n) {
      let a = Tl(n);
      for (let o of e)
        if (a === o || (0, yg.default)(o, n)) {
          (0, Oa.validateChild)(r, s, n);
          return;
        }
      throw new TypeError(`Property ${s} of ${r.type} expected node to be of a type ${JSON.stringify(e)} but instead got ${JSON.stringify(n?.
      type)}`);
    }
    return i(t, "validate"), t.oneOfNodeOrValueTypes = e, t;
  }
  i(SN, "assertNodeOrValueType");
  function wf(e) {
    function t(r, s, n) {
      if (Tl(n) !== e)
        throw new TypeError(`Property ${s} expected type of ${e} but got ${Tl(n)}`);
    }
    return i(t, "validate"), t.type = e, t;
  }
  i(wf, "assertValueType");
  function vN(e) {
    let t = Object.keys(e);
    function r(s, n, a) {
      let o = [];
      for (let l of t)
        try {
          (0, Oa.validateField)(s, l, a[l], e[l]);
        } catch (u) {
          if (u instanceof TypeError) {
            o.push(u.message);
            continue;
          }
          throw u;
        }
      if (o.length)
        throw new TypeError(`Property ${n} of ${s.type} expected to have the following:
${o.join(`
`)}`);
    }
    return i(r, "validate"), r.shapeOf = e, r;
  }
  i(vN, "assertShape");
  function PN() {
    function e(t) {
      var r;
      let s = t;
      for (; t; ) {
        let {
          type: n
        } = s;
        if (n === "OptionalCallExpression") {
          if (s.optional) return;
          s = s.callee;
          continue;
        }
        if (n === "OptionalMemberExpression") {
          if (s.optional) return;
          s = s.object;
          continue;
        }
        break;
      }
      throw new TypeError(`Non-optional ${t.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chai\
n from ${(r = s) == null ? void 0 : r.type}`);
    }
    return i(e, "validate"), e;
  }
  i(PN, "assertOptionalChainStart");
  function xg(...e) {
    function t(...r) {
      for (let s of e)
        s(...r);
    }
    if (i(t, "validate"), t.chainOf = e, e.length >= 2 && "type" in e[0] && e[0].type === "array" && !("each" in e[1]))
      throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
    return t;
  }
  i(xg, "chain");
  var AN = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate", "unionShape"]), CN = /* @__PURE__ */ new Set(
  ["default", "optional", "deprecated", "validate"]), Af = {};
  function wN(...e) {
    return (t, r = {}) => {
      let s = r.aliases;
      if (!s) {
        var n;
        r.inherits && (s = (n = Af[r.inherits].aliases) == null ? void 0 : n.slice()), s ?? (s = []), r.aliases = s;
      }
      let a = e.filter((o) => !s.includes(o));
      s.unshift(...a), Eg(t, r);
    };
  }
  i(wN, "defineAliasedType");
  function Eg(e, t = {}) {
    let r = t.inherits && Af[t.inherits] || {}, s = t.fields;
    if (!s && (s = {}, r.fields)) {
      let l = Object.getOwnPropertyNames(r.fields);
      for (let u of l) {
        let c = r.fields[u], p = c.default;
        if (Array.isArray(p) ? p.length > 0 : p && typeof p == "object")
          throw new Error("field defaults can only be primitives or empty arrays currently");
        s[u] = {
          default: Array.isArray(p) ? [] : p,
          optional: c.optional,
          deprecated: c.deprecated,
          validate: c.validate
        };
      }
    }
    let n = t.visitor || r.visitor || [], a = t.aliases || r.aliases || [], o = t.builder || r.builder || t.visitor || [];
    for (let l of Object.keys(t))
      if (!AN.has(l))
        throw new Error(`Unknown type option "${l}" on ${e}`);
    t.deprecatedAlias && (dN[t.deprecatedAlias] = e);
    for (let l of n.concat(o))
      s[l] = s[l] || {};
    for (let l of Object.keys(s)) {
      let u = s[l];
      u.default !== void 0 && !o.includes(l) && (u.optional = !0), u.default === void 0 ? u.default = null : !u.validate && u.default != null &&
      (u.validate = wf(Tl(u.default)));
      for (let c of Object.keys(u))
        if (!CN.has(c))
          throw new Error(`Unknown field key "${c}" on ${e}.${l}`);
    }
    uN[e] = t.visitor = n, fN[e] = t.builder = o, pN[e] = t.fields = s, cN[e] = t.aliases = a, a.forEach((l) => {
      Pf[l] = Pf[l] || [], Pf[l].push(e);
    }), t.validate && (hN[e] = t.validate), t.unionShape && (mN[e] = t.unionShape), Af[e] = t;
  }
  i(Eg, "defineType");
});

// ../node_modules/@babel/types/lib/definitions/core.js
var Ba = D((pt) => {
  "use strict";
  Object.defineProperty(pt, "__esModule", {
    value: !0
  });
  pt.patternLikeCommon = pt.importAttributes = pt.functionTypeAnnotationCommon = pt.functionDeclarationCommon = pt.functionCommon = pt.classMethodOrPropertyUnionShapeCommon =
  pt.classMethodOrPropertyCommon = pt.classMethodOrDeclareMethodCommon = void 0;
  var Ut = yi(), DN = gi(), Sg = bi(), _N = hg(), xi = Ti(), C = es(), Na = /* @__PURE__ */ i((e = !1) => ({
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [!0],
        properties: {
          key: {
            validate: (0, C.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [!1],
        properties: {
          key: {
            validate: e ? (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName") : (0, C.assertNodeType)(
            "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral")
          }
        }
      }]
    }
  }), "classMethodOrPropertyUnionShapeCommon");
  pt.classMethodOrPropertyUnionShapeCommon = Na;
  var W = (0, C.defineAliasedType)("Standardized");
  W("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, C.arrayOf)((0, C.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  W("AssignmentExpression", {
    fields: {
      operator: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function() {
          let e = (0, C.assertOneOf)(...xi.ASSIGNMENT_OPERATORS), t = (0, C.assertOneOf)("=");
          return function(r, s, n) {
            ((0, Ut.default)("Pattern", r.left) ? t : e)(r, s, n);
          };
        }(), {
          oneOf: xi.ASSIGNMENT_OPERATORS
        }) : (0, C.assertValueType)("string")
      },
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "\
ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, C.assertNodeType)(
        "LVal", "OptionalMemberExpression")
      },
      right: {
        validate: (0, C.assertNodeType)("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  W("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: (0, C.assertOneOf)(...xi.BINARY_OPERATORS)
      },
      left: {
        validate: function() {
          let e = (0, C.assertNodeType)("Expression"), t = (0, C.assertNodeType)("Expression", "PrivateName");
          return Object.assign(function(s, n, a) {
            (s.operator === "in" ? t : e)(s, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "PrivateName"]
          });
        }()
      },
      right: {
        validate: (0, C.assertNodeType)("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  W("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, C.assertValueType)("string")
      }
    }
  });
  W("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: (0, C.assertNodeType)("DirectiveLiteral")
      }
    }
  });
  W("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, C.assertValueType)("string")
      }
    }
  });
  W("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: (0, C.arrayOfType)("Directive"),
        default: []
      },
      body: (0, C.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  W("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, C.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  W("CallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, C.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
      },
      arguments: (0, C.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      typeArguments: {
        validate: (0, C.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      typeParameters: {
        validate: (0, C.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  W("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: (0, C.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: !0
      },
      body: {
        validate: (0, C.assertNodeType)("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  W("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: (0, C.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, C.assertNodeType)("Expression")
      },
      alternate: {
        validate: (0, C.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  W("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: (0, C.assertNodeType)("Identifier"),
        optional: !0
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  W("DebuggerStatement", {
    aliases: ["Statement"]
  });
  W("DoWhileStatement", {
    builder: ["test", "body"],
    visitor: ["body", "test"],
    fields: {
      test: {
        validate: (0, C.assertNodeType)("Expression")
      },
      body: {
        validate: (0, C.assertNodeType)("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  W("EmptyStatement", {
    aliases: ["Statement"]
  });
  W("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, C.assertNodeType)("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  W("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: (0, C.assertNodeType)("Program")
      },
      comments: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertEach)((0, C.assertNodeType)("CommentBlock", "CommentLine")) : Object.assign(
        () => {
        }, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }),
        optional: !0
      },
      tokens: {
        validate: (0, C.assertEach)(Object.assign(() => {
        }, {
          type: "any"
        })),
        optional: !0
      }
    }
  });
  W("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "Array\
Pattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, C.assertNodeType)("Var\
iableDeclaration", "LVal")
      },
      right: {
        validate: (0, C.assertNodeType)("Expression")
      },
      body: {
        validate: (0, C.assertNodeType)("Statement")
      }
    }
  });
  W("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: (0, C.assertNodeType)("VariableDeclaration", "Expression"),
        optional: !0
      },
      test: {
        validate: (0, C.assertNodeType)("Expression"),
        optional: !0
      },
      update: {
        validate: (0, C.assertNodeType)("Expression"),
        optional: !0
      },
      body: {
        validate: (0, C.assertNodeType)("Statement")
      }
    }
  });
  var Ei = /* @__PURE__ */ i(() => ({
    params: (0, C.validateArrayOfType)("FunctionParameter"),
    generator: {
      default: !1
    },
    async: {
      default: !1
    }
  }), "functionCommon");
  pt.functionCommon = Ei;
  var Cn = /* @__PURE__ */ i(() => ({
    returnType: {
      validate: (0, C.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, C.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "functionTypeAnnotationCommon");
  pt.functionTypeAnnotationCommon = Cn;
  var vg = /* @__PURE__ */ i(() => Object.assign({}, Ei(), {
    declare: {
      validate: (0, C.assertValueType)("boolean"),
      optional: !0
    },
    id: {
      validate: (0, C.assertNodeType)("Identifier"),
      optional: !0
    }
  }), "functionDeclarationCommon");
  pt.functionDeclarationCommon = vg;
  W("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
    fields: Object.assign({}, vg(), Cn(), {
      body: {
        validate: (0, C.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, C.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let e = (0, C.assertNodeType)("Identifier");
      return function(t, r, s) {
        (0, Ut.default)("ExportDefaultDeclaration", t) || e(s, "id", s.id);
      };
    }() : void 0
  });
  W("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Ei(), Cn(), {
      id: {
        validate: (0, C.assertNodeType)("Identifier"),
        optional: !0
      },
      body: {
        validate: (0, C.assertNodeType)("BlockStatement")
      },
      predicate: {
        validate: (0, C.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  var Si = /* @__PURE__ */ i(() => ({
    typeAnnotation: {
      validate: (0, C.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: !0
    },
    optional: {
      validate: (0, C.assertValueType)("boolean"),
      optional: !0
    },
    decorators: {
      validate: (0, C.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "patternLikeCommon");
  pt.patternLikeCommon = Si;
  W("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "FunctionParameter", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, Si(), {
      name: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("string"), Object.assign(function(e, t, r) {
          if (!(0, DN.default)(r, !1))
            throw new TypeError(`"${r}" is not a valid identifier name`);
        }, {
          type: "string"
        })) : (0, C.assertValueType)("string")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(e, t, r) {
      let s = /\.(\w+)$/.exec(t.toString());
      if (!s) return;
      let [, n] = s, a = {
        computed: !1
      };
      if (n === "property") {
        if ((0, Ut.default)("MemberExpression", e, a) || (0, Ut.default)("OptionalMemberExpression", e, a)) return;
      } else if (n === "key") {
        if ((0, Ut.default)("Property", e, a) || (0, Ut.default)("Method", e, a)) return;
      } else if (n === "exported") {
        if ((0, Ut.default)("ExportSpecifier", e)) return;
      } else if (n === "imported") {
        if ((0, Ut.default)("ImportSpecifier", e, {
          imported: r
        })) return;
      } else if (n === "meta" && (0, Ut.default)("MetaProperty", e, {
        meta: r
      }))
        return;
      if (((0, Sg.isKeyword)(r.name) || (0, Sg.isReservedWord)(r.name, !1)) && r.name !== "this")
        throw new TypeError(`"${r.name}" is not a valid identifier`);
    } : void 0
  });
  W("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: (0, C.assertNodeType)("Expression")
      },
      consequent: {
        validate: (0, C.assertNodeType)("Statement")
      },
      alternate: {
        optional: !0,
        validate: (0, C.assertNodeType)("Statement")
      }
    }
  });
  W("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: (0, C.assertNodeType)("Identifier")
      },
      body: {
        validate: (0, C.assertNodeType)("Statement")
      }
    }
  });
  W("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, C.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  W("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: (0, C.chain)((0, C.assertValueType)("number"), Object.assign(function(e, t, r) {
          if (1 / r < 0 || !Number.isFinite(r)) {
            let s = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${r}) instead.`);
          }
        }, {
          type: "number"
        }))
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  W("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  W("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, C.assertValueType)("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  W("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: (0, C.assertValueType)("string")
      },
      flags: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("string"), Object.assign(function(e, t, r) {
          let s = /[^dgimsuvy]/.exec(r);
          if (s)
            throw new TypeError(`"${s[0]}" is not a valid RegExp flag`);
        }, {
          type: "string"
        })) : (0, C.assertValueType)("string"),
        default: ""
      }
    }
  });
  W("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: (0, C.assertOneOf)(...xi.LOGICAL_OPERATORS)
      },
      left: {
        validate: (0, C.assertNodeType)("Expression")
      },
      right: {
        validate: (0, C.assertNodeType)("Expression")
      }
    }
  });
  W("MemberExpression", {
    builder: ["object", "property", "computed", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"]],
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal", "PatternLike"],
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [!0],
        properties: {
          property: {
            validate: (0, C.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [!1],
        properties: {
          property: {
            validate: (0, C.assertNodeType)("Identifier", "PrivateName")
          }
        }
      }]
    },
    fields: Object.assign({
      object: {
        validate: (0, C.assertNodeType)("Expression", "Super")
      },
      property: {
        validate: function() {
          let e = (0, C.assertNodeType)("Identifier", "PrivateName"), t = (0, C.assertNodeType)("Expression"), r = /* @__PURE__ */ i(function(s, n, a) {
            (s.computed ? t : e)(s, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r;
        }()
      },
      computed: {
        default: !1
      }
    }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
      optional: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  W("NewExpression", {
    inherits: "CallExpression"
  });
  W("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceType: {
        validate: (0, C.assertOneOf)("script", "module"),
        default: "script"
      },
      interpreter: {
        validate: (0, C.assertNodeType)("InterpreterDirective"),
        default: null,
        optional: !0
      },
      directives: {
        validate: (0, C.arrayOfType)("Directive"),
        default: []
      },
      body: (0, C.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  W("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, C.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
    }
  });
  W("ObjectMethod", Object.assign({
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
  }, Na(), {
    fields: Object.assign({}, Ei(), Cn(), {
      kind: Object.assign({
        validate: (0, C.assertOneOf)("method", "get", "set")
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        default: "method"
      }),
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, C.assertNodeType)("Expres\
sion"), r = /* @__PURE__ */ i(function(s, n, a) {
            (s.computed ? t : e)(s, n, a);
          }, "validator");
          return r.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"], r;
        }()
      },
      decorators: {
        validate: (0, C.arrayOfType)("Decorator"),
        optional: !0
      },
      body: {
        validate: (0, C.assertNodeType)("BlockStatement")
      }
    }),
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  }));
  W("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand", ...process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"]],
    unionShape: {
      discriminator: "computed",
      shapes: [{
        name: "computed",
        value: [!0],
        properties: {
          key: {
            validate: (0, C.assertNodeType)("Expression")
          }
        }
      }, {
        name: "nonComputed",
        value: [!1],
        properties: {
          key: {
            validate: (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName")
          }
        }
      }]
    },
    fields: {
      computed: {
        default: !1
      },
      key: {
        validate: function() {
          let e = (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"), t = (0, C.
          assertNodeType)("Expression");
          return Object.assign(function(s, n, a) {
            (s.computed ? t : e)(s, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
          });
        }()
      },
      value: {
        validate: (0, C.assertNodeType)("Expression", "PatternLike")
      },
      shorthand: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (r) {
            if (e.computed)
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            if (!(0, Ut.default)("Identifier", e.key))
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }, {
          type: "boolean"
        })) : (0, C.assertValueType)("boolean"),
        default: !1
      },
      decorators: {
        validate: (0, C.arrayOfType)("Decorator"),
        optional: !0
      }
    },
    visitor: ["decorators", "key", "value"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let e = (0, C.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssert\
ion"), t = (0, C.assertNodeType)("Expression");
      return function(r, s, n) {
        ((0, Ut.default)("ObjectPattern", r) ? e : t)(n, "value", n.value);
      };
    }() : void 0
  });
  W("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["FunctionParameter", "PatternLike", "LVal"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, Si(), {
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpressio\
n", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression") : (0, C.assertNodeType)("Identifier", "ArrayPattern",
        "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression", "RestEleme\
nt", "AssignmentPattern")
      }
    }),
    validate: process.env.BABEL_TYPES_8_BREAKING ? function(e, t) {
      let r = /(\w+)\[(\d+)\]/.exec(t.toString());
      if (!r) throw new Error("Internal Babel error: malformed key.");
      let [, s, n] = r;
      if (e[s].length > +n + 1)
        throw new TypeError(`RestElement must be last element of ${s}`);
    } : void 0
  });
  W("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, C.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  W("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: (0, C.validateArrayOfType)("Expression")
    },
    aliases: ["Expression"]
  });
  W("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: (0, C.assertNodeType)("Expression")
      }
    }
  });
  W("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: (0, C.assertNodeType)("Expression"),
        optional: !0
      },
      consequent: (0, C.validateArrayOfType)("Statement")
    }
  });
  W("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: (0, C.assertNodeType)("Expression")
      },
      cases: (0, C.validateArrayOfType)("SwitchCase")
    }
  });
  W("ThisExpression", {
    aliases: ["Expression"]
  });
  W("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: (0, C.assertNodeType)("Expression")
      }
    }
  });
  W("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertNodeType)("BlockStatement"), Object.assign(function(e) {
          if (!e.handler && !e.finalizer)
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        })) : (0, C.assertNodeType)("BlockStatement")
      },
      handler: {
        optional: !0,
        validate: (0, C.assertNodeType)("CatchClause")
      },
      finalizer: {
        optional: !0,
        validate: (0, C.assertNodeType)("BlockStatement")
      }
    }
  });
  W("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !0
      },
      argument: {
        validate: (0, C.assertNodeType)("Expression")
      },
      operator: {
        validate: (0, C.assertOneOf)(...xi.UNARY_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  W("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        default: !1
      },
      argument: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertNodeType)("Identifier", "MemberExpression") : (0, C.assertNodeType)("Expr\
ession")
      },
      operator: {
        validate: (0, C.assertOneOf)(...xi.UPDATE_OPERATORS)
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  W("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      kind: {
        validate: (0, C.assertOneOf)("var", "let", "const", "using", "await using")
      },
      declarations: (0, C.validateArrayOfType)("VariableDeclarator")
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
      let e = (0, C.assertNodeType)("Identifier", "Placeholder"), t = (0, C.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "\
Placeholder"), r = (0, C.assertNodeType)("Identifier", "VoidPattern", "Placeholder");
      return function(s, n, a) {
        let {
          kind: o,
          declarations: l
        } = a, u = (0, Ut.default)("ForXStatement", s, {
          left: a
        });
        if (u && l.length !== 1)
          throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${s.type}`);
        for (let c of l)
          o === "const" || o === "let" || o === "var" ? !u && !c.init ? e(c, "id", c.id) : t(c, "id", c.id) : r(c, "id", c.id);
      };
    })() : void 0
  });
  W("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "VoidPattern") :
        (0, C.assertNodeType)("LVal", "VoidPattern")
      },
      definite: {
        optional: !0,
        validate: (0, C.assertValueType)("boolean")
      },
      init: {
        optional: !0,
        validate: (0, C.assertNodeType)("Expression")
      }
    }
  });
  W("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: (0, C.assertNodeType)("Expression")
      },
      body: {
        validate: (0, C.assertNodeType)("Statement")
      }
    }
  });
  W("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: (0, C.assertNodeType)("Expression")
      },
      body: {
        validate: (0, C.assertNodeType)("Statement")
      }
    }
  });
  W("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, Si(), {
      left: {
        validate: (0, C.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExp\
ression", "TSTypeAssertion", "TSNonNullExpression")
      },
      right: {
        validate: (0, C.assertNodeType)("Expression")
      },
      decorators: {
        validate: (0, C.arrayOfType)("Decorator"),
        optional: !0
      }
    })
  });
  W("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, Si(), {
      elements: {
        validate: (0, C.chain)((0, C.assertValueType)("array"), (0, C.assertEach)((0, C.assertNodeOrValueType)("null", "PatternLike")))
      }
    })
  });
  W("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, Ei(), Cn(), {
      expression: {
        validate: (0, C.assertValueType)("boolean")
      },
      body: {
        validate: (0, C.assertNodeType)("BlockStatement", "Expression")
      },
      predicate: {
        validate: (0, C.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
        optional: !0
      }
    })
  });
  W("ClassBody", {
    visitor: ["body"],
    fields: {
      body: (0, C.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty",
      "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
    }
  });
  W("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: (0, C.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, C.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, C.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, C.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, C.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, C.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, C.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, C.assertNodeType)("InterfaceExtends"),
        optional: !0
      }
    }
  });
  W("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: (0, C.assertNodeType)("Identifier"),
        optional: !0
      },
      typeParameters: {
        validate: (0, C.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: !0
      },
      body: {
        validate: (0, C.assertNodeType)("ClassBody")
      },
      superClass: {
        optional: !0,
        validate: (0, C.assertNodeType)("Expression")
      },
      superTypeParameters: {
        validate: (0, C.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      },
      implements: {
        validate: (0, C.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
        optional: !0
      },
      decorators: {
        validate: (0, C.arrayOfType)("Decorator"),
        optional: !0
      },
      mixins: {
        validate: (0, C.assertNodeType)("InterfaceExtends"),
        optional: !0
      },
      declare: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      abstract: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      }
    },
    validate: process.env.BABEL_TYPES_8_BREAKING ? function() {
      let e = (0, C.assertNodeType)("Identifier");
      return function(t, r, s) {
        (0, Ut.default)("ExportDefaultDeclaration", t) || e(s, "id", s.id);
      };
    }() : void 0
  });
  var Df = pt.importAttributes = {
    attributes: {
      optional: !0,
      validate: (0, C.arrayOfType)("ImportAttribute")
    },
    assertions: {
      deprecated: !0,
      optional: !0,
      validate: (0, C.arrayOfType)("ImportAttribute")
    }
  };
  W("ExportAllDeclaration", {
    builder: ["source"],
    visitor: ["source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      source: {
        validate: (0, C.assertNodeType)("StringLiteral")
      },
      exportKind: (0, C.validateOptional)((0, C.assertOneOf)("type", "value"))
    }, Df)
  });
  W("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: {
      declaration: (0, C.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
      exportKind: (0, C.validateOptional)((0, C.assertOneOf)("value"))
    }
  });
  W("ExportNamedDeclaration", {
    builder: ["declaration", "specifiers", "source"],
    visitor: ["declaration", "specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
    fields: Object.assign({
      declaration: {
        optional: !0,
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertNodeType)("Declaration"), Object.assign(function(e, t, r) {
          if (r && e.specifiers.length)
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          if (r && e.source)
            throw new TypeError("Cannot export a declaration from a source");
        }, {
          oneOfNodeTypes: ["Declaration"]
        })) : (0, C.assertNodeType)("Declaration")
      }
    }, Df, {
      specifiers: {
        default: [],
        validate: (0, C.arrayOf)(function() {
          let e = (0, C.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"), t = (0, C.assertNodeType)(
          "ExportSpecifier");
          return process.env.BABEL_TYPES_8_BREAKING ? Object.assign(function(r, s, n) {
            (r.source ? e : t)(r, s, n);
          }, {
            oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
          }) : e;
        }())
      },
      source: {
        validate: (0, C.assertNodeType)("StringLiteral"),
        optional: !0
      },
      exportKind: (0, C.validateOptional)((0, C.assertOneOf)("type", "value"))
    })
  });
  W("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, C.assertNodeType)("Identifier")
      },
      exported: {
        validate: (0, C.assertNodeType)("Identifier", "StringLiteral")
      },
      exportKind: {
        validate: (0, C.assertOneOf)("type", "value"),
        optional: !0
      }
    }
  });
  W("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function() {
          if (!process.env.BABEL_TYPES_8_BREAKING)
            return (0, C.assertNodeType)("VariableDeclaration", "LVal");
          let e = (0, C.assertNodeType)("VariableDeclaration"), t = (0, C.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "\
ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
          return Object.assign(function(r, s, n) {
            (0, Ut.default)("VariableDeclaration", n) ? e(r, s, n) : t(r, s, n);
          }, {
            oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TS\
SatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
          });
        }()
      },
      right: {
        validate: (0, C.assertNodeType)("Expression")
      },
      body: {
        validate: (0, C.assertNodeType)("Statement")
      },
      await: {
        default: !1
      }
    }
  });
  W("ImportDeclaration", {
    builder: ["specifiers", "source"],
    visitor: ["specifiers", "source", "attributes", "assertions"],
    aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
    fields: Object.assign({}, Df, {
      module: {
        optional: !0,
        validate: (0, C.assertValueType)("boolean")
      },
      phase: {
        default: null,
        validate: (0, C.assertOneOf)("source", "defer")
      },
      specifiers: (0, C.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
      source: {
        validate: (0, C.assertNodeType)("StringLiteral")
      },
      importKind: {
        validate: (0, C.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    })
  });
  W("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, C.assertNodeType)("Identifier")
      }
    }
  });
  W("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, C.assertNodeType)("Identifier")
      }
    }
  });
  W("ImportSpecifier", {
    visitor: ["imported", "local"],
    builder: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: (0, C.assertNodeType)("Identifier")
      },
      imported: {
        validate: (0, C.assertNodeType)("Identifier", "StringLiteral")
      },
      importKind: {
        validate: (0, C.assertOneOf)("type", "typeof", "value"),
        optional: !0
      }
    }
  });
  W("ImportExpression", {
    visitor: ["source", "options"],
    aliases: ["Expression"],
    fields: {
      phase: {
        default: null,
        validate: (0, C.assertOneOf)("source", "defer")
      },
      source: {
        validate: (0, C.assertNodeType)("Expression")
      },
      options: {
        validate: (0, C.assertNodeType)("Expression"),
        optional: !0
      }
    }
  });
  W("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertNodeType)("Identifier"), Object.assign(function(e, t, r) {
          let s;
          switch (r.name) {
            case "function":
              s = "sent";
              break;
            case "new":
              s = "target";
              break;
            case "import":
              s = "meta";
              break;
          }
          if (!(0, Ut.default)("Identifier", e.property, {
            name: s
          }))
            throw new TypeError("Unrecognised MetaProperty");
        }, {
          oneOfNodeTypes: ["Identifier"]
        })) : (0, C.assertNodeType)("Identifier")
      },
      property: {
        validate: (0, C.assertNodeType)("Identifier")
      }
    }
  });
  var Sl = /* @__PURE__ */ i(() => ({
    abstract: {
      validate: (0, C.assertValueType)("boolean"),
      optional: !0
    },
    accessibility: {
      validate: (0, C.assertOneOf)("public", "private", "protected"),
      optional: !0
    },
    static: {
      default: !1
    },
    override: {
      default: !1
    },
    computed: {
      default: !1
    },
    optional: {
      validate: (0, C.assertValueType)("boolean"),
      optional: !0
    },
    key: {
      validate: (0, C.chain)(function() {
        let e = (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"), t = (0, C.assertNodeType)("Expressi\
on");
        return function(r, s, n) {
          (r.computed ? t : e)(r, s, n);
        };
      }(), (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
    }
  }), "classMethodOrPropertyCommon");
  pt.classMethodOrPropertyCommon = Sl;
  var _f = /* @__PURE__ */ i(() => Object.assign({}, Ei(), Sl(), {
    params: (0, C.validateArrayOfType)("FunctionParameter", "TSParameterProperty"),
    kind: {
      validate: (0, C.assertOneOf)("get", "set", "method", "constructor"),
      default: "method"
    },
    access: {
      validate: (0, C.chain)((0, C.assertValueType)("string"), (0, C.assertOneOf)("public", "private", "protected")),
      optional: !0
    },
    decorators: {
      validate: (0, C.arrayOfType)("Decorator"),
      optional: !0
    }
  }), "classMethodOrDeclareMethodCommon");
  pt.classMethodOrDeclareMethodCommon = _f;
  W("ClassMethod", Object.assign({
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"]
  }, Na(), {
    fields: Object.assign({}, _f(), Cn(), {
      body: {
        validate: (0, C.assertNodeType)("BlockStatement")
      }
    })
  }));
  W("ObjectPattern", {
    visitor: ["decorators", "properties", "typeAnnotation"],
    builder: ["properties"],
    aliases: ["FunctionParameter", "Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, Si(), {
      properties: (0, C.validateArrayOfType)("RestElement", "ObjectProperty")
    })
  });
  W("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: (0, C.assertNodeType)("Expression")
      }
    }
  });
  W("Super", {
    aliases: ["Expression"]
  });
  W("TaggedTemplateExpression", {
    visitor: ["tag", "typeParameters", "quasi"],
    builder: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: (0, C.assertNodeType)("Expression")
      },
      quasi: {
        validate: (0, C.assertNodeType)("TemplateLiteral")
      },
      typeParameters: {
        validate: (0, C.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: !0
      }
    }
  });
  W("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: (0, C.chain)((0, C.assertShape)({
          raw: {
            validate: (0, C.assertValueType)("string")
          },
          cooked: {
            validate: (0, C.assertValueType)("string"),
            optional: !0
          }
        }), /* @__PURE__ */ i(function(t) {
          let r = t.value.raw, s = !1, n = /* @__PURE__ */ i(() => {
            throw new Error("Internal @babel/types error.");
          }, "error"), {
            str: a,
            firstInvalidLoc: o
          } = (0, _N.readStringContents)("template", r, 0, 0, 0, {
            unterminated() {
              s = !0;
            },
            strictNumericEscape: n,
            invalidEscapeSequence: n,
            numericSeparatorInEscapeSequence: n,
            unexpectedNumericSeparator: n,
            invalidDigit: n,
            invalidCodePoint: n
          });
          if (!s) throw new Error("Invalid raw");
          t.value.cooked = o ? null : a;
        }, "templateElementCookedValidator"))
      },
      tail: {
        default: !1
      }
    }
  });
  W("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: (0, C.validateArrayOfType)("TemplateElement"),
      expressions: {
        validate: (0, C.chain)((0, C.assertValueType)("array"), (0, C.assertEach)((0, C.assertNodeType)("Expression", "TSType")), function(e, t, r) {
          if (e.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of expressions.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
        })
      }
    }
  });
  W("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("boolean"), Object.assign(function(e, t, r) {
          if (r && !e.argument)
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
        }, {
          type: "boolean"
        })) : (0, C.assertValueType)("boolean"),
        default: !1
      },
      argument: {
        optional: !0,
        validate: (0, C.assertNodeType)("Expression")
      }
    }
  });
  W("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: (0, C.assertNodeType)("Expression")
      }
    }
  });
  W("Import", {
    aliases: ["Expression"]
  });
  W("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, C.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  W("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, C.assertNodeType)("Identifier")
      }
    }
  });
  W("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: (0, C.assertNodeType)("Expression")
      },
      property: {
        validate: function() {
          let e = (0, C.assertNodeType)("Identifier"), t = (0, C.assertNodeType)("Expression");
          return Object.assign(function(s, n, a) {
            (s.computed ? t : e)(s, n, a);
          }, {
            oneOfNodeTypes: ["Expression", "Identifier"]
          });
        }()
      },
      computed: {
        default: !1
      },
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("boolean"), (0, C.assertOptionalChainStart)()) : (0, C.
        assertValueType)("boolean")
      }
    }
  });
  W("OptionalCallExpression", {
    visitor: ["callee", "typeParameters", "typeArguments", "arguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: (0, C.assertNodeType)("Expression")
      },
      arguments: (0, C.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
      optional: {
        validate: process.env.BABEL_TYPES_8_BREAKING ? (0, C.chain)((0, C.assertValueType)("boolean"), (0, C.assertOptionalChainStart)()) : (0, C.
        assertValueType)("boolean")
      },
      typeArguments: {
        validate: (0, C.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, C.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  W("ClassProperty", Object.assign({
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"]
  }, Na(), {
    fields: Object.assign({}, Sl(), {
      value: {
        validate: (0, C.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, C.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, C.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, C.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }));
  W("ClassAccessorProperty", Object.assign({
    visitor: ["decorators", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property", "Accessor"]
  }, Na(!0), {
    fields: Object.assign({}, Sl(), {
      key: {
        validate: (0, C.chain)(function() {
          let e = (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName"), t = (0, C.assertNodeType)(
          "Expression");
          return function(r, s, n) {
            (r.computed ? t : e)(r, s, n);
          };
        }(), (0, C.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
      },
      value: {
        validate: (0, C.assertNodeType)("Expression"),
        optional: !0
      },
      definite: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, C.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, C.arrayOfType)("Decorator"),
        optional: !0
      },
      readonly: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      declare: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, C.assertNodeType)("Variance"),
        optional: !0
      }
    })
  }));
  W("ClassPrivateProperty", {
    visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: (0, C.assertNodeType)("PrivateName")
      },
      value: {
        validate: (0, C.assertNodeType)("Expression"),
        optional: !0
      },
      typeAnnotation: {
        validate: (0, C.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: !0
      },
      decorators: {
        validate: (0, C.arrayOfType)("Decorator"),
        optional: !0
      },
      static: {
        validate: (0, C.assertValueType)("boolean"),
        default: !1
      },
      readonly: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      optional: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      definite: {
        validate: (0, C.assertValueType)("boolean"),
        optional: !0
      },
      variance: {
        validate: (0, C.assertNodeType)("Variance"),
        optional: !0
      }
    }
  });
  W("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, _f(), Cn(), {
      kind: {
        validate: (0, C.assertOneOf)("get", "set", "method"),
        default: "method"
      },
      key: {
        validate: (0, C.assertNodeType)("PrivateName")
      },
      body: {
        validate: (0, C.assertNodeType)("BlockStatement")
      }
    })
  });
  W("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: (0, C.assertNodeType)("Identifier")
      }
    }
  });
  W("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: (0, C.validateArrayOfType)("Statement")
    },
    aliases: ["Scopable", "BlockParent", "FunctionParent"]
  });
  W("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: (0, C.assertNodeType)("Identifier", "StringLiteral")
      },
      value: {
        validate: (0, C.assertNodeType)("StringLiteral")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/flow.js
var Ag = D(() => {
  "use strict";
  var Pg = Ba(), L = es(), re = (0, L.defineAliasedType)("Flow"), If = /* @__PURE__ */ i((e) => {
    let t = e === "DeclareClass";
    re(e, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", ...t ? ["mixins", "implements"] : [], "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        id: (0, L.validateType)("Identifier"),
        typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
        extends: (0, L.validateOptional)((0, L.arrayOfType)("InterfaceExtends"))
      }, t ? {
        mixins: (0, L.validateOptional)((0, L.arrayOfType)("InterfaceExtends")),
        implements: (0, L.validateOptional)((0, L.arrayOfType)("ClassImplements"))
      } : {}, {
        body: (0, L.validateType)("ObjectTypeAnnotation")
      })
    });
  }, "defineInterfaceishType");
  re("AnyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  re("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["FlowType"],
    fields: {
      elementType: (0, L.validateType)("FlowType")
    }
  });
  re("BooleanTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  re("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  re("NullLiteralTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  re("ClassImplements", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  If("DeclareClass");
  re("DeclareFunction", {
    builder: ["id"],
    visitor: ["id", "predicate"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      predicate: (0, L.validateOptionalType)("DeclaredPredicate")
    }
  });
  If("DeclareInterface");
  re("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier", "StringLiteral"),
      body: (0, L.validateType)("BlockStatement"),
      kind: (0, L.validateOptional)((0, L.assertOneOf)("CommonJS", "ES"))
    }
  });
  re("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: (0, L.validateType)("TypeAnnotation")
    }
  });
  re("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, L.validateType)("FlowType")
    }
  });
  re("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, L.validateOptionalType)("FlowType"),
      impltype: (0, L.validateOptionalType)("FlowType")
    }
  });
  re("DeclareVariable", {
    visitor: ["id"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier")
    }
  });
  re("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      declaration: (0, L.validateOptionalType)("Flow"),
      specifiers: (0, L.validateOptional)((0, L.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
      source: (0, L.validateOptionalType)("StringLiteral"),
      default: (0, L.validateOptional)((0, L.assertValueType)("boolean"))
    }, Pg.importAttributes)
  });
  re("DeclareExportAllDeclaration", {
    visitor: ["source", "attributes"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: Object.assign({
      source: (0, L.validateType)("StringLiteral"),
      exportKind: (0, L.validateOptional)((0, L.assertOneOf)("type", "value"))
    }, Pg.importAttributes)
  });
  re("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["FlowPredicate"],
    fields: {
      value: (0, L.validateType)("Flow")
    }
  });
  re("ExistsTypeAnnotation", {
    aliases: ["FlowType"]
  });
  re("FunctionTypeAnnotation", {
    builder: ["typeParameters", "params", "rest", "returnType"],
    visitor: ["typeParameters", "this", "params", "rest", "returnType"],
    aliases: ["FlowType"],
    fields: {
      typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
      params: (0, L.validateArrayOfType)("FunctionTypeParam"),
      rest: (0, L.validateOptionalType)("FunctionTypeParam"),
      this: (0, L.validateOptionalType)("FunctionTypeParam"),
      returnType: (0, L.validateType)("FlowType")
    }
  });
  re("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    fields: {
      name: (0, L.validateOptionalType)("Identifier"),
      typeAnnotation: (0, L.validateType)("FlowType"),
      optional: (0, L.validateOptional)((0, L.assertValueType)("boolean"))
    }
  });
  re("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["FlowType"],
    fields: {
      id: (0, L.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  re("InferredPredicate", {
    aliases: ["FlowPredicate"]
  });
  re("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    fields: {
      id: (0, L.validateType)("Identifier", "QualifiedTypeIdentifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterInstantiation")
    }
  });
  If("InterfaceDeclaration");
  re("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["FlowType"],
    fields: {
      extends: (0, L.validateOptional)((0, L.arrayOfType)("InterfaceExtends")),
      body: (0, L.validateType)("ObjectTypeAnnotation")
    }
  });
  re("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, L.validate)((0, L.arrayOfType)("FlowType"))
    }
  });
  re("MixedTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  re("EmptyTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  re("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["FlowType"],
    fields: {
      typeAnnotation: (0, L.validateType)("FlowType")
    }
  });
  re("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, L.validate)((0, L.assertValueType)("number"))
    }
  });
  re("NumberTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  re("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: (0, L.validate)((0, L.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
      indexers: {
        validate: (0, L.arrayOfType)("ObjectTypeIndexer"),
        optional: !0,
        default: []
      },
      callProperties: {
        validate: (0, L.arrayOfType)("ObjectTypeCallProperty"),
        optional: !0,
        default: []
      },
      internalSlots: {
        validate: (0, L.arrayOfType)("ObjectTypeInternalSlot"),
        optional: !0,
        default: []
      },
      exact: {
        validate: (0, L.assertValueType)("boolean"),
        default: !1
      },
      inexact: (0, L.validateOptional)((0, L.assertValueType)("boolean"))
    }
  });
  re("ObjectTypeInternalSlot", {
    visitor: ["id", "value"],
    builder: ["id", "value", "optional", "static", "method"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      value: (0, L.validateType)("FlowType"),
      optional: (0, L.validate)((0, L.assertValueType)("boolean")),
      static: (0, L.validate)((0, L.assertValueType)("boolean")),
      method: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  re("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["UserWhitespacable"],
    fields: {
      value: (0, L.validateType)("FlowType"),
      static: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  re("ObjectTypeIndexer", {
    visitor: ["variance", "id", "key", "value"],
    builder: ["id", "key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      id: (0, L.validateOptionalType)("Identifier"),
      key: (0, L.validateType)("FlowType"),
      value: (0, L.validateType)("FlowType"),
      static: (0, L.validate)((0, L.assertValueType)("boolean")),
      variance: (0, L.validateOptionalType)("Variance")
    }
  });
  re("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["UserWhitespacable"],
    fields: {
      key: (0, L.validateType)("Identifier", "StringLiteral"),
      value: (0, L.validateType)("FlowType"),
      kind: (0, L.validate)((0, L.assertOneOf)("init", "get", "set")),
      static: (0, L.validate)((0, L.assertValueType)("boolean")),
      proto: (0, L.validate)((0, L.assertValueType)("boolean")),
      optional: (0, L.validate)((0, L.assertValueType)("boolean")),
      variance: (0, L.validateOptionalType)("Variance"),
      method: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  re("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["UserWhitespacable"],
    fields: {
      argument: (0, L.validateType)("FlowType")
    }
  });
  re("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
      supertype: (0, L.validateOptionalType)("FlowType"),
      impltype: (0, L.validateType)("FlowType")
    }
  });
  re("QualifiedTypeIdentifier", {
    visitor: ["qualification", "id"],
    builder: ["id", "qualification"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      qualification: (0, L.validateType)("Identifier", "QualifiedTypeIdentifier")
    }
  });
  re("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["FlowType"],
    fields: {
      value: (0, L.validate)((0, L.assertValueType)("string"))
    }
  });
  re("StringTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  re("SymbolTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  re("ThisTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  re("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, L.validate)((0, L.arrayOfType)("FlowType"))
    }
  });
  re("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["FlowType"],
    fields: {
      argument: (0, L.validateType)("FlowType")
    }
  });
  re("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      typeParameters: (0, L.validateOptionalType)("TypeParameterDeclaration"),
      right: (0, L.validateType)("FlowType")
    }
  });
  re("TypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, L.validateType)("FlowType")
    }
  });
  re("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["ExpressionWrapper", "Expression"],
    fields: {
      expression: (0, L.validateType)("Expression"),
      typeAnnotation: (0, L.validateType)("TypeAnnotation")
    }
  });
  re("TypeParameter", {
    visitor: ["bound", "default", "variance"],
    fields: {
      name: (0, L.validate)((0, L.assertValueType)("string")),
      bound: (0, L.validateOptionalType)("TypeAnnotation"),
      default: (0, L.validateOptionalType)("FlowType"),
      variance: (0, L.validateOptionalType)("Variance")
    }
  });
  re("TypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, L.validate)((0, L.arrayOfType)("TypeParameter"))
    }
  });
  re("TypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, L.validate)((0, L.arrayOfType)("FlowType"))
    }
  });
  re("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["FlowType"],
    fields: {
      types: (0, L.validate)((0, L.arrayOfType)("FlowType"))
    }
  });
  re("Variance", {
    builder: ["kind"],
    fields: {
      kind: (0, L.validate)((0, L.assertOneOf)("minus", "plus"))
    }
  });
  re("VoidTypeAnnotation", {
    aliases: ["FlowType", "FlowBaseAnnotation"]
  });
  re("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      body: (0, L.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
    }
  });
  re("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, L.validate)((0, L.assertValueType)("boolean")),
      members: (0, L.validateArrayOfType)("EnumBooleanMember"),
      hasUnknownMembers: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  re("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, L.validate)((0, L.assertValueType)("boolean")),
      members: (0, L.validateArrayOfType)("EnumNumberMember"),
      hasUnknownMembers: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  re("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: (0, L.validate)((0, L.assertValueType)("boolean")),
      members: (0, L.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
      hasUnknownMembers: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  re("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: (0, L.validateArrayOfType)("EnumDefaultedMember"),
      hasUnknownMembers: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
  re("EnumBooleanMember", {
    aliases: ["EnumMember"],
    builder: ["id"],
    visitor: ["id", "init"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      init: (0, L.validateType)("BooleanLiteral")
    }
  });
  re("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      init: (0, L.validateType)("NumericLiteral")
    }
  });
  re("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: (0, L.validateType)("Identifier"),
      init: (0, L.validateType)("StringLiteral")
    }
  });
  re("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: (0, L.validateType)("Identifier")
    }
  });
  re("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, L.validateType)("FlowType"),
      indexType: (0, L.validateType)("FlowType")
    }
  });
  re("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["FlowType"],
    fields: {
      objectType: (0, L.validateType)("FlowType"),
      indexType: (0, L.validateType)("FlowType"),
      optional: (0, L.validate)((0, L.assertValueType)("boolean"))
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/jsx.js
var Cg = D(() => {
  "use strict";
  var He = es(), $t = (0, He.defineAliasedType)("JSX");
  $t("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, He.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: !0,
        validate: (0, He.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  $t("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["Immutable"],
    fields: {
      name: {
        validate: (0, He.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  $t("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["Immutable", "Expression"],
    fields: Object.assign({
      openingElement: {
        validate: (0, He.assertNodeType)("JSXOpeningElement")
      },
      closingElement: {
        optional: !0,
        validate: (0, He.assertNodeType)("JSXClosingElement")
      },
      children: (0, He.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }, {
      selfClosing: {
        validate: (0, He.assertValueType)("boolean"),
        optional: !0
      }
    })
  });
  $t("JSXEmptyExpression", {});
  $t("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, He.assertNodeType)("Expression", "JSXEmptyExpression")
      }
    }
  });
  $t("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["Immutable"],
    fields: {
      expression: {
        validate: (0, He.assertNodeType)("Expression")
      }
    }
  });
  $t("JSXIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, He.assertValueType)("string")
      }
    }
  });
  $t("JSXMemberExpression", {
    visitor: ["object", "property"],
    fields: {
      object: {
        validate: (0, He.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: (0, He.assertNodeType)("JSXIdentifier")
      }
    }
  });
  $t("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    fields: {
      namespace: {
        validate: (0, He.assertNodeType)("JSXIdentifier")
      },
      name: {
        validate: (0, He.assertNodeType)("JSXIdentifier")
      }
    }
  });
  $t("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "typeParameters", "typeArguments", "attributes"],
    aliases: ["Immutable"],
    fields: Object.assign({
      name: {
        validate: (0, He.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        default: !1
      },
      attributes: (0, He.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
      typeArguments: {
        validate: (0, He.assertNodeType)("TypeParameterInstantiation"),
        optional: !0
      }
    }, {
      typeParameters: {
        validate: (0, He.assertNodeType)("TSTypeParameterInstantiation"),
        optional: !0
      }
    })
  });
  $t("JSXSpreadAttribute", {
    visitor: ["argument"],
    fields: {
      argument: {
        validate: (0, He.assertNodeType)("Expression")
      }
    }
  });
  $t("JSXText", {
    aliases: ["Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: (0, He.assertValueType)("string")
      }
    }
  });
  $t("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: (0, He.assertNodeType)("JSXOpeningFragment")
      },
      closingFragment: {
        validate: (0, He.assertNodeType)("JSXClosingFragment")
      },
      children: (0, He.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
    }
  });
  $t("JSXOpeningFragment", {
    aliases: ["Immutable"]
  });
  $t("JSXClosingFragment", {
    aliases: ["Immutable"]
  });
});

// ../node_modules/@babel/types/lib/definitions/placeholders.js
var Bf = D((Ws) => {
  "use strict";
  Object.defineProperty(Ws, "__esModule", {
    value: !0
  });
  Ws.PLACEHOLDERS_FLIPPED_ALIAS = Ws.PLACEHOLDERS_ALIAS = Ws.PLACEHOLDERS = void 0;
  var IN = es(), ON = Ws.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBo\
dy", "Pattern"], Nf = Ws.PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };
  for (let e of ON) {
    let t = IN.ALIAS_KEYS[e];
    t != null && t.length && (Nf[e] = t);
  }
  var Of = Ws.PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(Nf).forEach((e) => {
    Nf[e].forEach((t) => {
      hasOwnProperty.call(Of, t) || (Of[t] = []), Of[t].push(e);
    });
  });
});

// ../node_modules/@babel/types/lib/definitions/misc.js
var wg = D(() => {
  "use strict";
  var vl = es(), NN = Bf(), BN = Ba(), kf = (0, vl.defineAliasedType)("Miscellaneous");
  kf("Noop", {
    visitor: []
  });
  kf("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: Object.assign({
      name: {
        validate: (0, vl.assertNodeType)("Identifier")
      },
      expectedNode: {
        validate: (0, vl.assertOneOf)(...NN.PLACEHOLDERS)
      }
    }, (0, BN.patternLikeCommon)())
  });
  kf("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: (0, vl.assertValueType)("string")
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/experimental.js
var Dg = D(() => {
  "use strict";
  var Ue = es();
  (0, Ue.default)("ArgumentPlaceholder", {});
  (0, Ue.default)("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: process.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: (0, Ue.assertNodeType)("Expression")
      },
      callee: {
        validate: (0, Ue.assertNodeType)("Expression")
      }
    } : {
      object: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(() => {
        }, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    }
  });
  (0, Ue.default)("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, Ue.assertNodeType)("Expression")
      }
    }
  });
  (0, Ue.default)("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: (0, Ue.assertNodeType)("BlockStatement")
      },
      async: {
        validate: (0, Ue.assertValueType)("boolean"),
        default: !1
      }
    }
  });
  (0, Ue.default)("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: (0, Ue.assertNodeType)("Identifier")
      }
    }
  });
  (0, Ue.default)("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: (0, Ue.validateArrayOfType)("ObjectProperty", "SpreadElement")
    }
  });
  (0, Ue.default)("TupleExpression", {
    fields: {
      elements: {
        validate: (0, Ue.arrayOfType)("Expression", "SpreadElement"),
        default: []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  (0, Ue.default)("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: (0, Ue.assertValueType)("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  (0, Ue.default)("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: (0, Ue.assertNodeType)("Program")
      }
    },
    aliases: ["Expression"]
  });
  (0, Ue.default)("TopicReference", {
    aliases: ["Expression"]
  });
  (0, Ue.default)("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: (0, Ue.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, Ue.default)("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: (0, Ue.assertNodeType)("Expression")
      }
    },
    aliases: ["Expression"]
  });
  (0, Ue.default)("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
  (0, Ue.default)("VoidPattern", {
    aliases: ["Pattern", "PatternLike", "FunctionParameter"]
  });
});

// ../node_modules/@babel/types/lib/definitions/typescript.js
var Fg = D(() => {
  "use strict";
  var q = es(), Ff = Ba(), kN = yi(), oe = (0, q.defineAliasedType)("TypeScript"), zt = (0, q.assertValueType)("boolean"), _g = /* @__PURE__ */ i(
  () => ({
    returnType: {
      validate: (0, q.assertNodeType)("TSTypeAnnotation", "Noop"),
      optional: !0
    },
    typeParameters: {
      validate: (0, q.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
      optional: !0
    }
  }), "tSFunctionTypeAnnotationCommon");
  oe("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: (0, q.assertOneOf)("public", "private", "protected"),
        optional: !0
      },
      readonly: {
        validate: (0, q.assertValueType)("boolean"),
        optional: !0
      },
      parameter: {
        validate: (0, q.assertNodeType)("Identifier", "AssignmentPattern")
      },
      override: {
        validate: (0, q.assertValueType)("boolean"),
        optional: !0
      },
      decorators: {
        validate: (0, q.arrayOfType)("Decorator"),
        optional: !0
      }
    }
  });
  oe("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, (0, Ff.functionDeclarationCommon)(), _g())
  });
  oe("TSDeclareMethod", Object.assign({
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"]
  }, (0, Ff.classMethodOrPropertyUnionShapeCommon)(), {
    fields: Object.assign({}, (0, Ff.classMethodOrDeclareMethodCommon)(), _g())
  }));
  oe("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: (0, q.validateType)("TSEntityName"),
      right: (0, q.validateType)("Identifier")
    }
  });
  var Pl = /* @__PURE__ */ i(() => ({
    typeParameters: (0, q.validateOptionalType)("TSTypeParameterDeclaration"),
    parameters: (0, q.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
    typeAnnotation: (0, q.validateOptionalType)("TSTypeAnnotation")
  }), "signatureDeclarationCommon"), Ig = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: Pl()
  };
  oe("TSCallSignatureDeclaration", Ig);
  oe("TSConstructSignatureDeclaration", Ig);
  var Og = /* @__PURE__ */ i(() => ({
    key: (0, q.validateType)("Expression"),
    computed: {
      default: !1
    },
    optional: (0, q.validateOptional)(zt)
  }), "namedTypeElementCommon");
  oe("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation"],
    fields: Object.assign({}, Og(), {
      readonly: (0, q.validateOptional)(zt),
      typeAnnotation: (0, q.validateOptionalType)("TSTypeAnnotation"),
      kind: {
        optional: !0,
        validate: (0, q.assertOneOf)("get", "set")
      }
    })
  });
  oe("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, Pl(), Og(), {
      kind: {
        validate: (0, q.assertOneOf)("method", "get", "set")
      }
    })
  });
  oe("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: (0, q.validateOptional)(zt),
      static: (0, q.validateOptional)(zt),
      parameters: (0, q.validateArrayOfType)("Identifier"),
      typeAnnotation: (0, q.validateOptionalType)("TSTypeAnnotation")
    }
  });
  var FN = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword",
  "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
  for (let e of FN)
    oe(e, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  oe("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var Ng = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  oe("TSFunctionType", Object.assign({}, Ng, {
    fields: Pl()
  }));
  oe("TSConstructorType", Object.assign({}, Ng, {
    fields: Object.assign({}, Pl(), {
      abstract: (0, q.validateOptional)(zt)
    })
  }));
  oe("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: (0, q.validateType)("TSEntityName"),
      typeParameters: (0, q.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  oe("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: (0, q.validateType)("Identifier", "TSThisType"),
      typeAnnotation: (0, q.validateOptionalType)("TSTypeAnnotation"),
      asserts: (0, q.validateOptional)(zt)
    }
  });
  oe("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName", "typeParameters"],
    fields: {
      exprName: (0, q.validateType)("TSEntityName", "TSImportType"),
      typeParameters: (0, q.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  oe("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: (0, q.validateArrayOfType)("TSTypeElement")
    }
  });
  oe("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: (0, q.validateType)("TSType")
    }
  });
  oe("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: (0, q.validateArrayOfType)("TSType", "TSNamedTupleMember")
    }
  });
  oe("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, q.validateType)("TSType")
    }
  });
  oe("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, q.validateType)("TSType")
    }
  });
  oe("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: (0, q.validateType)("Identifier"),
      optional: {
        validate: zt,
        default: !1
      },
      elementType: (0, q.validateType)("TSType")
    }
  });
  var Bg = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: (0, q.validateArrayOfType)("TSType")
    }
  };
  oe("TSUnionType", Bg);
  oe("TSIntersectionType", Bg);
  oe("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: (0, q.validateType)("TSType"),
      extendsType: (0, q.validateType)("TSType"),
      trueType: (0, q.validateType)("TSType"),
      falseType: (0, q.validateType)("TSType")
    }
  });
  oe("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: (0, q.validateType)("TSTypeParameter")
    }
  });
  oe("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: (0, q.validateType)("TSType")
    }
  });
  oe("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    builder: ["typeAnnotation", "operator"],
    fields: {
      operator: {
        validate: (0, q.assertValueType)("string"),
        default: "keyof"
      },
      typeAnnotation: (0, q.validateType)("TSType")
    }
  });
  oe("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: (0, q.validateType)("TSType"),
      indexType: (0, q.validateType)("TSType")
    }
  });
  oe("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "nameType", "typeAnnotation"],
    builder: ["typeParameter", "typeAnnotation", "nameType"],
    fields: Object.assign({}, {
      typeParameter: (0, q.validateType)("TSTypeParameter")
    }, {
      readonly: (0, q.validateOptional)((0, q.assertOneOf)(!0, !1, "+", "-")),
      optional: (0, q.validateOptional)((0, q.assertOneOf)(!0, !1, "+", "-")),
      typeAnnotation: (0, q.validateOptionalType)("TSType"),
      nameType: (0, q.validateOptionalType)("TSType")
    })
  });
  oe("TSTemplateLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["quasis", "types"],
    fields: {
      quasis: (0, q.validateArrayOfType)("TemplateElement"),
      types: {
        validate: (0, q.chain)((0, q.assertValueType)("array"), (0, q.assertEach)((0, q.assertNodeType)("TSType")), function(e, t, r) {
          if (e.quasis.length !== r.length + 1)
            throw new TypeError(`Number of ${e.type} quasis should be exactly one more than the number of types.
Expected ${r.length + 1} quasis but got ${e.quasis.length}`);
        })
      }
    }
  });
  oe("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: {
        validate: function() {
          let e = (0, q.assertNodeType)("NumericLiteral", "BigIntLiteral"), t = (0, q.assertOneOf)("-"), r = (0, q.assertNodeType)("NumericL\
iteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral"), s = /* @__PURE__ */ i(function(a, o, l) {
            (0, kN.default)("UnaryExpression", l) ? (t(l, "operator", l.operator), e(l, "argument", l.argument)) : r(a, o, l);
          }, "validator");
          return s.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpressi\
on"], s;
        }()
      }
    }
  });
  oe("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, q.validateType)("TSEntityName"),
      typeParameters: (0, q.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  oe("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: (0, q.validateOptional)(zt),
      id: (0, q.validateType)("Identifier"),
      typeParameters: (0, q.validateOptionalType)("TSTypeParameterDeclaration"),
      extends: (0, q.validateOptional)((0, q.arrayOfType)("TSExpressionWithTypeArguments")),
      body: (0, q.validateType)("TSInterfaceBody")
    }
  });
  oe("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: (0, q.validateArrayOfType)("TSTypeElement")
    }
  });
  oe("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: (0, q.validateOptional)(zt),
      id: (0, q.validateType)("Identifier"),
      typeParameters: (0, q.validateOptionalType)("TSTypeParameterDeclaration"),
      typeAnnotation: (0, q.validateType)("TSType")
    }
  });
  oe("TSInstantiationExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: (0, q.validateType)("Expression"),
      typeParameters: (0, q.validateOptionalType)("TSTypeParameterInstantiation")
    }
  });
  var kg = {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: (0, q.validateType)("Expression"),
      typeAnnotation: (0, q.validateType)("TSType")
    }
  };
  oe("TSAsExpression", kg);
  oe("TSSatisfiesExpression", kg);
  oe("TSTypeAssertion", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: (0, q.validateType)("TSType"),
      expression: (0, q.validateType)("Expression")
    }
  });
  oe("TSEnumBody", {
    visitor: ["members"],
    fields: {
      members: (0, q.validateArrayOfType)("TSEnumMember")
    }
  });
  oe("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: (0, q.validateOptional)(zt),
      const: (0, q.validateOptional)(zt),
      id: (0, q.validateType)("Identifier"),
      members: (0, q.validateArrayOfType)("TSEnumMember"),
      initializer: (0, q.validateOptionalType)("Expression"),
      body: (0, q.validateOptionalType)("TSEnumBody")
    }
  });
  oe("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: (0, q.validateType)("Identifier", "StringLiteral"),
      initializer: (0, q.validateOptionalType)("Expression")
    }
  });
  oe("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: Object.assign({
      kind: {
        validate: (0, q.assertOneOf)("global", "module", "namespace")
      },
      declare: (0, q.validateOptional)(zt)
    }, {
      global: (0, q.validateOptional)(zt)
    }, {
      id: (0, q.validateType)("Identifier", "StringLiteral"),
      body: (0, q.validateType)("TSModuleBlock", "TSModuleDeclaration")
    })
  });
  oe("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
    visitor: ["body"],
    fields: {
      body: (0, q.validateArrayOfType)("Statement")
    }
  });
  oe("TSImportType", {
    aliases: ["TSType"],
    builder: ["argument", "qualifier", "typeParameters"],
    visitor: ["argument", "options", "qualifier", "typeParameters"],
    fields: {
      argument: (0, q.validateType)("StringLiteral"),
      qualifier: (0, q.validateOptionalType)("TSEntityName"),
      typeParameters: (0, q.validateOptionalType)("TSTypeParameterInstantiation"),
      options: {
        validate: (0, q.assertNodeType)("ObjectExpression"),
        optional: !0
      }
    }
  });
  oe("TSImportEqualsDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "moduleReference"],
    fields: Object.assign({}, {
      isExport: (0, q.validate)(zt)
    }, {
      id: (0, q.validateType)("Identifier"),
      moduleReference: (0, q.validateType)("TSEntityName", "TSExternalModuleReference"),
      importKind: {
        validate: (0, q.assertOneOf)("type", "value"),
        optional: !0
      }
    })
  });
  oe("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: (0, q.validateType)("StringLiteral")
    }
  });
  oe("TSNonNullExpression", {
    aliases: ["Expression", "LVal", "PatternLike"],
    visitor: ["expression"],
    fields: {
      expression: (0, q.validateType)("Expression")
    }
  });
  oe("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: (0, q.validateType)("Expression")
    }
  });
  oe("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: (0, q.validateType)("Identifier")
    }
  });
  oe("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: (0, q.assertNodeType)("TSType")
      }
    }
  });
  oe("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: (0, q.validateArrayOfType)("TSType")
    }
  });
  oe("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: (0, q.validateArrayOfType)("TSTypeParameter")
    }
  });
  oe("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: (0, q.assertValueType)("string")
      },
      in: {
        validate: (0, q.assertValueType)("boolean"),
        optional: !0
      },
      out: {
        validate: (0, q.assertValueType)("boolean"),
        optional: !0
      },
      const: {
        validate: (0, q.assertValueType)("boolean"),
        optional: !0
      },
      constraint: {
        validate: (0, q.assertNodeType)("TSType"),
        optional: !0
      },
      default: {
        validate: (0, q.assertNodeType)("TSType"),
        optional: !0
      }
    }
  });
});

// ../node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var Lg = D((Al) => {
  "use strict";
  Object.defineProperty(Al, "__esModule", {
    value: !0
  });
  Al.DEPRECATED_ALIASES = void 0;
  var JTe = Al.DEPRECATED_ALIASES = {
    ModuleDeclaration: "ImportOrExportDeclaration"
  };
});

// ../node_modules/@babel/types/lib/definitions/index.js
var dr = D((Nt) => {
  "use strict";
  Object.defineProperty(Nt, "__esModule", {
    value: !0
  });
  Object.defineProperty(Nt, "ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vt.ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(Nt, "BUILDER_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vt.BUILDER_KEYS;
    }, "get")
  });
  Object.defineProperty(Nt, "DEPRECATED_ALIASES", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Lf.DEPRECATED_ALIASES;
    }, "get")
  });
  Object.defineProperty(Nt, "DEPRECATED_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vt.DEPRECATED_KEYS;
    }, "get")
  });
  Object.defineProperty(Nt, "FLIPPED_ALIAS_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vt.FLIPPED_ALIAS_KEYS;
    }, "get")
  });
  Object.defineProperty(Nt, "NODE_FIELDS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vt.NODE_FIELDS;
    }, "get")
  });
  Object.defineProperty(Nt, "NODE_PARENT_VALIDATIONS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vt.NODE_PARENT_VALIDATIONS;
    }, "get")
  });
  Object.defineProperty(Nt, "NODE_UNION_SHAPES__PRIVATE", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vt.NODE_UNION_SHAPES__PRIVATE;
    }, "get")
  });
  Object.defineProperty(Nt, "PLACEHOLDERS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return jf.PLACEHOLDERS;
    }, "get")
  });
  Object.defineProperty(Nt, "PLACEHOLDERS_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return jf.PLACEHOLDERS_ALIAS;
    }, "get")
  });
  Object.defineProperty(Nt, "PLACEHOLDERS_FLIPPED_ALIAS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return jf.PLACEHOLDERS_FLIPPED_ALIAS;
    }, "get")
  });
  Nt.TYPES = void 0;
  Object.defineProperty(Nt, "VISITOR_KEYS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vt.VISITOR_KEYS;
    }, "get")
  });
  Ba();
  Ag();
  Cg();
  wg();
  Dg();
  Fg();
  var Vt = es(), jf = Bf(), Lf = Lg();
  Object.keys(Lf.DEPRECATED_ALIASES).forEach((e) => {
    Vt.FLIPPED_ALIAS_KEYS[e] = Vt.FLIPPED_ALIAS_KEYS[Lf.DEPRECATED_ALIASES[e]];
  });
  for (let {
    types: e,
    set: t
  } of Vt.allExpandedTypes)
    for (let r of e) {
      let s = Vt.FLIPPED_ALIAS_KEYS[r];
      s ? s.forEach(t.add, t) : t.add(r);
    }
  var XTe = Nt.TYPES = [].concat(Object.keys(Vt.VISITOR_KEYS), Object.keys(Vt.FLIPPED_ALIAS_KEYS), Object.keys(Vt.DEPRECATED_KEYS));
});

// ../node_modules/@babel/types/lib/validators/validate.js
var El = D((vi) => {
  "use strict";
  Object.defineProperty(vi, "__esModule", {
    value: !0
  });
  vi.default = LN;
  vi.validateChild = Mg;
  vi.validateField = jg;
  vi.validateInternal = jN;
  var ka = dr();
  function LN(e, t, r) {
    if (!e) return;
    let s = ka.NODE_FIELDS[e.type];
    if (!s) return;
    let n = s[t];
    jg(e, t, r, n), Mg(e, t, r);
  }
  i(LN, "validate");
  function jN(e, t, r, s, n) {
    if (e != null && e.validate && !(e.optional && s == null) && (e.validate(t, r, s), n)) {
      var a;
      let o = s.type;
      if (o == null) return;
      (a = ka.NODE_PARENT_VALIDATIONS[o]) == null || a.call(ka.NODE_PARENT_VALIDATIONS, t, r, s);
    }
  }
  i(jN, "validateInternal");
  function jg(e, t, r, s) {
    s != null && s.validate && (s.optional && r == null || s.validate(e, t, r));
  }
  i(jg, "validateField");
  function Mg(e, t, r) {
    var s;
    let n = r?.type;
    n != null && ((s = ka.NODE_PARENT_VALIDATIONS[n]) == null || s.call(ka.NODE_PARENT_VALIDATIONS, e, t, r));
  }
  i(Mg, "validateChild");
});

// ../node_modules/@babel/types/lib/builders/generated/lowercase.js
var Mf = D((x) => {
  "use strict";
  Object.defineProperty(x, "__esModule", {
    value: !0
  });
  x.anyTypeAnnotation = bk;
  x.argumentPlaceholder = YF;
  x.arrayExpression = UN;
  x.arrayPattern = LB;
  x.arrayTypeAnnotation = gk;
  x.arrowFunctionExpression = jB;
  x.assignmentExpression = $N;
  x.assignmentPattern = FB;
  x.awaitExpression = ik;
  x.bigIntLiteral = qN;
  x.binaryExpression = VN;
  x.bindExpression = HF;
  x.blockStatement = HN;
  x.booleanLiteral = dB;
  x.booleanLiteralTypeAnnotation = xk;
  x.booleanTypeAnnotation = Tk;
  x.breakStatement = JN;
  x.callExpression = GN;
  x.catchClause = XN;
  x.classAccessorProperty = pk;
  x.classBody = MB;
  x.classDeclaration = qB;
  x.classExpression = RB;
  x.classImplements = Sk;
  x.classMethod = QB;
  x.classPrivateMethod = dk;
  x.classPrivateProperty = fk;
  x.classProperty = ck;
  x.conditionalExpression = zN;
  x.continueStatement = QN;
  x.debuggerStatement = ZN;
  x.decimalLiteral = ZF;
  x.declareClass = vk;
  x.declareExportAllDeclaration = Nk;
  x.declareExportDeclaration = Ok;
  x.declareFunction = Pk;
  x.declareInterface = Ak;
  x.declareModule = Ck;
  x.declareModuleExports = wk;
  x.declareOpaqueType = _k;
  x.declareTypeAlias = Dk;
  x.declareVariable = Ik;
  x.declaredPredicate = Bk;
  x.decorator = JF;
  x.directive = WN;
  x.directiveLiteral = YN;
  x.doExpression = GF;
  x.doWhileStatement = eB;
  x.emptyStatement = tB;
  x.emptyTypeAnnotation = Kk;
  x.enumBooleanBody = gF;
  x.enumBooleanMember = SF;
  x.enumDeclaration = bF;
  x.enumDefaultedMember = AF;
  x.enumNumberBody = TF;
  x.enumNumberMember = vF;
  x.enumStringBody = xF;
  x.enumStringMember = PF;
  x.enumSymbolBody = EF;
  x.existsTypeAnnotation = kk;
  x.exportAllDeclaration = UB;
  x.exportDefaultDeclaration = $B;
  x.exportDefaultSpecifier = XF;
  x.exportNamedDeclaration = VB;
  x.exportNamespaceSpecifier = ok;
  x.exportSpecifier = KB;
  x.expressionStatement = rB;
  x.file = sB;
  x.forInStatement = nB;
  x.forOfStatement = WB;
  x.forStatement = iB;
  x.functionDeclaration = aB;
  x.functionExpression = oB;
  x.functionTypeAnnotation = Fk;
  x.functionTypeParam = Lk;
  x.genericTypeAnnotation = jk;
  x.identifier = lB;
  x.ifStatement = uB;
  x.import = ak;
  x.importAttribute = yk;
  x.importDeclaration = YB;
  x.importDefaultSpecifier = HB;
  x.importExpression = XB;
  x.importNamespaceSpecifier = JB;
  x.importSpecifier = GB;
  x.indexedAccessType = CF;
  x.inferredPredicate = Mk;
  x.interfaceDeclaration = qk;
  x.interfaceExtends = Rk;
  x.interfaceTypeAnnotation = Uk;
  x.interpreterDirective = KN;
  x.intersectionTypeAnnotation = $k;
  x.jSXAttribute = x.jsxAttribute = DF;
  x.jSXClosingElement = x.jsxClosingElement = _F;
  x.jSXClosingFragment = x.jsxClosingFragment = $F;
  x.jSXElement = x.jsxElement = IF;
  x.jSXEmptyExpression = x.jsxEmptyExpression = OF;
  x.jSXExpressionContainer = x.jsxExpressionContainer = NF;
  x.jSXFragment = x.jsxFragment = qF;
  x.jSXIdentifier = x.jsxIdentifier = kF;
  x.jSXMemberExpression = x.jsxMemberExpression = FF;
  x.jSXNamespacedName = x.jsxNamespacedName = LF;
  x.jSXOpeningElement = x.jsxOpeningElement = jF;
  x.jSXOpeningFragment = x.jsxOpeningFragment = UF;
  x.jSXSpreadAttribute = x.jsxSpreadAttribute = MF;
  x.jSXSpreadChild = x.jsxSpreadChild = BF;
  x.jSXText = x.jsxText = RF;
  x.labeledStatement = cB;
  x.logicalExpression = hB;
  x.memberExpression = mB;
  x.metaProperty = zB;
  x.mixedTypeAnnotation = Vk;
  x.moduleExpression = eL;
  x.newExpression = yB;
  x.noop = VF;
  x.nullLiteral = fB;
  x.nullLiteralTypeAnnotation = Ek;
  x.nullableTypeAnnotation = Wk;
  x.numberLiteral = Tj;
  x.numberLiteralTypeAnnotation = Yk;
  x.numberTypeAnnotation = Hk;
  x.numericLiteral = Rg;
  x.objectExpression = gB;
  x.objectMethod = TB;
  x.objectPattern = ZB;
  x.objectProperty = xB;
  x.objectTypeAnnotation = Jk;
  x.objectTypeCallProperty = Xk;
  x.objectTypeIndexer = zk;
  x.objectTypeInternalSlot = Gk;
  x.objectTypeProperty = Qk;
  x.objectTypeSpreadProperty = Zk;
  x.opaqueType = eF;
  x.optionalCallExpression = uk;
  x.optionalIndexedAccessType = wF;
  x.optionalMemberExpression = lk;
  x.parenthesizedExpression = vB;
  x.pipelineBareFunction = sL;
  x.pipelinePrimaryTopicReference = nL;
  x.pipelineTopicExpression = rL;
  x.placeholder = KF;
  x.privateName = hk;
  x.program = bB;
  x.qualifiedTypeIdentifier = tF;
  x.recordExpression = zF;
  x.regExpLiteral = qg;
  x.regexLiteral = xj;
  x.restElement = Ug;
  x.restProperty = Ej;
  x.returnStatement = EB;
  x.sequenceExpression = SB;
  x.spreadElement = $g;
  x.spreadProperty = Sj;
  x.staticBlock = mk;
  x.stringLiteral = pB;
  x.stringLiteralTypeAnnotation = rF;
  x.stringTypeAnnotation = sF;
  x.super = ek;
  x.switchCase = PB;
  x.switchStatement = AB;
  x.symbolTypeAnnotation = nF;
  x.taggedTemplateExpression = tk;
  x.templateElement = rk;
  x.templateLiteral = sk;
  x.thisExpression = CB;
  x.thisTypeAnnotation = iF;
  x.throwStatement = wB;
  x.topicReference = tL;
  x.tryStatement = DB;
  x.tSAnyKeyword = x.tsAnyKeyword = mL;
  x.tSArrayType = x.tsArrayType = FL;
  x.tSAsExpression = x.tsAsExpression = tj;
  x.tSBigIntKeyword = x.tsBigIntKeyword = bL;
  x.tSBooleanKeyword = x.tsBooleanKeyword = yL;
  x.tSCallSignatureDeclaration = x.tsCallSignatureDeclaration = cL;
  x.tSConditionalType = x.tsConditionalType = $L;
  x.tSConstructSignatureDeclaration = x.tsConstructSignatureDeclaration = pL;
  x.tSConstructorType = x.tsConstructorType = IL;
  x.tSDeclareFunction = x.tsDeclareFunction = oL;
  x.tSDeclareMethod = x.tsDeclareMethod = lL;
  x.tSEnumBody = x.tsEnumBody = nj;
  x.tSEnumDeclaration = x.tsEnumDeclaration = ij;
  x.tSEnumMember = x.tsEnumMember = aj;
  x.tSExportAssignment = x.tsExportAssignment = dj;
  x.tSExpressionWithTypeArguments = x.tsExpressionWithTypeArguments = XL;
  x.tSExternalModuleReference = x.tsExternalModuleReference = pj;
  x.tSFunctionType = x.tsFunctionType = _L;
  x.tSImportEqualsDeclaration = x.tsImportEqualsDeclaration = cj;
  x.tSImportType = x.tsImportType = uj;
  x.tSIndexSignature = x.tsIndexSignature = hL;
  x.tSIndexedAccessType = x.tsIndexedAccessType = YL;
  x.tSInferType = x.tsInferType = VL;
  x.tSInstantiationExpression = x.tsInstantiationExpression = ej;
  x.tSInterfaceBody = x.tsInterfaceBody = QL;
  x.tSInterfaceDeclaration = x.tsInterfaceDeclaration = zL;
  x.tSIntersectionType = x.tsIntersectionType = UL;
  x.tSIntrinsicKeyword = x.tsIntrinsicKeyword = gL;
  x.tSLiteralType = x.tsLiteralType = GL;
  x.tSMappedType = x.tsMappedType = HL;
  x.tSMethodSignature = x.tsMethodSignature = dL;
  x.tSModuleBlock = x.tsModuleBlock = lj;
  x.tSModuleDeclaration = x.tsModuleDeclaration = oj;
  x.tSNamedTupleMember = x.tsNamedTupleMember = RL;
  x.tSNamespaceExportDeclaration = x.tsNamespaceExportDeclaration = hj;
  x.tSNeverKeyword = x.tsNeverKeyword = TL;
  x.tSNonNullExpression = x.tsNonNullExpression = fj;
  x.tSNullKeyword = x.tsNullKeyword = xL;
  x.tSNumberKeyword = x.tsNumberKeyword = EL;
  x.tSObjectKeyword = x.tsObjectKeyword = SL;
  x.tSOptionalType = x.tsOptionalType = jL;
  x.tSParameterProperty = x.tsParameterProperty = aL;
  x.tSParenthesizedType = x.tsParenthesizedType = KL;
  x.tSPropertySignature = x.tsPropertySignature = fL;
  x.tSQualifiedName = x.tsQualifiedName = uL;
  x.tSRestType = x.tsRestType = ML;
  x.tSSatisfiesExpression = x.tsSatisfiesExpression = rj;
  x.tSStringKeyword = x.tsStringKeyword = vL;
  x.tSSymbolKeyword = x.tsSymbolKeyword = PL;
  x.tSTemplateLiteralType = x.tsTemplateLiteralType = JL;
  x.tSThisType = x.tsThisType = DL;
  x.tSTupleType = x.tsTupleType = LL;
  x.tSTypeAliasDeclaration = x.tsTypeAliasDeclaration = ZL;
  x.tSTypeAnnotation = x.tsTypeAnnotation = mj;
  x.tSTypeAssertion = x.tsTypeAssertion = sj;
  x.tSTypeLiteral = x.tsTypeLiteral = kL;
  x.tSTypeOperator = x.tsTypeOperator = WL;
  x.tSTypeParameter = x.tsTypeParameter = gj;
  x.tSTypeParameterDeclaration = x.tsTypeParameterDeclaration = bj;
  x.tSTypeParameterInstantiation = x.tsTypeParameterInstantiation = yj;
  x.tSTypePredicate = x.tsTypePredicate = NL;
  x.tSTypeQuery = x.tsTypeQuery = BL;
  x.tSTypeReference = x.tsTypeReference = OL;
  x.tSUndefinedKeyword = x.tsUndefinedKeyword = AL;
  x.tSUnionType = x.tsUnionType = qL;
  x.tSUnknownKeyword = x.tsUnknownKeyword = CL;
  x.tSVoidKeyword = x.tsVoidKeyword = wL;
  x.tupleExpression = QF;
  x.tupleTypeAnnotation = aF;
  x.typeAlias = lF;
  x.typeAnnotation = uF;
  x.typeCastExpression = cF;
  x.typeParameter = pF;
  x.typeParameterDeclaration = fF;
  x.typeParameterInstantiation = dF;
  x.typeofTypeAnnotation = oF;
  x.unaryExpression = _B;
  x.unionTypeAnnotation = hF;
  x.updateExpression = IB;
  x.v8IntrinsicIdentifier = WF;
  x.variableDeclaration = OB;
  x.variableDeclarator = NB;
  x.variance = mF;
  x.voidPattern = iL;
  x.voidTypeAnnotation = yF;
  x.whileStatement = BB;
  x.withStatement = kB;
  x.yieldExpression = nk;
  var MN = El(), Cl = mi(), RN = es(), {
    validateInternal: y
  } = MN, {
    NODE_FIELDS: B
  } = RN;
  function qN(e) {
    typeof e == "bigint" && (e = e.toString());
    let t = {
      type: "BigIntLiteral",
      value: e
    }, r = B.BigIntLiteral;
    return y(r.value, t, "value", e), t;
  }
  i(qN, "bigIntLiteral");
  function UN(e = []) {
    let t = {
      type: "ArrayExpression",
      elements: e
    }, r = B.ArrayExpression;
    return y(r.elements, t, "elements", e, 1), t;
  }
  i(UN, "arrayExpression");
  function $N(e, t, r) {
    let s = {
      type: "AssignmentExpression",
      operator: e,
      left: t,
      right: r
    }, n = B.AssignmentExpression;
    return y(n.operator, s, "operator", e), y(n.left, s, "left", t, 1), y(n.right, s, "right", r, 1), s;
  }
  i($N, "assignmentExpression");
  function VN(e, t, r) {
    let s = {
      type: "BinaryExpression",
      operator: e,
      left: t,
      right: r
    }, n = B.BinaryExpression;
    return y(n.operator, s, "operator", e), y(n.left, s, "left", t, 1), y(n.right, s, "right", r, 1), s;
  }
  i(VN, "binaryExpression");
  function KN(e) {
    let t = {
      type: "InterpreterDirective",
      value: e
    }, r = B.InterpreterDirective;
    return y(r.value, t, "value", e), t;
  }
  i(KN, "interpreterDirective");
  function WN(e) {
    let t = {
      type: "Directive",
      value: e
    }, r = B.Directive;
    return y(r.value, t, "value", e, 1), t;
  }
  i(WN, "directive");
  function YN(e) {
    let t = {
      type: "DirectiveLiteral",
      value: e
    }, r = B.DirectiveLiteral;
    return y(r.value, t, "value", e), t;
  }
  i(YN, "directiveLiteral");
  function HN(e, t = []) {
    let r = {
      type: "BlockStatement",
      body: e,
      directives: t
    }, s = B.BlockStatement;
    return y(s.body, r, "body", e, 1), y(s.directives, r, "directives", t, 1), r;
  }
  i(HN, "blockStatement");
  function JN(e = null) {
    let t = {
      type: "BreakStatement",
      label: e
    }, r = B.BreakStatement;
    return y(r.label, t, "label", e, 1), t;
  }
  i(JN, "breakStatement");
  function GN(e, t) {
    let r = {
      type: "CallExpression",
      callee: e,
      arguments: t
    }, s = B.CallExpression;
    return y(s.callee, r, "callee", e, 1), y(s.arguments, r, "arguments", t, 1), r;
  }
  i(GN, "callExpression");
  function XN(e = null, t) {
    let r = {
      type: "CatchClause",
      param: e,
      body: t
    }, s = B.CatchClause;
    return y(s.param, r, "param", e, 1), y(s.body, r, "body", t, 1), r;
  }
  i(XN, "catchClause");
  function zN(e, t, r) {
    let s = {
      type: "ConditionalExpression",
      test: e,
      consequent: t,
      alternate: r
    }, n = B.ConditionalExpression;
    return y(n.test, s, "test", e, 1), y(n.consequent, s, "consequent", t, 1), y(n.alternate, s, "alternate", r, 1), s;
  }
  i(zN, "conditionalExpression");
  function QN(e = null) {
    let t = {
      type: "ContinueStatement",
      label: e
    }, r = B.ContinueStatement;
    return y(r.label, t, "label", e, 1), t;
  }
  i(QN, "continueStatement");
  function ZN() {
    return {
      type: "DebuggerStatement"
    };
  }
  i(ZN, "debuggerStatement");
  function eB(e, t) {
    let r = {
      type: "DoWhileStatement",
      test: e,
      body: t
    }, s = B.DoWhileStatement;
    return y(s.test, r, "test", e, 1), y(s.body, r, "body", t, 1), r;
  }
  i(eB, "doWhileStatement");
  function tB() {
    return {
      type: "EmptyStatement"
    };
  }
  i(tB, "emptyStatement");
  function rB(e) {
    let t = {
      type: "ExpressionStatement",
      expression: e
    }, r = B.ExpressionStatement;
    return y(r.expression, t, "expression", e, 1), t;
  }
  i(rB, "expressionStatement");
  function sB(e, t = null, r = null) {
    let s = {
      type: "File",
      program: e,
      comments: t,
      tokens: r
    }, n = B.File;
    return y(n.program, s, "program", e, 1), y(n.comments, s, "comments", t, 1), y(n.tokens, s, "tokens", r), s;
  }
  i(sB, "file");
  function nB(e, t, r) {
    let s = {
      type: "ForInStatement",
      left: e,
      right: t,
      body: r
    }, n = B.ForInStatement;
    return y(n.left, s, "left", e, 1), y(n.right, s, "right", t, 1), y(n.body, s, "body", r, 1), s;
  }
  i(nB, "forInStatement");
  function iB(e = null, t = null, r = null, s) {
    let n = {
      type: "ForStatement",
      init: e,
      test: t,
      update: r,
      body: s
    }, a = B.ForStatement;
    return y(a.init, n, "init", e, 1), y(a.test, n, "test", t, 1), y(a.update, n, "update", r, 1), y(a.body, n, "body", s, 1), n;
  }
  i(iB, "forStatement");
  function aB(e = null, t, r, s = !1, n = !1) {
    let a = {
      type: "FunctionDeclaration",
      id: e,
      params: t,
      body: r,
      generator: s,
      async: n
    }, o = B.FunctionDeclaration;
    return y(o.id, a, "id", e, 1), y(o.params, a, "params", t, 1), y(o.body, a, "body", r, 1), y(o.generator, a, "generator", s), y(o.async,
    a, "async", n), a;
  }
  i(aB, "functionDeclaration");
  function oB(e = null, t, r, s = !1, n = !1) {
    let a = {
      type: "FunctionExpression",
      id: e,
      params: t,
      body: r,
      generator: s,
      async: n
    }, o = B.FunctionExpression;
    return y(o.id, a, "id", e, 1), y(o.params, a, "params", t, 1), y(o.body, a, "body", r, 1), y(o.generator, a, "generator", s), y(o.async,
    a, "async", n), a;
  }
  i(oB, "functionExpression");
  function lB(e) {
    let t = {
      type: "Identifier",
      name: e
    }, r = B.Identifier;
    return y(r.name, t, "name", e), t;
  }
  i(lB, "identifier");
  function uB(e, t, r = null) {
    let s = {
      type: "IfStatement",
      test: e,
      consequent: t,
      alternate: r
    }, n = B.IfStatement;
    return y(n.test, s, "test", e, 1), y(n.consequent, s, "consequent", t, 1), y(n.alternate, s, "alternate", r, 1), s;
  }
  i(uB, "ifStatement");
  function cB(e, t) {
    let r = {
      type: "LabeledStatement",
      label: e,
      body: t
    }, s = B.LabeledStatement;
    return y(s.label, r, "label", e, 1), y(s.body, r, "body", t, 1), r;
  }
  i(cB, "labeledStatement");
  function pB(e) {
    let t = {
      type: "StringLiteral",
      value: e
    }, r = B.StringLiteral;
    return y(r.value, t, "value", e), t;
  }
  i(pB, "stringLiteral");
  function Rg(e) {
    let t = {
      type: "NumericLiteral",
      value: e
    }, r = B.NumericLiteral;
    return y(r.value, t, "value", e), t;
  }
  i(Rg, "numericLiteral");
  function fB() {
    return {
      type: "NullLiteral"
    };
  }
  i(fB, "nullLiteral");
  function dB(e) {
    let t = {
      type: "BooleanLiteral",
      value: e
    }, r = B.BooleanLiteral;
    return y(r.value, t, "value", e), t;
  }
  i(dB, "booleanLiteral");
  function qg(e, t = "") {
    let r = {
      type: "RegExpLiteral",
      pattern: e,
      flags: t
    }, s = B.RegExpLiteral;
    return y(s.pattern, r, "pattern", e), y(s.flags, r, "flags", t), r;
  }
  i(qg, "regExpLiteral");
  function hB(e, t, r) {
    let s = {
      type: "LogicalExpression",
      operator: e,
      left: t,
      right: r
    }, n = B.LogicalExpression;
    return y(n.operator, s, "operator", e), y(n.left, s, "left", t, 1), y(n.right, s, "right", r, 1), s;
  }
  i(hB, "logicalExpression");
  function mB(e, t, r = !1, s = null) {
    let n = {
      type: "MemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: s
    }, a = B.MemberExpression;
    return y(a.object, n, "object", e, 1), y(a.property, n, "property", t, 1), y(a.computed, n, "computed", r), y(a.optional, n, "optional",
    s), n;
  }
  i(mB, "memberExpression");
  function yB(e, t) {
    let r = {
      type: "NewExpression",
      callee: e,
      arguments: t
    }, s = B.NewExpression;
    return y(s.callee, r, "callee", e, 1), y(s.arguments, r, "arguments", t, 1), r;
  }
  i(yB, "newExpression");
  function bB(e, t = [], r = "script", s = null) {
    let n = {
      type: "Program",
      body: e,
      directives: t,
      sourceType: r,
      interpreter: s
    }, a = B.Program;
    return y(a.body, n, "body", e, 1), y(a.directives, n, "directives", t, 1), y(a.sourceType, n, "sourceType", r), y(a.interpreter, n, "int\
erpreter", s, 1), n;
  }
  i(bB, "program");
  function gB(e) {
    let t = {
      type: "ObjectExpression",
      properties: e
    }, r = B.ObjectExpression;
    return y(r.properties, t, "properties", e, 1), t;
  }
  i(gB, "objectExpression");
  function TB(e = "method", t, r, s, n = !1, a = !1, o = !1) {
    let l = {
      type: "ObjectMethod",
      kind: e,
      key: t,
      params: r,
      body: s,
      computed: n,
      generator: a,
      async: o
    }, u = B.ObjectMethod;
    return y(u.kind, l, "kind", e), y(u.key, l, "key", t, 1), y(u.params, l, "params", r, 1), y(u.body, l, "body", s, 1), y(u.computed, l, "\
computed", n), y(u.generator, l, "generator", a), y(u.async, l, "async", o), l;
  }
  i(TB, "objectMethod");
  function xB(e, t, r = !1, s = !1, n = null) {
    let a = {
      type: "ObjectProperty",
      key: e,
      value: t,
      computed: r,
      shorthand: s,
      decorators: n
    }, o = B.ObjectProperty;
    return y(o.key, a, "key", e, 1), y(o.value, a, "value", t, 1), y(o.computed, a, "computed", r), y(o.shorthand, a, "shorthand", s), y(o.decorators,
    a, "decorators", n, 1), a;
  }
  i(xB, "objectProperty");
  function Ug(e) {
    let t = {
      type: "RestElement",
      argument: e
    }, r = B.RestElement;
    return y(r.argument, t, "argument", e, 1), t;
  }
  i(Ug, "restElement");
  function EB(e = null) {
    let t = {
      type: "ReturnStatement",
      argument: e
    }, r = B.ReturnStatement;
    return y(r.argument, t, "argument", e, 1), t;
  }
  i(EB, "returnStatement");
  function SB(e) {
    let t = {
      type: "SequenceExpression",
      expressions: e
    }, r = B.SequenceExpression;
    return y(r.expressions, t, "expressions", e, 1), t;
  }
  i(SB, "sequenceExpression");
  function vB(e) {
    let t = {
      type: "ParenthesizedExpression",
      expression: e
    }, r = B.ParenthesizedExpression;
    return y(r.expression, t, "expression", e, 1), t;
  }
  i(vB, "parenthesizedExpression");
  function PB(e = null, t) {
    let r = {
      type: "SwitchCase",
      test: e,
      consequent: t
    }, s = B.SwitchCase;
    return y(s.test, r, "test", e, 1), y(s.consequent, r, "consequent", t, 1), r;
  }
  i(PB, "switchCase");
  function AB(e, t) {
    let r = {
      type: "SwitchStatement",
      discriminant: e,
      cases: t
    }, s = B.SwitchStatement;
    return y(s.discriminant, r, "discriminant", e, 1), y(s.cases, r, "cases", t, 1), r;
  }
  i(AB, "switchStatement");
  function CB() {
    return {
      type: "ThisExpression"
    };
  }
  i(CB, "thisExpression");
  function wB(e) {
    let t = {
      type: "ThrowStatement",
      argument: e
    }, r = B.ThrowStatement;
    return y(r.argument, t, "argument", e, 1), t;
  }
  i(wB, "throwStatement");
  function DB(e, t = null, r = null) {
    let s = {
      type: "TryStatement",
      block: e,
      handler: t,
      finalizer: r
    }, n = B.TryStatement;
    return y(n.block, s, "block", e, 1), y(n.handler, s, "handler", t, 1), y(n.finalizer, s, "finalizer", r, 1), s;
  }
  i(DB, "tryStatement");
  function _B(e, t, r = !0) {
    let s = {
      type: "UnaryExpression",
      operator: e,
      argument: t,
      prefix: r
    }, n = B.UnaryExpression;
    return y(n.operator, s, "operator", e), y(n.argument, s, "argument", t, 1), y(n.prefix, s, "prefix", r), s;
  }
  i(_B, "unaryExpression");
  function IB(e, t, r = !1) {
    let s = {
      type: "UpdateExpression",
      operator: e,
      argument: t,
      prefix: r
    }, n = B.UpdateExpression;
    return y(n.operator, s, "operator", e), y(n.argument, s, "argument", t, 1), y(n.prefix, s, "prefix", r), s;
  }
  i(IB, "updateExpression");
  function OB(e, t) {
    let r = {
      type: "VariableDeclaration",
      kind: e,
      declarations: t
    }, s = B.VariableDeclaration;
    return y(s.kind, r, "kind", e), y(s.declarations, r, "declarations", t, 1), r;
  }
  i(OB, "variableDeclaration");
  function NB(e, t = null) {
    let r = {
      type: "VariableDeclarator",
      id: e,
      init: t
    }, s = B.VariableDeclarator;
    return y(s.id, r, "id", e, 1), y(s.init, r, "init", t, 1), r;
  }
  i(NB, "variableDeclarator");
  function BB(e, t) {
    let r = {
      type: "WhileStatement",
      test: e,
      body: t
    }, s = B.WhileStatement;
    return y(s.test, r, "test", e, 1), y(s.body, r, "body", t, 1), r;
  }
  i(BB, "whileStatement");
  function kB(e, t) {
    let r = {
      type: "WithStatement",
      object: e,
      body: t
    }, s = B.WithStatement;
    return y(s.object, r, "object", e, 1), y(s.body, r, "body", t, 1), r;
  }
  i(kB, "withStatement");
  function FB(e, t) {
    let r = {
      type: "AssignmentPattern",
      left: e,
      right: t
    }, s = B.AssignmentPattern;
    return y(s.left, r, "left", e, 1), y(s.right, r, "right", t, 1), r;
  }
  i(FB, "assignmentPattern");
  function LB(e) {
    let t = {
      type: "ArrayPattern",
      elements: e
    }, r = B.ArrayPattern;
    return y(r.elements, t, "elements", e, 1), t;
  }
  i(LB, "arrayPattern");
  function jB(e, t, r = !1) {
    let s = {
      type: "ArrowFunctionExpression",
      params: e,
      body: t,
      async: r,
      expression: null
    }, n = B.ArrowFunctionExpression;
    return y(n.params, s, "params", e, 1), y(n.body, s, "body", t, 1), y(n.async, s, "async", r), s;
  }
  i(jB, "arrowFunctionExpression");
  function MB(e) {
    let t = {
      type: "ClassBody",
      body: e
    }, r = B.ClassBody;
    return y(r.body, t, "body", e, 1), t;
  }
  i(MB, "classBody");
  function RB(e = null, t = null, r, s = null) {
    let n = {
      type: "ClassExpression",
      id: e,
      superClass: t,
      body: r,
      decorators: s
    }, a = B.ClassExpression;
    return y(a.id, n, "id", e, 1), y(a.superClass, n, "superClass", t, 1), y(a.body, n, "body", r, 1), y(a.decorators, n, "decorators", s, 1),
    n;
  }
  i(RB, "classExpression");
  function qB(e = null, t = null, r, s = null) {
    let n = {
      type: "ClassDeclaration",
      id: e,
      superClass: t,
      body: r,
      decorators: s
    }, a = B.ClassDeclaration;
    return y(a.id, n, "id", e, 1), y(a.superClass, n, "superClass", t, 1), y(a.body, n, "body", r, 1), y(a.decorators, n, "decorators", s, 1),
    n;
  }
  i(qB, "classDeclaration");
  function UB(e) {
    let t = {
      type: "ExportAllDeclaration",
      source: e
    }, r = B.ExportAllDeclaration;
    return y(r.source, t, "source", e, 1), t;
  }
  i(UB, "exportAllDeclaration");
  function $B(e) {
    let t = {
      type: "ExportDefaultDeclaration",
      declaration: e
    }, r = B.ExportDefaultDeclaration;
    return y(r.declaration, t, "declaration", e, 1), t;
  }
  i($B, "exportDefaultDeclaration");
  function VB(e = null, t = [], r = null) {
    let s = {
      type: "ExportNamedDeclaration",
      declaration: e,
      specifiers: t,
      source: r
    }, n = B.ExportNamedDeclaration;
    return y(n.declaration, s, "declaration", e, 1), y(n.specifiers, s, "specifiers", t, 1), y(n.source, s, "source", r, 1), s;
  }
  i(VB, "exportNamedDeclaration");
  function KB(e, t) {
    let r = {
      type: "ExportSpecifier",
      local: e,
      exported: t
    }, s = B.ExportSpecifier;
    return y(s.local, r, "local", e, 1), y(s.exported, r, "exported", t, 1), r;
  }
  i(KB, "exportSpecifier");
  function WB(e, t, r, s = !1) {
    let n = {
      type: "ForOfStatement",
      left: e,
      right: t,
      body: r,
      await: s
    }, a = B.ForOfStatement;
    return y(a.left, n, "left", e, 1), y(a.right, n, "right", t, 1), y(a.body, n, "body", r, 1), y(a.await, n, "await", s), n;
  }
  i(WB, "forOfStatement");
  function YB(e, t) {
    let r = {
      type: "ImportDeclaration",
      specifiers: e,
      source: t
    }, s = B.ImportDeclaration;
    return y(s.specifiers, r, "specifiers", e, 1), y(s.source, r, "source", t, 1), r;
  }
  i(YB, "importDeclaration");
  function HB(e) {
    let t = {
      type: "ImportDefaultSpecifier",
      local: e
    }, r = B.ImportDefaultSpecifier;
    return y(r.local, t, "local", e, 1), t;
  }
  i(HB, "importDefaultSpecifier");
  function JB(e) {
    let t = {
      type: "ImportNamespaceSpecifier",
      local: e
    }, r = B.ImportNamespaceSpecifier;
    return y(r.local, t, "local", e, 1), t;
  }
  i(JB, "importNamespaceSpecifier");
  function GB(e, t) {
    let r = {
      type: "ImportSpecifier",
      local: e,
      imported: t
    }, s = B.ImportSpecifier;
    return y(s.local, r, "local", e, 1), y(s.imported, r, "imported", t, 1), r;
  }
  i(GB, "importSpecifier");
  function XB(e, t = null) {
    let r = {
      type: "ImportExpression",
      source: e,
      options: t
    }, s = B.ImportExpression;
    return y(s.source, r, "source", e, 1), y(s.options, r, "options", t, 1), r;
  }
  i(XB, "importExpression");
  function zB(e, t) {
    let r = {
      type: "MetaProperty",
      meta: e,
      property: t
    }, s = B.MetaProperty;
    return y(s.meta, r, "meta", e, 1), y(s.property, r, "property", t, 1), r;
  }
  i(zB, "metaProperty");
  function QB(e = "method", t, r, s, n = !1, a = !1, o = !1, l = !1) {
    let u = {
      type: "ClassMethod",
      kind: e,
      key: t,
      params: r,
      body: s,
      computed: n,
      static: a,
      generator: o,
      async: l
    }, c = B.ClassMethod;
    return y(c.kind, u, "kind", e), y(c.key, u, "key", t, 1), y(c.params, u, "params", r, 1), y(c.body, u, "body", s, 1), y(c.computed, u, "\
computed", n), y(c.static, u, "static", a), y(c.generator, u, "generator", o), y(c.async, u, "async", l), u;
  }
  i(QB, "classMethod");
  function ZB(e) {
    let t = {
      type: "ObjectPattern",
      properties: e
    }, r = B.ObjectPattern;
    return y(r.properties, t, "properties", e, 1), t;
  }
  i(ZB, "objectPattern");
  function $g(e) {
    let t = {
      type: "SpreadElement",
      argument: e
    }, r = B.SpreadElement;
    return y(r.argument, t, "argument", e, 1), t;
  }
  i($g, "spreadElement");
  function ek() {
    return {
      type: "Super"
    };
  }
  i(ek, "_super");
  function tk(e, t) {
    let r = {
      type: "TaggedTemplateExpression",
      tag: e,
      quasi: t
    }, s = B.TaggedTemplateExpression;
    return y(s.tag, r, "tag", e, 1), y(s.quasi, r, "quasi", t, 1), r;
  }
  i(tk, "taggedTemplateExpression");
  function rk(e, t = !1) {
    let r = {
      type: "TemplateElement",
      value: e,
      tail: t
    }, s = B.TemplateElement;
    return y(s.value, r, "value", e), y(s.tail, r, "tail", t), r;
  }
  i(rk, "templateElement");
  function sk(e, t) {
    let r = {
      type: "TemplateLiteral",
      quasis: e,
      expressions: t
    }, s = B.TemplateLiteral;
    return y(s.quasis, r, "quasis", e, 1), y(s.expressions, r, "expressions", t, 1), r;
  }
  i(sk, "templateLiteral");
  function nk(e = null, t = !1) {
    let r = {
      type: "YieldExpression",
      argument: e,
      delegate: t
    }, s = B.YieldExpression;
    return y(s.argument, r, "argument", e, 1), y(s.delegate, r, "delegate", t), r;
  }
  i(nk, "yieldExpression");
  function ik(e) {
    let t = {
      type: "AwaitExpression",
      argument: e
    }, r = B.AwaitExpression;
    return y(r.argument, t, "argument", e, 1), t;
  }
  i(ik, "awaitExpression");
  function ak() {
    return {
      type: "Import"
    };
  }
  i(ak, "_import");
  function ok(e) {
    let t = {
      type: "ExportNamespaceSpecifier",
      exported: e
    }, r = B.ExportNamespaceSpecifier;
    return y(r.exported, t, "exported", e, 1), t;
  }
  i(ok, "exportNamespaceSpecifier");
  function lk(e, t, r = !1, s) {
    let n = {
      type: "OptionalMemberExpression",
      object: e,
      property: t,
      computed: r,
      optional: s
    }, a = B.OptionalMemberExpression;
    return y(a.object, n, "object", e, 1), y(a.property, n, "property", t, 1), y(a.computed, n, "computed", r), y(a.optional, n, "optional",
    s), n;
  }
  i(lk, "optionalMemberExpression");
  function uk(e, t, r) {
    let s = {
      type: "OptionalCallExpression",
      callee: e,
      arguments: t,
      optional: r
    }, n = B.OptionalCallExpression;
    return y(n.callee, s, "callee", e, 1), y(n.arguments, s, "arguments", t, 1), y(n.optional, s, "optional", r), s;
  }
  i(uk, "optionalCallExpression");
  function ck(e, t = null, r = null, s = null, n = !1, a = !1) {
    let o = {
      type: "ClassProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: s,
      computed: n,
      static: a
    }, l = B.ClassProperty;
    return y(l.key, o, "key", e, 1), y(l.value, o, "value", t, 1), y(l.typeAnnotation, o, "typeAnnotation", r, 1), y(l.decorators, o, "decor\
ators", s, 1), y(l.computed, o, "computed", n), y(l.static, o, "static", a), o;
  }
  i(ck, "classProperty");
  function pk(e, t = null, r = null, s = null, n = !1, a = !1) {
    let o = {
      type: "ClassAccessorProperty",
      key: e,
      value: t,
      typeAnnotation: r,
      decorators: s,
      computed: n,
      static: a
    }, l = B.ClassAccessorProperty;
    return y(l.key, o, "key", e, 1), y(l.value, o, "value", t, 1), y(l.typeAnnotation, o, "typeAnnotation", r, 1), y(l.decorators, o, "decor\
ators", s, 1), y(l.computed, o, "computed", n), y(l.static, o, "static", a), o;
  }
  i(pk, "classAccessorProperty");
  function fk(e, t = null, r = null, s = !1) {
    let n = {
      type: "ClassPrivateProperty",
      key: e,
      value: t,
      decorators: r,
      static: s
    }, a = B.ClassPrivateProperty;
    return y(a.key, n, "key", e, 1), y(a.value, n, "value", t, 1), y(a.decorators, n, "decorators", r, 1), y(a.static, n, "static", s), n;
  }
  i(fk, "classPrivateProperty");
  function dk(e = "method", t, r, s, n = !1) {
    let a = {
      type: "ClassPrivateMethod",
      kind: e,
      key: t,
      params: r,
      body: s,
      static: n
    }, o = B.ClassPrivateMethod;
    return y(o.kind, a, "kind", e), y(o.key, a, "key", t, 1), y(o.params, a, "params", r, 1), y(o.body, a, "body", s, 1), y(o.static, a, "st\
atic", n), a;
  }
  i(dk, "classPrivateMethod");
  function hk(e) {
    let t = {
      type: "PrivateName",
      id: e
    }, r = B.PrivateName;
    return y(r.id, t, "id", e, 1), t;
  }
  i(hk, "privateName");
  function mk(e) {
    let t = {
      type: "StaticBlock",
      body: e
    }, r = B.StaticBlock;
    return y(r.body, t, "body", e, 1), t;
  }
  i(mk, "staticBlock");
  function yk(e, t) {
    let r = {
      type: "ImportAttribute",
      key: e,
      value: t
    }, s = B.ImportAttribute;
    return y(s.key, r, "key", e, 1), y(s.value, r, "value", t, 1), r;
  }
  i(yk, "importAttribute");
  function bk() {
    return {
      type: "AnyTypeAnnotation"
    };
  }
  i(bk, "anyTypeAnnotation");
  function gk(e) {
    let t = {
      type: "ArrayTypeAnnotation",
      elementType: e
    }, r = B.ArrayTypeAnnotation;
    return y(r.elementType, t, "elementType", e, 1), t;
  }
  i(gk, "arrayTypeAnnotation");
  function Tk() {
    return {
      type: "BooleanTypeAnnotation"
    };
  }
  i(Tk, "booleanTypeAnnotation");
  function xk(e) {
    let t = {
      type: "BooleanLiteralTypeAnnotation",
      value: e
    }, r = B.BooleanLiteralTypeAnnotation;
    return y(r.value, t, "value", e), t;
  }
  i(xk, "booleanLiteralTypeAnnotation");
  function Ek() {
    return {
      type: "NullLiteralTypeAnnotation"
    };
  }
  i(Ek, "nullLiteralTypeAnnotation");
  function Sk(e, t = null) {
    let r = {
      type: "ClassImplements",
      id: e,
      typeParameters: t
    }, s = B.ClassImplements;
    return y(s.id, r, "id", e, 1), y(s.typeParameters, r, "typeParameters", t, 1), r;
  }
  i(Sk, "classImplements");
  function vk(e, t = null, r = null, s) {
    let n = {
      type: "DeclareClass",
      id: e,
      typeParameters: t,
      extends: r,
      body: s
    }, a = B.DeclareClass;
    return y(a.id, n, "id", e, 1), y(a.typeParameters, n, "typeParameters", t, 1), y(a.extends, n, "extends", r, 1), y(a.body, n, "body", s,
    1), n;
  }
  i(vk, "declareClass");
  function Pk(e) {
    let t = {
      type: "DeclareFunction",
      id: e
    }, r = B.DeclareFunction;
    return y(r.id, t, "id", e, 1), t;
  }
  i(Pk, "declareFunction");
  function Ak(e, t = null, r = null, s) {
    let n = {
      type: "DeclareInterface",
      id: e,
      typeParameters: t,
      extends: r,
      body: s
    }, a = B.DeclareInterface;
    return y(a.id, n, "id", e, 1), y(a.typeParameters, n, "typeParameters", t, 1), y(a.extends, n, "extends", r, 1), y(a.body, n, "body", s,
    1), n;
  }
  i(Ak, "declareInterface");
  function Ck(e, t, r = null) {
    let s = {
      type: "DeclareModule",
      id: e,
      body: t,
      kind: r
    }, n = B.DeclareModule;
    return y(n.id, s, "id", e, 1), y(n.body, s, "body", t, 1), y(n.kind, s, "kind", r), s;
  }
  i(Ck, "declareModule");
  function wk(e) {
    let t = {
      type: "DeclareModuleExports",
      typeAnnotation: e
    }, r = B.DeclareModuleExports;
    return y(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  i(wk, "declareModuleExports");
  function Dk(e, t = null, r) {
    let s = {
      type: "DeclareTypeAlias",
      id: e,
      typeParameters: t,
      right: r
    }, n = B.DeclareTypeAlias;
    return y(n.id, s, "id", e, 1), y(n.typeParameters, s, "typeParameters", t, 1), y(n.right, s, "right", r, 1), s;
  }
  i(Dk, "declareTypeAlias");
  function _k(e, t = null, r = null) {
    let s = {
      type: "DeclareOpaqueType",
      id: e,
      typeParameters: t,
      supertype: r
    }, n = B.DeclareOpaqueType;
    return y(n.id, s, "id", e, 1), y(n.typeParameters, s, "typeParameters", t, 1), y(n.supertype, s, "supertype", r, 1), s;
  }
  i(_k, "declareOpaqueType");
  function Ik(e) {
    let t = {
      type: "DeclareVariable",
      id: e
    }, r = B.DeclareVariable;
    return y(r.id, t, "id", e, 1), t;
  }
  i(Ik, "declareVariable");
  function Ok(e = null, t = null, r = null, s = null) {
    let n = {
      type: "DeclareExportDeclaration",
      declaration: e,
      specifiers: t,
      source: r,
      attributes: s
    }, a = B.DeclareExportDeclaration;
    return y(a.declaration, n, "declaration", e, 1), y(a.specifiers, n, "specifiers", t, 1), y(a.source, n, "source", r, 1), y(a.attributes,
    n, "attributes", s, 1), n;
  }
  i(Ok, "declareExportDeclaration");
  function Nk(e, t = null) {
    let r = {
      type: "DeclareExportAllDeclaration",
      source: e,
      attributes: t
    }, s = B.DeclareExportAllDeclaration;
    return y(s.source, r, "source", e, 1), y(s.attributes, r, "attributes", t, 1), r;
  }
  i(Nk, "declareExportAllDeclaration");
  function Bk(e) {
    let t = {
      type: "DeclaredPredicate",
      value: e
    }, r = B.DeclaredPredicate;
    return y(r.value, t, "value", e, 1), t;
  }
  i(Bk, "declaredPredicate");
  function kk() {
    return {
      type: "ExistsTypeAnnotation"
    };
  }
  i(kk, "existsTypeAnnotation");
  function Fk(e = null, t, r = null, s) {
    let n = {
      type: "FunctionTypeAnnotation",
      typeParameters: e,
      params: t,
      rest: r,
      returnType: s
    }, a = B.FunctionTypeAnnotation;
    return y(a.typeParameters, n, "typeParameters", e, 1), y(a.params, n, "params", t, 1), y(a.rest, n, "rest", r, 1), y(a.returnType, n, "r\
eturnType", s, 1), n;
  }
  i(Fk, "functionTypeAnnotation");
  function Lk(e = null, t) {
    let r = {
      type: "FunctionTypeParam",
      name: e,
      typeAnnotation: t
    }, s = B.FunctionTypeParam;
    return y(s.name, r, "name", e, 1), y(s.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  i(Lk, "functionTypeParam");
  function jk(e, t = null) {
    let r = {
      type: "GenericTypeAnnotation",
      id: e,
      typeParameters: t
    }, s = B.GenericTypeAnnotation;
    return y(s.id, r, "id", e, 1), y(s.typeParameters, r, "typeParameters", t, 1), r;
  }
  i(jk, "genericTypeAnnotation");
  function Mk() {
    return {
      type: "InferredPredicate"
    };
  }
  i(Mk, "inferredPredicate");
  function Rk(e, t = null) {
    let r = {
      type: "InterfaceExtends",
      id: e,
      typeParameters: t
    }, s = B.InterfaceExtends;
    return y(s.id, r, "id", e, 1), y(s.typeParameters, r, "typeParameters", t, 1), r;
  }
  i(Rk, "interfaceExtends");
  function qk(e, t = null, r = null, s) {
    let n = {
      type: "InterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: s
    }, a = B.InterfaceDeclaration;
    return y(a.id, n, "id", e, 1), y(a.typeParameters, n, "typeParameters", t, 1), y(a.extends, n, "extends", r, 1), y(a.body, n, "body", s,
    1), n;
  }
  i(qk, "interfaceDeclaration");
  function Uk(e = null, t) {
    let r = {
      type: "InterfaceTypeAnnotation",
      extends: e,
      body: t
    }, s = B.InterfaceTypeAnnotation;
    return y(s.extends, r, "extends", e, 1), y(s.body, r, "body", t, 1), r;
  }
  i(Uk, "interfaceTypeAnnotation");
  function $k(e) {
    let t = {
      type: "IntersectionTypeAnnotation",
      types: e
    }, r = B.IntersectionTypeAnnotation;
    return y(r.types, t, "types", e, 1), t;
  }
  i($k, "intersectionTypeAnnotation");
  function Vk() {
    return {
      type: "MixedTypeAnnotation"
    };
  }
  i(Vk, "mixedTypeAnnotation");
  function Kk() {
    return {
      type: "EmptyTypeAnnotation"
    };
  }
  i(Kk, "emptyTypeAnnotation");
  function Wk(e) {
    let t = {
      type: "NullableTypeAnnotation",
      typeAnnotation: e
    }, r = B.NullableTypeAnnotation;
    return y(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  i(Wk, "nullableTypeAnnotation");
  function Yk(e) {
    let t = {
      type: "NumberLiteralTypeAnnotation",
      value: e
    }, r = B.NumberLiteralTypeAnnotation;
    return y(r.value, t, "value", e), t;
  }
  i(Yk, "numberLiteralTypeAnnotation");
  function Hk() {
    return {
      type: "NumberTypeAnnotation"
    };
  }
  i(Hk, "numberTypeAnnotation");
  function Jk(e, t = [], r = [], s = [], n = !1) {
    let a = {
      type: "ObjectTypeAnnotation",
      properties: e,
      indexers: t,
      callProperties: r,
      internalSlots: s,
      exact: n
    }, o = B.ObjectTypeAnnotation;
    return y(o.properties, a, "properties", e, 1), y(o.indexers, a, "indexers", t, 1), y(o.callProperties, a, "callProperties", r, 1), y(o.internalSlots,
    a, "internalSlots", s, 1), y(o.exact, a, "exact", n), a;
  }
  i(Jk, "objectTypeAnnotation");
  function Gk(e, t, r, s, n) {
    let a = {
      type: "ObjectTypeInternalSlot",
      id: e,
      value: t,
      optional: r,
      static: s,
      method: n
    }, o = B.ObjectTypeInternalSlot;
    return y(o.id, a, "id", e, 1), y(o.value, a, "value", t, 1), y(o.optional, a, "optional", r), y(o.static, a, "static", s), y(o.method, a,
    "method", n), a;
  }
  i(Gk, "objectTypeInternalSlot");
  function Xk(e) {
    let t = {
      type: "ObjectTypeCallProperty",
      value: e,
      static: null
    }, r = B.ObjectTypeCallProperty;
    return y(r.value, t, "value", e, 1), t;
  }
  i(Xk, "objectTypeCallProperty");
  function zk(e = null, t, r, s = null) {
    let n = {
      type: "ObjectTypeIndexer",
      id: e,
      key: t,
      value: r,
      variance: s,
      static: null
    }, a = B.ObjectTypeIndexer;
    return y(a.id, n, "id", e, 1), y(a.key, n, "key", t, 1), y(a.value, n, "value", r, 1), y(a.variance, n, "variance", s, 1), n;
  }
  i(zk, "objectTypeIndexer");
  function Qk(e, t, r = null) {
    let s = {
      type: "ObjectTypeProperty",
      key: e,
      value: t,
      variance: r,
      kind: null,
      method: null,
      optional: null,
      proto: null,
      static: null
    }, n = B.ObjectTypeProperty;
    return y(n.key, s, "key", e, 1), y(n.value, s, "value", t, 1), y(n.variance, s, "variance", r, 1), s;
  }
  i(Qk, "objectTypeProperty");
  function Zk(e) {
    let t = {
      type: "ObjectTypeSpreadProperty",
      argument: e
    }, r = B.ObjectTypeSpreadProperty;
    return y(r.argument, t, "argument", e, 1), t;
  }
  i(Zk, "objectTypeSpreadProperty");
  function eF(e, t = null, r = null, s) {
    let n = {
      type: "OpaqueType",
      id: e,
      typeParameters: t,
      supertype: r,
      impltype: s
    }, a = B.OpaqueType;
    return y(a.id, n, "id", e, 1), y(a.typeParameters, n, "typeParameters", t, 1), y(a.supertype, n, "supertype", r, 1), y(a.impltype, n, "i\
mpltype", s, 1), n;
  }
  i(eF, "opaqueType");
  function tF(e, t) {
    let r = {
      type: "QualifiedTypeIdentifier",
      id: e,
      qualification: t
    }, s = B.QualifiedTypeIdentifier;
    return y(s.id, r, "id", e, 1), y(s.qualification, r, "qualification", t, 1), r;
  }
  i(tF, "qualifiedTypeIdentifier");
  function rF(e) {
    let t = {
      type: "StringLiteralTypeAnnotation",
      value: e
    }, r = B.StringLiteralTypeAnnotation;
    return y(r.value, t, "value", e), t;
  }
  i(rF, "stringLiteralTypeAnnotation");
  function sF() {
    return {
      type: "StringTypeAnnotation"
    };
  }
  i(sF, "stringTypeAnnotation");
  function nF() {
    return {
      type: "SymbolTypeAnnotation"
    };
  }
  i(nF, "symbolTypeAnnotation");
  function iF() {
    return {
      type: "ThisTypeAnnotation"
    };
  }
  i(iF, "thisTypeAnnotation");
  function aF(e) {
    let t = {
      type: "TupleTypeAnnotation",
      types: e
    }, r = B.TupleTypeAnnotation;
    return y(r.types, t, "types", e, 1), t;
  }
  i(aF, "tupleTypeAnnotation");
  function oF(e) {
    let t = {
      type: "TypeofTypeAnnotation",
      argument: e
    }, r = B.TypeofTypeAnnotation;
    return y(r.argument, t, "argument", e, 1), t;
  }
  i(oF, "typeofTypeAnnotation");
  function lF(e, t = null, r) {
    let s = {
      type: "TypeAlias",
      id: e,
      typeParameters: t,
      right: r
    }, n = B.TypeAlias;
    return y(n.id, s, "id", e, 1), y(n.typeParameters, s, "typeParameters", t, 1), y(n.right, s, "right", r, 1), s;
  }
  i(lF, "typeAlias");
  function uF(e) {
    let t = {
      type: "TypeAnnotation",
      typeAnnotation: e
    }, r = B.TypeAnnotation;
    return y(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  i(uF, "typeAnnotation");
  function cF(e, t) {
    let r = {
      type: "TypeCastExpression",
      expression: e,
      typeAnnotation: t
    }, s = B.TypeCastExpression;
    return y(s.expression, r, "expression", e, 1), y(s.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  i(cF, "typeCastExpression");
  function pF(e = null, t = null, r = null) {
    let s = {
      type: "TypeParameter",
      bound: e,
      default: t,
      variance: r,
      name: null
    }, n = B.TypeParameter;
    return y(n.bound, s, "bound", e, 1), y(n.default, s, "default", t, 1), y(n.variance, s, "variance", r, 1), s;
  }
  i(pF, "typeParameter");
  function fF(e) {
    let t = {
      type: "TypeParameterDeclaration",
      params: e
    }, r = B.TypeParameterDeclaration;
    return y(r.params, t, "params", e, 1), t;
  }
  i(fF, "typeParameterDeclaration");
  function dF(e) {
    let t = {
      type: "TypeParameterInstantiation",
      params: e
    }, r = B.TypeParameterInstantiation;
    return y(r.params, t, "params", e, 1), t;
  }
  i(dF, "typeParameterInstantiation");
  function hF(e) {
    let t = {
      type: "UnionTypeAnnotation",
      types: e
    }, r = B.UnionTypeAnnotation;
    return y(r.types, t, "types", e, 1), t;
  }
  i(hF, "unionTypeAnnotation");
  function mF(e) {
    let t = {
      type: "Variance",
      kind: e
    }, r = B.Variance;
    return y(r.kind, t, "kind", e), t;
  }
  i(mF, "variance");
  function yF() {
    return {
      type: "VoidTypeAnnotation"
    };
  }
  i(yF, "voidTypeAnnotation");
  function bF(e, t) {
    let r = {
      type: "EnumDeclaration",
      id: e,
      body: t
    }, s = B.EnumDeclaration;
    return y(s.id, r, "id", e, 1), y(s.body, r, "body", t, 1), r;
  }
  i(bF, "enumDeclaration");
  function gF(e) {
    let t = {
      type: "EnumBooleanBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    }, r = B.EnumBooleanBody;
    return y(r.members, t, "members", e, 1), t;
  }
  i(gF, "enumBooleanBody");
  function TF(e) {
    let t = {
      type: "EnumNumberBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    }, r = B.EnumNumberBody;
    return y(r.members, t, "members", e, 1), t;
  }
  i(TF, "enumNumberBody");
  function xF(e) {
    let t = {
      type: "EnumStringBody",
      members: e,
      explicitType: null,
      hasUnknownMembers: null
    }, r = B.EnumStringBody;
    return y(r.members, t, "members", e, 1), t;
  }
  i(xF, "enumStringBody");
  function EF(e) {
    let t = {
      type: "EnumSymbolBody",
      members: e,
      hasUnknownMembers: null
    }, r = B.EnumSymbolBody;
    return y(r.members, t, "members", e, 1), t;
  }
  i(EF, "enumSymbolBody");
  function SF(e) {
    let t = {
      type: "EnumBooleanMember",
      id: e,
      init: null
    }, r = B.EnumBooleanMember;
    return y(r.id, t, "id", e, 1), t;
  }
  i(SF, "enumBooleanMember");
  function vF(e, t) {
    let r = {
      type: "EnumNumberMember",
      id: e,
      init: t
    }, s = B.EnumNumberMember;
    return y(s.id, r, "id", e, 1), y(s.init, r, "init", t, 1), r;
  }
  i(vF, "enumNumberMember");
  function PF(e, t) {
    let r = {
      type: "EnumStringMember",
      id: e,
      init: t
    }, s = B.EnumStringMember;
    return y(s.id, r, "id", e, 1), y(s.init, r, "init", t, 1), r;
  }
  i(PF, "enumStringMember");
  function AF(e) {
    let t = {
      type: "EnumDefaultedMember",
      id: e
    }, r = B.EnumDefaultedMember;
    return y(r.id, t, "id", e, 1), t;
  }
  i(AF, "enumDefaultedMember");
  function CF(e, t) {
    let r = {
      type: "IndexedAccessType",
      objectType: e,
      indexType: t
    }, s = B.IndexedAccessType;
    return y(s.objectType, r, "objectType", e, 1), y(s.indexType, r, "indexType", t, 1), r;
  }
  i(CF, "indexedAccessType");
  function wF(e, t) {
    let r = {
      type: "OptionalIndexedAccessType",
      objectType: e,
      indexType: t,
      optional: null
    }, s = B.OptionalIndexedAccessType;
    return y(s.objectType, r, "objectType", e, 1), y(s.indexType, r, "indexType", t, 1), r;
  }
  i(wF, "optionalIndexedAccessType");
  function DF(e, t = null) {
    let r = {
      type: "JSXAttribute",
      name: e,
      value: t
    }, s = B.JSXAttribute;
    return y(s.name, r, "name", e, 1), y(s.value, r, "value", t, 1), r;
  }
  i(DF, "jsxAttribute");
  function _F(e) {
    let t = {
      type: "JSXClosingElement",
      name: e
    }, r = B.JSXClosingElement;
    return y(r.name, t, "name", e, 1), t;
  }
  i(_F, "jsxClosingElement");
  function IF(e, t = null, r, s = null) {
    let n = {
      type: "JSXElement",
      openingElement: e,
      closingElement: t,
      children: r,
      selfClosing: s
    }, a = B.JSXElement;
    return y(a.openingElement, n, "openingElement", e, 1), y(a.closingElement, n, "closingElement", t, 1), y(a.children, n, "children", r, 1),
    y(a.selfClosing, n, "selfClosing", s), n;
  }
  i(IF, "jsxElement");
  function OF() {
    return {
      type: "JSXEmptyExpression"
    };
  }
  i(OF, "jsxEmptyExpression");
  function NF(e) {
    let t = {
      type: "JSXExpressionContainer",
      expression: e
    }, r = B.JSXExpressionContainer;
    return y(r.expression, t, "expression", e, 1), t;
  }
  i(NF, "jsxExpressionContainer");
  function BF(e) {
    let t = {
      type: "JSXSpreadChild",
      expression: e
    }, r = B.JSXSpreadChild;
    return y(r.expression, t, "expression", e, 1), t;
  }
  i(BF, "jsxSpreadChild");
  function kF(e) {
    let t = {
      type: "JSXIdentifier",
      name: e
    }, r = B.JSXIdentifier;
    return y(r.name, t, "name", e), t;
  }
  i(kF, "jsxIdentifier");
  function FF(e, t) {
    let r = {
      type: "JSXMemberExpression",
      object: e,
      property: t
    }, s = B.JSXMemberExpression;
    return y(s.object, r, "object", e, 1), y(s.property, r, "property", t, 1), r;
  }
  i(FF, "jsxMemberExpression");
  function LF(e, t) {
    let r = {
      type: "JSXNamespacedName",
      namespace: e,
      name: t
    }, s = B.JSXNamespacedName;
    return y(s.namespace, r, "namespace", e, 1), y(s.name, r, "name", t, 1), r;
  }
  i(LF, "jsxNamespacedName");
  function jF(e, t, r = !1) {
    let s = {
      type: "JSXOpeningElement",
      name: e,
      attributes: t,
      selfClosing: r
    }, n = B.JSXOpeningElement;
    return y(n.name, s, "name", e, 1), y(n.attributes, s, "attributes", t, 1), y(n.selfClosing, s, "selfClosing", r), s;
  }
  i(jF, "jsxOpeningElement");
  function MF(e) {
    let t = {
      type: "JSXSpreadAttribute",
      argument: e
    }, r = B.JSXSpreadAttribute;
    return y(r.argument, t, "argument", e, 1), t;
  }
  i(MF, "jsxSpreadAttribute");
  function RF(e) {
    let t = {
      type: "JSXText",
      value: e
    }, r = B.JSXText;
    return y(r.value, t, "value", e), t;
  }
  i(RF, "jsxText");
  function qF(e, t, r) {
    let s = {
      type: "JSXFragment",
      openingFragment: e,
      closingFragment: t,
      children: r
    }, n = B.JSXFragment;
    return y(n.openingFragment, s, "openingFragment", e, 1), y(n.closingFragment, s, "closingFragment", t, 1), y(n.children, s, "children", r,
    1), s;
  }
  i(qF, "jsxFragment");
  function UF() {
    return {
      type: "JSXOpeningFragment"
    };
  }
  i(UF, "jsxOpeningFragment");
  function $F() {
    return {
      type: "JSXClosingFragment"
    };
  }
  i($F, "jsxClosingFragment");
  function VF() {
    return {
      type: "Noop"
    };
  }
  i(VF, "noop");
  function KF(e, t) {
    let r = {
      type: "Placeholder",
      expectedNode: e,
      name: t
    }, s = B.Placeholder;
    return y(s.expectedNode, r, "expectedNode", e), y(s.name, r, "name", t, 1), r;
  }
  i(KF, "placeholder");
  function WF(e) {
    let t = {
      type: "V8IntrinsicIdentifier",
      name: e
    }, r = B.V8IntrinsicIdentifier;
    return y(r.name, t, "name", e), t;
  }
  i(WF, "v8IntrinsicIdentifier");
  function YF() {
    return {
      type: "ArgumentPlaceholder"
    };
  }
  i(YF, "argumentPlaceholder");
  function HF(e, t) {
    let r = {
      type: "BindExpression",
      object: e,
      callee: t
    }, s = B.BindExpression;
    return y(s.object, r, "object", e, 1), y(s.callee, r, "callee", t, 1), r;
  }
  i(HF, "bindExpression");
  function JF(e) {
    let t = {
      type: "Decorator",
      expression: e
    }, r = B.Decorator;
    return y(r.expression, t, "expression", e, 1), t;
  }
  i(JF, "decorator");
  function GF(e, t = !1) {
    let r = {
      type: "DoExpression",
      body: e,
      async: t
    }, s = B.DoExpression;
    return y(s.body, r, "body", e, 1), y(s.async, r, "async", t), r;
  }
  i(GF, "doExpression");
  function XF(e) {
    let t = {
      type: "ExportDefaultSpecifier",
      exported: e
    }, r = B.ExportDefaultSpecifier;
    return y(r.exported, t, "exported", e, 1), t;
  }
  i(XF, "exportDefaultSpecifier");
  function zF(e) {
    let t = {
      type: "RecordExpression",
      properties: e
    }, r = B.RecordExpression;
    return y(r.properties, t, "properties", e, 1), t;
  }
  i(zF, "recordExpression");
  function QF(e = []) {
    let t = {
      type: "TupleExpression",
      elements: e
    }, r = B.TupleExpression;
    return y(r.elements, t, "elements", e, 1), t;
  }
  i(QF, "tupleExpression");
  function ZF(e) {
    let t = {
      type: "DecimalLiteral",
      value: e
    }, r = B.DecimalLiteral;
    return y(r.value, t, "value", e), t;
  }
  i(ZF, "decimalLiteral");
  function eL(e) {
    let t = {
      type: "ModuleExpression",
      body: e
    }, r = B.ModuleExpression;
    return y(r.body, t, "body", e, 1), t;
  }
  i(eL, "moduleExpression");
  function tL() {
    return {
      type: "TopicReference"
    };
  }
  i(tL, "topicReference");
  function rL(e) {
    let t = {
      type: "PipelineTopicExpression",
      expression: e
    }, r = B.PipelineTopicExpression;
    return y(r.expression, t, "expression", e, 1), t;
  }
  i(rL, "pipelineTopicExpression");
  function sL(e) {
    let t = {
      type: "PipelineBareFunction",
      callee: e
    }, r = B.PipelineBareFunction;
    return y(r.callee, t, "callee", e, 1), t;
  }
  i(sL, "pipelineBareFunction");
  function nL() {
    return {
      type: "PipelinePrimaryTopicReference"
    };
  }
  i(nL, "pipelinePrimaryTopicReference");
  function iL() {
    return {
      type: "VoidPattern"
    };
  }
  i(iL, "voidPattern");
  function aL(e) {
    let t = {
      type: "TSParameterProperty",
      parameter: e
    }, r = B.TSParameterProperty;
    return y(r.parameter, t, "parameter", e, 1), t;
  }
  i(aL, "tsParameterProperty");
  function oL(e = null, t = null, r, s = null) {
    let n = {
      type: "TSDeclareFunction",
      id: e,
      typeParameters: t,
      params: r,
      returnType: s
    }, a = B.TSDeclareFunction;
    return y(a.id, n, "id", e, 1), y(a.typeParameters, n, "typeParameters", t, 1), y(a.params, n, "params", r, 1), y(a.returnType, n, "retur\
nType", s, 1), n;
  }
  i(oL, "tsDeclareFunction");
  function lL(e = null, t, r = null, s, n = null) {
    let a = {
      type: "TSDeclareMethod",
      decorators: e,
      key: t,
      typeParameters: r,
      params: s,
      returnType: n
    }, o = B.TSDeclareMethod;
    return y(o.decorators, a, "decorators", e, 1), y(o.key, a, "key", t, 1), y(o.typeParameters, a, "typeParameters", r, 1), y(o.params, a, "\
params", s, 1), y(o.returnType, a, "returnType", n, 1), a;
  }
  i(lL, "tsDeclareMethod");
  function uL(e, t) {
    let r = {
      type: "TSQualifiedName",
      left: e,
      right: t
    }, s = B.TSQualifiedName;
    return y(s.left, r, "left", e, 1), y(s.right, r, "right", t, 1), r;
  }
  i(uL, "tsQualifiedName");
  function cL(e = null, t, r = null) {
    let s = {
      type: "TSCallSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, n = B.TSCallSignatureDeclaration;
    return y(n.typeParameters, s, "typeParameters", e, 1), y(n.parameters, s, "parameters", t, 1), y(n.typeAnnotation, s, "typeAnnotation", r,
    1), s;
  }
  i(cL, "tsCallSignatureDeclaration");
  function pL(e = null, t, r = null) {
    let s = {
      type: "TSConstructSignatureDeclaration",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, n = B.TSConstructSignatureDeclaration;
    return y(n.typeParameters, s, "typeParameters", e, 1), y(n.parameters, s, "parameters", t, 1), y(n.typeAnnotation, s, "typeAnnotation", r,
    1), s;
  }
  i(pL, "tsConstructSignatureDeclaration");
  function fL(e, t = null) {
    let r = {
      type: "TSPropertySignature",
      key: e,
      typeAnnotation: t
    }, s = B.TSPropertySignature;
    return y(s.key, r, "key", e, 1), y(s.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  i(fL, "tsPropertySignature");
  function dL(e, t = null, r, s = null) {
    let n = {
      type: "TSMethodSignature",
      key: e,
      typeParameters: t,
      parameters: r,
      typeAnnotation: s,
      kind: null
    }, a = B.TSMethodSignature;
    return y(a.key, n, "key", e, 1), y(a.typeParameters, n, "typeParameters", t, 1), y(a.parameters, n, "parameters", r, 1), y(a.typeAnnotation,
    n, "typeAnnotation", s, 1), n;
  }
  i(dL, "tsMethodSignature");
  function hL(e, t = null) {
    let r = {
      type: "TSIndexSignature",
      parameters: e,
      typeAnnotation: t
    }, s = B.TSIndexSignature;
    return y(s.parameters, r, "parameters", e, 1), y(s.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  i(hL, "tsIndexSignature");
  function mL() {
    return {
      type: "TSAnyKeyword"
    };
  }
  i(mL, "tsAnyKeyword");
  function yL() {
    return {
      type: "TSBooleanKeyword"
    };
  }
  i(yL, "tsBooleanKeyword");
  function bL() {
    return {
      type: "TSBigIntKeyword"
    };
  }
  i(bL, "tsBigIntKeyword");
  function gL() {
    return {
      type: "TSIntrinsicKeyword"
    };
  }
  i(gL, "tsIntrinsicKeyword");
  function TL() {
    return {
      type: "TSNeverKeyword"
    };
  }
  i(TL, "tsNeverKeyword");
  function xL() {
    return {
      type: "TSNullKeyword"
    };
  }
  i(xL, "tsNullKeyword");
  function EL() {
    return {
      type: "TSNumberKeyword"
    };
  }
  i(EL, "tsNumberKeyword");
  function SL() {
    return {
      type: "TSObjectKeyword"
    };
  }
  i(SL, "tsObjectKeyword");
  function vL() {
    return {
      type: "TSStringKeyword"
    };
  }
  i(vL, "tsStringKeyword");
  function PL() {
    return {
      type: "TSSymbolKeyword"
    };
  }
  i(PL, "tsSymbolKeyword");
  function AL() {
    return {
      type: "TSUndefinedKeyword"
    };
  }
  i(AL, "tsUndefinedKeyword");
  function CL() {
    return {
      type: "TSUnknownKeyword"
    };
  }
  i(CL, "tsUnknownKeyword");
  function wL() {
    return {
      type: "TSVoidKeyword"
    };
  }
  i(wL, "tsVoidKeyword");
  function DL() {
    return {
      type: "TSThisType"
    };
  }
  i(DL, "tsThisType");
  function _L(e = null, t, r = null) {
    let s = {
      type: "TSFunctionType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, n = B.TSFunctionType;
    return y(n.typeParameters, s, "typeParameters", e, 1), y(n.parameters, s, "parameters", t, 1), y(n.typeAnnotation, s, "typeAnnotation", r,
    1), s;
  }
  i(_L, "tsFunctionType");
  function IL(e = null, t, r = null) {
    let s = {
      type: "TSConstructorType",
      typeParameters: e,
      parameters: t,
      typeAnnotation: r
    }, n = B.TSConstructorType;
    return y(n.typeParameters, s, "typeParameters", e, 1), y(n.parameters, s, "parameters", t, 1), y(n.typeAnnotation, s, "typeAnnotation", r,
    1), s;
  }
  i(IL, "tsConstructorType");
  function OL(e, t = null) {
    let r = {
      type: "TSTypeReference",
      typeName: e,
      typeParameters: t
    }, s = B.TSTypeReference;
    return y(s.typeName, r, "typeName", e, 1), y(s.typeParameters, r, "typeParameters", t, 1), r;
  }
  i(OL, "tsTypeReference");
  function NL(e, t = null, r = null) {
    let s = {
      type: "TSTypePredicate",
      parameterName: e,
      typeAnnotation: t,
      asserts: r
    }, n = B.TSTypePredicate;
    return y(n.parameterName, s, "parameterName", e, 1), y(n.typeAnnotation, s, "typeAnnotation", t, 1), y(n.asserts, s, "asserts", r), s;
  }
  i(NL, "tsTypePredicate");
  function BL(e, t = null) {
    let r = {
      type: "TSTypeQuery",
      exprName: e,
      typeParameters: t
    }, s = B.TSTypeQuery;
    return y(s.exprName, r, "exprName", e, 1), y(s.typeParameters, r, "typeParameters", t, 1), r;
  }
  i(BL, "tsTypeQuery");
  function kL(e) {
    let t = {
      type: "TSTypeLiteral",
      members: e
    }, r = B.TSTypeLiteral;
    return y(r.members, t, "members", e, 1), t;
  }
  i(kL, "tsTypeLiteral");
  function FL(e) {
    let t = {
      type: "TSArrayType",
      elementType: e
    }, r = B.TSArrayType;
    return y(r.elementType, t, "elementType", e, 1), t;
  }
  i(FL, "tsArrayType");
  function LL(e) {
    let t = {
      type: "TSTupleType",
      elementTypes: e
    }, r = B.TSTupleType;
    return y(r.elementTypes, t, "elementTypes", e, 1), t;
  }
  i(LL, "tsTupleType");
  function jL(e) {
    let t = {
      type: "TSOptionalType",
      typeAnnotation: e
    }, r = B.TSOptionalType;
    return y(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  i(jL, "tsOptionalType");
  function ML(e) {
    let t = {
      type: "TSRestType",
      typeAnnotation: e
    }, r = B.TSRestType;
    return y(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  i(ML, "tsRestType");
  function RL(e, t, r = !1) {
    let s = {
      type: "TSNamedTupleMember",
      label: e,
      elementType: t,
      optional: r
    }, n = B.TSNamedTupleMember;
    return y(n.label, s, "label", e, 1), y(n.elementType, s, "elementType", t, 1), y(n.optional, s, "optional", r), s;
  }
  i(RL, "tsNamedTupleMember");
  function qL(e) {
    let t = {
      type: "TSUnionType",
      types: e
    }, r = B.TSUnionType;
    return y(r.types, t, "types", e, 1), t;
  }
  i(qL, "tsUnionType");
  function UL(e) {
    let t = {
      type: "TSIntersectionType",
      types: e
    }, r = B.TSIntersectionType;
    return y(r.types, t, "types", e, 1), t;
  }
  i(UL, "tsIntersectionType");
  function $L(e, t, r, s) {
    let n = {
      type: "TSConditionalType",
      checkType: e,
      extendsType: t,
      trueType: r,
      falseType: s
    }, a = B.TSConditionalType;
    return y(a.checkType, n, "checkType", e, 1), y(a.extendsType, n, "extendsType", t, 1), y(a.trueType, n, "trueType", r, 1), y(a.falseType,
    n, "falseType", s, 1), n;
  }
  i($L, "tsConditionalType");
  function VL(e) {
    let t = {
      type: "TSInferType",
      typeParameter: e
    }, r = B.TSInferType;
    return y(r.typeParameter, t, "typeParameter", e, 1), t;
  }
  i(VL, "tsInferType");
  function KL(e) {
    let t = {
      type: "TSParenthesizedType",
      typeAnnotation: e
    }, r = B.TSParenthesizedType;
    return y(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  i(KL, "tsParenthesizedType");
  function WL(e, t = "keyof") {
    let r = {
      type: "TSTypeOperator",
      typeAnnotation: e,
      operator: t
    }, s = B.TSTypeOperator;
    return y(s.typeAnnotation, r, "typeAnnotation", e, 1), y(s.operator, r, "operator", t), r;
  }
  i(WL, "tsTypeOperator");
  function YL(e, t) {
    let r = {
      type: "TSIndexedAccessType",
      objectType: e,
      indexType: t
    }, s = B.TSIndexedAccessType;
    return y(s.objectType, r, "objectType", e, 1), y(s.indexType, r, "indexType", t, 1), r;
  }
  i(YL, "tsIndexedAccessType");
  function HL(e, t = null, r = null) {
    let s = {
      type: "TSMappedType",
      typeParameter: e,
      typeAnnotation: t,
      nameType: r
    }, n = B.TSMappedType;
    return y(n.typeParameter, s, "typeParameter", e, 1), y(n.typeAnnotation, s, "typeAnnotation", t, 1), y(n.nameType, s, "nameType", r, 1),
    s;
  }
  i(HL, "tsMappedType");
  function JL(e, t) {
    let r = {
      type: "TSTemplateLiteralType",
      quasis: e,
      types: t
    }, s = B.TSTemplateLiteralType;
    return y(s.quasis, r, "quasis", e, 1), y(s.types, r, "types", t, 1), r;
  }
  i(JL, "tsTemplateLiteralType");
  function GL(e) {
    let t = {
      type: "TSLiteralType",
      literal: e
    }, r = B.TSLiteralType;
    return y(r.literal, t, "literal", e, 1), t;
  }
  i(GL, "tsLiteralType");
  function XL(e, t = null) {
    let r = {
      type: "TSExpressionWithTypeArguments",
      expression: e,
      typeParameters: t
    }, s = B.TSExpressionWithTypeArguments;
    return y(s.expression, r, "expression", e, 1), y(s.typeParameters, r, "typeParameters", t, 1), r;
  }
  i(XL, "tsExpressionWithTypeArguments");
  function zL(e, t = null, r = null, s) {
    let n = {
      type: "TSInterfaceDeclaration",
      id: e,
      typeParameters: t,
      extends: r,
      body: s
    }, a = B.TSInterfaceDeclaration;
    return y(a.id, n, "id", e, 1), y(a.typeParameters, n, "typeParameters", t, 1), y(a.extends, n, "extends", r, 1), y(a.body, n, "body", s,
    1), n;
  }
  i(zL, "tsInterfaceDeclaration");
  function QL(e) {
    let t = {
      type: "TSInterfaceBody",
      body: e
    }, r = B.TSInterfaceBody;
    return y(r.body, t, "body", e, 1), t;
  }
  i(QL, "tsInterfaceBody");
  function ZL(e, t = null, r) {
    let s = {
      type: "TSTypeAliasDeclaration",
      id: e,
      typeParameters: t,
      typeAnnotation: r
    }, n = B.TSTypeAliasDeclaration;
    return y(n.id, s, "id", e, 1), y(n.typeParameters, s, "typeParameters", t, 1), y(n.typeAnnotation, s, "typeAnnotation", r, 1), s;
  }
  i(ZL, "tsTypeAliasDeclaration");
  function ej(e, t = null) {
    let r = {
      type: "TSInstantiationExpression",
      expression: e,
      typeParameters: t
    }, s = B.TSInstantiationExpression;
    return y(s.expression, r, "expression", e, 1), y(s.typeParameters, r, "typeParameters", t, 1), r;
  }
  i(ej, "tsInstantiationExpression");
  function tj(e, t) {
    let r = {
      type: "TSAsExpression",
      expression: e,
      typeAnnotation: t
    }, s = B.TSAsExpression;
    return y(s.expression, r, "expression", e, 1), y(s.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  i(tj, "tsAsExpression");
  function rj(e, t) {
    let r = {
      type: "TSSatisfiesExpression",
      expression: e,
      typeAnnotation: t
    }, s = B.TSSatisfiesExpression;
    return y(s.expression, r, "expression", e, 1), y(s.typeAnnotation, r, "typeAnnotation", t, 1), r;
  }
  i(rj, "tsSatisfiesExpression");
  function sj(e, t) {
    let r = {
      type: "TSTypeAssertion",
      typeAnnotation: e,
      expression: t
    }, s = B.TSTypeAssertion;
    return y(s.typeAnnotation, r, "typeAnnotation", e, 1), y(s.expression, r, "expression", t, 1), r;
  }
  i(sj, "tsTypeAssertion");
  function nj(e) {
    let t = {
      type: "TSEnumBody",
      members: e
    }, r = B.TSEnumBody;
    return y(r.members, t, "members", e, 1), t;
  }
  i(nj, "tsEnumBody");
  function ij(e, t) {
    let r = {
      type: "TSEnumDeclaration",
      id: e,
      members: t
    }, s = B.TSEnumDeclaration;
    return y(s.id, r, "id", e, 1), y(s.members, r, "members", t, 1), r;
  }
  i(ij, "tsEnumDeclaration");
  function aj(e, t = null) {
    let r = {
      type: "TSEnumMember",
      id: e,
      initializer: t
    }, s = B.TSEnumMember;
    return y(s.id, r, "id", e, 1), y(s.initializer, r, "initializer", t, 1), r;
  }
  i(aj, "tsEnumMember");
  function oj(e, t) {
    let r = {
      type: "TSModuleDeclaration",
      id: e,
      body: t,
      kind: null
    }, s = B.TSModuleDeclaration;
    return y(s.id, r, "id", e, 1), y(s.body, r, "body", t, 1), r;
  }
  i(oj, "tsModuleDeclaration");
  function lj(e) {
    let t = {
      type: "TSModuleBlock",
      body: e
    }, r = B.TSModuleBlock;
    return y(r.body, t, "body", e, 1), t;
  }
  i(lj, "tsModuleBlock");
  function uj(e, t = null, r = null) {
    let s = {
      type: "TSImportType",
      argument: e,
      qualifier: t,
      typeParameters: r
    }, n = B.TSImportType;
    return y(n.argument, s, "argument", e, 1), y(n.qualifier, s, "qualifier", t, 1), y(n.typeParameters, s, "typeParameters", r, 1), s;
  }
  i(uj, "tsImportType");
  function cj(e, t) {
    let r = {
      type: "TSImportEqualsDeclaration",
      id: e,
      moduleReference: t,
      isExport: null
    }, s = B.TSImportEqualsDeclaration;
    return y(s.id, r, "id", e, 1), y(s.moduleReference, r, "moduleReference", t, 1), r;
  }
  i(cj, "tsImportEqualsDeclaration");
  function pj(e) {
    let t = {
      type: "TSExternalModuleReference",
      expression: e
    }, r = B.TSExternalModuleReference;
    return y(r.expression, t, "expression", e, 1), t;
  }
  i(pj, "tsExternalModuleReference");
  function fj(e) {
    let t = {
      type: "TSNonNullExpression",
      expression: e
    }, r = B.TSNonNullExpression;
    return y(r.expression, t, "expression", e, 1), t;
  }
  i(fj, "tsNonNullExpression");
  function dj(e) {
    let t = {
      type: "TSExportAssignment",
      expression: e
    }, r = B.TSExportAssignment;
    return y(r.expression, t, "expression", e, 1), t;
  }
  i(dj, "tsExportAssignment");
  function hj(e) {
    let t = {
      type: "TSNamespaceExportDeclaration",
      id: e
    }, r = B.TSNamespaceExportDeclaration;
    return y(r.id, t, "id", e, 1), t;
  }
  i(hj, "tsNamespaceExportDeclaration");
  function mj(e) {
    let t = {
      type: "TSTypeAnnotation",
      typeAnnotation: e
    }, r = B.TSTypeAnnotation;
    return y(r.typeAnnotation, t, "typeAnnotation", e, 1), t;
  }
  i(mj, "tsTypeAnnotation");
  function yj(e) {
    let t = {
      type: "TSTypeParameterInstantiation",
      params: e
    }, r = B.TSTypeParameterInstantiation;
    return y(r.params, t, "params", e, 1), t;
  }
  i(yj, "tsTypeParameterInstantiation");
  function bj(e) {
    let t = {
      type: "TSTypeParameterDeclaration",
      params: e
    }, r = B.TSTypeParameterDeclaration;
    return y(r.params, t, "params", e, 1), t;
  }
  i(bj, "tsTypeParameterDeclaration");
  function gj(e = null, t = null, r) {
    let s = {
      type: "TSTypeParameter",
      constraint: e,
      default: t,
      name: r
    }, n = B.TSTypeParameter;
    return y(n.constraint, s, "constraint", e, 1), y(n.default, s, "default", t, 1), y(n.name, s, "name", r), s;
  }
  i(gj, "tsTypeParameter");
  function Tj(e) {
    return (0, Cl.default)("NumberLiteral", "NumericLiteral", "The node type "), Rg(e);
  }
  i(Tj, "NumberLiteral");
  function xj(e, t = "") {
    return (0, Cl.default)("RegexLiteral", "RegExpLiteral", "The node type "), qg(e, t);
  }
  i(xj, "RegexLiteral");
  function Ej(e) {
    return (0, Cl.default)("RestProperty", "RestElement", "The node type "), Ug(e);
  }
  i(Ej, "RestProperty");
  function Sj(e) {
    return (0, Cl.default)("SpreadProperty", "SpreadElement", "The node type "), $g(e);
  }
  i(Sj, "SpreadProperty");
});

// ../node_modules/@babel/types/lib/builders/generated/uppercase.js
var Vg = D((m) => {
  "use strict";
  Object.defineProperty(m, "__esModule", {
    value: !0
  });
  m.JSXIdentifier = m.JSXFragment = m.JSXExpressionContainer = m.JSXEmptyExpression = m.JSXElement = m.JSXClosingFragment = m.JSXClosingElement =
  m.JSXAttribute = m.IntersectionTypeAnnotation = m.InterpreterDirective = m.InterfaceTypeAnnotation = m.InterfaceExtends = m.InterfaceDeclaration =
  m.InferredPredicate = m.IndexedAccessType = m.ImportSpecifier = m.ImportNamespaceSpecifier = m.ImportExpression = m.ImportDefaultSpecifier =
  m.ImportDeclaration = m.ImportAttribute = m.Import = m.IfStatement = m.Identifier = m.GenericTypeAnnotation = m.FunctionTypeParam = m.FunctionTypeAnnotation =
  m.FunctionExpression = m.FunctionDeclaration = m.ForStatement = m.ForOfStatement = m.ForInStatement = m.File = m.ExpressionStatement = m.ExportSpecifier =
  m.ExportNamespaceSpecifier = m.ExportNamedDeclaration = m.ExportDefaultSpecifier = m.ExportDefaultDeclaration = m.ExportAllDeclaration = m.
  ExistsTypeAnnotation = m.EnumSymbolBody = m.EnumStringMember = m.EnumStringBody = m.EnumNumberMember = m.EnumNumberBody = m.EnumDefaultedMember =
  m.EnumDeclaration = m.EnumBooleanMember = m.EnumBooleanBody = m.EmptyTypeAnnotation = m.EmptyStatement = m.DoWhileStatement = m.DoExpression =
  m.DirectiveLiteral = m.Directive = m.Decorator = m.DeclaredPredicate = m.DeclareVariable = m.DeclareTypeAlias = m.DeclareOpaqueType = m.DeclareModuleExports =
  m.DeclareModule = m.DeclareInterface = m.DeclareFunction = m.DeclareExportDeclaration = m.DeclareExportAllDeclaration = m.DeclareClass = m.
  DecimalLiteral = m.DebuggerStatement = m.ContinueStatement = m.ConditionalExpression = m.ClassProperty = m.ClassPrivateProperty = m.ClassPrivateMethod =
  m.ClassMethod = m.ClassImplements = m.ClassExpression = m.ClassDeclaration = m.ClassBody = m.ClassAccessorProperty = m.CatchClause = m.CallExpression =
  m.BreakStatement = m.BooleanTypeAnnotation = m.BooleanLiteralTypeAnnotation = m.BooleanLiteral = m.BlockStatement = m.BindExpression = m.BinaryExpression =
  m.BigIntLiteral = m.AwaitExpression = m.AssignmentPattern = m.AssignmentExpression = m.ArrowFunctionExpression = m.ArrayTypeAnnotation = m.
  ArrayPattern = m.ArrayExpression = m.ArgumentPlaceholder = m.AnyTypeAnnotation = void 0;
  m.TSNumberKeyword = m.TSNullKeyword = m.TSNonNullExpression = m.TSNeverKeyword = m.TSNamespaceExportDeclaration = m.TSNamedTupleMember = m.
  TSModuleDeclaration = m.TSModuleBlock = m.TSMethodSignature = m.TSMappedType = m.TSLiteralType = m.TSIntrinsicKeyword = m.TSIntersectionType =
  m.TSInterfaceDeclaration = m.TSInterfaceBody = m.TSInstantiationExpression = m.TSInferType = m.TSIndexedAccessType = m.TSIndexSignature = m.
  TSImportType = m.TSImportEqualsDeclaration = m.TSFunctionType = m.TSExternalModuleReference = m.TSExpressionWithTypeArguments = m.TSExportAssignment =
  m.TSEnumMember = m.TSEnumDeclaration = m.TSEnumBody = m.TSDeclareMethod = m.TSDeclareFunction = m.TSConstructorType = m.TSConstructSignatureDeclaration =
  m.TSConditionalType = m.TSCallSignatureDeclaration = m.TSBooleanKeyword = m.TSBigIntKeyword = m.TSAsExpression = m.TSArrayType = m.TSAnyKeyword =
  m.SymbolTypeAnnotation = m.SwitchStatement = m.SwitchCase = m.Super = m.StringTypeAnnotation = m.StringLiteralTypeAnnotation = m.StringLiteral =
  m.StaticBlock = m.SpreadProperty = m.SpreadElement = m.SequenceExpression = m.ReturnStatement = m.RestProperty = m.RestElement = m.RegexLiteral =
  m.RegExpLiteral = m.RecordExpression = m.QualifiedTypeIdentifier = m.Program = m.PrivateName = m.Placeholder = m.PipelineTopicExpression =
  m.PipelinePrimaryTopicReference = m.PipelineBareFunction = m.ParenthesizedExpression = m.OptionalMemberExpression = m.OptionalIndexedAccessType =
  m.OptionalCallExpression = m.OpaqueType = m.ObjectTypeSpreadProperty = m.ObjectTypeProperty = m.ObjectTypeInternalSlot = m.ObjectTypeIndexer =
  m.ObjectTypeCallProperty = m.ObjectTypeAnnotation = m.ObjectProperty = m.ObjectPattern = m.ObjectMethod = m.ObjectExpression = m.NumericLiteral =
  m.NumberTypeAnnotation = m.NumberLiteralTypeAnnotation = m.NumberLiteral = m.NullableTypeAnnotation = m.NullLiteralTypeAnnotation = m.NullLiteral =
  m.Noop = m.NewExpression = m.ModuleExpression = m.MixedTypeAnnotation = m.MetaProperty = m.MemberExpression = m.LogicalExpression = m.LabeledStatement =
  m.JSXText = m.JSXSpreadChild = m.JSXSpreadAttribute = m.JSXOpeningFragment = m.JSXOpeningElement = m.JSXNamespacedName = m.JSXMemberExpression =
  void 0;
  m.YieldExpression = m.WithStatement = m.WhileStatement = m.VoidTypeAnnotation = m.VoidPattern = m.Variance = m.VariableDeclarator = m.VariableDeclaration =
  m.V8IntrinsicIdentifier = m.UpdateExpression = m.UnionTypeAnnotation = m.UnaryExpression = m.TypeofTypeAnnotation = m.TypeParameterInstantiation =
  m.TypeParameterDeclaration = m.TypeParameter = m.TypeCastExpression = m.TypeAnnotation = m.TypeAlias = m.TupleTypeAnnotation = m.TupleExpression =
  m.TryStatement = m.TopicReference = m.ThrowStatement = m.ThisTypeAnnotation = m.ThisExpression = m.TemplateLiteral = m.TemplateElement = m.
  TaggedTemplateExpression = m.TSVoidKeyword = m.TSUnknownKeyword = m.TSUnionType = m.TSUndefinedKeyword = m.TSTypeReference = m.TSTypeQuery =
  m.TSTypePredicate = m.TSTypeParameterInstantiation = m.TSTypeParameterDeclaration = m.TSTypeParameter = m.TSTypeOperator = m.TSTypeLiteral =
  m.TSTypeAssertion = m.TSTypeAnnotation = m.TSTypeAliasDeclaration = m.TSTupleType = m.TSThisType = m.TSTemplateLiteralType = m.TSSymbolKeyword =
  m.TSStringKeyword = m.TSSatisfiesExpression = m.TSRestType = m.TSQualifiedName = m.TSPropertySignature = m.TSParenthesizedType = m.TSParameterProperty =
  m.TSOptionalType = m.TSObjectKeyword = void 0;
  var Fa = Mf(), sxe = mi();
  function I(e) {
    return Fa[e];
  }
  i(I, "alias");
  var nxe = m.ArrayExpression = I("arrayExpression"), ixe = m.AssignmentExpression = I("assignmentExpression"), axe = m.BinaryExpression = I(
  "binaryExpression"), oxe = m.InterpreterDirective = I("interpreterDirective"), lxe = m.Directive = I("directive"), uxe = m.DirectiveLiteral =
  I("directiveLiteral"), cxe = m.BlockStatement = I("blockStatement"), pxe = m.BreakStatement = I("breakStatement"), fxe = m.CallExpression =
  I("callExpression"), dxe = m.CatchClause = I("catchClause"), hxe = m.ConditionalExpression = I("conditionalExpression"), mxe = m.ContinueStatement =
  I("continueStatement"), yxe = m.DebuggerStatement = I("debuggerStatement"), bxe = m.DoWhileStatement = I("doWhileStatement"), gxe = m.EmptyStatement =
  I("emptyStatement"), Txe = m.ExpressionStatement = I("expressionStatement"), xxe = m.File = I("file"), Exe = m.ForInStatement = I("forInSt\
atement"), Sxe = m.ForStatement = I("forStatement"), vxe = m.FunctionDeclaration = I("functionDeclaration"), Pxe = m.FunctionExpression = I(
  "functionExpression"), Axe = m.Identifier = I("identifier"), Cxe = m.IfStatement = I("ifStatement"), wxe = m.LabeledStatement = I("labeled\
Statement"), Dxe = m.StringLiteral = I("stringLiteral"), _xe = m.NumericLiteral = I("numericLiteral"), Ixe = m.NullLiteral = I("nullLiteral"),
  Oxe = m.BooleanLiteral = I("booleanLiteral"), Nxe = m.RegExpLiteral = I("regExpLiteral"), Bxe = m.LogicalExpression = I("logicalExpression"),
  kxe = m.MemberExpression = I("memberExpression"), Fxe = m.NewExpression = I("newExpression"), Lxe = m.Program = I("program"), jxe = m.ObjectExpression =
  I("objectExpression"), Mxe = m.ObjectMethod = I("objectMethod"), Rxe = m.ObjectProperty = I("objectProperty"), qxe = m.RestElement = I("re\
stElement"), Uxe = m.ReturnStatement = I("returnStatement"), $xe = m.SequenceExpression = I("sequenceExpression"), Vxe = m.ParenthesizedExpression =
  I("parenthesizedExpression"), Kxe = m.SwitchCase = I("switchCase"), Wxe = m.SwitchStatement = I("switchStatement"), Yxe = m.ThisExpression =
  I("thisExpression"), Hxe = m.ThrowStatement = I("throwStatement"), Jxe = m.TryStatement = I("tryStatement"), Gxe = m.UnaryExpression = I("\
unaryExpression"), Xxe = m.UpdateExpression = I("updateExpression"), zxe = m.VariableDeclaration = I("variableDeclaration"), Qxe = m.VariableDeclarator =
  I("variableDeclarator"), Zxe = m.WhileStatement = I("whileStatement"), eEe = m.WithStatement = I("withStatement"), tEe = m.AssignmentPattern =
  I("assignmentPattern"), rEe = m.ArrayPattern = I("arrayPattern"), sEe = m.ArrowFunctionExpression = I("arrowFunctionExpression"), nEe = m.
  ClassBody = I("classBody"), iEe = m.ClassExpression = I("classExpression"), aEe = m.ClassDeclaration = I("classDeclaration"), oEe = m.ExportAllDeclaration =
  I("exportAllDeclaration"), lEe = m.ExportDefaultDeclaration = I("exportDefaultDeclaration"), uEe = m.ExportNamedDeclaration = I("exportNam\
edDeclaration"), cEe = m.ExportSpecifier = I("exportSpecifier"), pEe = m.ForOfStatement = I("forOfStatement"), fEe = m.ImportDeclaration = I(
  "importDeclaration"), dEe = m.ImportDefaultSpecifier = I("importDefaultSpecifier"), hEe = m.ImportNamespaceSpecifier = I("importNamespaceS\
pecifier"), mEe = m.ImportSpecifier = I("importSpecifier"), yEe = m.ImportExpression = I("importExpression"), bEe = m.MetaProperty = I("meta\
Property"), gEe = m.ClassMethod = I("classMethod"), TEe = m.ObjectPattern = I("objectPattern"), xEe = m.SpreadElement = I("spreadElement"), EEe = m.
  Super = I("super"), SEe = m.TaggedTemplateExpression = I("taggedTemplateExpression"), vEe = m.TemplateElement = I("templateElement"), PEe = m.
  TemplateLiteral = I("templateLiteral"), AEe = m.YieldExpression = I("yieldExpression"), CEe = m.AwaitExpression = I("awaitExpression"), wEe = m.
  Import = I("import"), DEe = m.BigIntLiteral = I("bigIntLiteral"), _Ee = m.ExportNamespaceSpecifier = I("exportNamespaceSpecifier"), IEe = m.
  OptionalMemberExpression = I("optionalMemberExpression"), OEe = m.OptionalCallExpression = I("optionalCallExpression"), NEe = m.ClassProperty =
  I("classProperty"), BEe = m.ClassAccessorProperty = I("classAccessorProperty"), kEe = m.ClassPrivateProperty = I("classPrivateProperty"), FEe = m.
  ClassPrivateMethod = I("classPrivateMethod"), LEe = m.PrivateName = I("privateName"), jEe = m.StaticBlock = I("staticBlock"), MEe = m.ImportAttribute =
  I("importAttribute"), REe = m.AnyTypeAnnotation = I("anyTypeAnnotation"), qEe = m.ArrayTypeAnnotation = I("arrayTypeAnnotation"), UEe = m.
  BooleanTypeAnnotation = I("booleanTypeAnnotation"), $Ee = m.BooleanLiteralTypeAnnotation = I("booleanLiteralTypeAnnotation"), VEe = m.NullLiteralTypeAnnotation =
  I("nullLiteralTypeAnnotation"), KEe = m.ClassImplements = I("classImplements"), WEe = m.DeclareClass = I("declareClass"), YEe = m.DeclareFunction =
  I("declareFunction"), HEe = m.DeclareInterface = I("declareInterface"), JEe = m.DeclareModule = I("declareModule"), GEe = m.DeclareModuleExports =
  I("declareModuleExports"), XEe = m.DeclareTypeAlias = I("declareTypeAlias"), zEe = m.DeclareOpaqueType = I("declareOpaqueType"), QEe = m.DeclareVariable =
  I("declareVariable"), ZEe = m.DeclareExportDeclaration = I("declareExportDeclaration"), eSe = m.DeclareExportAllDeclaration = I("declareEx\
portAllDeclaration"), tSe = m.DeclaredPredicate = I("declaredPredicate"), rSe = m.ExistsTypeAnnotation = I("existsTypeAnnotation"), sSe = m.
  FunctionTypeAnnotation = I("functionTypeAnnotation"), nSe = m.FunctionTypeParam = I("functionTypeParam"), iSe = m.GenericTypeAnnotation = I(
  "genericTypeAnnotation"), aSe = m.InferredPredicate = I("inferredPredicate"), oSe = m.InterfaceExtends = I("interfaceExtends"), lSe = m.InterfaceDeclaration =
  I("interfaceDeclaration"), uSe = m.InterfaceTypeAnnotation = I("interfaceTypeAnnotation"), cSe = m.IntersectionTypeAnnotation = I("interse\
ctionTypeAnnotation"), pSe = m.MixedTypeAnnotation = I("mixedTypeAnnotation"), fSe = m.EmptyTypeAnnotation = I("emptyTypeAnnotation"), dSe = m.
  NullableTypeAnnotation = I("nullableTypeAnnotation"), hSe = m.NumberLiteralTypeAnnotation = I("numberLiteralTypeAnnotation"), mSe = m.NumberTypeAnnotation =
  I("numberTypeAnnotation"), ySe = m.ObjectTypeAnnotation = I("objectTypeAnnotation"), bSe = m.ObjectTypeInternalSlot = I("objectTypeInterna\
lSlot"), gSe = m.ObjectTypeCallProperty = I("objectTypeCallProperty"), TSe = m.ObjectTypeIndexer = I("objectTypeIndexer"), xSe = m.ObjectTypeProperty =
  I("objectTypeProperty"), ESe = m.ObjectTypeSpreadProperty = I("objectTypeSpreadProperty"), SSe = m.OpaqueType = I("opaqueType"), vSe = m.QualifiedTypeIdentifier =
  I("qualifiedTypeIdentifier"), PSe = m.StringLiteralTypeAnnotation = I("stringLiteralTypeAnnotation"), ASe = m.StringTypeAnnotation = I("st\
ringTypeAnnotation"), CSe = m.SymbolTypeAnnotation = I("symbolTypeAnnotation"), wSe = m.ThisTypeAnnotation = I("thisTypeAnnotation"), DSe = m.
  TupleTypeAnnotation = I("tupleTypeAnnotation"), _Se = m.TypeofTypeAnnotation = I("typeofTypeAnnotation"), ISe = m.TypeAlias = I("typeAlias"),
  OSe = m.TypeAnnotation = I("typeAnnotation"), NSe = m.TypeCastExpression = I("typeCastExpression"), BSe = m.TypeParameter = I("typeParamet\
er"), kSe = m.TypeParameterDeclaration = I("typeParameterDeclaration"), FSe = m.TypeParameterInstantiation = I("typeParameterInstantiation"),
  LSe = m.UnionTypeAnnotation = I("unionTypeAnnotation"), jSe = m.Variance = I("variance"), MSe = m.VoidTypeAnnotation = I("voidTypeAnnotati\
on"), RSe = m.EnumDeclaration = I("enumDeclaration"), qSe = m.EnumBooleanBody = I("enumBooleanBody"), USe = m.EnumNumberBody = I("enumNumber\
Body"), $Se = m.EnumStringBody = I("enumStringBody"), VSe = m.EnumSymbolBody = I("enumSymbolBody"), KSe = m.EnumBooleanMember = I("enumBoole\
anMember"), WSe = m.EnumNumberMember = I("enumNumberMember"), YSe = m.EnumStringMember = I("enumStringMember"), HSe = m.EnumDefaultedMember =
  I("enumDefaultedMember"), JSe = m.IndexedAccessType = I("indexedAccessType"), GSe = m.OptionalIndexedAccessType = I("optionalIndexedAccess\
Type"), XSe = m.JSXAttribute = I("jsxAttribute"), zSe = m.JSXClosingElement = I("jsxClosingElement"), QSe = m.JSXElement = I("jsxElement"), ZSe = m.
  JSXEmptyExpression = I("jsxEmptyExpression"), eve = m.JSXExpressionContainer = I("jsxExpressionContainer"), tve = m.JSXSpreadChild = I("js\
xSpreadChild"), rve = m.JSXIdentifier = I("jsxIdentifier"), sve = m.JSXMemberExpression = I("jsxMemberExpression"), nve = m.JSXNamespacedName =
  I("jsxNamespacedName"), ive = m.JSXOpeningElement = I("jsxOpeningElement"), ave = m.JSXSpreadAttribute = I("jsxSpreadAttribute"), ove = m.
  JSXText = I("jsxText"), lve = m.JSXFragment = I("jsxFragment"), uve = m.JSXOpeningFragment = I("jsxOpeningFragment"), cve = m.JSXClosingFragment =
  I("jsxClosingFragment"), pve = m.Noop = I("noop"), fve = m.Placeholder = I("placeholder"), dve = m.V8IntrinsicIdentifier = I("v8IntrinsicI\
dentifier"), hve = m.ArgumentPlaceholder = I("argumentPlaceholder"), mve = m.BindExpression = I("bindExpression"), yve = m.Decorator = I("de\
corator"), bve = m.DoExpression = I("doExpression"), gve = m.ExportDefaultSpecifier = I("exportDefaultSpecifier"), Tve = m.RecordExpression =
  I("recordExpression"), xve = m.TupleExpression = I("tupleExpression"), Eve = m.DecimalLiteral = I("decimalLiteral"), Sve = m.ModuleExpression =
  I("moduleExpression"), vve = m.TopicReference = I("topicReference"), Pve = m.PipelineTopicExpression = I("pipelineTopicExpression"), Ave = m.
  PipelineBareFunction = I("pipelineBareFunction"), Cve = m.PipelinePrimaryTopicReference = I("pipelinePrimaryTopicReference"), wve = m.VoidPattern =
  I("voidPattern"), Dve = m.TSParameterProperty = I("tsParameterProperty"), _ve = m.TSDeclareFunction = I("tsDeclareFunction"), Ive = m.TSDeclareMethod =
  I("tsDeclareMethod"), Ove = m.TSQualifiedName = I("tsQualifiedName"), Nve = m.TSCallSignatureDeclaration = I("tsCallSignatureDeclaration"),
  Bve = m.TSConstructSignatureDeclaration = I("tsConstructSignatureDeclaration"), kve = m.TSPropertySignature = I("tsPropertySignature"), Fve = m.
  TSMethodSignature = I("tsMethodSignature"), Lve = m.TSIndexSignature = I("tsIndexSignature"), jve = m.TSAnyKeyword = I("tsAnyKeyword"), Mve = m.
  TSBooleanKeyword = I("tsBooleanKeyword"), Rve = m.TSBigIntKeyword = I("tsBigIntKeyword"), qve = m.TSIntrinsicKeyword = I("tsIntrinsicKeywo\
rd"), Uve = m.TSNeverKeyword = I("tsNeverKeyword"), $ve = m.TSNullKeyword = I("tsNullKeyword"), Vve = m.TSNumberKeyword = I("tsNumberKeyword"),
  Kve = m.TSObjectKeyword = I("tsObjectKeyword"), Wve = m.TSStringKeyword = I("tsStringKeyword"), Yve = m.TSSymbolKeyword = I("tsSymbolKeywo\
rd"), Hve = m.TSUndefinedKeyword = I("tsUndefinedKeyword"), Jve = m.TSUnknownKeyword = I("tsUnknownKeyword"), Gve = m.TSVoidKeyword = I("tsV\
oidKeyword"), Xve = m.TSThisType = I("tsThisType"), zve = m.TSFunctionType = I("tsFunctionType"), Qve = m.TSConstructorType = I("tsConstruct\
orType"), Zve = m.TSTypeReference = I("tsTypeReference"), ePe = m.TSTypePredicate = I("tsTypePredicate"), tPe = m.TSTypeQuery = I("tsTypeQue\
ry"), rPe = m.TSTypeLiteral = I("tsTypeLiteral"), sPe = m.TSArrayType = I("tsArrayType"), nPe = m.TSTupleType = I("tsTupleType"), iPe = m.TSOptionalType =
  I("tsOptionalType"), aPe = m.TSRestType = I("tsRestType"), oPe = m.TSNamedTupleMember = I("tsNamedTupleMember"), lPe = m.TSUnionType = I("\
tsUnionType"), uPe = m.TSIntersectionType = I("tsIntersectionType"), cPe = m.TSConditionalType = I("tsConditionalType"), pPe = m.TSInferType =
  I("tsInferType"), fPe = m.TSParenthesizedType = I("tsParenthesizedType"), dPe = m.TSTypeOperator = I("tsTypeOperator"), hPe = m.TSIndexedAccessType =
  I("tsIndexedAccessType"), mPe = m.TSMappedType = I("tsMappedType"), yPe = m.TSTemplateLiteralType = I("tsTemplateLiteralType"), bPe = m.TSLiteralType =
  I("tsLiteralType"), gPe = m.TSExpressionWithTypeArguments = I("tsExpressionWithTypeArguments"), TPe = m.TSInterfaceDeclaration = I("tsInte\
rfaceDeclaration"), xPe = m.TSInterfaceBody = I("tsInterfaceBody"), EPe = m.TSTypeAliasDeclaration = I("tsTypeAliasDeclaration"), SPe = m.TSInstantiationExpression =
  I("tsInstantiationExpression"), vPe = m.TSAsExpression = I("tsAsExpression"), PPe = m.TSSatisfiesExpression = I("tsSatisfiesExpression"), APe = m.
  TSTypeAssertion = I("tsTypeAssertion"), CPe = m.TSEnumBody = I("tsEnumBody"), wPe = m.TSEnumDeclaration = I("tsEnumDeclaration"), DPe = m.
  TSEnumMember = I("tsEnumMember"), _Pe = m.TSModuleDeclaration = I("tsModuleDeclaration"), IPe = m.TSModuleBlock = I("tsModuleBlock"), OPe = m.
  TSImportType = I("tsImportType"), NPe = m.TSImportEqualsDeclaration = I("tsImportEqualsDeclaration"), BPe = m.TSExternalModuleReference = I(
  "tsExternalModuleReference"), kPe = m.TSNonNullExpression = I("tsNonNullExpression"), FPe = m.TSExportAssignment = I("tsExportAssignment"),
  LPe = m.TSNamespaceExportDeclaration = I("tsNamespaceExportDeclaration"), jPe = m.TSTypeAnnotation = I("tsTypeAnnotation"), MPe = m.TSTypeParameterInstantiation =
  I("tsTypeParameterInstantiation"), RPe = m.TSTypeParameterDeclaration = I("tsTypeParameterDeclaration"), qPe = m.TSTypeParameter = I("tsTy\
peParameter"), UPe = m.NumberLiteral = Fa.numberLiteral, $Pe = m.RegexLiteral = Fa.regexLiteral, VPe = m.RestProperty = Fa.restProperty, KPe = m.
  SpreadProperty = Fa.spreadProperty;
});

// ../node_modules/@babel/types/lib/builders/generated/index.js
var Qt = D((Ys) => {
  "use strict";
  Object.defineProperty(Ys, "__esModule", {
    value: !0
  });
  var Rf = Mf();
  Object.keys(Rf).forEach(function(e) {
    e === "default" || e === "__esModule" || e in Ys && Ys[e] === Rf[e] || Object.defineProperty(Ys, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return Rf[e];
      }, "get")
    });
  });
  var qf = Vg();
  Object.keys(qf).forEach(function(e) {
    e === "default" || e === "__esModule" || e in Ys && Ys[e] === qf[e] || Object.defineProperty(Ys, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return qf[e];
      }, "get")
    });
  });
});

// ../node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var Kg = D((Uf) => {
  "use strict";
  Object.defineProperty(Uf, "__esModule", {
    value: !0
  });
  Uf.default = Aj;
  var vj = Qt(), Pj = ce();
  function Aj(e, t) {
    let r = e.value.split(/\r\n|\n|\r/), s = 0;
    for (let a = 0; a < r.length; a++)
      /[^ \t]/.exec(r[a]) && (s = a);
    let n = "";
    for (let a = 0; a < r.length; a++) {
      let o = r[a], l = a === 0, u = a === r.length - 1, c = a === s, p = o.replace(/\t/g, " ");
      l || (p = p.replace(/^ +/, "")), u || (p = p.replace(/ +$/, "")), p && (c || (p += " "), n += p);
    }
    n && t.push((0, Pj.inherits)((0, vj.stringLiteral)(n), e));
  }
  i(Aj, "cleanJSXElementLiteralChild");
});

// ../node_modules/@babel/types/lib/builders/react/buildChildren.js
var Wg = D((Vf) => {
  "use strict";
  Object.defineProperty(Vf, "__esModule", {
    value: !0
  });
  Vf.default = wj;
  var $f = ze(), Cj = Kg();
  function wj(e) {
    let t = [];
    for (let r = 0; r < e.children.length; r++) {
      let s = e.children[r];
      if ((0, $f.isJSXText)(s)) {
        (0, Cj.default)(s, t);
        continue;
      }
      (0, $f.isJSXExpressionContainer)(s) && (s = s.expression), !(0, $f.isJSXEmptyExpression)(s) && t.push(s);
    }
    return t;
  }
  i(wj, "buildChildren");
});

// ../node_modules/@babel/types/lib/validators/isNode.js
var Wf = D((Kf) => {
  "use strict";
  Object.defineProperty(Kf, "__esModule", {
    value: !0
  });
  Kf.default = _j;
  var Dj = dr();
  function _j(e) {
    return !!(e && Dj.VISITOR_KEYS[e.type]);
  }
  i(_j, "isNode");
});

// ../node_modules/@babel/types/lib/asserts/assertNode.js
var Yg = D((Yf) => {
  "use strict";
  Object.defineProperty(Yf, "__esModule", {
    value: !0
  });
  Yf.default = Oj;
  var Ij = Wf();
  function Oj(e) {
    if (!(0, Ij.default)(e)) {
      var t;
      let r = (t = e?.type) != null ? t : JSON.stringify(e);
      throw new TypeError(`Not a valid node of type "${r}"`);
    }
  }
  i(Oj, "assertNode");
});

// ../node_modules/@babel/types/lib/asserts/generated/index.js
var Hg = D((v) => {
  "use strict";
  Object.defineProperty(v, "__esModule", {
    value: !0
  });
  v.assertAccessor = z$;
  v.assertAnyTypeAnnotation = hR;
  v.assertArgumentPlaceholder = Vq;
  v.assertArrayExpression = Bj;
  v.assertArrayPattern = OM;
  v.assertArrayTypeAnnotation = mR;
  v.assertArrowFunctionExpression = NM;
  v.assertAssignmentExpression = kj;
  v.assertAssignmentPattern = IM;
  v.assertAwaitExpression = tR;
  v.assertBigIntLiteral = sR;
  v.assertBinary = g$;
  v.assertBinaryExpression = Fj;
  v.assertBindExpression = Kq;
  v.assertBlock = E$;
  v.assertBlockParent = x$;
  v.assertBlockStatement = Rj;
  v.assertBooleanLiteral = aM;
  v.assertBooleanLiteralTypeAnnotation = bR;
  v.assertBooleanTypeAnnotation = yR;
  v.assertBreakStatement = qj;
  v.assertCallExpression = Uj;
  v.assertCatchClause = $j;
  v.assertClass = H$;
  v.assertClassAccessorProperty = lR;
  v.assertClassBody = BM;
  v.assertClassDeclaration = FM;
  v.assertClassExpression = kM;
  v.assertClassImplements = TR;
  v.assertClassMethod = HM;
  v.assertClassPrivateMethod = cR;
  v.assertClassPrivateProperty = uR;
  v.assertClassProperty = oR;
  v.assertCompletionStatement = P$;
  v.assertConditional = A$;
  v.assertConditionalExpression = Vj;
  v.assertContinueStatement = Kj;
  v.assertDebuggerStatement = Wj;
  v.assertDecimalLiteral = Xq;
  v.assertDeclaration = k$;
  v.assertDeclareClass = xR;
  v.assertDeclareExportAllDeclaration = _R;
  v.assertDeclareExportDeclaration = DR;
  v.assertDeclareFunction = ER;
  v.assertDeclareInterface = SR;
  v.assertDeclareModule = vR;
  v.assertDeclareModuleExports = PR;
  v.assertDeclareOpaqueType = CR;
  v.assertDeclareTypeAlias = AR;
  v.assertDeclareVariable = wR;
  v.assertDeclaredPredicate = IR;
  v.assertDecorator = Wq;
  v.assertDirective = jj;
  v.assertDirectiveLiteral = Mj;
  v.assertDoExpression = Yq;
  v.assertDoWhileStatement = Yj;
  v.assertEmptyStatement = Hj;
  v.assertEmptyTypeAnnotation = UR;
  v.assertEnumBody = nV;
  v.assertEnumBooleanBody = mq;
  v.assertEnumBooleanMember = Tq;
  v.assertEnumDeclaration = hq;
  v.assertEnumDefaultedMember = Sq;
  v.assertEnumMember = iV;
  v.assertEnumNumberBody = yq;
  v.assertEnumNumberMember = xq;
  v.assertEnumStringBody = bq;
  v.assertEnumStringMember = Eq;
  v.assertEnumSymbolBody = gq;
  v.assertExistsTypeAnnotation = OR;
  v.assertExportAllDeclaration = LM;
  v.assertExportDeclaration = G$;
  v.assertExportDefaultDeclaration = jM;
  v.assertExportDefaultSpecifier = Hq;
  v.assertExportNamedDeclaration = MM;
  v.assertExportNamespaceSpecifier = nR;
  v.assertExportSpecifier = RM;
  v.assertExpression = b$;
  v.assertExpressionStatement = Jj;
  v.assertExpressionWrapper = D$;
  v.assertFile = Gj;
  v.assertFlow = Z$;
  v.assertFlowBaseAnnotation = tV;
  v.assertFlowDeclaration = rV;
  v.assertFlowPredicate = sV;
  v.assertFlowType = eV;
  v.assertFor = _$;
  v.assertForInStatement = Xj;
  v.assertForOfStatement = qM;
  v.assertForStatement = zj;
  v.assertForXStatement = I$;
  v.assertFunction = O$;
  v.assertFunctionDeclaration = Qj;
  v.assertFunctionExpression = Zj;
  v.assertFunctionParameter = F$;
  v.assertFunctionParent = N$;
  v.assertFunctionTypeAnnotation = NR;
  v.assertFunctionTypeParam = BR;
  v.assertGenericTypeAnnotation = kR;
  v.assertIdentifier = eM;
  v.assertIfStatement = tM;
  v.assertImmutable = q$;
  v.assertImport = rR;
  v.assertImportAttribute = dR;
  v.assertImportDeclaration = UM;
  v.assertImportDefaultSpecifier = $M;
  v.assertImportExpression = WM;
  v.assertImportNamespaceSpecifier = VM;
  v.assertImportOrExportDeclaration = J$;
  v.assertImportSpecifier = KM;
  v.assertIndexedAccessType = vq;
  v.assertInferredPredicate = FR;
  v.assertInterfaceDeclaration = jR;
  v.assertInterfaceExtends = LR;
  v.assertInterfaceTypeAnnotation = MR;
  v.assertInterpreterDirective = Lj;
  v.assertIntersectionTypeAnnotation = RR;
  v.assertJSX = aV;
  v.assertJSXAttribute = Aq;
  v.assertJSXClosingElement = Cq;
  v.assertJSXClosingFragment = Rq;
  v.assertJSXElement = wq;
  v.assertJSXEmptyExpression = Dq;
  v.assertJSXExpressionContainer = _q;
  v.assertJSXFragment = jq;
  v.assertJSXIdentifier = Oq;
  v.assertJSXMemberExpression = Nq;
  v.assertJSXNamespacedName = Bq;
  v.assertJSXOpeningElement = kq;
  v.assertJSXOpeningFragment = Mq;
  v.assertJSXSpreadAttribute = Fq;
  v.assertJSXSpreadChild = Iq;
  v.assertJSXText = Lq;
  v.assertLVal = j$;
  v.assertLabeledStatement = rM;
  v.assertLiteral = R$;
  v.assertLogicalExpression = lM;
  v.assertLoop = C$;
  v.assertMemberExpression = uM;
  v.assertMetaProperty = YM;
  v.assertMethod = $$;
  v.assertMiscellaneous = oV;
  v.assertMixedTypeAnnotation = qR;
  v.assertModuleDeclaration = yV;
  v.assertModuleExpression = zq;
  v.assertModuleSpecifier = X$;
  v.assertNewExpression = cM;
  v.assertNoop = qq;
  v.assertNullLiteral = iM;
  v.assertNullLiteralTypeAnnotation = gR;
  v.assertNullableTypeAnnotation = $R;
  v.assertNumberLiteral = fV;
  v.assertNumberLiteralTypeAnnotation = VR;
  v.assertNumberTypeAnnotation = KR;
  v.assertNumericLiteral = nM;
  v.assertObjectExpression = fM;
  v.assertObjectMember = V$;
  v.assertObjectMethod = dM;
  v.assertObjectPattern = JM;
  v.assertObjectProperty = hM;
  v.assertObjectTypeAnnotation = WR;
  v.assertObjectTypeCallProperty = HR;
  v.assertObjectTypeIndexer = JR;
  v.assertObjectTypeInternalSlot = YR;
  v.assertObjectTypeProperty = GR;
  v.assertObjectTypeSpreadProperty = XR;
  v.assertOpaqueType = zR;
  v.assertOptionalCallExpression = aR;
  v.assertOptionalIndexedAccessType = Pq;
  v.assertOptionalMemberExpression = iR;
  v.assertParenthesizedExpression = gM;
  v.assertPattern = Y$;
  v.assertPatternLike = L$;
  v.assertPipelineBareFunction = eU;
  v.assertPipelinePrimaryTopicReference = tU;
  v.assertPipelineTopicExpression = Zq;
  v.assertPlaceholder = Uq;
  v.assertPrivate = Q$;
  v.assertPrivateName = pR;
  v.assertProgram = pM;
  v.assertProperty = K$;
  v.assertPureish = B$;
  v.assertQualifiedTypeIdentifier = QR;
  v.assertRecordExpression = Jq;
  v.assertRegExpLiteral = oM;
  v.assertRegexLiteral = dV;
  v.assertRestElement = mM;
  v.assertRestProperty = hV;
  v.assertReturnStatement = yM;
  v.assertScopable = T$;
  v.assertSequenceExpression = bM;
  v.assertSpreadElement = GM;
  v.assertSpreadProperty = mV;
  v.assertStandardized = y$;
  v.assertStatement = S$;
  v.assertStaticBlock = fR;
  v.assertStringLiteral = sM;
  v.assertStringLiteralTypeAnnotation = ZR;
  v.assertStringTypeAnnotation = eq;
  v.assertSuper = XM;
  v.assertSwitchCase = TM;
  v.assertSwitchStatement = xM;
  v.assertSymbolTypeAnnotation = tq;
  v.assertTSAnyKeyword = fU;
  v.assertTSArrayType = NU;
  v.assertTSAsExpression = QU;
  v.assertTSBaseType = pV;
  v.assertTSBigIntKeyword = hU;
  v.assertTSBooleanKeyword = dU;
  v.assertTSCallSignatureDeclaration = oU;
  v.assertTSConditionalType = RU;
  v.assertTSConstructSignatureDeclaration = lU;
  v.assertTSConstructorType = wU;
  v.assertTSDeclareFunction = nU;
  v.assertTSDeclareMethod = iU;
  v.assertTSEntityName = M$;
  v.assertTSEnumBody = t$;
  v.assertTSEnumDeclaration = r$;
  v.assertTSEnumMember = s$;
  v.assertTSExportAssignment = c$;
  v.assertTSExpressionWithTypeArguments = HU;
  v.assertTSExternalModuleReference = l$;
  v.assertTSFunctionType = CU;
  v.assertTSImportEqualsDeclaration = o$;
  v.assertTSImportType = a$;
  v.assertTSIndexSignature = pU;
  v.assertTSIndexedAccessType = VU;
  v.assertTSInferType = qU;
  v.assertTSInstantiationExpression = zU;
  v.assertTSInterfaceBody = GU;
  v.assertTSInterfaceDeclaration = JU;
  v.assertTSIntersectionType = MU;
  v.assertTSIntrinsicKeyword = mU;
  v.assertTSLiteralType = YU;
  v.assertTSMappedType = KU;
  v.assertTSMethodSignature = cU;
  v.assertTSModuleBlock = i$;
  v.assertTSModuleDeclaration = n$;
  v.assertTSNamedTupleMember = LU;
  v.assertTSNamespaceExportDeclaration = p$;
  v.assertTSNeverKeyword = yU;
  v.assertTSNonNullExpression = u$;
  v.assertTSNullKeyword = bU;
  v.assertTSNumberKeyword = gU;
  v.assertTSObjectKeyword = TU;
  v.assertTSOptionalType = kU;
  v.assertTSParameterProperty = sU;
  v.assertTSParenthesizedType = UU;
  v.assertTSPropertySignature = uU;
  v.assertTSQualifiedName = aU;
  v.assertTSRestType = FU;
  v.assertTSSatisfiesExpression = ZU;
  v.assertTSStringKeyword = xU;
  v.assertTSSymbolKeyword = EU;
  v.assertTSTemplateLiteralType = WU;
  v.assertTSThisType = AU;
  v.assertTSTupleType = BU;
  v.assertTSType = cV;
  v.assertTSTypeAliasDeclaration = XU;
  v.assertTSTypeAnnotation = f$;
  v.assertTSTypeAssertion = e$;
  v.assertTSTypeElement = uV;
  v.assertTSTypeLiteral = OU;
  v.assertTSTypeOperator = $U;
  v.assertTSTypeParameter = m$;
  v.assertTSTypeParameterDeclaration = h$;
  v.assertTSTypeParameterInstantiation = d$;
  v.assertTSTypePredicate = _U;
  v.assertTSTypeQuery = IU;
  v.assertTSTypeReference = DU;
  v.assertTSUndefinedKeyword = SU;
  v.assertTSUnionType = jU;
  v.assertTSUnknownKeyword = vU;
  v.assertTSVoidKeyword = PU;
  v.assertTaggedTemplateExpression = zM;
  v.assertTemplateElement = QM;
  v.assertTemplateLiteral = ZM;
  v.assertTerminatorless = v$;
  v.assertThisExpression = EM;
  v.assertThisTypeAnnotation = rq;
  v.assertThrowStatement = SM;
  v.assertTopicReference = Qq;
  v.assertTryStatement = vM;
  v.assertTupleExpression = Gq;
  v.assertTupleTypeAnnotation = sq;
  v.assertTypeAlias = iq;
  v.assertTypeAnnotation = aq;
  v.assertTypeCastExpression = oq;
  v.assertTypeParameter = lq;
  v.assertTypeParameterDeclaration = uq;
  v.assertTypeParameterInstantiation = cq;
  v.assertTypeScript = lV;
  v.assertTypeofTypeAnnotation = nq;
  v.assertUnaryExpression = PM;
  v.assertUnaryLike = W$;
  v.assertUnionTypeAnnotation = pq;
  v.assertUpdateExpression = AM;
  v.assertUserWhitespacable = U$;
  v.assertV8IntrinsicIdentifier = $q;
  v.assertVariableDeclaration = CM;
  v.assertVariableDeclarator = wM;
  v.assertVariance = fq;
  v.assertVoidPattern = rU;
  v.assertVoidTypeAnnotation = dq;
  v.assertWhile = w$;
  v.assertWhileStatement = DM;
  v.assertWithStatement = _M;
  v.assertYieldExpression = eR;
  var Nj = yi(), La = mi();
  function P(e, t, r) {
    if (!(0, Nj.default)(e, t, r))
      throw new Error(`Expected type "${e}" with option ${JSON.stringify(r)}, but instead got "${t.type}".`);
  }
  i(P, "assert");
  function Bj(e, t) {
    P("ArrayExpression", e, t);
  }
  i(Bj, "assertArrayExpression");
  function kj(e, t) {
    P("AssignmentExpression", e, t);
  }
  i(kj, "assertAssignmentExpression");
  function Fj(e, t) {
    P("BinaryExpression", e, t);
  }
  i(Fj, "assertBinaryExpression");
  function Lj(e, t) {
    P("InterpreterDirective", e, t);
  }
  i(Lj, "assertInterpreterDirective");
  function jj(e, t) {
    P("Directive", e, t);
  }
  i(jj, "assertDirective");
  function Mj(e, t) {
    P("DirectiveLiteral", e, t);
  }
  i(Mj, "assertDirectiveLiteral");
  function Rj(e, t) {
    P("BlockStatement", e, t);
  }
  i(Rj, "assertBlockStatement");
  function qj(e, t) {
    P("BreakStatement", e, t);
  }
  i(qj, "assertBreakStatement");
  function Uj(e, t) {
    P("CallExpression", e, t);
  }
  i(Uj, "assertCallExpression");
  function $j(e, t) {
    P("CatchClause", e, t);
  }
  i($j, "assertCatchClause");
  function Vj(e, t) {
    P("ConditionalExpression", e, t);
  }
  i(Vj, "assertConditionalExpression");
  function Kj(e, t) {
    P("ContinueStatement", e, t);
  }
  i(Kj, "assertContinueStatement");
  function Wj(e, t) {
    P("DebuggerStatement", e, t);
  }
  i(Wj, "assertDebuggerStatement");
  function Yj(e, t) {
    P("DoWhileStatement", e, t);
  }
  i(Yj, "assertDoWhileStatement");
  function Hj(e, t) {
    P("EmptyStatement", e, t);
  }
  i(Hj, "assertEmptyStatement");
  function Jj(e, t) {
    P("ExpressionStatement", e, t);
  }
  i(Jj, "assertExpressionStatement");
  function Gj(e, t) {
    P("File", e, t);
  }
  i(Gj, "assertFile");
  function Xj(e, t) {
    P("ForInStatement", e, t);
  }
  i(Xj, "assertForInStatement");
  function zj(e, t) {
    P("ForStatement", e, t);
  }
  i(zj, "assertForStatement");
  function Qj(e, t) {
    P("FunctionDeclaration", e, t);
  }
  i(Qj, "assertFunctionDeclaration");
  function Zj(e, t) {
    P("FunctionExpression", e, t);
  }
  i(Zj, "assertFunctionExpression");
  function eM(e, t) {
    P("Identifier", e, t);
  }
  i(eM, "assertIdentifier");
  function tM(e, t) {
    P("IfStatement", e, t);
  }
  i(tM, "assertIfStatement");
  function rM(e, t) {
    P("LabeledStatement", e, t);
  }
  i(rM, "assertLabeledStatement");
  function sM(e, t) {
    P("StringLiteral", e, t);
  }
  i(sM, "assertStringLiteral");
  function nM(e, t) {
    P("NumericLiteral", e, t);
  }
  i(nM, "assertNumericLiteral");
  function iM(e, t) {
    P("NullLiteral", e, t);
  }
  i(iM, "assertNullLiteral");
  function aM(e, t) {
    P("BooleanLiteral", e, t);
  }
  i(aM, "assertBooleanLiteral");
  function oM(e, t) {
    P("RegExpLiteral", e, t);
  }
  i(oM, "assertRegExpLiteral");
  function lM(e, t) {
    P("LogicalExpression", e, t);
  }
  i(lM, "assertLogicalExpression");
  function uM(e, t) {
    P("MemberExpression", e, t);
  }
  i(uM, "assertMemberExpression");
  function cM(e, t) {
    P("NewExpression", e, t);
  }
  i(cM, "assertNewExpression");
  function pM(e, t) {
    P("Program", e, t);
  }
  i(pM, "assertProgram");
  function fM(e, t) {
    P("ObjectExpression", e, t);
  }
  i(fM, "assertObjectExpression");
  function dM(e, t) {
    P("ObjectMethod", e, t);
  }
  i(dM, "assertObjectMethod");
  function hM(e, t) {
    P("ObjectProperty", e, t);
  }
  i(hM, "assertObjectProperty");
  function mM(e, t) {
    P("RestElement", e, t);
  }
  i(mM, "assertRestElement");
  function yM(e, t) {
    P("ReturnStatement", e, t);
  }
  i(yM, "assertReturnStatement");
  function bM(e, t) {
    P("SequenceExpression", e, t);
  }
  i(bM, "assertSequenceExpression");
  function gM(e, t) {
    P("ParenthesizedExpression", e, t);
  }
  i(gM, "assertParenthesizedExpression");
  function TM(e, t) {
    P("SwitchCase", e, t);
  }
  i(TM, "assertSwitchCase");
  function xM(e, t) {
    P("SwitchStatement", e, t);
  }
  i(xM, "assertSwitchStatement");
  function EM(e, t) {
    P("ThisExpression", e, t);
  }
  i(EM, "assertThisExpression");
  function SM(e, t) {
    P("ThrowStatement", e, t);
  }
  i(SM, "assertThrowStatement");
  function vM(e, t) {
    P("TryStatement", e, t);
  }
  i(vM, "assertTryStatement");
  function PM(e, t) {
    P("UnaryExpression", e, t);
  }
  i(PM, "assertUnaryExpression");
  function AM(e, t) {
    P("UpdateExpression", e, t);
  }
  i(AM, "assertUpdateExpression");
  function CM(e, t) {
    P("VariableDeclaration", e, t);
  }
  i(CM, "assertVariableDeclaration");
  function wM(e, t) {
    P("VariableDeclarator", e, t);
  }
  i(wM, "assertVariableDeclarator");
  function DM(e, t) {
    P("WhileStatement", e, t);
  }
  i(DM, "assertWhileStatement");
  function _M(e, t) {
    P("WithStatement", e, t);
  }
  i(_M, "assertWithStatement");
  function IM(e, t) {
    P("AssignmentPattern", e, t);
  }
  i(IM, "assertAssignmentPattern");
  function OM(e, t) {
    P("ArrayPattern", e, t);
  }
  i(OM, "assertArrayPattern");
  function NM(e, t) {
    P("ArrowFunctionExpression", e, t);
  }
  i(NM, "assertArrowFunctionExpression");
  function BM(e, t) {
    P("ClassBody", e, t);
  }
  i(BM, "assertClassBody");
  function kM(e, t) {
    P("ClassExpression", e, t);
  }
  i(kM, "assertClassExpression");
  function FM(e, t) {
    P("ClassDeclaration", e, t);
  }
  i(FM, "assertClassDeclaration");
  function LM(e, t) {
    P("ExportAllDeclaration", e, t);
  }
  i(LM, "assertExportAllDeclaration");
  function jM(e, t) {
    P("ExportDefaultDeclaration", e, t);
  }
  i(jM, "assertExportDefaultDeclaration");
  function MM(e, t) {
    P("ExportNamedDeclaration", e, t);
  }
  i(MM, "assertExportNamedDeclaration");
  function RM(e, t) {
    P("ExportSpecifier", e, t);
  }
  i(RM, "assertExportSpecifier");
  function qM(e, t) {
    P("ForOfStatement", e, t);
  }
  i(qM, "assertForOfStatement");
  function UM(e, t) {
    P("ImportDeclaration", e, t);
  }
  i(UM, "assertImportDeclaration");
  function $M(e, t) {
    P("ImportDefaultSpecifier", e, t);
  }
  i($M, "assertImportDefaultSpecifier");
  function VM(e, t) {
    P("ImportNamespaceSpecifier", e, t);
  }
  i(VM, "assertImportNamespaceSpecifier");
  function KM(e, t) {
    P("ImportSpecifier", e, t);
  }
  i(KM, "assertImportSpecifier");
  function WM(e, t) {
    P("ImportExpression", e, t);
  }
  i(WM, "assertImportExpression");
  function YM(e, t) {
    P("MetaProperty", e, t);
  }
  i(YM, "assertMetaProperty");
  function HM(e, t) {
    P("ClassMethod", e, t);
  }
  i(HM, "assertClassMethod");
  function JM(e, t) {
    P("ObjectPattern", e, t);
  }
  i(JM, "assertObjectPattern");
  function GM(e, t) {
    P("SpreadElement", e, t);
  }
  i(GM, "assertSpreadElement");
  function XM(e, t) {
    P("Super", e, t);
  }
  i(XM, "assertSuper");
  function zM(e, t) {
    P("TaggedTemplateExpression", e, t);
  }
  i(zM, "assertTaggedTemplateExpression");
  function QM(e, t) {
    P("TemplateElement", e, t);
  }
  i(QM, "assertTemplateElement");
  function ZM(e, t) {
    P("TemplateLiteral", e, t);
  }
  i(ZM, "assertTemplateLiteral");
  function eR(e, t) {
    P("YieldExpression", e, t);
  }
  i(eR, "assertYieldExpression");
  function tR(e, t) {
    P("AwaitExpression", e, t);
  }
  i(tR, "assertAwaitExpression");
  function rR(e, t) {
    P("Import", e, t);
  }
  i(rR, "assertImport");
  function sR(e, t) {
    P("BigIntLiteral", e, t);
  }
  i(sR, "assertBigIntLiteral");
  function nR(e, t) {
    P("ExportNamespaceSpecifier", e, t);
  }
  i(nR, "assertExportNamespaceSpecifier");
  function iR(e, t) {
    P("OptionalMemberExpression", e, t);
  }
  i(iR, "assertOptionalMemberExpression");
  function aR(e, t) {
    P("OptionalCallExpression", e, t);
  }
  i(aR, "assertOptionalCallExpression");
  function oR(e, t) {
    P("ClassProperty", e, t);
  }
  i(oR, "assertClassProperty");
  function lR(e, t) {
    P("ClassAccessorProperty", e, t);
  }
  i(lR, "assertClassAccessorProperty");
  function uR(e, t) {
    P("ClassPrivateProperty", e, t);
  }
  i(uR, "assertClassPrivateProperty");
  function cR(e, t) {
    P("ClassPrivateMethod", e, t);
  }
  i(cR, "assertClassPrivateMethod");
  function pR(e, t) {
    P("PrivateName", e, t);
  }
  i(pR, "assertPrivateName");
  function fR(e, t) {
    P("StaticBlock", e, t);
  }
  i(fR, "assertStaticBlock");
  function dR(e, t) {
    P("ImportAttribute", e, t);
  }
  i(dR, "assertImportAttribute");
  function hR(e, t) {
    P("AnyTypeAnnotation", e, t);
  }
  i(hR, "assertAnyTypeAnnotation");
  function mR(e, t) {
    P("ArrayTypeAnnotation", e, t);
  }
  i(mR, "assertArrayTypeAnnotation");
  function yR(e, t) {
    P("BooleanTypeAnnotation", e, t);
  }
  i(yR, "assertBooleanTypeAnnotation");
  function bR(e, t) {
    P("BooleanLiteralTypeAnnotation", e, t);
  }
  i(bR, "assertBooleanLiteralTypeAnnotation");
  function gR(e, t) {
    P("NullLiteralTypeAnnotation", e, t);
  }
  i(gR, "assertNullLiteralTypeAnnotation");
  function TR(e, t) {
    P("ClassImplements", e, t);
  }
  i(TR, "assertClassImplements");
  function xR(e, t) {
    P("DeclareClass", e, t);
  }
  i(xR, "assertDeclareClass");
  function ER(e, t) {
    P("DeclareFunction", e, t);
  }
  i(ER, "assertDeclareFunction");
  function SR(e, t) {
    P("DeclareInterface", e, t);
  }
  i(SR, "assertDeclareInterface");
  function vR(e, t) {
    P("DeclareModule", e, t);
  }
  i(vR, "assertDeclareModule");
  function PR(e, t) {
    P("DeclareModuleExports", e, t);
  }
  i(PR, "assertDeclareModuleExports");
  function AR(e, t) {
    P("DeclareTypeAlias", e, t);
  }
  i(AR, "assertDeclareTypeAlias");
  function CR(e, t) {
    P("DeclareOpaqueType", e, t);
  }
  i(CR, "assertDeclareOpaqueType");
  function wR(e, t) {
    P("DeclareVariable", e, t);
  }
  i(wR, "assertDeclareVariable");
  function DR(e, t) {
    P("DeclareExportDeclaration", e, t);
  }
  i(DR, "assertDeclareExportDeclaration");
  function _R(e, t) {
    P("DeclareExportAllDeclaration", e, t);
  }
  i(_R, "assertDeclareExportAllDeclaration");
  function IR(e, t) {
    P("DeclaredPredicate", e, t);
  }
  i(IR, "assertDeclaredPredicate");
  function OR(e, t) {
    P("ExistsTypeAnnotation", e, t);
  }
  i(OR, "assertExistsTypeAnnotation");
  function NR(e, t) {
    P("FunctionTypeAnnotation", e, t);
  }
  i(NR, "assertFunctionTypeAnnotation");
  function BR(e, t) {
    P("FunctionTypeParam", e, t);
  }
  i(BR, "assertFunctionTypeParam");
  function kR(e, t) {
    P("GenericTypeAnnotation", e, t);
  }
  i(kR, "assertGenericTypeAnnotation");
  function FR(e, t) {
    P("InferredPredicate", e, t);
  }
  i(FR, "assertInferredPredicate");
  function LR(e, t) {
    P("InterfaceExtends", e, t);
  }
  i(LR, "assertInterfaceExtends");
  function jR(e, t) {
    P("InterfaceDeclaration", e, t);
  }
  i(jR, "assertInterfaceDeclaration");
  function MR(e, t) {
    P("InterfaceTypeAnnotation", e, t);
  }
  i(MR, "assertInterfaceTypeAnnotation");
  function RR(e, t) {
    P("IntersectionTypeAnnotation", e, t);
  }
  i(RR, "assertIntersectionTypeAnnotation");
  function qR(e, t) {
    P("MixedTypeAnnotation", e, t);
  }
  i(qR, "assertMixedTypeAnnotation");
  function UR(e, t) {
    P("EmptyTypeAnnotation", e, t);
  }
  i(UR, "assertEmptyTypeAnnotation");
  function $R(e, t) {
    P("NullableTypeAnnotation", e, t);
  }
  i($R, "assertNullableTypeAnnotation");
  function VR(e, t) {
    P("NumberLiteralTypeAnnotation", e, t);
  }
  i(VR, "assertNumberLiteralTypeAnnotation");
  function KR(e, t) {
    P("NumberTypeAnnotation", e, t);
  }
  i(KR, "assertNumberTypeAnnotation");
  function WR(e, t) {
    P("ObjectTypeAnnotation", e, t);
  }
  i(WR, "assertObjectTypeAnnotation");
  function YR(e, t) {
    P("ObjectTypeInternalSlot", e, t);
  }
  i(YR, "assertObjectTypeInternalSlot");
  function HR(e, t) {
    P("ObjectTypeCallProperty", e, t);
  }
  i(HR, "assertObjectTypeCallProperty");
  function JR(e, t) {
    P("ObjectTypeIndexer", e, t);
  }
  i(JR, "assertObjectTypeIndexer");
  function GR(e, t) {
    P("ObjectTypeProperty", e, t);
  }
  i(GR, "assertObjectTypeProperty");
  function XR(e, t) {
    P("ObjectTypeSpreadProperty", e, t);
  }
  i(XR, "assertObjectTypeSpreadProperty");
  function zR(e, t) {
    P("OpaqueType", e, t);
  }
  i(zR, "assertOpaqueType");
  function QR(e, t) {
    P("QualifiedTypeIdentifier", e, t);
  }
  i(QR, "assertQualifiedTypeIdentifier");
  function ZR(e, t) {
    P("StringLiteralTypeAnnotation", e, t);
  }
  i(ZR, "assertStringLiteralTypeAnnotation");
  function eq(e, t) {
    P("StringTypeAnnotation", e, t);
  }
  i(eq, "assertStringTypeAnnotation");
  function tq(e, t) {
    P("SymbolTypeAnnotation", e, t);
  }
  i(tq, "assertSymbolTypeAnnotation");
  function rq(e, t) {
    P("ThisTypeAnnotation", e, t);
  }
  i(rq, "assertThisTypeAnnotation");
  function sq(e, t) {
    P("TupleTypeAnnotation", e, t);
  }
  i(sq, "assertTupleTypeAnnotation");
  function nq(e, t) {
    P("TypeofTypeAnnotation", e, t);
  }
  i(nq, "assertTypeofTypeAnnotation");
  function iq(e, t) {
    P("TypeAlias", e, t);
  }
  i(iq, "assertTypeAlias");
  function aq(e, t) {
    P("TypeAnnotation", e, t);
  }
  i(aq, "assertTypeAnnotation");
  function oq(e, t) {
    P("TypeCastExpression", e, t);
  }
  i(oq, "assertTypeCastExpression");
  function lq(e, t) {
    P("TypeParameter", e, t);
  }
  i(lq, "assertTypeParameter");
  function uq(e, t) {
    P("TypeParameterDeclaration", e, t);
  }
  i(uq, "assertTypeParameterDeclaration");
  function cq(e, t) {
    P("TypeParameterInstantiation", e, t);
  }
  i(cq, "assertTypeParameterInstantiation");
  function pq(e, t) {
    P("UnionTypeAnnotation", e, t);
  }
  i(pq, "assertUnionTypeAnnotation");
  function fq(e, t) {
    P("Variance", e, t);
  }
  i(fq, "assertVariance");
  function dq(e, t) {
    P("VoidTypeAnnotation", e, t);
  }
  i(dq, "assertVoidTypeAnnotation");
  function hq(e, t) {
    P("EnumDeclaration", e, t);
  }
  i(hq, "assertEnumDeclaration");
  function mq(e, t) {
    P("EnumBooleanBody", e, t);
  }
  i(mq, "assertEnumBooleanBody");
  function yq(e, t) {
    P("EnumNumberBody", e, t);
  }
  i(yq, "assertEnumNumberBody");
  function bq(e, t) {
    P("EnumStringBody", e, t);
  }
  i(bq, "assertEnumStringBody");
  function gq(e, t) {
    P("EnumSymbolBody", e, t);
  }
  i(gq, "assertEnumSymbolBody");
  function Tq(e, t) {
    P("EnumBooleanMember", e, t);
  }
  i(Tq, "assertEnumBooleanMember");
  function xq(e, t) {
    P("EnumNumberMember", e, t);
  }
  i(xq, "assertEnumNumberMember");
  function Eq(e, t) {
    P("EnumStringMember", e, t);
  }
  i(Eq, "assertEnumStringMember");
  function Sq(e, t) {
    P("EnumDefaultedMember", e, t);
  }
  i(Sq, "assertEnumDefaultedMember");
  function vq(e, t) {
    P("IndexedAccessType", e, t);
  }
  i(vq, "assertIndexedAccessType");
  function Pq(e, t) {
    P("OptionalIndexedAccessType", e, t);
  }
  i(Pq, "assertOptionalIndexedAccessType");
  function Aq(e, t) {
    P("JSXAttribute", e, t);
  }
  i(Aq, "assertJSXAttribute");
  function Cq(e, t) {
    P("JSXClosingElement", e, t);
  }
  i(Cq, "assertJSXClosingElement");
  function wq(e, t) {
    P("JSXElement", e, t);
  }
  i(wq, "assertJSXElement");
  function Dq(e, t) {
    P("JSXEmptyExpression", e, t);
  }
  i(Dq, "assertJSXEmptyExpression");
  function _q(e, t) {
    P("JSXExpressionContainer", e, t);
  }
  i(_q, "assertJSXExpressionContainer");
  function Iq(e, t) {
    P("JSXSpreadChild", e, t);
  }
  i(Iq, "assertJSXSpreadChild");
  function Oq(e, t) {
    P("JSXIdentifier", e, t);
  }
  i(Oq, "assertJSXIdentifier");
  function Nq(e, t) {
    P("JSXMemberExpression", e, t);
  }
  i(Nq, "assertJSXMemberExpression");
  function Bq(e, t) {
    P("JSXNamespacedName", e, t);
  }
  i(Bq, "assertJSXNamespacedName");
  function kq(e, t) {
    P("JSXOpeningElement", e, t);
  }
  i(kq, "assertJSXOpeningElement");
  function Fq(e, t) {
    P("JSXSpreadAttribute", e, t);
  }
  i(Fq, "assertJSXSpreadAttribute");
  function Lq(e, t) {
    P("JSXText", e, t);
  }
  i(Lq, "assertJSXText");
  function jq(e, t) {
    P("JSXFragment", e, t);
  }
  i(jq, "assertJSXFragment");
  function Mq(e, t) {
    P("JSXOpeningFragment", e, t);
  }
  i(Mq, "assertJSXOpeningFragment");
  function Rq(e, t) {
    P("JSXClosingFragment", e, t);
  }
  i(Rq, "assertJSXClosingFragment");
  function qq(e, t) {
    P("Noop", e, t);
  }
  i(qq, "assertNoop");
  function Uq(e, t) {
    P("Placeholder", e, t);
  }
  i(Uq, "assertPlaceholder");
  function $q(e, t) {
    P("V8IntrinsicIdentifier", e, t);
  }
  i($q, "assertV8IntrinsicIdentifier");
  function Vq(e, t) {
    P("ArgumentPlaceholder", e, t);
  }
  i(Vq, "assertArgumentPlaceholder");
  function Kq(e, t) {
    P("BindExpression", e, t);
  }
  i(Kq, "assertBindExpression");
  function Wq(e, t) {
    P("Decorator", e, t);
  }
  i(Wq, "assertDecorator");
  function Yq(e, t) {
    P("DoExpression", e, t);
  }
  i(Yq, "assertDoExpression");
  function Hq(e, t) {
    P("ExportDefaultSpecifier", e, t);
  }
  i(Hq, "assertExportDefaultSpecifier");
  function Jq(e, t) {
    P("RecordExpression", e, t);
  }
  i(Jq, "assertRecordExpression");
  function Gq(e, t) {
    P("TupleExpression", e, t);
  }
  i(Gq, "assertTupleExpression");
  function Xq(e, t) {
    P("DecimalLiteral", e, t);
  }
  i(Xq, "assertDecimalLiteral");
  function zq(e, t) {
    P("ModuleExpression", e, t);
  }
  i(zq, "assertModuleExpression");
  function Qq(e, t) {
    P("TopicReference", e, t);
  }
  i(Qq, "assertTopicReference");
  function Zq(e, t) {
    P("PipelineTopicExpression", e, t);
  }
  i(Zq, "assertPipelineTopicExpression");
  function eU(e, t) {
    P("PipelineBareFunction", e, t);
  }
  i(eU, "assertPipelineBareFunction");
  function tU(e, t) {
    P("PipelinePrimaryTopicReference", e, t);
  }
  i(tU, "assertPipelinePrimaryTopicReference");
  function rU(e, t) {
    P("VoidPattern", e, t);
  }
  i(rU, "assertVoidPattern");
  function sU(e, t) {
    P("TSParameterProperty", e, t);
  }
  i(sU, "assertTSParameterProperty");
  function nU(e, t) {
    P("TSDeclareFunction", e, t);
  }
  i(nU, "assertTSDeclareFunction");
  function iU(e, t) {
    P("TSDeclareMethod", e, t);
  }
  i(iU, "assertTSDeclareMethod");
  function aU(e, t) {
    P("TSQualifiedName", e, t);
  }
  i(aU, "assertTSQualifiedName");
  function oU(e, t) {
    P("TSCallSignatureDeclaration", e, t);
  }
  i(oU, "assertTSCallSignatureDeclaration");
  function lU(e, t) {
    P("TSConstructSignatureDeclaration", e, t);
  }
  i(lU, "assertTSConstructSignatureDeclaration");
  function uU(e, t) {
    P("TSPropertySignature", e, t);
  }
  i(uU, "assertTSPropertySignature");
  function cU(e, t) {
    P("TSMethodSignature", e, t);
  }
  i(cU, "assertTSMethodSignature");
  function pU(e, t) {
    P("TSIndexSignature", e, t);
  }
  i(pU, "assertTSIndexSignature");
  function fU(e, t) {
    P("TSAnyKeyword", e, t);
  }
  i(fU, "assertTSAnyKeyword");
  function dU(e, t) {
    P("TSBooleanKeyword", e, t);
  }
  i(dU, "assertTSBooleanKeyword");
  function hU(e, t) {
    P("TSBigIntKeyword", e, t);
  }
  i(hU, "assertTSBigIntKeyword");
  function mU(e, t) {
    P("TSIntrinsicKeyword", e, t);
  }
  i(mU, "assertTSIntrinsicKeyword");
  function yU(e, t) {
    P("TSNeverKeyword", e, t);
  }
  i(yU, "assertTSNeverKeyword");
  function bU(e, t) {
    P("TSNullKeyword", e, t);
  }
  i(bU, "assertTSNullKeyword");
  function gU(e, t) {
    P("TSNumberKeyword", e, t);
  }
  i(gU, "assertTSNumberKeyword");
  function TU(e, t) {
    P("TSObjectKeyword", e, t);
  }
  i(TU, "assertTSObjectKeyword");
  function xU(e, t) {
    P("TSStringKeyword", e, t);
  }
  i(xU, "assertTSStringKeyword");
  function EU(e, t) {
    P("TSSymbolKeyword", e, t);
  }
  i(EU, "assertTSSymbolKeyword");
  function SU(e, t) {
    P("TSUndefinedKeyword", e, t);
  }
  i(SU, "assertTSUndefinedKeyword");
  function vU(e, t) {
    P("TSUnknownKeyword", e, t);
  }
  i(vU, "assertTSUnknownKeyword");
  function PU(e, t) {
    P("TSVoidKeyword", e, t);
  }
  i(PU, "assertTSVoidKeyword");
  function AU(e, t) {
    P("TSThisType", e, t);
  }
  i(AU, "assertTSThisType");
  function CU(e, t) {
    P("TSFunctionType", e, t);
  }
  i(CU, "assertTSFunctionType");
  function wU(e, t) {
    P("TSConstructorType", e, t);
  }
  i(wU, "assertTSConstructorType");
  function DU(e, t) {
    P("TSTypeReference", e, t);
  }
  i(DU, "assertTSTypeReference");
  function _U(e, t) {
    P("TSTypePredicate", e, t);
  }
  i(_U, "assertTSTypePredicate");
  function IU(e, t) {
    P("TSTypeQuery", e, t);
  }
  i(IU, "assertTSTypeQuery");
  function OU(e, t) {
    P("TSTypeLiteral", e, t);
  }
  i(OU, "assertTSTypeLiteral");
  function NU(e, t) {
    P("TSArrayType", e, t);
  }
  i(NU, "assertTSArrayType");
  function BU(e, t) {
    P("TSTupleType", e, t);
  }
  i(BU, "assertTSTupleType");
  function kU(e, t) {
    P("TSOptionalType", e, t);
  }
  i(kU, "assertTSOptionalType");
  function FU(e, t) {
    P("TSRestType", e, t);
  }
  i(FU, "assertTSRestType");
  function LU(e, t) {
    P("TSNamedTupleMember", e, t);
  }
  i(LU, "assertTSNamedTupleMember");
  function jU(e, t) {
    P("TSUnionType", e, t);
  }
  i(jU, "assertTSUnionType");
  function MU(e, t) {
    P("TSIntersectionType", e, t);
  }
  i(MU, "assertTSIntersectionType");
  function RU(e, t) {
    P("TSConditionalType", e, t);
  }
  i(RU, "assertTSConditionalType");
  function qU(e, t) {
    P("TSInferType", e, t);
  }
  i(qU, "assertTSInferType");
  function UU(e, t) {
    P("TSParenthesizedType", e, t);
  }
  i(UU, "assertTSParenthesizedType");
  function $U(e, t) {
    P("TSTypeOperator", e, t);
  }
  i($U, "assertTSTypeOperator");
  function VU(e, t) {
    P("TSIndexedAccessType", e, t);
  }
  i(VU, "assertTSIndexedAccessType");
  function KU(e, t) {
    P("TSMappedType", e, t);
  }
  i(KU, "assertTSMappedType");
  function WU(e, t) {
    P("TSTemplateLiteralType", e, t);
  }
  i(WU, "assertTSTemplateLiteralType");
  function YU(e, t) {
    P("TSLiteralType", e, t);
  }
  i(YU, "assertTSLiteralType");
  function HU(e, t) {
    P("TSExpressionWithTypeArguments", e, t);
  }
  i(HU, "assertTSExpressionWithTypeArguments");
  function JU(e, t) {
    P("TSInterfaceDeclaration", e, t);
  }
  i(JU, "assertTSInterfaceDeclaration");
  function GU(e, t) {
    P("TSInterfaceBody", e, t);
  }
  i(GU, "assertTSInterfaceBody");
  function XU(e, t) {
    P("TSTypeAliasDeclaration", e, t);
  }
  i(XU, "assertTSTypeAliasDeclaration");
  function zU(e, t) {
    P("TSInstantiationExpression", e, t);
  }
  i(zU, "assertTSInstantiationExpression");
  function QU(e, t) {
    P("TSAsExpression", e, t);
  }
  i(QU, "assertTSAsExpression");
  function ZU(e, t) {
    P("TSSatisfiesExpression", e, t);
  }
  i(ZU, "assertTSSatisfiesExpression");
  function e$(e, t) {
    P("TSTypeAssertion", e, t);
  }
  i(e$, "assertTSTypeAssertion");
  function t$(e, t) {
    P("TSEnumBody", e, t);
  }
  i(t$, "assertTSEnumBody");
  function r$(e, t) {
    P("TSEnumDeclaration", e, t);
  }
  i(r$, "assertTSEnumDeclaration");
  function s$(e, t) {
    P("TSEnumMember", e, t);
  }
  i(s$, "assertTSEnumMember");
  function n$(e, t) {
    P("TSModuleDeclaration", e, t);
  }
  i(n$, "assertTSModuleDeclaration");
  function i$(e, t) {
    P("TSModuleBlock", e, t);
  }
  i(i$, "assertTSModuleBlock");
  function a$(e, t) {
    P("TSImportType", e, t);
  }
  i(a$, "assertTSImportType");
  function o$(e, t) {
    P("TSImportEqualsDeclaration", e, t);
  }
  i(o$, "assertTSImportEqualsDeclaration");
  function l$(e, t) {
    P("TSExternalModuleReference", e, t);
  }
  i(l$, "assertTSExternalModuleReference");
  function u$(e, t) {
    P("TSNonNullExpression", e, t);
  }
  i(u$, "assertTSNonNullExpression");
  function c$(e, t) {
    P("TSExportAssignment", e, t);
  }
  i(c$, "assertTSExportAssignment");
  function p$(e, t) {
    P("TSNamespaceExportDeclaration", e, t);
  }
  i(p$, "assertTSNamespaceExportDeclaration");
  function f$(e, t) {
    P("TSTypeAnnotation", e, t);
  }
  i(f$, "assertTSTypeAnnotation");
  function d$(e, t) {
    P("TSTypeParameterInstantiation", e, t);
  }
  i(d$, "assertTSTypeParameterInstantiation");
  function h$(e, t) {
    P("TSTypeParameterDeclaration", e, t);
  }
  i(h$, "assertTSTypeParameterDeclaration");
  function m$(e, t) {
    P("TSTypeParameter", e, t);
  }
  i(m$, "assertTSTypeParameter");
  function y$(e, t) {
    P("Standardized", e, t);
  }
  i(y$, "assertStandardized");
  function b$(e, t) {
    P("Expression", e, t);
  }
  i(b$, "assertExpression");
  function g$(e, t) {
    P("Binary", e, t);
  }
  i(g$, "assertBinary");
  function T$(e, t) {
    P("Scopable", e, t);
  }
  i(T$, "assertScopable");
  function x$(e, t) {
    P("BlockParent", e, t);
  }
  i(x$, "assertBlockParent");
  function E$(e, t) {
    P("Block", e, t);
  }
  i(E$, "assertBlock");
  function S$(e, t) {
    P("Statement", e, t);
  }
  i(S$, "assertStatement");
  function v$(e, t) {
    P("Terminatorless", e, t);
  }
  i(v$, "assertTerminatorless");
  function P$(e, t) {
    P("CompletionStatement", e, t);
  }
  i(P$, "assertCompletionStatement");
  function A$(e, t) {
    P("Conditional", e, t);
  }
  i(A$, "assertConditional");
  function C$(e, t) {
    P("Loop", e, t);
  }
  i(C$, "assertLoop");
  function w$(e, t) {
    P("While", e, t);
  }
  i(w$, "assertWhile");
  function D$(e, t) {
    P("ExpressionWrapper", e, t);
  }
  i(D$, "assertExpressionWrapper");
  function _$(e, t) {
    P("For", e, t);
  }
  i(_$, "assertFor");
  function I$(e, t) {
    P("ForXStatement", e, t);
  }
  i(I$, "assertForXStatement");
  function O$(e, t) {
    P("Function", e, t);
  }
  i(O$, "assertFunction");
  function N$(e, t) {
    P("FunctionParent", e, t);
  }
  i(N$, "assertFunctionParent");
  function B$(e, t) {
    P("Pureish", e, t);
  }
  i(B$, "assertPureish");
  function k$(e, t) {
    P("Declaration", e, t);
  }
  i(k$, "assertDeclaration");
  function F$(e, t) {
    P("FunctionParameter", e, t);
  }
  i(F$, "assertFunctionParameter");
  function L$(e, t) {
    P("PatternLike", e, t);
  }
  i(L$, "assertPatternLike");
  function j$(e, t) {
    P("LVal", e, t);
  }
  i(j$, "assertLVal");
  function M$(e, t) {
    P("TSEntityName", e, t);
  }
  i(M$, "assertTSEntityName");
  function R$(e, t) {
    P("Literal", e, t);
  }
  i(R$, "assertLiteral");
  function q$(e, t) {
    P("Immutable", e, t);
  }
  i(q$, "assertImmutable");
  function U$(e, t) {
    P("UserWhitespacable", e, t);
  }
  i(U$, "assertUserWhitespacable");
  function $$(e, t) {
    P("Method", e, t);
  }
  i($$, "assertMethod");
  function V$(e, t) {
    P("ObjectMember", e, t);
  }
  i(V$, "assertObjectMember");
  function K$(e, t) {
    P("Property", e, t);
  }
  i(K$, "assertProperty");
  function W$(e, t) {
    P("UnaryLike", e, t);
  }
  i(W$, "assertUnaryLike");
  function Y$(e, t) {
    P("Pattern", e, t);
  }
  i(Y$, "assertPattern");
  function H$(e, t) {
    P("Class", e, t);
  }
  i(H$, "assertClass");
  function J$(e, t) {
    P("ImportOrExportDeclaration", e, t);
  }
  i(J$, "assertImportOrExportDeclaration");
  function G$(e, t) {
    P("ExportDeclaration", e, t);
  }
  i(G$, "assertExportDeclaration");
  function X$(e, t) {
    P("ModuleSpecifier", e, t);
  }
  i(X$, "assertModuleSpecifier");
  function z$(e, t) {
    P("Accessor", e, t);
  }
  i(z$, "assertAccessor");
  function Q$(e, t) {
    P("Private", e, t);
  }
  i(Q$, "assertPrivate");
  function Z$(e, t) {
    P("Flow", e, t);
  }
  i(Z$, "assertFlow");
  function eV(e, t) {
    P("FlowType", e, t);
  }
  i(eV, "assertFlowType");
  function tV(e, t) {
    P("FlowBaseAnnotation", e, t);
  }
  i(tV, "assertFlowBaseAnnotation");
  function rV(e, t) {
    P("FlowDeclaration", e, t);
  }
  i(rV, "assertFlowDeclaration");
  function sV(e, t) {
    P("FlowPredicate", e, t);
  }
  i(sV, "assertFlowPredicate");
  function nV(e, t) {
    P("EnumBody", e, t);
  }
  i(nV, "assertEnumBody");
  function iV(e, t) {
    P("EnumMember", e, t);
  }
  i(iV, "assertEnumMember");
  function aV(e, t) {
    P("JSX", e, t);
  }
  i(aV, "assertJSX");
  function oV(e, t) {
    P("Miscellaneous", e, t);
  }
  i(oV, "assertMiscellaneous");
  function lV(e, t) {
    P("TypeScript", e, t);
  }
  i(lV, "assertTypeScript");
  function uV(e, t) {
    P("TSTypeElement", e, t);
  }
  i(uV, "assertTSTypeElement");
  function cV(e, t) {
    P("TSType", e, t);
  }
  i(cV, "assertTSType");
  function pV(e, t) {
    P("TSBaseType", e, t);
  }
  i(pV, "assertTSBaseType");
  function fV(e, t) {
    (0, La.default)("assertNumberLiteral", "assertNumericLiteral"), P("NumberLiteral", e, t);
  }
  i(fV, "assertNumberLiteral");
  function dV(e, t) {
    (0, La.default)("assertRegexLiteral", "assertRegExpLiteral"), P("RegexLiteral", e, t);
  }
  i(dV, "assertRegexLiteral");
  function hV(e, t) {
    (0, La.default)("assertRestProperty", "assertRestElement"), P("RestProperty", e, t);
  }
  i(hV, "assertRestProperty");
  function mV(e, t) {
    (0, La.default)("assertSpreadProperty", "assertSpreadElement"), P("SpreadProperty", e, t);
  }
  i(mV, "assertSpreadProperty");
  function yV(e, t) {
    (0, La.default)("assertModuleDeclaration", "assertImportOrExportDeclaration"), P("ModuleDeclaration", e, t);
  }
  i(yV, "assertModuleDeclaration");
});

// ../node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var Jg = D((wl) => {
  "use strict";
  Object.defineProperty(wl, "__esModule", {
    value: !0
  });
  wl.default = void 0;
  var kr = Qt(), iAe = wl.default = bV;
  function bV(e) {
    switch (e) {
      case "string":
        return (0, kr.stringTypeAnnotation)();
      case "number":
        return (0, kr.numberTypeAnnotation)();
      case "undefined":
        return (0, kr.voidTypeAnnotation)();
      case "boolean":
        return (0, kr.booleanTypeAnnotation)();
      case "function":
        return (0, kr.genericTypeAnnotation)((0, kr.identifier)("Function"));
      case "object":
        return (0, kr.genericTypeAnnotation)((0, kr.identifier)("Object"));
      case "symbol":
        return (0, kr.genericTypeAnnotation)((0, kr.identifier)("Symbol"));
      case "bigint":
        return (0, kr.anyTypeAnnotation)();
    }
    throw new Error("Invalid typeof value: " + e);
  }
  i(bV, "createTypeAnnotationBasedOnTypeof");
});

// ../node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var Jf = D((Hf) => {
  "use strict";
  Object.defineProperty(Hf, "__esModule", {
    value: !0
  });
  Hf.default = Xg;
  var ja = ze();
  function Gg(e) {
    return (0, ja.isIdentifier)(e) ? e.name : `${e.id.name}.${Gg(e.qualification)}`;
  }
  i(Gg, "getQualifiedName");
  function Xg(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      if (l && !a.includes(l)) {
        if ((0, ja.isAnyTypeAnnotation)(l))
          return [l];
        if ((0, ja.isFlowBaseAnnotation)(l)) {
          s.set(l.type, l);
          continue;
        }
        if ((0, ja.isUnionTypeAnnotation)(l)) {
          n.has(l.types) || (t.push(...l.types), n.add(l.types));
          continue;
        }
        if ((0, ja.isGenericTypeAnnotation)(l)) {
          let u = Gg(l.id);
          if (r.has(u)) {
            let c = r.get(u);
            c.typeParameters ? l.typeParameters && (c.typeParameters.params.push(...l.typeParameters.params), c.typeParameters.params = Xg(c.
            typeParameters.params)) : c = l.typeParameters;
          } else
            r.set(u, l);
          continue;
        }
        a.push(l);
      }
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  i(Xg, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var zg = D((Gf) => {
  "use strict";
  Object.defineProperty(Gf, "__esModule", {
    value: !0
  });
  Gf.default = xV;
  var gV = Qt(), TV = Jf();
  function xV(e) {
    let t = (0, TV.default)(e);
    return t.length === 1 ? t[0] : (0, gV.unionTypeAnnotation)(t);
  }
  i(xV, "createFlowUnionType");
});

// ../node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var eT = D((Xf) => {
  "use strict";
  Object.defineProperty(Xf, "__esModule", {
    value: !0
  });
  Xf.default = Zg;
  var Pi = ze();
  function Qg(e) {
    return (0, Pi.isIdentifier)(e) ? e.name : (0, Pi.isThisExpression)(e) ? "this" : `${e.right.name}.${Qg(e.left)}`;
  }
  i(Qg, "getQualifiedName");
  function Zg(e) {
    let t = Array.from(e), r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), a = [];
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      if (!l || a.includes(l))
        continue;
      if ((0, Pi.isTSAnyKeyword)(l))
        return [l];
      if ((0, Pi.isTSBaseType)(l)) {
        s.set(l.type, l);
        continue;
      }
      if ((0, Pi.isTSUnionType)(l)) {
        n.has(l.types) || (t.push(...l.types), n.add(l.types));
        continue;
      }
      let u = "typeParameters";
      if ((0, Pi.isTSTypeReference)(l) && l[u]) {
        let c = l[u], p = Qg(l.typeName);
        if (r.has(p)) {
          let f = r.get(p), h = f[u];
          h ? (h.params.push(...c.params), h.params = Zg(h.params)) : f = c;
        } else
          r.set(p, l);
        continue;
      }
      a.push(l);
    }
    for (let [, o] of s)
      a.push(o);
    for (let [, o] of r)
      a.push(o);
    return a;
  }
  i(Zg, "removeTypeDuplicates");
});

// ../node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var tT = D((zf) => {
  "use strict";
  Object.defineProperty(zf, "__esModule", {
    value: !0
  });
  zf.default = PV;
  var EV = Qt(), SV = eT(), vV = ze();
  function PV(e) {
    let t = e.map((s) => (0, vV.isTSTypeAnnotation)(s) ? s.typeAnnotation : s), r = (0, SV.default)(t);
    return r.length === 1 ? r[0] : (0, EV.tsUnionType)(r);
  }
  i(PV, "createTSUnionType");
});

// ../node_modules/@babel/types/lib/builders/productions.js
var Zf = D((Qf) => {
  "use strict";
  Object.defineProperty(Qf, "__esModule", {
    value: !0
  });
  Qf.buildUndefinedNode = AV;
  var rT = Qt();
  function AV() {
    return (0, rT.unaryExpression)("void", (0, rT.numericLiteral)(0), !0);
  }
  i(AV, "buildUndefinedNode");
});

// ../node_modules/@babel/types/lib/clone/cloneNode.js
var Hs = D((td) => {
  "use strict";
  Object.defineProperty(td, "__esModule", {
    value: !0
  });
  td.default = CV;
  var sT = dr(), nT = ze(), {
    hasOwn: ts
  } = {
    hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
  };
  function iT(e, t, r, s) {
    return e && typeof e.type == "string" ? aT(e, t, r, s) : e;
  }
  i(iT, "cloneIfNode");
  function ed(e, t, r, s) {
    return Array.isArray(e) ? e.map((n) => iT(n, t, r, s)) : iT(e, t, r, s);
  }
  i(ed, "cloneIfNodeOrArray");
  function CV(e, t = !0, r = !1) {
    return aT(e, t, r, /* @__PURE__ */ new Map());
  }
  i(CV, "cloneNode");
  function aT(e, t = !0, r = !1, s) {
    if (!e) return e;
    let {
      type: n
    } = e, a = {
      type: e.type
    };
    if ((0, nT.isIdentifier)(e))
      a.name = e.name, ts(e, "optional") && typeof e.optional == "boolean" && (a.optional = e.optional), ts(e, "typeAnnotation") && (a.typeAnnotation =
      t ? ed(e.typeAnnotation, !0, r, s) : e.typeAnnotation), ts(e, "decorators") && (a.decorators = t ? ed(e.decorators, !0, r, s) : e.decorators);
    else if (ts(sT.NODE_FIELDS, n))
      for (let o of Object.keys(sT.NODE_FIELDS[n]))
        ts(e, o) && (t ? a[o] = (0, nT.isFile)(e) && o === "comments" ? Dl(e.comments, t, r, s) : ed(e[o], !0, r, s) : a[o] = e[o]);
    else
      throw new Error(`Unknown node type: "${n}"`);
    return ts(e, "loc") && (r ? a.loc = null : a.loc = e.loc), ts(e, "leadingComments") && (a.leadingComments = Dl(e.leadingComments, t, r, s)),
    ts(e, "innerComments") && (a.innerComments = Dl(e.innerComments, t, r, s)), ts(e, "trailingComments") && (a.trailingComments = Dl(e.trailingComments,
    t, r, s)), ts(e, "extra") && (a.extra = Object.assign({}, e.extra)), a;
  }
  i(aT, "cloneNodeInternal");
  function Dl(e, t, r, s) {
    return !e || !t ? e : e.map((n) => {
      let a = s.get(n);
      if (a) return a;
      let {
        type: o,
        value: l,
        loc: u
      } = n, c = {
        type: o,
        value: l,
        loc: u
      };
      return r && (c.loc = null), s.set(n, c), c;
    });
  }
  i(Dl, "maybeCloneComments");
});

// ../node_modules/@babel/types/lib/clone/clone.js
var oT = D((rd) => {
  "use strict";
  Object.defineProperty(rd, "__esModule", {
    value: !0
  });
  rd.default = DV;
  var wV = Hs();
  function DV(e) {
    return (0, wV.default)(e, !1);
  }
  i(DV, "clone");
});

// ../node_modules/@babel/types/lib/clone/cloneDeep.js
var lT = D((sd) => {
  "use strict";
  Object.defineProperty(sd, "__esModule", {
    value: !0
  });
  sd.default = IV;
  var _V = Hs();
  function IV(e) {
    return (0, _V.default)(e);
  }
  i(IV, "cloneDeep");
});

// ../node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var uT = D((nd) => {
  "use strict";
  Object.defineProperty(nd, "__esModule", {
    value: !0
  });
  nd.default = NV;
  var OV = Hs();
  function NV(e) {
    return (0, OV.default)(e, !0, !0);
  }
  i(NV, "cloneDeepWithoutLoc");
});

// ../node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var cT = D((id) => {
  "use strict";
  Object.defineProperty(id, "__esModule", {
    value: !0
  });
  id.default = kV;
  var BV = Hs();
  function kV(e) {
    return (0, BV.default)(e, !1, !0);
  }
  i(kV, "cloneWithoutLoc");
});

// ../node_modules/@babel/types/lib/comments/addComments.js
var od = D((ad) => {
  "use strict";
  Object.defineProperty(ad, "__esModule", {
    value: !0
  });
  ad.default = FV;
  function FV(e, t, r) {
    if (!r || !e) return e;
    let s = `${t}Comments`;
    return e[s] ? t === "leading" ? e[s] = r.concat(e[s]) : e[s].push(...r) : e[s] = r, e;
  }
  i(FV, "addComments");
});

// ../node_modules/@babel/types/lib/comments/addComment.js
var pT = D((ld) => {
  "use strict";
  Object.defineProperty(ld, "__esModule", {
    value: !0
  });
  ld.default = jV;
  var LV = od();
  function jV(e, t, r, s) {
    return (0, LV.default)(e, t, [{
      type: s ? "CommentLine" : "CommentBlock",
      value: r
    }]);
  }
  i(jV, "addComment");
});

// ../node_modules/@babel/types/lib/utils/inherit.js
var _l = D((ud) => {
  "use strict";
  Object.defineProperty(ud, "__esModule", {
    value: !0
  });
  ud.default = MV;
  function MV(e, t, r) {
    t && r && (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
  }
  i(MV, "inherit");
});

// ../node_modules/@babel/types/lib/comments/inheritInnerComments.js
var pd = D((cd) => {
  "use strict";
  Object.defineProperty(cd, "__esModule", {
    value: !0
  });
  cd.default = qV;
  var RV = _l();
  function qV(e, t) {
    (0, RV.default)("innerComments", e, t);
  }
  i(qV, "inheritInnerComments");
});

// ../node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var dd = D((fd) => {
  "use strict";
  Object.defineProperty(fd, "__esModule", {
    value: !0
  });
  fd.default = $V;
  var UV = _l();
  function $V(e, t) {
    (0, UV.default)("leadingComments", e, t);
  }
  i($V, "inheritLeadingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var md = D((hd) => {
  "use strict";
  Object.defineProperty(hd, "__esModule", {
    value: !0
  });
  hd.default = KV;
  var VV = _l();
  function KV(e, t) {
    (0, VV.default)("trailingComments", e, t);
  }
  i(KV, "inheritTrailingComments");
});

// ../node_modules/@babel/types/lib/comments/inheritsComments.js
var bd = D((yd) => {
  "use strict";
  Object.defineProperty(yd, "__esModule", {
    value: !0
  });
  yd.default = JV;
  var WV = md(), YV = dd(), HV = pd();
  function JV(e, t) {
    return (0, WV.default)(e, t), (0, YV.default)(e, t), (0, HV.default)(e, t), e;
  }
  i(JV, "inheritsComments");
});

// ../node_modules/@babel/types/lib/comments/removeComments.js
var fT = D((gd) => {
  "use strict";
  Object.defineProperty(gd, "__esModule", {
    value: !0
  });
  gd.default = XV;
  var GV = Ti();
  function XV(e) {
    return GV.COMMENT_KEYS.forEach((t) => {
      e[t] = null;
    }), e;
  }
  i(XV, "removeComments");
});

// ../node_modules/@babel/types/lib/constants/generated/index.js
var dT = D((V) => {
  "use strict";
  Object.defineProperty(V, "__esModule", {
    value: !0
  });
  V.WHILE_TYPES = V.USERWHITESPACABLE_TYPES = V.UNARYLIKE_TYPES = V.TYPESCRIPT_TYPES = V.TSTYPE_TYPES = V.TSTYPEELEMENT_TYPES = V.TSENTITYNAME_TYPES =
  V.TSBASETYPE_TYPES = V.TERMINATORLESS_TYPES = V.STATEMENT_TYPES = V.STANDARDIZED_TYPES = V.SCOPABLE_TYPES = V.PUREISH_TYPES = V.PROPERTY_TYPES =
  V.PRIVATE_TYPES = V.PATTERN_TYPES = V.PATTERNLIKE_TYPES = V.OBJECTMEMBER_TYPES = V.MODULESPECIFIER_TYPES = V.MODULEDECLARATION_TYPES = V.MISCELLANEOUS_TYPES =
  V.METHOD_TYPES = V.LVAL_TYPES = V.LOOP_TYPES = V.LITERAL_TYPES = V.JSX_TYPES = V.IMPORTOREXPORTDECLARATION_TYPES = V.IMMUTABLE_TYPES = V.FUNCTION_TYPES =
  V.FUNCTIONPARENT_TYPES = V.FUNCTIONPARAMETER_TYPES = V.FOR_TYPES = V.FORXSTATEMENT_TYPES = V.FLOW_TYPES = V.FLOWTYPE_TYPES = V.FLOWPREDICATE_TYPES =
  V.FLOWDECLARATION_TYPES = V.FLOWBASEANNOTATION_TYPES = V.EXPRESSION_TYPES = V.EXPRESSIONWRAPPER_TYPES = V.EXPORTDECLARATION_TYPES = V.ENUMMEMBER_TYPES =
  V.ENUMBODY_TYPES = V.DECLARATION_TYPES = V.CONDITIONAL_TYPES = V.COMPLETIONSTATEMENT_TYPES = V.CLASS_TYPES = V.BLOCK_TYPES = V.BLOCKPARENT_TYPES =
  V.BINARY_TYPES = V.ACCESSOR_TYPES = void 0;
  var fe = dr(), KAe = V.STANDARDIZED_TYPES = fe.FLIPPED_ALIAS_KEYS.Standardized, WAe = V.EXPRESSION_TYPES = fe.FLIPPED_ALIAS_KEYS.Expression,
  YAe = V.BINARY_TYPES = fe.FLIPPED_ALIAS_KEYS.Binary, HAe = V.SCOPABLE_TYPES = fe.FLIPPED_ALIAS_KEYS.Scopable, JAe = V.BLOCKPARENT_TYPES = fe.
  FLIPPED_ALIAS_KEYS.BlockParent, GAe = V.BLOCK_TYPES = fe.FLIPPED_ALIAS_KEYS.Block, XAe = V.STATEMENT_TYPES = fe.FLIPPED_ALIAS_KEYS.Statement,
  zAe = V.TERMINATORLESS_TYPES = fe.FLIPPED_ALIAS_KEYS.Terminatorless, QAe = V.COMPLETIONSTATEMENT_TYPES = fe.FLIPPED_ALIAS_KEYS.CompletionStatement,
  ZAe = V.CONDITIONAL_TYPES = fe.FLIPPED_ALIAS_KEYS.Conditional, e3e = V.LOOP_TYPES = fe.FLIPPED_ALIAS_KEYS.Loop, t3e = V.WHILE_TYPES = fe.FLIPPED_ALIAS_KEYS.
  While, r3e = V.EXPRESSIONWRAPPER_TYPES = fe.FLIPPED_ALIAS_KEYS.ExpressionWrapper, s3e = V.FOR_TYPES = fe.FLIPPED_ALIAS_KEYS.For, n3e = V.FORXSTATEMENT_TYPES =
  fe.FLIPPED_ALIAS_KEYS.ForXStatement, i3e = V.FUNCTION_TYPES = fe.FLIPPED_ALIAS_KEYS.Function, a3e = V.FUNCTIONPARENT_TYPES = fe.FLIPPED_ALIAS_KEYS.
  FunctionParent, o3e = V.PUREISH_TYPES = fe.FLIPPED_ALIAS_KEYS.Pureish, l3e = V.DECLARATION_TYPES = fe.FLIPPED_ALIAS_KEYS.Declaration, u3e = V.
  FUNCTIONPARAMETER_TYPES = fe.FLIPPED_ALIAS_KEYS.FunctionParameter, c3e = V.PATTERNLIKE_TYPES = fe.FLIPPED_ALIAS_KEYS.PatternLike, p3e = V.
  LVAL_TYPES = fe.FLIPPED_ALIAS_KEYS.LVal, f3e = V.TSENTITYNAME_TYPES = fe.FLIPPED_ALIAS_KEYS.TSEntityName, d3e = V.LITERAL_TYPES = fe.FLIPPED_ALIAS_KEYS.
  Literal, h3e = V.IMMUTABLE_TYPES = fe.FLIPPED_ALIAS_KEYS.Immutable, m3e = V.USERWHITESPACABLE_TYPES = fe.FLIPPED_ALIAS_KEYS.UserWhitespacable,
  y3e = V.METHOD_TYPES = fe.FLIPPED_ALIAS_KEYS.Method, b3e = V.OBJECTMEMBER_TYPES = fe.FLIPPED_ALIAS_KEYS.ObjectMember, g3e = V.PROPERTY_TYPES =
  fe.FLIPPED_ALIAS_KEYS.Property, T3e = V.UNARYLIKE_TYPES = fe.FLIPPED_ALIAS_KEYS.UnaryLike, x3e = V.PATTERN_TYPES = fe.FLIPPED_ALIAS_KEYS.Pattern,
  E3e = V.CLASS_TYPES = fe.FLIPPED_ALIAS_KEYS.Class, zV = V.IMPORTOREXPORTDECLARATION_TYPES = fe.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration,
  S3e = V.EXPORTDECLARATION_TYPES = fe.FLIPPED_ALIAS_KEYS.ExportDeclaration, v3e = V.MODULESPECIFIER_TYPES = fe.FLIPPED_ALIAS_KEYS.ModuleSpecifier,
  P3e = V.ACCESSOR_TYPES = fe.FLIPPED_ALIAS_KEYS.Accessor, A3e = V.PRIVATE_TYPES = fe.FLIPPED_ALIAS_KEYS.Private, C3e = V.FLOW_TYPES = fe.FLIPPED_ALIAS_KEYS.
  Flow, w3e = V.FLOWTYPE_TYPES = fe.FLIPPED_ALIAS_KEYS.FlowType, D3e = V.FLOWBASEANNOTATION_TYPES = fe.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation,
  _3e = V.FLOWDECLARATION_TYPES = fe.FLIPPED_ALIAS_KEYS.FlowDeclaration, I3e = V.FLOWPREDICATE_TYPES = fe.FLIPPED_ALIAS_KEYS.FlowPredicate, O3e = V.
  ENUMBODY_TYPES = fe.FLIPPED_ALIAS_KEYS.EnumBody, N3e = V.ENUMMEMBER_TYPES = fe.FLIPPED_ALIAS_KEYS.EnumMember, B3e = V.JSX_TYPES = fe.FLIPPED_ALIAS_KEYS.
  JSX, k3e = V.MISCELLANEOUS_TYPES = fe.FLIPPED_ALIAS_KEYS.Miscellaneous, F3e = V.TYPESCRIPT_TYPES = fe.FLIPPED_ALIAS_KEYS.TypeScript, L3e = V.
  TSTYPEELEMENT_TYPES = fe.FLIPPED_ALIAS_KEYS.TSTypeElement, j3e = V.TSTYPE_TYPES = fe.FLIPPED_ALIAS_KEYS.TSType, M3e = V.TSBASETYPE_TYPES =
  fe.FLIPPED_ALIAS_KEYS.TSBaseType, R3e = V.MODULEDECLARATION_TYPES = zV;
});

// ../node_modules/@babel/types/lib/converters/toBlock.js
var Ed = D((xd) => {
  "use strict";
  Object.defineProperty(xd, "__esModule", {
    value: !0
  });
  xd.default = QV;
  var Il = ze(), Td = Qt();
  function QV(e, t) {
    if ((0, Il.isBlockStatement)(e))
      return e;
    let r = [];
    return (0, Il.isEmptyStatement)(e) ? r = [] : ((0, Il.isStatement)(e) || ((0, Il.isFunction)(t) ? e = (0, Td.returnStatement)(e) : e = (0, Td.
    expressionStatement)(e)), r = [e]), (0, Td.blockStatement)(r);
  }
  i(QV, "toBlock");
});

// ../node_modules/@babel/types/lib/converters/ensureBlock.js
var hT = D((Sd) => {
  "use strict";
  Object.defineProperty(Sd, "__esModule", {
    value: !0
  });
  Sd.default = eK;
  var ZV = Ed();
  function eK(e, t = "body") {
    let r = (0, ZV.default)(e[t], e);
    return e[t] = r, r;
  }
  i(eK, "ensureBlock");
});

// ../node_modules/@babel/types/lib/converters/toIdentifier.js
var Pd = D((vd) => {
  "use strict";
  Object.defineProperty(vd, "__esModule", {
    value: !0
  });
  vd.default = sK;
  var tK = gi(), rK = bi();
  function sK(e) {
    e = e + "";
    let t = "";
    for (let r of e)
      t += (0, rK.isIdentifierChar)(r.codePointAt(0)) ? r : "-";
    return t = t.replace(/^[-0-9]+/, ""), t = t.replace(/[-\s]+(.)?/g, function(r, s) {
      return s ? s.toUpperCase() : "";
    }), (0, tK.default)(t) || (t = `_${t}`), t || "_";
  }
  i(sK, "toIdentifier");
});

// ../node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var mT = D((Ad) => {
  "use strict";
  Object.defineProperty(Ad, "__esModule", {
    value: !0
  });
  Ad.default = iK;
  var nK = Pd();
  function iK(e) {
    return e = (0, nK.default)(e), (e === "eval" || e === "arguments") && (e = "_" + e), e;
  }
  i(iK, "toBindingIdentifierName");
});

// ../node_modules/@babel/types/lib/converters/toComputedKey.js
var yT = D((Cd) => {
  "use strict";
  Object.defineProperty(Cd, "__esModule", {
    value: !0
  });
  Cd.default = lK;
  var aK = ze(), oK = Qt();
  function lK(e, t = e.key || e.property) {
    return !e.computed && (0, aK.isIdentifier)(t) && (t = (0, oK.stringLiteral)(t.name)), t;
  }
  i(lK, "toComputedKey");
});

// ../node_modules/@babel/types/lib/converters/toExpression.js
var bT = D((Ol) => {
  "use strict";
  Object.defineProperty(Ol, "__esModule", {
    value: !0
  });
  Ol.default = void 0;
  var Ma = ze(), z3e = Ol.default = uK;
  function uK(e) {
    if ((0, Ma.isExpressionStatement)(e) && (e = e.expression), (0, Ma.isExpression)(e))
      return e;
    if ((0, Ma.isClass)(e) ? (e.type = "ClassExpression", e.abstract = !1) : (0, Ma.isFunction)(e) && (e.type = "FunctionExpression"), !(0, Ma.
    isExpression)(e))
      throw new Error(`cannot turn ${e.type} to an expression`);
    return e;
  }
  i(uK, "toExpression");
});

// ../node_modules/@babel/types/lib/traverse/traverseFast.js
var Dd = D((wd) => {
  "use strict";
  Object.defineProperty(wd, "__esModule", {
    value: !0
  });
  wd.default = Ra;
  var cK = dr(), gT = Symbol(), TT = Symbol();
  function Ra(e, t, r) {
    if (!e) return !1;
    let s = cK.VISITOR_KEYS[e.type];
    if (!s) return !1;
    r = r || {};
    let n = t(e, r);
    if (n !== void 0)
      switch (n) {
        case gT:
          return !1;
        case TT:
          return !0;
      }
    for (let a of s) {
      let o = e[a];
      if (o) {
        if (Array.isArray(o)) {
          for (let l of o)
            if (Ra(l, t, r)) return !0;
        } else if (Ra(o, t, r)) return !0;
      }
    }
    return !1;
  }
  i(Ra, "traverseFast");
  Ra.skip = gT;
  Ra.stop = TT;
});

// ../node_modules/@babel/types/lib/modifications/removeProperties.js
var Id = D((_d) => {
  "use strict";
  Object.defineProperty(_d, "__esModule", {
    value: !0
  });
  _d.default = dK;
  var pK = Ti(), xT = ["tokens", "start", "end", "loc", "raw", "rawValue"], fK = [...pK.COMMENT_KEYS, "comments", ...xT];
  function dK(e, t = {}) {
    let r = t.preserveComments ? xT : fK;
    for (let n of r)
      e[n] != null && (e[n] = void 0);
    for (let n of Object.keys(e))
      n[0] === "_" && e[n] != null && (e[n] = void 0);
    let s = Object.getOwnPropertySymbols(e);
    for (let n of s)
      e[n] = null;
  }
  i(dK, "removeProperties");
});

// ../node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var Nd = D((Od) => {
  "use strict";
  Object.defineProperty(Od, "__esModule", {
    value: !0
  });
  Od.default = yK;
  var hK = Dd(), mK = Id();
  function yK(e, t) {
    return (0, hK.default)(e, mK.default, t), e;
  }
  i(yK, "removePropertiesDeep");
});

// ../node_modules/@babel/types/lib/converters/toKeyAlias.js
var ST = D((Bd) => {
  "use strict";
  Object.defineProperty(Bd, "__esModule", {
    value: !0
  });
  Bd.default = wn;
  var ET = ze(), bK = Hs(), gK = Nd();
  function wn(e, t = e.key) {
    let r;
    return e.kind === "method" ? wn.increment() + "" : ((0, ET.isIdentifier)(t) ? r = t.name : (0, ET.isStringLiteral)(t) ? r = JSON.stringify(
    t.value) : r = JSON.stringify((0, gK.default)((0, bK.default)(t))), e.computed && (r = `[${r}]`), e.static && (r = `static:${r}`), r);
  }
  i(wn, "toKeyAlias");
  wn.uid = 0;
  wn.increment = function() {
    return wn.uid >= Number.MAX_SAFE_INTEGER ? wn.uid = 0 : wn.uid++;
  };
});

// ../node_modules/@babel/types/lib/converters/toStatement.js
var vT = D((Bl) => {
  "use strict";
  Object.defineProperty(Bl, "__esModule", {
    value: !0
  });
  Bl.default = void 0;
  var Nl = ze(), TK = Qt(), lCe = Bl.default = xK;
  function xK(e, t) {
    if ((0, Nl.isStatement)(e))
      return e;
    let r = !1, s;
    if ((0, Nl.isClass)(e))
      r = !0, s = "ClassDeclaration";
    else if ((0, Nl.isFunction)(e))
      r = !0, s = "FunctionDeclaration";
    else if ((0, Nl.isAssignmentExpression)(e))
      return (0, TK.expressionStatement)(e);
    if (r && !e.id && (s = !1), !s) {
      if (t)
        return !1;
      throw new Error(`cannot turn ${e.type} to a statement`);
    }
    return e.type = s, e;
  }
  i(xK, "toStatement");
});

// ../node_modules/@babel/types/lib/converters/valueToNode.js
var PT = D((kl) => {
  "use strict";
  Object.defineProperty(kl, "__esModule", {
    value: !0
  });
  kl.default = void 0;
  var EK = gi(), ot = Qt(), pCe = kl.default = kd, SK = Function.call.bind(Object.prototype.toString);
  function vK(e) {
    return SK(e) === "[object RegExp]";
  }
  i(vK, "isRegExp");
  function PK(e) {
    if (typeof e != "object" || e === null || Object.prototype.toString.call(e) !== "[object Object]")
      return !1;
    let t = Object.getPrototypeOf(e);
    return t === null || Object.getPrototypeOf(t) === null;
  }
  i(PK, "isPlainObject");
  function kd(e) {
    if (e === void 0)
      return (0, ot.identifier)("undefined");
    if (e === !0 || e === !1)
      return (0, ot.booleanLiteral)(e);
    if (e === null)
      return (0, ot.nullLiteral)();
    if (typeof e == "string")
      return (0, ot.stringLiteral)(e);
    if (typeof e == "number") {
      let t;
      if (Number.isFinite(e))
        t = (0, ot.numericLiteral)(Math.abs(e));
      else {
        let r;
        Number.isNaN(e) ? r = (0, ot.numericLiteral)(0) : r = (0, ot.numericLiteral)(1), t = (0, ot.binaryExpression)("/", r, (0, ot.numericLiteral)(
        0));
      }
      return (e < 0 || Object.is(e, -0)) && (t = (0, ot.unaryExpression)("-", t)), t;
    }
    if (typeof e == "bigint")
      return e < 0 ? (0, ot.unaryExpression)("-", (0, ot.bigIntLiteral)(-e)) : (0, ot.bigIntLiteral)(e);
    if (vK(e)) {
      let t = e.source, r = /\/([a-z]*)$/.exec(e.toString())[1];
      return (0, ot.regExpLiteral)(t, r);
    }
    if (Array.isArray(e))
      return (0, ot.arrayExpression)(e.map(kd));
    if (PK(e)) {
      let t = [];
      for (let r of Object.keys(e)) {
        let s, n = !1;
        (0, EK.default)(r) ? r === "__proto__" ? (n = !0, s = (0, ot.stringLiteral)(r)) : s = (0, ot.identifier)(r) : s = (0, ot.stringLiteral)(
        r), t.push((0, ot.objectProperty)(s, kd(e[r]), n));
      }
      return (0, ot.objectExpression)(t);
    }
    throw new Error("don't know how to turn this value into a node");
  }
  i(kd, "valueToNode");
});

// ../node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var AT = D((Fd) => {
  "use strict";
  Object.defineProperty(Fd, "__esModule", {
    value: !0
  });
  Fd.default = CK;
  var AK = Qt();
  function CK(e, t, r = !1) {
    return e.object = (0, AK.memberExpression)(e.object, e.property, e.computed), e.property = t, e.computed = !!r, e;
  }
  i(CK, "appendToMemberExpression");
});

// ../node_modules/@babel/types/lib/modifications/inherits.js
var wT = D((Ld) => {
  "use strict";
  Object.defineProperty(Ld, "__esModule", {
    value: !0
  });
  Ld.default = DK;
  var CT = Ti(), wK = bd();
  function DK(e, t) {
    if (!e || !t) return e;
    for (let r of CT.INHERIT_KEYS.optional)
      e[r] == null && (e[r] = t[r]);
    for (let r of Object.keys(t))
      r[0] === "_" && r !== "__clone" && (e[r] = t[r]);
    for (let r of CT.INHERIT_KEYS.force)
      e[r] = t[r];
    return (0, wK.default)(e, t), e;
  }
  i(DK, "inherits");
});

// ../node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var DT = D((jd) => {
  "use strict";
  Object.defineProperty(jd, "__esModule", {
    value: !0
  });
  jd.default = OK;
  var _K = Qt(), IK = ce();
  function OK(e, t) {
    if ((0, IK.isSuper)(e.object))
      throw new Error("Cannot prepend node to super property access (`super.foo`).");
    return e.object = (0, _K.memberExpression)(t, e.object), e;
  }
  i(OK, "prependToMemberExpression");
});

// ../node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var _T = D((Md) => {
  "use strict";
  Object.defineProperty(Md, "__esModule", {
    value: !0
  });
  Md.default = NK;
  function NK(e) {
    let t = [].concat(e), r = /* @__PURE__ */ Object.create(null);
    for (; t.length; ) {
      let s = t.pop();
      if (s)
        switch (s.type) {
          case "ArrayPattern":
            t.push(...s.elements);
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            t.push(s.left);
            break;
          case "ObjectPattern":
            t.push(...s.properties);
            break;
          case "ObjectProperty":
            t.push(s.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            t.push(s.argument);
            break;
          case "UnaryExpression":
            s.operator === "delete" && t.push(s.argument);
            break;
          case "Identifier":
            r[s.name] = s;
            break;
          default:
            break;
        }
    }
    return r;
  }
  i(NK, "getAssignmentIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var qa = D((qd) => {
  "use strict";
  Object.defineProperty(qd, "__esModule", {
    value: !0
  });
  qd.default = Rd;
  var ys = ze();
  function Rd(e, t, r, s) {
    let n = [].concat(e), a = /* @__PURE__ */ Object.create(null);
    for (; n.length; ) {
      let o = n.shift();
      if (!o || s && ((0, ys.isAssignmentExpression)(o) || (0, ys.isUnaryExpression)(o) || (0, ys.isUpdateExpression)(o)))
        continue;
      if ((0, ys.isIdentifier)(o)) {
        t ? (a[o.name] = a[o.name] || []).push(o) : a[o.name] = o;
        continue;
      }
      if ((0, ys.isExportDeclaration)(o) && !(0, ys.isExportAllDeclaration)(o)) {
        (0, ys.isDeclaration)(o.declaration) && n.push(o.declaration);
        continue;
      }
      if (r) {
        if ((0, ys.isFunctionDeclaration)(o)) {
          n.push(o.id);
          continue;
        }
        if ((0, ys.isFunctionExpression)(o))
          continue;
      }
      let l = Rd.keys[o.type];
      if (l)
        for (let u = 0; u < l.length; u++) {
          let c = l[u], p = o[c];
          p && (Array.isArray(p) ? n.push(...p) : n.push(p));
        }
    }
    return a;
  }
  i(Rd, "getBindingIdentifiers");
  var BK = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    TSImportEqualsDeclaration: ["id"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ClassPrivateMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };
  Rd.keys = BK;
});

// ../node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var IT = D((Fl) => {
  "use strict";
  Object.defineProperty(Fl, "__esModule", {
    value: !0
  });
  Fl.default = void 0;
  var kK = qa(), PCe = Fl.default = FK;
  function FK(e, t) {
    return (0, kK.default)(e, t, !0);
  }
  i(FK, "getOuterBindingIdentifiers");
});

// ../node_modules/@babel/types/lib/retrievers/getFunctionName.js
var NT = D((Ud) => {
  "use strict";
  Object.defineProperty(Ud, "__esModule", {
    value: !0
  });
  Ud.default = jK;
  var hr = ze();
  function LK(e) {
    return (0, hr.isNullLiteral)(e) ? "null" : (0, hr.isRegExpLiteral)(e) ? `/${e.pattern}/${e.flags}` : (0, hr.isTemplateLiteral)(e) ? e.quasis.
    map((t) => t.value.raw).join("") : e.value !== void 0 ? String(e.value) : null;
  }
  i(LK, "getNameFromLiteralId");
  function OT(e) {
    if (!e.computed || (0, hr.isLiteral)(e.key))
      return e.key;
  }
  i(OT, "getObjectMemberKey");
  function jK(e, t) {
    if ("id" in e && e.id)
      return {
        name: e.id.name,
        originalNode: e.id
      };
    let r = "", s;
    if ((0, hr.isObjectProperty)(t, {
      value: e
    }) ? s = OT(t) : (0, hr.isObjectMethod)(e) || (0, hr.isClassMethod)(e) ? (s = OT(e), e.kind === "get" ? r = "get " : e.kind === "set" &&
    (r = "set ")) : (0, hr.isVariableDeclarator)(t, {
      init: e
    }) ? s = t.id : (0, hr.isAssignmentExpression)(t, {
      operator: "=",
      right: e
    }) && (s = t.left), !s) return null;
    let n = (0, hr.isLiteral)(s) ? LK(s) : (0, hr.isIdentifier)(s) ? s.name : (0, hr.isPrivateName)(s) ? s.id.name : null;
    return n == null ? null : {
      name: r + n,
      originalNode: s
    };
  }
  i(jK, "getFunctionName");
});

// ../node_modules/@babel/types/lib/traverse/traverse.js
var BT = D((Vd) => {
  "use strict";
  Object.defineProperty(Vd, "__esModule", {
    value: !0
  });
  Vd.default = RK;
  var MK = dr();
  function RK(e, t, r) {
    typeof t == "function" && (t = {
      enter: t
    });
    let {
      enter: s,
      exit: n
    } = t;
    $d(e, s, n, r, []);
  }
  i(RK, "traverse");
  function $d(e, t, r, s, n) {
    let a = MK.VISITOR_KEYS[e.type];
    if (a) {
      t && t(e, n, s);
      for (let o of a) {
        let l = e[o];
        if (Array.isArray(l))
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c && (n.push({
              node: e,
              key: o,
              index: u
            }), $d(c, t, r, s, n), n.pop());
          }
        else l && (n.push({
          node: e,
          key: o
        }), $d(l, t, r, s, n), n.pop());
      }
      r && r(e, n, s);
    }
  }
  i($d, "traverseSimpleImpl");
});

// ../node_modules/@babel/types/lib/validators/isBinding.js
var kT = D((Kd) => {
  "use strict";
  Object.defineProperty(Kd, "__esModule", {
    value: !0
  });
  Kd.default = UK;
  var qK = qa();
  function UK(e, t, r) {
    if (r && e.type === "Identifier" && t.type === "ObjectProperty" && r.type === "ObjectExpression")
      return !1;
    let s = qK.default.keys[t.type];
    if (s)
      for (let n = 0; n < s.length; n++) {
        let a = s[n], o = t[a];
        if (Array.isArray(o)) {
          if (o.includes(e)) return !0;
        } else if (o === e) return !0;
      }
    return !1;
  }
  i(UK, "isBinding");
});

// ../node_modules/@babel/types/lib/validators/isLet.js
var Yd = D((Wd) => {
  "use strict";
  Object.defineProperty(Wd, "__esModule", {
    value: !0
  });
  Wd.default = VK;
  var $K = ze();
  FT = Symbol.for("var used to be block scoped");
  var FT;
  function VK(e) {
    return (0, $K.isVariableDeclaration)(e) && (e.kind !== "var" || e[FT]);
  }
  i(VK, "isLet");
});

// ../node_modules/@babel/types/lib/validators/isBlockScoped.js
var jT = D((Hd) => {
  "use strict";
  Object.defineProperty(Hd, "__esModule", {
    value: !0
  });
  Hd.default = WK;
  var LT = ze(), KK = Yd();
  function WK(e) {
    return (0, LT.isFunctionDeclaration)(e) || (0, LT.isClassDeclaration)(e) || (0, KK.default)(e);
  }
  i(WK, "isBlockScoped");
});

// ../node_modules/@babel/types/lib/validators/isImmutable.js
var MT = D((Jd) => {
  "use strict";
  Object.defineProperty(Jd, "__esModule", {
    value: !0
  });
  Jd.default = JK;
  var YK = bl(), HK = ze();
  function JK(e) {
    return (0, YK.default)(e.type, "Immutable") ? !0 : (0, HK.isIdentifier)(e) ? e.name === "undefined" : !1;
  }
  i(JK, "isImmutable");
});

// ../node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var qT = D((Xd) => {
  "use strict";
  Object.defineProperty(Xd, "__esModule", {
    value: !0
  });
  Xd.default = Gd;
  var RT = dr();
  function Gd(e, t) {
    if (typeof e != "object" || typeof t != "object" || e == null || t == null)
      return e === t;
    if (e.type !== t.type)
      return !1;
    let r = Object.keys(RT.NODE_FIELDS[e.type] || e.type), s = RT.VISITOR_KEYS[e.type];
    for (let n of r) {
      let a = e[n], o = t[n];
      if (typeof a != typeof o)
        return !1;
      if (!(a == null && o == null)) {
        if (a == null || o == null)
          return !1;
        if (Array.isArray(a)) {
          if (!Array.isArray(o) || a.length !== o.length)
            return !1;
          for (let l = 0; l < a.length; l++)
            if (!Gd(a[l], o[l]))
              return !1;
          continue;
        }
        if (typeof a == "object" && !(s != null && s.includes(n))) {
          for (let l of Object.keys(a))
            if (a[l] !== o[l])
              return !1;
          continue;
        }
        if (!Gd(a, o))
          return !1;
      }
    }
    return !0;
  }
  i(Gd, "isNodesEquivalent");
});

// ../node_modules/@babel/types/lib/validators/isReferenced.js
var UT = D((zd) => {
  "use strict";
  Object.defineProperty(zd, "__esModule", {
    value: !0
  });
  zd.default = GK;
  function GK(e, t, r) {
    switch (t.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return t.property === e ? !!t.computed : t.object === e;
      case "JSXMemberExpression":
        return t.object === e;
      case "VariableDeclarator":
        return t.init === e;
      case "ArrowFunctionExpression":
        return t.body === e;
      case "PrivateName":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return t.key === e ? !!t.computed : !1;
      case "ObjectProperty":
        return t.key === e ? !!t.computed : !r || r.type !== "ObjectPattern";
      case "ClassProperty":
      case "ClassAccessorProperty":
        return t.key === e ? !!t.computed : !0;
      case "ClassPrivateProperty":
        return t.key !== e;
      case "ClassDeclaration":
      case "ClassExpression":
        return t.superClass === e;
      case "AssignmentExpression":
        return t.right === e;
      case "AssignmentPattern":
        return t.right === e;
      case "LabeledStatement":
        return !1;
      case "CatchClause":
        return !1;
      case "RestElement":
        return !1;
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      case "FunctionDeclaration":
      case "FunctionExpression":
        return !1;
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return !1;
      case "ExportSpecifier":
        return r != null && r.source ? !1 : t.local === e;
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return !1;
      case "ImportAttribute":
        return !1;
      case "JSXAttribute":
        return !1;
      case "ObjectPattern":
      case "ArrayPattern":
        return !1;
      case "MetaProperty":
        return !1;
      case "ObjectTypeProperty":
        return t.key !== e;
      case "TSEnumMember":
        return t.id !== e;
      case "TSPropertySignature":
        return t.key === e ? !!t.computed : !0;
    }
    return !0;
  }
  i(GK, "isReferenced");
});

// ../node_modules/@babel/types/lib/validators/isScope.js
var $T = D((Qd) => {
  "use strict";
  Object.defineProperty(Qd, "__esModule", {
    value: !0
  });
  Qd.default = XK;
  var Dn = ze();
  function XK(e, t) {
    return (0, Dn.isBlockStatement)(e) && ((0, Dn.isFunction)(t) || (0, Dn.isCatchClause)(t)) ? !1 : (0, Dn.isPattern)(e) && ((0, Dn.isFunction)(
    t) || (0, Dn.isCatchClause)(t)) ? !0 : (0, Dn.isScopable)(e);
  }
  i(XK, "isScope");
});

// ../node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var KT = D((Zd) => {
  "use strict";
  Object.defineProperty(Zd, "__esModule", {
    value: !0
  });
  Zd.default = zK;
  var VT = ze();
  function zK(e) {
    return (0, VT.isImportDefaultSpecifier)(e) || (0, VT.isIdentifier)(e.imported || e.exported, {
      name: "default"
    });
  }
  i(zK, "isSpecifierDefault");
});

// ../node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var WT = D((e0) => {
  "use strict";
  Object.defineProperty(e0, "__esModule", {
    value: !0
  });
  e0.default = eW;
  var QK = gi(), ZK = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implement\
s", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transie\
nt", "volatile"]);
  function eW(e) {
    return (0, QK.default)(e) && !ZK.has(e);
  }
  i(eW, "isValidES3Identifier");
});

// ../node_modules/@babel/types/lib/validators/isVar.js
var HT = D((t0) => {
  "use strict";
  Object.defineProperty(t0, "__esModule", {
    value: !0
  });
  t0.default = rW;
  var tW = ze();
  YT = Symbol.for("var used to be block scoped");
  var YT;
  function rW(e) {
    return (0, tW.isVariableDeclaration)(e, {
      kind: "var"
    }) && !e[YT];
  }
  i(rW, "isVar");
});

// ../node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var JT = D((n0) => {
  "use strict";
  Object.defineProperty(n0, "__esModule", {
    value: !0
  });
  n0.default = Ll;
  var sW = qa(), _n = ze(), r0 = Qt(), s0 = Zf(), nW = Hs();
  function Ll(e, t) {
    let r = [], s = !0;
    for (let n of e)
      if ((0, _n.isEmptyStatement)(n) || (s = !1), (0, _n.isExpression)(n))
        r.push(n);
      else if ((0, _n.isExpressionStatement)(n))
        r.push(n.expression);
      else if ((0, _n.isVariableDeclaration)(n)) {
        if (n.kind !== "var") return;
        for (let a of n.declarations) {
          let o = (0, sW.default)(a);
          for (let l of Object.keys(o))
            t.push({
              kind: n.kind,
              id: (0, nW.default)(o[l])
            });
          a.init && r.push((0, r0.assignmentExpression)("=", a.id, a.init));
        }
        s = !0;
      } else if ((0, _n.isIfStatement)(n)) {
        let a = n.consequent ? Ll([n.consequent], t) : (0, s0.buildUndefinedNode)(), o = n.alternate ? Ll([n.alternate], t) : (0, s0.buildUndefinedNode)();
        if (!a || !o) return;
        r.push((0, r0.conditionalExpression)(n.test, a, o));
      } else if ((0, _n.isBlockStatement)(n)) {
        let a = Ll(n.body, t);
        if (!a) return;
        r.push(a);
      } else if ((0, _n.isEmptyStatement)(n))
        e.indexOf(n) === 0 && (s = !0);
      else
        return;
    return s && r.push((0, s0.buildUndefinedNode)()), r.length === 1 ? r[0] : (0, r0.sequenceExpression)(r);
  }
  i(Ll, "gatherSequenceExpressions");
});

// ../node_modules/@babel/types/lib/converters/toSequenceExpression.js
var GT = D((i0) => {
  "use strict";
  Object.defineProperty(i0, "__esModule", {
    value: !0
  });
  i0.default = aW;
  var iW = JT();
  function aW(e, t) {
    if (!(e != null && e.length)) return;
    let r = [], s = (0, iW.default)(e, r);
    if (s) {
      for (let n of r)
        t.push(n);
      return s;
    }
  }
  i(aW, "toSequenceExpression");
});

// ../node_modules/@babel/types/lib/index.js
var ce = D((Y) => {
  "use strict";
  Object.defineProperty(Y, "__esModule", {
    value: !0
  });
  var Js = {
    react: !0,
    assertNode: !0,
    createTypeAnnotationBasedOnTypeof: !0,
    createUnionTypeAnnotation: !0,
    createFlowUnionType: !0,
    createTSUnionType: !0,
    cloneNode: !0,
    clone: !0,
    cloneDeep: !0,
    cloneDeepWithoutLoc: !0,
    cloneWithoutLoc: !0,
    addComment: !0,
    addComments: !0,
    inheritInnerComments: !0,
    inheritLeadingComments: !0,
    inheritsComments: !0,
    inheritTrailingComments: !0,
    removeComments: !0,
    ensureBlock: !0,
    toBindingIdentifierName: !0,
    toBlock: !0,
    toComputedKey: !0,
    toExpression: !0,
    toIdentifier: !0,
    toKeyAlias: !0,
    toStatement: !0,
    valueToNode: !0,
    appendToMemberExpression: !0,
    inherits: !0,
    prependToMemberExpression: !0,
    removeProperties: !0,
    removePropertiesDeep: !0,
    removeTypeDuplicates: !0,
    getAssignmentIdentifiers: !0,
    getBindingIdentifiers: !0,
    getOuterBindingIdentifiers: !0,
    getFunctionName: !0,
    traverse: !0,
    traverseFast: !0,
    shallowEqual: !0,
    is: !0,
    isBinding: !0,
    isBlockScoped: !0,
    isImmutable: !0,
    isLet: !0,
    isNode: !0,
    isNodesEquivalent: !0,
    isPlaceholderType: !0,
    isReferenced: !0,
    isScope: !0,
    isSpecifierDefault: !0,
    isType: !0,
    isValidES3Identifier: !0,
    isValidIdentifier: !0,
    isVar: !0,
    matchesPattern: !0,
    validate: !0,
    buildMatchMemberExpression: !0,
    __internal__deprecationWarning: !0
  };
  Object.defineProperty(Y, "__internal__deprecationWarning", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return cY.default;
    }, "get")
  });
  Object.defineProperty(Y, "addComment", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return gW.default;
    }, "get")
  });
  Object.defineProperty(Y, "addComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return TW.default;
    }, "get")
  });
  Object.defineProperty(Y, "appendToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return kW.default;
    }, "get")
  });
  Object.defineProperty(Y, "assertNode", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return cW.default;
    }, "get")
  });
  Object.defineProperty(Y, "buildMatchMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return uY.default;
    }, "get")
  });
  Object.defineProperty(Y, "clone", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return hW.default;
    }, "get")
  });
  Object.defineProperty(Y, "cloneDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return mW.default;
    }, "get")
  });
  Object.defineProperty(Y, "cloneDeepWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return yW.default;
    }, "get")
  });
  Object.defineProperty(Y, "cloneNode", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return dW.default;
    }, "get")
  });
  Object.defineProperty(Y, "cloneWithoutLoc", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return bW.default;
    }, "get")
  });
  Object.defineProperty(Y, "createFlowUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return XT.default;
    }, "get")
  });
  Object.defineProperty(Y, "createTSUnionType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fW.default;
    }, "get")
  });
  Object.defineProperty(Y, "createTypeAnnotationBasedOnTypeof", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return pW.default;
    }, "get")
  });
  Object.defineProperty(Y, "createUnionTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return XT.default;
    }, "get")
  });
  Object.defineProperty(Y, "ensureBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return AW.default;
    }, "get")
  });
  Object.defineProperty(Y, "getAssignmentIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return qW.default;
    }, "get")
  });
  Object.defineProperty(Y, "getBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return UW.default;
    }, "get")
  });
  Object.defineProperty(Y, "getFunctionName", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return VW.default;
    }, "get")
  });
  Object.defineProperty(Y, "getOuterBindingIdentifiers", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return $W.default;
    }, "get")
  });
  Object.defineProperty(Y, "inheritInnerComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return xW.default;
    }, "get")
  });
  Object.defineProperty(Y, "inheritLeadingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return EW.default;
    }, "get")
  });
  Object.defineProperty(Y, "inheritTrailingComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return vW.default;
    }, "get")
  });
  Object.defineProperty(Y, "inherits", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return FW.default;
    }, "get")
  });
  Object.defineProperty(Y, "inheritsComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return SW.default;
    }, "get")
  });
  Object.defineProperty(Y, "is", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return YW.default;
    }, "get")
  });
  Object.defineProperty(Y, "isBinding", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return HW.default;
    }, "get")
  });
  Object.defineProperty(Y, "isBlockScoped", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return JW.default;
    }, "get")
  });
  Object.defineProperty(Y, "isImmutable", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return GW.default;
    }, "get")
  });
  Object.defineProperty(Y, "isLet", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return XW.default;
    }, "get")
  });
  Object.defineProperty(Y, "isNode", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return zW.default;
    }, "get")
  });
  Object.defineProperty(Y, "isNodesEquivalent", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return QW.default;
    }, "get")
  });
  Object.defineProperty(Y, "isPlaceholderType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return ZW.default;
    }, "get")
  });
  Object.defineProperty(Y, "isReferenced", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return eY.default;
    }, "get")
  });
  Object.defineProperty(Y, "isScope", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return tY.default;
    }, "get")
  });
  Object.defineProperty(Y, "isSpecifierDefault", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return rY.default;
    }, "get")
  });
  Object.defineProperty(Y, "isType", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return sY.default;
    }, "get")
  });
  Object.defineProperty(Y, "isValidES3Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return nY.default;
    }, "get")
  });
  Object.defineProperty(Y, "isValidIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return iY.default;
    }, "get")
  });
  Object.defineProperty(Y, "isVar", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return aY.default;
    }, "get")
  });
  Object.defineProperty(Y, "matchesPattern", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return oY.default;
    }, "get")
  });
  Object.defineProperty(Y, "prependToMemberExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return LW.default;
    }, "get")
  });
  Y.react = void 0;
  Object.defineProperty(Y, "removeComments", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return PW.default;
    }, "get")
  });
  Object.defineProperty(Y, "removeProperties", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return jW.default;
    }, "get")
  });
  Object.defineProperty(Y, "removePropertiesDeep", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return MW.default;
    }, "get")
  });
  Object.defineProperty(Y, "removeTypeDuplicates", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return RW.default;
    }, "get")
  });
  Object.defineProperty(Y, "shallowEqual", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return WW.default;
    }, "get")
  });
  Object.defineProperty(Y, "toBindingIdentifierName", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return CW.default;
    }, "get")
  });
  Object.defineProperty(Y, "toBlock", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return wW.default;
    }, "get")
  });
  Object.defineProperty(Y, "toComputedKey", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return DW.default;
    }, "get")
  });
  Object.defineProperty(Y, "toExpression", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return _W.default;
    }, "get")
  });
  Object.defineProperty(Y, "toIdentifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return IW.default;
    }, "get")
  });
  Object.defineProperty(Y, "toKeyAlias", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return OW.default;
    }, "get")
  });
  Object.defineProperty(Y, "toStatement", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return NW.default;
    }, "get")
  });
  Object.defineProperty(Y, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return jl.default;
    }, "get")
  });
  Object.defineProperty(Y, "traverseFast", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return KW.default;
    }, "get")
  });
  Object.defineProperty(Y, "validate", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return lY.default;
    }, "get")
  });
  Object.defineProperty(Y, "valueToNode", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return BW.default;
    }, "get")
  });
  var oW = Zb(), lW = eg(), uW = Wg(), cW = Yg(), a0 = Hg();
  Object.keys(a0).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Js, e) || e in Y && Y[e] === a0[e] || Object.defineProperty(
    Y, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return a0[e];
      }, "get")
    });
  });
  var pW = Jg(), XT = zg(), fW = tT(), o0 = Zf();
  Object.keys(o0).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Js, e) || e in Y && Y[e] === o0[e] || Object.defineProperty(
    Y, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return o0[e];
      }, "get")
    });
  });
  var l0 = Qt();
  Object.keys(l0).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Js, e) || e in Y && Y[e] === l0[e] || Object.defineProperty(
    Y, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return l0[e];
      }, "get")
    });
  });
  var dW = Hs(), hW = oT(), mW = lT(), yW = uT(), bW = cT(), gW = pT(), TW = od(), xW = pd(), EW = dd(), SW = bd(), vW = md(), PW = fT(), u0 = dT();
  Object.keys(u0).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Js, e) || e in Y && Y[e] === u0[e] || Object.defineProperty(
    Y, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return u0[e];
      }, "get")
    });
  });
  var c0 = Ti();
  Object.keys(c0).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Js, e) || e in Y && Y[e] === c0[e] || Object.defineProperty(
    Y, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return c0[e];
      }, "get")
    });
  });
  var AW = hT(), CW = mT(), wW = Ed(), DW = yT(), _W = bT(), IW = Pd(), OW = ST(), NW = vT(), BW = PT(), p0 = dr();
  Object.keys(p0).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Js, e) || e in Y && Y[e] === p0[e] || Object.defineProperty(
    Y, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return p0[e];
      }, "get")
    });
  });
  var kW = AT(), FW = wT(), LW = DT(), jW = Id(), MW = Nd(), RW = Jf(), qW = _T(), UW = qa(), $W = IT(), VW = NT(), jl = BT();
  Object.keys(jl).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Js, e) || e in Y && Y[e] === jl[e] || Object.defineProperty(
    Y, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return jl[e];
      }, "get")
    });
  });
  var KW = Dd(), WW = ml(), YW = yi(), HW = kT(), JW = jT(), GW = MT(), XW = Yd(), zW = Wf(), QW = qT(), ZW = mf(), eY = UT(), tY = $T(), rY = KT(),
  sY = bl(), nY = WT(), iY = gi(), aY = HT(), oY = uf(), lY = El(), uY = pf(), f0 = ze();
  Object.keys(f0).forEach(function(e) {
    e === "default" || e === "__esModule" || Object.prototype.hasOwnProperty.call(Js, e) || e in Y && Y[e] === f0[e] || Object.defineProperty(
    Y, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return f0[e];
      }, "get")
    });
  });
  var cY = mi(), pY = GT(), t4e = Y.react = {
    isReactComponent: oW.default,
    isCompatTag: lW.default,
    buildChildren: uW.default
  };
  Y.toSequenceExpression = pY.default;
  process.env.BABEL_TYPES_8_BREAKING && console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-releas\
e instead!");
});

// ../node_modules/@babel/template/lib/formatters.js
var zT = D((mr) => {
  "use strict";
  Object.defineProperty(mr, "__esModule", {
    value: !0
  });
  mr.statements = mr.statement = mr.smart = mr.program = mr.expression = void 0;
  var fY = ce(), {
    assertExpressionStatement: dY
  } = fY;
  function d0(e) {
    return {
      code: /* @__PURE__ */ i((t) => `/* @babel/template */;
${t}`, "code"),
      validate: /* @__PURE__ */ i(() => {
      }, "validate"),
      unwrap: /* @__PURE__ */ i((t) => e(t.program.body.slice(1)), "unwrap")
    };
  }
  i(d0, "makeStatementFormatter");
  var n4e = mr.smart = d0((e) => e.length > 1 ? e : e[0]), i4e = mr.statements = d0((e) => e), a4e = mr.statement = d0((e) => {
    if (e.length === 0)
      throw new Error("Found nothing to return.");
    if (e.length > 1)
      throw new Error("Found multiple statements but wanted one");
    return e[0];
  }), hY = mr.expression = {
    code: /* @__PURE__ */ i((e) => `(
${e}
)`, "code"),
    validate: /* @__PURE__ */ i((e) => {
      if (e.program.body.length > 1)
        throw new Error("Found multiple statements but wanted one");
      if (hY.unwrap(e).start === 0)
        throw new Error("Parse result included parens.");
    }, "validate"),
    unwrap: /* @__PURE__ */ i(({
      program: e
    }) => {
      let [t] = e.body;
      return dY(t), t.expression;
    }, "unwrap")
  }, o4e = mr.program = {
    code: /* @__PURE__ */ i((e) => e, "code"),
    validate: /* @__PURE__ */ i(() => {
    }, "validate"),
    unwrap: /* @__PURE__ */ i((e) => e.program, "unwrap")
  };
});

// ../node_modules/@babel/template/lib/options.js
var Ml = D((Ua) => {
  "use strict";
  Object.defineProperty(Ua, "__esModule", {
    value: !0
  });
  Ua.merge = bY;
  Ua.normalizeReplacements = TY;
  Ua.validate = gY;
  var mY = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function yY(e, t) {
    if (e == null) return {};
    var r = {};
    for (var s in e) if ({}.hasOwnProperty.call(e, s)) {
      if (t.indexOf(s) !== -1) continue;
      r[s] = e[s];
    }
    return r;
  }
  i(yY, "_objectWithoutPropertiesLoose");
  function bY(e, t) {
    let {
      placeholderWhitelist: r = e.placeholderWhitelist,
      placeholderPattern: s = e.placeholderPattern,
      preserveComments: n = e.preserveComments,
      syntacticPlaceholders: a = e.syntacticPlaceholders
    } = t;
    return {
      parser: Object.assign({}, e.parser, t.parser),
      placeholderWhitelist: r,
      placeholderPattern: s,
      preserveComments: n,
      syntacticPlaceholders: a
    };
  }
  i(bY, "merge");
  function gY(e) {
    if (e != null && typeof e != "object")
      throw new Error("Unknown template options.");
    let t = e || {}, {
      placeholderWhitelist: r,
      placeholderPattern: s,
      preserveComments: n,
      syntacticPlaceholders: a
    } = t, o = yY(t, mY);
    if (r != null && !(r instanceof Set))
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    if (s != null && !(s instanceof RegExp) && s !== !1)
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    if (n != null && typeof n != "boolean")
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    if (a != null && typeof a != "boolean")
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    if (a === !0 && (r != null || s != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    return {
      parser: o,
      placeholderWhitelist: r || void 0,
      placeholderPattern: s ?? void 0,
      preserveComments: n ?? void 0,
      syntacticPlaceholders: a ?? void 0
    };
  }
  i(gY, "validate");
  function TY(e) {
    if (Array.isArray(e))
      return e.reduce((t, r, s) => (t["$" + s] = r, t), {});
    if (typeof e == "object" || e == null)
      return e || void 0;
    throw new Error("Template replacements must be an array, object, null, or undefined");
  }
  i(TY, "normalizeReplacements");
});

// ../node_modules/@babel/parser/lib/index.js
var Bn = D((za) => {
  "use strict";
  Object.defineProperty(za, "__esModule", {
    value: !0
  });
  function xY(e, t) {
    if (e == null) return {};
    var r = {};
    for (var s in e) if ({}.hasOwnProperty.call(e, s)) {
      if (t.indexOf(s) !== -1) continue;
      r[s] = e[s];
    }
    return r;
  }
  i(xY, "_objectWithoutPropertiesLoose");
  var is = class {
    static {
      i(this, "Position");
    }
    constructor(t, r, s) {
      this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = r, this.index = s;
    }
  }, Di = class {
    static {
      i(this, "SourceLocation");
    }
    constructor(t, r) {
      this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = r;
    }
  };
  function Wt(e, t) {
    let {
      line: r,
      column: s,
      index: n
    } = e;
    return new is(r, s + t, n + t);
  }
  i(Wt, "createPositionWithColumnOffset");
  var QT = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", EY = {
    ImportMetaOutsideModule: {
      message: `import.meta may appear only with 'sourceType: "module"'`,
      code: QT
    },
    ImportOutsideModule: {
      message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
      code: QT
    }
  }, ZT = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: {
      true: "prefix operation",
      false: "postfix operation"
    },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression"
  }, Ul = /* @__PURE__ */ i((e) => e.type === "UpdateExpression" ? ZT.UpdateExpression[`${e.prefix}`] : ZT[e.type], "toNodeDescription"), SY = {
    AccessorIsGenerator: /* @__PURE__ */ i(({
      kind: e
    }) => `A ${e}ter cannot be a generator.`, "AccessorIsGenerator"),
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: /* @__PURE__ */ i(({
      kind: e
    }) => `Missing initializer in ${e} declaration.`, "DeclarationMissingInitializer"),
    DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(deco\
rator)(args)'.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use\
 the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the s\
ame time.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use \
the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: /* @__PURE__ */ i(({
      exportName: e
    }) => `\`${e}\` has already been exported. Exported identifiers must be unique.`, "DuplicateExport"),
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: /* @__PURE__ */ i(({
      localName: e,
      exportName: t
    }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${e}' as '${t}' } from 'some-module'\`?`, "ExportBindingIsString"),
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: /* @__PURE__ */ i(({
      type: e
    }) => `'${e === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, "ForInOfLoopInitialize\
r"),
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: /* @__PURE__ */ i(({
      type: e
    }) => `Unsyntactic ${e === "BreakStatement" ? "break" : "continue"}.`, "IllegalBreakContinue"),
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You \
can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
    ImportBindingIsString: /* @__PURE__ */ i(({
      importName: e
    }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${e}" as foo }\`?`, "ImportBindingIsString"),
    ImportCallArity: "`import()` requires exactly one or two arguments.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverDiscardElement: "'void' must be followed by an expression when not used in a binding position.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: /* @__PURE__ */ i(({
      radix: e
    }) => `Expected number in radix ${e}.`, "InvalidDigit"),
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: /* @__PURE__ */ i(({
      reservedWord: e
    }) => `Escape sequence in keyword ${e}.`, "InvalidEscapedReservedWord"),
    InvalidIdentifier: /* @__PURE__ */ i(({
      identifierName: e
    }) => `Invalid identifier ${e}.`, "InvalidIdentifier"),
    InvalidLhs: /* @__PURE__ */ i(({
      ancestor: e
    }) => `Invalid left-hand side in ${Ul(e)}.`, "InvalidLhs"),
    InvalidLhsBinding: /* @__PURE__ */ i(({
      ancestor: e
    }) => `Binding invalid left-hand side in ${Ul(e)}.`, "InvalidLhsBinding"),
    InvalidLhsOptionalChaining: /* @__PURE__ */ i(({
      ancestor: e
    }) => `Invalid optional chaining in the left-hand side of ${Ul(e)}.`, "InvalidLhsOptionalChaining"),
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: /* @__PURE__ */ i(({
      unexpected: e
    }) => `Unexpected character '${e}'.`, "InvalidOrUnexpectedToken"),
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: /* @__PURE__ */ i(({
      identifierName: e
    }) => `Private name #${e} is not defined.`, "InvalidPrivateFieldResolution"),
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: /* @__PURE__ */ i(({
      labelName: e
    }) => `Label '${e}' is already declared.`, "LabelRedeclaration"),
    LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: /* @__PURE__ */ i(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling the parser plugin: ${e.map((t) => JSON.stringify(t)).join(", ")}.`, "MissingPlugin"),
    MissingOneOfPlugins: /* @__PURE__ */ i(({
      missingPlugin: e
    }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${e.map((t) => JSON.stringify(t)).join(", ")}.`,
    "MissingOneOfPlugins"),
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: /* @__PURE__ */ i(({
      key: e
    }) => `Duplicate key "${e}" is not allowed in module attributes.`, "ModuleAttributesWithDuplicateKeys"),
    ModuleExportNameHasLoneSurrogate: /* @__PURE__ */ i(({
      surrogateCharCode: e
    }) => `An export name cannot include a lone surrogate, found '\\u${e.toString(16)}'.`, "ModuleExportNameHasLoneSurrogate"),
    ModuleExportUndefined: /* @__PURE__ */ i(({
      localName: e
    }) => `Export '${e}' is not defined.`, "ModuleExportUndefined"),
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: /* @__PURE__ */ i(({
      identifierName: e
    }) => `Private names are only allowed in property accesses (\`obj.#${e}\`) or in \`in\` expressions (\`#${e} in obj\`).`, "PrivateInExpe\
ctedIn"),
    PrivateNameRedeclaration: /* @__PURE__ */ i(({
      identifierName: e
    }) => `Duplicate private name #${e}.`, "PrivateNameRedeclaration"),
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 're\
cordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the\
 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of th\
e 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if sta\
tement.",
    SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or n\
ot extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'reco\
rdAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the '\
recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the \
'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: /* @__PURE__ */ i(({
      keyword: e
    }) => `Unexpected keyword '${e}'.`, "UnexpectedKeyword"),
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: /* @__PURE__ */ i(({
      reservedWord: e
    }) => `Unexpected reserved word '${e}'.`, "UnexpectedReservedWord"),
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: /* @__PURE__ */ i(({
      expected: e,
      unexpected: t
    }) => `Unexpected token${t ? ` '${t}'.` : ""}${e ? `, expected "${e}"` : ""}`, "UnexpectedToken"),
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script` or in the bare case statement\
.",
    UnexpectedVoidPattern: "Unexpected void binding.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: /* @__PURE__ */ i(({
      target: e,
      onlyValidPropertyName: t
    }) => `The only valid meta property for ${e} is ${e}.${t}.`, "UnsupportedMetaProperty"),
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationExport: "Using declaration cannot be exported.",
    UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: /* @__PURE__ */ i(({
      identifierName: e
    }) => `Identifier '${e}' has already been declared.`, "VarRedeclaration"),
    VoidPatternCatchClauseParam: "A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to disca\
rd the caught error.",
    VoidPatternInitializer: "A void binding may not have an initializer.",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    YieldNotInGeneratorFunction: "'yield' is only allowed within generator functions.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, vY = {
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: /* @__PURE__ */ i(({
      referenceName: e
    }) => `Assigning to '${e}' in strict mode.`, "StrictEvalArguments"),
    StrictEvalArgumentsBinding: /* @__PURE__ */ i(({
      bindingName: e
    }) => `Binding '${e}' in strict mode.`, "StrictEvalArgumentsBinding"),
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode."
  }, PY = {
    ParseExpressionEmptyInput: "Unexpected parseExpression() input: The input is empty or contains only comments.",
    ParseExpressionExpectsEOF: /* @__PURE__ */ i(({
      unexpected: e
    }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the \
unexpected character \`${String.fromCodePoint(e)}\`.`, "ParseExpressionExpectsEOF")
  }, AY = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), CY = Object.
  assign({
    PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due \
to its loose operator precedence.",
    PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" opt\
ion.',
    PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: /* @__PURE__ */ i(({
      token: e
    }) => `Invalid topic token ${e}. In order to use ${e} as a topic reference, the pipelineOperator plugin must be configured with { "propo\
sal": "hack", "topicToken": "${e}" }.`, "PipeTopicUnconfiguredToken"),
    PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: /* @__PURE__ */ i(({
      type: e
    }) => `Hack-style pipe body cannot be an unparenthesized ${Ul({
      type: e
    })}; please wrap it in parentheses.`, "PipeUnparenthesizedBody")
  }, {
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "sma\
rt" option.'
  }), wY = ["message"];
  function ex(e, t, r) {
    Object.defineProperty(e, t, {
      enumerable: !1,
      configurable: !0,
      value: r
    });
  }
  i(ex, "defineHidden");
  function DY({
    toMessage: e,
    code: t,
    reasonCode: r,
    syntaxPlugin: s
  }) {
    let n = r === "MissingPlugin" || r === "MissingOneOfPlugins";
    {
      let a = {
        AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
        AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
        ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumRefer\
ence",
        SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
        SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
        SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
      };
      a[r] && (r = a[r]);
    }
    return /* @__PURE__ */ i(function a(o, l) {
      let u = new SyntaxError();
      return u.code = t, u.reasonCode = r, u.loc = o, u.pos = o.index, u.syntaxPlugin = s, n && (u.missingPlugin = l.missingPlugin), ex(u, "\
clone", /* @__PURE__ */ i(function(p = {}) {
        var f;
        let {
          line: h,
          column: b,
          index: T
        } = (f = p.loc) != null ? f : o;
        return a(new is(h, b, T), Object.assign({}, l, p.details));
      }, "clone")), ex(u, "details", l), Object.defineProperty(u, "message", {
        configurable: !0,
        get() {
          let c = `${e(l)} (${o.line}:${o.column})`;
          return this.message = c, c;
        },
        set(c) {
          Object.defineProperty(this, "message", {
            value: c,
            writable: !0
          });
        }
      }), u;
    }, "constructor");
  }
  i(DY, "toParseErrorConstructor");
  function ss(e, t) {
    if (Array.isArray(e))
      return (s) => ss(s, e[0]);
    let r = {};
    for (let s of Object.keys(e)) {
      let n = e[s], a = typeof n == "string" ? {
        message: /* @__PURE__ */ i(() => n, "message")
      } : typeof n == "function" ? {
        message: n
      } : n, {
        message: o
      } = a, l = xY(a, wY), u = typeof o == "string" ? () => o : o;
      r[s] = DY(Object.assign({
        code: "BABEL_PARSER_SYNTAX_ERROR",
        reasonCode: s,
        toMessage: u
      }, t ? {
        syntaxPlugin: t
      } : {}, l));
    }
    return r;
  }
  i(ss, "ParseErrorEnum");
  var O = Object.assign({}, ss(EY), ss(SY), ss(vY), ss(PY), ss`pipelineOperator`(CY));
  function _Y() {
    return {
      sourceType: "script",
      sourceFilename: void 0,
      startIndex: 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: !1,
      allowReturnOutsideFunction: !1,
      allowNewTargetOutsideFunction: !1,
      allowImportExportEverywhere: !1,
      allowSuperOutsideMethod: !1,
      allowUndeclaredExports: !1,
      allowYieldOutsideFunction: !1,
      plugins: [],
      strictMode: void 0,
      ranges: !1,
      tokens: !1,
      createImportExpressions: !1,
      createParenthesizedExpressions: !1,
      errorRecovery: !1,
      attachComment: !0,
      annexB: !0
    };
  }
  i(_Y, "createDefaultOptions");
  function IY(e) {
    let t = _Y();
    if (e == null)
      return t;
    if (e.annexB != null && e.annexB !== !1)
      throw new Error("The `annexB` option can only be set to `false`.");
    for (let r of Object.keys(t))
      e[r] != null && (t[r] = e[r]);
    if (t.startLine === 1)
      e.startIndex == null && t.startColumn > 0 ? t.startIndex = t.startColumn : e.startColumn == null && t.startIndex > 0 && (t.startColumn =
      t.startIndex);
    else if ((e.startColumn == null || e.startIndex == null) && e.startIndex != null)
      throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
    if (t.sourceType === "commonjs") {
      if (e.allowAwaitOutsideFunction != null)
        throw new Error("The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.");
      if (e.allowReturnOutsideFunction != null)
        throw new Error("`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction`\
 option or use `sourceType: 'script'`.");
      if (e.allowNewTargetOutsideFunction != null)
        throw new Error("`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFun\
ction` option or use `sourceType: 'script'`.");
    }
    return t;
  }
  i(IY, "getOptions");
  var {
    defineProperty: OY
  } = Object, tx = /* @__PURE__ */ i((e, t) => {
    e && OY(e, t, {
      enumerable: !1,
      value: e[t]
    });
  }, "toUnenumerable");
  function $a(e) {
    return tx(e.loc.start, "index"), tx(e.loc.end, "index"), e;
  }
  i($a, "toESTreeLocation");
  var NY = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "ESTreeParserMixin");
    }
    parse() {
      let r = $a(super.parse());
      return this.optionFlags & 256 && (r.tokens = r.tokens.map($a)), r;
    }
    parseRegExpLiteral({
      pattern: r,
      flags: s
    }) {
      let n = null;
      try {
        n = new RegExp(r, s);
      } catch {
      }
      let a = this.estreeParseLiteral(n);
      return a.regex = {
        pattern: r,
        flags: s
      }, a;
    }
    parseBigIntLiteral(r) {
      let s;
      try {
        s = BigInt(r);
      } catch {
        s = null;
      }
      let n = this.estreeParseLiteral(s);
      return n.bigint = String(n.value || r), n;
    }
    parseDecimalLiteral(r) {
      let n = this.estreeParseLiteral(null);
      return n.decimal = String(n.value || r), n;
    }
    estreeParseLiteral(r) {
      return this.parseLiteral(r, "Literal");
    }
    parseStringLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNumericLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    parseNullLiteral() {
      return this.estreeParseLiteral(null);
    }
    parseBooleanLiteral(r) {
      return this.estreeParseLiteral(r);
    }
    estreeParseChainExpression(r, s) {
      let n = this.startNodeAtNode(r);
      return n.expression = r, this.finishNodeAt(n, "ChainExpression", s);
    }
    directiveToStmt(r) {
      let s = r.value;
      delete r.value, this.castNodeTo(s, "Literal"), s.raw = s.extra.raw, s.value = s.extra.expressionValue;
      let n = this.castNodeTo(r, "ExpressionStatement");
      return n.expression = s, n.directive = s.extra.rawValue, delete s.extra, n;
    }
    fillOptionalPropertiesForTSESLint(r) {
    }
    cloneEstreeStringLiteral(r) {
      let {
        start: s,
        end: n,
        loc: a,
        range: o,
        raw: l,
        value: u
      } = r, c = Object.create(r.constructor.prototype);
      return c.type = "Literal", c.start = s, c.end = n, c.loc = a, c.range = o, c.raw = l, c.value = u, c;
    }
    initFunction(r, s) {
      super.initFunction(r, s), r.expression = !1;
    }
    checkDeclaration(r) {
      r != null && this.isObjectProperty(r) ? this.checkDeclaration(r.value) : super.checkDeclaration(r);
    }
    getObjectOrClassMethodParams(r) {
      return r.value.params;
    }
    isValidDirective(r) {
      var s;
      return r.type === "ExpressionStatement" && r.expression.type === "Literal" && typeof r.expression.value == "string" && !((s = r.expression.
      extra) != null && s.parenthesized);
    }
    parseBlockBody(r, s, n, a, o) {
      super.parseBlockBody(r, s, n, a, o);
      let l = r.directives.map((u) => this.directiveToStmt(u));
      r.body = l.concat(r.body), delete r.directives;
    }
    parsePrivateName() {
      let r = super.parsePrivateName();
      return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(r) : r;
    }
    convertPrivateNameToPrivateIdentifier(r) {
      let s = super.getPrivateNameSV(r);
      return delete r.id, r.name = s, this.castNodeTo(r, "PrivateIdentifier");
    }
    isPrivateName(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.type === "PrivateIdentifier" : super.isPrivateName(r);
    }
    getPrivateNameSV(r) {
      return this.getPluginOption("estree", "classFeatures") ? r.name : super.getPrivateNameSV(r);
    }
    parseLiteral(r, s) {
      let n = super.parseLiteral(r, s);
      return n.raw = n.extra.raw, delete n.extra, n;
    }
    parseFunctionBody(r, s, n = !1) {
      super.parseFunctionBody(r, s, n), r.expression = r.body.type !== "BlockStatement";
    }
    parseMethod(r, s, n, a, o, l, u = !1) {
      let c = this.startNode();
      c.kind = r.kind, c = super.parseMethod(c, s, n, a, o, l, u), delete c.kind;
      let {
        typeParameters: p
      } = r;
      p && (delete r.typeParameters, c.typeParameters = p, this.resetStartLocationFromNode(c, p));
      let f = this.castNodeTo(c, "FunctionExpression");
      return r.value = f, l === "ClassPrivateMethod" && (r.computed = !1), l === "ObjectMethod" ? (r.kind === "method" && (r.kind = "init"),
      r.shorthand = !1, this.finishNode(r, "Property")) : this.finishNode(r, "MethodDefinition");
    }
    nameIsConstructor(r) {
      return r.type === "Literal" ? r.value === "constructor" : super.nameIsConstructor(r);
    }
    parseClassProperty(...r) {
      let s = super.parseClassProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && this.castNodeTo(s, "PropertyDefinition"), s;
    }
    parseClassPrivateProperty(...r) {
      let s = super.parseClassPrivateProperty(...r);
      return this.getPluginOption("estree", "classFeatures") && (this.castNodeTo(s, "PropertyDefinition"), s.computed = !1), s;
    }
    parseClassAccessorProperty(r) {
      let s = super.parseClassAccessorProperty(r);
      return this.getPluginOption("estree", "classFeatures") && (s.abstract && this.hasPlugin("typescript") ? (delete s.abstract, this.castNodeTo(
      s, "TSAbstractAccessorProperty")) : this.castNodeTo(s, "AccessorProperty")), s;
    }
    parseObjectProperty(r, s, n, a) {
      let o = super.parseObjectProperty(r, s, n, a);
      return o && (o.kind = "init", this.castNodeTo(o, "Property")), o;
    }
    finishObjectProperty(r) {
      return r.kind = "init", this.finishNode(r, "Property");
    }
    isValidLVal(r, s, n, a) {
      return r === "Property" ? "value" : super.isValidLVal(r, s, n, a);
    }
    isAssignable(r, s) {
      return r != null && this.isObjectProperty(r) ? this.isAssignable(r.value, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      if (r != null && this.isObjectProperty(r)) {
        let {
          key: n,
          value: a
        } = r;
        this.isPrivateName(n) && this.classScope.usePrivateName(this.getPrivateNameSV(n), n.loc.start), this.toAssignable(a, s);
      } else
        super.toAssignable(r, s);
    }
    toAssignableObjectExpressionProp(r, s, n) {
      r.type === "Property" && (r.kind === "get" || r.kind === "set") ? this.raise(O.PatternHasAccessor, r.key) : r.type === "Property" && r.
      method ? this.raise(O.PatternHasMethod, r.key) : super.toAssignableObjectExpressionProp(r, s, n);
    }
    finishCallExpression(r, s) {
      let n = super.finishCallExpression(r, s);
      if (n.callee.type === "Import") {
        var a;
        this.castNodeTo(n, "ImportExpression"), n.source = n.arguments[0], n.options = (a = n.arguments[1]) != null ? a : null;
        {
          var o;
          n.attributes = (o = n.arguments[1]) != null ? o : null;
        }
        delete n.arguments, delete n.callee;
      } else n.type === "OptionalCallExpression" ? this.castNodeTo(n, "CallExpression") : n.optional = !1;
      return n;
    }
    toReferencedArguments(r) {
      r.type !== "ImportExpression" && super.toReferencedArguments(r);
    }
    parseExport(r, s) {
      let n = this.state.lastTokStartLoc, a = super.parseExport(r, s);
      switch (a.type) {
        case "ExportAllDeclaration":
          a.exported = null;
          break;
        case "ExportNamedDeclaration":
          a.specifiers.length === 1 && a.specifiers[0].type === "ExportNamespaceSpecifier" && (this.castNodeTo(a, "ExportAllDeclaration"), a.
          exported = a.specifiers[0].exported, delete a.specifiers);
        case "ExportDefaultDeclaration":
          {
            var o;
            let {
              declaration: l
            } = a;
            l?.type === "ClassDeclaration" && ((o = l.decorators) == null ? void 0 : o.length) > 0 && l.start === a.start && this.resetStartLocation(
            a, n);
          }
          break;
      }
      return a;
    }
    stopParseSubscript(r, s) {
      let n = super.stopParseSubscript(r, s);
      return s.optionalChainMember ? this.estreeParseChainExpression(n, r.loc.end) : n;
    }
    parseMember(r, s, n, a, o) {
      let l = super.parseMember(r, s, n, a, o);
      return l.type === "OptionalMemberExpression" ? this.castNodeTo(l, "MemberExpression") : l.optional = !1, l;
    }
    isOptionalMemberExpression(r) {
      return r.type === "ChainExpression" ? r.expression.type === "MemberExpression" : super.isOptionalMemberExpression(r);
    }
    hasPropertyAsPrivateName(r) {
      return r.type === "ChainExpression" && (r = r.expression), super.hasPropertyAsPrivateName(r);
    }
    isObjectProperty(r) {
      return r.type === "Property" && r.kind === "init" && !r.method;
    }
    isObjectMethod(r) {
      return r.type === "Property" && (r.method || r.kind === "get" || r.kind === "set");
    }
    castNodeTo(r, s) {
      let n = super.castNodeTo(r, s);
      return this.fillOptionalPropertiesForTSESLint(n), n;
    }
    cloneIdentifier(r) {
      let s = super.cloneIdentifier(r);
      return this.fillOptionalPropertiesForTSESLint(s), s;
    }
    cloneStringLiteral(r) {
      return r.type === "Literal" ? this.cloneEstreeStringLiteral(r) : super.cloneStringLiteral(r);
    }
    finishNodeAt(r, s, n) {
      return $a(super.finishNodeAt(r, s, n));
    }
    finishNode(r, s) {
      let n = super.finishNode(r, s);
      return this.fillOptionalPropertiesForTSESLint(n), n;
    }
    resetStartLocation(r, s) {
      super.resetStartLocation(r, s), $a(r);
    }
    resetEndLocation(r, s = this.state.lastTokEndLoc) {
      super.resetEndLocation(r, s), $a(r);
    }
  }, "estree"), On = class {
    static {
      i(this, "TokContext");
    }
    constructor(t, r) {
      this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!r;
    }
  }, _e = {
    brace: new On("{"),
    j_oTag: new On("<tag"),
    j_cTag: new On("</tag"),
    j_expr: new On("<tag>...</tag>", !0)
  };
  _e.template = new On("`", !0);
  var be = !0, J = !0, h0 = !0, Va = !0, Gs = !0, BY = !0, Kl = class {
    static {
      i(this, "ExportedTokenType");
    }
    constructor(t, r = {}) {
      this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop =
      void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = r.keyword,
      this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.rightAssociative = !!r.rightAssociative, this.isLoop = !!r.isLoop,
      this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop != null ? r.binop : null, this.
      updateContext = null;
    }
  }, U0 = /* @__PURE__ */ new Map();
  function Ce(e, t = {}) {
    t.keyword = e;
    let r = ae(e, t);
    return U0.set(e, r), r;
  }
  i(Ce, "createKeyword");
  function Kt(e, t) {
    return ae(e, {
      beforeExpr: be,
      binop: t
    });
  }
  i(Kt, "createBinop");
  var Ha = -1, gs = [], $0 = [], V0 = [], K0 = [], W0 = [], Y0 = [];
  function ae(e, t = {}) {
    var r, s, n, a;
    return ++Ha, $0.push(e), V0.push((r = t.binop) != null ? r : -1), K0.push((s = t.beforeExpr) != null ? s : !1), W0.push((n = t.startsExpr) !=
    null ? n : !1), Y0.push((a = t.prefix) != null ? a : !1), gs.push(new Kl(e, t)), Ha;
  }
  i(ae, "createToken");
  function Te(e, t = {}) {
    var r, s, n, a;
    return ++Ha, U0.set(e, Ha), $0.push(e), V0.push((r = t.binop) != null ? r : -1), K0.push((s = t.beforeExpr) != null ? s : !1), W0.push((n =
    t.startsExpr) != null ? n : !1), Y0.push((a = t.prefix) != null ? a : !1), gs.push(new Kl("name", t)), Ha;
  }
  i(Te, "createKeywordLike");
  var kY = {
    bracketL: ae("[", {
      beforeExpr: be,
      startsExpr: J
    }),
    bracketHashL: ae("#[", {
      beforeExpr: be,
      startsExpr: J
    }),
    bracketBarL: ae("[|", {
      beforeExpr: be,
      startsExpr: J
    }),
    bracketR: ae("]"),
    bracketBarR: ae("|]"),
    braceL: ae("{", {
      beforeExpr: be,
      startsExpr: J
    }),
    braceBarL: ae("{|", {
      beforeExpr: be,
      startsExpr: J
    }),
    braceHashL: ae("#{", {
      beforeExpr: be,
      startsExpr: J
    }),
    braceR: ae("}"),
    braceBarR: ae("|}"),
    parenL: ae("(", {
      beforeExpr: be,
      startsExpr: J
    }),
    parenR: ae(")"),
    comma: ae(",", {
      beforeExpr: be
    }),
    semi: ae(";", {
      beforeExpr: be
    }),
    colon: ae(":", {
      beforeExpr: be
    }),
    doubleColon: ae("::", {
      beforeExpr: be
    }),
    dot: ae("."),
    question: ae("?", {
      beforeExpr: be
    }),
    questionDot: ae("?."),
    arrow: ae("=>", {
      beforeExpr: be
    }),
    template: ae("template"),
    ellipsis: ae("...", {
      beforeExpr: be
    }),
    backQuote: ae("`", {
      startsExpr: J
    }),
    dollarBraceL: ae("${", {
      beforeExpr: be,
      startsExpr: J
    }),
    templateTail: ae("...`", {
      startsExpr: J
    }),
    templateNonTail: ae("...${", {
      beforeExpr: be,
      startsExpr: J
    }),
    at: ae("@"),
    hash: ae("#", {
      startsExpr: J
    }),
    interpreterDirective: ae("#!..."),
    eq: ae("=", {
      beforeExpr: be,
      isAssign: Va
    }),
    assign: ae("_=", {
      beforeExpr: be,
      isAssign: Va
    }),
    slashAssign: ae("_=", {
      beforeExpr: be,
      isAssign: Va
    }),
    xorAssign: ae("_=", {
      beforeExpr: be,
      isAssign: Va
    }),
    moduloAssign: ae("_=", {
      beforeExpr: be,
      isAssign: Va
    }),
    incDec: ae("++/--", {
      prefix: Gs,
      postfix: BY,
      startsExpr: J
    }),
    bang: ae("!", {
      beforeExpr: be,
      prefix: Gs,
      startsExpr: J
    }),
    tilde: ae("~", {
      beforeExpr: be,
      prefix: Gs,
      startsExpr: J
    }),
    doubleCaret: ae("^^", {
      startsExpr: J
    }),
    doubleAt: ae("@@", {
      startsExpr: J
    }),
    pipeline: Kt("|>", 0),
    nullishCoalescing: Kt("??", 1),
    logicalOR: Kt("||", 1),
    logicalAND: Kt("&&", 2),
    bitwiseOR: Kt("|", 3),
    bitwiseXOR: Kt("^", 4),
    bitwiseAND: Kt("&", 5),
    equality: Kt("==/!=/===/!==", 6),
    lt: Kt("</>/<=/>=", 7),
    gt: Kt("</>/<=/>=", 7),
    relational: Kt("</>/<=/>=", 7),
    bitShift: Kt("<</>>/>>>", 8),
    bitShiftL: Kt("<</>>/>>>", 8),
    bitShiftR: Kt("<</>>/>>>", 8),
    plusMin: ae("+/-", {
      beforeExpr: be,
      binop: 9,
      prefix: Gs,
      startsExpr: J
    }),
    modulo: ae("%", {
      binop: 10,
      startsExpr: J
    }),
    star: ae("*", {
      binop: 10
    }),
    slash: Kt("/", 10),
    exponent: ae("**", {
      beforeExpr: be,
      binop: 11,
      rightAssociative: !0
    }),
    _in: Ce("in", {
      beforeExpr: be,
      binop: 7
    }),
    _instanceof: Ce("instanceof", {
      beforeExpr: be,
      binop: 7
    }),
    _break: Ce("break"),
    _case: Ce("case", {
      beforeExpr: be
    }),
    _catch: Ce("catch"),
    _continue: Ce("continue"),
    _debugger: Ce("debugger"),
    _default: Ce("default", {
      beforeExpr: be
    }),
    _else: Ce("else", {
      beforeExpr: be
    }),
    _finally: Ce("finally"),
    _function: Ce("function", {
      startsExpr: J
    }),
    _if: Ce("if"),
    _return: Ce("return", {
      beforeExpr: be
    }),
    _switch: Ce("switch"),
    _throw: Ce("throw", {
      beforeExpr: be,
      prefix: Gs,
      startsExpr: J
    }),
    _try: Ce("try"),
    _var: Ce("var"),
    _const: Ce("const"),
    _with: Ce("with"),
    _new: Ce("new", {
      beforeExpr: be,
      startsExpr: J
    }),
    _this: Ce("this", {
      startsExpr: J
    }),
    _super: Ce("super", {
      startsExpr: J
    }),
    _class: Ce("class", {
      startsExpr: J
    }),
    _extends: Ce("extends", {
      beforeExpr: be
    }),
    _export: Ce("export"),
    _import: Ce("import", {
      startsExpr: J
    }),
    _null: Ce("null", {
      startsExpr: J
    }),
    _true: Ce("true", {
      startsExpr: J
    }),
    _false: Ce("false", {
      startsExpr: J
    }),
    _typeof: Ce("typeof", {
      beforeExpr: be,
      prefix: Gs,
      startsExpr: J
    }),
    _void: Ce("void", {
      beforeExpr: be,
      prefix: Gs,
      startsExpr: J
    }),
    _delete: Ce("delete", {
      beforeExpr: be,
      prefix: Gs,
      startsExpr: J
    }),
    _do: Ce("do", {
      isLoop: h0,
      beforeExpr: be
    }),
    _for: Ce("for", {
      isLoop: h0
    }),
    _while: Ce("while", {
      isLoop: h0
    }),
    _as: Te("as", {
      startsExpr: J
    }),
    _assert: Te("assert", {
      startsExpr: J
    }),
    _async: Te("async", {
      startsExpr: J
    }),
    _await: Te("await", {
      startsExpr: J
    }),
    _defer: Te("defer", {
      startsExpr: J
    }),
    _from: Te("from", {
      startsExpr: J
    }),
    _get: Te("get", {
      startsExpr: J
    }),
    _let: Te("let", {
      startsExpr: J
    }),
    _meta: Te("meta", {
      startsExpr: J
    }),
    _of: Te("of", {
      startsExpr: J
    }),
    _sent: Te("sent", {
      startsExpr: J
    }),
    _set: Te("set", {
      startsExpr: J
    }),
    _source: Te("source", {
      startsExpr: J
    }),
    _static: Te("static", {
      startsExpr: J
    }),
    _using: Te("using", {
      startsExpr: J
    }),
    _yield: Te("yield", {
      startsExpr: J
    }),
    _asserts: Te("asserts", {
      startsExpr: J
    }),
    _checks: Te("checks", {
      startsExpr: J
    }),
    _exports: Te("exports", {
      startsExpr: J
    }),
    _global: Te("global", {
      startsExpr: J
    }),
    _implements: Te("implements", {
      startsExpr: J
    }),
    _intrinsic: Te("intrinsic", {
      startsExpr: J
    }),
    _infer: Te("infer", {
      startsExpr: J
    }),
    _is: Te("is", {
      startsExpr: J
    }),
    _mixins: Te("mixins", {
      startsExpr: J
    }),
    _proto: Te("proto", {
      startsExpr: J
    }),
    _require: Te("require", {
      startsExpr: J
    }),
    _satisfies: Te("satisfies", {
      startsExpr: J
    }),
    _keyof: Te("keyof", {
      startsExpr: J
    }),
    _readonly: Te("readonly", {
      startsExpr: J
    }),
    _unique: Te("unique", {
      startsExpr: J
    }),
    _abstract: Te("abstract", {
      startsExpr: J
    }),
    _declare: Te("declare", {
      startsExpr: J
    }),
    _enum: Te("enum", {
      startsExpr: J
    }),
    _module: Te("module", {
      startsExpr: J
    }),
    _namespace: Te("namespace", {
      startsExpr: J
    }),
    _interface: Te("interface", {
      startsExpr: J
    }),
    _type: Te("type", {
      startsExpr: J
    }),
    _opaque: Te("opaque", {
      startsExpr: J
    }),
    name: ae("name", {
      startsExpr: J
    }),
    placeholder: ae("%%", {
      startsExpr: J
    }),
    string: ae("string", {
      startsExpr: J
    }),
    num: ae("num", {
      startsExpr: J
    }),
    bigint: ae("bigint", {
      startsExpr: J
    }),
    decimal: ae("decimal", {
      startsExpr: J
    }),
    regexp: ae("regexp", {
      startsExpr: J
    }),
    privateName: ae("#name", {
      startsExpr: J
    }),
    eof: ae("eof"),
    jsxName: ae("jsxName"),
    jsxText: ae("jsxText", {
      beforeExpr: be
    }),
    jsxTagStart: ae("jsxTagStart", {
      startsExpr: J
    }),
    jsxTagEnd: ae("jsxTagEnd")
  };
  function ke(e) {
    return e >= 93 && e <= 133;
  }
  i(ke, "tokenIsIdentifier");
  function FY(e) {
    return e <= 92;
  }
  i(FY, "tokenKeywordOrIdentifierIsKeyword");
  function Fr(e) {
    return e >= 58 && e <= 133;
  }
  i(Fr, "tokenIsKeywordOrIdentifier");
  function dx(e) {
    return e >= 58 && e <= 137;
  }
  i(dx, "tokenIsLiteralPropertyName");
  function LY(e) {
    return K0[e];
  }
  i(LY, "tokenComesBeforeExpression");
  function Wa(e) {
    return W0[e];
  }
  i(Wa, "tokenCanStartExpression");
  function jY(e) {
    return e >= 29 && e <= 33;
  }
  i(jY, "tokenIsAssignment");
  function rx(e) {
    return e >= 129 && e <= 131;
  }
  i(rx, "tokenIsFlowInterfaceOrTypeOrOpaque");
  function MY(e) {
    return e >= 90 && e <= 92;
  }
  i(MY, "tokenIsLoop");
  function H0(e) {
    return e >= 58 && e <= 92;
  }
  i(H0, "tokenIsKeyword");
  function RY(e) {
    return e >= 39 && e <= 59;
  }
  i(RY, "tokenIsOperator");
  function qY(e) {
    return e === 34;
  }
  i(qY, "tokenIsPostfix");
  function UY(e) {
    return Y0[e];
  }
  i(UY, "tokenIsPrefix");
  function $Y(e) {
    return e >= 121 && e <= 123;
  }
  i($Y, "tokenIsTSTypeOperator");
  function VY(e) {
    return e >= 124 && e <= 130;
  }
  i(VY, "tokenIsTSDeclarationStart");
  function Qs(e) {
    return $0[e];
  }
  i(Qs, "tokenLabelName");
  function $l(e) {
    return V0[e];
  }
  i($l, "tokenOperatorPrecedence");
  function KY(e) {
    return e === 57;
  }
  i(KY, "tokenIsRightAssociative");
  function Wl(e) {
    return e >= 24 && e <= 25;
  }
  i(Wl, "tokenIsTemplate");
  function bs(e) {
    return gs[e];
  }
  i(bs, "getExportedToken");
  gs[8].updateContext = (e) => {
    e.pop();
  }, gs[5].updateContext = gs[7].updateContext = gs[23].updateContext = (e) => {
    e.push(_e.brace);
  }, gs[22].updateContext = (e) => {
    e[e.length - 1] === _e.template ? e.pop() : e.push(_e.template);
  }, gs[143].updateContext = (e) => {
    e.push(_e.j_expr, _e.j_oTag);
  };
  var J0 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088F\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993\
-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5C\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92\
-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDC-\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\
\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00\
-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\
\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7DC\uA7F1-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\
\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",
  hx = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\
\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\
\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ADD\u1AE0-\u1AEB\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0\
-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00\
-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65", WY = new RegExp("[" + J0 + "]"), YY = new RegExp("[" + J0 + hx + "]");
  J0 = hx = null;
  var mx = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157,
  19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5,
  3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28,
  36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21,
  43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20,
  1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0,
  2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0,
  3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0,
  50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637,
  96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24,
  3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395,
  2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0,
  4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322,
  29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26,
  2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2,
  3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489], HY = [509,
  0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14,
  32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7,
  3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214,
  6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0,
  29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2,
  1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470,
  0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15,
  0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0,
  475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
  function x0(e, t) {
    let r = 65536;
    for (let s = 0, n = t.length; s < n; s += 2) {
      if (r += t[s], r > e) return !1;
      if (r += t[s + 1], r >= e) return !0;
    }
    return !1;
  }
  i(x0, "isInAstralSet");
  function ns(e) {
    return e < 65 ? e === 36 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && WY.test(String.fromCharCode(e)) :
    x0(e, mx);
  }
  i(ns, "isIdentifierStart");
  function Nn(e) {
    return e < 48 ? e === 36 : e < 58 ? !0 : e < 65 ? !1 : e <= 90 ? !0 : e < 97 ? e === 95 : e <= 122 ? !0 : e <= 65535 ? e >= 170 && YY.test(
    String.fromCharCode(e)) : x0(e, mx) || x0(e, HY);
  }
  i(Nn, "isIdentifierChar");
  var G0 = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "swit\
ch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false",
    "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  }, JY = new Set(G0.keyword), GY = new Set(G0.strict), XY = new Set(G0.strictBind);
  function yx(e, t) {
    return t && e === "await" || e === "enum";
  }
  i(yx, "isReservedWord");
  function bx(e, t) {
    return yx(e, t) || GY.has(e);
  }
  i(bx, "isStrictReservedWord");
  function gx(e) {
    return XY.has(e);
  }
  i(gx, "isStrictBindOnlyReservedWord");
  function Tx(e, t) {
    return bx(e, t) || gx(e);
  }
  i(Tx, "isStrictBindReservedWord");
  function zY(e) {
    return JY.has(e);
  }
  i(zY, "isKeyword");
  function QY(e, t, r) {
    return e === 64 && t === 64 && ns(r);
  }
  i(QY, "isIteratorStart");
  var ZY = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function",
  "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import",
  "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protecte\
d", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function eH(e) {
    return ZY.has(e);
  }
  i(eH, "canBeReservedWord");
  var Ja = class {
    static {
      i(this, "Scope");
    }
    constructor(t) {
      this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
    }
  }, Ga = class {
    static {
      i(this, "ScopeHandler");
    }
    constructor(t, r) {
      this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t,
      this.inModule = r;
    }
    get inTopLevel() {
      return (this.currentScope().flags & 1) > 0;
    }
    get inFunction() {
      return (this.currentVarScopeFlags() & 2) > 0;
    }
    get allowSuper() {
      return (this.currentThisScopeFlags() & 16) > 0;
    }
    get allowDirectSuper() {
      return (this.currentThisScopeFlags() & 32) > 0;
    }
    get allowNewTarget() {
      return (this.currentThisScopeFlags() & 512) > 0;
    }
    get inClass() {
      return (this.currentThisScopeFlags() & 64) > 0;
    }
    get inClassAndNotInNonArrowFunction() {
      let t = this.currentThisScopeFlags();
      return (t & 64) > 0 && (t & 2) === 0;
    }
    get inStaticBlock() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 128)
          return !0;
        if (r & 1731)
          return !1;
      }
    }
    get inNonArrowFunction() {
      return (this.currentThisScopeFlags() & 2) > 0;
    }
    get inBareCaseStatement() {
      return (this.currentScope().flags & 256) > 0;
    }
    get treatFunctionsAsVar() {
      return this.treatFunctionsAsVarInScope(this.currentScope());
    }
    createScope(t) {
      return new Ja(t);
    }
    enter(t) {
      this.scopeStack.push(this.createScope(t));
    }
    exit() {
      return this.scopeStack.pop().flags;
    }
    treatFunctionsAsVarInScope(t) {
      return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
    }
    declareName(t, r, s) {
      let n = this.currentScope();
      if (r & 8 || r & 16) {
        this.checkRedeclarationInScope(n, t, r, s);
        let a = n.names.get(t) || 0;
        r & 16 ? a = a | 4 : (n.firstLexicalName || (n.firstLexicalName = t), a = a | 2), n.names.set(t, a), r & 8 && this.maybeExportDefined(
        n, t);
      } else if (r & 4)
        for (let a = this.scopeStack.length - 1; a >= 0 && (n = this.scopeStack[a], this.checkRedeclarationInScope(n, t, r, s), n.names.set(
        t, (n.names.get(t) || 0) | 1), this.maybeExportDefined(n, t), !(n.flags & 1667)); --a)
          ;
      this.parser.inModule && n.flags & 1 && this.undefinedExports.delete(t);
    }
    maybeExportDefined(t, r) {
      this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(r);
    }
    checkRedeclarationInScope(t, r, s, n) {
      this.isRedeclaredInScope(t, r, s) && this.parser.raise(O.VarRedeclaration, n, {
        identifierName: r
      });
    }
    isRedeclaredInScope(t, r, s) {
      if (!(s & 1)) return !1;
      if (s & 8)
        return t.names.has(r);
      let n = t.names.get(r) || 0;
      return s & 16 ? (n & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (n & 1) > 0 : (n & 2) > 0 && !(t.flags & 8 && t.firstLexicalName ===
      r) || !this.treatFunctionsAsVarInScope(t) && (n & 4) > 0;
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      this.scopeStack[0].names.has(r) || this.undefinedExports.set(r, t.loc.start);
    }
    currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    }
    currentVarScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 1667)
          return r;
      }
    }
    currentThisScopeFlags() {
      for (let t = this.scopeStack.length - 1; ; t--) {
        let {
          flags: r
        } = this.scopeStack[t];
        if (r & 1731 && !(r & 4))
          return r;
      }
    }
  }, E0 = class extends Ja {
    static {
      i(this, "FlowScope");
    }
    constructor(...t) {
      super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
    }
  }, S0 = class extends Ga {
    static {
      i(this, "FlowScopeHandler");
    }
    createScope(t) {
      return new E0(t);
    }
    declareName(t, r, s) {
      let n = this.currentScope();
      if (r & 2048) {
        this.checkRedeclarationInScope(n, t, r, s), this.maybeExportDefined(n, t), n.declareFunctions.add(t);
        return;
      }
      super.declareName(t, r, s);
    }
    isRedeclaredInScope(t, r, s) {
      if (super.isRedeclaredInScope(t, r, s)) return !0;
      if (s & 2048 && !t.declareFunctions.has(r)) {
        let n = t.names.get(r);
        return (n & 4) > 0 || (n & 2) > 0;
      }
      return !1;
    }
    checkLocalExport(t) {
      this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
    }
  }, tH = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "stat\
ic", "string", "true", "typeof", "void"]), le = ss`flow`({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since \
they are either an ES module or they are a CommonJS module.",
    AssignReservedType: /* @__PURE__ */ i(({
      reservedType: e
    }) => `Cannot overwrite reserved type ${e}.`, "AssignReservedType"),
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: /* @__PURE__ */ i(({
      memberName: e,
      enumName: t
    }) => `Boolean enum members need to be initialized. Use either \`${e} = true,\` or \`${e} = false,\` in enum \`${t}\`.`, "EnumBooleanMem\
berNotInitialized"),
    EnumDuplicateMemberName: /* @__PURE__ */ i(({
      memberName: e,
      enumName: t
    }) => `Enum member names need to be unique, but the name \`${e}\` has already been used before in enum \`${t}\`.`, "EnumDuplicateMemberN\
ame"),
    EnumInconsistentMemberValues: /* @__PURE__ */ i(({
      enumName: e
    }) => `Enum \`${e}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, num\
bers, or strings) for all member initializers.`, "EnumInconsistentMemberValues"),
    EnumInvalidExplicitType: /* @__PURE__ */ i(({
      invalidEnumType: e,
      enumName: t
    }) => `Enum type \`${e}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, "EnumInvalidEx\
plicitType"),
    EnumInvalidExplicitTypeUnknownSupplied: /* @__PURE__ */ i(({
      enumName: e
    }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${e}\`.`, "EnumInvalidEx\
plicitTypeUnknownSupplied"),
    EnumInvalidMemberInitializerPrimaryType: /* @__PURE__ */ i(({
      enumName: e,
      memberName: t,
      explicitType: r
    }) => `Enum \`${e}\` has type \`${r}\`, so the initializer of \`${t}\` needs to be a ${r} literal.`, "EnumInvalidMemberInitializerPrimar\
yType"),
    EnumInvalidMemberInitializerSymbolType: /* @__PURE__ */ i(({
      enumName: e,
      memberName: t
    }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${e}\`.`, "EnumInvalidMemberInitializerSymbolType"),
    EnumInvalidMemberInitializerUnknownType: /* @__PURE__ */ i(({
      enumName: e,
      memberName: t
    }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${e}\`.`, "EnumInv\
alidMemberInitializerUnknownType"),
    EnumInvalidMemberName: /* @__PURE__ */ i(({
      enumName: e,
      memberName: t,
      suggestion: r
    }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${r}\`, in enum \`${e}\
\`.`, "EnumInvalidMemberName"),
    EnumNumberMemberNotInitialized: /* @__PURE__ */ i(({
      enumName: e,
      memberName: t
    }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${e}\`.`, "EnumNumberMemberNotInitialized"),
    EnumStringMemberInconsistentlyInitialized: /* @__PURE__ */ i(({
      enumName: e
    }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${e}\`.`, "EnumStringMemb\
erInconsistentlyInitialized"),
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements.\
 It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign({
      message: "A binding pattern parameter cannot be optional in an implementation signature."
    }, {
      reasonCode: "OptionalBindingPattern"
    }),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\
.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: /* @__PURE__ */ i(({
      reservedType: e
    }) => `Unexpected reserved type ${e}.`, "UnexpectedReservedType"),
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}\
`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: /* @__PURE__ */ i(({
      unsupportedExportKind: e,
      suggestion: t
    }) => `\`declare export ${e}\` is not supported. Use \`${t}\` instead.`, "UnsupportedDeclareExportKind"),
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  });
  function rH(e) {
    return e.type === "DeclareExportAllDeclaration" || e.type === "DeclareExportDeclaration" && (!e.declaration || e.declaration.type !== "T\
ypeAlias" && e.declaration.type !== "InterfaceDeclaration");
  }
  i(rH, "isEsModuleType");
  function sx(e) {
    return e.importKind === "type" || e.importKind === "typeof";
  }
  i(sx, "hasTypeImportKind");
  var sH = {
    const: "declare export var",
    let: "declare export var",
    type: "export type",
    interface: "export interface"
  };
  function nH(e, t) {
    let r = [], s = [];
    for (let n = 0; n < e.length; n++)
      (t(e[n], n, e) ? r : s).push(e[n]);
    return [r, s];
  }
  i(nH, "partition");
  var iH = /\*?\s*@((?:no)?flow)\b/, aH = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "FlowParserMixin");
    }
    constructor(...r) {
      super(...r), this.flowPragma = void 0;
    }
    getScopeHandler() {
      return S0;
    }
    shouldParseTypes() {
      return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
    }
    finishToken(r, s) {
      r !== 134 && r !== 13 && r !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(r, s);
    }
    addComment(r) {
      if (this.flowPragma === void 0) {
        let s = iH.exec(r.value);
        if (s) if (s[1] === "flow")
          this.flowPragma = "flow";
        else if (s[1] === "noflow")
          this.flowPragma = "noflow";
        else
          throw new Error("Unexpected flow pragma");
      }
      super.addComment(r);
    }
    flowParseTypeInitialiser(r) {
      let s = this.state.inType;
      this.state.inType = !0, this.expect(r || 14);
      let n = this.flowParseType();
      return this.state.inType = s, n;
    }
    flowParsePredicate() {
      let r = this.startNode(), s = this.state.startLoc;
      return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(le.UnexpectedSpaceBetweenModuloChecks,
      s), this.eat(10) ? (r.value = super.parseExpression(), this.expect(11), this.finishNode(r, "DeclaredPredicate")) : this.finishNode(r, "\
InferredPredicate");
    }
    flowParseTypeAndPredicateInitialiser() {
      let r = this.state.inType;
      this.state.inType = !0, this.expect(14);
      let s = null, n = null;
      return this.match(54) ? (this.state.inType = r, n = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = r, this.
      match(54) && (n = this.flowParsePredicate())), [s, n];
    }
    flowParseDeclareClass(r) {
      return this.next(), this.flowParseInterfaceish(r, !0), this.finishNode(r, "DeclareClass");
    }
    flowParseDeclareFunction(r) {
      this.next();
      let s = r.id = this.parseIdentifier(), n = this.startNode(), a = this.startNode();
      this.match(47) ? n.typeParameters = this.flowParseTypeParameterDeclaration() : n.typeParameters = null, this.expect(10);
      let o = this.flowParseFunctionTypeParams();
      return n.params = o.params, n.rest = o.rest, n.this = o._this, this.expect(11), [n.returnType, r.predicate] = this.flowParseTypeAndPredicateInitialiser(),
      a.typeAnnotation = this.finishNode(n, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(a, "TypeAnnotation"), this.resetEndLocation(
      s), this.semicolon(), this.scope.declareName(r.id.name, 2048, r.id.loc.start), this.finishNode(r, "DeclareFunction");
    }
    flowParseDeclare(r, s) {
      if (this.match(80))
        return this.flowParseDeclareClass(r);
      if (this.match(68))
        return this.flowParseDeclareFunction(r);
      if (this.match(74))
        return this.flowParseDeclareVariable(r);
      if (this.eatContextual(127))
        return this.match(16) ? this.flowParseDeclareModuleExports(r) : (s && this.raise(le.NestedDeclareModule, this.state.lastTokStartLoc),
        this.flowParseDeclareModule(r));
      if (this.isContextual(130))
        return this.flowParseDeclareTypeAlias(r);
      if (this.isContextual(131))
        return this.flowParseDeclareOpaqueType(r);
      if (this.isContextual(129))
        return this.flowParseDeclareInterface(r);
      if (this.match(82))
        return this.flowParseDeclareExportDeclaration(r, s);
      throw this.unexpected();
    }
    flowParseDeclareVariable(r) {
      return this.next(), r.id = this.flowParseTypeAnnotatableIdentifier(!0), this.scope.declareName(r.id.name, 5, r.id.loc.start), this.semicolon(),
      this.finishNode(r, "DeclareVariable");
    }
    flowParseDeclareModule(r) {
      this.scope.enter(0), this.match(134) ? r.id = super.parseExprAtom() : r.id = this.parseIdentifier();
      let s = r.body = this.startNode(), n = s.body = [];
      for (this.expect(5); !this.match(8); ) {
        let l = this.startNode();
        this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(le.InvalidNonTypeImportInDeclareModule, this.
        state.lastTokStartLoc), n.push(super.parseImport(l))) : (this.expectContextual(125, le.UnsupportedStatementInDeclareModule), n.push(
        this.flowParseDeclare(l, !0)));
      }
      this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
      let a = null, o = !1;
      return n.forEach((l) => {
        rH(l) ? (a === "CommonJS" && this.raise(le.AmbiguousDeclareModuleKind, l), a = "ES") : l.type === "DeclareModuleExports" && (o && this.
        raise(le.DuplicateDeclareModuleExports, l), a === "ES" && this.raise(le.AmbiguousDeclareModuleKind, l), a = "CommonJS", o = !0);
      }), r.kind = a || "CommonJS", this.finishNode(r, "DeclareModule");
    }
    flowParseDeclareExportDeclaration(r, s) {
      if (this.expect(82), this.eat(65))
        return this.match(68) || this.match(80) ? r.declaration = this.flowParseDeclare(this.startNode()) : (r.declaration = this.flowParseType(),
        this.semicolon()), r.default = !0, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
        let n = this.state.value;
        throw this.raise(le.UnsupportedDeclareExportKind, this.state.startLoc, {
          unsupportedExportKind: n,
          suggestion: sH[n]
        });
      }
      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131))
        return r.declaration = this.flowParseDeclare(this.startNode()), r.default = !1, this.finishNode(r, "DeclareExportDeclaration");
      if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131))
        return r = this.parseExport(r, null), r.type === "ExportNamedDeclaration" ? (r.default = !1, delete r.exportKind, this.castNodeTo(r,
        "DeclareExportDeclaration")) : this.castNodeTo(r, "DeclareExportAllDeclaration");
      throw this.unexpected();
    }
    flowParseDeclareModuleExports(r) {
      return this.next(), this.expectContextual(111), r.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(r,
      "DeclareModuleExports");
    }
    flowParseDeclareTypeAlias(r) {
      this.next();
      let s = this.flowParseTypeAlias(r);
      return this.castNodeTo(s, "DeclareTypeAlias"), s;
    }
    flowParseDeclareOpaqueType(r) {
      this.next();
      let s = this.flowParseOpaqueType(r, !0);
      return this.castNodeTo(s, "DeclareOpaqueType"), s;
    }
    flowParseDeclareInterface(r) {
      return this.next(), this.flowParseInterfaceish(r, !1), this.finishNode(r, "DeclareInterface");
    }
    flowParseInterfaceish(r, s) {
      if (r.id = this.flowParseRestrictedIdentifier(!s, !0), this.scope.declareName(r.id.name, s ? 17 : 8201, r.id.loc.start), this.match(47) ?
      r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (!s && this.eat(12));
      if (s) {
        if (r.implements = [], r.mixins = [], this.eatContextual(117))
          do
            r.mixins.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
        if (this.eatContextual(113))
          do
            r.implements.push(this.flowParseInterfaceExtends());
          while (this.eat(12));
      }
      r.body = this.flowParseObjectType({
        allowStatic: s,
        allowExact: !1,
        allowSpread: !1,
        allowProto: s,
        allowInexact: !1
      });
    }
    flowParseInterfaceExtends() {
      let r = this.startNode();
      return r.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? r.typeParameters = this.flowParseTypeParameterInstantiation() :
      r.typeParameters = null, this.finishNode(r, "InterfaceExtends");
    }
    flowParseInterface(r) {
      return this.flowParseInterfaceish(r, !1), this.finishNode(r, "InterfaceDeclaration");
    }
    checkNotUnderscore(r) {
      r === "_" && this.raise(le.UnexpectedReservedUnderscore, this.state.startLoc);
    }
    checkReservedType(r, s, n) {
      tH.has(r) && this.raise(n ? le.AssignReservedType : le.UnexpectedReservedType, s, {
        reservedType: r
      });
    }
    flowParseRestrictedIdentifier(r, s) {
      return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(r);
    }
    flowParseTypeAlias(r) {
      return r.id = this.flowParseRestrictedIdentifier(!1, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.start), this.match(47) ? r.
      typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.right = this.flowParseTypeInitialiser(29), this.
      semicolon(), this.finishNode(r, "TypeAlias");
    }
    flowParseOpaqueType(r, s) {
      return this.expectContextual(130), r.id = this.flowParseRestrictedIdentifier(!0, !0), this.scope.declareName(r.id.name, 8201, r.id.loc.
      start), this.match(47) ? r.typeParameters = this.flowParseTypeParameterDeclaration() : r.typeParameters = null, r.supertype = null, this.
      match(14) && (r.supertype = this.flowParseTypeInitialiser(14)), r.impltype = null, s || (r.impltype = this.flowParseTypeInitialiser(29)),
      this.semicolon(), this.finishNode(r, "OpaqueType");
    }
    flowParseTypeParameter(r = !1) {
      let s = this.state.startLoc, n = this.startNode(), a = this.flowParseVariance(), o = this.flowParseTypeAnnotatableIdentifier();
      return n.name = o.name, n.variance = a, n.bound = o.typeAnnotation, this.match(29) ? (this.eat(29), n.default = this.flowParseType()) :
      r && this.raise(le.MissingTypeParamDefault, s), this.finishNode(n, "TypeParameter");
    }
    flowParseTypeParameterDeclaration() {
      let r = this.state.inType, s = this.startNode();
      s.params = [], this.state.inType = !0, this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let n = !1;
      do {
        let a = this.flowParseTypeParameter(n);
        s.params.push(a), a.default && (n = !0), this.match(48) || this.expect(12);
      } while (!this.match(48));
      return this.expect(48), this.state.inType = r, this.finishNode(s, "TypeParameterDeclaration");
    }
    flowInTopLevelContext(r) {
      if (this.curContext() !== _e.brace) {
        let s = this.state.context;
        this.state.context = [s[0]];
        try {
          return r();
        } finally {
          this.state.context = s;
        }
      } else
        return r();
    }
    flowParseTypeParameterInstantiationInExpression() {
      if (this.reScan_lt() === 47)
        return this.flowParseTypeParameterInstantiation();
    }
    flowParseTypeParameterInstantiation() {
      let r = this.startNode(), s = this.state.inType;
      return this.state.inType = !0, r.params = [], this.flowInTopLevelContext(() => {
        this.expect(47);
        let n = this.state.noAnonFunctionType;
        for (this.state.noAnonFunctionType = !1; !this.match(48); )
          r.params.push(this.flowParseType()), this.match(48) || this.expect(12);
        this.state.noAnonFunctionType = n;
      }), this.state.inType = s, !this.state.inType && this.curContext() === _e.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(
      r, "TypeParameterInstantiation");
    }
    flowParseTypeParameterInstantiationCallOrNew() {
      if (this.reScan_lt() !== 47) return null;
      let r = this.startNode(), s = this.state.inType;
      for (r.params = [], this.state.inType = !0, this.expect(47); !this.match(48); )
        r.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
      return this.expect(48), this.state.inType = s, this.finishNode(r, "TypeParameterInstantiation");
    }
    flowParseInterfaceType() {
      let r = this.startNode();
      if (this.expectContextual(129), r.extends = [], this.eat(81))
        do
          r.extends.push(this.flowParseInterfaceExtends());
        while (this.eat(12));
      return r.body = this.flowParseObjectType({
        allowStatic: !1,
        allowExact: !1,
        allowSpread: !1,
        allowProto: !1,
        allowInexact: !1
      }), this.finishNode(r, "InterfaceTypeAnnotation");
    }
    flowParseObjectPropertyKey() {
      return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(!0);
    }
    flowParseObjectTypeIndexer(r, s, n) {
      return r.static = s, this.lookahead().type === 14 ? (r.id = this.flowParseObjectPropertyKey(), r.key = this.flowParseTypeInitialiser()) :
      (r.id = null, r.key = this.flowParseType()), this.expect(3), r.value = this.flowParseTypeInitialiser(), r.variance = n, this.finishNode(
      r, "ObjectTypeIndexer");
    }
    flowParseObjectTypeInternalSlot(r, s) {
      return r.static = s, r.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (r.method =
      !0, r.optional = !1, r.value = this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start))) : (r.method = !1, this.eat(17) && (r.
      optional = !0), r.value = this.flowParseTypeInitialiser()), this.finishNode(r, "ObjectTypeInternalSlot");
    }
    flowParseObjectTypeMethodish(r) {
      for (r.params = [], r.rest = null, r.typeParameters = null, r.this = null, this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()),
      this.expect(10), this.match(78) && (r.this = this.flowParseFunctionTypeParam(!0), r.this.name = null, this.match(11) || this.expect(12)); !this.
      match(11) && !this.match(21); )
        r.params.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (r.rest = this.flowParseFunctionTypeParam(!1)), this.expect(11), r.returnType = this.flowParseTypeInitialiser(),
      this.finishNode(r, "FunctionTypeAnnotation");
    }
    flowParseObjectTypeCallProperty(r, s) {
      let n = this.startNode();
      return r.static = s, r.value = this.flowParseObjectTypeMethodish(n), this.finishNode(r, "ObjectTypeCallProperty");
    }
    flowParseObjectType({
      allowStatic: r,
      allowExact: s,
      allowSpread: n,
      allowProto: a,
      allowInexact: o
    }) {
      let l = this.state.inType;
      this.state.inType = !0;
      let u = this.startNode();
      u.callProperties = [], u.properties = [], u.indexers = [], u.internalSlots = [];
      let c, p, f = !1;
      for (s && this.match(6) ? (this.expect(6), c = 9, p = !0) : (this.expect(5), c = 8, p = !1), u.exact = p; !this.match(c); ) {
        let b = !1, T = null, d = null, g = this.startNode();
        if (a && this.isContextual(118)) {
          let _ = this.lookahead();
          _.type !== 14 && _.type !== 17 && (this.next(), T = this.state.startLoc, r = !1);
        }
        if (r && this.isContextual(106)) {
          let _ = this.lookahead();
          _.type !== 14 && _.type !== 17 && (this.next(), b = !0);
        }
        let E = this.flowParseVariance();
        if (this.eat(0))
          T != null && this.unexpected(T), this.eat(0) ? (E && this.unexpected(E.loc.start), u.internalSlots.push(this.flowParseObjectTypeInternalSlot(
          g, b))) : u.indexers.push(this.flowParseObjectTypeIndexer(g, b, E));
        else if (this.match(10) || this.match(47))
          T != null && this.unexpected(T), E && this.unexpected(E.loc.start), u.callProperties.push(this.flowParseObjectTypeCallProperty(g, b));
        else {
          let _ = "init";
          if (this.isContextual(99) || this.isContextual(104)) {
            let k = this.lookahead();
            dx(k.type) && (_ = this.state.value, this.next());
          }
          let N = this.flowParseObjectTypeProperty(g, b, T, E, _, n, o ?? !p);
          N === null ? (f = !0, d = this.state.lastTokStartLoc) : u.properties.push(N);
        }
        this.flowObjectTypeSemicolon(), d && !this.match(8) && !this.match(9) && this.raise(le.UnexpectedExplicitInexactInObject, d);
      }
      this.expect(c), n && (u.inexact = f);
      let h = this.finishNode(u, "ObjectTypeAnnotation");
      return this.state.inType = l, h;
    }
    flowParseObjectTypeProperty(r, s, n, a, o, l, u) {
      if (this.eat(21))
        return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (l ? u || this.raise(le.InexactInsideExact, this.state.lastTokStartLoc) :
        this.raise(le.InexactInsideNonObject, this.state.lastTokStartLoc), a && this.raise(le.InexactVariance, a), null) : (l || this.raise(
        le.UnexpectedSpreadType, this.state.lastTokStartLoc), n != null && this.unexpected(n), a && this.raise(le.SpreadVariance, a), r.argument =
        this.flowParseType(), this.finishNode(r, "ObjectTypeSpreadProperty"));
      {
        r.key = this.flowParseObjectPropertyKey(), r.static = s, r.proto = n != null, r.kind = o;
        let c = !1;
        return this.match(47) || this.match(10) ? (r.method = !0, n != null && this.unexpected(n), a && this.unexpected(a.loc.start), r.value =
        this.flowParseObjectTypeMethodish(this.startNodeAt(r.loc.start)), (o === "get" || o === "set") && this.flowCheckGetterSetterParams(r),
        !l && r.key.name === "constructor" && r.value.this && this.raise(le.ThisParamBannedInConstructor, r.value.this)) : (o !== "init" && this.
        unexpected(), r.method = !1, this.eat(17) && (c = !0), r.value = this.flowParseTypeInitialiser(), r.variance = a), r.optional = c, this.
        finishNode(r, "ObjectTypeProperty");
      }
    }
    flowCheckGetterSetterParams(r) {
      let s = r.kind === "get" ? 0 : 1, n = r.value.params.length + (r.value.rest ? 1 : 0);
      r.value.this && this.raise(r.kind === "get" ? le.GetterMayNotHaveThisParam : le.SetterMayNotHaveThisParam, r.value.this), n !== s && this.
      raise(r.kind === "get" ? O.BadGetterArity : O.BadSetterArity, r), r.kind === "set" && r.value.rest && this.raise(O.BadSetterRestParameter,
      r);
    }
    flowObjectTypeSemicolon() {
      !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
    }
    flowParseQualifiedTypeIdentifier(r, s) {
      r ?? (r = this.state.startLoc);
      let n = s || this.flowParseRestrictedIdentifier(!0);
      for (; this.eat(16); ) {
        let a = this.startNodeAt(r);
        a.qualification = n, a.id = this.flowParseRestrictedIdentifier(!0), n = this.finishNode(a, "QualifiedTypeIdentifier");
      }
      return n;
    }
    flowParseGenericType(r, s) {
      let n = this.startNodeAt(r);
      return n.typeParameters = null, n.id = this.flowParseQualifiedTypeIdentifier(r, s), this.match(47) && (n.typeParameters = this.flowParseTypeParameterInstantiation()),
      this.finishNode(n, "GenericTypeAnnotation");
    }
    flowParseTypeofType() {
      let r = this.startNode();
      return this.expect(87), r.argument = this.flowParsePrimaryType(), this.finishNode(r, "TypeofTypeAnnotation");
    }
    flowParseTupleType() {
      let r = this.startNode();
      for (r.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (r.types.push(this.flowParseType()), !this.match(
      3)); )
        this.expect(12);
      return this.expect(3), this.finishNode(r, "TupleTypeAnnotation");
    }
    flowParseFunctionTypeParam(r) {
      let s = null, n = !1, a = null, o = this.startNode(), l = this.lookahead(), u = this.state.type === 78;
      return l.type === 14 || l.type === 17 ? (u && !r && this.raise(le.ThisParamMustBeFirst, o), s = this.parseIdentifier(u), this.eat(17) &&
      (n = !0, u && this.raise(le.ThisParamMayNotBeOptional, o)), a = this.flowParseTypeInitialiser()) : a = this.flowParseType(), o.name = s,
      o.optional = n, o.typeAnnotation = a, this.finishNode(o, "FunctionTypeParam");
    }
    reinterpretTypeAsFunctionTypeParam(r) {
      let s = this.startNodeAt(r.loc.start);
      return s.name = null, s.optional = !1, s.typeAnnotation = r, this.finishNode(s, "FunctionTypeParam");
    }
    flowParseFunctionTypeParams(r = []) {
      let s = null, n = null;
      for (this.match(78) && (n = this.flowParseFunctionTypeParam(!0), n.name = null, this.match(11) || this.expect(12)); !this.match(11) &&
      !this.match(21); )
        r.push(this.flowParseFunctionTypeParam(!1)), this.match(11) || this.expect(12);
      return this.eat(21) && (s = this.flowParseFunctionTypeParam(!1)), {
        params: r,
        rest: s,
        _this: n
      };
    }
    flowIdentToTypeAnnotation(r, s, n) {
      switch (n.name) {
        case "any":
          return this.finishNode(s, "AnyTypeAnnotation");
        case "bool":
        case "boolean":
          return this.finishNode(s, "BooleanTypeAnnotation");
        case "mixed":
          return this.finishNode(s, "MixedTypeAnnotation");
        case "empty":
          return this.finishNode(s, "EmptyTypeAnnotation");
        case "number":
          return this.finishNode(s, "NumberTypeAnnotation");
        case "string":
          return this.finishNode(s, "StringTypeAnnotation");
        case "symbol":
          return this.finishNode(s, "SymbolTypeAnnotation");
        default:
          return this.checkNotUnderscore(n.name), this.flowParseGenericType(r, n);
      }
    }
    flowParsePrimaryType() {
      let r = this.state.startLoc, s = this.startNode(), n, a, o = !1, l = this.state.noAnonFunctionType;
      switch (this.state.type) {
        case 5:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !1,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !0
          });
        case 6:
          return this.flowParseObjectType({
            allowStatic: !1,
            allowExact: !0,
            allowSpread: !0,
            allowProto: !1,
            allowInexact: !1
          });
        case 0:
          return this.state.noAnonFunctionType = !1, a = this.flowParseTupleType(), this.state.noAnonFunctionType = l, a;
        case 47: {
          let u = this.startNode();
          return u.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), n = this.flowParseFunctionTypeParams(), u.params =
          n.params, u.rest = n.rest, u.this = n._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), this.finishNode(
          u, "FunctionTypeAnnotation");
        }
        case 10: {
          let u = this.startNode();
          if (this.next(), !this.match(11) && !this.match(21))
            if (ke(this.state.type) || this.match(78)) {
              let c = this.lookahead().type;
              o = c !== 17 && c !== 14;
            } else
              o = !0;
          if (o) {
            if (this.state.noAnonFunctionType = !1, a = this.flowParseType(), this.state.noAnonFunctionType = l, this.state.noAnonFunctionType ||
            !(this.match(12) || this.match(11) && this.lookahead().type === 19))
              return this.expect(11), a;
            this.eat(12);
          }
          return a ? n = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(a)]) : n = this.flowParseFunctionTypeParams(),
          u.params = n.params, u.rest = n.rest, u.this = n._this, this.expect(11), this.expect(19), u.returnType = this.flowParseType(), u.typeParameters =
          null, this.finishNode(u, "FunctionTypeAnnotation");
        }
        case 134:
          return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
        case 85:
        case 86:
          return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
        case 53:
          if (this.state.value === "-") {
            if (this.next(), this.match(135))
              return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
            if (this.match(136))
              return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
            throw this.raise(le.UnexpectedSubtractionOperand, this.state.startLoc);
          }
          throw this.unexpected();
        case 135:
          return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
        case 136:
          return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
        case 88:
          return this.next(), this.finishNode(s, "VoidTypeAnnotation");
        case 84:
          return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
        case 78:
          return this.next(), this.finishNode(s, "ThisTypeAnnotation");
        case 55:
          return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
        case 87:
          return this.flowParseTypeofType();
        default:
          if (H0(this.state.type)) {
            let u = Qs(this.state.type);
            return this.next(), super.createIdentifier(s, u);
          } else if (ke(this.state.type))
            return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(r, s, this.parseIdentifier());
      }
      throw this.unexpected();
    }
    flowParsePostfixType() {
      let r = this.state.startLoc, s = this.flowParsePrimaryType(), n = !1;
      for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
        let a = this.startNodeAt(r), o = this.eat(18);
        n = n || o, this.expect(0), !o && this.match(3) ? (a.elementType = s, this.next(), s = this.finishNode(a, "ArrayTypeAnnotation")) : (a.
        objectType = s, a.indexType = this.flowParseType(), this.expect(3), n ? (a.optional = o, s = this.finishNode(a, "OptionalIndexedAcce\
ssType")) : s = this.finishNode(a, "IndexedAccessType"));
      }
      return s;
    }
    flowParsePrefixType() {
      let r = this.startNode();
      return this.eat(17) ? (r.typeAnnotation = this.flowParsePrefixType(), this.finishNode(r, "NullableTypeAnnotation")) : this.flowParsePostfixType();
    }
    flowParseAnonFunctionWithoutParens() {
      let r = this.flowParsePrefixType();
      if (!this.state.noAnonFunctionType && this.eat(19)) {
        let s = this.startNodeAt(r.loc.start);
        return s.params = [this.reinterpretTypeAsFunctionTypeParam(r)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.
        typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
      }
      return r;
    }
    flowParseIntersectionType() {
      let r = this.startNode();
      this.eat(45);
      let s = this.flowParseAnonFunctionWithoutParens();
      for (r.types = [s]; this.eat(45); )
        r.types.push(this.flowParseAnonFunctionWithoutParens());
      return r.types.length === 1 ? s : this.finishNode(r, "IntersectionTypeAnnotation");
    }
    flowParseUnionType() {
      let r = this.startNode();
      this.eat(43);
      let s = this.flowParseIntersectionType();
      for (r.types = [s]; this.eat(43); )
        r.types.push(this.flowParseIntersectionType());
      return r.types.length === 1 ? s : this.finishNode(r, "UnionTypeAnnotation");
    }
    flowParseType() {
      let r = this.state.inType;
      this.state.inType = !0;
      let s = this.flowParseUnionType();
      return this.state.inType = r, s;
    }
    flowParseTypeOrImplicitInstantiation() {
      if (this.state.type === 132 && this.state.value === "_") {
        let r = this.state.startLoc, s = this.parseIdentifier();
        return this.flowParseGenericType(r, s);
      } else
        return this.flowParseType();
    }
    flowParseTypeAnnotation() {
      let r = this.startNode();
      return r.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(r, "TypeAnnotation");
    }
    flowParseTypeAnnotatableIdentifier(r) {
      let s = r ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
      return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    flowParseVariance() {
      let r = null;
      return this.match(53) ? (r = this.startNode(), this.state.value === "+" ? r.kind = "plus" : r.kind = "minus", this.next(), this.finishNode(
      r, "Variance")) : r;
    }
    parseFunctionBody(r, s, n = !1) {
      if (s) {
        this.forwardNoArrowParamsConversionAt(r, () => super.parseFunctionBody(r, !0, n));
        return;
      }
      super.parseFunctionBody(r, !1, n);
    }
    parseFunctionBodyAndFinish(r, s, n = !1) {
      if (this.match(14)) {
        let a = this.startNode();
        [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.returnType = a.typeAnnotation ? this.finishNode(a, "\
TypeAnnotation") : null;
      }
      return super.parseFunctionBodyAndFinish(r, s, n);
    }
    parseStatementLike(r) {
      if (this.state.strict && this.isContextual(129)) {
        let n = this.lookahead();
        if (Fr(n.type)) {
          let a = this.startNode();
          return this.next(), this.flowParseInterface(a);
        }
      } else if (this.isContextual(126)) {
        let n = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(n);
      }
      let s = super.parseStatementLike(r);
      return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
    }
    parseExpressionStatement(r, s, n) {
      if (s.type === "Identifier") {
        if (s.name === "declare") {
          if (this.match(80) || ke(this.state.type) || this.match(68) || this.match(74) || this.match(82))
            return this.flowParseDeclare(r);
        } else if (ke(this.state.type)) {
          if (s.name === "interface")
            return this.flowParseInterface(r);
          if (s.name === "type")
            return this.flowParseTypeAlias(r);
          if (s.name === "opaque")
            return this.flowParseOpaqueType(r, !1);
        }
      }
      return super.parseExpressionStatement(r, s, n);
    }
    shouldParseExportDeclaration() {
      let {
        type: r
      } = this.state;
      return r === 126 || rx(r) ? !this.state.containsEsc : super.shouldParseExportDeclaration();
    }
    isExportDefaultSpecifier() {
      let {
        type: r
      } = this.state;
      return r === 126 || rx(r) ? this.state.containsEsc : super.isExportDefaultSpecifier();
    }
    parseExportDefaultExpression() {
      if (this.isContextual(126)) {
        let r = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(r);
      }
      return super.parseExportDefaultExpression();
    }
    parseConditional(r, s, n) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let h = this.lookaheadCharCode();
        if (h === 44 || h === 61 || h === 58 || h === 41)
          return this.setOptionalParametersError(n), r;
      }
      this.expect(17);
      let a = this.state.clone(), o = this.state.noArrowAt, l = this.startNodeAt(s), {
        consequent: u,
        failed: c
      } = this.tryParseConditionalConsequent(), [p, f] = this.getArrowLikeExpressions(u);
      if (c || f.length > 0) {
        let h = [...o];
        if (f.length > 0) {
          this.state = a, this.state.noArrowAt = h;
          for (let b = 0; b < f.length; b++)
            h.push(f[b].start);
          ({
            consequent: u,
            failed: c
          } = this.tryParseConditionalConsequent()), [p, f] = this.getArrowLikeExpressions(u);
        }
        c && p.length > 1 && this.raise(le.AmbiguousConditionalArrow, a.startLoc), c && p.length === 1 && (this.state = a, h.push(p[0].start),
        this.state.noArrowAt = h, {
          consequent: u,
          failed: c
        } = this.tryParseConditionalConsequent());
      }
      return this.getArrowLikeExpressions(u, !0), this.state.noArrowAt = o, this.expect(14), l.test = r, l.consequent = u, l.alternate = this.
      forwardNoArrowParamsConversionAt(l, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(l, "ConditionalExpression");
    }
    tryParseConditionalConsequent() {
      this.state.noArrowParamsConversionAt.push(this.state.start);
      let r = this.parseMaybeAssignAllowIn(), s = !this.match(14);
      return this.state.noArrowParamsConversionAt.pop(), {
        consequent: r,
        failed: s
      };
    }
    getArrowLikeExpressions(r, s) {
      let n = [r], a = [];
      for (; n.length !== 0; ) {
        let o = n.pop();
        o.type === "ArrowFunctionExpression" && o.body.type !== "BlockStatement" ? (o.typeParameters || !o.returnType ? this.finishArrowValidation(
        o) : a.push(o), n.push(o.body)) : o.type === "ConditionalExpression" && (n.push(o.consequent), n.push(o.alternate));
      }
      return s ? (a.forEach((o) => this.finishArrowValidation(o)), [a, []]) : nH(a, (o) => o.params.every((l) => this.isAssignable(l, !0)));
    }
    finishArrowValidation(r) {
      var s;
      this.toAssignableList(r.params, (s = r.extra) == null ? void 0 : s.trailingCommaLoc, !1), this.scope.enter(518), super.checkParams(r, !1,
      !0), this.scope.exit();
    }
    forwardNoArrowParamsConversionAt(r, s) {
      let n;
      return this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? (this.state.noArrowParamsConversionAt.push(this.
      state.start), n = s(), this.state.noArrowParamsConversionAt.pop()) : n = s(), n;
    }
    parseParenItem(r, s) {
      let n = super.parseParenItem(r, s);
      if (this.eat(17) && (n.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(s);
        return a.expression = n, a.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(a, "TypeCastExpression");
      }
      return n;
    }
    assertModuleNodeAllowed(r) {
      r.type === "ImportDeclaration" && (r.importKind === "type" || r.importKind === "typeof") || r.type === "ExportNamedDeclaration" && r.exportKind ===
      "type" || r.type === "ExportAllDeclaration" && r.exportKind === "type" || super.assertModuleNodeAllowed(r);
    }
    parseExportDeclaration(r) {
      if (this.isContextual(130)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.match(5) ? (r.specifiers = this.parseExportSpecifiers(!0), super.parseExportFrom(r), null) : this.flowParseTypeAlias(
        s);
      } else if (this.isContextual(131)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseOpaqueType(s, !1);
      } else if (this.isContextual(129)) {
        r.exportKind = "type";
        let s = this.startNode();
        return this.next(), this.flowParseInterface(s);
      } else if (this.isContextual(126)) {
        r.exportKind = "value";
        let s = this.startNode();
        return this.next(), this.flowParseEnumDeclaration(s);
      } else
        return super.parseExportDeclaration(r);
    }
    eatExportStar(r) {
      return super.eatExportStar(r) ? !0 : this.isContextual(130) && this.lookahead().type === 55 ? (r.exportKind = "type", this.next(), this.
      next(), !0) : !1;
    }
    maybeParseExportNamespaceSpecifier(r) {
      let {
        startLoc: s
      } = this.state, n = super.maybeParseExportNamespaceSpecifier(r);
      return n && r.exportKind === "type" && this.unexpected(s), n;
    }
    parseClassId(r, s, n) {
      super.parseClassId(r, s, n), this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration());
    }
    parseClassMember(r, s, n) {
      let {
        startLoc: a
      } = this.state;
      if (this.isContextual(125)) {
        if (super.parseClassMemberFromModifier(r, s))
          return;
        s.declare = !0;
      }
      super.parseClassMember(r, s, n), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "Property\
Definition" ? this.raise(le.DeclareClassElement, a) : s.value && this.raise(le.DeclareClassFieldInitializer, s.value));
    }
    isIterator(r) {
      return r === "iterator" || r === "asyncIterator";
    }
    readIterator() {
      let r = super.readWord1(), s = "@@" + r;
      (!this.isIterator(r) || !this.state.inType) && this.raise(O.InvalidIdentifier, this.state.curPosition(), {
        identifierName: s
      }), this.finishToken(132, s);
    }
    getTokenFromCode(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      r === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (r === 62 || r === 60) ? this.finishOp(r === 62 ? 48 : 47, 1) : this.
      state.inType && r === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : QY(r, s, this.input.charCodeAt(this.state.pos + 2)) ?
      (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(r);
    }
    isAssignable(r, s) {
      return r.type === "TypeCastExpression" ? this.isAssignable(r.expression, s) : super.isAssignable(r, s);
    }
    toAssignable(r, s = !1) {
      !s && r.type === "AssignmentExpression" && r.left.type === "TypeCastExpression" && (r.left = this.typeCastToParameter(r.left)), super.
      toAssignable(r, s);
    }
    toAssignableList(r, s, n) {
      for (let a = 0; a < r.length; a++) {
        let o = r[a];
        o?.type === "TypeCastExpression" && (r[a] = this.typeCastToParameter(o));
      }
      super.toAssignableList(r, s, n);
    }
    toReferencedList(r, s) {
      for (let a = 0; a < r.length; a++) {
        var n;
        let o = r[a];
        o && o.type === "TypeCastExpression" && !((n = o.extra) != null && n.parenthesized) && (r.length > 1 || !s) && this.raise(le.TypeCastInPattern,
        o.typeAnnotation);
      }
      return r;
    }
    parseArrayLike(r, s, n) {
      let a = super.parseArrayLike(r, s, n);
      return n != null && !this.state.maybeInArrowParameters && this.toReferencedList(a.elements), a;
    }
    isValidLVal(r, s, n, a) {
      return r === "TypeCastExpression" || super.isValidLVal(r, s, n, a);
    }
    parseClassProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return this.match(14) && (r.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(14) || super.isClassProperty();
    }
    isNonstaticConstructor(r) {
      return !this.match(14) && super.isNonstaticConstructor(r);
    }
    pushClassMethod(r, s, n, a, o, l) {
      if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassMethod(r, s, n, a, o, l), s.params && o) {
        let u = s.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(le.ThisParamBannedInConstructor, s);
      } else if (s.type === "MethodDefinition" && o && s.value.params) {
        let u = s.value.params;
        u.length > 0 && this.isThisParam(u[0]) && this.raise(le.ThisParamBannedInConstructor, s);
      }
    }
    pushClassPrivateMethod(r, s, n, a) {
      s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()),
      super.pushClassPrivateMethod(r, s, n, a);
    }
    parseClassSuper(r) {
      if (super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression()),
      this.isContextual(113)) {
        this.next();
        let s = r.implements = [];
        do {
          let n = this.startNode();
          n.id = this.flowParseRestrictedIdentifier(!0), this.match(47) ? n.typeParameters = this.flowParseTypeParameterInstantiation() : n.
          typeParameters = null, s.push(this.finishNode(n, "ClassImplements"));
        } while (this.eat(12));
      }
    }
    checkGetterSetterParams(r) {
      super.checkGetterSetterParams(r);
      let s = this.getObjectOrClassMethodParams(r);
      if (s.length > 0) {
        let n = s[0];
        this.isThisParam(n) && r.kind === "get" ? this.raise(le.GetterMayNotHaveThisParam, n) : this.isThisParam(n) && this.raise(le.SetterMayNotHaveThisParam,
        n);
      }
    }
    parsePropertyNamePrefixOperator(r) {
      r.variance = this.flowParseVariance();
    }
    parseObjPropValue(r, s, n, a, o, l, u) {
      r.variance && this.unexpected(r.variance.loc.start), delete r.variance;
      let c;
      this.match(47) && !l && (c = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
      let p = super.parseObjPropValue(r, s, n, a, o, l, u);
      return c && ((p.value || p).typeParameters = c), p;
    }
    parseFunctionParamType(r) {
      return this.eat(17) && (r.type !== "Identifier" && this.raise(le.PatternIsOptional, r), this.isThisParam(r) && this.raise(le.ThisParamMayNotBeOptional,
      r), r.optional = !0), this.match(14) ? r.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(r) && this.raise(le.ThisParamAnnotationRequired,
      r), this.match(29) && this.isThisParam(r) && this.raise(le.ThisParamNoDefault, r), this.resetEndLocation(r), r;
    }
    parseMaybeDefault(r, s) {
      let n = super.parseMaybeDefault(r, s);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(le.TypeBeforeInitializer,
      n.typeAnnotation), n;
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(le.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    parseImportSpecifierLocal(r, s, n) {
      s.local = sx(r) ? this.flowParseRestrictedIdentifier(!0, !0) : this.parseIdentifier(), r.specifiers.push(this.finishImportSpecifier(s,
      n));
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        if (!r) return !0;
        let s = this.lookaheadCharCode();
        return s === 123 || s === 42;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, n, a) {
      if (super.applyImportPhase(r, s, n, a), s) {
        if (!n && this.match(65))
          return;
        r.exportKind = n === "type" ? n : "value";
      } else
        n === "type" && this.match(55) && this.unexpected(), r.importKind = n === "type" || n === "typeof" ? n : "value";
    }
    parseImportSpecifier(r, s, n, a, o) {
      let l = r.imported, u = null;
      l.type === "Identifier" && (l.name === "type" ? u = "type" : l.name === "typeof" && (u = "typeof"));
      let c = !1;
      if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
        let f = this.parseIdentifier(!0);
        u !== null && !Fr(this.state.type) ? (r.imported = f, r.importKind = u, r.local = this.cloneIdentifier(f)) : (r.imported = l, r.importKind =
        null, r.local = this.parseIdentifier());
      } else {
        if (u !== null && Fr(this.state.type))
          r.imported = this.parseIdentifier(!0), r.importKind = u;
        else {
          if (s)
            throw this.raise(O.ImportBindingIsString, r, {
              importName: l.value
            });
          r.imported = l, r.importKind = null;
        }
        this.eatContextual(93) ? r.local = this.parseIdentifier() : (c = !0, r.local = this.cloneIdentifier(r.imported));
      }
      let p = sx(r);
      return n && p && this.raise(le.ImportTypeShorthandOnlyInPureImport, r), (n || p) && this.checkReservedType(r.local.name, r.local.loc.start,
      !0), c && !n && !p && this.checkReservedWord(r.local.name, r.loc.start, !0, !0), this.finishImportSpecifier(r, "ImportSpecifier");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 78:
          return this.parseIdentifier(!0);
        default:
          return super.parseBindingAtom();
      }
    }
    parseFunctionParams(r, s) {
      let n = r.kind;
      n !== "get" && n !== "set" && this.match(47) && (r.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(
      r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), this.match(14) && (r.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      if (this.match(14)) {
        let n = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = !0, r.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = n;
      }
      return super.parseAsyncArrowFromCallExpression(r, s);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    parseMaybeAssign(r, s) {
      var n;
      let a = null, o;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (a = this.state.clone(), o = this.tryParse(() => super.parseMaybeAssign(r, s), a), !o.error) return o.node;
        let {
          context: c
        } = this.state, p = c[c.length - 1];
        (p === _e.j_oTag || p === _e.j_expr) && c.pop();
      }
      if ((n = o) != null && n.error || this.match(47)) {
        var l, u;
        a = a || this.state.clone();
        let c, p = this.tryParse((h) => {
          var b;
          c = this.flowParseTypeParameterDeclaration();
          let T = this.forwardNoArrowParamsConversionAt(c, () => {
            let g = super.parseMaybeAssign(r, s);
            return this.resetStartLocationFromNode(g, c), g;
          });
          (b = T.extra) != null && b.parenthesized && h();
          let d = this.maybeUnwrapTypeCastExpression(T);
          return d.type !== "ArrowFunctionExpression" && h(), d.typeParameters = c, this.resetStartLocationFromNode(d, c), T;
        }, a), f = null;
        if (p.node && this.maybeUnwrapTypeCastExpression(p.node).type === "ArrowFunctionExpression") {
          if (!p.error && !p.aborted)
            return p.node.async && this.raise(le.UnexpectedTypeParameterBeforeAsyncArrowFunction, c), p.node;
          f = p.node;
        }
        if ((l = o) != null && l.node)
          return this.state = o.failState, o.node;
        if (f)
          return this.state = p.failState, f;
        throw (u = o) != null && u.thrown ? o.error : p.thrown ? p.error : this.raise(le.UnexpectedTokenAfterTypeParameter, c);
      }
      return super.parseMaybeAssign(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse(() => {
          let n = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = !0;
          let a = this.startNode();
          return [a.typeAnnotation, r.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = n, this.canInsertSemicolon() &&
          this.unexpected(), this.match(19) || this.unexpected(), a;
        });
        if (s.thrown) return null;
        s.error && (this.state = s.failState), r.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
      }
      return super.parseArrow(r);
    }
    shouldParseArrow(r) {
      return this.match(14) || super.shouldParseArrow(r);
    }
    setArrowFunctionParameters(r, s) {
      this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)) ? r.params = s : super.setArrowFunctionParameters(r, s);
    }
    checkParams(r, s, n, a = !0) {
      if (!(n && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(r.start)))) {
        for (let o = 0; o < r.params.length; o++)
          this.isThisParam(r.params[o]) && o > 0 && this.raise(le.ThisParamMustBeFirst, r.params[o]);
        super.checkParams(r, s, n, a);
      }
    }
    parseParenAndDistinguishExpression(r) {
      return super.parseParenAndDistinguishExpression(r && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
    }
    parseSubscripts(r, s, n) {
      if (r.type === "Identifier" && r.name === "async" && this.state.noArrowAt.includes(s.index)) {
        this.next();
        let a = this.startNodeAt(s);
        a.callee = r, a.arguments = super.parseCallExpressionArguments(), r = this.finishNode(a, "CallExpression");
      } else if (r.type === "Identifier" && r.name === "async" && this.match(47)) {
        let a = this.state.clone(), o = this.tryParse((u) => this.parseAsyncArrowWithTypeParameters(s) || u(), a);
        if (!o.error && !o.aborted) return o.node;
        let l = this.tryParse(() => super.parseSubscripts(r, s, n), a);
        if (l.node && !l.error) return l.node;
        if (o.node)
          return this.state = o.failState, o.node;
        if (l.node)
          return this.state = l.failState, l.node;
        throw o.error || l.error;
      }
      return super.parseSubscripts(r, s, n);
    }
    parseSubscript(r, s, n, a) {
      if (this.match(18) && this.isLookaheadToken_lt()) {
        if (a.optionalChainMember = !0, n)
          return a.stop = !0, r;
        this.next();
        let o = this.startNodeAt(s);
        return o.callee = r, o.typeArguments = this.flowParseTypeParameterInstantiationInExpression(), this.expect(10), o.arguments = this.parseCallExpressionArguments(),
        o.optional = !0, this.finishCallExpression(o, !0);
      } else if (!n && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
        let o = this.startNodeAt(s);
        o.callee = r;
        let l = this.tryParse(() => (o.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), o.arguments = super.
        parseCallExpressionArguments(), a.optionalChainMember && (o.optional = !1), this.finishCallExpression(o, a.optionalChainMember)));
        if (l.node)
          return l.error && (this.state = l.failState), l.node;
      }
      return super.parseSubscript(r, s, n, a);
    }
    parseNewCallee(r) {
      super.parseNewCallee(r);
      let s = null;
      this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), r.typeArguments =
      s;
    }
    parseAsyncArrowWithTypeParameters(r) {
      let s = this.startNodeAt(r);
      if (this.parseFunctionParams(s, !1), !!this.parseArrow(s))
        return super.parseArrowExpression(s, void 0, !0);
    }
    readToken_mult_modulo(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 42 && s === 47 && this.state.hasFlowComment) {
        this.state.hasFlowComment = !1, this.state.pos += 2, this.nextToken();
        return;
      }
      super.readToken_mult_modulo(r);
    }
    readToken_pipe_amp(r) {
      let s = this.input.charCodeAt(this.state.pos + 1);
      if (r === 124 && s === 125) {
        this.finishOp(9, 2);
        return;
      }
      super.readToken_pipe_amp(r);
    }
    parseTopLevel(r, s) {
      let n = super.parseTopLevel(r, s);
      return this.state.hasFlowComment && this.raise(le.UnterminatedFlowComment, this.state.curPosition()), n;
    }
    skipBlockComment() {
      if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
        if (this.state.hasFlowComment)
          throw this.raise(le.NestedFlowComment, this.state.startLoc);
        this.hasFlowCommentCompletion();
        let r = this.skipFlowComment();
        r && (this.state.pos += r, this.state.hasFlowComment = !0);
        return;
      }
      return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
    }
    skipFlowComment() {
      let {
        pos: r
      } = this.state, s = 2;
      for (; [32, 9].includes(this.input.charCodeAt(r + s)); )
        s++;
      let n = this.input.charCodeAt(s + r), a = this.input.charCodeAt(s + r + 1);
      return n === 58 && a === 58 ? s + 2 : this.input.slice(s + r, s + r + 12) === "flow-include" ? s + 12 : n === 58 && a !== 58 ? s : !1;
    }
    hasFlowCommentCompletion() {
      if (this.input.indexOf("*/", this.state.pos) === -1)
        throw this.raise(O.UnterminatedComment, this.state.curPosition());
    }
    flowEnumErrorBooleanMemberNotInitialized(r, {
      enumName: s,
      memberName: n
    }) {
      this.raise(le.EnumBooleanMemberNotInitialized, r, {
        memberName: n,
        enumName: s
      });
    }
    flowEnumErrorInvalidMemberInitializer(r, s) {
      return this.raise(s.explicitType ? s.explicitType === "symbol" ? le.EnumInvalidMemberInitializerSymbolType : le.EnumInvalidMemberInitializerPrimaryType :
      le.EnumInvalidMemberInitializerUnknownType, r, s);
    }
    flowEnumErrorNumberMemberNotInitialized(r, s) {
      this.raise(le.EnumNumberMemberNotInitialized, r, s);
    }
    flowEnumErrorStringMemberInconsistentlyInitialized(r, s) {
      this.raise(le.EnumStringMemberInconsistentlyInitialized, r, s);
    }
    flowEnumMemberInit() {
      let r = this.state.startLoc, s = /* @__PURE__ */ i(() => this.match(12) || this.match(8), "endOfInit");
      switch (this.state.type) {
        case 135: {
          let n = this.parseNumericLiteral(this.state.value);
          return s() ? {
            type: "number",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 134: {
          let n = this.parseStringLiteral(this.state.value);
          return s() ? {
            type: "string",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        case 85:
        case 86: {
          let n = this.parseBooleanLiteral(this.match(85));
          return s() ? {
            type: "boolean",
            loc: n.loc.start,
            value: n
          } : {
            type: "invalid",
            loc: r
          };
        }
        default:
          return {
            type: "invalid",
            loc: r
          };
      }
    }
    flowEnumMemberRaw() {
      let r = this.state.startLoc, s = this.parseIdentifier(!0), n = this.eat(29) ? this.flowEnumMemberInit() : {
        type: "none",
        loc: r
      };
      return {
        id: s,
        init: n
      };
    }
    flowEnumCheckExplicitTypeMismatch(r, s, n) {
      let {
        explicitType: a
      } = s;
      a !== null && a !== n && this.flowEnumErrorInvalidMemberInitializer(r, s);
    }
    flowEnumMembers({
      enumName: r,
      explicitType: s
    }) {
      let n = /* @__PURE__ */ new Set(), a = {
        booleanMembers: [],
        numberMembers: [],
        stringMembers: [],
        defaultedMembers: []
      }, o = !1;
      for (; !this.match(8); ) {
        if (this.eat(21)) {
          o = !0;
          break;
        }
        let l = this.startNode(), {
          id: u,
          init: c
        } = this.flowEnumMemberRaw(), p = u.name;
        if (p === "")
          continue;
        /^[a-z]/.test(p) && this.raise(le.EnumInvalidMemberName, u, {
          memberName: p,
          suggestion: p[0].toUpperCase() + p.slice(1),
          enumName: r
        }), n.has(p) && this.raise(le.EnumDuplicateMemberName, u, {
          memberName: p,
          enumName: r
        }), n.add(p);
        let f = {
          enumName: r,
          explicitType: s,
          memberName: p
        };
        switch (l.id = u, c.type) {
          case "boolean": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "boolean"), l.init = c.value, a.booleanMembers.push(this.finishNode(l, "EnumBoo\
leanMember"));
            break;
          }
          case "number": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "number"), l.init = c.value, a.numberMembers.push(this.finishNode(l, "EnumNumbe\
rMember"));
            break;
          }
          case "string": {
            this.flowEnumCheckExplicitTypeMismatch(c.loc, f, "string"), l.init = c.value, a.stringMembers.push(this.finishNode(l, "EnumStrin\
gMember"));
            break;
          }
          case "invalid":
            throw this.flowEnumErrorInvalidMemberInitializer(c.loc, f);
          case "none":
            switch (s) {
              case "boolean":
                this.flowEnumErrorBooleanMemberNotInitialized(c.loc, f);
                break;
              case "number":
                this.flowEnumErrorNumberMemberNotInitialized(c.loc, f);
                break;
              default:
                a.defaultedMembers.push(this.finishNode(l, "EnumDefaultedMember"));
            }
        }
        this.match(8) || this.expect(12);
      }
      return {
        members: a,
        hasUnknownMembers: o
      };
    }
    flowEnumStringMembers(r, s, {
      enumName: n
    }) {
      if (r.length === 0)
        return s;
      if (s.length === 0)
        return r;
      if (s.length > r.length) {
        for (let a of r)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return s;
      } else {
        for (let a of s)
          this.flowEnumErrorStringMemberInconsistentlyInitialized(a, {
            enumName: n
          });
        return r;
      }
    }
    flowEnumParseExplicitType({
      enumName: r
    }) {
      if (!this.eatContextual(102)) return null;
      if (!ke(this.state.type))
        throw this.raise(le.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
          enumName: r
        });
      let {
        value: s
      } = this.state;
      return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(le.EnumInvalidExplicitType, this.
      state.startLoc, {
        enumName: r,
        invalidEnumType: s
      }), s;
    }
    flowEnumBody(r, s) {
      let n = s.name, a = s.loc.start, o = this.flowEnumParseExplicitType({
        enumName: n
      });
      this.expect(5);
      let {
        members: l,
        hasUnknownMembers: u
      } = this.flowEnumMembers({
        enumName: n,
        explicitType: o
      });
      switch (r.hasUnknownMembers = u, o) {
        case "boolean":
          return r.explicitType = !0, r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
        case "number":
          return r.explicitType = !0, r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
        case "string":
          return r.explicitType = !0, r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
            enumName: n
          }), this.expect(8), this.finishNode(r, "EnumStringBody");
        case "symbol":
          return r.members = l.defaultedMembers, this.expect(8), this.finishNode(r, "EnumSymbolBody");
        default: {
          let c = /* @__PURE__ */ i(() => (r.members = [], this.expect(8), this.finishNode(r, "EnumStringBody")), "empty");
          r.explicitType = !1;
          let p = l.booleanMembers.length, f = l.numberMembers.length, h = l.stringMembers.length, b = l.defaultedMembers.length;
          if (!p && !f && !h && !b)
            return c();
          if (!p && !f)
            return r.members = this.flowEnumStringMembers(l.stringMembers, l.defaultedMembers, {
              enumName: n
            }), this.expect(8), this.finishNode(r, "EnumStringBody");
          if (!f && !h && p >= b) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorBooleanMemberNotInitialized(T.loc.start, {
                enumName: n,
                memberName: T.id.name
              });
            return r.members = l.booleanMembers, this.expect(8), this.finishNode(r, "EnumBooleanBody");
          } else if (!p && !h && f >= b) {
            for (let T of l.defaultedMembers)
              this.flowEnumErrorNumberMemberNotInitialized(T.loc.start, {
                enumName: n,
                memberName: T.id.name
              });
            return r.members = l.numberMembers, this.expect(8), this.finishNode(r, "EnumNumberBody");
          } else
            return this.raise(le.EnumInconsistentMemberValues, a, {
              enumName: n
            }), c();
        }
      }
    }
    flowParseEnumDeclaration(r) {
      let s = this.parseIdentifier();
      return r.id = s, r.body = this.flowEnumBody(this.startNode(), s), this.finishNode(r, "EnumDeclaration");
    }
    jsxParseOpeningElementAfterName(r) {
      return this.shouldParseTypes() && (this.match(47) || this.match(51)) && (r.typeArguments = this.flowParseTypeParameterInstantiationInExpression()),
      super.jsxParseOpeningElementAfterName(r);
    }
    isLookaheadToken_lt() {
      let r = this.nextTokenStart();
      if (this.input.charCodeAt(r) === 60) {
        let s = this.input.charCodeAt(r + 1);
        return s !== 60 && s !== 61;
      }
      return !1;
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    maybeUnwrapTypeCastExpression(r) {
      return r.type === "TypeCastExpression" ? r.expression : r;
    }
  }, "flow"), oH = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    int: "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  }, lH = /\r\n|[\r\n\u2028\u2029]/, Rl = new RegExp(lH.source, "g");
  function Ci(e) {
    switch (e) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return !0;
      default:
        return !1;
    }
  }
  i(Ci, "isNewLine");
  function nx(e, t, r) {
    for (let s = t; s < r; s++)
      if (Ci(e.charCodeAt(s)))
        return !0;
    return !1;
  }
  i(nx, "hasNewLine");
  var m0 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, y0 = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
  function uH(e) {
    switch (e) {
      case 9:
      case 11:
      case 12:
      case 32:
      case 160:
      case 5760:
      case 8192:
      case 8193:
      case 8194:
      case 8195:
      case 8196:
      case 8197:
      case 8198:
      case 8199:
      case 8200:
      case 8201:
      case 8202:
      case 8239:
      case 8287:
      case 12288:
      case 65279:
        return !0;
      default:
        return !1;
    }
  }
  i(uH, "isWhitespace");
  var In = ss`jsx`({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: /* @__PURE__ */ i(({
      openingTagName: e
    }) => `Expected corresponding JSX closing tag for <${e}>.`, "MissingClosingTagElement"),
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: /* @__PURE__ */ i(({
      unexpected: e,
      HTMLEntity: t
    }) => `Unexpected token \`${e}\`. Did you mean \`${t}\` or \`{'${e}'}\`?`, "UnexpectedToken"),
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  });
  function Xs(e) {
    return e ? e.type === "JSXOpeningFragment" || e.type === "JSXClosingFragment" : !1;
  }
  i(Xs, "isFragment");
  function Ai(e) {
    if (e.type === "JSXIdentifier")
      return e.name;
    if (e.type === "JSXNamespacedName")
      return e.namespace.name + ":" + e.name.name;
    if (e.type === "JSXMemberExpression")
      return Ai(e.object) + "." + Ai(e.property);
    throw new Error("Node had unexpected type: " + e.type);
  }
  i(Ai, "getQualifiedJSXName");
  var cH = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "JSXParserMixin");
    }
    jsxReadToken() {
      let r = "", s = this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(In.UnterminatedJsxContent, this.state.startLoc);
        let n = this.input.charCodeAt(this.state.pos);
        switch (n) {
          case 60:
          case 123:
            if (this.state.pos === this.state.start) {
              n === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(143)) : super.getTokenFromCode(n);
              return;
            }
            r += this.input.slice(s, this.state.pos), this.finishToken(142, r);
            return;
          case 38:
            r += this.input.slice(s, this.state.pos), r += this.jsxReadEntity(), s = this.state.pos;
            break;
          case 62:
          case 125:
          default:
            Ci(n) ? (r += this.input.slice(s, this.state.pos), r += this.jsxReadNewLine(!0), s = this.state.pos) : ++this.state.pos;
        }
      }
    }
    jsxReadNewLine(r) {
      let s = this.input.charCodeAt(this.state.pos), n;
      return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, n = r ? `
` : `\r
`) : n = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, n;
    }
    jsxReadString(r) {
      let s = "", n = ++this.state.pos;
      for (; ; ) {
        if (this.state.pos >= this.length)
          throw this.raise(O.UnterminatedString, this.state.startLoc);
        let a = this.input.charCodeAt(this.state.pos);
        if (a === r) break;
        a === 38 ? (s += this.input.slice(n, this.state.pos), s += this.jsxReadEntity(), n = this.state.pos) : Ci(a) ? (s += this.input.slice(
        n, this.state.pos), s += this.jsxReadNewLine(!1), n = this.state.pos) : ++this.state.pos;
      }
      s += this.input.slice(n, this.state.pos++), this.finishToken(134, s);
    }
    jsxReadEntity() {
      let r = ++this.state.pos;
      if (this.codePointAtPos(this.state.pos) === 35) {
        ++this.state.pos;
        let s = 10;
        this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
        let n = this.readInt(s, void 0, !1, "bail");
        if (n !== null && this.codePointAtPos(this.state.pos) === 59)
          return ++this.state.pos, String.fromCodePoint(n);
      } else {
        let s = 0, n = !1;
        for (; s++ < 10 && this.state.pos < this.length && !(n = this.codePointAtPos(this.state.pos) === 59); )
          ++this.state.pos;
        if (n) {
          let a = this.input.slice(r, this.state.pos), o = oH[a];
          if (++this.state.pos, o)
            return o;
        }
      }
      return this.state.pos = r, "&";
    }
    jsxReadWord() {
      let r, s = this.state.pos;
      do
        r = this.input.charCodeAt(++this.state.pos);
      while (Nn(r) || r === 45);
      this.finishToken(141, this.input.slice(s, this.state.pos));
    }
    jsxParseIdentifier() {
      let r = this.startNode();
      return this.match(141) ? r.name = this.state.value : H0(this.state.type) ? r.name = Qs(this.state.type) : this.unexpected(), this.next(),
      this.finishNode(r, "JSXIdentifier");
    }
    jsxParseNamespacedName() {
      let r = this.state.startLoc, s = this.jsxParseIdentifier();
      if (!this.eat(14)) return s;
      let n = this.startNodeAt(r);
      return n.namespace = s, n.name = this.jsxParseIdentifier(), this.finishNode(n, "JSXNamespacedName");
    }
    jsxParseElementName() {
      let r = this.state.startLoc, s = this.jsxParseNamespacedName();
      if (s.type === "JSXNamespacedName")
        return s;
      for (; this.eat(16); ) {
        let n = this.startNodeAt(r);
        n.object = s, n.property = this.jsxParseIdentifier(), s = this.finishNode(n, "JSXMemberExpression");
      }
      return s;
    }
    jsxParseAttributeValue() {
      let r;
      switch (this.state.type) {
        case 5:
          return r = this.startNode(), this.setContext(_e.brace), this.next(), r = this.jsxParseExpressionContainer(r, _e.j_oTag), r.expression.
          type === "JSXEmptyExpression" && this.raise(In.AttributeIsEmpty, r), r;
        case 143:
        case 134:
          return this.parseExprAtom();
        default:
          throw this.raise(In.UnsupportedJsxValue, this.state.startLoc);
      }
    }
    jsxParseEmptyExpression() {
      let r = this.startNodeAt(this.state.lastTokEndLoc);
      return this.finishNodeAt(r, "JSXEmptyExpression", this.state.startLoc);
    }
    jsxParseSpreadChild(r) {
      return this.next(), r.expression = this.parseExpression(), this.setContext(_e.j_expr), this.state.canStartJSXElement = !0, this.expect(
      8), this.finishNode(r, "JSXSpreadChild");
    }
    jsxParseExpressionContainer(r, s) {
      if (this.match(8))
        r.expression = this.jsxParseEmptyExpression();
      else {
        let n = this.parseExpression();
        r.expression = n;
      }
      return this.setContext(s), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXExpressionContainer");
    }
    jsxParseAttribute() {
      let r = this.startNode();
      return this.match(5) ? (this.setContext(_e.brace), this.next(), this.expect(21), r.argument = this.parseMaybeAssignAllowIn(), this.setContext(
      _e.j_oTag), this.state.canStartJSXElement = !0, this.expect(8), this.finishNode(r, "JSXSpreadAttribute")) : (r.name = this.jsxParseNamespacedName(),
      r.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(r, "JSXAttribute"));
    }
    jsxParseOpeningElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(
      s));
    }
    jsxParseOpeningElementAfterName(r) {
      let s = [];
      for (; !this.match(56) && !this.match(144); )
        s.push(this.jsxParseAttribute());
      return r.attributes = s, r.selfClosing = this.eat(56), this.expect(144), this.finishNode(r, "JSXOpeningElement");
    }
    jsxParseClosingElementAt(r) {
      let s = this.startNodeAt(r);
      return this.eat(144) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(144), this.finishNode(
      s, "JSXClosingElement"));
    }
    jsxParseElementAt(r) {
      let s = this.startNodeAt(r), n = [], a = this.jsxParseOpeningElementAt(r), o = null;
      if (!a.selfClosing) {
        e: for (; ; )
          switch (this.state.type) {
            case 143:
              if (r = this.state.startLoc, this.next(), this.eat(56)) {
                o = this.jsxParseClosingElementAt(r);
                break e;
              }
              n.push(this.jsxParseElementAt(r));
              break;
            case 142:
              n.push(this.parseLiteral(this.state.value, "JSXText"));
              break;
            case 5: {
              let l = this.startNode();
              this.setContext(_e.brace), this.next(), this.match(21) ? n.push(this.jsxParseSpreadChild(l)) : n.push(this.jsxParseExpressionContainer(
              l, _e.j_expr));
              break;
            }
            default:
              this.unexpected();
          }
        Xs(a) && !Xs(o) && o !== null ? this.raise(In.MissingClosingTagFragment, o) : !Xs(a) && Xs(o) ? this.raise(In.MissingClosingTagElement,
        o, {
          openingTagName: Ai(a.name)
        }) : !Xs(a) && !Xs(o) && Ai(o.name) !== Ai(a.name) && this.raise(In.MissingClosingTagElement, o, {
          openingTagName: Ai(a.name)
        });
      }
      if (Xs(a) ? (s.openingFragment = a, s.closingFragment = o) : (s.openingElement = a, s.closingElement = o), s.children = n, this.match(
      47))
        throw this.raise(In.UnwrappedAdjacentJSXElements, this.state.startLoc);
      return Xs(a) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
    }
    jsxParseElement() {
      let r = this.state.startLoc;
      return this.next(), this.jsxParseElementAt(r);
    }
    setContext(r) {
      let {
        context: s
      } = this.state;
      s[s.length - 1] = r;
    }
    parseExprAtom(r) {
      return this.match(143) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(
      143), this.jsxParseElement()) : super.parseExprAtom(r);
    }
    skipSpace() {
      this.curContext().preserveSpace || super.skipSpace();
    }
    getTokenFromCode(r) {
      let s = this.curContext();
      if (s === _e.j_expr) {
        this.jsxReadToken();
        return;
      }
      if (s === _e.j_oTag || s === _e.j_cTag) {
        if (ns(r)) {
          this.jsxReadWord();
          return;
        }
        if (r === 62) {
          ++this.state.pos, this.finishToken(144);
          return;
        }
        if ((r === 34 || r === 39) && s === _e.j_oTag) {
          this.jsxReadString(r);
          return;
        }
      }
      if (r === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
        ++this.state.pos, this.finishToken(143);
        return;
      }
      super.getTokenFromCode(r);
    }
    updateContext(r) {
      let {
        context: s,
        type: n
      } = this.state;
      if (n === 56 && r === 143)
        s.splice(-2, 2, _e.j_cTag), this.state.canStartJSXElement = !1;
      else if (n === 143)
        s.push(_e.j_oTag);
      else if (n === 144) {
        let a = s[s.length - 1];
        a === _e.j_oTag && r === 56 || a === _e.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === _e.j_expr) : (this.setContext(
        _e.j_expr), this.state.canStartJSXElement = !0);
      } else
        this.state.canStartJSXElement = LY(n);
    }
  }, "jsx"), v0 = class extends Ja {
    static {
      i(this, "TypeScriptScope");
    }
    constructor(...t) {
      super(...t), this.tsNames = /* @__PURE__ */ new Map();
    }
  }, P0 = class extends Ga {
    static {
      i(this, "TypeScriptScopeHandler");
    }
    constructor(...t) {
      super(...t), this.importsStack = [];
    }
    createScope(t) {
      return this.importsStack.push(/* @__PURE__ */ new Set()), new v0(t);
    }
    enter(t) {
      t === 1024 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
    }
    exit() {
      let t = super.exit();
      return t === 1024 && this.importsStack.pop(), t;
    }
    hasImport(t, r) {
      let s = this.importsStack.length;
      if (this.importsStack[s - 1].has(t))
        return !0;
      if (!r && s > 1) {
        for (let n = 0; n < s - 1; n++)
          if (this.importsStack[n].has(t)) return !0;
      }
      return !1;
    }
    declareName(t, r, s) {
      if (r & 4096) {
        this.hasImport(t, !0) && this.parser.raise(O.VarRedeclaration, s, {
          identifierName: t
        }), this.importsStack[this.importsStack.length - 1].add(t);
        return;
      }
      let n = this.currentScope(), a = n.tsNames.get(t) || 0;
      if (r & 1024) {
        this.maybeExportDefined(n, t), n.tsNames.set(t, a | 16);
        return;
      }
      super.declareName(t, r, s), r & 2 && (r & 1 || (this.checkRedeclarationInScope(n, t, r, s), this.maybeExportDefined(n, t)), a = a | 1),
      r & 256 && (a = a | 2), r & 512 && (a = a | 4), r & 128 && (a = a | 8), a && n.tsNames.set(t, a);
    }
    isRedeclaredInScope(t, r, s) {
      let n = t.tsNames.get(r);
      if ((n & 2) > 0) {
        if (s & 256) {
          let a = !!(s & 512), o = (n & 4) > 0;
          return a !== o;
        }
        return !0;
      }
      return s & 128 && (n & 8) > 0 ? t.names.get(r) & 2 ? !!(s & 1) : !1 : s & 2 && (n & 1) > 0 ? !0 : super.isRedeclaredInScope(t, r, s);
    }
    checkLocalExport(t) {
      let {
        name: r
      } = t;
      if (this.hasImport(r)) return;
      let s = this.scopeStack.length;
      for (let n = s - 1; n >= 0; n--) {
        let o = this.scopeStack[n].tsNames.get(r);
        if ((o & 1) > 0 || (o & 16) > 0)
          return;
      }
      super.checkLocalExport(t);
    }
  }, A0 = class {
    static {
      i(this, "ProductionParameterHandler");
    }
    constructor() {
      this.stacks = [];
    }
    enter(t) {
      this.stacks.push(t);
    }
    exit() {
      this.stacks.pop();
    }
    currentFlags() {
      return this.stacks[this.stacks.length - 1];
    }
    get hasAwait() {
      return (this.currentFlags() & 2) > 0;
    }
    get hasYield() {
      return (this.currentFlags() & 1) > 0;
    }
    get hasReturn() {
      return (this.currentFlags() & 4) > 0;
    }
    get hasIn() {
      return (this.currentFlags() & 8) > 0;
    }
  };
  function Vl(e, t) {
    return (e ? 2 : 0) | (t ? 1 : 0);
  }
  i(Vl, "functionFlags");
  var C0 = class {
    static {
      i(this, "BaseParser");
    }
    constructor() {
      this.sawUnambiguousESM = !1, this.ambiguousScriptDifferentAst = !1;
    }
    sourceToOffsetPos(t) {
      return t + this.startIndex;
    }
    offsetToSourcePos(t) {
      return t - this.startIndex;
    }
    hasPlugin(t) {
      if (typeof t == "string")
        return this.plugins.has(t);
      {
        let [r, s] = t;
        if (!this.hasPlugin(r))
          return !1;
        let n = this.plugins.get(r);
        for (let a of Object.keys(s))
          if (n?.[a] !== s[a])
            return !1;
        return !0;
      }
    }
    getPluginOption(t, r) {
      var s;
      return (s = this.plugins.get(t)) == null ? void 0 : s[r];
    }
  };
  function xx(e, t) {
    e.trailingComments === void 0 ? e.trailingComments = t : e.trailingComments.unshift(...t);
  }
  i(xx, "setTrailingComments");
  function pH(e, t) {
    e.leadingComments === void 0 ? e.leadingComments = t : e.leadingComments.unshift(...t);
  }
  i(pH, "setLeadingComments");
  function Xa(e, t) {
    e.innerComments === void 0 ? e.innerComments = t : e.innerComments.unshift(...t);
  }
  i(Xa, "setInnerComments");
  function zs(e, t, r) {
    let s = null, n = t.length;
    for (; s === null && n > 0; )
      s = t[--n];
    s === null || s.start > r.start ? Xa(e, r.comments) : xx(s, r.comments);
  }
  i(zs, "adjustInnerComments");
  var w0 = class extends C0 {
    static {
      i(this, "CommentsParser");
    }
    addComment(t) {
      this.filename && (t.loc.filename = this.filename);
      let {
        commentsLen: r
      } = this.state;
      this.comments.length !== r && (this.comments.length = r), this.comments.push(t), this.state.commentsLen++;
    }
    processComment(t) {
      let {
        commentStack: r
      } = this.state, s = r.length;
      if (s === 0) return;
      let n = s - 1, a = r[n];
      a.start === t.end && (a.leadingNode = t, n--);
      let {
        start: o
      } = t;
      for (; n >= 0; n--) {
        let l = r[n], u = l.end;
        if (u > o)
          l.containingNode = t, this.finalizeComment(l), r.splice(n, 1);
        else {
          u === o && (l.trailingNode = t);
          break;
        }
      }
    }
    finalizeComment(t) {
      var r;
      let {
        comments: s
      } = t;
      if (t.leadingNode !== null || t.trailingNode !== null)
        t.leadingNode !== null && xx(t.leadingNode, s), t.trailingNode !== null && pH(t.trailingNode, s);
      else {
        let n = t.containingNode, a = t.start;
        if (this.input.charCodeAt(this.offsetToSourcePos(a) - 1) === 44)
          switch (n.type) {
            case "ObjectExpression":
            case "ObjectPattern":
            case "RecordExpression":
              zs(n, n.properties, t);
              break;
            case "CallExpression":
            case "OptionalCallExpression":
              zs(n, n.arguments, t);
              break;
            case "ImportExpression":
              zs(n, [n.source, (r = n.options) != null ? r : null], t);
              break;
            case "FunctionDeclaration":
            case "FunctionExpression":
            case "ArrowFunctionExpression":
            case "ObjectMethod":
            case "ClassMethod":
            case "ClassPrivateMethod":
              zs(n, n.params, t);
              break;
            case "ArrayExpression":
            case "ArrayPattern":
            case "TupleExpression":
              zs(n, n.elements, t);
              break;
            case "ExportNamedDeclaration":
            case "ImportDeclaration":
              zs(n, n.specifiers, t);
              break;
            case "TSEnumDeclaration":
              zs(n, n.members, t);
              break;
            case "TSEnumBody":
              zs(n, n.members, t);
              break;
            default:
              Xa(n, s);
          }
        else
          Xa(n, s);
      }
    }
    finalizeRemainingComments() {
      let {
        commentStack: t
      } = this.state;
      for (let r = t.length - 1; r >= 0; r--)
        this.finalizeComment(t[r]);
      this.state.commentStack = [];
    }
    resetPreviousNodeTrailingComments(t) {
      let {
        commentStack: r
      } = this.state, {
        length: s
      } = r;
      if (s === 0) return;
      let n = r[s - 1];
      n.leadingNode === t && (n.leadingNode = null);
    }
    takeSurroundingComments(t, r, s) {
      let {
        commentStack: n
      } = this.state, a = n.length;
      if (a === 0) return;
      let o = a - 1;
      for (; o >= 0; o--) {
        let l = n[o], u = l.end;
        if (l.start === s)
          l.leadingNode = t;
        else if (u === r)
          l.trailingNode = t;
        else if (u < r)
          break;
      }
    }
  }, D0 = class e {
    static {
      i(this, "State");
    }
    constructor() {
      this.flags = 1024, this.startIndex = void 0, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0,
      this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 140, this.value = null, this.start = 0, this.
      end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [_e.brace], this.firstInvalidTemplateEscapePos = null,
      this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
    }
    get strict() {
      return (this.flags & 1) > 0;
    }
    set strict(t) {
      t ? this.flags |= 1 : this.flags &= -2;
    }
    init({
      strictMode: t,
      sourceType: r,
      startIndex: s,
      startLine: n,
      startColumn: a
    }) {
      this.strict = t === !1 ? !1 : t === !0 ? !0 : r === "module", this.startIndex = s, this.curLine = n, this.lineStart = -a, this.startLoc =
      this.endLoc = new is(n, a, s);
    }
    get maybeInArrowParameters() {
      return (this.flags & 2) > 0;
    }
    set maybeInArrowParameters(t) {
      t ? this.flags |= 2 : this.flags &= -3;
    }
    get inType() {
      return (this.flags & 4) > 0;
    }
    set inType(t) {
      t ? this.flags |= 4 : this.flags &= -5;
    }
    get noAnonFunctionType() {
      return (this.flags & 8) > 0;
    }
    set noAnonFunctionType(t) {
      t ? this.flags |= 8 : this.flags &= -9;
    }
    get hasFlowComment() {
      return (this.flags & 16) > 0;
    }
    set hasFlowComment(t) {
      t ? this.flags |= 16 : this.flags &= -17;
    }
    get isAmbientContext() {
      return (this.flags & 32) > 0;
    }
    set isAmbientContext(t) {
      t ? this.flags |= 32 : this.flags &= -33;
    }
    get inAbstractClass() {
      return (this.flags & 64) > 0;
    }
    set inAbstractClass(t) {
      t ? this.flags |= 64 : this.flags &= -65;
    }
    get inDisallowConditionalTypesContext() {
      return (this.flags & 128) > 0;
    }
    set inDisallowConditionalTypesContext(t) {
      t ? this.flags |= 128 : this.flags &= -129;
    }
    get soloAwait() {
      return (this.flags & 256) > 0;
    }
    set soloAwait(t) {
      t ? this.flags |= 256 : this.flags &= -257;
    }
    get inFSharpPipelineDirectBody() {
      return (this.flags & 512) > 0;
    }
    set inFSharpPipelineDirectBody(t) {
      t ? this.flags |= 512 : this.flags &= -513;
    }
    get canStartJSXElement() {
      return (this.flags & 1024) > 0;
    }
    set canStartJSXElement(t) {
      t ? this.flags |= 1024 : this.flags &= -1025;
    }
    get containsEsc() {
      return (this.flags & 2048) > 0;
    }
    set containsEsc(t) {
      t ? this.flags |= 2048 : this.flags &= -2049;
    }
    get hasTopLevelAwait() {
      return (this.flags & 4096) > 0;
    }
    set hasTopLevelAwait(t) {
      t ? this.flags |= 4096 : this.flags &= -4097;
    }
    curPosition() {
      return new is(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
    }
    clone() {
      let t = new e();
      return t.flags = this.flags, t.startIndex = this.startIndex, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.
      startLoc, t.endLoc = this.endLoc, t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.
      slice(), t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.
      slice(), t.commentsLen = this.commentsLen, t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value =
      this.value, t.start = this.start, t.end = this.end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.
      context = this.context.slice(), t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors,
      t.tokensLength = this.tokensLength, t;
    }
  }, fH = /* @__PURE__ */ i(function(t) {
    return t >= 48 && t <= 57;
  }, "isDigit"), ix = {
    decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
  }, ql = {
    bin: /* @__PURE__ */ i((e) => e === 48 || e === 49, "bin"),
    oct: /* @__PURE__ */ i((e) => e >= 48 && e <= 55, "oct"),
    dec: /* @__PURE__ */ i((e) => e >= 48 && e <= 57, "dec"),
    hex: /* @__PURE__ */ i((e) => e >= 48 && e <= 57 || e >= 65 && e <= 70 || e >= 97 && e <= 102, "hex")
  };
  function ax(e, t, r, s, n, a) {
    let o = r, l = s, u = n, c = "", p = null, f = r, {
      length: h
    } = t;
    for (; ; ) {
      if (r >= h) {
        a.unterminated(o, l, u), c += t.slice(f, r);
        break;
      }
      let b = t.charCodeAt(r);
      if (dH(e, b, t, r)) {
        c += t.slice(f, r);
        break;
      }
      if (b === 92) {
        c += t.slice(f, r);
        let T = hH(t, r, s, n, e === "template", a);
        T.ch === null && !p ? p = {
          pos: r,
          lineStart: s,
          curLine: n
        } : c += T.ch, {
          pos: r,
          lineStart: s,
          curLine: n
        } = T, f = r;
      } else b === 8232 || b === 8233 ? (++r, ++n, s = r) : b === 10 || b === 13 ? e === "template" ? (c += t.slice(f, r) + `
`, ++r, b === 13 && t.charCodeAt(r) === 10 && ++r, ++n, f = s = r) : a.unterminated(o, l, u) : ++r;
    }
    return {
      pos: r,
      str: c,
      firstInvalidLoc: p,
      lineStart: s,
      curLine: n,
      containsInvalid: !!p
    };
  }
  i(ax, "readStringContents");
  function dH(e, t, r, s) {
    return e === "template" ? t === 96 || t === 36 && r.charCodeAt(s + 1) === 123 : t === (e === "double" ? 34 : 39);
  }
  i(dH, "isStringEnd");
  function hH(e, t, r, s, n, a) {
    let o = !n;
    t++;
    let l = /* @__PURE__ */ i((c) => ({
      pos: t,
      ch: c,
      lineStart: r,
      curLine: s
    }), "res"), u = e.charCodeAt(t++);
    switch (u) {
      case 110:
        return l(`
`);
      case 114:
        return l("\r");
      case 120: {
        let c;
        return {
          code: c,
          pos: t
        } = _0(e, t, r, s, 2, !1, o, a), l(c === null ? null : String.fromCharCode(c));
      }
      case 117: {
        let c;
        return {
          code: c,
          pos: t
        } = Sx(e, t, r, s, o, a), l(c === null ? null : String.fromCodePoint(c));
      }
      case 116:
        return l("	");
      case 98:
        return l("\b");
      case 118:
        return l("\v");
      case 102:
        return l("\f");
      case 13:
        e.charCodeAt(t) === 10 && ++t;
      case 10:
        r = t, ++s;
      case 8232:
      case 8233:
        return l("");
      case 56:
      case 57:
        if (n)
          return l(null);
        a.strictNumericEscape(t - 1, r, s);
      default:
        if (u >= 48 && u <= 55) {
          let c = t - 1, f = /^[0-7]+/.exec(e.slice(c, t + 2))[0], h = parseInt(f, 8);
          h > 255 && (f = f.slice(0, -1), h = parseInt(f, 8)), t += f.length - 1;
          let b = e.charCodeAt(t);
          if (f !== "0" || b === 56 || b === 57) {
            if (n)
              return l(null);
            a.strictNumericEscape(c, r, s);
          }
          return l(String.fromCharCode(h));
        }
        return l(String.fromCharCode(u));
    }
  }
  i(hH, "readEscapedChar");
  function _0(e, t, r, s, n, a, o, l) {
    let u = t, c;
    return {
      n: c,
      pos: t
    } = Ex(e, t, r, s, 16, n, a, !1, l, !o), c === null && (o ? l.invalidEscapeSequence(u, r, s) : t = u - 1), {
      code: c,
      pos: t
    };
  }
  i(_0, "readHexChar");
  function Ex(e, t, r, s, n, a, o, l, u, c) {
    let p = t, f = n === 16 ? ix.hex : ix.decBinOct, h = n === 16 ? ql.hex : n === 10 ? ql.dec : n === 8 ? ql.oct : ql.bin, b = !1, T = 0;
    for (let d = 0, g = a ?? 1 / 0; d < g; ++d) {
      let E = e.charCodeAt(t), _;
      if (E === 95 && l !== "bail") {
        let N = e.charCodeAt(t - 1), k = e.charCodeAt(t + 1);
        if (l) {
          if (Number.isNaN(k) || !h(k) || f.has(N) || f.has(k)) {
            if (c) return {
              n: null,
              pos: t
            };
            u.unexpectedNumericSeparator(t, r, s);
          }
        } else {
          if (c) return {
            n: null,
            pos: t
          };
          u.numericSeparatorInEscapeSequence(t, r, s);
        }
        ++t;
        continue;
      }
      if (E >= 97 ? _ = E - 97 + 10 : E >= 65 ? _ = E - 65 + 10 : fH(E) ? _ = E - 48 : _ = 1 / 0, _ >= n) {
        if (_ <= 9 && c)
          return {
            n: null,
            pos: t
          };
        if (_ <= 9 && u.invalidDigit(t, r, s, n))
          _ = 0;
        else if (o)
          _ = 0, b = !0;
        else
          break;
      }
      ++t, T = T * n + _;
    }
    return t === p || a != null && t - p !== a || b ? {
      n: null,
      pos: t
    } : {
      n: T,
      pos: t
    };
  }
  i(Ex, "readInt");
  function Sx(e, t, r, s, n, a) {
    let o = e.charCodeAt(t), l;
    if (o === 123) {
      if (++t, {
        code: l,
        pos: t
      } = _0(e, t, r, s, e.indexOf("}", t) - t, !0, n, a), ++t, l !== null && l > 1114111)
        if (n)
          a.invalidCodePoint(t, r, s);
        else
          return {
            code: null,
            pos: t
          };
    } else
      ({
        code: l,
        pos: t
      } = _0(e, t, r, s, 4, !1, n, a));
    return {
      code: l,
      pos: t
    };
  }
  i(Sx, "readCodePoint");
  function Ka(e, t, r) {
    return new is(r, e - t, e);
  }
  i(Ka, "buildPosition");
  var mH = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), rs = class {
    static {
      i(this, "Token");
    }
    constructor(t) {
      let r = t.startIndex || 0;
      this.type = t.type, this.value = t.value, this.start = r + t.start, this.end = r + t.end, this.loc = new Di(t.startLoc, t.endLoc);
    }
  }, I0 = class extends w0 {
    static {
      i(this, "Tokenizer");
    }
    constructor(t, r) {
      super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = {
        invalidDigit: /* @__PURE__ */ i((s, n, a, o) => this.optionFlags & 2048 ? (this.raise(O.InvalidDigit, Ka(s, n, a), {
          radix: o
        }), !0) : !1, "invalidDigit"),
        numericSeparatorInEscapeSequence: this.errorBuilder(O.NumericSeparatorInEscapeSequence),
        unexpectedNumericSeparator: this.errorBuilder(O.UnexpectedNumericSeparator)
      }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
        invalidEscapeSequence: this.errorBuilder(O.InvalidEscapeSequence),
        invalidCodePoint: this.errorBuilder(O.InvalidCodePoint)
      }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: /* @__PURE__ */ i((s, n, a) => {
          this.recordStrictModeErrors(O.StrictNumericEscape, Ka(s, n, a));
        }, "strictNumericEscape"),
        unterminated: /* @__PURE__ */ i((s, n, a) => {
          throw this.raise(O.UnterminatedString, Ka(s - 1, n, a));
        }, "unterminated")
      }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
        strictNumericEscape: this.errorBuilder(O.StrictNumericEscape),
        unterminated: /* @__PURE__ */ i((s, n, a) => {
          throw this.raise(O.UnterminatedTemplate, Ka(s, n, a));
        }, "unterminated")
      }), this.state = new D0(), this.state.init(t), this.input = r, this.length = r.length, this.comments = [], this.isLookahead = !1;
    }
    pushToken(t) {
      this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
    }
    next() {
      this.checkKeywordEscapes(), this.optionFlags & 256 && this.pushToken(new rs(this.state)), this.state.lastTokEndLoc = this.state.endLoc,
      this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
    }
    eat(t) {
      return this.match(t) ? (this.next(), !0) : !1;
    }
    match(t) {
      return this.state.type === t;
    }
    createLookaheadState(t) {
      return {
        pos: t.pos,
        value: null,
        type: t.type,
        start: t.start,
        end: t.end,
        context: [this.curContext()],
        inType: t.inType,
        startLoc: t.startLoc,
        lastTokEndLoc: t.lastTokEndLoc,
        curLine: t.curLine,
        lineStart: t.lineStart,
        curPosition: t.curPosition
      };
    }
    lookahead() {
      let t = this.state;
      this.state = this.createLookaheadState(t), this.isLookahead = !0, this.nextToken(), this.isLookahead = !1;
      let r = this.state;
      return this.state = t, r;
    }
    nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    }
    nextTokenStartSince(t) {
      return m0.lastIndex = t, m0.test(this.input) ? m0.lastIndex : t;
    }
    lookaheadCharCode() {
      return this.lookaheadCharCodeSince(this.state.pos);
    }
    lookaheadCharCodeSince(t) {
      return this.input.charCodeAt(this.nextTokenStartSince(t));
    }
    nextTokenInLineStart() {
      return this.nextTokenInLineStartSince(this.state.pos);
    }
    nextTokenInLineStartSince(t) {
      return y0.lastIndex = t, y0.test(this.input) ? y0.lastIndex : t;
    }
    lookaheadInLineCharCode() {
      return this.input.charCodeAt(this.nextTokenInLineStart());
    }
    codePointAtPos(t) {
      let r = this.input.charCodeAt(t);
      if ((r & 64512) === 55296 && ++t < this.input.length) {
        let s = this.input.charCodeAt(t);
        (s & 64512) === 56320 && (r = 65536 + ((r & 1023) << 10) + (s & 1023));
      }
      return r;
    }
    setStrict(t) {
      this.state.strict = t, t && (this.state.strictErrors.forEach(([r, s]) => this.raise(r, s)), this.state.strictErrors.clear());
    }
    curContext() {
      return this.state.context[this.state.context.length - 1];
    }
    nextToken() {
      if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.
      pos >= this.length) {
        this.finishToken(140);
        return;
      }
      this.getTokenFromCode(this.codePointAtPos(this.state.pos));
    }
    skipBlockComment(t) {
      let r;
      this.isLookahead || (r = this.state.curPosition());
      let s = this.state.pos, n = this.input.indexOf(t, s + 2);
      if (n === -1)
        throw this.raise(O.UnterminatedComment, this.state.curPosition());
      for (this.state.pos = n + t.length, Rl.lastIndex = s + 2; Rl.test(this.input) && Rl.lastIndex <= n; )
        ++this.state.curLine, this.state.lineStart = Rl.lastIndex;
      if (this.isLookahead) return;
      let a = {
        type: "CommentBlock",
        value: this.input.slice(s + 2, n),
        start: this.sourceToOffsetPos(s),
        end: this.sourceToOffsetPos(n + t.length),
        loc: new Di(r, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(a), a;
    }
    skipLineComment(t) {
      let r = this.state.pos, s;
      this.isLookahead || (s = this.state.curPosition());
      let n = this.input.charCodeAt(this.state.pos += t);
      if (this.state.pos < this.length)
        for (; !Ci(n) && ++this.state.pos < this.length; )
          n = this.input.charCodeAt(this.state.pos);
      if (this.isLookahead) return;
      let a = this.state.pos, l = {
        type: "CommentLine",
        value: this.input.slice(r + t, a),
        start: this.sourceToOffsetPos(r),
        end: this.sourceToOffsetPos(a),
        loc: new Di(s, this.state.curPosition())
      };
      return this.optionFlags & 256 && this.pushToken(l), l;
    }
    skipSpace() {
      let t = this.state.pos, r = this.optionFlags & 4096 ? [] : null;
      e: for (; this.state.pos < this.length; ) {
        let s = this.input.charCodeAt(this.state.pos);
        switch (s) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;
          case 13:
            this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
          case 10:
          case 8232:
          case 8233:
            ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
            break;
          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42: {
                let n = this.skipBlockComment("*/");
                n !== void 0 && (this.addComment(n), r?.push(n));
                break;
              }
              case 47: {
                let n = this.skipLineComment(2);
                n !== void 0 && (this.addComment(n), r?.push(n));
                break;
              }
              default:
                break e;
            }
            break;
          default:
            if (uH(s))
              ++this.state.pos;
            else if (s === 45 && !this.inModule && this.optionFlags & 8192) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 45 && this.input.charCodeAt(n + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                let a = this.skipLineComment(3);
                a !== void 0 && (this.addComment(a), r?.push(a));
              } else
                break e;
            } else if (s === 60 && !this.inModule && this.optionFlags & 8192) {
              let n = this.state.pos;
              if (this.input.charCodeAt(n + 1) === 33 && this.input.charCodeAt(n + 2) === 45 && this.input.charCodeAt(n + 3) === 45) {
                let a = this.skipLineComment(4);
                a !== void 0 && (this.addComment(a), r?.push(a));
              } else
                break e;
            } else
              break e;
        }
      }
      if (r?.length > 0) {
        let s = this.state.pos, n = {
          start: this.sourceToOffsetPos(t),
          end: this.sourceToOffsetPos(s),
          comments: r,
          leadingNode: null,
          trailingNode: null,
          containingNode: null
        };
        this.state.commentStack.push(n);
      }
    }
    finishToken(t, r) {
      this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
      let s = this.state.type;
      this.state.type = t, this.state.value = r, this.isLookahead || this.updateContext(s);
    }
    replaceToken(t) {
      this.state.type = t, this.updateContext();
    }
    readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter())
        return;
      let t = this.state.pos + 1, r = this.codePointAtPos(t);
      if (r >= 48 && r <= 57)
        throw this.raise(O.UnexpectedDigitAfterHash, this.state.curPosition());
      if (r === 123 || r === 91 && this.hasPlugin("recordAndTuple")) {
        if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar")
          throw this.raise(r === 123 ? O.RecordExpressionHashIncorrectStartSyntaxType : O.TupleExpressionHashIncorrectStartSyntaxType, this.
          state.curPosition());
        this.state.pos += 2, r === 123 ? this.finishToken(7) : this.finishToken(1);
      } else ns(r) ? (++this.state.pos, this.finishToken(139, this.readWord1(r))) : r === 92 ? (++this.state.pos, this.finishToken(139, this.
      readWord1())) : this.finishOp(27, 1);
    }
    readToken_dot() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t >= 48 && t <= 57) {
        this.readNumber(!0);
        return;
      }
      t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(
      16));
    }
    readToken_slash() {
      this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
    }
    readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return !1;
      let t = this.input.charCodeAt(this.state.pos + 1);
      if (t !== 33) return !1;
      let r = this.state.pos;
      for (this.state.pos += 1; !Ci(t) && ++this.state.pos < this.length; )
        t = this.input.charCodeAt(this.state.pos);
      let s = this.input.slice(r + 2, this.state.pos);
      return this.finishToken(28, s), !0;
    }
    readToken_mult_modulo(t) {
      let r = t === 42 ? 55 : 54, s = 1, n = this.input.charCodeAt(this.state.pos + 1);
      t === 42 && n === 42 && (s++, n = this.input.charCodeAt(this.state.pos + 2), r = 57), n === 61 && !this.state.inType && (s++, r = t ===
      37 ? 33 : 30), this.finishOp(r, s);
    }
    readToken_pipe_amp(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
        return;
      }
      if (t === 124) {
        if (r === 62) {
          this.finishOp(39, 2);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(O.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(9);
          return;
        }
        if (this.hasPlugin("recordAndTuple") && r === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
            throw this.raise(O.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
          this.state.pos += 2, this.finishToken(4);
          return;
        }
      }
      if (r === 61) {
        this.finishOp(30, 2);
        return;
      }
      this.finishOp(t === 124 ? 43 : 45, 1);
    }
    readToken_caret() {
      let t = this.input.charCodeAt(this.state.pos + 1);
      t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "^^"
      }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
    }
    readToken_atSign() {
      this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", {
        proposal: "hack",
        topicToken: "@@"
      }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
    }
    readToken_plus_min(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === t) {
        this.finishOp(34, 2);
        return;
      }
      r === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
    }
    readToken_lt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 60) {
        if (this.input.charCodeAt(t + 2) === 61) {
          this.finishOp(30, 3);
          return;
        }
        this.finishOp(51, 2);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(47, 1);
    }
    readToken_gt() {
      let {
        pos: t
      } = this.state, r = this.input.charCodeAt(t + 1);
      if (r === 62) {
        let s = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
        if (this.input.charCodeAt(t + s) === 61) {
          this.finishOp(30, s + 1);
          return;
        }
        this.finishOp(52, s);
        return;
      }
      if (r === 61) {
        this.finishOp(49, 2);
        return;
      }
      this.finishOp(48, 1);
    }
    readToken_eq_excl(t) {
      let r = this.input.charCodeAt(this.state.pos + 1);
      if (r === 61) {
        this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }
      if (t === 61 && r === 62) {
        this.state.pos += 2, this.finishToken(19);
        return;
      }
      this.finishOp(t === 61 ? 29 : 35, 1);
    }
    readToken_question() {
      let t = this.input.charCodeAt(this.state.pos + 1), r = this.input.charCodeAt(this.state.pos + 2);
      t === 63 ? r === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(r >= 48 && r <= 57) ? (this.state.pos += 2, this.finishToken(
      18)) : (++this.state.pos, this.finishToken(17));
    }
    getTokenFromCode(t) {
      switch (t) {
        case 46:
          this.readToken_dot();
          return;
        case 40:
          ++this.state.pos, this.finishToken(10);
          return;
        case 41:
          ++this.state.pos, this.finishToken(11);
          return;
        case 59:
          ++this.state.pos, this.finishToken(13);
          return;
        case 44:
          ++this.state.pos, this.finishToken(12);
          return;
        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(O.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(2);
          } else
            ++this.state.pos, this.finishToken(0);
          return;
        case 93:
          ++this.state.pos, this.finishToken(3);
          return;
        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
              throw this.raise(O.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
            this.state.pos += 2, this.finishToken(6);
          } else
            ++this.state.pos, this.finishToken(5);
          return;
        case 125:
          ++this.state.pos, this.finishToken(8);
          return;
        case 58:
          this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.
          finishToken(14));
          return;
        case 63:
          this.readToken_question();
          return;
        case 96:
          this.readTemplateToken();
          return;
        case 48: {
          let r = this.input.charCodeAt(this.state.pos + 1);
          if (r === 120 || r === 88) {
            this.readRadixNumber(16);
            return;
          }
          if (r === 111 || r === 79) {
            this.readRadixNumber(8);
            return;
          }
          if (r === 98 || r === 66) {
            this.readRadixNumber(2);
            return;
          }
        }
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(!1);
          return;
        case 34:
        case 39:
          this.readString(t);
          return;
        case 47:
          this.readToken_slash();
          return;
        case 37:
        case 42:
          this.readToken_mult_modulo(t);
          return;
        case 124:
        case 38:
          this.readToken_pipe_amp(t);
          return;
        case 94:
          this.readToken_caret();
          return;
        case 43:
        case 45:
          this.readToken_plus_min(t);
          return;
        case 60:
          this.readToken_lt();
          return;
        case 62:
          this.readToken_gt();
          return;
        case 61:
        case 33:
          this.readToken_eq_excl(t);
          return;
        case 126:
          this.finishOp(36, 1);
          return;
        case 64:
          this.readToken_atSign();
          return;
        case 35:
          this.readToken_numberSign();
          return;
        case 92:
          this.readWord();
          return;
        default:
          if (ns(t)) {
            this.readWord(t);
            return;
          }
      }
      throw this.raise(O.InvalidOrUnexpectedToken, this.state.curPosition(), {
        unexpected: String.fromCodePoint(t)
      });
    }
    finishOp(t, r) {
      let s = this.input.slice(this.state.pos, this.state.pos + r);
      this.state.pos += r, this.finishToken(t, s);
    }
    readRegexp() {
      let t = this.state.startLoc, r = this.state.start + 1, s, n, {
        pos: a
      } = this.state;
      for (; ; ++a) {
        if (a >= this.length)
          throw this.raise(O.UnterminatedRegExp, Wt(t, 1));
        let c = this.input.charCodeAt(a);
        if (Ci(c))
          throw this.raise(O.UnterminatedRegExp, Wt(t, 1));
        if (s)
          s = !1;
        else {
          if (c === 91)
            n = !0;
          else if (c === 93 && n)
            n = !1;
          else if (c === 47 && !n)
            break;
          s = c === 92;
        }
      }
      let o = this.input.slice(r, a);
      ++a;
      let l = "", u = /* @__PURE__ */ i(() => Wt(t, a + 2 - r), "nextPos");
      for (; a < this.length; ) {
        let c = this.codePointAtPos(a), p = String.fromCharCode(c);
        if (mH.has(c))
          c === 118 ? l.includes("u") && this.raise(O.IncompatibleRegExpUVFlags, u()) : c === 117 && l.includes("v") && this.raise(O.IncompatibleRegExpUVFlags,
          u()), l.includes(p) && this.raise(O.DuplicateRegExpFlags, u());
        else if (Nn(c) || c === 92)
          this.raise(O.MalformedRegExpFlags, u());
        else
          break;
        ++a, l += p;
      }
      this.state.pos = a, this.finishToken(138, {
        pattern: o,
        flags: l
      });
    }
    readInt(t, r, s = !1, n = !0) {
      let {
        n: a,
        pos: o
      } = Ex(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, r, s, n, this.errorHandlers_readInt, !1);
      return this.state.pos = o, a;
    }
    readRadixNumber(t) {
      let r = this.state.pos, s = this.state.curPosition(), n = !1;
      this.state.pos += 2;
      let a = this.readInt(t);
      a == null && this.raise(O.InvalidDigit, Wt(s, 2), {
        radix: t
      });
      let o = this.input.charCodeAt(this.state.pos);
      if (o === 110)
        ++this.state.pos, n = !0;
      else if (o === 109)
        throw this.raise(O.InvalidDecimal, s);
      if (ns(this.codePointAtPos(this.state.pos)))
        throw this.raise(O.NumberIdentifier, this.state.curPosition());
      if (n) {
        let l = this.input.slice(r, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(136, l);
        return;
      }
      this.finishToken(135, a);
    }
    readNumber(t) {
      let r = this.state.pos, s = this.state.curPosition(), n = !1, a = !1, o = !1, l = !1;
      !t && this.readInt(10) === null && this.raise(O.InvalidNumber, this.state.curPosition());
      let u = this.state.pos - r >= 2 && this.input.charCodeAt(r) === 48;
      if (u) {
        let b = this.input.slice(r, this.state.pos);
        if (this.recordStrictModeErrors(O.StrictOctalLiteral, s), !this.state.strict) {
          let T = b.indexOf("_");
          T > 0 && this.raise(O.ZeroDigitNumericSeparator, Wt(s, T));
        }
        l = u && !/[89]/.test(b);
      }
      let c = this.input.charCodeAt(this.state.pos);
      if (c === 46 && !l && (++this.state.pos, this.readInt(10), n = !0, c = this.input.charCodeAt(this.state.pos)), (c === 69 || c === 101) &&
      !l && (c = this.input.charCodeAt(++this.state.pos), (c === 43 || c === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(
      O.InvalidOrMissingExponent, s), n = !0, o = !0, c = this.input.charCodeAt(this.state.pos)), c === 110 && ((n || u) && this.raise(O.InvalidBigIntLiteral,
      s), ++this.state.pos, a = !0), c === 109) {
        this.expectPlugin("decimal", this.state.curPosition()), (o || u) && this.raise(O.InvalidDecimal, s), ++this.state.pos;
        var p = !0;
      }
      if (ns(this.codePointAtPos(this.state.pos)))
        throw this.raise(O.NumberIdentifier, this.state.curPosition());
      let f = this.input.slice(r, this.state.pos).replace(/[_mn]/g, "");
      if (a) {
        this.finishToken(136, f);
        return;
      }
      if (p) {
        this.finishToken(137, f);
        return;
      }
      let h = l ? parseInt(f, 8) : parseFloat(f);
      this.finishToken(135, h);
    }
    readCodePoint(t) {
      let {
        code: r,
        pos: s
      } = Sx(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
      return this.state.pos = s, r;
    }
    readString(t) {
      let {
        str: r,
        pos: s,
        curLine: n,
        lineStart: a
      } = ax(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
      this.state.pos = s + 1, this.state.lineStart = a, this.state.curLine = n, this.finishToken(134, r);
    }
    readTemplateContinuation() {
      this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
    }
    readTemplateToken() {
      let t = this.input[this.state.pos], {
        str: r,
        firstInvalidLoc: s,
        pos: n,
        curLine: a,
        lineStart: o
      } = ax("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
      this.state.pos = n + 1, this.state.lineStart = o, this.state.curLine = a, s && (this.state.firstInvalidTemplateEscapePos = new is(s.curLine,
      s.pos - s.lineStart, this.sourceToOffsetPos(s.pos))), this.input.codePointAt(n) === 96 ? this.finishToken(24, s ? null : t + r + "`") :
      (this.state.pos++, this.finishToken(25, s ? null : t + r + "${"));
    }
    recordStrictModeErrors(t, r) {
      let s = r.index;
      this.state.strict && !this.state.strictErrors.has(s) ? this.raise(t, r) : this.state.strictErrors.set(s, [t, r]);
    }
    readWord1(t) {
      this.state.containsEsc = !1;
      let r = "", s = this.state.pos, n = this.state.pos;
      for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
        let a = this.codePointAtPos(this.state.pos);
        if (Nn(a))
          this.state.pos += a <= 65535 ? 1 : 2;
        else if (a === 92) {
          this.state.containsEsc = !0, r += this.input.slice(n, this.state.pos);
          let o = this.state.curPosition(), l = this.state.pos === s ? ns : Nn;
          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(O.MissingUnicodeEscape, this.state.curPosition()), n = this.state.pos - 1;
            continue;
          }
          ++this.state.pos;
          let u = this.readCodePoint(!0);
          u !== null && (l(u) || this.raise(O.EscapedCharNotAnIdentifier, o), r += String.fromCodePoint(u)), n = this.state.pos;
        } else
          break;
      }
      return r + this.input.slice(n, this.state.pos);
    }
    readWord(t) {
      let r = this.readWord1(t), s = U0.get(r);
      s !== void 0 ? this.finishToken(s, Qs(s)) : this.finishToken(132, r);
    }
    checkKeywordEscapes() {
      let {
        type: t
      } = this.state;
      H0(t) && this.state.containsEsc && this.raise(O.InvalidEscapedReservedWord, this.state.startLoc, {
        reservedWord: Qs(t)
      });
    }
    raise(t, r, s = {}) {
      let n = r instanceof is ? r : r.loc.start, a = t(n, s);
      if (!(this.optionFlags & 2048)) throw a;
      return this.isLookahead || this.state.errors.push(a), a;
    }
    raiseOverwrite(t, r, s = {}) {
      let n = r instanceof is ? r : r.loc.start, a = n.index, o = this.state.errors;
      for (let l = o.length - 1; l >= 0; l--) {
        let u = o[l];
        if (u.loc.index === a)
          return o[l] = t(n, s);
        if (u.loc.index < a) break;
      }
      return this.raise(t, r, s);
    }
    updateContext(t) {
    }
    unexpected(t, r) {
      throw this.raise(O.UnexpectedToken, t ?? this.state.startLoc, {
        expected: r ? Qs(r) : null
      });
    }
    expectPlugin(t, r) {
      if (this.hasPlugin(t))
        return !0;
      throw this.raise(O.MissingPlugin, r ?? this.state.startLoc, {
        missingPlugin: [t]
      });
    }
    expectOnePlugin(t) {
      if (!t.some((r) => this.hasPlugin(r)))
        throw this.raise(O.MissingOneOfPlugins, this.state.startLoc, {
          missingPlugin: t
        });
    }
    errorBuilder(t) {
      return (r, s, n) => {
        this.raise(t, Ka(r, s, n));
      };
    }
  }, O0 = class {
    static {
      i(this, "ClassScope");
    }
    constructor() {
      this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
    }
  }, N0 = class {
    static {
      i(this, "ClassScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
    }
    current() {
      return this.stack[this.stack.length - 1];
    }
    enter() {
      this.stack.push(new O0());
    }
    exit() {
      let t = this.stack.pop(), r = this.current();
      for (let [s, n] of Array.from(t.undefinedPrivateNames))
        r ? r.undefinedPrivateNames.has(s) || r.undefinedPrivateNames.set(s, n) : this.parser.raise(O.InvalidPrivateFieldResolution, n, {
          identifierName: s
        });
    }
    declarePrivateName(t, r, s) {
      let {
        privateNames: n,
        loneAccessors: a,
        undefinedPrivateNames: o
      } = this.current(), l = n.has(t);
      if (r & 3) {
        let u = l && a.get(t);
        if (u) {
          let c = u & 4, p = r & 4, f = u & 3, h = r & 3;
          l = f === h || c !== p, l || a.delete(t);
        } else l || a.set(t, r);
      }
      l && this.parser.raise(O.PrivateNameRedeclaration, s, {
        identifierName: t
      }), n.add(t), o.delete(t);
    }
    usePrivateName(t, r) {
      let s;
      for (s of this.stack)
        if (s.privateNames.has(t)) return;
      s ? s.undefinedPrivateNames.set(t, r) : this.parser.raise(O.InvalidPrivateFieldResolution, r, {
        identifierName: t
      });
    }
  }, _i = class {
    static {
      i(this, "ExpressionScope");
    }
    constructor(t = 0) {
      this.type = t;
    }
    canBeArrowParameterDeclaration() {
      return this.type === 2 || this.type === 1;
    }
    isCertainlyParameterDeclaration() {
      return this.type === 3;
    }
  }, Yl = class extends _i {
    static {
      i(this, "ArrowHeadParsingScope");
    }
    constructor(t) {
      super(t), this.declarationErrors = /* @__PURE__ */ new Map();
    }
    recordDeclarationError(t, r) {
      let s = r.index;
      this.declarationErrors.set(s, [t, r]);
    }
    clearDeclarationError(t) {
      this.declarationErrors.delete(t);
    }
    iterateErrors(t) {
      this.declarationErrors.forEach(t);
    }
  }, B0 = class {
    static {
      i(this, "ExpressionScopeHandler");
    }
    constructor(t) {
      this.parser = void 0, this.stack = [new _i()], this.parser = t;
    }
    enter(t) {
      this.stack.push(t);
    }
    exit() {
      this.stack.pop();
    }
    recordParameterInitializerError(t, r) {
      let s = r.loc.start, {
        stack: n
      } = this, a = n.length - 1, o = n[a];
      for (; !o.isCertainlyParameterDeclaration(); ) {
        if (o.canBeArrowParameterDeclaration())
          o.recordDeclarationError(t, s);
        else
          return;
        o = n[--a];
      }
      this.parser.raise(t, s);
    }
    recordArrowParameterBindingError(t, r) {
      let {
        stack: s
      } = this, n = s[s.length - 1], a = r.loc.start;
      if (n.isCertainlyParameterDeclaration())
        this.parser.raise(t, a);
      else if (n.canBeArrowParameterDeclaration())
        n.recordDeclarationError(t, a);
      else
        return;
    }
    recordAsyncArrowParametersError(t) {
      let {
        stack: r
      } = this, s = r.length - 1, n = r[s];
      for (; n.canBeArrowParameterDeclaration(); )
        n.type === 2 && n.recordDeclarationError(O.AwaitBindingIdentifier, t), n = r[--s];
    }
    validateAsPattern() {
      let {
        stack: t
      } = this, r = t[t.length - 1];
      r.canBeArrowParameterDeclaration() && r.iterateErrors(([s, n]) => {
        this.parser.raise(s, n);
        let a = t.length - 2, o = t[a];
        for (; o.canBeArrowParameterDeclaration(); )
          o.clearDeclarationError(n.index), o = t[--a];
      });
    }
  };
  function yH() {
    return new _i(3);
  }
  i(yH, "newParameterDeclarationScope");
  function bH() {
    return new Yl(1);
  }
  i(bH, "newArrowHeadScope");
  function gH() {
    return new Yl(2);
  }
  i(gH, "newAsyncArrowScope");
  function vx() {
    return new _i();
  }
  i(vx, "newExpressionScope");
  var k0 = class extends I0 {
    static {
      i(this, "UtilParser");
    }
    addExtra(t, r, s, n = !0) {
      if (!t) return;
      let {
        extra: a
      } = t;
      a == null && (a = {}, t.extra = a), n ? a[r] = s : Object.defineProperty(a, r, {
        enumerable: n,
        value: s
      });
    }
    isContextual(t) {
      return this.state.type === t && !this.state.containsEsc;
    }
    isUnparsedContextual(t, r) {
      if (this.input.startsWith(r, t)) {
        let s = this.input.charCodeAt(t + r.length);
        return !(Nn(s) || (s & 64512) === 55296);
      }
      return !1;
    }
    isLookaheadContextual(t) {
      let r = this.nextTokenStart();
      return this.isUnparsedContextual(r, t);
    }
    eatContextual(t) {
      return this.isContextual(t) ? (this.next(), !0) : !1;
    }
    expectContextual(t, r) {
      if (!this.eatContextual(t)) {
        if (r != null)
          throw this.raise(r, this.state.startLoc);
        this.unexpected(null, t);
      }
    }
    canInsertSemicolon() {
      return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
    }
    hasPrecedingLineBreak() {
      return nx(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
    }
    hasFollowingLineBreak() {
      return nx(this.input, this.state.end, this.nextTokenStart());
    }
    isLineTerminator() {
      return this.eat(13) || this.canInsertSemicolon();
    }
    semicolon(t = !0) {
      (t ? this.isLineTerminator() : this.eat(13)) || this.raise(O.MissingSemicolon, this.state.lastTokEndLoc);
    }
    expect(t, r) {
      this.eat(t) || this.unexpected(r, t);
    }
    tryParse(t, r = this.state.clone()) {
      let s = {
        node: null
      };
      try {
        let n = t((a = null) => {
          throw s.node = a, s;
        });
        if (this.state.errors.length > r.errors.length) {
          let a = this.state;
          return this.state = r, this.state.tokensLength = a.tokensLength, {
            node: n,
            error: a.errors[r.errors.length],
            thrown: !1,
            aborted: !1,
            failState: a
          };
        }
        return {
          node: n,
          error: null,
          thrown: !1,
          aborted: !1,
          failState: null
        };
      } catch (n) {
        let a = this.state;
        if (this.state = r, n instanceof SyntaxError)
          return {
            node: null,
            error: n,
            thrown: !0,
            aborted: !1,
            failState: a
          };
        if (n === s)
          return {
            node: s.node,
            error: null,
            thrown: !1,
            aborted: !0,
            failState: a
          };
        throw n;
      }
    }
    checkExpressionErrors(t, r) {
      if (!t) return !1;
      let {
        shorthandAssignLoc: s,
        doubleProtoLoc: n,
        privateKeyLoc: a,
        optionalParametersLoc: o,
        voidPatternLoc: l
      } = t, u = !!s || !!n || !!o || !!a || !!l;
      if (!r)
        return u;
      s != null && this.raise(O.InvalidCoverInitializedName, s), n != null && this.raise(O.DuplicateProto, n), a != null && this.raise(O.UnexpectedPrivateField,
      a), o != null && this.unexpected(o), l != null && this.raise(O.InvalidCoverDiscardElement, l);
    }
    isLiteralPropertyName() {
      return dx(this.state.type);
    }
    isPrivateName(t) {
      return t.type === "PrivateName";
    }
    getPrivateNameSV(t) {
      return t.id.name;
    }
    hasPropertyAsPrivateName(t) {
      return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
    }
    isObjectProperty(t) {
      return t.type === "ObjectProperty";
    }
    isObjectMethod(t) {
      return t.type === "ObjectMethod";
    }
    initializeScopes(t = this.options.sourceType === "module") {
      let r = this.state.labels;
      this.state.labels = [];
      let s = this.exportedIdentifiers;
      this.exportedIdentifiers = /* @__PURE__ */ new Set();
      let n = this.inModule;
      this.inModule = t;
      let a = this.scope, o = this.getScopeHandler();
      this.scope = new o(this, t);
      let l = this.prodParam;
      this.prodParam = new A0();
      let u = this.classScope;
      this.classScope = new N0(this);
      let c = this.expressionScope;
      return this.expressionScope = new B0(this), () => {
        this.state.labels = r, this.exportedIdentifiers = s, this.inModule = n, this.scope = a, this.prodParam = l, this.classScope = u, this.
        expressionScope = c;
      };
    }
    enterInitialScopes() {
      let t = 0;
      (this.inModule || this.optionFlags & 1) && (t |= 2), this.optionFlags & 32 && (t |= 1);
      let r = !this.inModule && this.options.sourceType === "commonjs";
      (r || this.optionFlags & 2) && (t |= 4), this.prodParam.enter(t);
      let s = r ? 514 : 1;
      this.optionFlags & 4 && (s |= 512), this.scope.enter(s);
    }
    checkDestructuringPrivate(t) {
      let {
        privateKeyLoc: r
      } = t;
      r !== null && this.expectPlugin("destructuringPrivate", r);
    }
  }, wi = class {
    static {
      i(this, "ExpressionErrors");
    }
    constructor() {
      this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null, this.voidPatternLoc =
      null;
    }
  }, Ii = class {
    static {
      i(this, "Node");
    }
    constructor(t, r, s) {
      this.type = "", this.start = r, this.end = 0, this.loc = new Di(s), t?.optionFlags & 128 && (this.range = [r, 0]), t != null && t.filename &&
      (this.loc.filename = t.filename);
    }
  }, F0 = Ii.prototype;
  F0.__clone = function() {
    let e = new Ii(void 0, this.start, this.loc.start), t = Object.keys(this);
    for (let r = 0, s = t.length; r < s; r++) {
      let n = t[r];
      n !== "leadingComments" && n !== "trailingComments" && n !== "innerComments" && (e[n] = this[n]);
    }
    return e;
  };
  var L0 = class extends k0 {
    static {
      i(this, "NodeUtils");
    }
    startNode() {
      let t = this.state.startLoc;
      return new Ii(this, t.index, t);
    }
    startNodeAt(t) {
      return new Ii(this, t.index, t);
    }
    startNodeAtNode(t) {
      return this.startNodeAt(t.loc.start);
    }
    finishNode(t, r) {
      return this.finishNodeAt(t, r, this.state.lastTokEndLoc);
    }
    finishNodeAt(t, r, s) {
      return t.type = r, t.end = s.index, t.loc.end = s, this.optionFlags & 128 && (t.range[1] = s.index), this.optionFlags & 4096 && this.processComment(
      t), t;
    }
    resetStartLocation(t, r) {
      t.start = r.index, t.loc.start = r, this.optionFlags & 128 && (t.range[0] = r.index);
    }
    resetEndLocation(t, r = this.state.lastTokEndLoc) {
      t.end = r.index, t.loc.end = r, this.optionFlags & 128 && (t.range[1] = r.index);
    }
    resetStartLocationFromNode(t, r) {
      this.resetStartLocation(t, r.loc.start);
    }
    castNodeTo(t, r) {
      return t.type = r, t;
    }
    cloneIdentifier(t) {
      let {
        type: r,
        start: s,
        end: n,
        loc: a,
        range: o,
        name: l
      } = t, u = Object.create(F0);
      return u.type = r, u.start = s, u.end = n, u.loc = a, u.range = o, u.name = l, t.extra && (u.extra = t.extra), u;
    }
    cloneStringLiteral(t) {
      let {
        type: r,
        start: s,
        end: n,
        loc: a,
        range: o,
        extra: l
      } = t, u = Object.create(F0);
      return u.type = r, u.start = s, u.end = n, u.loc = a, u.range = o, u.extra = l, u.value = t.value, u;
    }
  }, j0 = /* @__PURE__ */ i((e) => e.type === "ParenthesizedExpression" ? j0(e.expression) : e, "unwrapParenthesizedExpression"), M0 = class extends L0 {
    static {
      i(this, "LValParser");
    }
    toAssignable(t, r = !1) {
      var s, n;
      let a;
      switch ((t.type === "ParenthesizedExpression" || (s = t.extra) != null && s.parenthesized) && (a = j0(t), r ? a.type === "Identifier" ?
      this.expressionScope.recordArrowParameterBindingError(O.InvalidParenthesizedAssignment, t) : a.type !== "CallExpression" && a.type !==
      "MemberExpression" && !this.isOptionalMemberExpression(a) && this.raise(O.InvalidParenthesizedAssignment, t) : this.raise(O.InvalidParenthesizedAssignment,
      t)), t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          break;
        case "ObjectExpression":
          this.castNodeTo(t, "ObjectPattern");
          for (let l = 0, u = t.properties.length, c = u - 1; l < u; l++) {
            var o;
            let p = t.properties[l], f = l === c;
            this.toAssignableObjectExpressionProp(p, f, r), f && p.type === "RestElement" && (o = t.extra) != null && o.trailingCommaLoc && this.
            raise(O.RestTrailingComma, t.extra.trailingCommaLoc);
          }
          break;
        case "ObjectProperty": {
          let {
            key: l,
            value: u
          } = t;
          this.isPrivateName(l) && this.classScope.usePrivateName(this.getPrivateNameSV(l), l.loc.start), this.toAssignable(u, r);
          break;
        }
        case "SpreadElement":
          throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignabl\
e's caller.");
        case "ArrayExpression":
          this.castNodeTo(t, "ArrayPattern"), this.toAssignableList(t.elements, (n = t.extra) == null ? void 0 : n.trailingCommaLoc, r);
          break;
        case "AssignmentExpression":
          t.operator !== "=" && this.raise(O.MissingEqInAssignment, t.left.loc.end), this.castNodeTo(t, "AssignmentPattern"), delete t.operator,
          t.left.type === "VoidPattern" && this.raise(O.VoidPatternInitializer, t.left), this.toAssignable(t.left, r);
          break;
        case "ParenthesizedExpression":
          this.toAssignable(a, r);
          break;
      }
    }
    toAssignableObjectExpressionProp(t, r, s) {
      if (t.type === "ObjectMethod")
        this.raise(t.kind === "get" || t.kind === "set" ? O.PatternHasAccessor : O.PatternHasMethod, t.key);
      else if (t.type === "SpreadElement") {
        this.castNodeTo(t, "RestElement");
        let n = t.argument;
        this.checkToRestConversion(n, !1), this.toAssignable(n, s), r || this.raise(O.RestTrailingComma, t);
      } else
        this.toAssignable(t, s);
    }
    toAssignableList(t, r, s) {
      let n = t.length - 1;
      for (let a = 0; a <= n; a++) {
        let o = t[a];
        o && (this.toAssignableListItem(t, a, s), o.type === "RestElement" && (a < n ? this.raise(O.RestTrailingComma, o) : r && this.raise(
        O.RestTrailingComma, r)));
      }
    }
    toAssignableListItem(t, r, s) {
      let n = t[r];
      if (n.type === "SpreadElement") {
        this.castNodeTo(n, "RestElement");
        let a = n.argument;
        this.checkToRestConversion(a, !0), this.toAssignable(a, s);
      } else
        this.toAssignable(n, s);
    }
    isAssignable(t, r) {
      switch (t.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "RestElement":
        case "VoidPattern":
          return !0;
        case "ObjectExpression": {
          let s = t.properties.length - 1;
          return t.properties.every((n, a) => n.type !== "ObjectMethod" && (a === s || n.type !== "SpreadElement") && this.isAssignable(n));
        }
        case "ObjectProperty":
          return this.isAssignable(t.value);
        case "SpreadElement":
          return this.isAssignable(t.argument);
        case "ArrayExpression":
          return t.elements.every((s) => s === null || this.isAssignable(s));
        case "AssignmentExpression":
          return t.operator === "=";
        case "ParenthesizedExpression":
          return this.isAssignable(t.expression);
        case "MemberExpression":
        case "OptionalMemberExpression":
          return !r;
        default:
          return !1;
      }
    }
    toReferencedList(t, r) {
      return t;
    }
    toReferencedListDeep(t, r) {
      this.toReferencedList(t, r);
      for (let s of t)
        s?.type === "ArrayExpression" && this.toReferencedListDeep(s.elements);
    }
    parseSpread(t) {
      let r = this.startNode();
      return this.next(), r.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(r, "SpreadElement");
    }
    parseRestBinding() {
      let t = this.startNode();
      this.next();
      let r = this.parseBindingAtom();
      return r.type === "VoidPattern" && this.raise(O.UnexpectedVoidPattern, r), t.argument = r, this.finishNode(t, "RestElement");
    }
    parseBindingAtom() {
      switch (this.state.type) {
        case 0: {
          let t = this.startNode();
          return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
        }
        case 5:
          return this.parseObjectLike(8, !0);
        case 88:
          return this.parseVoidPattern(null);
      }
      return this.parseIdentifier();
    }
    parseBindingList(t, r, s) {
      let n = s & 1, a = [], o = !0;
      for (; !this.eat(t); )
        if (o ? o = !1 : this.expect(12), n && this.match(12))
          a.push(null);
        else {
          if (this.eat(t))
            break;
          if (this.match(21)) {
            let l = this.parseRestBinding();
            if ((this.hasPlugin("flow") || s & 2) && (l = this.parseFunctionParamType(l)), a.push(l), !this.checkCommaAfterRest(r)) {
              this.expect(t);
              break;
            }
          } else {
            let l = [];
            if (s & 2)
              for (this.match(26) && this.hasPlugin("decorators") && this.raise(O.UnsupportedParameterDecorator, this.state.startLoc); this.
              match(26); )
                l.push(this.parseDecorator());
            a.push(this.parseBindingElement(s, l));
          }
        }
      return a;
    }
    parseBindingRestProperty(t) {
      return this.next(), this.hasPlugin("discardBinding") && this.match(88) ? (t.argument = this.parseVoidPattern(null), this.raise(O.UnexpectedVoidPattern,
      t.argument)) : t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
    }
    parseBindingProperty() {
      let {
        type: t,
        startLoc: r
      } = this.state;
      if (t === 21)
        return this.parseBindingRestProperty(this.startNode());
      let s = this.startNode();
      return t === 139 ? (this.expectPlugin("destructuringPrivate", r), this.classScope.usePrivateName(this.state.value, r), s.key = this.parsePrivateName()) :
      this.parsePropertyName(s), s.method = !1, this.parseObjPropValue(s, r, !1, !1, !0, !1);
    }
    parseBindingElement(t, r) {
      let s = this.parseMaybeDefault();
      return (this.hasPlugin("flow") || t & 2) && this.parseFunctionParamType(s), r.length && (s.decorators = r, this.resetStartLocationFromNode(
      s, r[0])), this.parseMaybeDefault(s.loc.start, s);
    }
    parseFunctionParamType(t) {
      return t;
    }
    parseMaybeDefault(t, r) {
      if (t ?? (t = this.state.startLoc), r = r ?? this.parseBindingAtom(), !this.eat(29)) return r;
      let s = this.startNodeAt(t);
      return r.type === "VoidPattern" && this.raise(O.VoidPatternInitializer, r), s.left = r, s.right = this.parseMaybeAssignAllowIn(), this.
      finishNode(s, "AssignmentPattern");
    }
    isValidLVal(t, r, s, n) {
      switch (t) {
        case "AssignmentPattern":
          return "left";
        case "RestElement":
          return "argument";
        case "ObjectProperty":
          return "value";
        case "ParenthesizedExpression":
          return "expression";
        case "ArrayPattern":
          return "elements";
        case "ObjectPattern":
          return "properties";
        case "VoidPattern":
          return !0;
        case "CallExpression":
          if (!r && !this.state.strict && this.optionFlags & 8192)
            return !0;
      }
      return !1;
    }
    isOptionalMemberExpression(t) {
      return t.type === "OptionalMemberExpression";
    }
    checkLVal(t, r, s = 64, n = !1, a = !1, o = !1, l = !1) {
      var u;
      let c = t.type;
      if (this.isObjectMethod(t)) return;
      let p = this.isOptionalMemberExpression(t);
      if (p || c === "MemberExpression") {
        p && (this.expectPlugin("optionalChainingAssign", t.loc.start), r.type !== "AssignmentExpression" && this.raise(O.InvalidLhsOptionalChaining,
        t, {
          ancestor: r
        })), s !== 64 && this.raise(O.InvalidPropertyBindingPattern, t);
        return;
      }
      if (c === "Identifier") {
        this.checkIdentifier(t, s, a);
        let {
          name: E
        } = t;
        n && (n.has(E) ? this.raise(O.ParamDupe, t) : n.add(E));
        return;
      } else c === "VoidPattern" && r.type === "CatchClause" && this.raise(O.VoidPatternCatchClauseParam, t);
      let f = j0(t);
      l || (l = f.type === "CallExpression" && (f.callee.type === "Import" || f.callee.type === "Super"));
      let h = this.isValidLVal(c, l, !(o || (u = t.extra) != null && u.parenthesized) && r.type === "AssignmentExpression", s);
      if (h === !0) return;
      if (h === !1) {
        let E = s === 64 ? O.InvalidLhs : O.InvalidLhsBinding;
        this.raise(E, t, {
          ancestor: r
        });
        return;
      }
      let b, T;
      typeof h == "string" ? (b = h, T = c === "ParenthesizedExpression") : [b, T] = h;
      let d = c === "ArrayPattern" || c === "ObjectPattern" ? {
        type: c
      } : r, g = t[b];
      if (Array.isArray(g))
        for (let E of g)
          E && this.checkLVal(E, d, s, n, a, T, !0);
      else g && this.checkLVal(g, d, s, n, a, T, l);
    }
    checkIdentifier(t, r, s = !1) {
      this.state.strict && (s ? Tx(t.name, this.inModule) : gx(t.name)) && (r === 64 ? this.raise(O.StrictEvalArguments, t, {
        referenceName: t.name
      }) : this.raise(O.StrictEvalArgumentsBinding, t, {
        bindingName: t.name
      })), r & 8192 && t.name === "let" && this.raise(O.LetInLexicalBinding, t), r & 64 || this.declareNameFromIdentifier(t, r);
    }
    declareNameFromIdentifier(t, r) {
      this.scope.declareName(t.name, r, t.loc.start);
    }
    checkToRestConversion(t, r) {
      switch (t.type) {
        case "ParenthesizedExpression":
          this.checkToRestConversion(t.expression, r);
          break;
        case "Identifier":
        case "MemberExpression":
          break;
        case "ArrayExpression":
        case "ObjectExpression":
          if (r) break;
        default:
          this.raise(O.InvalidRestAssignmentPattern, t);
      }
    }
    checkCommaAfterRest(t) {
      return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? O.RestTrailingComma : O.ElementAfterRest, this.state.startLoc), !0) :
      !1;
    }
  }, b0 = /in(?:stanceof)?|as|satisfies/y;
  function TH(e) {
    if (e == null)
      throw new Error(`Unexpected ${e} value.`);
    return e;
  }
  i(TH, "nonNull");
  function ox(e) {
    if (!e)
      throw new Error("Assert fail");
  }
  i(ox, "assert");
  var ee = ss`typescript`({
    AbstractMethodHasImplementation: /* @__PURE__ */ i(({
      methodName: e
    }) => `Method '${e}' cannot have an implementation because it is marked abstract.`, "AbstractMethodHasImplementation"),
    AbstractPropertyHasInitializer: /* @__PURE__ */ i(({
      propertyName: e
    }) => `Property '${e}' cannot have an initializer because it is marked abstract.`, "AbstractPropertyHasInitializer"),
    AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
    AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or num\
eric literal or literal enum reference.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: /* @__PURE__ */ i(({
      kind: e
    }) => `'declare' is not allowed in ${e}ters.`, "DeclareAccessor"),
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: /* @__PURE__ */ i(({
      modifier: e
    }) => `Accessibility modifier already seen: '${e}'.`, "DuplicateAccessibilityModifier"),
    DuplicateModifier: /* @__PURE__ */ i(({
      modifier: e
    }) => `Duplicate modifier: '${e}'.`, "DuplicateModifier"),
    EmptyHeritageClauseType: /* @__PURE__ */ i(({
      token: e
    }) => `'${e}' list cannot be empty.`, "EmptyHeritageClauseType"),
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
    IncompatibleModifiers: /* @__PURE__ */ i(({
      modifiers: e
    }) => `'${e[0]}' modifier cannot be used with '${e[1]}' modifier.`, "IncompatibleModifiers"),
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: /* @__PURE__ */ i(({
      modifier: e
    }) => `Index signatures cannot have an accessibility modifier ('${e}').`, "IndexSignatureHasAccessibility"),
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
    InvalidHeritageClauseType: /* @__PURE__ */ i(({
      token: e
    }) => `'${e}' list can only include identifiers or qualified-names with optional type arguments.`, "InvalidHeritageClauseType"),
    InvalidModifierOnAwaitUsingDeclaration: /* @__PURE__ */ i((e) => `'${e}' modifier cannot appear on an await using declaration.`, "Invali\
dModifierOnAwaitUsingDeclaration"),
    InvalidModifierOnTypeMember: /* @__PURE__ */ i(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type member.`, "InvalidModifierOnTypeMember"),
    InvalidModifierOnTypeParameter: /* @__PURE__ */ i(({
      modifier: e
    }) => `'${e}' modifier cannot appear on a type parameter.`, "InvalidModifierOnTypeParameter"),
    InvalidModifierOnTypeParameterPositions: /* @__PURE__ */ i(({
      modifier: e
    }) => `'${e}' modifier can only appear on a type parameter of a class, interface or type alias.`, "InvalidModifierOnTypeParameterPositio\
ns"),
    InvalidModifierOnUsingDeclaration: /* @__PURE__ */ i((e) => `'${e}' modifier cannot appear on a using declaration.`, "InvalidModifierOnU\
singDeclaration"),
    InvalidModifiersOrder: /* @__PURE__ */ i(({
      orderedModifiers: e
    }) => `'${e[0]}' modifier must precede '${e[1]}' modifier.`, "InvalidModifiersOrder"),
    InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the i\
nstantiation expression in parentheses, or delete the type arguments.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifier: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: /* @__PURE__ */ i(({
      modifier: e
    }) => `Private elements cannot have an accessibility modifier ('${e}').`, "PrivateElementHasAccessibility"),
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
    ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
    SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    SingleTypeParameterWithoutTrailingComma: /* @__PURE__ */ i(({
      typeParameterName: e
    }) => `Single type parameter ${e} should have a trailing comma. Example usage: <${e},>.`, "SingleTypeParameterWithoutTrailingComma"),
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`n\
ame?: type`), rather than after the type (`name: type?`).",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number =\
 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statemen\
t.",
    TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statemen\
t.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: /* @__PURE__ */ i(({
      type: e
    }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${e}.`, "UnsupportedSignatureParameterKind"),
    UsingDeclarationInAmbientContext: /* @__PURE__ */ i((e) => `'${e}' declarations are not allowed in ambient contexts.`, "UsingDeclaration\
InAmbientContext")
  });
  function xH(e) {
    switch (e) {
      case "any":
        return "TSAnyKeyword";
      case "boolean":
        return "TSBooleanKeyword";
      case "bigint":
        return "TSBigIntKeyword";
      case "never":
        return "TSNeverKeyword";
      case "number":
        return "TSNumberKeyword";
      case "object":
        return "TSObjectKeyword";
      case "string":
        return "TSStringKeyword";
      case "symbol":
        return "TSSymbolKeyword";
      case "undefined":
        return "TSUndefinedKeyword";
      case "unknown":
        return "TSUnknownKeyword";
      default:
        return;
    }
  }
  i(xH, "keywordTypeFromName");
  function lx(e) {
    return e === "private" || e === "public" || e === "protected";
  }
  i(lx, "tsIsAccessModifier");
  function EH(e) {
    return e === "in" || e === "out";
  }
  i(EH, "tsIsVarianceAnnotations");
  var SH = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "TypeScriptParserMixin");
    }
    constructor(...r) {
      super(...r), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out"],
        disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ee.InvalidModifierOnTypeParameter
      }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["const"],
        disallowedModifiers: ["in", "out"],
        errorTemplate: ee.InvalidModifierOnTypeParameterPositions
      }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
        allowedModifiers: ["in", "out", "const"],
        disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
        errorTemplate: ee.InvalidModifierOnTypeParameter
      });
    }
    getScopeHandler() {
      return P0;
    }
    tsIsIdentifier() {
      return ke(this.state.type);
    }
    tsTokenCanFollowModifier() {
      return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
    }
    tsNextTokenOnSameLineAndCanFollowModifier() {
      return this.next(), this.hasPrecedingLineBreak() ? !1 : this.tsTokenCanFollowModifier();
    }
    tsNextTokenCanFollowModifier() {
      return this.match(106) ? (this.next(), this.tsTokenCanFollowModifier()) : this.tsNextTokenOnSameLineAndCanFollowModifier();
    }
    tsParseModifier(r, s, n) {
      if (!ke(this.state.type) && this.state.type !== 58 && this.state.type !== 75)
        return;
      let a = this.state.value;
      if (r.includes(a)) {
        if (n && this.match(106) || s && this.tsIsStartOfStaticBlocks())
          return;
        if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)))
          return a;
      }
    }
    tsParseModifiers({
      allowedModifiers: r,
      disallowedModifiers: s,
      stopOnStartOfClassStaticBlock: n,
      errorTemplate: a = ee.InvalidModifierOnTypeMember
    }, o) {
      let l = /* @__PURE__ */ i((c, p, f, h) => {
        p === f && o[h] && this.raise(ee.InvalidModifiersOrder, c, {
          orderedModifiers: [f, h]
        });
      }, "enforceOrder"), u = /* @__PURE__ */ i((c, p, f, h) => {
        (o[f] && p === h || o[h] && p === f) && this.raise(ee.IncompatibleModifiers, c, {
          modifiers: [f, h]
        });
      }, "incompatible");
      for (; ; ) {
        let {
          startLoc: c
        } = this.state, p = this.tsParseModifier(r.concat(s ?? []), n, o.static);
        if (!p) break;
        lx(p) ? o.accessibility ? this.raise(ee.DuplicateAccessibilityModifier, c, {
          modifier: p
        }) : (l(c, p, p, "override"), l(c, p, p, "static"), l(c, p, p, "readonly"), o.accessibility = p) : EH(p) ? (o[p] && this.raise(ee.DuplicateModifier,
        c, {
          modifier: p
        }), o[p] = !0, l(c, p, "in", "out")) : (hasOwnProperty.call(o, p) ? this.raise(ee.DuplicateModifier, c, {
          modifier: p
        }) : (l(c, p, "static", "readonly"), l(c, p, "static", "override"), l(c, p, "override", "readonly"), l(c, p, "abstract", "override"),
        u(c, p, "declare", "override"), u(c, p, "static", "abstract")), o[p] = !0), s != null && s.includes(p) && this.raise(a, c, {
          modifier: p
        });
      }
    }
    tsIsListTerminator(r) {
      switch (r) {
        case "EnumMembers":
        case "TypeMembers":
          return this.match(8);
        case "HeritageClauseElement":
          return this.match(5);
        case "TupleElementTypes":
          return this.match(3);
        case "TypeParametersOrArguments":
          return this.match(48);
      }
    }
    tsParseList(r, s) {
      let n = [];
      for (; !this.tsIsListTerminator(r); )
        n.push(s());
      return n;
    }
    tsParseDelimitedList(r, s, n) {
      return TH(this.tsParseDelimitedListWorker(r, s, !0, n));
    }
    tsParseDelimitedListWorker(r, s, n, a) {
      let o = [], l = -1;
      for (; !this.tsIsListTerminator(r); ) {
        l = -1;
        let u = s();
        if (u == null)
          return;
        if (o.push(u), this.eat(12)) {
          l = this.state.lastTokStartLoc.index;
          continue;
        }
        if (this.tsIsListTerminator(r))
          break;
        n && this.expect(12);
        return;
      }
      return a && (a.value = l), o;
    }
    tsParseBracketedList(r, s, n, a, o) {
      a || (n ? this.expect(0) : this.expect(47));
      let l = this.tsParseDelimitedList(r, s, o);
      return n ? this.expect(3) : this.expect(48), l;
    }
    tsParseImportType() {
      let r = this.startNode();
      return this.expect(83), this.expect(10), this.match(134) ? r.argument = this.parseStringLiteral(this.state.value) : (this.raise(ee.UnsupportedImportTypeArgument,
      this.state.startLoc), r.argument = super.parseExprAtom()), this.eat(12) ? r.options = this.tsParseImportTypeOptions() : r.options = null,
      this.expect(11), this.eat(16) && (r.qualifier = this.tsParseEntityName(3)), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSImportType");
    }
    tsParseImportTypeOptions() {
      let r = this.startNode();
      this.expect(5);
      let s = this.startNode();
      return this.isContextual(76) ? (s.method = !1, s.key = this.parseIdentifier(!0), s.computed = !1, s.shorthand = !1) : this.unexpected(
      null, 76), this.expect(14), s.value = this.tsParseImportTypeWithPropertyValue(), r.properties = [this.finishObjectProperty(s)], this.eat(
      12), this.expect(8), this.finishNode(r, "ObjectExpression");
    }
    tsParseImportTypeWithPropertyValue() {
      let r = this.startNode(), s = [];
      for (this.expect(5); !this.match(8); ) {
        let n = this.state.type;
        ke(n) || n === 134 ? s.push(super.parsePropertyDefinition(null)) : this.unexpected(), this.eat(12);
      }
      return r.properties = s, this.next(), this.finishNode(r, "ObjectExpression");
    }
    tsParseEntityName(r) {
      let s;
      if (r & 1 && this.match(78))
        if (r & 2)
          s = this.parseIdentifier(!0);
        else {
          let n = this.startNode();
          this.next(), s = this.finishNode(n, "ThisExpression");
        }
      else
        s = this.parseIdentifier(!!(r & 1));
      for (; this.eat(16); ) {
        let n = this.startNodeAtNode(s);
        n.left = s, n.right = this.parseIdentifier(!!(r & 1)), s = this.finishNode(n, "TSQualifiedName");
      }
      return s;
    }
    tsParseTypeReference() {
      let r = this.startNode();
      return r.typeName = this.tsParseEntityName(1), !this.hasPrecedingLineBreak() && this.match(47) && (r.typeParameters = this.tsParseTypeArguments()),
      this.finishNode(r, "TSTypeReference");
    }
    tsParseThisTypePredicate(r) {
      this.next();
      let s = this.startNodeAtNode(r);
      return s.parameterName = r, s.typeAnnotation = this.tsParseTypeAnnotation(!1), s.asserts = !1, this.finishNode(s, "TSTypePredicate");
    }
    tsParseThisTypeNode() {
      let r = this.startNode();
      return this.next(), this.finishNode(r, "TSThisType");
    }
    tsParseTypeQuery() {
      let r = this.startNode();
      return this.expect(87), this.match(83) ? r.exprName = this.tsParseImportType() : r.exprName = this.tsParseEntityName(3), !this.hasPrecedingLineBreak() &&
      this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSTypeQuery");
    }
    tsParseTypeParameter(r) {
      let s = this.startNode();
      return r(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(
      29), this.finishNode(s, "TSTypeParameter");
    }
    tsTryParseTypeParameters(r) {
      if (this.match(47))
        return this.tsParseTypeParameters(r);
    }
    tsParseTypeParameters(r) {
      let s = this.startNode();
      this.match(47) || this.match(143) ? this.next() : this.unexpected();
      let n = {
        value: -1
      };
      return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, r), !1, !0, n), s.params.
      length === 0 && this.raise(ee.EmptyTypeParameters, s), n.value !== -1 && this.addExtra(s, "trailingComma", n.value), this.finishNode(s,
      "TSTypeParameterDeclaration");
    }
    tsFillSignature(r, s) {
      let n = r === 19, a = "parameters", o = "typeAnnotation";
      s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[a] = this.tsParseBindingListForSignature(),
      n ? s[o] = this.tsParseTypeOrTypePredicateAnnotation(r) : this.match(r) && (s[o] = this.tsParseTypeOrTypePredicateAnnotation(r));
    }
    tsParseBindingListForSignature() {
      let r = super.parseBindingList(11, 41, 2);
      for (let s of r) {
        let {
          type: n
        } = s;
        (n === "AssignmentPattern" || n === "TSParameterProperty") && this.raise(ee.UnsupportedSignatureParameterKind, s, {
          type: n
        });
      }
      return r;
    }
    tsParseTypeMemberSemicolon() {
      !this.eat(12) && !this.isLineTerminator() && this.expect(13);
    }
    tsParseSignatureMember(r, s) {
      return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, r);
    }
    tsIsUnambiguouslyIndexSignature() {
      return this.next(), ke(this.state.type) ? (this.next(), this.match(14)) : !1;
    }
    tsTryParseIndexSignature(r) {
      if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this))))
        return;
      this.expect(0);
      let s = this.parseIdentifier();
      s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), r.parameters = [s];
      let n = this.tsTryParseTypeAnnotation();
      return n && (r.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSIndexSignature");
    }
    tsParsePropertyOrMethodSignature(r, s) {
      if (this.eat(17) && (r.optional = !0), this.match(10) || this.match(47)) {
        s && this.raise(ee.ReadonlyForMethodSignature, r);
        let n = r;
        n.kind && this.match(47) && this.raise(ee.AccessorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, n), this.
        tsParseTypeMemberSemicolon();
        let a = "parameters", o = "typeAnnotation";
        if (n.kind === "get")
          n[a].length > 0 && (this.raise(O.BadGetterArity, this.state.curPosition()), this.isThisParam(n[a][0]) && this.raise(ee.AccessorCannotDeclareThisParameter,
          this.state.curPosition()));
        else if (n.kind === "set") {
          if (n[a].length !== 1)
            this.raise(O.BadSetterArity, this.state.curPosition());
          else {
            let l = n[a][0];
            this.isThisParam(l) && this.raise(ee.AccessorCannotDeclareThisParameter, this.state.curPosition()), l.type === "Identifier" && l.
            optional && this.raise(ee.SetAccessorCannotHaveOptionalParameter, this.state.curPosition()), l.type === "RestElement" && this.raise(
            ee.SetAccessorCannotHaveRestParameter, this.state.curPosition());
          }
          n[o] && this.raise(ee.SetAccessorCannotHaveReturnType, n[o]);
        } else
          n.kind = "method";
        return this.finishNode(n, "TSMethodSignature");
      } else {
        let n = r;
        s && (n.readonly = !0);
        let a = this.tsTryParseTypeAnnotation();
        return a && (n.typeAnnotation = a), this.tsParseTypeMemberSemicolon(), this.finishNode(n, "TSPropertySignature");
      }
    }
    tsParseTypeMember() {
      let r = this.startNode();
      if (this.match(10) || this.match(47))
        return this.tsParseSignatureMember("TSCallSignatureDeclaration", r);
      if (this.match(77)) {
        let n = this.startNode();
        return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", r) : (r.key = this.
        createIdentifier(n, "new"), this.tsParsePropertyOrMethodSignature(r, !1));
      }
      this.tsParseModifiers({
        allowedModifiers: ["readonly"],
        disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
      }, r);
      let s = this.tsTryParseIndexSignature(r);
      return s || (super.parsePropertyName(r), !r.computed && r.key.type === "Identifier" && (r.key.name === "get" || r.key.name === "set") &&
      this.tsTokenCanFollowModifier() && (r.kind = r.key.name, super.parsePropertyName(r), !this.match(10) && !this.match(47) && this.unexpected(
      null, 10)), this.tsParsePropertyOrMethodSignature(r, !!r.readonly));
    }
    tsParseTypeLiteral() {
      let r = this.startNode();
      return r.members = this.tsParseObjectTypeMembers(), this.finishNode(r, "TSTypeLiteral");
    }
    tsParseObjectTypeMembers() {
      this.expect(5);
      let r = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
      return this.expect(8), r;
    }
    tsIsStartOfMappedType() {
      return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.
      tsIsIdentifier()) ? !1 : (this.next(), this.match(58)));
    }
    tsParseMappedType() {
      let r = this.startNode();
      this.expect(5), this.match(53) ? (r.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) &&
      (r.readonly = !0), this.expect(0);
      {
        let s = this.startNode();
        s.name = this.tsParseTypeParameterName(), s.constraint = this.tsExpectThenParseType(58), r.typeParameter = this.finishNode(s, "TSTyp\
eParameter");
      }
      return r.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (r.optional = this.state.value,
      this.next(), this.expect(17)) : this.eat(17) && (r.optional = !0), r.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(
      8), this.finishNode(r, "TSMappedType");
    }
    tsParseTupleType() {
      let r = this.startNode();
      r.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), !0, !1);
      let s = !1;
      return r.elementTypes.forEach((n) => {
        let {
          type: a
        } = n;
        s && a !== "TSRestType" && a !== "TSOptionalType" && !(a === "TSNamedTupleMember" && n.optional) && this.raise(ee.OptionalTypeBeforeRequired,
        n), s || (s = a === "TSNamedTupleMember" && n.optional || a === "TSOptionalType");
      }), this.finishNode(r, "TSTupleType");
    }
    tsParseTupleElementType() {
      let r = this.state.startLoc, s = this.eat(21), {
        startLoc: n
      } = this.state, a, o, l, u, p = Fr(this.state.type) ? this.lookaheadCharCode() : null;
      if (p === 58)
        a = !0, l = !1, o = this.parseIdentifier(!0), this.expect(14), u = this.tsParseType();
      else if (p === 63) {
        l = !0;
        let f = this.state.value, h = this.tsParseNonArrayType();
        this.lookaheadCharCode() === 58 ? (a = !0, o = this.createIdentifier(this.startNodeAt(n), f), this.expect(17), this.expect(14), u = this.
        tsParseType()) : (a = !1, u = h, this.expect(17));
      } else
        u = this.tsParseType(), l = this.eat(17), a = this.eat(14);
      if (a) {
        let f;
        o ? (f = this.startNodeAt(n), f.optional = l, f.label = o, f.elementType = u, this.eat(17) && (f.optional = !0, this.raise(ee.TupleOptionalAfterType,
        this.state.lastTokStartLoc))) : (f = this.startNodeAt(n), f.optional = l, this.raise(ee.InvalidTupleMemberLabel, u), f.label = u, f.
        elementType = this.tsParseType()), u = this.finishNode(f, "TSNamedTupleMember");
      } else if (l) {
        let f = this.startNodeAt(n);
        f.typeAnnotation = u, u = this.finishNode(f, "TSOptionalType");
      }
      if (s) {
        let f = this.startNodeAt(r);
        f.typeAnnotation = u, u = this.finishNode(f, "TSRestType");
      }
      return u;
    }
    tsParseParenthesizedType() {
      let r = this.startNode();
      return this.expect(10), r.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(r, "TSParenthesizedType");
    }
    tsParseFunctionOrConstructorType(r, s) {
      let n = this.startNode();
      return r === "TSConstructorType" && (n.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.
      tsFillSignature(19, n)), this.finishNode(n, r);
    }
    tsParseLiteralTypeNode() {
      let r = this.startNode();
      switch (this.state.type) {
        case 135:
        case 136:
        case 134:
        case 85:
        case 86:
          r.literal = super.parseExprAtom();
          break;
        default:
          this.unexpected();
      }
      return this.finishNode(r, "TSLiteralType");
    }
    tsParseTemplateLiteralType() {
      {
        let r = this.startNode();
        return r.literal = super.parseTemplate(!1), this.finishNode(r, "TSLiteralType");
      }
    }
    parseTemplateSubstitution() {
      return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
    }
    tsParseThisTypeOrThisTypePredicate() {
      let r = this.tsParseThisTypeNode();
      return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(r) : r;
    }
    tsParseNonArrayType() {
      switch (this.state.type) {
        case 134:
        case 135:
        case 136:
        case 85:
        case 86:
          return this.tsParseLiteralTypeNode();
        case 53:
          if (this.state.value === "-") {
            let r = this.startNode(), s = this.lookahead();
            return s.type !== 135 && s.type !== 136 && this.unexpected(), r.literal = this.parseMaybeUnary(), this.finishNode(r, "TSLiteralT\
ype");
          }
          break;
        case 78:
          return this.tsParseThisTypeOrThisTypePredicate();
        case 87:
          return this.tsParseTypeQuery();
        case 83:
          return this.tsParseImportType();
        case 5:
          return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
        case 0:
          return this.tsParseTupleType();
        case 10:
          return this.tsParseParenthesizedType();
        case 25:
        case 24:
          return this.tsParseTemplateLiteralType();
        default: {
          let {
            type: r
          } = this.state;
          if (ke(r) || r === 88 || r === 84) {
            let s = r === 88 ? "TSVoidKeyword" : r === 84 ? "TSNullKeyword" : xH(this.state.value);
            if (s !== void 0 && this.lookaheadCharCode() !== 46) {
              let n = this.startNode();
              return this.next(), this.finishNode(n, s);
            }
            return this.tsParseTypeReference();
          }
        }
      }
      throw this.unexpected();
    }
    tsParseArrayTypeOrHigher() {
      let {
        startLoc: r
      } = this.state, s = this.tsParseNonArrayType();
      for (; !this.hasPrecedingLineBreak() && this.eat(0); )
        if (this.match(3)) {
          let n = this.startNodeAt(r);
          n.elementType = s, this.expect(3), s = this.finishNode(n, "TSArrayType");
        } else {
          let n = this.startNodeAt(r);
          n.objectType = s, n.indexType = this.tsParseType(), this.expect(3), s = this.finishNode(n, "TSIndexedAccessType");
        }
      return s;
    }
    tsParseTypeOperator() {
      let r = this.startNode(), s = this.state.value;
      return this.next(), r.operator = s, r.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(
      r), this.finishNode(r, "TSTypeOperator");
    }
    tsCheckTypeAnnotationForReadOnly(r) {
      switch (r.typeAnnotation.type) {
        case "TSTupleType":
        case "TSArrayType":
          return;
        default:
          this.raise(ee.UnexpectedReadonly, r);
      }
    }
    tsParseInferType() {
      let r = this.startNode();
      this.expectContextual(115);
      let s = this.startNode();
      return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), r.typeParameter =
      this.finishNode(s, "TSTypeParameter"), this.finishNode(r, "TSInferType");
    }
    tsParseConstraintForInferType() {
      if (this.eat(81)) {
        let r = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
        if (this.state.inDisallowConditionalTypesContext || !this.match(17))
          return r;
      }
    }
    tsParseTypeOperatorOrHigher() {
      return $Y(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() :
      this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
    }
    tsParseUnionOrIntersectionType(r, s, n) {
      let a = this.startNode(), o = this.eat(n), l = [];
      do
        l.push(s());
      while (this.eat(n));
      return l.length === 1 && !o ? l[0] : (a.types = l, this.finishNode(a, r));
    }
    tsParseIntersectionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
    }
    tsParseUnionTypeOrHigher() {
      return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
    }
    tsIsStartOfFunctionType() {
      return this.match(47) ? !0 : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
    }
    tsSkipParameterStart() {
      if (ke(this.state.type) || this.match(78))
        return this.next(), !0;
      if (this.match(5)) {
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return this.parseObjectLike(8, !0), r.length === s;
        } catch {
          return !1;
        }
      }
      if (this.match(0)) {
        this.next();
        let {
          errors: r
        } = this.state, s = r.length;
        try {
          return super.parseBindingList(3, 93, 1), r.length === s;
        } catch {
          return !1;
        }
      }
      return !1;
    }
    tsIsUnambiguouslyStartOfFunctionType() {
      return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(
      17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
    }
    tsParseTypeOrTypePredicateAnnotation(r) {
      return this.tsInType(() => {
        let s = this.startNode();
        this.expect(r);
        let n = this.startNode(), a = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
        if (a && this.match(78)) {
          let u = this.tsParseThisTypeOrThisTypePredicate();
          return u.type === "TSThisType" ? (n.parameterName = u, n.asserts = !0, n.typeAnnotation = null, u = this.finishNode(n, "TSTypePred\
icate")) : (this.resetStartLocationFromNode(u, n), u.asserts = !0), s.typeAnnotation = u, this.finishNode(s, "TSTypeAnnotation");
        }
        let o = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
        if (!o)
          return a ? (n.parameterName = this.parseIdentifier(), n.asserts = a, n.typeAnnotation = null, s.typeAnnotation = this.finishNode(n,
          "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(!1, s);
        let l = this.tsParseTypeAnnotation(!1);
        return n.parameterName = o, n.typeAnnotation = l, n.asserts = a, s.typeAnnotation = this.finishNode(n, "TSTypePredicate"), this.finishNode(
        s, "TSTypeAnnotation");
      });
    }
    tsTryParseTypeOrTypePredicateAnnotation() {
      if (this.match(14))
        return this.tsParseTypeOrTypePredicateAnnotation(14);
    }
    tsTryParseTypeAnnotation() {
      if (this.match(14))
        return this.tsParseTypeAnnotation();
    }
    tsTryParseType() {
      return this.tsEatThenParseType(14);
    }
    tsParseTypePredicatePrefix() {
      let r = this.parseIdentifier();
      if (this.isContextual(116) && !this.hasPrecedingLineBreak())
        return this.next(), r;
    }
    tsParseTypePredicateAsserts() {
      if (this.state.type !== 109)
        return !1;
      let r = this.state.containsEsc;
      return this.next(), !ke(this.state.type) && !this.match(78) ? !1 : (r && this.raise(O.InvalidEscapedReservedWord, this.state.lastTokStartLoc,
      {
        reservedWord: "asserts"
      }), !0);
    }
    tsParseTypeAnnotation(r = !0, s = this.startNode()) {
      return this.tsInType(() => {
        r && this.expect(14), s.typeAnnotation = this.tsParseType();
      }), this.finishNode(s, "TSTypeAnnotation");
    }
    tsParseType() {
      ox(this.state.inType);
      let r = this.tsParseNonConditionalType();
      if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81))
        return r;
      let s = this.startNodeAtNode(r);
      return s.checkType = r, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(
      17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(
      () => this.tsParseType()), this.finishNode(s, "TSConditionalType");
    }
    isAbstractConstructorSignature() {
      return this.isContextual(124) && this.isLookaheadContextual("new");
    }
    tsParseNonConditionalType() {
      return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType(
      "TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", !0) : this.tsParseUnionTypeOrHigher();
    }
    tsParseTypeAssertion() {
      this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(ee.ReservedTypeAssertion, this.state.startLoc);
      let r = this.startNode();
      return r.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.
      expect(48), r.expression = this.parseMaybeUnary(), this.finishNode(r, "TSTypeAssertion");
    }
    tsParseHeritageClause(r) {
      let s = this.state.startLoc, n = this.tsParseDelimitedList("HeritageClauseElement", () => {
        {
          let a = this.startNode();
          return a.expression = this.tsParseEntityName(3), this.match(47) && (a.typeParameters = this.tsParseTypeArguments()), this.finishNode(
          a, "TSExpressionWithTypeArguments");
        }
      });
      return n.length || this.raise(ee.EmptyHeritageClauseType, s, {
        token: r
      }), n;
    }
    tsParseInterfaceDeclaration(r, s = {}) {
      if (this.hasFollowingLineBreak()) return null;
      this.expectContextual(129), s.declare && (r.declare = !0), ke(this.state.type) ? (r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, 130)) : (r.id = null, this.raise(ee.MissingInterfaceName, this.state.startLoc)), r.typeParameters = this.tsTryParseTypeParameters(
      this.tsParseInOutConstModifiers), this.eat(81) && (r.extends = this.tsParseHeritageClause("extends"));
      let n = this.startNode();
      return n.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), r.body = this.finishNode(n, "TSInterfaceBody"), this.finishNode(
      r, "TSInterfaceDeclaration");
    }
    tsParseTypeAliasDeclaration(r) {
      return r.id = this.parseIdentifier(), this.checkIdentifier(r.id, 2), r.typeAnnotation = this.tsInType(() => {
        if (r.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookaheadCharCode() !==
        46) {
          let s = this.startNode();
          return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
        }
        return this.tsParseType();
      }), this.semicolon(), this.finishNode(r, "TSTypeAliasDeclaration");
    }
    tsInTopLevelContext(r) {
      if (this.curContext() !== _e.brace) {
        let s = this.state.context;
        this.state.context = [s[0]];
        try {
          return r();
        } finally {
          this.state.context = s;
        }
      } else
        return r();
    }
    tsInType(r) {
      let s = this.state.inType;
      this.state.inType = !0;
      try {
        return r();
      } finally {
        this.state.inType = s;
      }
    }
    tsInDisallowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !0;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsInAllowConditionalTypesContext(r) {
      let s = this.state.inDisallowConditionalTypesContext;
      this.state.inDisallowConditionalTypesContext = !1;
      try {
        return r();
      } finally {
        this.state.inDisallowConditionalTypesContext = s;
      }
    }
    tsEatThenParseType(r) {
      if (this.match(r))
        return this.tsNextThenParseType();
    }
    tsExpectThenParseType(r) {
      return this.tsInType(() => (this.expect(r), this.tsParseType()));
    }
    tsNextThenParseType() {
      return this.tsInType(() => (this.next(), this.tsParseType()));
    }
    tsParseEnumMember() {
      let r = this.startNode();
      return r.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(!0), this.eat(29) && (r.initializer =
      super.parseMaybeAssignAllowIn()), this.finishNode(r, "TSEnumMember");
    }
    tsParseEnumDeclaration(r, s = {}) {
      return s.const && (r.const = !0), s.declare && (r.declare = !0), this.expectContextual(126), r.id = this.parseIdentifier(), this.checkIdentifier(
      r.id, r.const ? 8971 : 8459), this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)),
      this.expect(8), this.finishNode(r, "TSEnumDeclaration");
    }
    tsParseEnumBody() {
      let r = this.startNode();
      return this.expect(5), r.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(
      r, "TSEnumBody");
    }
    tsParseModuleBlock() {
      let r = this.startNode();
      return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(r.body = [], void 0, !0, 8), this.scope.exit(), this.finishNode(
      r, "TSModuleBlock");
    }
    tsParseModuleOrNamespaceDeclaration(r, s = !1) {
      if (r.id = this.parseIdentifier(), s || this.checkIdentifier(r.id, 1024), this.eat(16)) {
        let n = this.startNode();
        this.tsParseModuleOrNamespaceDeclaration(n, !0), r.body = n;
      } else
        this.scope.enter(1024), this.prodParam.enter(0), r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
      return this.finishNode(r, "TSModuleDeclaration");
    }
    tsParseAmbientExternalModuleDeclaration(r) {
      return this.isContextual(112) ? (r.kind = "global", r.global = !0, r.id = this.parseIdentifier()) : this.match(134) ? (r.kind = "modul\
e", r.id = super.parseStringLiteral(this.state.value)) : this.unexpected(), this.match(5) ? (this.scope.enter(1024), this.prodParam.enter(0),
      r.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(r, "TSModuleDeclarat\
ion");
    }
    tsParseImportEqualsDeclaration(r, s, n) {
      r.isExport = n || !1, r.id = s || this.parseIdentifier(), this.checkIdentifier(r.id, 4096), this.expect(29);
      let a = this.tsParseModuleReference();
      return r.importKind === "type" && a.type !== "TSExternalModuleReference" && this.raise(ee.ImportAliasHasImportType, a), r.moduleReference =
      a, this.semicolon(), this.finishNode(r, "TSImportEqualsDeclaration");
    }
    tsIsExternalModuleReference() {
      return this.isContextual(119) && this.lookaheadCharCode() === 40;
    }
    tsParseModuleReference() {
      return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
    }
    tsParseExternalModuleReference() {
      let r = this.startNode();
      return this.expectContextual(119), this.expect(10), this.match(134) || this.unexpected(), r.expression = super.parseExprAtom(), this.expect(
      11), this.sawUnambiguousESM = !0, this.finishNode(r, "TSExternalModuleReference");
    }
    tsLookAhead(r) {
      let s = this.state.clone(), n = r();
      return this.state = s, n;
    }
    tsTryParseAndCatch(r) {
      let s = this.tryParse((n) => r() || n());
      if (!(s.aborted || !s.node))
        return s.error && (this.state = s.failState), s.node;
    }
    tsTryParse(r) {
      let s = this.state.clone(), n = r();
      if (n !== void 0 && n !== !1)
        return n;
      this.state = s;
    }
    tsTryParseDeclare(r) {
      if (this.isLineTerminator())
        return;
      let s = this.state.type;
      return this.tsInAmbientContext(() => {
        switch (s) {
          case 68:
            return r.declare = !0, super.parseFunctionStatement(r, !1, !1);
          case 80:
            return r.declare = !0, this.parseClass(r, !0, !1);
          case 126:
            return this.tsParseEnumDeclaration(r, {
              declare: !0
            });
          case 112:
            return this.tsParseAmbientExternalModuleDeclaration(r);
          case 100:
            if (this.state.containsEsc)
              return;
          case 75:
          case 74:
            return !this.match(75) || !this.isLookaheadContextual("enum") ? (r.declare = !0, this.parseVarStatement(r, this.state.value, !0)) :
            (this.expect(75), this.tsParseEnumDeclaration(r, {
              const: !0,
              declare: !0
            }));
          case 107:
            if (this.isUsing())
              return this.raise(ee.InvalidModifierOnUsingDeclaration, this.state.startLoc, "declare"), r.declare = !0, this.parseVarStatement(
              r, "using", !0);
            break;
          case 96:
            if (this.isAwaitUsing())
              return this.raise(ee.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, "declare"), r.declare = !0, this.next(), this.
              parseVarStatement(r, "await using", !0);
            break;
          case 129: {
            let n = this.tsParseInterfaceDeclaration(r, {
              declare: !0
            });
            if (n) return n;
          }
          default:
            if (ke(s))
              return this.tsParseDeclaration(r, this.state.type, !0, null);
        }
      });
    }
    tsTryParseExportDeclaration() {
      return this.tsParseDeclaration(this.startNode(), this.state.type, !0, null);
    }
    tsParseDeclaration(r, s, n, a) {
      switch (s) {
        case 124:
          if (this.tsCheckLineTerminator(n) && (this.match(80) || ke(this.state.type)))
            return this.tsParseAbstractDeclaration(r, a);
          break;
        case 127:
          if (this.tsCheckLineTerminator(n)) {
            if (this.match(134))
              return this.tsParseAmbientExternalModuleDeclaration(r);
            if (ke(this.state.type))
              return r.kind = "module", this.tsParseModuleOrNamespaceDeclaration(r);
          }
          break;
        case 128:
          if (this.tsCheckLineTerminator(n) && ke(this.state.type))
            return r.kind = "namespace", this.tsParseModuleOrNamespaceDeclaration(r);
          break;
        case 130:
          if (this.tsCheckLineTerminator(n) && ke(this.state.type))
            return this.tsParseTypeAliasDeclaration(r);
          break;
      }
    }
    tsCheckLineTerminator(r) {
      return r ? this.hasFollowingLineBreak() ? !1 : (this.next(), !0) : !this.isLineTerminator();
    }
    tsTryParseGenericAsyncArrowFunction(r) {
      if (!this.match(47)) return;
      let s = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = !0;
      let n = this.tsTryParseAndCatch(() => {
        let a = this.startNodeAt(r);
        return a.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(a), a.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(),
        this.expect(19), a;
      });
      if (this.state.maybeInArrowParameters = s, !!n)
        return super.parseArrowExpression(n, null, !0);
    }
    tsParseTypeArgumentsInExpression() {
      if (this.reScan_lt() === 47)
        return this.tsParseTypeArguments();
    }
    tsParseTypeArguments() {
      let r = this.startNode();
      return r.params = this.tsInType(() => this.tsInTopLevelContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArgu\
ments", this.tsParseType.bind(this))))), r.params.length === 0 ? this.raise(ee.EmptyTypeArguments, r) : !this.state.inType && this.curContext() ===
      _e.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(r, "TSTypeParameterInstantiation");
    }
    tsIsDeclarationStart() {
      return VY(this.state.type);
    }
    isExportDefaultSpecifier() {
      return this.tsIsDeclarationStart() ? !1 : super.isExportDefaultSpecifier();
    }
    parseBindingElement(r, s) {
      let n = s.length ? s[0].loc.start : this.state.startLoc, a = {};
      this.tsParseModifiers({
        allowedModifiers: ["public", "private", "protected", "override", "readonly"]
      }, a);
      let o = a.accessibility, l = a.override, u = a.readonly;
      !(r & 4) && (o || u || l) && this.raise(ee.UnexpectedParameterModifier, n);
      let c = this.parseMaybeDefault();
      r & 2 && this.parseFunctionParamType(c);
      let p = this.parseMaybeDefault(c.loc.start, c);
      if (o || u || l) {
        let f = this.startNodeAt(n);
        return s.length && (f.decorators = s), o && (f.accessibility = o), u && (f.readonly = u), l && (f.override = l), p.type !== "Identif\
ier" && p.type !== "AssignmentPattern" && this.raise(ee.UnsupportedParameterPropertyKind, f), f.parameter = p, this.finishNode(f, "TSParamet\
erProperty");
      }
      return s.length && (c.decorators = s), p;
    }
    isSimpleParameter(r) {
      return r.type === "TSParameterProperty" && super.isSimpleParameter(r.parameter) || super.isSimpleParameter(r);
    }
    tsDisallowOptionalPattern(r) {
      for (let s of r.params)
        s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(ee.PatternIsOptional, s);
    }
    setArrowFunctionParameters(r, s, n) {
      super.setArrowFunctionParameters(r, s, n), this.tsDisallowOptionalPattern(r);
    }
    parseFunctionBodyAndFinish(r, s, n = !1) {
      this.match(14) && (r.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
      let a = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
      return a && !this.match(5) && this.isLineTerminator() ? this.finishNode(r, a) : a === "TSDeclareFunction" && this.state.isAmbientContext &&
      (this.raise(ee.DeclareFunctionHasImplementation, r), r.declare) ? super.parseFunctionBodyAndFinish(r, a, n) : (this.tsDisallowOptionalPattern(
      r), super.parseFunctionBodyAndFinish(r, s, n));
    }
    registerFunctionStatementId(r) {
      !r.body && r.id ? this.checkIdentifier(r.id, 1024) : super.registerFunctionStatementId(r);
    }
    tsCheckForInvalidTypeCasts(r) {
      r.forEach((s) => {
        s?.type === "TSTypeCastExpression" && this.raise(ee.UnexpectedTypeAnnotation, s.typeAnnotation);
      });
    }
    toReferencedList(r, s) {
      return this.tsCheckForInvalidTypeCasts(r), r;
    }
    parseArrayLike(r, s, n) {
      let a = super.parseArrayLike(r, s, n);
      return a.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(a.elements), a;
    }
    parseSubscript(r, s, n, a) {
      if (!this.hasPrecedingLineBreak() && this.match(35)) {
        this.state.canStartJSXElement = !1, this.next();
        let l = this.startNodeAt(s);
        return l.expression = r, this.finishNode(l, "TSNonNullExpression");
      }
      let o = !1;
      if (this.match(18) && this.lookaheadCharCode() === 60) {
        if (n)
          return a.stop = !0, r;
        a.optionalChainMember = o = !0, this.next();
      }
      if (this.match(47) || this.match(51)) {
        let l, u = this.tsTryParseAndCatch(() => {
          if (!n && this.atPossibleAsyncArrow(r)) {
            let h = this.tsTryParseGenericAsyncArrowFunction(s);
            if (h)
              return a.stop = !0, h;
          }
          let c = this.tsParseTypeArgumentsInExpression();
          if (!c) return;
          if (o && !this.match(10)) {
            l = this.state.curPosition();
            return;
          }
          if (Wl(this.state.type)) {
            let h = super.parseTaggedTemplateExpression(r, s, a);
            return h.typeParameters = c, h;
          }
          if (!n && this.eat(10)) {
            let h = this.startNodeAt(s);
            return h.callee = r, h.arguments = this.parseCallExpressionArguments(), this.tsCheckForInvalidTypeCasts(h.arguments), h.typeParameters =
            c, a.optionalChainMember && (h.optional = o), this.finishCallExpression(h, a.optionalChainMember);
          }
          let p = this.state.type;
          if (p === 48 || p === 52 || p !== 10 && Wa(p) && !this.hasPrecedingLineBreak())
            return;
          let f = this.startNodeAt(s);
          return f.expression = r, f.typeParameters = c, this.finishNode(f, "TSInstantiationExpression");
        });
        if (l && this.unexpected(l, 10), u)
          return u.type === "TSInstantiationExpression" && ((this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(
          ee.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), !this.match(16) && !this.match(18) && (u.expression = super.
          stopParseSubscript(r, a))), u;
      }
      return super.parseSubscript(r, s, n, a);
    }
    parseNewCallee(r) {
      var s;
      super.parseNewCallee(r);
      let {
        callee: n
      } = r;
      n.type === "TSInstantiationExpression" && !((s = n.extra) != null && s.parenthesized) && (r.typeParameters = n.typeParameters, r.callee =
      n.expression);
    }
    parseExprOp(r, s, n) {
      let a;
      if ($l(58) > n && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (a = this.isContextual(120)))) {
        let o = this.startNodeAt(s);
        return o.expression = r, o.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (a && this.raise(O.UnexpectedKeyword,
        this.state.startLoc, {
          keyword: "const"
        }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(o, a ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(),
        this.parseExprOp(o, s, n);
      }
      return super.parseExprOp(r, s, n);
    }
    checkReservedWord(r, s, n, a) {
      this.state.isAmbientContext || super.checkReservedWord(r, s, n, a);
    }
    checkImportReflection(r) {
      super.checkImportReflection(r), r.module && r.importKind !== "value" && this.raise(ee.ImportReflectionHasImportType, r.specifiers[0].loc.
      start);
    }
    checkDuplicateExports() {
    }
    isPotentialImportPhase(r) {
      if (super.isPotentialImportPhase(r)) return !0;
      if (this.isContextual(130)) {
        let s = this.lookaheadCharCode();
        return r ? s === 123 || s === 42 : s !== 61;
      }
      return !r && this.isContextual(87);
    }
    applyImportPhase(r, s, n, a) {
      super.applyImportPhase(r, s, n, a), s ? r.exportKind = n === "type" ? "type" : "value" : r.importKind = n === "type" || n === "typeof" ?
      n : "value";
    }
    parseImport(r) {
      if (this.match(134))
        return r.importKind = "value", super.parseImport(r);
      let s;
      if (ke(this.state.type) && this.lookaheadCharCode() === 61)
        return r.importKind = "value", this.tsParseImportEqualsDeclaration(r);
      if (this.isContextual(130)) {
        let n = this.parseMaybeImportPhase(r, !1);
        if (this.lookaheadCharCode() === 61)
          return this.tsParseImportEqualsDeclaration(r, n);
        s = super.parseImportSpecifiersAndAfter(r, n);
      } else
        s = super.parseImport(r);
      return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(ee.TypeImportCannotSpecifyDefaultAndNamed,
      s), s;
    }
    parseExport(r, s) {
      if (this.match(83)) {
        let n = r;
        this.next();
        let a = null;
        return this.isContextual(130) && this.isPotentialImportPhase(!1) ? a = this.parseMaybeImportPhase(n, !1) : n.importKind = "value", this.
        tsParseImportEqualsDeclaration(n, a, !0);
      } else if (this.eat(29)) {
        let n = r;
        return n.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(n, "TSExportAssignment");
      } else if (this.eatContextual(93)) {
        let n = r;
        return this.expectContextual(128), n.id = this.parseIdentifier(), this.semicolon(), this.finishNode(n, "TSNamespaceExportDeclaration");
      } else
        return super.parseExport(r, s);
    }
    isAbstractClass() {
      return this.isContextual(124) && this.isLookaheadContextual("class");
    }
    parseExportDefaultExpression() {
      if (this.isAbstractClass()) {
        let r = this.startNode();
        return this.next(), r.abstract = !0, this.parseClass(r, !0, !0);
      }
      if (this.match(129)) {
        let r = this.tsParseInterfaceDeclaration(this.startNode());
        if (r) return r;
      }
      return super.parseExportDefaultExpression();
    }
    parseVarStatement(r, s, n = !1) {
      let {
        isAmbientContext: a
      } = this.state, o = super.parseVarStatement(r, s, n || a);
      if (!a) return o;
      if (!r.declare && (s === "using" || s === "await using"))
        return this.raiseOverwrite(ee.UsingDeclarationInAmbientContext, r, s), o;
      for (let {
        id: l,
        init: u
      } of o.declarations)
        u && (s === "var" || s === "let" || l.typeAnnotation ? this.raise(ee.InitializerNotAllowedInAmbientContext, u) : PH(u, this.hasPlugin(
        "estree")) || this.raise(ee.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, u));
      return o;
    }
    parseStatementContent(r, s) {
      if (!this.state.containsEsc)
        switch (this.state.type) {
          case 75: {
            if (this.isLookaheadContextual("enum")) {
              let n = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(n, {
                const: !0
              });
            }
            break;
          }
          case 124:
          case 125: {
            if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {
              let n = this.state.type, a = this.startNode();
              this.next();
              let o = n === 125 ? this.tsTryParseDeclare(a) : this.tsParseAbstractDeclaration(a, s);
              return o ? (n === 125 && (o.declare = !0), o) : (a.expression = this.createIdentifier(this.startNodeAt(a.loc.start), n === 125 ?
              "declare" : "abstract"), this.semicolon(!1), this.finishNode(a, "ExpressionStatement"));
            }
            break;
          }
          case 126:
            return this.tsParseEnumDeclaration(this.startNode());
          case 112: {
            if (this.lookaheadCharCode() === 123) {
              let a = this.startNode();
              return this.tsParseAmbientExternalModuleDeclaration(a);
            }
            break;
          }
          case 129: {
            let n = this.tsParseInterfaceDeclaration(this.startNode());
            if (n) return n;
            break;
          }
          case 127: {
            if (this.nextTokenIsIdentifierOrStringLiteralOnSameLine()) {
              let n = this.startNode();
              return this.next(), this.tsParseDeclaration(n, 127, !1, s);
            }
            break;
          }
          case 128: {
            if (this.nextTokenIsIdentifierOnSameLine()) {
              let n = this.startNode();
              return this.next(), this.tsParseDeclaration(n, 128, !1, s);
            }
            break;
          }
          case 130: {
            if (this.nextTokenIsIdentifierOnSameLine()) {
              let n = this.startNode();
              return this.next(), this.tsParseTypeAliasDeclaration(n);
            }
            break;
          }
        }
      return super.parseStatementContent(r, s);
    }
    parseAccessModifier() {
      return this.tsParseModifier(["public", "protected", "private"]);
    }
    tsHasSomeModifiers(r, s) {
      return s.some((n) => lx(n) ? r.accessibility === n : !!r[n]);
    }
    tsIsStartOfStaticBlocks() {
      return this.isContextual(106) && this.lookaheadCharCode() === 123;
    }
    parseClassMember(r, s, n) {
      let a = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
      this.tsParseModifiers({
        allowedModifiers: a,
        disallowedModifiers: ["in", "out"],
        stopOnStartOfClassStaticBlock: !0,
        errorTemplate: ee.InvalidModifierOnTypeParameterPositions
      }, s);
      let o = /* @__PURE__ */ i(() => {
        this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, a) && this.raise(ee.StaticBlockCannotHaveModifier,
        this.state.curPosition()), super.parseClassStaticBlock(r, s)) : this.parseClassMemberWithIsStatic(r, s, n, !!s.static);
      }, "callParseClassMemberWithIsStatic");
      s.declare ? this.tsInAmbientContext(o) : o();
    }
    parseClassMemberWithIsStatic(r, s, n, a) {
      let o = this.tsTryParseIndexSignature(s);
      if (o) {
        r.body.push(o), s.abstract && this.raise(ee.IndexSignatureHasAbstract, s), s.accessibility && this.raise(ee.IndexSignatureHasAccessibility,
        s, {
          modifier: s.accessibility
        }), s.declare && this.raise(ee.IndexSignatureHasDeclare, s), s.override && this.raise(ee.IndexSignatureHasOverride, s);
        return;
      }
      !this.state.inAbstractClass && s.abstract && this.raise(ee.NonAbstractClassHasAbstractMethod, s), s.override && (n.hadSuperClass || this.
      raise(ee.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(r, s, n, a);
    }
    parsePostMemberNameModifiers(r) {
      this.eat(17) && (r.optional = !0), r.readonly && this.match(10) && this.raise(ee.ClassMethodHasReadonly, r), r.declare && this.match(10) &&
      this.raise(ee.ClassMethodHasDeclare, r);
    }
    shouldParseExportDeclaration() {
      return this.tsIsDeclarationStart() ? !0 : super.shouldParseExportDeclaration();
    }
    parseConditional(r, s, n) {
      if (!this.match(17)) return r;
      if (this.state.maybeInArrowParameters) {
        let a = this.lookaheadCharCode();
        if (a === 44 || a === 61 || a === 58 || a === 41)
          return this.setOptionalParametersError(n), r;
      }
      return super.parseConditional(r, s, n);
    }
    parseParenItem(r, s) {
      let n = super.parseParenItem(r, s);
      if (this.eat(17) && (n.optional = !0, this.resetEndLocation(r)), this.match(14)) {
        let a = this.startNodeAt(s);
        return a.expression = r, a.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(a, "TSTypeCastExpression");
      }
      return r;
    }
    parseExportDeclaration(r) {
      if (!this.state.isAmbientContext && this.isContextual(125))
        return this.tsInAmbientContext(() => this.parseExportDeclaration(r));
      let s = this.state.startLoc, n = this.eatContextual(125);
      if (n && (this.isContextual(125) || !this.shouldParseExportDeclaration()))
        throw this.raise(ee.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
      let o = ke(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(r);
      return o ? ((o.type === "TSInterfaceDeclaration" || o.type === "TSTypeAliasDeclaration" || n) && (r.exportKind = "type"), n && o.type !==
      "TSImportEqualsDeclaration" && (this.resetStartLocation(o, s), o.declare = !0), o) : null;
    }
    parseClassId(r, s, n, a) {
      if ((!s || n) && this.isContextual(113))
        return;
      super.parseClassId(r, s, n, r.declare ? 1024 : 8331);
      let o = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
      o && (r.typeParameters = o);
    }
    parseClassPropertyAnnotation(r) {
      r.optional || (this.eat(35) ? r.definite = !0 : this.eat(17) && (r.optional = !0));
      let s = this.tsTryParseTypeAnnotation();
      s && (r.typeAnnotation = s);
    }
    parseClassProperty(r) {
      if (this.parseClassPropertyAnnotation(r), this.state.isAmbientContext && !(r.readonly && !r.typeAnnotation) && this.match(29) && this.
      raise(ee.DeclareClassFieldHasInitializer, this.state.startLoc), r.abstract && this.match(29)) {
        let {
          key: s
        } = r;
        this.raise(ee.AbstractPropertyHasInitializer, this.state.startLoc, {
          propertyName: s.type === "Identifier" && !r.computed ? s.name : `[${this.input.slice(this.offsetToSourcePos(s.start), this.offsetToSourcePos(
          s.end))}]`
        });
      }
      return super.parseClassProperty(r);
    }
    parseClassPrivateProperty(r) {
      return r.abstract && this.raise(ee.PrivateElementHasAbstract, r), r.accessibility && this.raise(ee.PrivateElementHasAccessibility, r, {
        modifier: r.accessibility
      }), this.parseClassPropertyAnnotation(r), super.parseClassPrivateProperty(r);
    }
    parseClassAccessorProperty(r) {
      return this.parseClassPropertyAnnotation(r), r.optional && this.raise(ee.AccessorCannotBeOptional, r), super.parseClassAccessorProperty(
      r);
    }
    pushClassMethod(r, s, n, a, o, l) {
      let u = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      u && o && this.raise(ee.ConstructorHasTypeParameters, u);
      let {
        declare: c = !1,
        kind: p
      } = s;
      c && (p === "get" || p === "set") && this.raise(ee.DeclareAccessor, s, {
        kind: p
      }), u && (s.typeParameters = u), super.pushClassMethod(r, s, n, a, o, l);
    }
    pushClassPrivateMethod(r, s, n, a) {
      let o = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      o && (s.typeParameters = o), super.pushClassPrivateMethod(r, s, n, a);
    }
    declareClassPrivateMethodInScope(r, s) {
      r.type !== "TSDeclareMethod" && (r.type === "MethodDefinition" && r.value.body == null || super.declareClassPrivateMethodInScope(r, s));
    }
    parseClassSuper(r) {
      super.parseClassSuper(r), r.superClass && (this.match(47) || this.match(51)) && (r.superTypeParameters = this.tsParseTypeArgumentsInExpression()),
      this.eatContextual(113) && (r.implements = this.tsParseHeritageClause("implements"));
    }
    parseObjPropValue(r, s, n, a, o, l, u) {
      let c = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      return c && (r.typeParameters = c), super.parseObjPropValue(r, s, n, a, o, l, u);
    }
    parseFunctionParams(r, s) {
      let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
      n && (r.typeParameters = n), super.parseFunctionParams(r, s);
    }
    parseVarId(r, s) {
      super.parseVarId(r, s), r.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (r.definite = !0);
      let n = this.tsTryParseTypeAnnotation();
      n && (r.id.typeAnnotation = n, this.resetEndLocation(r.id));
    }
    parseAsyncArrowFromCallExpression(r, s) {
      return this.match(14) && (r.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(r, s);
    }
    parseMaybeAssign(r, s) {
      var n, a, o, l, u;
      let c, p, f;
      if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
        if (c = this.state.clone(), p = this.tryParse(() => super.parseMaybeAssign(r, s), c), !p.error) return p.node;
        let {
          context: T
        } = this.state, d = T[T.length - 1];
        (d === _e.j_oTag || d === _e.j_expr) && T.pop();
      }
      if (!((n = p) != null && n.error) && !this.match(47))
        return super.parseMaybeAssign(r, s);
      (!c || c === this.state) && (c = this.state.clone());
      let h, b = this.tryParse((T) => {
        var d, g;
        h = this.tsParseTypeParameters(this.tsParseConstModifier);
        let E = super.parseMaybeAssign(r, s);
        return (E.type !== "ArrowFunctionExpression" || (d = E.extra) != null && d.parenthesized) && T(), ((g = h) == null ? void 0 : g.params.
        length) !== 0 && this.resetStartLocationFromNode(E, h), E.typeParameters = h, E;
      }, c);
      if (!b.error && !b.aborted)
        return h && this.reportReservedArrowTypeParam(h), b.node;
      if (!p && (ox(!this.hasPlugin("jsx")), f = this.tryParse(() => super.parseMaybeAssign(r, s), c), !f.error))
        return f.node;
      if ((a = p) != null && a.node)
        return this.state = p.failState, p.node;
      if (b.node)
        return this.state = b.failState, h && this.reportReservedArrowTypeParam(h), b.node;
      if ((o = f) != null && o.node)
        return this.state = f.failState, f.node;
      throw ((l = p) == null ? void 0 : l.error) || b.error || ((u = f) == null ? void 0 : u.error);
    }
    reportReservedArrowTypeParam(r) {
      var s;
      r.params.length === 1 && !r.params[0].constraint && !((s = r.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "\
disallowAmbiguousJSXLike") && this.raise(ee.ReservedArrowTypeParam, r);
    }
    parseMaybeUnary(r, s) {
      return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(r, s);
    }
    parseArrow(r) {
      if (this.match(14)) {
        let s = this.tryParse((n) => {
          let a = this.tsParseTypeOrTypePredicateAnnotation(14);
          return (this.canInsertSemicolon() || !this.match(19)) && n(), a;
        });
        if (s.aborted) return;
        s.thrown || (s.error && (this.state = s.failState), r.returnType = s.node);
      }
      return super.parseArrow(r);
    }
    parseFunctionParamType(r) {
      this.eat(17) && (r.optional = !0);
      let s = this.tsTryParseTypeAnnotation();
      return s && (r.typeAnnotation = s), this.resetEndLocation(r), r;
    }
    isAssignable(r, s) {
      switch (r.type) {
        case "TSTypeCastExpression":
          return this.isAssignable(r.expression, s);
        case "TSParameterProperty":
          return !0;
        default:
          return super.isAssignable(r, s);
      }
    }
    toAssignable(r, s = !1) {
      switch (r.type) {
        case "ParenthesizedExpression":
          this.toAssignableParenthesizedExpression(r, s);
          break;
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
          s ? this.expressionScope.recordArrowParameterBindingError(ee.UnexpectedTypeCastInParameter, r) : this.raise(ee.UnexpectedTypeCastInParameter,
          r), this.toAssignable(r.expression, s);
          break;
        case "AssignmentExpression":
          !s && r.left.type === "TSTypeCastExpression" && (r.left = this.typeCastToParameter(r.left));
        default:
          super.toAssignable(r, s);
      }
    }
    toAssignableParenthesizedExpression(r, s) {
      switch (r.expression.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSNonNullExpression":
        case "TSTypeAssertion":
        case "ParenthesizedExpression":
          this.toAssignable(r.expression, s);
          break;
        default:
          super.toAssignable(r, s);
      }
    }
    checkToRestConversion(r, s) {
      switch (r.type) {
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          this.checkToRestConversion(r.expression, !1);
          break;
        default:
          super.checkToRestConversion(r, s);
      }
    }
    isValidLVal(r, s, n, a) {
      switch (r) {
        case "TSTypeCastExpression":
          return !0;
        case "TSParameterProperty":
          return "parameter";
        case "TSNonNullExpression":
          return "expression";
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
          return (a !== 64 || !n) && ["expression", !0];
        default:
          return super.isValidLVal(r, s, n, a);
      }
    }
    parseBindingAtom() {
      return this.state.type === 78 ? this.parseIdentifier(!0) : super.parseBindingAtom();
    }
    parseMaybeDecoratorArguments(r, s) {
      if (this.match(47) || this.match(51)) {
        let n = this.tsParseTypeArgumentsInExpression();
        if (this.match(10)) {
          let a = super.parseMaybeDecoratorArguments(r, s);
          return a.typeParameters = n, a;
        }
        this.unexpected(null, 10);
      }
      return super.parseMaybeDecoratorArguments(r, s);
    }
    checkCommaAfterRest(r) {
      return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === r ? (this.next(), !1) : super.checkCommaAfterRest(
      r);
    }
    isClassMethod() {
      return this.match(47) || super.isClassMethod();
    }
    isClassProperty() {
      return this.match(35) || this.match(14) || super.isClassProperty();
    }
    parseMaybeDefault(r, s) {
      let n = super.parseMaybeDefault(r, s);
      return n.type === "AssignmentPattern" && n.typeAnnotation && n.right.start < n.typeAnnotation.start && this.raise(ee.TypeAnnotationAfterAssign,
      n.typeAnnotation), n;
    }
    getTokenFromCode(r) {
      if (this.state.inType) {
        if (r === 62) {
          this.finishOp(48, 1);
          return;
        }
        if (r === 60) {
          this.finishOp(47, 1);
          return;
        }
      }
      super.getTokenFromCode(r);
    }
    reScan_lt_gt() {
      let {
        type: r
      } = this.state;
      r === 47 ? (this.state.pos -= 1, this.readToken_lt()) : r === 48 && (this.state.pos -= 1, this.readToken_gt());
    }
    reScan_lt() {
      let {
        type: r
      } = this.state;
      return r === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : r;
    }
    toAssignableListItem(r, s, n) {
      let a = r[s];
      a.type === "TSTypeCastExpression" && (r[s] = this.typeCastToParameter(a)), super.toAssignableListItem(r, s, n);
    }
    typeCastToParameter(r) {
      return r.expression.typeAnnotation = r.typeAnnotation, this.resetEndLocation(r.expression, r.typeAnnotation.loc.end), r.expression;
    }
    shouldParseArrow(r) {
      return this.match(14) ? r.every((s) => this.isAssignable(s, !0)) : super.shouldParseArrow(r);
    }
    shouldParseAsyncArrow() {
      return this.match(14) || super.shouldParseAsyncArrow();
    }
    canHaveLeadingDecorator() {
      return super.canHaveLeadingDecorator() || this.isAbstractClass();
    }
    jsxParseOpeningElementAfterName(r) {
      if (this.match(47) || this.match(51)) {
        let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
        s && (r.typeParameters = s);
      }
      return super.jsxParseOpeningElementAfterName(r);
    }
    getGetterSetterExpectedParamCount(r) {
      let s = super.getGetterSetterExpectedParamCount(r), a = this.getObjectOrClassMethodParams(r)[0];
      return a && this.isThisParam(a) ? s + 1 : s;
    }
    parseCatchClauseParam() {
      let r = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
      return s && (r.typeAnnotation = s, this.resetEndLocation(r)), r;
    }
    tsInAmbientContext(r) {
      let {
        isAmbientContext: s,
        strict: n
      } = this.state;
      this.state.isAmbientContext = !0, this.state.strict = !1;
      try {
        return r();
      } finally {
        this.state.isAmbientContext = s, this.state.strict = n;
      }
    }
    parseClass(r, s, n) {
      let a = this.state.inAbstractClass;
      this.state.inAbstractClass = !!r.abstract;
      try {
        return super.parseClass(r, s, n);
      } finally {
        this.state.inAbstractClass = a;
      }
    }
    tsParseAbstractDeclaration(r, s) {
      if (this.match(80))
        return r.abstract = !0, this.maybeTakeDecorators(s, this.parseClass(r, !0, !1));
      if (this.isContextual(129))
        return this.hasFollowingLineBreak() ? null : (r.abstract = !0, this.raise(ee.NonClassMethodPropertyHasAbstractModifier, r), this.tsParseInterfaceDeclaration(
        r));
      throw this.unexpected(null, 80);
    }
    parseMethod(r, s, n, a, o, l, u) {
      let c = super.parseMethod(r, s, n, a, o, l, u);
      if ((c.abstract || c.type === "TSAbstractMethodDefinition") && (this.hasPlugin("estree") ? c.value : c).body) {
        let {
          key: h
        } = c;
        this.raise(ee.AbstractMethodHasImplementation, c, {
          methodName: h.type === "Identifier" && !c.computed ? h.name : `[${this.input.slice(this.offsetToSourcePos(h.start), this.offsetToSourcePos(
          h.end))}]`
        });
      }
      return c;
    }
    tsParseTypeParameterName() {
      return this.parseIdentifier().name;
    }
    shouldParseAsAmbientContext() {
      return !!this.getPluginOption("typescript", "dts");
    }
    parse() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.parse();
    }
    getExpression() {
      return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = !0), super.getExpression();
    }
    parseExportSpecifier(r, s, n, a) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !1, n), this.finishNode(r, "ExportSpecifier")) : (r.exportKind = "value",
      super.parseExportSpecifier(r, s, n, a));
    }
    parseImportSpecifier(r, s, n, a, o) {
      return !s && a ? (this.parseTypeOnlyImportExportSpecifier(r, !0, n), this.finishNode(r, "ImportSpecifier")) : (r.importKind = "value",
      super.parseImportSpecifier(r, s, n, a, n ? 4098 : 4096));
    }
    parseTypeOnlyImportExportSpecifier(r, s, n) {
      let a = s ? "imported" : "local", o = s ? "local" : "exported", l = r[a], u, c = !1, p = !0, f = l.loc.start;
      if (this.isContextual(93)) {
        let b = this.parseIdentifier();
        if (this.isContextual(93)) {
          let T = this.parseIdentifier();
          Fr(this.state.type) ? (c = !0, l = b, u = s ? this.parseIdentifier() : this.parseModuleExportName(), p = !1) : (u = T, p = !1);
        } else Fr(this.state.type) ? (p = !1, u = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c = !0, l = b);
      } else Fr(this.state.type) && (c = !0, s ? (l = this.parseIdentifier(!0), this.isContextual(93) || this.checkReservedWord(l.name, l.loc.
      start, !0, !0)) : l = this.parseModuleExportName());
      c && n && this.raise(s ? ee.TypeModifierIsUsedInTypeImports : ee.TypeModifierIsUsedInTypeExports, f), r[a] = l, r[o] = u;
      let h = s ? "importKind" : "exportKind";
      r[h] = c ? "type" : "value", p && this.eatContextual(93) && (r[o] = s ? this.parseIdentifier() : this.parseModuleExportName()), r[o] ||
      (r[o] = this.cloneIdentifier(r[a])), s && this.checkIdentifier(r[o], c ? 4098 : 4096);
    }
    fillOptionalPropertiesForTSESLint(r) {
      var s, n, a, o, l, u, c, p, f, h, b, T, d, g, E, _, N, k, j, U, M, K, G, ue, te, De, je, wt, pr, Rt, Dr, _r, Xe, Ir, ds, Tt, Re, Be, Dt,
      _t, Or, va, vn, Pa, $s, Vs, Ks, Aa;
      switch (r.type) {
        case "ExpressionStatement":
          (s = r.directive) != null || (r.directive = void 0);
          return;
        case "RestElement":
          r.value = void 0;
        case "Identifier":
        case "ArrayPattern":
        case "AssignmentPattern":
        case "ObjectPattern":
          (n = r.decorators) != null || (r.decorators = []), (a = r.optional) != null || (r.optional = !1), (o = r.typeAnnotation) != null ||
          (r.typeAnnotation = void 0);
          return;
        case "TSParameterProperty":
          (l = r.accessibility) != null || (r.accessibility = void 0), (u = r.decorators) != null || (r.decorators = []), (c = r.override) !=
          null || (r.override = !1), (p = r.readonly) != null || (r.readonly = !1), (f = r.static) != null || (r.static = !1);
          return;
        case "TSEmptyBodyFunctionExpression":
          r.body = null;
        case "TSDeclareFunction":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          (h = r.declare) != null || (r.declare = !1), (b = r.returnType) != null || (r.returnType = void 0), (T = r.typeParameters) != null ||
          (r.typeParameters = void 0);
          return;
        case "Property":
          (d = r.optional) != null || (r.optional = !1);
          return;
        case "TSMethodSignature":
        case "TSPropertySignature":
          (g = r.optional) != null || (r.optional = !1);
        case "TSIndexSignature":
          (E = r.accessibility) != null || (r.accessibility = void 0), (_ = r.readonly) != null || (r.readonly = !1), (N = r.static) != null ||
          (r.static = !1);
          return;
        case "TSAbstractPropertyDefinition":
        case "PropertyDefinition":
        case "TSAbstractAccessorProperty":
        case "AccessorProperty":
          (k = r.declare) != null || (r.declare = !1), (j = r.definite) != null || (r.definite = !1), (U = r.readonly) != null || (r.readonly =
          !1), (M = r.typeAnnotation) != null || (r.typeAnnotation = void 0);
        case "TSAbstractMethodDefinition":
        case "MethodDefinition":
          (K = r.accessibility) != null || (r.accessibility = void 0), (G = r.decorators) != null || (r.decorators = []), (ue = r.override) !=
          null || (r.override = !1), (te = r.optional) != null || (r.optional = !1);
          return;
        case "ClassExpression":
          (De = r.id) != null || (r.id = null);
        case "ClassDeclaration":
          (je = r.abstract) != null || (r.abstract = !1), (wt = r.declare) != null || (r.declare = !1), (pr = r.decorators) != null || (r.decorators =
          []), (Rt = r.implements) != null || (r.implements = []), (Dr = r.superTypeArguments) != null || (r.superTypeArguments = void 0), (_r =
          r.typeParameters) != null || (r.typeParameters = void 0);
          return;
        case "TSTypeAliasDeclaration":
        case "VariableDeclaration":
          (Xe = r.declare) != null || (r.declare = !1);
          return;
        case "VariableDeclarator":
          (Ir = r.definite) != null || (r.definite = !1);
          return;
        case "TSEnumDeclaration":
          (ds = r.const) != null || (r.const = !1), (Tt = r.declare) != null || (r.declare = !1);
          return;
        case "TSEnumMember":
          (Re = r.computed) != null || (r.computed = !1);
          return;
        case "TSImportType":
          (Be = r.qualifier) != null || (r.qualifier = null), (Dt = r.options) != null || (r.options = null);
          return;
        case "TSInterfaceDeclaration":
          (_t = r.declare) != null || (r.declare = !1), (Or = r.extends) != null || (r.extends = []);
          return;
        case "TSMappedType":
          (va = r.optional) != null || (r.optional = !1), (vn = r.readonly) != null || (r.readonly = void 0);
          return;
        case "TSModuleDeclaration":
          (Pa = r.declare) != null || (r.declare = !1), ($s = r.global) != null || (r.global = r.kind === "global");
          return;
        case "TSTypeParameter":
          (Vs = r.const) != null || (r.const = !1), (Ks = r.in) != null || (r.in = !1), (Aa = r.out) != null || (r.out = !1);
          return;
      }
    }
    chStartsBindingIdentifierAndNotRelationalOperator(r, s) {
      if (ns(r)) {
        if (b0.lastIndex = s, b0.test(this.input)) {
          let n = this.codePointAtPos(b0.lastIndex);
          if (!Nn(n) && n !== 92)
            return !1;
        }
        return !0;
      } else return r === 92;
    }
    nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {
      let r = this.nextTokenInLineStart(), s = this.codePointAtPos(r);
      return this.chStartsBindingIdentifierAndNotRelationalOperator(s, r);
    }
    nextTokenIsIdentifierOrStringLiteralOnSameLine() {
      let r = this.nextTokenInLineStart(), s = this.codePointAtPos(r);
      return this.chStartsBindingIdentifier(s, r) || s === 34 || s === 39;
    }
  }, "typescript");
  function vH(e) {
    if (e.type !== "MemberExpression") return !1;
    let {
      computed: t,
      property: r
    } = e;
    return t && r.type !== "StringLiteral" && (r.type !== "TemplateLiteral" || r.expressions.length > 0) ? !1 : Ax(e.object);
  }
  i(vH, "isPossiblyLiteralEnum");
  function PH(e, t) {
    var r;
    let {
      type: s
    } = e;
    if ((r = e.extra) != null && r.parenthesized)
      return !1;
    if (t) {
      if (s === "Literal") {
        let {
          value: n
        } = e;
        if (typeof n == "string" || typeof n == "boolean")
          return !0;
      }
    } else if (s === "StringLiteral" || s === "BooleanLiteral")
      return !0;
    return !!(Px(e, t) || AH(e, t) || s === "TemplateLiteral" && e.expressions.length === 0 || vH(e));
  }
  i(PH, "isValidAmbientConstInitializer");
  function Px(e, t) {
    return t ? e.type === "Literal" && (typeof e.value == "number" || "bigint" in e) : e.type === "NumericLiteral" || e.type === "BigIntLite\
ral";
  }
  i(Px, "isNumber");
  function AH(e, t) {
    if (e.type === "UnaryExpression") {
      let {
        operator: r,
        argument: s
      } = e;
      if (r === "-" && Px(s, t))
        return !0;
    }
    return !1;
  }
  i(AH, "isNegativeNumber");
  function Ax(e) {
    return e.type === "Identifier" ? !0 : e.type !== "MemberExpression" || e.computed ? !1 : Ax(e.object);
  }
  i(Ax, "isUncomputedMemberExpressionChain");
  var ux = ss`placeholders`({
    ClassNameIsRequired: "A class name is required.",
    UnexpectedSpace: "Unexpected space in placeholder."
  }), CH = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "PlaceholdersParserMixin");
    }
    parsePlaceholder(r) {
      if (this.match(133)) {
        let s = this.startNode();
        return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(!0), this.assertNoSpace(), this.expect(133), this.finishPlaceholder(
        s, r);
      }
    }
    finishPlaceholder(r, s) {
      let n = r;
      return (!n.expectedNode || !n.type) && (n = this.finishNode(n, "Placeholder")), n.expectedNode = s, n;
    }
    getTokenFromCode(r) {
      r === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(133, 2) : super.getTokenFromCode(r);
    }
    parseExprAtom(r) {
      return this.parsePlaceholder("Expression") || super.parseExprAtom(r);
    }
    parseIdentifier(r) {
      return this.parsePlaceholder("Identifier") || super.parseIdentifier(r);
    }
    checkReservedWord(r, s, n, a) {
      r !== void 0 && super.checkReservedWord(r, s, n, a);
    }
    cloneIdentifier(r) {
      let s = super.cloneIdentifier(r);
      return s.type === "Placeholder" && (s.expectedNode = r.expectedNode), s;
    }
    cloneStringLiteral(r) {
      return r.type === "Placeholder" ? this.cloneIdentifier(r) : super.cloneStringLiteral(r);
    }
    parseBindingAtom() {
      return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
    }
    isValidLVal(r, s, n, a) {
      return r === "Placeholder" || super.isValidLVal(r, s, n, a);
    }
    toAssignable(r, s) {
      r && r.type === "Placeholder" && r.expectedNode === "Expression" ? r.expectedNode = "Pattern" : super.toAssignable(r, s);
    }
    chStartsBindingIdentifier(r, s) {
      if (super.chStartsBindingIdentifier(r, s))
        return !0;
      let n = this.nextTokenStart();
      return this.input.charCodeAt(n) === 37 && this.input.charCodeAt(n + 1) === 37;
    }
    verifyBreakContinue(r, s) {
      r.label && r.label.type === "Placeholder" || super.verifyBreakContinue(r, s);
    }
    parseExpressionStatement(r, s) {
      var n;
      if (s.type !== "Placeholder" || (n = s.extra) != null && n.parenthesized)
        return super.parseExpressionStatement(r, s);
      if (this.match(14)) {
        let o = r;
        return o.label = this.finishPlaceholder(s, "Identifier"), this.next(), o.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(),
        this.finishNode(o, "LabeledStatement");
      }
      this.semicolon();
      let a = r;
      return a.name = s.name, this.finishPlaceholder(a, "Statement");
    }
    parseBlock(r, s, n) {
      return this.parsePlaceholder("BlockStatement") || super.parseBlock(r, s, n);
    }
    parseFunctionId(r) {
      return this.parsePlaceholder("Identifier") || super.parseFunctionId(r);
    }
    parseClass(r, s, n) {
      let a = s ? "ClassDeclaration" : "ClassExpression";
      this.next();
      let o = this.state.strict, l = this.parsePlaceholder("Identifier");
      if (l)
        if (this.match(81) || this.match(133) || this.match(5))
          r.id = l;
        else {
          if (n || !s)
            return r.id = null, r.body = this.finishPlaceholder(l, "ClassBody"), this.finishNode(r, a);
          throw this.raise(ux.ClassNameIsRequired, this.state.startLoc);
        }
      else
        this.parseClassId(r, s, n);
      return super.parseClassSuper(r), r.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!r.superClass, o), this.finishNode(
      r, a);
    }
    parseExport(r, s) {
      let n = this.parsePlaceholder("Identifier");
      if (!n) return super.parseExport(r, s);
      let a = r;
      if (!this.isContextual(98) && !this.match(12))
        return a.specifiers = [], a.source = null, a.declaration = this.finishPlaceholder(n, "Declaration"), this.finishNode(a, "ExportNamed\
Declaration");
      this.expectPlugin("exportDefaultFrom");
      let o = this.startNode();
      return o.exported = n, a.specifiers = [this.finishNode(o, "ExportDefaultSpecifier")], super.parseExport(a, s);
    }
    isExportDefaultSpecifier() {
      if (this.match(65)) {
        let r = this.nextTokenStart();
        if (this.isUnparsedContextual(r, "from") && this.input.startsWith(Qs(133), this.nextTokenStartSince(r + 4)))
          return !0;
      }
      return super.isExportDefaultSpecifier();
    }
    maybeParseExportDefaultSpecifier(r, s) {
      var n;
      return (n = r.specifiers) != null && n.length ? !0 : super.maybeParseExportDefaultSpecifier(r, s);
    }
    checkExport(r) {
      let {
        specifiers: s
      } = r;
      s != null && s.length && (r.specifiers = s.filter((n) => n.exported.type === "Placeholder")), super.checkExport(r), r.specifiers = s;
    }
    parseImport(r) {
      let s = this.parsePlaceholder("Identifier");
      if (!s) return super.parseImport(r);
      if (r.specifiers = [], !this.isContextual(98) && !this.match(12))
        return r.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(r, "ImportDeclaration");
      let n = this.startNodeAtNode(s);
      return n.local = s, r.specifiers.push(this.finishNode(n, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(
      r) || this.parseNamedImportSpecifiers(r)), this.expectContextual(98), r.source = this.parseImportSource(), this.semicolon(), this.finishNode(
      r, "ImportDeclaration");
    }
    parseImportSource() {
      return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
    }
    assertNoSpace() {
      this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index) && this.raise(ux.UnexpectedSpace, this.state.lastTokEndLoc);
    }
  }, "placeholders"), wH = /* @__PURE__ */ i((e) => class extends e {
    static {
      i(this, "V8IntrinsicMixin");
    }
    parseV8Intrinsic() {
      if (this.match(54)) {
        let r = this.state.startLoc, s = this.startNode();
        if (this.next(), ke(this.state.type)) {
          let n = this.parseIdentifierName(), a = this.createIdentifier(s, n);
          if (this.castNodeTo(a, "V8IntrinsicIdentifier"), this.match(10))
            return a;
        }
        this.unexpected(r);
      }
    }
    parseExprAtom(r) {
      return this.parseV8Intrinsic() || super.parseExprAtom(r);
    }
  }, "v8intrinsic"), cx = ["minimal", "fsharp", "hack", "smart"], px = ["^^", "@@", "^", "%", "#"];
  function DH(e) {
    if (e.has("decorators")) {
      if (e.has("decorators-legacy"))
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      let s = e.get("decorators").decoratorsBeforeExport;
      if (s != null && typeof s != "boolean")
        throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
      let n = e.get("decorators").allowCallParenthesized;
      if (n != null && typeof n != "boolean")
        throw new Error("'allowCallParenthesized' must be a boolean.");
    }
    if (e.has("flow") && e.has("typescript"))
      throw new Error("Cannot combine flow and typescript plugins.");
    if (e.has("placeholders") && e.has("v8intrinsic"))
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    if (e.has("pipelineOperator")) {
      var t;
      let s = e.get("pipelineOperator").proposal;
      if (!cx.includes(s)) {
        let n = cx.map((a) => `"${a}"`).join(", ");
        throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${n}.`);
      }
      if (s === "hack") {
        if (e.has("placeholders"))
          throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
        if (e.has("v8intrinsic"))
          throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
        let n = e.get("pipelineOperator").topicToken;
        if (!px.includes(n)) {
          let a = px.map((o) => `"${o}"`).join(", ");
          throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${a}\
.`);
        }
        {
          var r;
          if (n === "#" && ((r = e.get("recordAndTuple")) == null ? void 0 : r.syntaxType) === "hash")
            throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(
            ["recordAndTuple", e.get("recordAndTuple")])}\`.`);
        }
      } else if (s === "smart" && ((t = e.get("recordAndTuple")) == null ? void 0 : t.syntaxType) === "hash")
        throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", e.
        get("recordAndTuple")])}\`.`);
    }
    if (e.has("moduleAttributes")) {
      if (e.has("deprecatedImportAssert") || e.has("importAssertions"))
        throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
      if (e.get("moduleAttributes").version !== "may-2020")
        throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the on\
ly supported value is 'may-2020'.");
    }
    if (e.has("importAssertions") && e.has("deprecatedImportAssert"))
      throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
    if (!e.has("deprecatedImportAssert") && e.has("importAttributes") && e.get("importAttributes").deprecatedAssertSyntax && e.set("deprecat\
edImportAssert", {}), e.has("recordAndTuple")) {
      let s = e.get("recordAndTuple").syntaxType;
      if (s != null) {
        let n = ["hash", "bar"];
        if (!n.includes(s))
          throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + n.map((a) => `'${a}'`).join(", "));
      }
    }
    if (e.has("asyncDoExpressions") && !e.has("doExpressions")) {
      let s = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      throw s.missingPlugins = "doExpressions", s;
    }
    if (e.has("optionalChainingAssign") && e.get("optionalChainingAssign").version !== "2023-07")
      throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, th\
e only supported value is '2023-07'.");
    if (e.has("discardBinding") && e.get("discardBinding").syntaxType !== "void")
      throw new Error("The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.");
  }
  i(DH, "validatePlugins");
  var Cx = {
    estree: NY,
    jsx: cH,
    flow: aH,
    typescript: SH,
    v8intrinsic: wH,
    placeholders: CH
  }, _H = Object.keys(Cx), R0 = class extends M0 {
    static {
      i(this, "ExpressionParser");
    }
    checkProto(t, r, s, n) {
      if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand)
        return s;
      let a = t.key;
      return (a.type === "Identifier" ? a.name : a.value) === "__proto__" ? r ? (this.raise(O.RecordNoProto, a), !0) : (s && (n ? n.doubleProtoLoc ===
      null && (n.doubleProtoLoc = a.loc.start) : this.raise(O.DuplicateProto, a)), !0) : s;
    }
    shouldExitDescending(t, r) {
      return t.type === "ArrowFunctionExpression" && this.offsetToSourcePos(t.start) === r;
    }
    getExpression() {
      if (this.enterInitialScopes(), this.nextToken(), this.match(140))
        throw this.raise(O.ParseExpressionEmptyInput, this.state.startLoc);
      let t = this.parseExpression();
      if (!this.match(140))
        throw this.raise(O.ParseExpressionExpectsEOF, this.state.startLoc, {
          unexpected: this.input.codePointAt(this.state.start)
        });
      return this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors, this.optionFlags & 256 && (t.tokens =
      this.tokens), t;
    }
    parseExpression(t, r) {
      return t ? this.disallowInAnd(() => this.parseExpressionBase(r)) : this.allowInAnd(() => this.parseExpressionBase(r));
    }
    parseExpressionBase(t) {
      let r = this.state.startLoc, s = this.parseMaybeAssign(t);
      if (this.match(12)) {
        let n = this.startNodeAt(r);
        for (n.expressions = [s]; this.eat(12); )
          n.expressions.push(this.parseMaybeAssign(t));
        return this.toReferencedList(n.expressions), this.finishNode(n, "SequenceExpression");
      }
      return s;
    }
    parseMaybeAssignDisallowIn(t, r) {
      return this.disallowInAnd(() => this.parseMaybeAssign(t, r));
    }
    parseMaybeAssignAllowIn(t, r) {
      return this.allowInAnd(() => this.parseMaybeAssign(t, r));
    }
    setOptionalParametersError(t) {
      t.optionalParametersLoc = this.state.startLoc;
    }
    parseMaybeAssign(t, r) {
      let s = this.state.startLoc, n = this.isContextual(108);
      if (n && this.prodParam.hasYield) {
        this.next();
        let u = this.parseYield(s);
        return r && (u = r.call(this, u, s)), u;
      }
      let a;
      t ? a = !1 : (t = new wi(), a = !0);
      let {
        type: o
      } = this.state;
      (o === 10 || ke(o)) && (this.state.potentialArrowAt = this.state.start);
      let l = this.parseMaybeConditional(t);
      if (r && (l = r.call(this, l, s)), jY(this.state.type)) {
        let u = this.startNodeAt(s), c = this.state.value;
        if (u.operator = c, this.match(29)) {
          this.toAssignable(l, !0), u.left = l;
          let p = s.index;
          t.doubleProtoLoc != null && t.doubleProtoLoc.index >= p && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.
          index >= p && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= p && (this.checkDestructuringPrivate(
          t), t.privateKeyLoc = null), t.voidPatternLoc != null && t.voidPatternLoc.index >= p && (t.voidPatternLoc = null);
        } else
          u.left = l;
        return this.next(), u.right = this.parseMaybeAssign(), this.checkLVal(l, this.finishNode(u, "AssignmentExpression"), void 0, void 0,
        void 0, void 0, c === "||=" || c === "&&=" || c === "??="), u;
      } else a && this.checkExpressionErrors(t, !0);
      if (n) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Wa(u) : Wa(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(O.YieldNotInGeneratorFunction, s), this.parseYield(s);
      }
      return l;
    }
    parseMaybeConditional(t) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, n = this.parseExprOps(t);
      return this.shouldExitDescending(n, s) ? n : this.parseConditional(n, r, t);
    }
    parseConditional(t, r, s) {
      if (this.eat(17)) {
        let n = this.startNodeAt(r);
        return n.test = t, n.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), n.alternate = this.parseMaybeAssign(), this.finishNode(
        n, "ConditionalExpression");
      }
      return t;
    }
    parseMaybeUnaryOrPrivate(t) {
      return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(t);
    }
    parseExprOps(t) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, n = this.parseMaybeUnaryOrPrivate(t);
      return this.shouldExitDescending(n, s) ? n : this.parseExprOp(n, r, -1);
    }
    parseExprOp(t, r, s) {
      if (this.isPrivateName(t)) {
        let a = this.getPrivateNameSV(t);
        (s >= $l(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(O.PrivateInExpectedIn, t, {
          identifierName: a
        }), this.classScope.usePrivateName(a, t.loc.start);
      }
      let n = this.state.type;
      if (RY(n) && (this.prodParam.hasIn || !this.match(58))) {
        let a = $l(n);
        if (a > s) {
          if (n === 39) {
            if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
              return t;
            this.checkPipelineAtInfixOperator(t, r);
          }
          let o = this.startNodeAt(r);
          o.left = t, o.operator = this.state.value;
          let l = n === 41 || n === 42, u = n === 40;
          if (u && (a = $l(42)), this.next(), n === 39 && this.hasPlugin(["pipelineOperator", {
            proposal: "minimal"
          }]) && this.state.type === 96 && this.prodParam.hasAwait)
            throw this.raise(O.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
          o.right = this.parseExprOpRightExpr(n, a);
          let c = this.finishNode(o, l || u ? "LogicalExpression" : "BinaryExpression"), p = this.state.type;
          if (u && (p === 41 || p === 42) || l && p === 40)
            throw this.raise(O.MixingCoalesceWithLogical, this.state.startLoc);
          return this.parseExprOp(c, r, s);
        }
      }
      return t;
    }
    parseExprOpRightExpr(t, r) {
      let s = this.state.startLoc;
      switch (t) {
        case 39:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "hack":
              return this.withTopicBindingContext(() => this.parseHackPipeBody());
            case "fsharp":
              return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(r));
          }
          if (this.getPluginOption("pipelineOperator", "proposal") === "smart")
            return this.withTopicBindingContext(() => {
              if (this.prodParam.hasYield && this.isContextual(108))
                throw this.raise(O.PipeBodyIsTighter, this.state.startLoc);
              return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, r), s);
            });
        default:
          return this.parseExprOpBaseRightExpr(t, r);
      }
    }
    parseExprOpBaseRightExpr(t, r) {
      let s = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, KY(t) ? r - 1 : r);
    }
    parseHackPipeBody() {
      var t;
      let {
        startLoc: r
      } = this.state, s = this.parseMaybeAssign();
      return AY.has(s.type) && !((t = s.extra) != null && t.parenthesized) && this.raise(O.PipeUnparenthesizedBody, r, {
        type: s.type
      }), this.topicReferenceWasUsedInCurrentContext() || this.raise(O.PipeTopicUnused, r), s;
    }
    checkExponentialAfterUnary(t) {
      this.match(57) && this.raise(O.UnexpectedTokenUnaryExponentiation, t.argument);
    }
    parseMaybeUnary(t, r) {
      let s = this.state.startLoc, n = this.isContextual(96);
      if (n && this.recordAwaitIfAllowed()) {
        this.next();
        let u = this.parseAwait(s);
        return r || this.checkExponentialAfterUnary(u), u;
      }
      let a = this.match(34), o = this.startNode();
      if (UY(this.state.type)) {
        o.operator = this.state.value, o.prefix = !0, this.match(72) && this.expectPlugin("throwExpressions");
        let u = this.match(89);
        if (this.next(), o.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), this.state.strict && u) {
          let c = o.argument;
          c.type === "Identifier" ? this.raise(O.StrictDelete, o) : this.hasPropertyAsPrivateName(c) && this.raise(O.DeletePrivateField, o);
        }
        if (!a)
          return r || this.checkExponentialAfterUnary(o), this.finishNode(o, "UnaryExpression");
      }
      let l = this.parseUpdate(o, a, t);
      if (n) {
        let {
          type: u
        } = this.state;
        if ((this.hasPlugin("v8intrinsic") ? Wa(u) : Wa(u) && !this.match(54)) && !this.isAmbiguousPrefixOrIdentifier())
          return this.raiseOverwrite(O.AwaitNotInAsyncContext, s), this.parseAwait(s);
      }
      return l;
    }
    parseUpdate(t, r, s) {
      if (r) {
        let o = t;
        return this.checkLVal(o.argument, this.finishNode(o, "UpdateExpression")), t;
      }
      let n = this.state.startLoc, a = this.parseExprSubscripts(s);
      if (this.checkExpressionErrors(s, !1)) return a;
      for (; qY(this.state.type) && !this.canInsertSemicolon(); ) {
        let o = this.startNodeAt(n);
        o.operator = this.state.value, o.prefix = !1, o.argument = a, this.next(), this.checkLVal(a, a = this.finishNode(o, "UpdateExpressio\
n"));
      }
      return a;
    }
    parseExprSubscripts(t) {
      let r = this.state.startLoc, s = this.state.potentialArrowAt, n = this.parseExprAtom(t);
      return this.shouldExitDescending(n, s) ? n : this.parseSubscripts(n, r);
    }
    parseSubscripts(t, r, s) {
      let n = {
        optionalChainMember: !1,
        maybeAsyncArrow: this.atPossibleAsyncArrow(t),
        stop: !1
      };
      do
        t = this.parseSubscript(t, r, s, n), n.maybeAsyncArrow = !1;
      while (!n.stop);
      return t;
    }
    parseSubscript(t, r, s, n) {
      let {
        type: a
      } = this.state;
      if (!s && a === 15)
        return this.parseBind(t, r, s, n);
      if (Wl(a))
        return this.parseTaggedTemplateExpression(t, r, n);
      let o = !1;
      if (a === 18) {
        if (s && (this.raise(O.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40))
          return this.stopParseSubscript(t, n);
        n.optionalChainMember = o = !0, this.next();
      }
      if (!s && this.match(10))
        return this.parseCoverCallAndAsyncArrowHead(t, r, n, o);
      {
        let l = this.eat(0);
        return l || o || this.eat(16) ? this.parseMember(t, r, n, l, o) : this.stopParseSubscript(t, n);
      }
    }
    stopParseSubscript(t, r) {
      return r.stop = !0, t;
    }
    parseMember(t, r, s, n, a) {
      let o = this.startNodeAt(r);
      return o.object = t, o.computed = n, n ? (o.property = this.parseExpression(), this.expect(3)) : this.match(139) ? (t.type === "Super" &&
      this.raise(O.SuperPrivateField, r), this.classScope.usePrivateName(this.state.value, this.state.startLoc), o.property = this.parsePrivateName()) :
      o.property = this.parseIdentifier(!0), s.optionalChainMember ? (o.optional = a, this.finishNode(o, "OptionalMemberExpression")) : this.
      finishNode(o, "MemberExpression");
    }
    parseBind(t, r, s, n) {
      let a = this.startNodeAt(r);
      return a.object = t, this.next(), a.callee = this.parseNoCallExpr(), n.stop = !0, this.parseSubscripts(this.finishNode(a, "BindExpress\
ion"), r, s);
    }
    parseCoverCallAndAsyncArrowHead(t, r, s, n) {
      let a = this.state.maybeInArrowParameters, o = null;
      this.state.maybeInArrowParameters = !0, this.next();
      let l = this.startNodeAt(r);
      l.callee = t;
      let {
        maybeAsyncArrow: u,
        optionalChainMember: c
      } = s;
      u && (this.expressionScope.enter(gH()), o = new wi()), c && (l.optional = n), n ? l.arguments = this.parseCallExpressionArguments() : l.
      arguments = this.parseCallExpressionArguments(t.type !== "Super", l, o);
      let p = this.finishCallExpression(l, c);
      return u && this.shouldParseAsyncArrow() && !n ? (s.stop = !0, this.checkDestructuringPrivate(o), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), p = this.parseAsyncArrowFromCallExpression(this.startNodeAt(r), p)) : (u && (this.checkExpressionErrors(o,
      !0), this.expressionScope.exit()), this.toReferencedArguments(p)), this.state.maybeInArrowParameters = a, p;
    }
    toReferencedArguments(t, r) {
      this.toReferencedListDeep(t.arguments, r);
    }
    parseTaggedTemplateExpression(t, r, s) {
      let n = this.startNodeAt(r);
      return n.tag = t, n.quasi = this.parseTemplate(!0), s.optionalChainMember && this.raise(O.OptionalChainingNoTemplate, r), this.finishNode(
      n, "TaggedTemplateExpression");
    }
    atPossibleAsyncArrow(t) {
      return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end -
      t.start === 5 && this.offsetToSourcePos(t.start) === this.state.potentialArrowAt;
    }
    finishCallExpression(t, r) {
      if (t.callee.type === "Import")
        if (t.arguments.length === 0 || t.arguments.length > 2)
          this.raise(O.ImportCallArity, t);
        else
          for (let s of t.arguments)
            s.type === "SpreadElement" && this.raise(O.ImportCallSpreadArgument, s);
      return this.finishNode(t, r ? "OptionalCallExpression" : "CallExpression");
    }
    parseCallExpressionArguments(t, r, s) {
      let n = [], a = !0, o = this.state.inFSharpPipelineDirectBody;
      for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(11); ) {
        if (a)
          a = !1;
        else if (this.expect(12), this.match(11)) {
          r && this.addTrailingCommaExtraToNode(r), this.next();
          break;
        }
        n.push(this.parseExprListItem(11, !1, s, t));
      }
      return this.state.inFSharpPipelineDirectBody = o, n;
    }
    shouldParseAsyncArrow() {
      return this.match(19) && !this.canInsertSemicolon();
    }
    parseAsyncArrowFromCallExpression(t, r) {
      var s;
      return this.resetPreviousNodeTrailingComments(r), this.expect(19), this.parseArrowExpression(t, r.arguments, !0, (s = r.extra) == null ?
      void 0 : s.trailingCommaLoc), r.innerComments && Xa(t, r.innerComments), r.callee.trailingComments && Xa(t, r.callee.trailingComments),
      t;
    }
    parseNoCallExpr() {
      let t = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), t, !0);
    }
    parseExprAtom(t) {
      let r, s = null, {
        type: n
      } = this.state;
      switch (n) {
        case 79:
          return this.parseSuper();
        case 83:
          return r = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaPropertyOrPhaseCall(r) : this.match(10) ? this.optionFlags &
          512 ? this.parseImportCall(r) : this.finishNode(r, "Import") : (this.raise(O.UnsupportedImport, this.state.lastTokStartLoc), this.
          finishNode(r, "Import"));
        case 78:
          return r = this.startNode(), this.next(), this.finishNode(r, "ThisExpression");
        case 90:
          return this.parseDo(this.startNode(), !1);
        case 56:
        case 31:
          return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
        case 135:
          return this.parseNumericLiteral(this.state.value);
        case 136:
          return this.parseBigIntLiteral(this.state.value);
        case 134:
          return this.parseStringLiteral(this.state.value);
        case 84:
          return this.parseNullLiteral();
        case 85:
          return this.parseBooleanLiteral(!0);
        case 86:
          return this.parseBooleanLiteral(!1);
        case 10: {
          let a = this.state.potentialArrowAt === this.state.start;
          return this.parseParenAndDistinguishExpression(a);
        }
        case 0:
          return this.parseArrayLike(3, !1, t);
        case 5:
          return this.parseObjectLike(8, !1, !1, t);
        case 68:
          return this.parseFunctionOrFunctionSent();
        case 26:
          s = this.parseDecorators();
        case 80:
          return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), !1);
        case 77:
          return this.parseNewOrNewTarget();
        case 25:
        case 24:
          return this.parseTemplate(!1);
        case 15: {
          r = this.startNode(), this.next(), r.object = null;
          let a = r.callee = this.parseNoCallExpr();
          if (a.type === "MemberExpression")
            return this.finishNode(r, "BindExpression");
          throw this.raise(O.UnsupportedBind, a);
        }
        case 139:
          return this.raise(O.PrivateInExpectedIn, this.state.startLoc, {
            identifierName: this.state.value
          }), this.parsePrivateName();
        case 33:
          return this.parseTopicReferenceThenEqualsSign(54, "%");
        case 32:
          return this.parseTopicReferenceThenEqualsSign(44, "^");
        case 37:
        case 38:
          return this.parseTopicReference("hack");
        case 44:
        case 54:
        case 27: {
          let a = this.getPluginOption("pipelineOperator", "proposal");
          if (a)
            return this.parseTopicReference(a);
          throw this.unexpected();
        }
        case 47: {
          let a = this.input.codePointAt(this.nextTokenStart());
          throw ns(a) || a === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
        }
        default:
          {
            if (n === 137)
              return this.parseDecimalLiteral(this.state.value);
            if (n === 2 || n === 1)
              return this.parseArrayLike(this.state.type === 2 ? 4 : 3, !0);
            if (n === 6 || n === 7)
              return this.parseObjectLike(this.state.type === 6 ? 9 : 8, !1, !0);
          }
          if (ke(n)) {
            if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123)
              return this.parseModuleExpression();
            let a = this.state.potentialArrowAt === this.state.start, o = this.state.containsEsc, l = this.parseIdentifier();
            if (!o && l.name === "async" && !this.canInsertSemicolon()) {
              let {
                type: u
              } = this.state;
              if (u === 68)
                return this.resetPreviousNodeTrailingComments(l), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(l));
              if (ke(u))
                return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(l)) : l;
              if (u === 90)
                return this.resetPreviousNodeTrailingComments(l), this.parseDo(this.startNodeAtNode(l), !0);
            }
            return a && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(l), [l],
            !1)) : l;
          } else
            throw this.unexpected();
      }
    }
    parseTopicReferenceThenEqualsSign(t, r) {
      let s = this.getPluginOption("pipelineOperator", "proposal");
      if (s)
        return this.state.type = t, this.state.value = r, this.state.pos--, this.state.end--, this.state.endLoc = Wt(this.state.endLoc, -1),
        this.parseTopicReference(s);
      throw this.unexpected();
    }
    parseTopicReference(t) {
      let r = this.startNode(), s = this.state.startLoc, n = this.state.type;
      return this.next(), this.finishTopicReference(r, s, t, n);
    }
    finishTopicReference(t, r, s, n) {
      if (this.testTopicReferenceConfiguration(s, r, n))
        return s === "hack" ? (this.topicReferenceIsAllowedInCurrentContext() || this.raise(O.PipeTopicUnbound, r), this.registerTopicReference(),
        this.finishNode(t, "TopicReference")) : (this.topicReferenceIsAllowedInCurrentContext() || this.raise(O.PrimaryTopicNotAllowed, r), this.
        registerTopicReference(), this.finishNode(t, "PipelinePrimaryTopicReference"));
      throw this.raise(O.PipeTopicUnconfiguredToken, r, {
        token: Qs(n)
      });
    }
    testTopicReferenceConfiguration(t, r, s) {
      switch (t) {
        case "hack":
          return this.hasPlugin(["pipelineOperator", {
            topicToken: Qs(s)
          }]);
        case "smart":
          return s === 27;
        default:
          throw this.raise(O.PipeTopicRequiresHackPipes, r);
      }
    }
    parseAsyncArrowUnaryFunction(t) {
      this.prodParam.enter(Vl(!0, this.prodParam.hasYield));
      let r = [this.parseIdentifier()];
      return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(O.LineTerminatorBeforeArrow, this.state.curPosition()), this.
      expect(19), this.parseArrowExpression(t, r, !0);
    }
    parseDo(t, r) {
      this.expectPlugin("doExpressions"), r && this.expectPlugin("asyncDoExpressions"), t.async = r, this.next();
      let s = this.state.labels;
      return this.state.labels = [], r ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(),
      this.state.labels = s, this.finishNode(t, "DoExpression");
    }
    parseSuper() {
      let t = this.startNode();
      return this.next(), this.match(10) && !this.scope.allowDirectSuper ? this.optionFlags & 16 || this.raise(O.SuperNotAllowed, t) : this.
      scope.allowSuper || this.optionFlags & 16 || this.raise(O.UnexpectedSuper, t), !this.match(10) && !this.match(0) && !this.match(16) &&
      this.raise(O.UnsupportedSuper, t), this.finishNode(t, "Super");
    }
    parsePrivateName() {
      let t = this.startNode(), r = this.startNodeAt(Wt(this.state.startLoc, 1)), s = this.state.value;
      return this.next(), t.id = this.createIdentifier(r, s), this.finishNode(t, "PrivateName");
    }
    parseFunctionOrFunctionSent() {
      let t = this.startNode();
      if (this.next(), this.prodParam.hasYield && this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "function");
        return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.
        parseMetaProperty(t, r, "sent");
      }
      return this.parseFunction(t);
    }
    parseMetaProperty(t, r, s) {
      t.meta = r;
      let n = this.state.containsEsc;
      return t.property = this.parseIdentifier(!0), (t.property.name !== s || n) && this.raise(O.UnsupportedMetaProperty, t.property, {
        target: r.name,
        onlyValidPropertyName: s
      }), this.finishNode(t, "MetaProperty");
    }
    parseImportMetaPropertyOrPhaseCall(t) {
      if (this.next(), this.isContextual(105) || this.isContextual(97)) {
        let r = this.isContextual(105);
        return this.expectPlugin(r ? "sourcePhaseImports" : "deferredImportEvaluation"), this.next(), t.phase = r ? "source" : "defer", this.
        parseImportCall(t);
      } else {
        let r = this.createIdentifierAt(this.startNodeAtNode(t), "import", this.state.lastTokStartLoc);
        return this.isContextual(101) && (this.inModule || this.raise(O.ImportMetaOutsideModule, r), this.sawUnambiguousESM = !0), this.parseMetaProperty(
        t, r, "meta");
      }
    }
    parseLiteralAtNode(t, r, s) {
      return this.addExtra(s, "rawValue", t), this.addExtra(s, "raw", this.input.slice(this.offsetToSourcePos(s.start), this.state.end)), s.
      value = t, this.next(), this.finishNode(s, r);
    }
    parseLiteral(t, r) {
      let s = this.startNode();
      return this.parseLiteralAtNode(t, r, s);
    }
    parseStringLiteral(t) {
      return this.parseLiteral(t, "StringLiteral");
    }
    parseNumericLiteral(t) {
      return this.parseLiteral(t, "NumericLiteral");
    }
    parseBigIntLiteral(t) {
      return this.parseLiteral(t, "BigIntLiteral");
    }
    parseDecimalLiteral(t) {
      return this.parseLiteral(t, "DecimalLiteral");
    }
    parseRegExpLiteral(t) {
      let r = this.startNode();
      return this.addExtra(r, "raw", this.input.slice(this.offsetToSourcePos(r.start), this.state.end)), r.pattern = t.pattern, r.flags = t.
      flags, this.next(), this.finishNode(r, "RegExpLiteral");
    }
    parseBooleanLiteral(t) {
      let r = this.startNode();
      return r.value = t, this.next(), this.finishNode(r, "BooleanLiteral");
    }
    parseNullLiteral() {
      let t = this.startNode();
      return this.next(), this.finishNode(t, "NullLiteral");
    }
    parseParenAndDistinguishExpression(t) {
      let r = this.state.startLoc, s;
      this.next(), this.expressionScope.enter(bH());
      let n = this.state.maybeInArrowParameters, a = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = !0, this.state.inFSharpPipelineDirectBody = !1;
      let o = this.state.startLoc, l = [], u = new wi(), c = !0, p, f;
      for (; !this.match(11); ) {
        if (c)
          c = !1;
        else if (this.expect(12, u.optionalParametersLoc === null ? null : u.optionalParametersLoc), this.match(11)) {
          f = this.state.startLoc;
          break;
        }
        if (this.match(21)) {
          let T = this.state.startLoc;
          if (p = this.state.startLoc, l.push(this.parseParenItem(this.parseRestBinding(), T)), !this.checkCommaAfterRest(41))
            break;
        } else
          l.push(this.parseMaybeAssignAllowInOrVoidPattern(11, u, this.parseParenItem));
      }
      let h = this.state.lastTokEndLoc;
      this.expect(11), this.state.maybeInArrowParameters = n, this.state.inFSharpPipelineDirectBody = a;
      let b = this.startNodeAt(r);
      return t && this.shouldParseArrow(l) && (b = this.parseArrow(b)) ? (this.checkDestructuringPrivate(u), this.expressionScope.validateAsPattern(),
      this.expressionScope.exit(), this.parseArrowExpression(b, l, !1), b) : (this.expressionScope.exit(), l.length || this.unexpected(this.
      state.lastTokStartLoc), f && this.unexpected(f), p && this.unexpected(p), this.checkExpressionErrors(u, !0), this.toReferencedListDeep(
      l, !0), l.length > 1 ? (s = this.startNodeAt(o), s.expressions = l, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s,
      h)) : s = l[0], this.wrapParenthesis(r, s));
    }
    wrapParenthesis(t, r) {
      if (!(this.optionFlags & 1024))
        return this.addExtra(r, "parenthesized", !0), this.addExtra(r, "parenStart", t.index), this.takeSurroundingComments(r, t.index, this.
        state.lastTokEndLoc.index), r;
      let s = this.startNodeAt(t);
      return s.expression = r, this.finishNode(s, "ParenthesizedExpression");
    }
    shouldParseArrow(t) {
      return !this.canInsertSemicolon();
    }
    parseArrow(t) {
      if (this.eat(19))
        return t;
    }
    parseParenItem(t, r) {
      return t;
    }
    parseNewOrNewTarget() {
      let t = this.startNode();
      if (this.next(), this.match(16)) {
        let r = this.createIdentifier(this.startNodeAtNode(t), "new");
        this.next();
        let s = this.parseMetaProperty(t, r, "target");
        return this.scope.allowNewTarget || this.raise(O.UnexpectedNewTarget, s), s;
      }
      return this.parseNew(t);
    }
    parseNew(t) {
      if (this.parseNewCallee(t), this.eat(10)) {
        let r = this.parseExprList(11);
        this.toReferencedList(r), t.arguments = r;
      } else
        t.arguments = [];
      return this.finishNode(t, "NewExpression");
    }
    parseNewCallee(t) {
      let r = this.match(83), s = this.parseNoCallExpr();
      t.callee = s, r && (s.type === "Import" || s.type === "ImportExpression") && this.raise(O.ImportCallNotNewExpression, s);
    }
    parseTemplateElement(t) {
      let {
        start: r,
        startLoc: s,
        end: n,
        value: a
      } = this.state, o = r + 1, l = this.startNodeAt(Wt(s, 1));
      a === null && (t || this.raise(O.InvalidEscapeSequenceTemplate, Wt(this.state.firstInvalidTemplateEscapePos, 1)));
      let u = this.match(24), c = u ? -1 : -2, p = n + c;
      l.value = {
        raw: this.input.slice(o, p).replace(/\r\n?/g, `
`),
        cooked: a === null ? null : a.slice(1, c)
      }, l.tail = u, this.next();
      let f = this.finishNode(l, "TemplateElement");
      return this.resetEndLocation(f, Wt(this.state.lastTokEndLoc, c)), f;
    }
    parseTemplate(t) {
      let r = this.startNode(), s = this.parseTemplateElement(t), n = [s], a = [];
      for (; !s.tail; )
        a.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), n.push(s = this.parseTemplateElement(t));
      return r.expressions = a, r.quasis = n, this.finishNode(r, "TemplateLiteral");
    }
    parseTemplateSubstitution() {
      return this.parseExpression();
    }
    parseObjectLike(t, r, s, n) {
      s && this.expectPlugin("recordAndTuple");
      let a = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let o = !1, l = !0, u = this.startNode();
      for (u.properties = [], this.next(); !this.match(t); ) {
        if (l)
          l = !1;
        else if (this.expect(12), this.match(t)) {
          this.addTrailingCommaExtraToNode(u);
          break;
        }
        let p;
        r ? p = this.parseBindingProperty() : (p = this.parsePropertyDefinition(n), o = this.checkProto(p, s, o, n)), s && !this.isObjectProperty(
        p) && p.type !== "SpreadElement" && this.raise(O.InvalidRecordProperty, p), p.shorthand && this.addExtra(p, "shorthand", !0), u.properties.
        push(p);
      }
      this.next(), this.state.inFSharpPipelineDirectBody = a;
      let c = "ObjectExpression";
      return r ? c = "ObjectPattern" : s && (c = "RecordExpression"), this.finishNode(u, c);
    }
    addTrailingCommaExtraToNode(t) {
      this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, !1);
    }
    maybeAsyncOrAccessorProp(t) {
      return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
    }
    parsePropertyDefinition(t) {
      let r = [];
      if (this.match(26))
        for (this.hasPlugin("decorators") && this.raise(O.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); )
          r.push(this.parseDecorator());
      let s = this.startNode(), n = !1, a = !1, o;
      if (this.match(21))
        return r.length && this.unexpected(), this.parseSpread();
      r.length && (s.decorators = r, r = []), s.method = !1, t && (o = this.state.startLoc);
      let l = this.eat(55);
      this.parsePropertyNamePrefixOperator(s);
      let u = this.state.containsEsc;
      if (this.parsePropertyName(s, t), !l && !u && this.maybeAsyncOrAccessorProp(s)) {
        let {
          key: c
        } = s, p = c.name;
        p === "async" && !this.hasPrecedingLineBreak() && (n = !0, this.resetPreviousNodeTrailingComments(c), l = this.eat(55), this.parsePropertyName(
        s)), (p === "get" || p === "set") && (a = !0, this.resetPreviousNodeTrailingComments(c), s.kind = p, this.match(55) && (l = !0, this.
        raise(O.AccessorIsGenerator, this.state.curPosition(), {
          kind: p
        }), this.next()), this.parsePropertyName(s));
      }
      return this.parseObjPropValue(s, o, l, n, !1, a, t);
    }
    getGetterSetterExpectedParamCount(t) {
      return t.kind === "get" ? 0 : 1;
    }
    getObjectOrClassMethodParams(t) {
      return t.params;
    }
    checkGetterSetterParams(t) {
      var r;
      let s = this.getGetterSetterExpectedParamCount(t), n = this.getObjectOrClassMethodParams(t);
      n.length !== s && this.raise(t.kind === "get" ? O.BadGetterArity : O.BadSetterArity, t), t.kind === "set" && ((r = n[n.length - 1]) ==
      null ? void 0 : r.type) === "RestElement" && this.raise(O.BadSetterRestParameter, t);
    }
    parseObjectMethod(t, r, s, n, a) {
      if (a) {
        let o = this.parseMethod(t, r, !1, !1, !1, "ObjectMethod");
        return this.checkGetterSetterParams(o), o;
      }
      if (s || r || this.match(10))
        return n && this.unexpected(), t.kind = "method", t.method = !0, this.parseMethod(t, r, s, !1, !1, "ObjectMethod");
    }
    parseObjectProperty(t, r, s, n) {
      if (t.shorthand = !1, this.eat(14))
        return t.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, n), this.finishObjectProperty(
        t);
      if (!t.computed && t.key.type === "Identifier") {
        if (this.checkReservedWord(t.key.name, t.key.loc.start, !0, !1), s)
          t.value = this.parseMaybeDefault(r, this.cloneIdentifier(t.key));
        else if (this.match(29)) {
          let a = this.state.startLoc;
          n != null ? n.shorthandAssignLoc === null && (n.shorthandAssignLoc = a) : this.raise(O.InvalidCoverInitializedName, a), t.value = this.
          parseMaybeDefault(r, this.cloneIdentifier(t.key));
        } else
          t.value = this.cloneIdentifier(t.key);
        return t.shorthand = !0, this.finishObjectProperty(t);
      }
    }
    finishObjectProperty(t) {
      return this.finishNode(t, "ObjectProperty");
    }
    parseObjPropValue(t, r, s, n, a, o, l) {
      let u = this.parseObjectMethod(t, s, n, a, o) || this.parseObjectProperty(t, r, a, l);
      return u || this.unexpected(), u;
    }
    parsePropertyName(t, r) {
      if (this.eat(0))
        t.computed = !0, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
      else {
        let {
          type: s,
          value: n
        } = this.state, a;
        if (Fr(s))
          a = this.parseIdentifier(!0);
        else
          switch (s) {
            case 135:
              a = this.parseNumericLiteral(n);
              break;
            case 134:
              a = this.parseStringLiteral(n);
              break;
            case 136:
              a = this.parseBigIntLiteral(n);
              break;
            case 139: {
              let o = this.state.startLoc;
              r != null ? r.privateKeyLoc === null && (r.privateKeyLoc = o) : this.raise(O.UnexpectedPrivateField, o), a = this.parsePrivateName();
              break;
            }
            default:
              if (s === 137) {
                a = this.parseDecimalLiteral(n);
                break;
              }
              this.unexpected();
          }
        t.key = a, s !== 139 && (t.computed = !1);
      }
    }
    initFunction(t, r) {
      t.id = null, t.generator = !1, t.async = r;
    }
    parseMethod(t, r, s, n, a, o, l = !1) {
      this.initFunction(t, s), t.generator = r, this.scope.enter(530 | (l ? 576 : 0) | (a ? 32 : 0)), this.prodParam.enter(Vl(s, t.generator)),
      this.parseFunctionParams(t, n);
      let u = this.parseFunctionBodyAndFinish(t, o, !0);
      return this.prodParam.exit(), this.scope.exit(), u;
    }
    parseArrayLike(t, r, s) {
      r && this.expectPlugin("recordAndTuple");
      let n = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !1;
      let a = this.startNode();
      return this.next(), a.elements = this.parseExprList(t, !r, s, a), this.state.inFSharpPipelineDirectBody = n, this.finishNode(a, r ? "T\
upleExpression" : "ArrayExpression");
    }
    parseArrowExpression(t, r, s, n) {
      this.scope.enter(518);
      let a = Vl(s, !1);
      !this.match(5) && this.prodParam.hasIn && (a |= 8), this.prodParam.enter(a), this.initFunction(t, s);
      let o = this.state.maybeInArrowParameters;
      return r && (this.state.maybeInArrowParameters = !0, this.setArrowFunctionParameters(t, r, n)), this.state.maybeInArrowParameters = !1,
      this.parseFunctionBody(t, !0), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = o, this.finishNode(t, "Ar\
rowFunctionExpression");
    }
    setArrowFunctionParameters(t, r, s) {
      this.toAssignableList(r, s, !1), t.params = r;
    }
    parseFunctionBodyAndFinish(t, r, s = !1) {
      return this.parseFunctionBody(t, !1, s), this.finishNode(t, r);
    }
    parseFunctionBody(t, r, s = !1) {
      let n = r && !this.match(5);
      if (this.expressionScope.enter(vx()), n)
        t.body = this.parseMaybeAssign(), this.checkParams(t, !1, r, !1);
      else {
        let a = this.state.strict, o = this.state.labels;
        this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(!0, !1, (l) => {
          let u = !this.isSimpleParamList(t.params);
          l && u && this.raise(O.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
          let c = !a && this.state.strict;
          this.checkParams(t, !this.state.strict && !r && !s && !u, r, c), this.state.strict && t.id && this.checkIdentifier(t.id, 65, c);
        }), this.prodParam.exit(), this.state.labels = o;
      }
      this.expressionScope.exit();
    }
    isSimpleParameter(t) {
      return t.type === "Identifier";
    }
    isSimpleParamList(t) {
      for (let r = 0, s = t.length; r < s; r++)
        if (!this.isSimpleParameter(t[r])) return !1;
      return !0;
    }
    checkParams(t, r, s, n = !0) {
      let a = !r && /* @__PURE__ */ new Set(), o = {
        type: "FormalParameters"
      };
      for (let l of t.params)
        this.checkLVal(l, o, 5, a, n);
    }
    parseExprList(t, r, s, n) {
      let a = [], o = !0;
      for (; !this.eat(t); ) {
        if (o)
          o = !1;
        else if (this.expect(12), this.match(t)) {
          n && this.addTrailingCommaExtraToNode(n), this.next();
          break;
        }
        a.push(this.parseExprListItem(t, r, s));
      }
      return a;
    }
    parseExprListItem(t, r, s, n) {
      let a;
      if (this.match(12))
        r || this.raise(O.UnexpectedToken, this.state.curPosition(), {
          unexpected: ","
        }), a = null;
      else if (this.match(21)) {
        let o = this.state.startLoc;
        a = this.parseParenItem(this.parseSpread(s), o);
      } else if (this.match(17)) {
        this.expectPlugin("partialApplication"), n || this.raise(O.UnexpectedArgumentPlaceholder, this.state.startLoc);
        let o = this.startNode();
        this.next(), a = this.finishNode(o, "ArgumentPlaceholder");
      } else
        a = this.parseMaybeAssignAllowInOrVoidPattern(t, s, this.parseParenItem);
      return a;
    }
    parseIdentifier(t) {
      let r = this.startNode(), s = this.parseIdentifierName(t);
      return this.createIdentifier(r, s);
    }
    createIdentifier(t, r) {
      return t.name = r, t.loc.identifierName = r, this.finishNode(t, "Identifier");
    }
    createIdentifierAt(t, r, s) {
      return t.name = r, t.loc.identifierName = r, this.finishNodeAt(t, "Identifier", s);
    }
    parseIdentifierName(t) {
      let r, {
        startLoc: s,
        type: n
      } = this.state;
      Fr(n) ? r = this.state.value : this.unexpected();
      let a = FY(n);
      return t ? a && this.replaceToken(132) : this.checkReservedWord(r, s, a, !1), this.next(), r;
    }
    checkReservedWord(t, r, s, n) {
      if (t.length > 10 || !eH(t))
        return;
      if (s && zY(t)) {
        this.raise(O.UnexpectedKeyword, r, {
          keyword: t
        });
        return;
      }
      if ((this.state.strict ? n ? Tx : bx : yx)(t, this.inModule)) {
        this.raise(O.UnexpectedReservedWord, r, {
          reservedWord: t
        });
        return;
      } else if (t === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(O.YieldBindingIdentifier, r);
          return;
        }
      } else if (t === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(O.AwaitBindingIdentifier, r);
          return;
        }
        if (this.scope.inStaticBlock) {
          this.raise(O.AwaitBindingIdentifierInStaticBlock, r);
          return;
        }
        this.expressionScope.recordAsyncArrowParametersError(r);
      } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
        this.raise(O.ArgumentsInClass, r);
        return;
      }
    }
    recordAwaitIfAllowed() {
      let t = this.prodParam.hasAwait;
      return t && !this.scope.inFunction && (this.state.hasTopLevelAwait = !0), t;
    }
    parseAwait(t) {
      let r = this.startNodeAt(t);
      return this.expressionScope.recordParameterInitializerError(O.AwaitExpressionFormalParameter, r), this.eat(55) && this.raise(O.ObsoleteAwaitStar,
      r), !this.scope.inFunction && !(this.optionFlags & 1) && (this.isAmbiguousPrefixOrIdentifier() ? this.ambiguousScriptDifferentAst = !0 :
      this.sawUnambiguousESM = !0), this.state.soloAwait || (r.argument = this.parseMaybeUnary(null, !0)), this.finishNode(r, "AwaitExpressi\
on");
    }
    isAmbiguousPrefixOrIdentifier() {
      if (this.hasPrecedingLineBreak()) return !0;
      let {
        type: t
      } = this.state;
      return t === 53 || t === 10 || t === 0 || Wl(t) || t === 102 && !this.state.containsEsc || t === 138 || t === 56 || this.hasPlugin("v8\
intrinsic") && t === 54;
    }
    parseYield(t) {
      let r = this.startNodeAt(t);
      this.expressionScope.recordParameterInitializerError(O.YieldInParameter, r);
      let s = !1, n = null;
      if (!this.hasPrecedingLineBreak())
        switch (s = this.eat(55), this.state.type) {
          case 13:
          case 140:
          case 8:
          case 11:
          case 3:
          case 9:
          case 14:
          case 12:
            if (!s) break;
          default:
            n = this.parseMaybeAssign();
        }
      return r.delegate = s, r.argument = n, this.finishNode(r, "YieldExpression");
    }
    parseImportCall(t) {
      if (this.next(), t.source = this.parseMaybeAssignAllowIn(), t.options = null, this.eat(12)) {
        if (this.match(11))
          this.addTrailingCommaExtraToNode(t.source);
        else if (t.options = this.parseMaybeAssignAllowIn(), this.eat(12) && (this.addTrailingCommaExtraToNode(t.options), !this.match(11))) {
          do
            this.parseMaybeAssignAllowIn();
          while (this.eat(12) && !this.match(11));
          this.raise(O.ImportCallArity, t);
        }
      }
      return this.expect(11), this.finishNode(t, "ImportExpression");
    }
    checkPipelineAtInfixOperator(t, r) {
      this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }]) && t.type === "SequenceExpression" && this.raise(O.PipelineHeadSequenceExpression, r);
    }
    parseSmartPipelineBodyInStyle(t, r) {
      if (this.isSimpleReference(t)) {
        let s = this.startNodeAt(r);
        return s.callee = t, this.finishNode(s, "PipelineBareFunction");
      } else {
        let s = this.startNodeAt(r);
        return this.checkSmartPipeTopicBodyEarlyErrors(r), s.expression = t, this.finishNode(s, "PipelineTopicExpression");
      }
    }
    isSimpleReference(t) {
      switch (t.type) {
        case "MemberExpression":
          return !t.computed && this.isSimpleReference(t.object);
        case "Identifier":
          return !0;
        default:
          return !1;
      }
    }
    checkSmartPipeTopicBodyEarlyErrors(t) {
      if (this.match(19))
        throw this.raise(O.PipelineBodyNoArrow, this.state.startLoc);
      this.topicReferenceWasUsedInCurrentContext() || this.raise(O.PipelineTopicUnused, t);
    }
    withTopicBindingContext(t) {
      let r = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };
      try {
        return t();
      } finally {
        this.state.topicContext = r;
      }
    }
    withSmartMixTopicForbiddingContext(t) {
      if (this.hasPlugin(["pipelineOperator", {
        proposal: "smart"
      }])) {
        let r = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        try {
          return t();
        } finally {
          this.state.topicContext = r;
        }
      } else
        return t();
    }
    withSoloAwaitPermittingContext(t) {
      let r = this.state.soloAwait;
      this.state.soloAwait = !0;
      try {
        return t();
      } finally {
        this.state.soloAwait = r;
      }
    }
    allowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & ~r) {
        this.prodParam.enter(r | 8);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    disallowInAnd(t) {
      let r = this.prodParam.currentFlags();
      if (8 & r) {
        this.prodParam.enter(r & -9);
        try {
          return t();
        } finally {
          this.prodParam.exit();
        }
      }
      return t();
    }
    registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    }
    topicReferenceIsAllowedInCurrentContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    }
    topicReferenceWasUsedInCurrentContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    }
    parseFSharpPipelineBody(t) {
      let r = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      let s = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = !0;
      let n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), r, t);
      return this.state.inFSharpPipelineDirectBody = s, n;
    }
    parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      let t = this.startNode();
      this.next(), this.match(5) || this.unexpected(null, 5);
      let r = this.startNodeAt(this.state.endLoc);
      this.next();
      let s = this.initializeScopes(!0);
      this.enterInitialScopes();
      try {
        t.body = this.parseProgram(r, 8, "module");
      } finally {
        s();
      }
      return this.finishNode(t, "ModuleExpression");
    }
    parseVoidPattern(t) {
      this.expectPlugin("discardBinding");
      let r = this.startNode();
      return t != null && (t.voidPatternLoc = this.state.startLoc), this.next(), this.finishNode(r, "VoidPattern");
    }
    parseMaybeAssignAllowInOrVoidPattern(t, r, s) {
      if (r != null && this.match(88)) {
        let n = this.lookaheadCharCode();
        if (n === 44 || n === (t === 3 ? 93 : t === 8 ? 125 : 41) || n === 61)
          return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(r));
      }
      return this.parseMaybeAssignAllowIn(r, s);
    }
    parsePropertyNamePrefixOperator(t) {
    }
  }, g0 = {
    kind: 1
  }, IH = {
    kind: 2
  }, OH = /[\uD800-\uDFFF]/u, T0 = /in(?:stanceof)?/y;
  function NH(e, t, r) {
    for (let s = 0; s < e.length; s++) {
      let n = e[s], {
        type: a
      } = n;
      if (typeof a == "number") {
        {
          if (a === 139) {
            let {
              loc: o,
              start: l,
              value: u,
              end: c
            } = n, p = l + 1, f = Wt(o.start, 1);
            e.splice(s, 1, new rs({
              type: bs(27),
              value: "#",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: f
            }), new rs({
              type: bs(132),
              value: u,
              start: p,
              end: c,
              startLoc: f,
              endLoc: o.end
            })), s++;
            continue;
          }
          if (Wl(a)) {
            let {
              loc: o,
              start: l,
              value: u,
              end: c
            } = n, p = l + 1, f = Wt(o.start, 1), h;
            t.charCodeAt(l - r) === 96 ? h = new rs({
              type: bs(22),
              value: "`",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: f
            }) : h = new rs({
              type: bs(8),
              value: "}",
              start: l,
              end: p,
              startLoc: o.start,
              endLoc: f
            });
            let b, T, d, g;
            a === 24 ? (T = c - 1, d = Wt(o.end, -1), b = u === null ? null : u.slice(1, -1), g = new rs({
              type: bs(22),
              value: "`",
              start: T,
              end: c,
              startLoc: d,
              endLoc: o.end
            })) : (T = c - 2, d = Wt(o.end, -2), b = u === null ? null : u.slice(1, -2), g = new rs({
              type: bs(23),
              value: "${",
              start: T,
              end: c,
              startLoc: d,
              endLoc: o.end
            })), e.splice(s, 1, h, new rs({
              type: bs(20),
              value: b,
              start: p,
              end: T,
              startLoc: f,
              endLoc: d
            }), g), s += 2;
            continue;
          }
        }
        n.type = bs(a);
      }
    }
    return e;
  }
  i(NH, "babel7CompatTokens");
  var q0 = class extends R0 {
    static {
      i(this, "StatementParser");
    }
    parseTopLevel(t, r) {
      return t.program = this.parseProgram(r, 140, this.options.sourceType === "module" ? "module" : "script"), t.comments = this.comments, this.
      optionFlags & 256 && (t.tokens = NH(this.tokens, this.input, this.startIndex)), this.finishNode(t, "File");
    }
    parseProgram(t, r, s) {
      if (t.sourceType = s, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, !0, !0, r), this.inModule) {
        if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0)
          for (let [a, o] of Array.from(this.scope.undefinedExports))
            this.raise(O.ModuleExportUndefined, o, {
              localName: a
            });
        this.addExtra(t, "topLevelAwait", this.state.hasTopLevelAwait);
      }
      let n;
      return r === 140 ? n = this.finishNode(t, "Program") : n = this.finishNodeAt(t, "Program", Wt(this.state.startLoc, -1)), n;
    }
    stmtToDirective(t) {
      let r = this.castNodeTo(t, "Directive"), s = this.castNodeTo(t.expression, "DirectiveLiteral"), n = s.value, a = this.input.slice(this.
      offsetToSourcePos(s.start), this.offsetToSourcePos(s.end)), o = s.value = a.slice(1, -1);
      return this.addExtra(s, "raw", a), this.addExtra(s, "rawValue", o), this.addExtra(s, "expressionValue", n), r.value = s, delete t.expression,
      r;
    }
    parseInterpreterDirective() {
      if (!this.match(28))
        return null;
      let t = this.startNode();
      return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
    }
    isLet() {
      return this.isContextual(100) ? this.hasFollowingBindingAtom() : !1;
    }
    isUsing() {
      return this.isContextual(107) ? this.nextTokenIsIdentifierOnSameLine() : !1;
    }
    isForUsing() {
      if (!this.isContextual(107))
        return !1;
      let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
      if (this.isUnparsedContextual(t, "of")) {
        let s = this.lookaheadCharCodeSince(t + 2);
        if (s !== 61 && s !== 58 && s !== 59)
          return !1;
      }
      return !!(this.chStartsBindingIdentifier(r, t) || this.isUnparsedContextual(t, "void"));
    }
    nextTokenIsIdentifierOnSameLine() {
      let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingIdentifier(r, t);
    }
    isAwaitUsing() {
      if (!this.isContextual(96))
        return !1;
      let t = this.nextTokenInLineStart();
      if (this.isUnparsedContextual(t, "using")) {
        t = this.nextTokenInLineStartSince(t + 5);
        let r = this.codePointAtPos(t);
        if (this.chStartsBindingIdentifier(r, t))
          return !0;
      }
      return !1;
    }
    chStartsBindingIdentifier(t, r) {
      if (ns(t)) {
        if (T0.lastIndex = r, T0.test(this.input)) {
          let s = this.codePointAtPos(T0.lastIndex);
          if (!Nn(s) && s !== 92)
            return !1;
        }
        return !0;
      } else return t === 92;
    }
    chStartsBindingPattern(t) {
      return t === 91 || t === 123;
    }
    hasFollowingBindingAtom() {
      let t = this.nextTokenStart(), r = this.codePointAtPos(t);
      return this.chStartsBindingPattern(r) || this.chStartsBindingIdentifier(r, t);
    }
    hasInLineFollowingBindingIdentifierOrBrace() {
      let t = this.nextTokenInLineStart(), r = this.codePointAtPos(t);
      return r === 123 || this.chStartsBindingIdentifier(r, t);
    }
    allowsUsing() {
      return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;
    }
    parseModuleItem() {
      return this.parseStatementLike(15);
    }
    parseStatementListItem() {
      return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
    }
    parseStatementOrSloppyAnnexBFunctionDeclaration(t = !1) {
      let r = 0;
      return this.options.annexB && !this.state.strict && (r |= 4, t && (r |= 8)), this.parseStatementLike(r);
    }
    parseStatement() {
      return this.parseStatementLike(0);
    }
    parseStatementLike(t) {
      let r = null;
      return this.match(26) && (r = this.parseDecorators(!0)), this.parseStatementContent(t, r);
    }
    parseStatementContent(t, r) {
      let s = this.state.type, n = this.startNode(), a = !!(t & 2), o = !!(t & 4), l = t & 1;
      switch (s) {
        case 60:
          return this.parseBreakContinueStatement(n, !0);
        case 63:
          return this.parseBreakContinueStatement(n, !1);
        case 64:
          return this.parseDebuggerStatement(n);
        case 90:
          return this.parseDoWhileStatement(n);
        case 91:
          return this.parseForStatement(n);
        case 68:
          if (this.lookaheadCharCode() === 46) break;
          return o || this.raise(this.state.strict ? O.StrictFunction : this.options.annexB ? O.SloppyFunctionAnnexB : O.SloppyFunction, this.
          state.startLoc), this.parseFunctionStatement(n, !1, !a && o);
        case 80:
          return a || this.unexpected(), this.parseClass(this.maybeTakeDecorators(r, n), !0);
        case 69:
          return this.parseIfStatement(n);
        case 70:
          return this.parseReturnStatement(n);
        case 71:
          return this.parseSwitchStatement(n);
        case 72:
          return this.parseThrowStatement(n);
        case 73:
          return this.parseTryStatement(n);
        case 96:
          if (this.isAwaitUsing())
            return this.allowsUsing() ? a ? this.recordAwaitIfAllowed() || this.raise(O.AwaitUsingNotInAsyncContext, n) : this.raise(O.UnexpectedLexicalDeclaration,
            n) : this.raise(O.UnexpectedUsingDeclaration, n), this.next(), this.parseVarStatement(n, "await using");
          break;
        case 107:
          if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace())
            break;
          return this.allowsUsing() ? a || this.raise(O.UnexpectedLexicalDeclaration, this.state.startLoc) : this.raise(O.UnexpectedUsingDeclaration,
          this.state.startLoc), this.parseVarStatement(n, "using");
        case 100: {
          if (this.state.containsEsc)
            break;
          let p = this.nextTokenStart(), f = this.codePointAtPos(p);
          if (f !== 91 && (!a && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(f, p) && f !== 123))
            break;
        }
        case 75:
          a || this.raise(O.UnexpectedLexicalDeclaration, this.state.startLoc);
        case 74: {
          let p = this.state.value;
          return this.parseVarStatement(n, p);
        }
        case 92:
          return this.parseWhileStatement(n);
        case 76:
          return this.parseWithStatement(n);
        case 5:
          return this.parseBlock();
        case 13:
          return this.parseEmptyStatement(n);
        case 83: {
          let p = this.lookaheadCharCode();
          if (p === 40 || p === 46)
            break;
        }
        case 82: {
          !(this.optionFlags & 8) && !l && this.raise(O.UnexpectedImportExport, this.state.startLoc), this.next();
          let p;
          return s === 83 ? p = this.parseImport(n) : p = this.parseExport(n, r), this.assertModuleNodeAllowed(p), p;
        }
        default:
          if (this.isAsyncFunction())
            return a || this.raise(O.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(n,
            !0, !a && o);
      }
      let u = this.state.value, c = this.parseExpression();
      return ke(s) && c.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(n, u, c, t) : this.parseExpressionStatement(n, c,
      r);
    }
    assertModuleNodeAllowed(t) {
      !(this.optionFlags & 8) && !this.inModule && this.raise(O.ImportOutsideModule, t);
    }
    decoratorsEnabledBeforeExport() {
      return this.hasPlugin("decorators-legacy") ? !0 : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBefore\
Export") !== !1;
    }
    maybeTakeDecorators(t, r, s) {
      if (t) {
        var n;
        (n = r.decorators) != null && n.length ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(
        O.DecoratorsBeforeAfterExport, r.decorators[0]), r.decorators.unshift(...t)) : r.decorators = t, this.resetStartLocationFromNode(r, t[0]),
        s && this.resetStartLocationFromNode(s, r);
      }
      return r;
    }
    canHaveLeadingDecorator() {
      return this.match(80);
    }
    parseDecorators(t) {
      let r = [];
      do
        r.push(this.parseDecorator());
      while (this.match(26));
      if (this.match(82))
        t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(O.DecoratorExportClass, this.state.startLoc);
      else if (!this.canHaveLeadingDecorator())
        throw this.raise(O.UnexpectedLeadingDecorator, this.state.startLoc);
      return r;
    }
    parseDecorator() {
      this.expectOnePlugin(["decorators", "decorators-legacy"]);
      let t = this.startNode();
      if (this.next(), this.hasPlugin("decorators")) {
        let r = this.state.startLoc, s;
        if (this.match(10)) {
          let n = this.state.startLoc;
          this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(n, s);
          let a = this.state.startLoc;
          t.expression = this.parseMaybeDecoratorArguments(s, n), this.getPluginOption("decorators", "allowCallParenthesized") === !1 && t.expression !==
          s && this.raise(O.DecoratorArgumentsOutsideParentheses, a);
        } else {
          for (s = this.parseIdentifier(!1); this.eat(16); ) {
            let n = this.startNodeAt(r);
            n.object = s, this.match(139) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) :
            n.property = this.parseIdentifier(!0), n.computed = !1, s = this.finishNode(n, "MemberExpression");
          }
          t.expression = this.parseMaybeDecoratorArguments(s, r);
        }
      } else
        t.expression = this.parseExprSubscripts();
      return this.finishNode(t, "Decorator");
    }
    parseMaybeDecoratorArguments(t, r) {
      if (this.eat(10)) {
        let s = this.startNodeAt(r);
        return s.callee = t, s.arguments = this.parseCallExpressionArguments(), this.toReferencedList(s.arguments), this.finishNode(s, "Call\
Expression");
      }
      return t;
    }
    parseBreakContinueStatement(t, r) {
      return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(
      t, r), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
    }
    verifyBreakContinue(t, r) {
      let s;
      for (s = 0; s < this.state.labels.length; ++s) {
        let n = this.state.labels[s];
        if ((t.label == null || n.name === t.label.name) && (n.kind != null && (r || n.kind === 1) || t.label && r))
          break;
      }
      if (s === this.state.labels.length) {
        let n = r ? "BreakStatement" : "ContinueStatement";
        this.raise(O.IllegalBreakContinue, t, {
          type: n
        });
      }
    }
    parseDebuggerStatement(t) {
      return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
    }
    parseHeaderExpression() {
      this.expect(10);
      let t = this.parseExpression();
      return this.expect(11), t;
    }
    parseDoWhileStatement(t) {
      return this.next(), this.state.labels.push(g0), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.
      labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
    }
    parseForStatement(t) {
      this.next(), this.state.labels.push(g0);
      let r = null;
      if (this.isContextual(96) && this.recordAwaitIfAllowed() && (r = this.state.startLoc, this.next()), this.scope.enter(0), this.expect(10),
      this.match(13))
        return r !== null && this.unexpected(r), this.parseFor(t, null);
      let s = this.isContextual(100);
      {
        let u = this.isAwaitUsing(), c = u || this.isForUsing(), p = s && this.hasFollowingBindingAtom() || c;
        if (this.match(74) || this.match(75) || p) {
          let f = this.startNode(), h;
          u ? (h = "await using", this.recordAwaitIfAllowed() || this.raise(O.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) :
          h = this.state.value, this.next(), this.parseVar(f, !0, h);
          let b = this.finishNode(f, "VariableDeclaration"), T = this.match(58);
          return T && c && this.raise(O.ForInUsing, b), (T || this.isContextual(102)) && b.declarations.length === 1 ? this.parseForIn(t, b,
          r) : (r !== null && this.unexpected(r), this.parseFor(t, b));
        }
      }
      let n = this.isContextual(95), a = new wi(), o = this.parseExpression(!0, a), l = this.isContextual(102);
      if (l && (s && this.raise(O.ForOfLet, o), r === null && n && o.type === "Identifier" && this.raise(O.ForOfAsync, o)), l || this.match(
      58)) {
        this.checkDestructuringPrivate(a), this.toAssignable(o, !0);
        let u = l ? "ForOfStatement" : "ForInStatement";
        return this.checkLVal(o, {
          type: u
        }), this.parseForIn(t, o, r);
      } else
        this.checkExpressionErrors(a, !0);
      return r !== null && this.unexpected(r), this.parseFor(t, o);
    }
    parseFunctionStatement(t, r, s) {
      return this.next(), this.parseFunction(t, 1 | (s ? 2 : 0) | (r ? 8 : 0));
    }
    parseIfStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate =
      this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
    }
    parseReturnStatement(t) {
      return this.prodParam.hasReturn || this.raise(O.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t.argument =
      null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
    }
    parseSwitchStatement(t) {
      this.next(), t.discriminant = this.parseHeaderExpression();
      let r = t.cases = [];
      this.expect(5), this.state.labels.push(IH), this.scope.enter(256);
      let s;
      for (let n; !this.match(8); )
        if (this.match(61) || this.match(65)) {
          let a = this.match(61);
          s && this.finishNode(s, "SwitchCase"), r.push(s = this.startNode()), s.consequent = [], this.next(), a ? s.test = this.parseExpression() :
          (n && this.raise(O.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), n = !0, s.test = null), this.expect(14);
        } else
          s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
      return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchState\
ment");
    }
    parseThrowStatement(t) {
      return this.next(), this.hasPrecedingLineBreak() && this.raise(O.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(),
      this.semicolon(), this.finishNode(t, "ThrowStatement");
    }
    parseCatchClauseParam() {
      let t = this.parseBindingAtom();
      return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, {
        type: "CatchClause"
      }, 9), t;
    }
    parseTryStatement(t) {
      if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
        let r = this.startNode();
        this.next(), this.match(10) ? (this.expect(10), r.param = this.parseCatchClauseParam(), this.expect(11)) : (r.param = null, this.scope.
        enter(0)), r.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(!1, !1)), this.scope.exit(), t.handler = this.finishNode(
        r, "CatchClause");
      }
      return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(O.NoCatchOrFinally, t), this.finishNode(
      t, "TryStatement");
    }
    parseVarStatement(t, r, s = !1) {
      return this.next(), this.parseVar(t, !1, r, s), this.semicolon(), this.finishNode(t, "VariableDeclaration");
    }
    parseWhileStatement(t) {
      return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(g0), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
    }
    parseWithStatement(t) {
      return this.state.strict && this.raise(O.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body =
      this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
    }
    parseEmptyStatement(t) {
      return this.next(), this.finishNode(t, "EmptyStatement");
    }
    parseLabeledStatement(t, r, s, n) {
      for (let o of this.state.labels)
        o.name === r && this.raise(O.LabelRedeclaration, s, {
          labelName: r
        });
      let a = MY(this.state.type) ? 1 : this.match(71) ? 2 : null;
      for (let o = this.state.labels.length - 1; o >= 0; o--) {
        let l = this.state.labels[o];
        if (l.statementStart === t.start)
          l.statementStart = this.sourceToOffsetPos(this.state.start), l.kind = a;
        else
          break;
      }
      return this.state.labels.push({
        name: r,
        kind: a,
        statementStart: this.sourceToOffsetPos(this.state.start)
      }), t.body = n & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0) : this.parseStatement(), this.state.labels.pop(), t.label =
      s, this.finishNode(t, "LabeledStatement");
    }
    parseExpressionStatement(t, r, s) {
      return t.expression = r, this.semicolon(), this.finishNode(t, "ExpressionStatement");
    }
    parseBlock(t = !1, r = !0, s) {
      let n = this.startNode();
      return t && this.state.strictErrors.clear(), this.expect(5), r && this.scope.enter(0), this.parseBlockBody(n, t, !1, 8, s), r && this.
      scope.exit(), this.finishNode(n, "BlockStatement");
    }
    isValidDirective(t) {
      return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
    }
    parseBlockBody(t, r, s, n, a) {
      let o = t.body = [], l = t.directives = [];
      this.parseBlockOrModuleBlockBody(o, r ? l : void 0, s, n, a);
    }
    parseBlockOrModuleBlockBody(t, r, s, n, a) {
      let o = this.state.strict, l = !1, u = !1;
      for (; !this.match(n); ) {
        let c = s ? this.parseModuleItem() : this.parseStatementListItem();
        if (r && !u) {
          if (this.isValidDirective(c)) {
            let p = this.stmtToDirective(c);
            r.push(p), !l && p.value.value === "use strict" && (l = !0, this.setStrict(!0));
            continue;
          }
          u = !0, this.state.strictErrors.clear();
        }
        t.push(c);
      }
      a?.call(this, l), o || this.setStrict(!1), this.next();
    }
    parseFor(t, r) {
      return t.init = r, this.semicolon(!1), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(!1), t.update = this.match(
      11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.
      scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
    }
    parseForIn(t, r, s) {
      let n = this.match(58);
      return this.next(), n ? s !== null && this.unexpected(s) : t.await = s !== null, r.type === "VariableDeclaration" && r.declarations[0].
      init != null && (!n || !this.options.annexB || this.state.strict || r.kind !== "var" || r.declarations[0].id.type !== "Identifier") &&
      this.raise(O.ForInOfLoopInitializer, r, {
        type: n ? "ForInStatement" : "ForOfStatement"
      }), r.type === "AssignmentPattern" && this.raise(O.InvalidLhs, r, {
        ancestor: {
          type: "ForStatement"
        }
      }), t.left = r, t.right = n ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(
      () => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, n ? "ForInStatement" : "ForOfStatement");
    }
    parseVar(t, r, s, n = !1) {
      let a = t.declarations = [];
      for (t.kind = s; ; ) {
        let o = this.startNode();
        if (this.parseVarId(o, s), o.init = this.eat(29) ? r ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, o.
        init === null && !n && (o.id.type !== "Identifier" && !(r && (this.match(58) || this.isContextual(102))) ? this.raise(O.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: "destructuring"
        }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(O.DeclarationMissingInitializer,
        this.state.lastTokEndLoc, {
          kind: s
        })), a.push(this.finishNode(o, "VariableDeclarator")), !this.eat(12)) break;
      }
      return t;
    }
    parseVarId(t, r) {
      let s = this.parseBindingAtom();
      r === "using" || r === "await using" ? (s.type === "ArrayPattern" || s.type === "ObjectPattern") && this.raise(O.UsingDeclarationHasBindingPattern,
      s.loc.start) : s.type === "VoidPattern" && this.raise(O.UnexpectedVoidPattern, s.loc.start), this.checkLVal(s, {
        type: "VariableDeclarator"
      }, r === "var" ? 5 : 8201), t.id = s;
    }
    parseAsyncFunctionExpression(t) {
      return this.parseFunction(t, 8);
    }
    parseFunction(t, r = 0) {
      let s = r & 2, n = !!(r & 1), a = n && !(r & 4), o = !!(r & 8);
      this.initFunction(t, o), this.match(55) && (s && this.raise(O.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.
      generator = !0), n && (t.id = this.parseFunctionId(a));
      let l = this.state.maybeInArrowParameters;
      return this.state.maybeInArrowParameters = !1, this.scope.enter(514), this.prodParam.enter(Vl(o, t.generator)), n || (t.id = this.parseFunctionId()),
      this.parseFunctionParams(t, !1), this.withSmartMixTopicForbiddingContext(() => {
        this.parseFunctionBodyAndFinish(t, n ? "FunctionDeclaration" : "FunctionExpression");
      }), this.prodParam.exit(), this.scope.exit(), n && !s && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = l, t;
    }
    parseFunctionId(t) {
      return t || ke(this.state.type) ? this.parseIdentifier() : null;
    }
    parseFunctionParams(t, r) {
      this.expect(10), this.expressionScope.enter(yH()), t.params = this.parseBindingList(11, 41, 2 | (r ? 4 : 0)), this.expressionScope.exit();
    }
    registerFunctionStatementId(t) {
      t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ?
      5 : 8201 : 17, t.id.loc.start);
    }
    parseClass(t, r, s) {
      this.next();
      let n = this.state.strict;
      return this.state.strict = !0, this.parseClassId(t, r, s), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, n), this.
      finishNode(t, r ? "ClassDeclaration" : "ClassExpression");
    }
    isClassProperty() {
      return this.match(29) || this.match(13) || this.match(8);
    }
    isClassMethod() {
      return this.match(10);
    }
    nameIsConstructor(t) {
      return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
    }
    isNonstaticConstructor(t) {
      return !t.computed && !t.static && this.nameIsConstructor(t.key);
    }
    parseClassBody(t, r) {
      this.classScope.enter();
      let s = {
        hadConstructor: !1,
        hadSuperClass: t
      }, n = [], a = this.startNode();
      if (a.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
        for (; !this.match(8); ) {
          if (this.eat(13)) {
            if (n.length > 0)
              throw this.raise(O.DecoratorSemicolon, this.state.lastTokEndLoc);
            continue;
          }
          if (this.match(26)) {
            n.push(this.parseDecorator());
            continue;
          }
          let o = this.startNode();
          n.length && (o.decorators = n, this.resetStartLocationFromNode(o, n[0]), n = []), this.parseClassMember(a, o, s), o.kind === "cons\
tructor" && o.decorators && o.decorators.length > 0 && this.raise(O.DecoratorConstructor, o);
        }
      }), this.state.strict = r, this.next(), n.length)
        throw this.raise(O.TrailingDecorator, this.state.startLoc);
      return this.classScope.exit(), this.finishNode(a, "ClassBody");
    }
    parseClassMemberFromModifier(t, r) {
      let s = this.parseIdentifier(!0);
      if (this.isClassMethod()) {
        let n = r;
        return n.kind = "method", n.computed = !1, n.key = s, n.static = !1, this.pushClassMethod(t, n, !1, !1, !1, !1), !0;
      } else if (this.isClassProperty()) {
        let n = r;
        return n.computed = !1, n.key = s, n.static = !1, t.body.push(this.parseClassProperty(n)), !0;
      }
      return this.resetPreviousNodeTrailingComments(s), !1;
    }
    parseClassMember(t, r, s) {
      let n = this.isContextual(106);
      if (n) {
        if (this.parseClassMemberFromModifier(t, r))
          return;
        if (this.eat(5)) {
          this.parseClassStaticBlock(t, r);
          return;
        }
      }
      this.parseClassMemberWithIsStatic(t, r, s, n);
    }
    parseClassMemberWithIsStatic(t, r, s, n) {
      let a = r, o = r, l = r, u = r, c = r, p = a, f = a;
      if (r.static = n, this.parsePropertyNamePrefixOperator(r), this.eat(55)) {
        p.kind = "method";
        let E = this.match(139);
        if (this.parseClassElementName(p), this.parsePostMemberNameModifiers(p), E) {
          this.pushClassPrivateMethod(t, o, !0, !1);
          return;
        }
        this.isNonstaticConstructor(a) && this.raise(O.ConstructorIsGenerator, a.key), this.pushClassMethod(t, a, !0, !1, !1, !1);
        return;
      }
      let h = !this.state.containsEsc && ke(this.state.type), b = this.parseClassElementName(r), T = h ? b.name : null, d = this.isPrivateName(
      b), g = this.state.startLoc;
      if (this.parsePostMemberNameModifiers(f), this.isClassMethod()) {
        if (p.kind = "method", d) {
          this.pushClassPrivateMethod(t, o, !1, !1);
          return;
        }
        let E = this.isNonstaticConstructor(a), _ = !1;
        E && (a.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(O.DuplicateConstructor, b), E && this.
        hasPlugin("typescript") && r.override && this.raise(O.OverrideOnConstructor, b), s.hadConstructor = !0, _ = s.hadSuperClass), this.pushClassMethod(
        t, a, !1, !1, E, _);
      } else if (this.isClassProperty())
        d ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, l);
      else if (T === "async" && !this.isLineTerminator()) {
        this.resetPreviousNodeTrailingComments(b);
        let E = this.eat(55);
        f.optional && this.unexpected(g), p.kind = "method";
        let _ = this.match(139);
        this.parseClassElementName(p), this.parsePostMemberNameModifiers(f), _ ? this.pushClassPrivateMethod(t, o, E, !0) : (this.isNonstaticConstructor(
        a) && this.raise(O.ConstructorIsAsync, a.key), this.pushClassMethod(t, a, E, !0, !1, !1));
      } else if ((T === "get" || T === "set") && !(this.match(55) && this.isLineTerminator())) {
        this.resetPreviousNodeTrailingComments(b), p.kind = T;
        let E = this.match(139);
        this.parseClassElementName(a), E ? this.pushClassPrivateMethod(t, o, !1, !1) : (this.isNonstaticConstructor(a) && this.raise(O.ConstructorIsAccessor,
        a.key), this.pushClassMethod(t, a, !1, !1, !1, !1)), this.checkGetterSetterParams(a);
      } else if (T === "accessor" && !this.isLineTerminator()) {
        this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(b);
        let E = this.match(139);
        this.parseClassElementName(l), this.pushClassAccessorProperty(t, c, E);
      } else this.isLineTerminator() ? d ? this.pushClassPrivateProperty(t, u) : this.pushClassProperty(t, l) : this.unexpected();
    }
    parseClassElementName(t) {
      let {
        type: r,
        value: s
      } = this.state;
      if ((r === 132 || r === 134) && t.static && s === "prototype" && this.raise(O.StaticPrototype, this.state.startLoc), r === 139) {
        s === "constructor" && this.raise(O.ConstructorClassPrivateField, this.state.startLoc);
        let n = this.parsePrivateName();
        return t.key = n, n;
      }
      return this.parsePropertyName(t), t.key;
    }
    parseClassStaticBlock(t, r) {
      var s;
      this.scope.enter(720);
      let n = this.state.labels;
      this.state.labels = [], this.prodParam.enter(0);
      let a = r.body = [];
      this.parseBlockOrModuleBlockBody(a, void 0, !1, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = n, t.body.push(this.
      finishNode(r, "StaticBlock")), (s = r.decorators) != null && s.length && this.raise(O.DecoratorStaticBlock, r);
    }
    pushClassProperty(t, r) {
      !r.computed && this.nameIsConstructor(r.key) && this.raise(O.ConstructorClassField, r.key), t.body.push(this.parseClassProperty(r));
    }
    pushClassPrivateProperty(t, r) {
      let s = this.parseClassPrivateProperty(r);
      t.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
    }
    pushClassAccessorProperty(t, r, s) {
      !s && !r.computed && this.nameIsConstructor(r.key) && this.raise(O.ConstructorClassField, r.key);
      let n = this.parseClassAccessorProperty(r);
      t.body.push(n), s && this.classScope.declarePrivateName(this.getPrivateNameSV(n.key), 0, n.key.loc.start);
    }
    pushClassMethod(t, r, s, n, a, o) {
      t.body.push(this.parseMethod(r, s, n, a, o, "ClassMethod", !0));
    }
    pushClassPrivateMethod(t, r, s, n) {
      let a = this.parseMethod(r, s, n, !1, !1, "ClassPrivateMethod", !0);
      t.body.push(a);
      let o = a.kind === "get" ? a.static ? 6 : 2 : a.kind === "set" ? a.static ? 5 : 1 : 0;
      this.declareClassPrivateMethodInScope(a, o);
    }
    declareClassPrivateMethodInScope(t, r) {
      this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), r, t.key.loc.start);
    }
    parsePostMemberNameModifiers(t) {
    }
    parseClassPrivateProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
    }
    parseClassProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
    }
    parseClassAccessorProperty(t) {
      return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
    }
    parseInitializer(t) {
      this.scope.enter(592), this.expressionScope.enter(vx()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() :
      null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
    }
    parseClassId(t, r, s, n = 8331) {
      if (ke(this.state.type))
        t.id = this.parseIdentifier(), r && this.declareNameFromIdentifier(t.id, n);
      else if (s || !r)
        t.id = null;
      else
        throw this.raise(O.MissingClassName, this.state.startLoc);
    }
    parseClassSuper(t) {
      t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
    }
    parseExport(t, r) {
      let s = this.parseMaybeImportPhase(t, !0), n = this.maybeParseExportDefaultSpecifier(t, s), a = !n || this.eat(12), o = a && this.eatExportStar(
      t), l = o && this.maybeParseExportNamespaceSpecifier(t), u = a && (!l || this.eat(12)), c = n || o;
      if (o && !l) {
        if (n && this.unexpected(), r)
          throw this.raise(O.UnsupportedDecoratorExport, t);
        return this.parseExportFrom(t, !0), this.sawUnambiguousESM = !0, this.finishNode(t, "ExportAllDeclaration");
      }
      let p = this.maybeParseExportNamedSpecifiers(t);
      n && a && !o && !p && this.unexpected(null, 5), l && u && this.unexpected(null, 98);
      let f;
      if (c || p) {
        if (f = !1, r)
          throw this.raise(O.UnsupportedDecoratorExport, t);
        this.parseExportFrom(t, c);
      } else
        f = this.maybeParseExportDeclaration(t);
      if (c || p || f) {
        var h;
        let b = t;
        if (this.checkExport(b, !0, !1, !!b.source), ((h = b.declaration) == null ? void 0 : h.type) === "ClassDeclaration")
          this.maybeTakeDecorators(r, b.declaration, b);
        else if (r)
          throw this.raise(O.UnsupportedDecoratorExport, t);
        return this.sawUnambiguousESM = !0, this.finishNode(b, "ExportNamedDeclaration");
      }
      if (this.eat(65)) {
        let b = t, T = this.parseExportDefaultExpression();
        if (b.declaration = T, T.type === "ClassDeclaration")
          this.maybeTakeDecorators(r, T, b);
        else if (r)
          throw this.raise(O.UnsupportedDecoratorExport, t);
        return this.checkExport(b, !0, !0), this.sawUnambiguousESM = !0, this.finishNode(b, "ExportDefaultDeclaration");
      }
      throw this.unexpected(null, 5);
    }
    eatExportStar(t) {
      return this.eat(55);
    }
    maybeParseExportDefaultSpecifier(t, r) {
      if (r || this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom", r?.loc.start);
        let s = r || this.parseIdentifier(!0), n = this.startNodeAtNode(s);
        return n.exported = s, t.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], !0;
      }
      return !1;
    }
    maybeParseExportNamespaceSpecifier(t) {
      if (this.isContextual(93)) {
        var r, s;
        (s = (r = t).specifiers) != null || (r.specifiers = []);
        let n = this.startNodeAt(this.state.lastTokStartLoc);
        return this.next(), n.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(n, "ExportNamespaceSpecifier")), !0;
      }
      return !1;
    }
    maybeParseExportNamedSpecifiers(t) {
      if (this.match(5)) {
        let r = t;
        r.specifiers || (r.specifiers = []);
        let s = r.exportKind === "type";
        return r.specifiers.push(...this.parseExportSpecifiers(s)), r.source = null, this.hasPlugin("importAssertions") ? r.assertions = [] :
        r.attributes = [], r.declaration = null, !0;
      }
      return !1;
    }
    maybeParseExportDeclaration(t) {
      return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") ? t.assertions = [] :
      t.attributes = [], t.declaration = this.parseExportDeclaration(t), !0) : !1;
    }
    isAsyncFunction() {
      if (!this.isContextual(95)) return !1;
      let t = this.nextTokenInLineStart();
      return this.isUnparsedContextual(t, "function");
    }
    parseExportDefaultExpression() {
      let t = this.startNode();
      if (this.match(68))
        return this.next(), this.parseFunction(t, 5);
      if (this.isAsyncFunction())
        return this.next(), this.next(), this.parseFunction(t, 13);
      if (this.match(80))
        return this.parseClass(t, !0, !0);
      if (this.match(26))
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === !0 && this.raise(O.DecoratorBeforeExport,
        this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(!1), this.startNode()), !0, !0);
      if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing())
        throw this.raise(O.UnsupportedDefaultExport, this.state.startLoc);
      let r = this.parseMaybeAssignAllowIn();
      return this.semicolon(), r;
    }
    parseExportDeclaration(t) {
      return this.match(80) ? this.parseClass(this.startNode(), !0, !1) : this.parseStatementListItem();
    }
    isExportDefaultSpecifier() {
      let {
        type: t
      } = this.state;
      if (ke(t)) {
        if (t === 95 && !this.state.containsEsc || t === 100)
          return !1;
        if ((t === 130 || t === 129) && !this.state.containsEsc) {
          let n = this.nextTokenStart(), a = this.input.charCodeAt(n);
          if (a === 123 || this.chStartsBindingIdentifier(a, n) && !this.input.startsWith("from", n))
            return this.expectOnePlugin(["flow", "typescript"]), !1;
        }
      } else if (!this.match(65))
        return !1;
      let r = this.nextTokenStart(), s = this.isUnparsedContextual(r, "from");
      if (this.input.charCodeAt(r) === 44 || ke(this.state.type) && s)
        return !0;
      if (this.match(65) && s) {
        let n = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
        return n === 34 || n === 39;
      }
      return !1;
    }
    parseExportFrom(t, r) {
      this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(
      t)) : r && this.unexpected(), this.semicolon();
    }
    shouldParseExportDeclaration() {
      let {
        type: t
      } = this.state;
      return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("\
decorators", "decoratorsBeforeExport") === !0 && this.raise(O.DecoratorBeforeExport, this.state.startLoc), !0) : this.isUsing() ? (this.raise(
      O.UsingDeclarationExport, this.state.startLoc), !0) : this.isAwaitUsing() ? (this.raise(O.UsingDeclarationExport, this.state.startLoc),
      !0) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
    }
    checkExport(t, r, s, n) {
      if (r) {
        var a;
        if (s) {
          if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
            var o;
            let l = t.declaration;
            l.type === "Identifier" && l.name === "from" && l.end - l.start === 4 && !((o = l.extra) != null && o.parenthesized) && this.raise(
            O.ExportDefaultFromAsIdentifier, l);
          }
        } else if ((a = t.specifiers) != null && a.length)
          for (let l of t.specifiers) {
            let {
              exported: u
            } = l, c = u.type === "Identifier" ? u.name : u.value;
            if (this.checkDuplicateExports(l, c), !n && l.local) {
              let {
                local: p
              } = l;
              p.type !== "Identifier" ? this.raise(O.ExportBindingIsString, l, {
                localName: p.value,
                exportName: c
              }) : (this.checkReservedWord(p.name, p.loc.start, !0, !1), this.scope.checkLocalExport(p));
            }
          }
        else if (t.declaration) {
          let l = t.declaration;
          if (l.type === "FunctionDeclaration" || l.type === "ClassDeclaration") {
            let {
              id: u
            } = l;
            if (!u) throw new Error("Assertion failure");
            this.checkDuplicateExports(t, u.name);
          } else if (l.type === "VariableDeclaration")
            for (let u of l.declarations)
              this.checkDeclaration(u.id);
        }
      }
    }
    checkDeclaration(t) {
      if (t.type === "Identifier")
        this.checkDuplicateExports(t, t.name);
      else if (t.type === "ObjectPattern")
        for (let r of t.properties)
          this.checkDeclaration(r);
      else if (t.type === "ArrayPattern")
        for (let r of t.elements)
          r && this.checkDeclaration(r);
      else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type ===
      "AssignmentPattern" && this.checkDeclaration(t.left);
    }
    checkDuplicateExports(t, r) {
      this.exportedIdentifiers.has(r) && (r === "default" ? this.raise(O.DuplicateDefaultExport, t) : this.raise(O.DuplicateExport, t, {
        exportName: r
      })), this.exportedIdentifiers.add(r);
    }
    parseExportSpecifiers(t) {
      let r = [], s = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (s)
          s = !1;
        else if (this.expect(12), this.eat(8)) break;
        let n = this.isContextual(130), a = this.match(134), o = this.startNode();
        o.local = this.parseModuleExportName(), r.push(this.parseExportSpecifier(o, a, t, n));
      }
      return r;
    }
    parseExportSpecifier(t, r, s, n) {
      return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : r ? t.exported = this.cloneStringLiteral(t.local) : t.exported ||
      (t.exported = this.cloneIdentifier(t.local)), this.finishNode(t, "ExportSpecifier");
    }
    parseModuleExportName() {
      if (this.match(134)) {
        let t = this.parseStringLiteral(this.state.value), r = OH.exec(t.value);
        return r && this.raise(O.ModuleExportNameHasLoneSurrogate, t, {
          surrogateCharCode: r[0].charCodeAt(0)
        }), t;
      }
      return this.parseIdentifier(!0);
    }
    isJSONModuleImport(t) {
      return t.assertions != null ? t.assertions.some(({
        key: r,
        value: s
      }) => s.value === "json" && (r.type === "Identifier" ? r.name === "type" : r.value === "type")) : !1;
    }
    checkImportReflection(t) {
      let {
        specifiers: r
      } = t, s = r.length === 1 ? r[0].type : null;
      if (t.phase === "source")
        s !== "ImportDefaultSpecifier" && this.raise(O.SourcePhaseImportRequiresDefault, r[0].loc.start);
      else if (t.phase === "defer")
        s !== "ImportNamespaceSpecifier" && this.raise(O.DeferImportRequiresNamespace, r[0].loc.start);
      else if (t.module) {
        var n;
        s !== "ImportDefaultSpecifier" && this.raise(O.ImportReflectionNotBinding, r[0].loc.start), ((n = t.assertions) == null ? void 0 : n.
        length) > 0 && this.raise(O.ImportReflectionHasAssertion, r[0].loc.start);
      }
    }
    checkJSONModuleImport(t) {
      if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
        let {
          specifiers: r
        } = t;
        if (r != null) {
          let s = r.find((n) => {
            let a;
            if (n.type === "ExportSpecifier" ? a = n.local : n.type === "ImportSpecifier" && (a = n.imported), a !== void 0)
              return a.type === "Identifier" ? a.name !== "default" : a.value !== "default";
          });
          s !== void 0 && this.raise(O.ImportJSONBindingNotDefault, s.loc.start);
        }
      }
    }
    isPotentialImportPhase(t) {
      return t ? !1 : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
    }
    applyImportPhase(t, r, s, n) {
      r || (s === "module" ? (this.expectPlugin("importReflection", n), t.module = !0) : this.hasPlugin("importReflection") && (t.module = !1),
      s === "source" ? (this.expectPlugin("sourcePhaseImports", n), t.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImport\
Evaluation", n), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
    }
    parseMaybeImportPhase(t, r) {
      if (!this.isPotentialImportPhase(r))
        return this.applyImportPhase(t, r, null), null;
      let s = this.startNode(), n = this.parseIdentifierName(!0), {
        type: a
      } = this.state;
      return (Fr(a) ? a !== 98 || this.lookaheadCharCode() === 102 : a !== 12) ? (this.applyImportPhase(t, r, n, s.loc.start), null) : (this.
      applyImportPhase(t, r, null), this.createIdentifier(s, n));
    }
    isPrecedingIdImportPhase(t) {
      let {
        type: r
      } = this.state;
      return ke(r) ? r !== 98 || this.lookaheadCharCode() === 102 : r !== 12;
    }
    parseImport(t) {
      return this.match(134) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, !1));
    }
    parseImportSpecifiersAndAfter(t, r) {
      t.specifiers = [];
      let n = !this.maybeParseDefaultImportSpecifier(t, r) || this.eat(12), a = n && this.maybeParseStarImportSpecifier(t);
      return n && !a && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
    }
    parseImportSourceAndAttributes(t) {
      var r;
      return (r = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.
      checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.sawUnambiguousESM = !0, this.finishNode(t, "ImportDecl\
aration");
    }
    parseImportSource() {
      return this.match(134) || this.unexpected(), this.parseExprAtom();
    }
    parseImportSpecifierLocal(t, r, s) {
      r.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(r, s));
    }
    finishImportSpecifier(t, r, s = 8201) {
      return this.checkLVal(t.local, {
        type: r
      }, s), this.finishNode(t, r);
    }
    parseImportAttributes() {
      this.expect(5);
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        if (this.match(8))
          break;
        let s = this.startNode(), n = this.state.value;
        if (r.has(n) && this.raise(O.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
          key: n
        }), r.add(n), this.match(134) ? s.key = this.parseStringLiteral(n) : s.key = this.parseIdentifier(!0), this.expect(14), !this.match(
        134))
          throw this.raise(O.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return this.expect(8), t;
    }
    parseModuleAttributes() {
      let t = [], r = /* @__PURE__ */ new Set();
      do {
        let s = this.startNode();
        if (s.key = this.parseIdentifier(!0), s.key.name !== "type" && this.raise(O.ModuleAttributeDifferentFromType, s.key), r.has(s.key.name) &&
        this.raise(O.ModuleAttributesWithDuplicateKeys, s.key, {
          key: s.key.name
        }), r.add(s.key.name), this.expect(14), !this.match(134))
          throw this.raise(O.ModuleAttributeInvalidValue, this.state.startLoc);
        s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
      } while (this.eat(12));
      return t;
    }
    maybeParseImportAttributes(t) {
      let r;
      var s = !1;
      if (this.match(76)) {
        if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40)
          return;
        this.next(), this.hasPlugin("moduleAttributes") ? (r = this.parseModuleAttributes(), this.addExtra(t, "deprecatedWithLegacySyntax", !0)) :
        r = this.parseImportAttributes(), s = !0;
      } else this.isContextual(94) && !this.hasPrecedingLineBreak() ? (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importA\
ssertions") && this.raise(O.ImportAttributesUseAssert, this.state.startLoc), this.hasPlugin("importAssertions") || this.addExtra(t, "depreca\
tedAssertSyntax", !0), this.next(), r = this.parseImportAttributes()) : r = [];
      !s && this.hasPlugin("importAssertions") ? t.assertions = r : t.attributes = r;
    }
    maybeParseDefaultImportSpecifier(t, r) {
      if (r) {
        let s = this.startNodeAtNode(r);
        return s.local = r, t.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), !0;
      } else if (Fr(this.state.type))
        return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), !0;
      return !1;
    }
    maybeParseStarImportSpecifier(t) {
      if (this.match(55)) {
        let r = this.startNode();
        return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, r, "ImportNamespaceSpecifier"), !0;
      }
      return !1;
    }
    parseNamedImportSpecifiers(t) {
      let r = !0;
      for (this.expect(5); !this.eat(8); ) {
        if (r)
          r = !1;
        else {
          if (this.eat(14))
            throw this.raise(O.DestructureNamedImport, this.state.startLoc);
          if (this.expect(12), this.eat(8)) break;
        }
        let s = this.startNode(), n = this.match(134), a = this.isContextual(130);
        s.imported = this.parseModuleExportName();
        let o = this.parseImportSpecifier(s, n, t.importKind === "type" || t.importKind === "typeof", a, void 0);
        t.specifiers.push(o);
      }
    }
    parseImportSpecifier(t, r, s, n, a) {
      if (this.eatContextual(93))
        t.local = this.parseIdentifier();
      else {
        let {
          imported: o
        } = t;
        if (r)
          throw this.raise(O.ImportBindingIsString, t, {
            importName: o.value
          });
        this.checkReservedWord(o.name, t.loc.start, !0, !0), t.local || (t.local = this.cloneIdentifier(o));
      }
      return this.finishImportSpecifier(t, "ImportSpecifier", a);
    }
    isThisParam(t) {
      return t.type === "Identifier" && t.name === "this";
    }
  }, Hl = class extends q0 {
    static {
      i(this, "Parser");
    }
    constructor(t, r, s) {
      let n = IY(t);
      super(n, r), this.options = n, this.initializeScopes(), this.plugins = s, this.filename = n.sourceFilename, this.startIndex = n.startIndex;
      let a = 0;
      n.allowAwaitOutsideFunction && (a |= 1), n.allowReturnOutsideFunction && (a |= 2), n.allowImportExportEverywhere && (a |= 8), n.allowSuperOutsideMethod &&
      (a |= 16), n.allowUndeclaredExports && (a |= 64), n.allowNewTargetOutsideFunction && (a |= 4), n.allowYieldOutsideFunction && (a |= 32),
      n.ranges && (a |= 128), n.tokens && (a |= 256), n.createImportExpressions && (a |= 512), n.createParenthesizedExpressions && (a |= 1024),
      n.errorRecovery && (a |= 2048), n.attachComment && (a |= 4096), n.annexB && (a |= 8192), this.optionFlags = a;
    }
    getScopeHandler() {
      return Ga;
    }
    parse() {
      this.enterInitialScopes();
      let t = this.startNode(), r = this.startNode();
      this.nextToken(), t.errors = null;
      let s = this.parseTopLevel(t, r);
      return s.errors = this.state.errors, s.comments.length = this.state.commentsLen, s;
    }
  };
  function BH(e, t) {
    var r;
    if (((r = t) == null ? void 0 : r.sourceType) === "unambiguous") {
      t = Object.assign({}, t);
      try {
        t.sourceType = "module";
        let s = Ya(t, e), n = s.parse();
        if (s.sawUnambiguousESM)
          return n;
        if (s.ambiguousScriptDifferentAst)
          try {
            return t.sourceType = "script", Ya(t, e).parse();
          } catch {
          }
        else
          n.program.sourceType = "script";
        return n;
      } catch (s) {
        try {
          return t.sourceType = "script", Ya(t, e).parse();
        } catch {
        }
        throw s;
      }
    } else
      return Ya(t, e).parse();
  }
  i(BH, "parse");
  function kH(e, t) {
    let r = Ya(t, e);
    return r.options.strictMode && (r.state.strict = !0), r.getExpression();
  }
  i(kH, "parseExpression");
  function FH(e) {
    let t = {};
    for (let r of Object.keys(e))
      t[r] = bs(e[r]);
    return t;
  }
  i(FH, "generateExportedTokenTypes");
  var LH = FH(kY);
  function Ya(e, t) {
    let r = Hl, s = /* @__PURE__ */ new Map();
    if (e != null && e.plugins) {
      for (let n of e.plugins) {
        let a, o;
        typeof n == "string" ? a = n : [a, o] = n, s.has(a) || s.set(a, o || {});
      }
      DH(s), r = jH(s);
    }
    return new r(e, t, s);
  }
  i(Ya, "getParser");
  var fx = /* @__PURE__ */ new Map();
  function jH(e) {
    let t = [];
    for (let n of _H)
      e.has(n) && t.push(n);
    let r = t.join("|"), s = fx.get(r);
    if (!s) {
      s = Hl;
      for (let n of t)
        s = Cx[n](s);
      fx.set(r, s);
    }
    return s;
  }
  i(jH, "getParserClass");
  za.parse = BH;
  za.parseExpression = kH;
  za.tokTypes = LH;
});

// ../node_modules/picocolors/picocolors.js
var _x = D((x4e, X0) => {
  var Gl = process || {}, wx = Gl.argv || [], Jl = Gl.env || {}, MH = !(Jl.NO_COLOR || wx.includes("--no-color")) && (!!Jl.FORCE_COLOR || wx.
  includes("--color") || Gl.platform === "win32" || (Gl.stdout || {}).isTTY && Jl.TERM !== "dumb" || !!Jl.CI), RH = /* @__PURE__ */ i((e, t, r = e) => (s) => {
    let n = "" + s, a = n.indexOf(t, e.length);
    return ~a ? e + qH(n, t, r, a) + t : e + n + t;
  }, "formatter"), qH = /* @__PURE__ */ i((e, t, r, s) => {
    let n = "", a = 0;
    do
      n += e.substring(a, s) + r, a = s + t.length, s = e.indexOf(t, a);
    while (~s);
    return n + e.substring(a);
  }, "replaceClose"), Dx = /* @__PURE__ */ i((e = MH) => {
    let t = e ? RH : () => String;
    return {
      isColorSupported: e,
      reset: t("\x1B[0m", "\x1B[0m"),
      bold: t("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: t("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: t("\x1B[3m", "\x1B[23m"),
      underline: t("\x1B[4m", "\x1B[24m"),
      inverse: t("\x1B[7m", "\x1B[27m"),
      hidden: t("\x1B[8m", "\x1B[28m"),
      strikethrough: t("\x1B[9m", "\x1B[29m"),
      black: t("\x1B[30m", "\x1B[39m"),
      red: t("\x1B[31m", "\x1B[39m"),
      green: t("\x1B[32m", "\x1B[39m"),
      yellow: t("\x1B[33m", "\x1B[39m"),
      blue: t("\x1B[34m", "\x1B[39m"),
      magenta: t("\x1B[35m", "\x1B[39m"),
      cyan: t("\x1B[36m", "\x1B[39m"),
      white: t("\x1B[37m", "\x1B[39m"),
      gray: t("\x1B[90m", "\x1B[39m"),
      bgBlack: t("\x1B[40m", "\x1B[49m"),
      bgRed: t("\x1B[41m", "\x1B[49m"),
      bgGreen: t("\x1B[42m", "\x1B[49m"),
      bgYellow: t("\x1B[43m", "\x1B[49m"),
      bgBlue: t("\x1B[44m", "\x1B[49m"),
      bgMagenta: t("\x1B[45m", "\x1B[49m"),
      bgCyan: t("\x1B[46m", "\x1B[49m"),
      bgWhite: t("\x1B[47m", "\x1B[49m"),
      blackBright: t("\x1B[90m", "\x1B[39m"),
      redBright: t("\x1B[91m", "\x1B[39m"),
      greenBright: t("\x1B[92m", "\x1B[39m"),
      yellowBright: t("\x1B[93m", "\x1B[39m"),
      blueBright: t("\x1B[94m", "\x1B[39m"),
      magentaBright: t("\x1B[95m", "\x1B[39m"),
      cyanBright: t("\x1B[96m", "\x1B[39m"),
      whiteBright: t("\x1B[97m", "\x1B[39m"),
      bgBlackBright: t("\x1B[100m", "\x1B[49m"),
      bgRedBright: t("\x1B[101m", "\x1B[49m"),
      bgGreenBright: t("\x1B[102m", "\x1B[49m"),
      bgYellowBright: t("\x1B[103m", "\x1B[49m"),
      bgBlueBright: t("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: t("\x1B[105m", "\x1B[49m"),
      bgCyanBright: t("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: t("\x1B[107m", "\x1B[49m")
    };
  }, "createColors");
  X0.exports = Dx();
  X0.exports.createColors = Dx;
});

// ../node_modules/js-tokens/index.js
var Ix = D((Xl) => {
  Object.defineProperty(Xl, "__esModule", {
    value: !0
  });
  Xl.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
  Xl.matchToToken = function(e) {
    var t = { type: "invalid", value: e[0], closed: void 0 };
    return e[1] ? (t.type = "string", t.closed = !!(e[3] || e[4])) : e[5] ? t.type = "comment" : e[6] ? (t.type = "comment", t.closed = !!e[7]) :
    e[8] ? t.type = "regex" : e[9] ? t.type = "number" : e[10] ? t.type = "name" : e[11] ? t.type = "punctuator" : e[12] && (t.type = "white\
space"), t;
  };
});

// ../node_modules/@babel/code-frame/lib/index.js
var Za = D((Qa) => {
  "use strict";
  Object.defineProperty(Qa, "__esModule", { value: !0 });
  var z0 = _x(), Ox = Ix(), Nx = bi();
  function UH() {
    return typeof process == "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? !1 : z0.isColorSupported;
  }
  i(UH, "isColorSupported");
  var zl = /* @__PURE__ */ i((e, t) => (r) => e(t(r)), "compose");
  function Fx(e) {
    return {
      keyword: e.cyan,
      capitalized: e.yellow,
      jsxIdentifier: e.yellow,
      punctuator: e.yellow,
      number: e.magenta,
      string: e.green,
      regex: e.magenta,
      comment: e.gray,
      invalid: zl(zl(e.white, e.bgRed), e.bold),
      gutter: e.gray,
      marker: zl(e.red, e.bold),
      message: zl(e.red, e.bold),
      reset: e.reset
    };
  }
  i(Fx, "buildDefs");
  var $H = Fx(z0.createColors(!0)), VH = Fx(z0.createColors(!1));
  function Lx(e) {
    return e ? $H : VH;
  }
  i(Lx, "getDefs");
  var KH = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]), WH = /\r\n|[\n\r\u2028\u2029]/, YH = /^[()[\]{}]$/, jx;
  {
    let e = /^[a-z][\w-]*$/i, t = /* @__PURE__ */ i(function(r, s, n) {
      if (r.type === "name") {
        if (Nx.isKeyword(r.value) || Nx.isStrictReservedWord(r.value, !0) || KH.has(r.value))
          return "keyword";
        if (e.test(r.value) && (n[s - 1] === "<" || n.slice(s - 2, s) === "</"))
          return "jsxIdentifier";
        if (r.value[0] !== r.value[0].toLowerCase())
          return "capitalized";
      }
      return r.type === "punctuator" && YH.test(r.value) ? "bracket" : r.type === "invalid" && (r.value === "@" || r.value === "#") ? "punct\
uator" : r.type;
    }, "getTokenType");
    jx = /* @__PURE__ */ i(function* (r) {
      let s;
      for (; s = Ox.default.exec(r); ) {
        let n = Ox.matchToToken(s);
        yield {
          type: t(n, s.index, r),
          value: n.value
        };
      }
    }, "tokenize");
  }
  function Mx(e) {
    if (e === "") return "";
    let t = Lx(!0), r = "";
    for (let {
      type: s,
      value: n
    } of jx(e))
      s in t ? r += n.split(WH).map((a) => t[s](a)).join(`
`) : r += n;
    return r;
  }
  i(Mx, "highlight");
  var Bx = !1, kx = /\r\n|[\n\r\u2028\u2029]/;
  function HH(e, t, r) {
    let s = Object.assign({
      column: 0,
      line: -1
    }, e.start), n = Object.assign({}, s, e.end), {
      linesAbove: a = 2,
      linesBelow: o = 3
    } = r || {}, l = s.line, u = s.column, c = n.line, p = n.column, f = Math.max(l - (a + 1), 0), h = Math.min(t.length, c + o);
    l === -1 && (f = 0), c === -1 && (h = t.length);
    let b = c - l, T = {};
    if (b)
      for (let d = 0; d <= b; d++) {
        let g = d + l;
        if (!u)
          T[g] = !0;
        else if (d === 0) {
          let E = t[g - 1].length;
          T[g] = [u, E - u + 1];
        } else if (d === b)
          T[g] = [0, p];
        else {
          let E = t[g - d].length;
          T[g] = [0, E];
        }
      }
    else
      u === p ? u ? T[l] = [u, 0] : T[l] = !0 : T[l] = [u, p - u];
    return {
      start: f,
      end: h,
      markerLines: T
    };
  }
  i(HH, "getMarkerLines");
  function Rx(e, t, r = {}) {
    let s = r.forceColor || UH() && r.highlightCode, n = Lx(s), a = e.split(kx), {
      start: o,
      end: l,
      markerLines: u
    } = HH(t, a, r), c = t.start && typeof t.start.column == "number", p = String(l).length, h = (s ? Mx(e) : e).split(kx, l).slice(o, l).map(
    (b, T) => {
      let d = o + 1 + T, E = ` ${` ${d}`.slice(-p)} |`, _ = u[d], N = !u[d + 1];
      if (_) {
        let k = "";
        if (Array.isArray(_)) {
          let j = b.slice(0, Math.max(_[0] - 1, 0)).replace(/[^\t]/g, " "), U = _[1] || 1;
          k = [`
 `, n.gutter(E.replace(/\d/g, " ")), " ", j, n.marker("^").repeat(U)].join(""), N && r.message && (k += " " + n.message(r.message));
        }
        return [n.marker(">"), n.gutter(E), b.length > 0 ? ` ${b}` : "", k].join("");
      } else
        return ` ${n.gutter(E)}${b.length > 0 ? ` ${b}` : ""}`;
    }).join(`
`);
    return r.message && !c && (h = `${" ".repeat(p + 1)}${r.message}
${h}`), s ? n.reset(h) : h;
  }
  i(Rx, "codeFrameColumns");
  function JH(e, t, r, s = {}) {
    if (!Bx) {
      Bx = !0;
      let a = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning)
        process.emitWarning(a, "DeprecationWarning");
      else {
        let o = new Error(a);
        o.name = "DeprecationWarning", console.warn(new Error(a));
      }
    }
    return r = Math.max(r, 0), Rx(e, {
      start: {
        column: r,
        line: t
      }
    }, s);
  }
  i(JH, "index");
  Qa.codeFrameColumns = Rx;
  Qa.default = JH;
  Qa.highlight = Mx;
});

// ../node_modules/@babel/template/lib/parse.js
var Z0 = D((Q0) => {
  "use strict";
  Object.defineProperty(Q0, "__esModule", {
    value: !0
  });
  Q0.default = lJ;
  var GH = ce(), XH = Bn(), zH = Za(), {
    isCallExpression: QH,
    isExpressionStatement: ZH,
    isFunction: eJ,
    isIdentifier: tJ,
    isJSXIdentifier: rJ,
    isNewExpression: sJ,
    isPlaceholder: Ql,
    isStatement: nJ,
    isStringLiteral: qx,
    removePropertiesDeep: iJ,
    traverse: aJ
  } = GH, oJ = /^[_$A-Z0-9]+$/;
  function lJ(e, t, r) {
    let {
      placeholderWhitelist: s,
      placeholderPattern: n,
      preserveComments: a,
      syntacticPlaceholders: o
    } = r, l = pJ(t, r.parser, o);
    iJ(l, {
      preserveComments: a
    }), e.validate(l);
    let u = {
      syntactic: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      legacy: {
        placeholders: [],
        placeholderNames: /* @__PURE__ */ new Set()
      },
      placeholderWhitelist: s,
      placeholderPattern: n,
      syntacticPlaceholders: o
    };
    return aJ(l, uJ, u), Object.assign({
      ast: l
    }, u.syntactic.placeholders.length ? u.syntactic : u.legacy);
  }
  i(lJ, "parseAndBuildMetadata");
  function uJ(e, t, r) {
    var s;
    let n, a = r.syntactic.placeholders.length > 0;
    if (Ql(e)) {
      if (r.syntacticPlaceholders === !1)
        throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
      n = e.name.name, a = !0;
    } else {
      if (a || r.syntacticPlaceholders)
        return;
      if (tJ(e) || rJ(e))
        n = e.name;
      else if (qx(e))
        n = e.value;
      else
        return;
    }
    if (a && (r.placeholderPattern != null || r.placeholderWhitelist != null))
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
    if (!a && (r.placeholderPattern === !1 || !(r.placeholderPattern || oJ).test(n)) && !((s = r.placeholderWhitelist) != null && s.has(n)))
      return;
    t = t.slice();
    let {
      node: o,
      key: l
    } = t[t.length - 1], u;
    qx(e) || Ql(e, {
      expectedNode: "StringLiteral"
    }) ? u = "string" : sJ(o) && l === "arguments" || QH(o) && l === "arguments" || eJ(o) && l === "params" ? u = "param" : ZH(o) && !Ql(e) ?
    (u = "statement", t = t.slice(0, -1)) : nJ(e) && Ql(e) ? u = "statement" : u = "other";
    let {
      placeholders: c,
      placeholderNames: p
    } = a ? r.syntactic : r.legacy;
    c.push({
      name: n,
      type: u,
      resolve: /* @__PURE__ */ i((f) => cJ(f, t), "resolve"),
      isDuplicate: p.has(n)
    }), p.add(n);
  }
  i(uJ, "placeholderVisitorHandler");
  function cJ(e, t) {
    let r = e;
    for (let a = 0; a < t.length - 1; a++) {
      let {
        key: o,
        index: l
      } = t[a];
      l === void 0 ? r = r[o] : r = r[o][l];
    }
    let {
      key: s,
      index: n
    } = t[t.length - 1];
    return {
      parent: r,
      key: s,
      index: n
    };
  }
  i(cJ, "resolveAncestors");
  function pJ(e, t, r) {
    let s = (t.plugins || []).slice();
    r !== !1 && s.push("placeholders"), t = Object.assign({
      allowAwaitOutsideFunction: !0,
      allowReturnOutsideFunction: !0,
      allowNewTargetOutsideFunction: !0,
      allowSuperOutsideMethod: !0,
      allowYieldOutsideFunction: !0,
      sourceType: "module"
    }, t, {
      plugins: s
    });
    try {
      return (0, XH.parse)(e, t);
    } catch (n) {
      let a = n.loc;
      throw a && (n.message += `
` + (0, zH.codeFrameColumns)(e, {
        start: a
      }), n.code = "BABEL_TEMPLATE_PARSE_ERROR"), n;
    }
  }
  i(pJ, "parseWithCodeFrame");
});

// ../node_modules/@babel/template/lib/populate.js
var sh = D((rh) => {
  "use strict";
  Object.defineProperty(rh, "__esModule", {
    value: !0
  });
  rh.default = bJ;
  var fJ = ce(), {
    blockStatement: dJ,
    cloneNode: th,
    emptyStatement: hJ,
    expressionStatement: eh,
    identifier: Zl,
    isStatement: Ux,
    isStringLiteral: mJ,
    stringLiteral: yJ,
    validate: $x
  } = fJ;
  function bJ(e, t) {
    let r = th(e.ast);
    return t && (e.placeholders.forEach((s) => {
      if (!hasOwnProperty.call(t, s.name)) {
        let n = s.name;
        throw new Error(`Error: No substitution given for "${n}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${n}'])}
            - { placeholderPattern: /^${n}$/ }`);
      }
    }), Object.keys(t).forEach((s) => {
      if (!e.placeholderNames.has(s))
        throw new Error(`Unknown substitution "${s}" given`);
    })), e.placeholders.slice().reverse().forEach((s) => {
      try {
        var n;
        gJ(s, r, (n = t && t[s.name]) != null ? n : null);
      } catch (a) {
        throw a.message = `@babel/template placeholder "${s.name}": ${a.message}`, a;
      }
    }), r;
  }
  i(bJ, "populatePlaceholders");
  function gJ(e, t, r) {
    e.isDuplicate && (Array.isArray(r) ? r = r.map((l) => th(l)) : typeof r == "object" && (r = th(r)));
    let {
      parent: s,
      key: n,
      index: a
    } = e.resolve(t);
    if (e.type === "string") {
      if (typeof r == "string" && (r = yJ(r)), !r || !mJ(r))
        throw new Error("Expected string substitution");
    } else if (e.type === "statement")
      a === void 0 ? r ? Array.isArray(r) ? r = dJ(r) : typeof r == "string" ? r = eh(Zl(r)) : Ux(r) || (r = eh(r)) : r = hJ() : r && !Array.
      isArray(r) && (typeof r == "string" && (r = Zl(r)), Ux(r) || (r = eh(r)));
    else if (e.type === "param") {
      if (typeof r == "string" && (r = Zl(r)), a === void 0) throw new Error("Assertion failure.");
    } else if (typeof r == "string" && (r = Zl(r)), Array.isArray(r))
      throw new Error("Cannot replace single expression with an array.");
    function o(l, u, c) {
      let p = l[u];
      l[u] = c, (p.type === "Identifier" || p.type === "Placeholder") && (p.typeAnnotation && (c.typeAnnotation = p.typeAnnotation), p.optional &&
      (c.optional = p.optional), p.decorators && (c.decorators = p.decorators));
    }
    if (i(o, "set"), a === void 0)
      $x(s, n, r), o(s, n, r);
    else {
      let l = s[n].slice();
      e.type === "statement" || e.type === "param" ? r == null ? l.splice(a, 1) : Array.isArray(r) ? l.splice(a, 1, ...r) : o(l, a, r) : o(l,
      a, r), $x(s, n, l), s[n] = l;
    }
  }
  i(gJ, "applyReplacement");
});

// ../node_modules/@babel/template/lib/string.js
var Vx = D((nh) => {
  "use strict";
  Object.defineProperty(nh, "__esModule", {
    value: !0
  });
  nh.default = SJ;
  var TJ = Ml(), xJ = Z0(), EJ = sh();
  function SJ(e, t, r) {
    t = e.code(t);
    let s;
    return (n) => {
      let a = (0, TJ.normalizeReplacements)(n);
      return s || (s = (0, xJ.default)(e, t, r)), e.unwrap((0, EJ.default)(s, a));
    };
  }
  i(SJ, "stringTemplate");
});

// ../node_modules/@babel/template/lib/literal.js
var Kx = D((ih) => {
  "use strict";
  Object.defineProperty(ih, "__esModule", {
    value: !0
  });
  ih.default = CJ;
  var vJ = Ml(), PJ = Z0(), AJ = sh();
  function CJ(e, t, r) {
    let {
      metadata: s,
      names: n
    } = wJ(e, t, r);
    return (a) => {
      let o = {};
      return a.forEach((l, u) => {
        o[n[u]] = l;
      }), (l) => {
        let u = (0, vJ.normalizeReplacements)(l);
        return u && Object.keys(u).forEach((c) => {
          if (hasOwnProperty.call(o, c))
            throw new Error("Unexpected replacement overlap.");
        }), e.unwrap((0, AJ.default)(s, u ? Object.assign(u, o) : o));
      };
    };
  }
  i(CJ, "literalTemplate");
  function wJ(e, t, r) {
    let s = "BABEL_TPL$", n = t.join("");
    do
      s = "$$" + s;
    while (n.includes(s));
    let {
      names: a,
      code: o
    } = DJ(t, s);
    return {
      metadata: (0, PJ.default)(e, e.code(o), {
        parser: r.parser,
        placeholderWhitelist: new Set(a.concat(r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : [])),
        placeholderPattern: r.placeholderPattern,
        preserveComments: r.preserveComments,
        syntacticPlaceholders: r.syntacticPlaceholders
      }),
      names: a
    };
  }
  i(wJ, "buildLiteralData");
  function DJ(e, t) {
    let r = [], s = e[0];
    for (let n = 1; n < e.length; n++) {
      let a = `${t}${n - 1}`;
      r.push(a), s += a + e[n];
    }
    return {
      names: r,
      code: s
    };
  }
  i(DJ, "buildTemplateCode");
});

// ../node_modules/@babel/template/lib/builder.js
var Xx = D((ah) => {
  "use strict";
  Object.defineProperty(ah, "__esModule", {
    value: !0
  });
  ah.default = Gx;
  var as = Ml(), Wx = Vx(), Yx = Kx(), Hx = (0, as.validate)({
    placeholderPattern: !1
  });
  function Gx(e, t) {
    let r = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap(), n = t || (0, as.validate)(null);
    return Object.assign((a, ...o) => {
      if (typeof a == "string") {
        if (o.length > 1) throw new Error("Unexpected extra params.");
        return Jx((0, Wx.default)(e, a, (0, as.merge)(n, (0, as.validate)(o[0]))));
      } else if (Array.isArray(a)) {
        let l = r.get(a);
        return l || (l = (0, Yx.default)(e, a, n), r.set(a, l)), Jx(l(o));
      } else if (typeof a == "object" && a) {
        if (o.length > 0) throw new Error("Unexpected extra params.");
        return Gx(e, (0, as.merge)(n, (0, as.validate)(a)));
      }
      throw new Error(`Unexpected template param ${typeof a}`);
    }, {
      ast: /* @__PURE__ */ i((a, ...o) => {
        if (typeof a == "string") {
          if (o.length > 1) throw new Error("Unexpected extra params.");
          return (0, Wx.default)(e, a, (0, as.merge)((0, as.merge)(n, (0, as.validate)(o[0])), Hx))();
        } else if (Array.isArray(a)) {
          let l = s.get(a);
          return l || (l = (0, Yx.default)(e, a, (0, as.merge)(n, Hx)), s.set(a, l)), l(o)();
        }
        throw new Error(`Unexpected template param ${typeof a}`);
      }, "ast")
    });
  }
  i(Gx, "createTemplateBuilder");
  function Jx(e) {
    let t = "";
    try {
      throw new Error();
    } catch (r) {
      r.stack && (t = r.stack.split(`
`).slice(3).join(`
`));
    }
    return (r) => {
      try {
        return e(r);
      } catch (s) {
        throw s.stack += `
    =============
${t}`, s;
      }
    };
  }
  i(Jx, "extendedTrace");
});

// ../node_modules/@babel/template/lib/index.js
var ro = D((Zt) => {
  "use strict";
  Object.defineProperty(Zt, "__esModule", {
    value: !0
  });
  Zt.statements = Zt.statement = Zt.smart = Zt.program = Zt.expression = Zt.default = void 0;
  var eo = zT(), to = Xx(), oh = Zt.smart = (0, to.default)(eo.smart), _J = Zt.statement = (0, to.default)(eo.statement), IJ = Zt.statements =
  (0, to.default)(eo.statements), OJ = Zt.expression = (0, to.default)(eo.expression), NJ = Zt.program = (0, to.default)(eo.program), F4e = Zt.
  default = Object.assign(oh.bind(void 0), {
    smart: oh,
    statement: _J,
    statements: IJ,
    expression: OJ,
    program: NJ,
    ast: oh.ast
  });
});

// ../node_modules/@babel/helpers/lib/helpers-generated.js
var zx = D((eu) => {
  "use strict";
  Object.defineProperty(eu, "__esModule", {
    value: !0
  });
  eu.default = void 0;
  var BJ = ro();
  function R(e, t, r) {
    return Object.freeze({
      minVersion: e,
      ast: /* @__PURE__ */ i(() => BJ.default.program.ast(t, {
        preserveComments: !0
      }), "ast"),
      metadata: r
    });
  }
  i(R, "helper");
  var kJ = eu.default = {
    __proto__: null,
    OverloadYield: R("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", {
      globals: [],
      locals: {
        _OverloadYield: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_OverloadYield",
      dependencies: {},
      internal: !1
    }),
    applyDecoratedDescriptor: R("7.0.0-beta.0", 'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach(functi\
on(i){a[i]=n[i]}),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().reve\
rse().reduce(function(r,n){return n(i,e,r)||r},a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializ\
er=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}', {
      globals: ["Object"],
      locals: {
        _applyDecoratedDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_applyDecoratedDescriptor",
      dependencies: {},
      internal: !1
    }),
    applyDecs2311: R("7.24.0", 'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Obj\
ect.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length\
;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||\
"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("At\
tempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){retu\
rn function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunction\
Name(function(){return v(this)},r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPropert\
yDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!==(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supporte\
d yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["field\
","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to \
call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"c\
lass decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?functi\
on(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get\
,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.i\
nit,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init\
 properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,\
0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0\
,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n\
.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,\
l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,g\
et c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}', {
      globals: ["Symbol", "Object", "TypeError", "Error"],
      locals: {
        applyDecs2311: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2311",
      dependencies: {
        checkInRHS: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.cons\
equent.body.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.pro\
perties.0.value.callee", "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"],
        toPropertyKey: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.al\
ternate.callee"]
      },
      internal: !1
    }),
    arrayLikeToArray: R("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[\
e];return n}", {
      globals: ["Array"],
      locals: {
        _arrayLikeToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayLikeToArray",
      dependencies: {},
      internal: !1
    }),
    arrayWithHoles: R("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", {
      globals: ["Array"],
      locals: {
        _arrayWithHoles: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayWithHoles",
      dependencies: {},
      internal: !1
    }),
    arrayWithoutHoles: R("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", {
      globals: ["Array"],
      locals: {
        _arrayWithoutHoles: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_arrayWithoutHoles",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.argument.callee"]
      },
      internal: !1
    }),
    assertClassBrand: R("7.24.0", 'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;th\
row new TypeError("Private element is not present on this object")}', {
      globals: ["TypeError"],
      locals: {
        _assertClassBrand: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_assertClassBrand",
      dependencies: {},
      internal: !1
    }),
    assertThisInitialized: R("7.0.0-beta.0", `function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been in\
itialised - super() hasn't been called");return e}`, {
      globals: ["ReferenceError"],
      locals: {
        _assertThisInitialized: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_assertThisInitialized",
      dependencies: {},
      internal: !1
    }),
    asyncGeneratorDelegate: R("7.0.0-beta.0", 'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promis\
e(function(n){n(t[e](r))}),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=functi\
on(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;re\
turn pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}', {
      globals: ["Promise", "Symbol"],
      locals: {
        _asyncGeneratorDelegate: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncGeneratorDelegate",
      dependencies: {
        OverloadYield: ["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"]
      },
      internal: !1
    }),
    asyncIterator: R("7.15.9", 'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.it\
erator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="\
@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation\
(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then(function\
(r){return{value:r,done:n}})}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null\
,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return voi\
d 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.retu\
rn;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}', {
      globals: ["Symbol", "TypeError", "Object", "Promise"],
      locals: {
        _asyncIterator: ["body.0.id"],
        AsyncFromSyncIterator: ["body.1.id", "body.0.body.body.1.body.body.1.consequent.argument.callee", "body.1.body.body.1.argument.expre\
ssions.1.left.object", "body.1.body.body.1.argument.expressions.2.callee", "body.1.body.body.1.argument.expressions.0.left"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncIterator",
      dependencies: {},
      internal: !1
    }),
    asyncToGenerator: R("7.0.0-beta.0", 'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.\
done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise(function(r,\
o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_t\
hrow,"throw",n)}_next(void 0)})}}', {
      globals: ["Promise"],
      locals: {
        asyncGeneratorStep: ["body.0.id", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.c\
allee", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"],
        _asyncToGenerator: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_asyncToGenerator",
      dependencies: {},
      internal: !1
    }),
    awaitAsyncGenerator: R("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", {
      globals: [],
      locals: {
        _awaitAsyncGenerator: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_awaitAsyncGenerator",
      dependencies: {
        OverloadYield: ["body.0.body.body.0.argument.callee"]
      },
      internal: !1
    }),
    callSuper: R("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Ref\
lect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", {
      globals: ["Reflect"],
      locals: {
        _callSuper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_callSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.0.argument.expressions.0.right.callee", "body.0.body.body.0.argument.expressions.1.arguments.1.co\
nsequent.arguments.2.object.callee"],
        isNativeReflectConstruct: ["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"],
        possibleConstructorReturn: ["body.0.body.body.0.argument.expressions.1.callee"]
      },
      internal: !1
    }),
    checkInRHS: R("7.20.5", `function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(n\
ull!==e?typeof e:"null"));return e}`, {
      globals: ["Object", "TypeError"],
      locals: {
        _checkInRHS: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_checkInRHS",
      dependencies: {},
      internal: !1
    }),
    checkPrivateRedeclaration: R("7.14.1", 'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the \
same private elements twice on an object")}', {
      globals: ["TypeError"],
      locals: {
        _checkPrivateRedeclaration: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_checkPrivateRedeclaration",
      dependencies: {},
      internal: !1
    }),
    classCallCheck: R("7.0.0-beta.0", 'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a func\
tion")}', {
      globals: ["TypeError"],
      locals: {
        _classCallCheck: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCallCheck",
      dependencies: {},
      internal: !1
    }),
    classNameTDZError: R("7.0.0-beta.0", `function _classNameTDZError(e){throw new ReferenceError('Class "'+e+'" cannot be referenced in com\
puted property keys.')}`, {
      globals: ["ReferenceError"],
      locals: {
        _classNameTDZError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classNameTDZError",
      dependencies: {},
      internal: !1
    }),
    classPrivateFieldGet2: R("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", {
      globals: [],
      locals: {
        _classPrivateFieldGet2: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldGet2",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
      },
      internal: !1
    }),
    classPrivateFieldInitSpec: R("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", {
      globals: [],
      locals: {
        _classPrivateFieldInitSpec: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldInitSpec",
      dependencies: {
        checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
      },
      internal: !1
    }),
    classPrivateFieldLooseBase: R("7.0.0-beta.0", 'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError(\
"attempted to use private field on non-instance");return e}', {
      globals: ["TypeError"],
      locals: {
        _classPrivateFieldBase: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldBase",
      dependencies: {},
      internal: !1
    }),
    classPrivateFieldLooseKey: R("7.0.0-beta.0", 'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}', {
      globals: [],
      locals: {
        id: ["body.0.declarations.0.id", "body.1.body.body.0.argument.left.left.right.argument", "body.1.body.body.0.argument.left.left.righ\
t.argument"],
        _classPrivateFieldKey: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldKey",
      dependencies: {},
      internal: !1
    }),
    classPrivateFieldSet2: R("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", {
      globals: [],
      locals: {
        _classPrivateFieldSet2: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldSet2",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
      },
      internal: !1
    }),
    classPrivateGetter: R("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", {
      globals: [],
      locals: {
        _classPrivateGetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateGetter",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
      },
      internal: !1
    }),
    classPrivateMethodInitSpec: R("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", {
      globals: [],
      locals: {
        _classPrivateMethodInitSpec: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodInitSpec",
      dependencies: {
        checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
      },
      internal: !1
    }),
    classPrivateSetter: R("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", {
      globals: [],
      locals: {
        _classPrivateSetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateSetter",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
      },
      internal: !1
    }),
    classStaticPrivateMethodGet: R("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", {
      globals: [],
      locals: {
        _classStaticPrivateMethodGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateMethodGet",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
      },
      internal: !1
    }),
    construct: R("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);va\
r o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", {
      globals: ["Reflect"],
      locals: {
        _construct: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_construct",
      dependencies: {
        isNativeReflectConstruct: ["body.0.body.body.0.test.callee"],
        setPrototypeOf: ["body.0.body.body.4.argument.expressions.0.right.callee"]
      },
      internal: !1
    }),
    createClass: R("7.0.0-beta.0", 'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.c\
onfigurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineP\
roperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}', {
      globals: ["Object"],
      locals: {
        _defineProperties: ["body.0.id", "body.1.body.body.0.argument.expressions.0.right.callee", "body.1.body.body.0.argument.expressions.\
1.right.callee"],
        _createClass: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createClass",
      dependencies: {
        toPropertyKey: ["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"]
      },
      internal: !1
    }),
    createForOfIteratorHelper: R("7.9.0", 'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r[\
"@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){\
};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid atte\
mpt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;\
return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||\
t.return()}finally{if(u)throw o}}}}', {
      globals: ["Symbol", "Array", "TypeError"],
      locals: {
        _createForOfIteratorHelper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createForOfIteratorHelper",
      dependencies: {
        unsupportedIterableToArray: ["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"]
      },
      internal: !1
    }),
    createForOfIteratorHelperLoose: R("7.9.0", 'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.ite\
rator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof\
 r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to i\
terate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["Symbol", "Array", "TypeError"],
      locals: {
        _createForOfIteratorHelperLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createForOfIteratorHelperLoose",
      dependencies: {
        unsupportedIterableToArray: ["body.0.body.body.2.test.left.right.right.callee"]
      },
      internal: !1
    }),
    createSuper: R("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var\
 s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,\
e)}}", {
      globals: ["Reflect"],
      locals: {
        _createSuper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee", "body.0.body.body.1.argument.body.body.1.cons\
equent.body.0.declarations.0.init.object.callee"],
        isNativeReflectConstruct: ["body.0.body.body.0.declarations.0.init.callee"],
        possibleConstructorReturn: ["body.0.body.body.1.argument.body.body.2.argument.callee"]
      },
      internal: !1
    }),
    decorate: R("7.1.5", `function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r(function(e\
){o.initializeInstanceElements(e,a.elements)},t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.ini\
tializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e\
};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach(function(t){r.fo\
rEach(function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)},this)},this)},initializeClassElements:function(e,r){var t=e\
.prototype;["method","field"].forEach(function(i){r.forEach(function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){va\
r n="static"===o?e:t;this.defineClassElement(n,r)}},this)},this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){v\
ar i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defi\
neProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach(function(e){this.addElementP\
lacement(e,o)},this),e.forEach(function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.a\
pply(t,r.extras),i.push.apply(i,r.finishers)},this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.appl\
y(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError(\
"Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s\
=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,\
this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r\
);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=thi\
s.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elemen\
ts;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Du\
plicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:\
e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kin\
d&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map(function(e){var r=this.toElementDes\
criptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r},t\
his)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError('An element descriptor\\'s .kind prope\
rty must be either "method" or "field", but a decorator created an element descriptor with .kind "'+r+'"');var t=toPropertyKey(e.key),i=e.pl\
acement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError('An element descriptor\\'s .placement property must be one of "sta\
tic", "prototype" or "own", but a decorator created an element descriptor with .placement "'+i+'"');var o=e.descriptor;this.disallowProperty\
(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProper\
ty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowPrope\
rty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"\
),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableP\
roperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.f\
romElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:fun\
ction(e){var r=e.kind+"";if("class"!==r)throw new TypeError('A class descriptor\\'s .kind property must be "class", but a decorator created a\
 class descriptor with .kind "'+r+'"');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class desc\
riptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallo\
wProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.element\
s),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw n\
ew TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+\
" can't have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.\
value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,\
configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"metho\
d",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"fiel\
d"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.des\
criptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.ke\
y&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descri\
ptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can\
't be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can't be p\
laced on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}r\
eturn r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.va\
lue&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expect\
ed '"+r+"' to be a function");return t}`, {
      globals: ["Object", "TypeError", "Symbol", "ReferenceError"],
      locals: {
        _decorate: ["body.0.id"],
        _getDecoratorsApi: ["body.1.id", "body.0.body.body.0.declarations.0.init.callee", "body.1.body.body.0.expression.left"],
        _createElementDescriptor: ["body.2.id", "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"],
        _coalesceGetterSetter: ["body.3.id", "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"],
        _coalesceClassElements: ["body.4.id", "body.0.body.body.2.declarations.1.init.arguments.0.callee"],
        _hasDecorators: ["body.5.id", "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.\
body.body.0.test.argument.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee", "body.4.body.body.0.body.\
body.1.consequent.consequent.body.0.test.right.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee", "body.4.bo\
dy.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"],
        _isDataDescriptor: ["body.6.id", "body.4.body.body.0.body.body.1.consequent.test.left.callee", "body.4.body.body.0.body.body.1.conse\
quent.test.right.callee"],
        _optionalCallableProperty: ["body.7.id", "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties\
.1.value.callee", "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"]
      },
      exportBindingAssignments: [],
      exportName: "_decorate",
      dependencies: {
        toArray: ["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"],
        toPropertyKey: ["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee", "body.2.body.bo\
dy.0.declarations.1.init.callee"]
      },
      internal: !1
    }),
    defaults: R("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.get\
OwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", {
      globals: ["Object"],
      locals: {
        _defaults: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defaults",
      dependencies: {},
      internal: !1
    }),
    defineAccessor: R("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty\
(r,n,c)}", {
      globals: ["Object"],
      locals: {
        _defineAccessor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineAccessor",
      dependencies: {},
      internal: !1
    }),
    defineProperty: R("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enu\
merable:!0,configurable:!0,writable:!0}):e[r]=t,e}", {
      globals: ["Object"],
      locals: {
        _defineProperty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineProperty",
      dependencies: {
        toPropertyKey: ["body.0.body.body.0.argument.expressions.0.test.left.right.callee"]
      },
      internal: !1
    }),
    extends: R("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.l\
ength;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", {
      globals: ["Object"],
      locals: {
        _extends: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_extends",
      dependencies: {},
      internal: !1
    }),
    get: R("7.0.0-beta.0", 'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=su\
perPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,\
arguments)}', {
      globals: ["Reflect", "Object"],
      locals: {
        _get: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_get",
      dependencies: {
        superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    getPrototypeOf: R("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind()\
:function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", {
      globals: ["Object"],
      locals: {
        _getPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_getPrototypeOf",
      dependencies: {},
      internal: !1
    }),
    identity: R("7.17.0", "function _identity(t){return t}", {
      globals: [],
      locals: {
        _identity: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_identity",
      dependencies: {},
      internal: !1
    }),
    importDeferProxy: R("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=functi\
on(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValu\
e(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:c\
onstValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:const\
Value(!1)})}", {
      globals: ["Proxy", "Reflect"],
      locals: {
        _importDeferProxy: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_importDeferProxy",
      dependencies: {},
      internal: !1
    }),
    inherits: R("7.0.0-beta.0", 'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either\
 be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty\
(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}', {
      globals: ["TypeError", "Object"],
      locals: {
        _inherits: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_inherits",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.1.expression.expressions.2.right.callee"]
      },
      internal: !1
    }),
    inheritsLoose: R("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setProto\
typeOf(t,o)}", {
      globals: ["Object"],
      locals: {
        _inheritsLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_inheritsLoose",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.0.expression.expressions.2.callee"]
      },
      internal: !1
    }),
    initializerDefineProperty: R("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.en\
umerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", {
      globals: ["Object"],
      locals: {
        _initializerDefineProperty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_initializerDefineProperty",
      dependencies: {},
      internal: !1
    }),
    initializerWarningHelper: R("7.0.0-beta.0", 'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Plea\
se ensure that transform-class-properties is enabled and runs after the decorators transform.")}', {
      globals: ["Error"],
      locals: {
        _initializerWarningHelper: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_initializerWarningHelper",
      dependencies: {},
      internal: !1
    }),
    instanceof: R("7.0.0-beta.0", 'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.ha\
sInstance](n):n instanceof e}', {
      globals: ["Symbol"],
      locals: {
        _instanceof: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_instanceof",
      dependencies: {},
      internal: !1
    }),
    interopRequireDefault: R("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", {
      globals: [],
      locals: {
        _interopRequireDefault: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_interopRequireDefault",
      dependencies: {},
      internal: !1
    }),
    interopRequireWildcard: R("7.14.0", 'function _interopRequireWildcard(e,t){if("function"==typeof WeakMap)var r=new WeakMap,n=new WeakMap\
;return(_interopRequireWildcard=function(e,t){if(!t&&e&&e.__esModule)return e;var o,i,f={__proto__:null,default:e};if(null===e||"object"!=ty\
peof e&&"function"!=typeof e)return f;if(o=t?n:r){if(o.has(e))return o.get(e);o.set(e,f)}for(const t in e)"default"!==t&&{}.hasOwnProperty.c\
all(e,t)&&((i=(o=Object.defineProperty)&&Object.getOwnPropertyDescriptor(e,t))&&(i.get||i.set)?o(f,t,i):f[t]=e[t]);return f})(e,t)}', {
      globals: ["WeakMap", "Object"],
      locals: {
        _interopRequireWildcard: ["body.0.id", "body.0.body.body.1.argument.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
      exportName: "_interopRequireWildcard",
      dependencies: {},
      internal: !1
    }),
    isNativeFunction: R("7.0.0-beta.0", 'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}cat\
ch(n){return"function"==typeof t}}', {
      globals: ["Function"],
      locals: {
        _isNativeFunction: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_isNativeFunction",
      dependencies: {},
      internal: !1
    }),
    isNativeReflectConstruct: R("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(B\
oolean,[],function(){}))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", {
      globals: ["Boolean", "Reflect"],
      locals: {
        _isNativeReflectConstruct: ["body.0.id", "body.0.body.body.1.argument.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
      exportName: "_isNativeReflectConstruct",
      dependencies: {},
      internal: !1
    }),
    iterableToArray: R("7.0.0-beta.0", 'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@ite\
rator"])return Array.from(r)}', {
      globals: ["Symbol", "Array"],
      locals: {
        _iterableToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_iterableToArray",
      dependencies: {},
      internal: !1
    }),
    iterableToArrayLimit: R("7.0.0-beta.0", 'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.ite\
rator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f\
=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u\
))return}finally{if(o)throw n}}return a}}', {
      globals: ["Symbol", "Object"],
      locals: {
        _iterableToArrayLimit: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_iterableToArrayLimit",
      dependencies: {},
      internal: !1
    }),
    jsx: R("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="functio\
n"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:vo\
id 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&\
&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}', {
      globals: ["Symbol", "Array"],
      locals: {
        REACT_ELEMENT_TYPE: ["body.0.declarations.0.id", "body.1.body.body.0.expression.left", "body.1.body.body.4.argument.properties.0.val\
ue", "body.1.body.body.0.expression.right.left"],
        _createRawReactElement: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_createRawReactElement",
      dependencies: {},
      internal: !1
    }),
    maybeArrayLike: R("7.9.0", 'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return ar\
rayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}', {
      globals: ["Array"],
      locals: {
        _maybeArrayLike: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_maybeArrayLike",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.body.1.argument.callee"]
      },
      internal: !1
    }),
    newArrowCheck: R("7.0.0-beta.0", 'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}', {
      globals: ["TypeError"],
      locals: {
        _newArrowCheck: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_newArrowCheck",
      dependencies: {},
      internal: !1
    }),
    nonIterableRest: R("7.0.0-beta.0", 'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instanc\
e.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["TypeError"],
      locals: {
        _nonIterableRest: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nonIterableRest",
      dependencies: {},
      internal: !1
    }),
    nonIterableSpread: R("7.0.0-beta.0", 'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance\
.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
      globals: ["TypeError"],
      locals: {
        _nonIterableSpread: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nonIterableSpread",
      dependencies: {},
      internal: !1
    }),
    nullishReceiverError: R("7.22.6", 'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}',
    {
      globals: ["TypeError"],
      locals: {
        _nullishReceiverError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_nullishReceiverError",
      dependencies: {},
      internal: !1
    }),
    objectDestructuringEmpty: R("7.0.0-beta.0", 'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+\
t)}', {
      globals: ["TypeError"],
      locals: {
        _objectDestructuringEmpty: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectDestructuringEmpty",
      dependencies: {},
      internal: !1
    }),
    objectSpread2: R("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbol\
s(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable})),t.push.apply(t,o)}return t}function _objectSpread2\
(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){definePropert\
y(e,r,t[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(fun\
ction(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))})}return e}", {
      globals: ["Object"],
      locals: {
        ownKeys: ["body.0.id", "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee", "body.1.body.body.0.body.body.1.\
expression.alternate.alternate.callee.object.callee"],
        _objectSpread2: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectSpread2",
      dependencies: {
        defineProperty: ["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"]
      },
      internal: !1
    }),
    objectWithoutProperties: R("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutProperties\
Loose(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],-1===t.indexOf(o)&&{}.proper\
tyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}", {
      globals: ["Object"],
      locals: {
        _objectWithoutProperties: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectWithoutProperties",
      dependencies: {
        objectWithoutPropertiesLoose: ["body.0.body.body.1.declarations.2.init.callee"]
      },
      internal: !1
    }),
    objectWithoutPropertiesLoose: R("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r\
)if({}.hasOwnProperty.call(r,n)){if(-1!==e.indexOf(n))continue;t[n]=r[n]}return t}", {
      globals: [],
      locals: {
        _objectWithoutPropertiesLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectWithoutPropertiesLoose",
      dependencies: {},
      internal: !1
    }),
    possibleConstructorReturn: R("7.0.0-beta.0", 'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))\
return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}', {
      globals: ["TypeError"],
      locals: {
        _possibleConstructorReturn: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_possibleConstructorReturn",
      dependencies: {
        assertThisInitialized: ["body.0.body.body.2.argument.callee"]
      },
      internal: !1
    }),
    readOnlyError: R("7.0.0-beta.0", `function _readOnlyError(r){throw new TypeError('"'+r+'" is read-only')}`, {
      globals: ["TypeError"],
      locals: {
        _readOnlyError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_readOnlyError",
      dependencies: {},
      internal: !1
    }),
    regenerator: R("7.27.0", `function _regenerator(){
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/ba\
bel-helpers/LICENSE */
var e,t,r="function"==typeof Symbol?Symbol:{},n=r.iterator||"@@iterator",o=r.toStringTag||"@@toStringTag";function i(r,n,o,i){var c=n&&n.pro\
totype instanceof Generator?n:Generator,u=Object.create(c.prototype);return define(u,"_invoke",function(r,n,o){var i,c,u,f=0,p=o||[],y=!1,G=\
{p:0,n:0,v:e,a:d,f:d.bind(e,4),d:function(t,r){return i=t,c=0,u=e,G.n=r,a}};function d(r,n){for(c=r,u=n,t=0;!y&&f&&!o&&t<p.length;t++){var o\
,i=p[t],d=G.p,l=i[2];r>3?(o=l===n)&&(u=i[(c=i[4])?5:(c=3,3)],i[4]=i[5]=e):i[0]<=d&&((o=r<2&&d<i[1])?(c=0,G.v=n,G.n=i[1]):d<l&&(o=r<3||i[0]>n\
||n>l)&&(i[4]=r,i[5]=n,G.n=l,c=0))}if(o||r>1)return a;throw y=!0,n}return function(o,p,l){if(f>1)throw TypeError("Generator is already runni\
ng");for(y&&1===p&&d(p,l),c=p,u=l;(t=c<2?e:u)||!y;){i||(c?c<3?(c>1&&(G.n=-1),d(c,u)):G.n=u:G.v=u);try{if(f=2,i){if(c||(o="next"),t=i[o]){if(\
!(t=t.call(i,u)))throw TypeError("iterator result is not an object");if(!t.done)return t;u=t.value,c<2&&(c=0)}else 1===c&&(t=i.return)&&t.ca\
ll(i),c<2&&(u=TypeError("The iterator does not provide a '"+o+"' method"),c=1);i=e}else if((t=(y=G.n<0)?u:r.call(n,G))!==a)break}catch(t){i=\
e,c=1,u=t}finally{f=1}}return{value:t,done:y}}}(r,o,i),!0),u}var a={};function Generator(){}function GeneratorFunction(){}function Generator\
FunctionPrototype(){}t=Object.getPrototypeOf;var c=[][n]?t(t([][n]())):(define(t={},n,function(){return this}),t),u=GeneratorFunctionPrototy\
pe.prototype=Generator.prototype=Object.create(c);function f(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,GeneratorFunctionProtot\
ype):(e.__proto__=GeneratorFunctionPrototype,define(e,o,"GeneratorFunction")),e.prototype=Object.create(u),e}return GeneratorFunction.protot\
ype=GeneratorFunctionPrototype,define(u,"constructor",GeneratorFunctionPrototype),define(GeneratorFunctionPrototype,"constructor",GeneratorF\
unction),GeneratorFunction.displayName="GeneratorFunction",define(GeneratorFunctionPrototype,o,"GeneratorFunction"),define(u),define(u,o,"Ge\
nerator"),define(u,n,function(){return this}),define(u,"toString",function(){return"[object Generator]"}),(_regenerator=function(){return{w:\
i,m:f}})()}`, {
      globals: ["Symbol", "Object", "TypeError"],
      locals: {
        _regenerator: ["body.0.id", "body.0.body.body.9.argument.expressions.9.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.9.argument.expressions.9.callee"],
      exportName: "_regenerator",
      dependencies: {
        regeneratorDefine: ["body.0.body.body.1.body.body.1.argument.expressions.0.callee", "body.0.body.body.7.declarations.0.init.alternat\
e.expressions.0.callee", "body.0.body.body.8.body.body.0.argument.expressions.0.alternate.expressions.1.callee", "body.0.body.body.9.argumen\
t.expressions.1.callee", "body.0.body.body.9.argument.expressions.2.callee", "body.0.body.body.9.argument.expressions.4.callee", "body.0.bod\
y.body.9.argument.expressions.5.callee", "body.0.body.body.9.argument.expressions.6.callee", "body.0.body.body.9.argument.expressions.7.call\
ee", "body.0.body.body.9.argument.expressions.8.callee"]
      },
      internal: !1
    }),
    regeneratorAsync: R("7.27.0", "function _regeneratorAsync(n,e,r,t,o){var a=asyncGen(n,e,r,t,o);return a.next().then(function(n){return n\
.done?n.value:a.next()})}", {
      globals: [],
      locals: {
        _regeneratorAsync: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorAsync",
      dependencies: {
        regeneratorAsyncGen: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    regeneratorAsyncGen: R("7.27.0", "function _regeneratorAsyncGen(r,e,t,o,n){return new regeneratorAsyncIterator(regenerator().w(r,e,t,o),\
n||Promise)}", {
      globals: ["Promise"],
      locals: {
        _regeneratorAsyncGen: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorAsyncGen",
      dependencies: {
        regenerator: ["body.0.body.body.0.argument.arguments.0.callee.object.callee"],
        regeneratorAsyncIterator: ["body.0.body.body.0.argument.callee"]
      },
      internal: !1
    }),
    regeneratorAsyncIterator: R("7.27.0", 'function AsyncIterator(t,e){function n(r,o,i,f){try{var c=t[r](o),u=c.value;return u instanceof O\
verloadYield?e.resolve(u.v).then(function(t){n("next",t,i,f)},function(t){n("throw",t,i,f)}):e.resolve(u).then(function(t){c.value=t,i(c)},f\
unction(t){return n("throw",t,i,f)})}catch(t){f(t)}}var r;this.next||(define(AsyncIterator.prototype),define(AsyncIterator.prototype,"functi\
on"==typeof Symbol&&Symbol.asyncIterator||"@asyncIterator",function(){return this})),define(this,"_invoke",function(t,o,i){function f(){retu\
rn new e(function(e,r){n(t,i,e,r)})}return r=r?r.then(f,f):f()},!0)}', {
      globals: ["Symbol"],
      locals: {
        AsyncIterator: ["body.0.id", "body.0.body.body.2.expression.expressions.0.right.expressions.0.arguments.0.object", "body.0.body.body\
.2.expression.expressions.0.right.expressions.1.arguments.0.object"]
      },
      exportBindingAssignments: [],
      exportName: "AsyncIterator",
      dependencies: {
        OverloadYield: ["body.0.body.body.0.body.body.0.block.body.1.argument.test.right"],
        regeneratorDefine: ["body.0.body.body.2.expression.expressions.0.right.expressions.0.callee", "body.0.body.body.2.expression.express\
ions.0.right.expressions.1.callee", "body.0.body.body.2.expression.expressions.1.callee"]
      },
      internal: !0
    }),
    regeneratorDefine: R("7.27.0", 'function regeneratorDefine(e,r,n,t){var i=Object.defineProperty;try{i({},"",{})}catch(e){i=0}regenerator\
Define=function(e,r,n,t){function o(r,n){regeneratorDefine(e,r,function(e){return this._invoke(r,n,e)})}r?i?i(e,r,{value:n,enumerable:!t,con\
figurable:!t,writable:!t}):e[r]=n:(o("next",0),o("throw",1),o("return",2))},regeneratorDefine(e,r,n,t)}', {
      globals: ["Object"],
      locals: {
        regeneratorDefine: ["body.0.id", "body.0.body.body.2.expression.expressions.0.right.body.body.0.body.body.0.expression.callee", "bod\
y.0.body.body.2.expression.expressions.1.callee", "body.0.body.body.2.expression.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.2.expression.expressions.0"],
      exportName: "regeneratorDefine",
      dependencies: {},
      internal: !0
    }),
    regeneratorKeys: R("7.27.0", "function _regeneratorKeys(e){var n=Object(e),r=[];for(var t in n)r.unshift(t);return function e(){for(;r.l\
ength;)if((t=r.pop())in n)return e.value=t,e.done=!1,e;return e.done=!0,e}}", {
      globals: ["Object"],
      locals: {
        _regeneratorKeys: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorKeys",
      dependencies: {},
      internal: !1
    }),
    regeneratorValues: R("7.18.0", 'function _regeneratorValues(e){if(null!=e){var t=e["function"==typeof Symbol&&Symbol.iterator||"@@iterat\
or"],r=0;if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length))return{next:function(){return e&&r>=e.length&&(e=vo\
id 0),{value:e&&e[r++],done:!e}}}}throw new TypeError(typeof e+" is not iterable")}', {
      globals: ["Symbol", "isNaN", "TypeError"],
      locals: {
        _regeneratorValues: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_regeneratorValues",
      dependencies: {},
      internal: !1
    }),
    set: R("7.0.0-beta.0", 'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=\
superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOw\
nPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}f\
unction _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}', {
      globals: ["Reflect", "Object", "TypeError"],
      locals: {
        set: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.0.test.left.argument.callee", "body.0.body.\
body.0.argument.expressions.0.left"],
        _set: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_set",
      dependencies: {
        superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"],
        defineProperty: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"]
      },
      internal: !1
    }),
    setFunctionName: R("7.23.6", 'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.definePr\
operty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}', {
      globals: ["Object"],
      locals: {
        setFunctionName: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "setFunctionName",
      dependencies: {},
      internal: !1
    }),
    setPrototypeOf: R("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind\
():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", {
      globals: ["Object"],
      locals: {
        _setPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_setPrototypeOf",
      dependencies: {},
      internal: !1
    }),
    skipFirstGeneratorNext: R("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.\
next(),r}}", {
      globals: [],
      locals: {
        _skipFirstGeneratorNext: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_skipFirstGeneratorNext",
      dependencies: {},
      internal: !1
    }),
    slicedToArray: R("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableT\
oArray(r,e)||nonIterableRest()}", {
      globals: [],
      locals: {
        _slicedToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_slicedToArray",
      dependencies: {
        arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArrayLimit: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
      },
      internal: !1
    }),
    superPropBase: R("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return \
t}", {
      globals: [],
      locals: {
        _superPropBase: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropBase",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.0.test.right.right.right.callee"]
      },
      internal: !1
    }),
    superPropGet: R("7.25.0", 'function _superPropGet(t,o,e,r){var p=get(getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==type\
of p?function(t){return p.apply(e,t)}:p}', {
      globals: [],
      locals: {
        _superPropGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropGet",
      dependencies: {
        get: ["body.0.body.body.0.declarations.0.init.callee"],
        getPrototypeOf: ["body.0.body.body.0.declarations.0.init.arguments.0.callee"]
      },
      internal: !1
    }),
    superPropSet: R("7.25.0", "function _superPropSet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}", {
      globals: [],
      locals: {
        _superPropSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_superPropSet",
      dependencies: {
        set: ["body.0.body.body.0.argument.callee"],
        getPrototypeOf: ["body.0.body.body.0.argument.arguments.0.callee"]
      },
      internal: !1
    }),
    taggedTemplateLiteral: R("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.definePrope\
rties(e,{raw:{value:Object.freeze(t)}}))}", {
      globals: ["Object"],
      locals: {
        _taggedTemplateLiteral: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_taggedTemplateLiteral",
      dependencies: {},
      internal: !1
    }),
    taggedTemplateLiteralLoose: R("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", {
      globals: [],
      locals: {
        _taggedTemplateLiteralLoose: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_taggedTemplateLiteralLoose",
      dependencies: {},
      internal: !1
    }),
    tdz: R("7.5.5", 'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}', {
      globals: ["ReferenceError"],
      locals: {
        _tdzError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_tdzError",
      dependencies: {},
      internal: !1
    }),
    temporalRef: R("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", {
      globals: [],
      locals: {
        _temporalRef: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_temporalRef",
      dependencies: {
        temporalUndefined: ["body.0.body.body.0.argument.test.right"],
        tdz: ["body.0.body.body.0.argument.consequent.callee"]
      },
      internal: !1
    }),
    temporalUndefined: R("7.0.0-beta.0", "function _temporalUndefined(){}", {
      globals: [],
      locals: {
        _temporalUndefined: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_temporalUndefined",
      dependencies: {},
      internal: !1
    }),
    toArray: R("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterabl\
eRest()}", {
      globals: [],
      locals: {
        _toArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toArray",
      dependencies: {
        arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
      },
      internal: !1
    }),
    toConsumableArray: R("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterabl\
eToArray(r)||nonIterableSpread()}", {
      globals: [],
      locals: {
        _toConsumableArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toConsumableArray",
      dependencies: {
        arrayWithoutHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
        iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
        unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
        nonIterableSpread: ["body.0.body.body.0.argument.right.callee"]
      },
      internal: !1
    }),
    toPrimitive: R("7.1.5", 'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e\
.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r\
?String:Number)(t)}', {
      globals: ["Symbol", "TypeError", "String", "Number"],
      locals: {
        toPrimitive: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "toPrimitive",
      dependencies: {},
      internal: !1
    }),
    toPropertyKey: R("7.1.5", 'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}', {
      globals: [],
      locals: {
        toPropertyKey: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "toPropertyKey",
      dependencies: {
        toPrimitive: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    toSetter: R("7.24.0", 'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,\
t.apply(n,e)}})}', {
      globals: ["Object"],
      locals: {
        _toSetter: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_toSetter",
      dependencies: {},
      internal: !1
    }),
    tsRewriteRelativeImportExtensions: R("7.27.0", 'function tsRewriteRelativeImportExtensions(t,e){return"string"==typeof t&&/^\\.\\.?\\//.tes\
t(t)?t.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+)?)\\.([cm]?)ts$/i,function(t,s,r,n,o){return s?e?".jsx":".js":!r||n&&o?r+n+"."+o.toLowerCase(\
)+"js":t}):t}', {
      globals: [],
      locals: {
        tsRewriteRelativeImportExtensions: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "tsRewriteRelativeImportExtensions",
      dependencies: {},
      internal: !1
    }),
    typeof: R("7.0.0-beta.0", 'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symb\
ol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symb\
ol":typeof o},_typeof(o)}', {
      globals: ["Symbol"],
      locals: {
        _typeof: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
      exportName: "_typeof",
      dependencies: {},
      internal: !1
    }),
    unsupportedIterableToArray: R("7.9.0", 'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,\
a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Argum\
ents"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}', {
      globals: ["Array"],
      locals: {
        _unsupportedIterableToArray: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_unsupportedIterableToArray",
      dependencies: {
        arrayLikeToArray: ["body.0.body.body.0.consequent.body.0.consequent.argument.callee", "body.0.body.body.0.consequent.body.2.argument\
.expressions.1.alternate.consequent.callee"]
      },
      internal: !1
    }),
    usingCtx: R("7.23.9", 'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return \
n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using d\
eclarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispos\
e")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is not\
 disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}\
return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)re\
turn s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}c\
atch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n\
,next()}return next()}}}', {
      globals: ["SuppressedError", "Error", "Object", "TypeError", "Symbol", "Promise"],
      locals: {
        _usingCtx: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_usingCtx",
      dependencies: {},
      internal: !1
    }),
    wrapAsyncGenerator: R("7.0.0-beta.0", 'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,argument\
s))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:\
o).then(function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"norm\
al",t)},function(e){resume("throw",e)})}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0})\
;break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){r\
eturn new Promise(function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))})},"function"!=typeof e.re\
turn&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return th\
is},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke(\
"throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};', {
      globals: ["Promise", "Symbol"],
      locals: {
        _wrapAsyncGenerator: ["body.0.id"],
        AsyncGenerator: ["body.1.id", "body.0.body.body.0.argument.body.body.0.argument.callee", "body.2.expression.expressions.0.left.objec\
t.object", "body.2.expression.expressions.1.left.object.object", "body.2.expression.expressions.2.left.object.object", "body.2.expression.ex\
pressions.3.left.object.object"]
      },
      exportBindingAssignments: [],
      exportName: "_wrapAsyncGenerator",
      dependencies: {
        OverloadYield: ["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"]
      },
      internal: !1
    }),
    wrapNativeSuper: R("7.0.0-beta.0", 'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=fun\
ction(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a f\
unction");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).c\
onstructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setP\
rototypeOf(Wrapper,t)},_wrapNativeSuper(t)}', {
      globals: ["Map", "TypeError", "Object"],
      locals: {
        _wrapNativeSuper: ["body.0.id", "body.0.body.body.1.argument.expressions.1.callee", "body.0.body.body.1.argument.expressions.0.left"]
      },
      exportBindingAssignments: ["body.0.body.body.1.argument.expressions.0"],
      exportName: "_wrapNativeSuper",
      dependencies: {
        getPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"],
        setPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"],
        isNativeFunction: ["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"],
        construct: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"]
      },
      internal: !1
    }),
    wrapRegExp: R("7.19.0", 'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=n\
ew WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildG\
roups(e,t){var p=r.get(t);return Object.keys(p).reduce(function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[\
o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r},Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function\
(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.pro\
totype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)(>|$\
)/g,function(e,r,t){if(""===t)return e;var p=o[r];return Array.isArray(p)?"$"+p.join("$"):"number"==typeof p?"$"+p:""}))}if("function"==type\
of p){var i=this;return e[Symbol.replace].call(this,t,function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).\
push(buildGroups(e,i)),p.apply(this,e)})}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}', {
      globals: ["RegExp", "WeakMap", "Object", "Symbol", "Array"],
      locals: {
        _wrapRegExp: ["body.0.id", "body.0.body.body.4.argument.expressions.3.callee.object", "body.0.body.body.0.expression.left"]
      },
      exportBindingAssignments: ["body.0.body.body.0.expression"],
      exportName: "_wrapRegExp",
      dependencies: {
        setPrototypeOf: ["body.0.body.body.2.body.body.1.argument.expressions.1.callee"],
        inherits: ["body.0.body.body.4.argument.expressions.0.callee"]
      },
      internal: !1
    }),
    writeOnlyError: R("7.12.13", `function _writeOnlyError(r){throw new TypeError('"'+r+'" is write-only')}`, {
      globals: ["TypeError"],
      locals: {
        _writeOnlyError: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_writeOnlyError",
      dependencies: {},
      internal: !1
    })
  };
  Object.assign(kJ, {
    AwaitValue: R("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", {
      globals: [],
      locals: {
        _AwaitValue: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_AwaitValue",
      dependencies: {},
      internal: !1
    }),
    applyDecs: R("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"g\
etMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.pri\
vate;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_a\
ssertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.publ\
ic={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMa\
pToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.len\
gth;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.fro\
m(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadat\
a||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer\
"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;cas\
e 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isSta\
tic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,\
v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function\
(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v\
=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMeta\
dataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("fun\
ction"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!\
==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&o\
ld_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,\
"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError\
((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.ini\
t)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberD\
ec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set\
:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPrope\
rtyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_member\
Dec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f\
=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1\
===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)\
))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length\
;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.v\
alue=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push(function(e,t){return f.get.call(e,t)}),e.push(function(e,t){return f.set.call(e,t)})):\
2===o?e.push(f):e.push(function(e,t){return f.call(e,t)}):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,\
l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&\
&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error(\
"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not current\
ly supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pus\
hInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push(function(e){for(var a=0;a<t.length;a++)t[a].call(e\
);return e})}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Obj\
ect.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,\
c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,function(){for(var e=0;e<o.length;e++)o[e].call(i)})}}function\
 applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r\
,e,o,a),old_convertMetadataMapToFinal(e,o),r}', {
      globals: ["Object", "Map", "Symbol", "Array", "Error", "TypeError", "console"],
      locals: {
        old_createMetadataMethodsForProperty: ["body.0.id", "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee", "body\
.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"],
        old_convertMetadataMapToFinal: ["body.1.id", "body.13.body.body.1.argument.expressions.1.callee", "body.13.body.body.1.argument.expr\
essions.3.callee"],
        old_createAddInitializerMethod: ["body.2.id", "body.3.body.body.3.test.expressions.0.right.right.callee", "body.12.body.body.0.conse\
quent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"],
        old_memberDec: ["body.3.id", "body.9.body.body.1.consequent.expression.left.right.right.callee", "body.9.body.body.1.alternate.body.\
body.1.expression.left.right.right.callee"],
        old_assertNotFinished: ["body.4.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee", "\
body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee", "body.2.body.body.0.argument.body.body.0.expres\
sion.expressions.0.callee"],
        old_assertMetadataKey: ["body.5.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee", "\
body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"],
        old_assertCallable: ["body.6.id", "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee", "body.7.body.body.1.con\
sequent.body.1.expression.expressions.0.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee", "body.7\
.body.body.1.consequent.body.1.expression.expressions.2.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.\
callee"],
        old_assertValidReturnValue: ["body.7.id", "body.9.body.body.1.consequent.expression.right.expressions.0.callee", "body.9.body.body.1\
.alternate.body.body.1.expression.right.expressions.0.callee", "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressio\
ns.0.callee"],
        old_getInit: ["body.8.id", "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.ca\
llee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"],
        old_applyMemberDec: ["body.9.id", "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"],
        old_applyMemberDecs: ["body.10.id", "body.13.body.body.1.argument.expressions.0.callee"],
        old_pushInitializers: ["body.11.id", "body.10.body.body.1.expression.expressions.0.callee", "body.10.body.body.1.expression.expressi\
ons.1.callee"],
        old_applyClassDecs: ["body.12.id", "body.13.body.body.1.argument.expressions.2.callee"],
        applyDecs: ["body.13.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs",
      dependencies: {
        setFunctionName: ["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.9.body.bo\
dy.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      },
      internal: !1
    }),
    applyDecs2203: R("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e){if(\
e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function\
 memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";brea\
k;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),\
0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=funct\
ion(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return \
e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertVali\
dReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get\
, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.se\
t"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method\
")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:\
r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:\
2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0=\
==n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(\
h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&\
(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof\
 l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.pus\
h(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push(function(e,t){return u.get.call(\
e,t)}),e.push(function(e,t){return u.set.call(e,t)})):2===n?e.push(u):e.push(function(e,t){return u.call(e,t)}):Object.defineProperty(t,a,c)\
)}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e})}return function(e,t,r){var a=[];re\
turn function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,\
h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4=\
==g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/access\
or. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,\
f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--\
){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertVali\
dReturnValue(10,c),n=c)}e.push(n,function(){for(var e=0;e<a.length;e++)a[e].call(n)})}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs22\
03(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2203Factory: ["body.0.id", "body.2.body.body.0.argument.callee.right.right.callee"],
        applyDecs2203Impl: ["body.1.declarations.0.id", "body.2.body.body.0.argument.callee.right.left", "body.2.body.body.0.argument.callee\
.left"],
        applyDecs2203: ["body.2.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2203",
      dependencies: {},
      internal: !1
    }),
    applyDecs2203R: R("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e){i\
f(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}functi\
on memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";br\
eak;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitial\
izerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a\
&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{s\
et:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}fu\
nction assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return a\
n object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t\
.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===\
e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(\
0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunc\
tionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2==\
=a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a\
?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g\
],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(vo\
id 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l)\
{var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l\
)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push(function(e,t){return f.get.call(e,t\
)}),e.push(function(e,t){return f.set.call(e,t)})):2===a?e.push(f):e.push(function(e,t){return f.call(e,t)}):Object.defineProperty(t,n,c))}f\
unction applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],\
d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3==\
=g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public \
method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMembe\
rDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0\
;r<t.length;r++)t[r].call(e);return e})}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for\
(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r\
,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}\
function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2203RFactory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
        applyDecs2203R: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
      },
      exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
      exportName: "applyDecs2203R",
      dependencies: {
        setFunctionName: ["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "bo\
dy.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      },
      internal: !1
    }),
    applyDecs2301: R("7.21.0", 'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e){if(\
e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function\
 assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n\
,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="fie\
ld"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)\
),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){r\
eturn assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(\
c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():func\
tion(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCall\
able(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e)\
{if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void\
 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init\
,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or \
void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0=\
==a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="se\
t"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropert\
yDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,\
n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m\
=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.\
get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)\
l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}el\
se{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set\
=p),s?1===a?(e.push(function(e,t){return p.get.call(e,t)}),e.push(function(e,t){return p.set.call(e,t)})):2===a?e.push(p):e.push(function(e,\
t){return p.call(e,t)}):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;\
u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){re\
turn checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)\
throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is\
 not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}\
}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push(function(e){for(var r=0;r<t.length;r++)t[r].c\
all(e);return e})}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.\
name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=\
!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs\
2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}', {
      globals: ["Error", "TypeError", "Object", "Map", "Array"],
      locals: {
        applyDecs2301Factory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
        applyDecs2301: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
      },
      exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
      exportName: "applyDecs2301",
      dependencies: {
        checkInRHS: ["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.b\
ody.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "bo\
dy.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
        toPropertyKey: ["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
      },
      internal: !1
    }),
    applyDecs2305: R("7.21.0", 'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}fu\
nction c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeEr\
ror(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))\
throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var \
w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName(function(){return g(this)},n,"get"),set:function(e){t[4](this,\
e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D\
=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,\
t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I\
)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.\
value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={\
has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&\
&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P\
)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+\
" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push(function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(\
e,t);return t}),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t\
){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length\
>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(\
t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){v\
ar d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw E\
rror("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not cu\
rrently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h)\
,d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&\
[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}', {
      globals: ["TypeError", "Array", "Object", "Error", "Symbol", "Map"],
      locals: {
        applyDecs2305: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "applyDecs2305",
      dependencies: {
        checkInRHS: ["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"],
        setFunctionName: ["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.\
0.value.callee", "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"],
        toPropertyKey: ["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alte\
rnate.callee"]
      },
      internal: !1
    }),
    classApplyDescriptorDestructureSet: R("7.13.10", 'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.\
__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");retu\
rn t}', {
      globals: ["TypeError"],
      locals: {
        _classApplyDescriptorDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorDestructureSet",
      dependencies: {},
      internal: !1
    }),
    classApplyDescriptorGet: R("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", {
      globals: [],
      locals: {
        _classApplyDescriptorGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorGet",
      dependencies: {},
      internal: !1
    }),
    classApplyDescriptorSet: R("7.13.10", 'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new T\
ypeError("attempted to set read only private field");t.value=l}}', {
      globals: ["TypeError"],
      locals: {
        _classApplyDescriptorSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classApplyDescriptorSet",
      dependencies: {},
      internal: !1
    }),
    classCheckPrivateStaticAccess: R("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", {
      globals: [],
      locals: {
        _classCheckPrivateStaticAccess: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCheckPrivateStaticAccess",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.callee"]
      },
      internal: !1
    }),
    classCheckPrivateStaticFieldDescriptor: R("7.13.10", 'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new Type\
Error("attempted to "+e+" private static field before its declaration")}', {
      globals: ["TypeError"],
      locals: {
        _classCheckPrivateStaticFieldDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classCheckPrivateStaticFieldDescriptor",
      dependencies: {},
      internal: !1
    }),
    classExtractFieldDescriptor: R("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", {
      globals: [],
      locals: {
        _classExtractFieldDescriptor: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classExtractFieldDescriptor",
      dependencies: {
        classPrivateFieldGet2: ["body.0.body.body.0.argument.callee"]
      },
      internal: !1
    }),
    classPrivateFieldDestructureSet: R("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return clas\
sApplyDescriptorDestructureSet(e,r)}", {
      globals: [],
      locals: {
        _classPrivateFieldDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldDestructureSet",
      dependencies: {
        classApplyDescriptorDestructureSet: ["body.0.body.body.1.argument.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    classPrivateFieldGet: R("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescripto\
rGet(e,r)}", {
      globals: [],
      locals: {
        _classPrivateFieldGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldGet",
      dependencies: {
        classApplyDescriptorGet: ["body.0.body.body.1.argument.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    classPrivateFieldSet: R("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescrip\
torSet(e,s,r),r}", {
      globals: [],
      locals: {
        _classPrivateFieldSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateFieldSet",
      dependencies: {
        classApplyDescriptorSet: ["body.0.body.body.1.argument.expressions.0.callee"],
        classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
      },
      internal: !1
    }),
    classPrivateMethodGet: R("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", {
      globals: [],
      locals: {
        _classPrivateMethodGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodGet",
      dependencies: {
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
      },
      internal: !1
    }),
    classPrivateMethodSet: R("7.1.6", 'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}', {
      globals: ["TypeError"],
      locals: {
        _classPrivateMethodSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classPrivateMethodSet",
      dependencies: {},
      internal: !1
    }),
    classStaticPrivateFieldDestructureSet: R("7.13.10", 'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t)\
,classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldDestructureSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldDestructureSet",
      dependencies: {
        classApplyDescriptorDestructureSet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      },
      internal: !1
    }),
    classStaticPrivateFieldSpecGet: R("7.0.2", 'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPriva\
teStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldSpecGet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldSpecGet",
      dependencies: {
        classApplyDescriptorGet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      },
      internal: !1
    }),
    classStaticPrivateFieldSpecSet: R("7.0.2", 'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPri\
vateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}', {
      globals: [],
      locals: {
        _classStaticPrivateFieldSpecSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateFieldSpecSet",
      dependencies: {
        classApplyDescriptorSet: ["body.0.body.body.0.argument.expressions.2.callee"],
        assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
        classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
      },
      internal: !1
    }),
    classStaticPrivateMethodSet: R("7.3.2", 'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static \
private field")}', {
      globals: ["TypeError"],
      locals: {
        _classStaticPrivateMethodSet: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_classStaticPrivateMethodSet",
      dependencies: {},
      internal: !1
    }),
    defineEnumerableProperties: R("7.0.0-beta.0", 'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enu\
merable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(\
r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}',
    {
      globals: ["Object"],
      locals: {
        _defineEnumerableProperties: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_defineEnumerableProperties",
      dependencies: {},
      internal: !1
    }),
    dispose: R("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=Suppressed\
Error:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Obje\
ct.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}funct\
ion _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch\
(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}', {
      globals: ["SuppressedError", "Error", "Object", "Promise"],
      locals: {
        dispose_SuppressedError: ["body.0.id", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object", "body.0.body\
.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value", "body.0.body.body.0.argumen\
t.expressions.1.callee", "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee", "body.0.body.body.0.argument.expre\
ssions.0.consequent.left", "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"],
        _dispose: ["body.1.id"]
      },
      exportBindingAssignments: [],
      exportName: "_dispose",
      dependencies: {},
      internal: !1
    }),
    objectSpread: R("7.0.0-beta.0", 'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments\
[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter(function(e){\
return Object.getOwnPropertyDescriptor(t,e).enumerable})),o.forEach(function(r){defineProperty(e,r,t[r])})}return e}', {
      globals: ["Object"],
      locals: {
        _objectSpread: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_objectSpread",
      dependencies: {
        defineProperty: ["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"]
      },
      internal: !1
    }),
    regeneratorRuntime: R("7.18.0", 'function _regeneratorRuntime(){"use strict";var r=regenerator(),e=r.m(_regeneratorRuntime),t=(Object.ge\
tPrototypeOf?Object.getPrototypeOf(e):e.__proto__).constructor;function n(r){var e="function"==typeof r&&r.constructor;return!!e&&(e===t||"G\
eneratorFunction"===(e.displayName||e.name))}var o={throw:1,return:2,break:3,continue:3};function a(r){var e,t;return function(n){e||(e={sto\
p:function(){return t(n.a,2)},catch:function(){return n.v},abrupt:function(r,e){return t(n.a,o[r],e)},delegateYield:function(r,o,a){return e\
.resultName=o,t(n.d,values(r),a)},finish:function(r){return t(n.f,r)}},t=function(r,t,o){n.p=e.prev,n.n=e.next;try{return r(t,o)}finally{e.n\
ext=n.n}}),e.resultName&&(e[e.resultName]=n.v,e.resultName=void 0),e.sent=n.v,e.next=n.n;try{return r.call(this,e)}finally{n.p=e.prev,n.n=e.\
next}}}return(_regeneratorRuntime=function(){return{wrap:function(e,t,n,o){return r.w(a(e),t,n,o&&o.reverse())},isGeneratorFunction:n,mark:r\
.m,awrap:function(r,e){return new OverloadYield(r,e)},AsyncIterator:AsyncIterator,async:function(r,e,t,o,u){return(n(e)?asyncGen:async)(a(r)\
,e,t,o,u)},keys:keys,values:values}})()}', {
      globals: ["Object"],
      locals: {
        _regeneratorRuntime: ["body.0.id", "body.0.body.body.0.declarations.1.init.arguments.0", "body.0.body.body.4.argument.callee.left"]
      },
      exportBindingAssignments: ["body.0.body.body.4.argument.callee"],
      exportName: "_regeneratorRuntime",
      dependencies: {
        OverloadYield: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.3.value.body.body.0.argument.callee"],
        regenerator: ["body.0.body.body.0.declarations.0.init.callee"],
        regeneratorAsync: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.5.value.body.body.0.argument.callee.alt\
ernate"],
        regeneratorAsyncGen: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.5.value.body.body.0.argument.callee.\
consequent"],
        regeneratorAsyncIterator: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.4.value"],
        regeneratorKeys: ["body.0.body.body.4.argument.callee.right.body.body.0.argument.properties.6.value"],
        regeneratorValues: ["body.0.body.body.3.body.body.1.argument.body.body.0.expression.expressions.0.right.expressions.0.right.properti\
es.3.value.body.body.0.argument.expressions.1.arguments.1.callee", "body.0.body.body.4.argument.callee.right.body.body.0.argument.properties\
.7.value"]
      },
      internal: !1
    }),
    using: R("7.22.0", 'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used\
 with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol\
.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.p\
ush({v:n,d:r,a:e}),n}', {
      globals: ["Object", "TypeError", "Symbol"],
      locals: {
        _using: ["body.0.id"]
      },
      exportBindingAssignments: [],
      exportName: "_using",
      dependencies: {},
      internal: !1
    })
  });
});

// ../node_modules/@babel/helpers/lib/index.js
var ch = D((Lr) => {
  "use strict";
  Object.defineProperty(Lr, "__esModule", {
    value: !0
  });
  Lr.default = void 0;
  Lr.get = Zx;
  Lr.getDependencies = RJ;
  Lr.isInternal = qJ;
  Lr.list = void 0;
  Lr.minVersion = MJ;
  var FJ = ce(), uh = zx(), {
    cloneNode: LJ,
    identifier: Qx
  } = FJ;
  function tu(e, t, r) {
    try {
      let s = t.split("."), n = s.shift();
      for (; s.length > 0; )
        e = e[n], n = s.shift();
      if (arguments.length > 2)
        e[n] = r;
      else
        return e[n];
    } catch (s) {
      throw s.message += ` (when accessing ${t})`, s;
    }
  }
  i(tu, "deep");
  function jJ(e, t, r, s, n, a) {
    let {
      locals: o,
      dependencies: l,
      exportBindingAssignments: u,
      exportName: c
    } = t, p = new Set(s || []);
    r && p.add(r);
    for (let [f, h] of (Object.entries || ((b) => Object.keys(b).map((T) => [T, b[T]])))(o)) {
      let b = f;
      if (r && f === c)
        b = r;
      else
        for (; p.has(b); ) b = "_" + b;
      if (b !== f)
        for (let T of h)
          tu(e, T, Qx(b));
    }
    for (let [f, h] of (Object.entries || ((b) => Object.keys(b).map((T) => [T, b[T]])))(l)) {
      let b = typeof n == "function" && n(f) || Qx(f);
      for (let T of h)
        tu(e, T, LJ(b));
    }
    a?.(e, c, (f) => {
      u.forEach((h) => tu(e, h, f(tu(e, h))));
    });
  }
  i(jJ, "permuteHelperAST");
  var lh = /* @__PURE__ */ Object.create(null);
  function ru(e) {
    if (!lh[e]) {
      let t = uh.default[e];
      if (!t)
        throw Object.assign(new ReferenceError(`Unknown helper ${e}`), {
          code: "BABEL_HELPER_UNKNOWN",
          helper: e
        });
      lh[e] = {
        minVersion: t.minVersion,
        build(r, s, n, a) {
          let o = t.ast();
          return jJ(o, t.metadata, s, n, r, a), {
            nodes: o.body,
            globals: t.metadata.globals
          };
        },
        getDependencies() {
          return Object.keys(t.metadata.dependencies);
        }
      };
    }
    return lh[e];
  }
  i(ru, "loadHelper");
  function Zx(e, t, r, s, n) {
    if (typeof r == "object") {
      let a = r;
      a?.type === "Identifier" ? r = a.name : r = void 0;
    }
    return ru(e).build(t, r, s, n);
  }
  i(Zx, "get");
  function MJ(e) {
    return ru(e).minVersion;
  }
  i(MJ, "minVersion");
  function RJ(e) {
    return ru(e).getDependencies();
  }
  i(RJ, "getDependencies");
  function qJ(e) {
    var t;
    return (t = uh.default[e]) == null ? void 0 : t.metadata.internal;
  }
  i(qJ, "isInternal");
  Lr.ensure = (e) => {
    ru(e);
  };
  var R4e = Lr.list = Object.keys(uh.default).map((e) => e.replace(/^_/, "")), q4e = Lr.default = Zx;
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var ph = D((xe) => {
  "use strict";
  Object.defineProperty(xe, "__esModule", {
    value: !0
  });
  xe.Var = xe.User = xe.Statement = xe.SpreadProperty = xe.Scope = xe.RestProperty = xe.ReferencedMemberExpression = xe.ReferencedIdentifier =
  xe.Referenced = xe.Pure = xe.NumericLiteralTypeAnnotation = xe.Generated = xe.ForAwaitStatement = xe.Flow = xe.Expression = xe.ExistentialTypeParam =
  xe.BlockScoped = xe.BindingIdentifier = void 0;
  var V4e = xe.ReferencedIdentifier = ["Identifier", "JSXIdentifier"], K4e = xe.ReferencedMemberExpression = ["MemberExpression"], W4e = xe.
  BindingIdentifier = ["Identifier"], Y4e = xe.Statement = ["Statement"], H4e = xe.Expression = ["Expression"], J4e = xe.Scope = ["Scopable",
  "Pattern"], G4e = xe.Referenced = null, X4e = xe.BlockScoped = ["FunctionDeclaration", "ClassDeclaration", "VariableDeclaration"], z4e = xe.
  Var = ["VariableDeclaration"], Q4e = xe.User = null, Z4e = xe.Generated = null, ewe = xe.Pure = null, twe = xe.Flow = ["Flow", "ImportDecl\
aration", "ExportDeclaration", "ImportSpecifier"], rwe = xe.RestProperty = ["RestElement"], swe = xe.SpreadProperty = ["RestElement"], nwe = xe.
  ExistentialTypeParam = ["ExistsTypeAnnotation"], iwe = xe.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"], awe = xe.ForAwaitStatement =
  ["ForOfStatement"];
});

// ../node_modules/ms/index.js
var tE = D((lwe, eE) => {
  var Oi = 1e3, Ni = Oi * 60, Bi = Ni * 60, kn = Bi * 24, UJ = kn * 7, $J = kn * 365.25;
  eE.exports = function(e, t) {
    t = t || {};
    var r = typeof e;
    if (r === "string" && e.length > 0)
      return VJ(e);
    if (r === "number" && isFinite(e))
      return t.long ? WJ(e) : KJ(e);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(e)
    );
  };
  function VJ(e) {
    if (e = String(e), !(e.length > 100)) {
      var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.
      exec(
        e
      );
      if (t) {
        var r = parseFloat(t[1]), s = (t[2] || "ms").toLowerCase();
        switch (s) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * $J;
          case "weeks":
          case "week":
          case "w":
            return r * UJ;
          case "days":
          case "day":
          case "d":
            return r * kn;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * Bi;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * Ni;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * Oi;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r;
          default:
            return;
        }
      }
    }
  }
  i(VJ, "parse");
  function KJ(e) {
    var t = Math.abs(e);
    return t >= kn ? Math.round(e / kn) + "d" : t >= Bi ? Math.round(e / Bi) + "h" : t >= Ni ? Math.round(e / Ni) + "m" : t >= Oi ? Math.round(
    e / Oi) + "s" : e + "ms";
  }
  i(KJ, "fmtShort");
  function WJ(e) {
    var t = Math.abs(e);
    return t >= kn ? su(e, t, kn, "day") : t >= Bi ? su(e, t, Bi, "hour") : t >= Ni ? su(e, t, Ni, "minute") : t >= Oi ? su(e, t, Oi, "secon\
d") : e + " ms";
  }
  i(WJ, "fmtLong");
  function su(e, t, r, s) {
    var n = t >= r * 1.5;
    return Math.round(e / r) + " " + s + (n ? "s" : "");
  }
  i(su, "plural");
});

// ../node_modules/debug/src/common.js
var fh = D((cwe, rE) => {
  function YJ(e) {
    r.debug = r, r.default = r, r.coerce = u, r.disable = o, r.enable = n, r.enabled = l, r.humanize = tE(), r.destroy = c, Object.keys(e).forEach(
    (p) => {
      r[p] = e[p];
    }), r.names = [], r.skips = [], r.formatters = {};
    function t(p) {
      let f = 0;
      for (let h = 0; h < p.length; h++)
        f = (f << 5) - f + p.charCodeAt(h), f |= 0;
      return r.colors[Math.abs(f) % r.colors.length];
    }
    i(t, "selectColor"), r.selectColor = t;
    function r(p) {
      let f, h = null, b, T;
      function d(...g) {
        if (!d.enabled)
          return;
        let E = d, _ = Number(/* @__PURE__ */ new Date()), N = _ - (f || _);
        E.diff = N, E.prev = f, E.curr = _, f = _, g[0] = r.coerce(g[0]), typeof g[0] != "string" && g.unshift("%O");
        let k = 0;
        g[0] = g[0].replace(/%([a-zA-Z%])/g, (U, M) => {
          if (U === "%%")
            return "%";
          k++;
          let K = r.formatters[M];
          if (typeof K == "function") {
            let G = g[k];
            U = K.call(E, G), g.splice(k, 1), k--;
          }
          return U;
        }), r.formatArgs.call(E, g), (E.log || r.log).apply(E, g);
      }
      return i(d, "debug"), d.namespace = p, d.useColors = r.useColors(), d.color = r.selectColor(p), d.extend = s, d.destroy = r.destroy, Object.
      defineProperty(d, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: /* @__PURE__ */ i(() => h !== null ? h : (b !== r.namespaces && (b = r.namespaces, T = r.enabled(p)), T), "get"),
        set: /* @__PURE__ */ i((g) => {
          h = g;
        }, "set")
      }), typeof r.init == "function" && r.init(d), d;
    }
    i(r, "createDebug");
    function s(p, f) {
      let h = r(this.namespace + (typeof f > "u" ? ":" : f) + p);
      return h.log = this.log, h;
    }
    i(s, "extend");
    function n(p) {
      r.save(p), r.namespaces = p, r.names = [], r.skips = [];
      let f = (typeof p == "string" ? p : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (let h of f)
        h[0] === "-" ? r.skips.push(h.slice(1)) : r.names.push(h);
    }
    i(n, "enable");
    function a(p, f) {
      let h = 0, b = 0, T = -1, d = 0;
      for (; h < p.length; )
        if (b < f.length && (f[b] === p[h] || f[b] === "*"))
          f[b] === "*" ? (T = b, d = h, b++) : (h++, b++);
        else if (T !== -1)
          b = T + 1, d++, h = d;
        else
          return !1;
      for (; b < f.length && f[b] === "*"; )
        b++;
      return b === f.length;
    }
    i(a, "matchesTemplate");
    function o() {
      let p = [
        ...r.names,
        ...r.skips.map((f) => "-" + f)
      ].join(",");
      return r.enable(""), p;
    }
    i(o, "disable");
    function l(p) {
      for (let f of r.skips)
        if (a(p, f))
          return !1;
      for (let f of r.names)
        if (a(p, f))
          return !0;
      return !1;
    }
    i(l, "enabled");
    function u(p) {
      return p instanceof Error ? p.stack || p.message : p;
    }
    i(u, "coerce");
    function c() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major versio\
n of `debug`.");
    }
    return i(c, "destroy"), r.enable(r.load()), r;
  }
  i(YJ, "setup");
  rE.exports = YJ;
});

// ../node_modules/debug/src/browser.js
var sE = D((er, nu) => {
  er.formatArgs = JJ;
  er.save = GJ;
  er.load = XJ;
  er.useColors = HJ;
  er.storage = zJ();
  er.destroy = /* @__PURE__ */ (() => {
    let e = !1;
    return () => {
      e || (e = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the nex\
t major version of `debug`."));
    };
  })();
  er.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function HJ() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
      return !0;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
      return !1;
    let e;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance ||
    // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && (e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(e[1], 10) >=
    31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  i(HJ, "useColors");
  function JJ(e) {
    if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" +
    nu.exports.humanize(this.diff), !this.useColors)
      return;
    let t = "color: " + this.color;
    e.splice(1, 0, t, "color: inherit");
    let r = 0, s = 0;
    e[0].replace(/%[a-zA-Z%]/g, (n) => {
      n !== "%%" && (r++, n === "%c" && (s = r));
    }), e.splice(s, 0, t);
  }
  i(JJ, "formatArgs");
  er.log = console.debug || console.log || (() => {
  });
  function GJ(e) {
    try {
      e ? er.storage.setItem("debug", e) : er.storage.removeItem("debug");
    } catch {
    }
  }
  i(GJ, "save");
  function XJ() {
    let e;
    try {
      e = er.storage.getItem("debug") || er.storage.getItem("DEBUG");
    } catch {
    }
    return !e && typeof process < "u" && "env" in process && (e = process.env.DEBUG), e;
  }
  i(XJ, "load");
  function zJ() {
    try {
      return localStorage;
    } catch {
    }
  }
  i(zJ, "localstorage");
  nu.exports = fh()(er);
  var { formatters: QJ } = nu.exports;
  QJ.j = function(e) {
    try {
      return JSON.stringify(e);
    } catch (t) {
      return "[UnexpectedJSONParseError]: " + t.message;
    }
  };
});

// ../node_modules/has-flag/index.js
var iE = D((dwe, nE) => {
  "use strict";
  nE.exports = (e, t = process.argv) => {
    let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", s = t.indexOf(r + e), n = t.indexOf("--");
    return s !== -1 && (n === -1 || s < n);
  };
});

// ../node_modules/supports-color/index.js
var lE = D((hwe, oE) => {
  "use strict";
  var ZJ = z("os"), aE = z("tty"), yr = iE(), { env: ft } = process, Zs;
  yr("no-color") || yr("no-colors") || yr("color=false") || yr("color=never") ? Zs = 0 : (yr("color") || yr("colors") || yr("color=true") ||
  yr("color=always")) && (Zs = 1);
  "FORCE_COLOR" in ft && (ft.FORCE_COLOR === "true" ? Zs = 1 : ft.FORCE_COLOR === "false" ? Zs = 0 : Zs = ft.FORCE_COLOR.length === 0 ? 1 : Math.
  min(parseInt(ft.FORCE_COLOR, 10), 3));
  function dh(e) {
    return e === 0 ? !1 : {
      level: e,
      hasBasic: !0,
      has256: e >= 2,
      has16m: e >= 3
    };
  }
  i(dh, "translateLevel");
  function hh(e, t) {
    if (Zs === 0)
      return 0;
    if (yr("color=16m") || yr("color=full") || yr("color=truecolor"))
      return 3;
    if (yr("color=256"))
      return 2;
    if (e && !t && Zs === void 0)
      return 0;
    let r = Zs || 0;
    if (ft.TERM === "dumb")
      return r;
    if (process.platform === "win32") {
      let s = ZJ.release().split(".");
      return Number(s[0]) >= 10 && Number(s[2]) >= 10586 ? Number(s[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in ft)
      return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((s) => s in ft) || ft.CI_NAME === "codeship" ?
      1 : r;
    if ("TEAMCITY_VERSION" in ft)
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(ft.TEAMCITY_VERSION) ? 1 : 0;
    if (ft.COLORTERM === "truecolor")
      return 3;
    if ("TERM_PROGRAM" in ft) {
      let s = parseInt((ft.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (ft.TERM_PROGRAM) {
        case "iTerm.app":
          return s >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(ft.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(ft.TERM) || "COLORTERM" in
    ft ? 1 : r;
  }
  i(hh, "supportsColor");
  function eG(e) {
    let t = hh(e, e && e.isTTY);
    return dh(t);
  }
  i(eG, "getSupportLevel");
  oE.exports = {
    supportsColor: eG,
    stdout: dh(hh(!0, aE.isatty(1))),
    stderr: dh(hh(!0, aE.isatty(2)))
  };
});

// ../node_modules/debug/src/node.js
var cE = D((dt, au) => {
  var tG = z("tty"), iu = z("util");
  dt.init = lG;
  dt.log = iG;
  dt.formatArgs = sG;
  dt.save = aG;
  dt.load = oG;
  dt.useColors = rG;
  dt.destroy = iu.deprecate(
    () => {
    },
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
  );
  dt.colors = [6, 2, 3, 4, 5, 1];
  try {
    let e = lE();
    e && (e.stderr || e).level >= 2 && (dt.colors = [
      20,
      21,
      26,
      27,
      32,
      33,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      56,
      57,
      62,
      63,
      68,
      69,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      92,
      93,
      98,
      99,
      112,
      113,
      128,
      129,
      134,
      135,
      148,
      149,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      178,
      179,
      184,
      185,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      214,
      215,
      220,
      221
    ]);
  } catch {
  }
  dt.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, t) => {
    let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (n, a) => a.toUpperCase()), s = process.env[t];
    return /^(yes|on|true|enabled)$/i.test(s) ? s = !0 : /^(no|off|false|disabled)$/i.test(s) ? s = !1 : s === "null" ? s = null : s = Number(
    s), e[r] = s, e;
  }, {});
  function rG() {
    return "colors" in dt.inspectOpts ? !!dt.inspectOpts.colors : tG.isatty(process.stderr.fd);
  }
  i(rG, "useColors");
  function sG(e) {
    let { namespace: t, useColors: r } = this;
    if (r) {
      let s = this.color, n = "\x1B[3" + (s < 8 ? s : "8;5;" + s), a = `  ${n};1m${t} \x1B[0m`;
      e[0] = a + e[0].split(`
`).join(`
` + a), e.push(n + "m+" + au.exports.humanize(this.diff) + "\x1B[0m");
    } else
      e[0] = nG() + t + " " + e[0];
  }
  i(sG, "formatArgs");
  function nG() {
    return dt.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  i(nG, "getDate");
  function iG(...e) {
    return process.stderr.write(iu.formatWithOptions(dt.inspectOpts, ...e) + `
`);
  }
  i(iG, "log");
  function aG(e) {
    e ? process.env.DEBUG = e : delete process.env.DEBUG;
  }
  i(aG, "save");
  function oG() {
    return process.env.DEBUG;
  }
  i(oG, "load");
  function lG(e) {
    e.inspectOpts = {};
    let t = Object.keys(dt.inspectOpts);
    for (let r = 0; r < t.length; r++)
      e.inspectOpts[t[r]] = dt.inspectOpts[t[r]];
  }
  i(lG, "init");
  au.exports = fh()(dt);
  var { formatters: uE } = au.exports;
  uE.o = function(e) {
    return this.inspectOpts.colors = this.useColors, iu.inspect(e, this.inspectOpts).split(`
`).map((t) => t.trim()).join(" ");
  };
  uE.O = function(e) {
    return this.inspectOpts.colors = this.useColors, iu.inspect(e, this.inspectOpts);
  };
});

// ../node_modules/debug/src/index.js
var Fn = D((bwe, mh) => {
  typeof process > "u" || process.type === "renderer" || process.browser === !0 || process.__nwjs ? mh.exports = sE() : mh.exports = cE();
});

// ../node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var yh = D((lt) => {
  "use strict";
  Object.defineProperty(lt, "__esModule", {
    value: !0
  });
  lt.isBindingIdentifier = OG;
  lt.isBlockScoped = LG;
  lt.isExpression = BG;
  lt.isFlow = UG;
  lt.isForAwaitStatement = KG;
  lt.isGenerated = RG;
  lt.isPure = qG;
  lt.isReferenced = FG;
  lt.isReferencedIdentifier = _G;
  lt.isReferencedMemberExpression = IG;
  lt.isRestProperty = $G;
  lt.isScope = kG;
  lt.isSpreadProperty = VG;
  lt.isStatement = NG;
  lt.isUser = MG;
  lt.isVar = jG;
  var uG = ce(), {
    isBinding: cG,
    isBlockScoped: pG,
    isExportDeclaration: fG,
    isExpression: dG,
    isFlow: hG,
    isForStatement: mG,
    isForXStatement: yG,
    isIdentifier: pE,
    isImportDeclaration: bG,
    isImportSpecifier: gG,
    isJSXIdentifier: TG,
    isJSXMemberExpression: xG,
    isMemberExpression: EG,
    isRestElement: fE,
    isReferenced: ou,
    isScope: SG,
    isStatement: vG,
    isVar: PG,
    isVariableDeclaration: AG,
    react: CG,
    isForOfStatement: wG
  } = uG, {
    isCompatTag: DG
  } = CG;
  function _G(e) {
    let {
      node: t,
      parent: r
    } = this;
    return pE(t, e) ? ou(t, r, this.parentPath.parent) : TG(t, e) ? !xG(r) && DG(t.name) ? !1 : ou(t, r, this.parentPath.parent) : !1;
  }
  i(_G, "isReferencedIdentifier");
  function IG() {
    let {
      node: e,
      parent: t
    } = this;
    return EG(e) && ou(e, t);
  }
  i(IG, "isReferencedMemberExpression");
  function OG() {
    let {
      node: e,
      parent: t
    } = this, r = this.parentPath.parent;
    return pE(e) && cG(e, t, r);
  }
  i(OG, "isBindingIdentifier");
  function NG() {
    let {
      node: e,
      parent: t
    } = this;
    return vG(e) ? !(AG(e) && (yG(t, {
      left: e
    }) || mG(t, {
      init: e
    }))) : !1;
  }
  i(NG, "isStatement");
  function BG() {
    return this.isIdentifier() ? this.isReferencedIdentifier() : dG(this.node);
  }
  i(BG, "isExpression");
  function kG() {
    return SG(this.node, this.parent);
  }
  i(kG, "isScope");
  function FG() {
    return ou(this.node, this.parent);
  }
  i(FG, "isReferenced");
  function LG() {
    return pG(this.node);
  }
  i(LG, "isBlockScoped");
  function jG() {
    return PG(this.node);
  }
  i(jG, "isVar");
  function MG() {
    var e;
    return !!((e = this.node) != null && e.loc);
  }
  i(MG, "isUser");
  function RG() {
    return !this.isUser();
  }
  i(RG, "isGenerated");
  function qG(e) {
    return this.scope.isPure(this.node, e);
  }
  i(qG, "isPure");
  function UG() {
    let {
      node: e
    } = this;
    return hG(e) ? !0 : bG(e) ? e.importKind === "type" || e.importKind === "typeof" : fG(e) ? e.exportKind === "type" : gG(e) ? e.importKind ===
    "type" || e.importKind === "typeof" : !1;
  }
  i(UG, "isFlow");
  function $G() {
    var e;
    return fE(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectPattern());
  }
  i($G, "isRestProperty");
  function VG() {
    var e;
    return fE(this.node) && ((e = this.parentPath) == null ? void 0 : e.isObjectExpression());
  }
  i(VG, "isSpreadProperty");
  function KG() {
    return wG(this.node, {
      await: !0
    });
  }
  i(KG, "isForAwaitStatement");
  lt.isExistentialTypeParam = /* @__PURE__ */ i(function() {
    throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
  }, "isExistentialTypeParam"), lt.isNumericLiteralTypeAnnotation = /* @__PURE__ */ i(function() {
    throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
  }, "isNumericLiteralTypeAnnotation");
});

// ../node_modules/@babel/traverse/lib/visitors.js
var no = D((jn) => {
  "use strict";
  Object.defineProperty(jn, "__esModule", {
    value: !0
  });
  jn.environmentVisitor = QG;
  jn.explode = vE;
  jn.isExplodedVisitor = SE;
  jn.merge = AE;
  jn.verify = PE;
  var EE = ph(), WG = yh(), YG = ce(), dE = br(), {
    DEPRECATED_KEYS: hE,
    DEPRECATED_ALIASES: mE,
    FLIPPED_ALIAS_KEYS: yE,
    TYPES: HG,
    __internal__deprecationWarning: bE
  } = YG;
  function JG(e) {
    return e in EE;
  }
  i(JG, "isVirtualType");
  function SE(e) {
    return e?._exploded;
  }
  i(SE, "isExplodedVisitor");
  function vE(e) {
    if (SE(e)) return e;
    e._exploded = !0;
    for (let r of Object.keys(e)) {
      if (Ln(r)) continue;
      let s = r.split("|");
      if (s.length === 1) continue;
      let n = e[r];
      delete e[r];
      for (let a of s)
        e[a] = n;
    }
    PE(e), delete e.__esModule, GG(e), xE(e);
    for (let r of Object.keys(e)) {
      if (Ln(r) || !JG(r)) continue;
      let s = e[r];
      for (let a of Object.keys(s))
        s[a] = XG(r, s[a]);
      delete e[r];
      let n = EE[r];
      if (n !== null)
        for (let a of n) {
          var t;
          (t = e[a]) != null || (e[a] = {}), so(e[a], s);
        }
      else
        so(e, s);
    }
    for (let r of Object.keys(e)) {
      if (Ln(r)) continue;
      let s = yE[r];
      if (r in hE) {
        let a = hE[r];
        bE(r, a, "Visitor "), s = [a];
      } else if (r in mE) {
        let a = mE[r];
        bE(r, a, "Visitor "), s = yE[a];
      }
      if (!s) continue;
      let n = e[r];
      delete e[r];
      for (let a of s) {
        let o = e[a];
        o ? so(o, n) : e[a] = Object.assign({}, n);
      }
    }
    for (let r of Object.keys(e))
      Ln(r) || xE(e[r]);
    return e;
  }
  i(vE, "explode$1");
  function PE(e) {
    if (!e._verified) {
      if (typeof e == "function")
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Functi\
on }`?");
      for (let t of Object.keys(e)) {
        if ((t === "enter" || t === "exit") && gE(t, e[t]), Ln(t)) continue;
        if (!HG.includes(t))
          throw new Error(`You gave us a visitor for the node type ${t} but it's not a valid type in @babel/traverse 7.28.5`);
        let r = e[t];
        if (typeof r == "object")
          for (let s of Object.keys(r))
            if (s === "enter" || s === "exit")
              gE(`${t}.${s}`, r[s]);
            else
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${t} that has the invalid property ${s}`);
      }
      e._verified = !0;
    }
  }
  i(PE, "verify$1");
  function gE(e, t) {
    let r = [].concat(t);
    for (let s of r)
      if (typeof s != "function")
        throw new TypeError(`Non-function found defined in ${e} with type ${typeof s}`);
  }
  i(gE, "validateVisitorMethods");
  function AE(e, t = [], r) {
    let s = {
      _verified: !0,
      _exploded: !0
    };
    Object.defineProperty(s, "_exploded", {
      enumerable: !1
    }), Object.defineProperty(s, "_verified", {
      enumerable: !1
    });
    for (let n = 0; n < e.length; n++) {
      let a = vE(e[n]), o = t[n], l = a;
      (o || r) && (l = TE(l, o, r)), so(s, l);
      for (let u of Object.keys(a)) {
        if (Ln(u)) continue;
        let c = a[u];
        (o || r) && (c = TE(c, o, r));
        let p = s[u] || (s[u] = {});
        so(p, c);
      }
    }
    return s;
  }
  i(AE, "merge");
  function TE(e, t, r) {
    let s = {};
    for (let n of ["enter", "exit"]) {
      let a = e[n];
      Array.isArray(a) && (a = a.map(function(o) {
        let l = o;
        return t && (l = /* @__PURE__ */ i(function(u) {
          o.call(t, u, t);
        }, "newFn")), r && (l = r(t?.key, n, l)), l !== o && (l.toString = () => o.toString()), l;
      }), s[n] = a);
    }
    return s;
  }
  i(TE, "wrapWithStateOrWrapper");
  function GG(e) {
    for (let t of Object.keys(e)) {
      if (Ln(t)) continue;
      let r = e[t];
      typeof r == "function" && (e[t] = {
        enter: r
      });
    }
  }
  i(GG, "ensureEntranceObjects");
  function xE(e) {
    e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]), e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
  }
  i(xE, "ensureCallbackArrays");
  function XG(e, t) {
    let r = `is${e}`, s = WG[r], n = /* @__PURE__ */ i(function(a) {
      if (s.call(a))
        return t.apply(this, arguments);
    }, "newFn");
    return n.toString = () => t.toString(), n;
  }
  i(XG, "wrapCheck");
  function Ln(e) {
    return e[0] === "_" || e === "enter" || e === "exit" || e === "shouldSkip" || e === "denylist" || e === "noScope" || e === "skipKeys" ||
    e === "blacklist";
  }
  i(Ln, "shouldIgnoreKey");
  function so(e, t) {
    for (let r of ["enter", "exit"])
      t[r] && (e[r] = [].concat(e[r] || [], t[r]));
  }
  i(so, "mergePair");
  var zG = {
    FunctionParent(e) {
      e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && (e.requeueComputedKeyAndDecorators ? e.requeueComputedKeyAndDecorators() :
      dE.requeueComputedKeyAndDecorators.call(e)));
    },
    Property(e) {
      e.isObjectProperty() || (e.skip(), e.requeueComputedKeyAndDecorators ? e.requeueComputedKeyAndDecorators() : dE.requeueComputedKeyAndDecorators.
      call(e));
    }
  };
  function QG(e) {
    return AE([zG, e]);
  }
  i(QG, "environmentVisitor");
});

// ../node_modules/@babel/traverse/lib/scope/lib/renamer.js
var CE = D((uu) => {
  "use strict";
  Object.defineProperty(uu, "__esModule", {
    value: !0
  });
  uu.default = void 0;
  var lu = ce(), ZG = lu, eX = cu(), tX = no(), rX = br(), {
    getAssignmentIdentifiers: sX
  } = ZG, nX = {
    ReferencedIdentifier({
      node: e
    }, t) {
      e.name === t.oldName && (e.name = t.newName);
    },
    Scope(e, t) {
      e.scope.bindingIdentifierEquals(t.oldName, t.binding.identifier) || (e.skip(), e.isMethod() && (e.requeueComputedKeyAndDecorators ? e.
      requeueComputedKeyAndDecorators() : rX.requeueComputedKeyAndDecorators.call(e)));
    },
    ObjectProperty({
      node: e,
      scope: t
    }, r) {
      let {
        name: s
      } = e.key;
      if (e.shorthand && (s === r.oldName || s === r.newName) && t.getBindingIdentifier(s) === r.binding.identifier) {
        e.shorthand = !1;
        {
          var n;
          (n = e.extra) != null && n.shorthand && (e.extra.shorthand = !1);
        }
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator"(e, t) {
      if (e.isVariableDeclaration()) return;
      let r = e.isAssignmentExpression() ? sX(e.node) : e.getOuterBindingIdentifiers();
      for (let s in r)
        s === t.oldName && (r[s].name = t.newName);
    }
  }, bh = class {
    static {
      i(this, "Renamer");
    }
    constructor(t, r, s) {
      this.newName = s, this.oldName = r, this.binding = t;
    }
    maybeConvertFromExportDeclaration(t) {
      let r = t.parentPath;
      if (r.isExportDeclaration()) {
        if (r.isExportDefaultDeclaration()) {
          let {
            declaration: s
          } = r.node;
          if (lu.isDeclaration(s) && !s.id)
            return;
        }
        r.isExportAllDeclaration() || r.splitExportDeclaration();
      }
    }
    maybeConvertFromClassFunctionDeclaration(t) {
      return t;
    }
    maybeConvertFromClassFunctionExpression(t) {
      return t;
    }
    rename() {
      let {
        binding: t,
        oldName: r,
        newName: s
      } = this, {
        scope: n,
        path: a
      } = t, o = a.find((c) => c.isDeclaration() || c.isFunctionExpression() || c.isClassExpression());
      o && o.getOuterBindingIdentifiers()[r] === t.identifier && this.maybeConvertFromExportDeclaration(o);
      let l = arguments[0] || n.block, u = {
        discriminant: !0
      };
      lu.isMethod(l) && (l.computed && (u.key = !0), lu.isObjectMethod(l) || (u.decorators = !0)), (0, eX.traverseNode)(l, (0, tX.explode)(nX),
      n, this, n.path, u), arguments[0] || (n.removeOwnBinding(r), n.bindings[s] = t, this.binding.identifier.name = s), o && (this.maybeConvertFromClassFunctionDeclaration(
      a), this.maybeConvertFromClassFunctionExpression(a));
    }
  };
  uu.default = bh;
});

// ../node_modules/@babel/traverse/lib/scope/traverseForScope.js
var wE = D((gh) => {
  "use strict";
  Object.defineProperty(gh, "__esModule", {
    value: !0
  });
  gh.default = cX;
  var iX = ce(), aX = nt(), oX = no(), lX = br(), {
    VISITOR_KEYS: uX
  } = iX;
  function cX(e, t, r) {
    let s = (0, oX.explode)(t);
    if (s.enter || s.exit)
      throw new Error("Should not be used with enter/exit visitors.");
    n(e.parentPath, e.parent, e.node, e.container, e.key, e.listKey, e.hub, e);
    function n(a, o, l, u, c, p, f, h) {
      if (!l)
        return;
      let b = h || aX.NodePath.get({
        hub: f,
        parentPath: a,
        parent: o,
        container: u,
        listKey: p,
        key: c
      });
      lX.setScope.call(b);
      let T = s[l.type];
      if (T) {
        if (T.enter)
          for (let g of T.enter)
            g.call(r, b, r);
        if (T.exit)
          for (let g of T.exit)
            g.call(r, b, r);
      }
      if (b.shouldSkip)
        return;
      let d = uX[l.type];
      if (d != null && d.length)
        for (let g of d) {
          let E = l[g];
          if (E)
            if (Array.isArray(E))
              for (let _ = 0; _ < E.length; _++) {
                let N = E[_];
                n(b, l, N, E, _, g);
              }
            else
              n(b, l, E, l, g, null);
        }
    }
    i(n, "_traverse");
  }
  i(cX, "traverseForScope");
});

// ../node_modules/@babel/traverse/lib/scope/binding.js
var DE = D((pu) => {
  "use strict";
  Object.defineProperty(pu, "__esModule", {
    value: !0
  });
  pu.default = void 0;
  var Th = class {
    static {
      i(this, "Binding");
    }
    constructor({
      identifier: t,
      scope: r,
      path: s,
      kind: n
    }) {
      this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = !0,
      this.referencePaths = [], this.referenced = !1, this.references = 0, this.identifier = t, this.scope = r, this.path = s, this.kind = n,
      (n === "var" || n === "hoisted") && pX(s) && this.reassign(s), this.clearValue();
    }
    deoptValue() {
      this.clearValue(), this.hasDeoptedValue = !0;
    }
    setValue(t) {
      this.hasDeoptedValue || (this.hasValue = !0, this.value = t);
    }
    clearValue() {
      this.hasDeoptedValue = !1, this.hasValue = !1, this.value = null;
    }
    reassign(t) {
      this.constant = !1, !this.constantViolations.includes(t) && this.constantViolations.push(t);
    }
    reference(t) {
      this.referencePaths.includes(t) || (this.referenced = !0, this.references++, this.referencePaths.push(t));
    }
    dereference() {
      this.references--, this.referenced = !!this.references;
    }
  };
  pu.default = Th;
  function pX(e) {
    let t = !e.isVariableDeclarator() || e.node.init;
    for (let {
      parentPath: r,
      key: s
    } = e; r; {
      parentPath: r,
      key: s
    } = r) {
      if (r.isFunctionParent()) return !1;
      if (s === "left" && r.isForXStatement() || t && s === "body" && r.isLoop())
        return !0;
    }
    return !1;
  }
  i(pX, "isInitInLoop");
});

// ../node_modules/@babel/traverse/lib/cache.js
var Mn = D((rr) => {
  "use strict";
  Object.defineProperty(rr, "__esModule", {
    value: !0
  });
  rr.clear = dX;
  rr.clearPath = _E;
  rr.clearScope = IE;
  rr.getCachedPaths = hX;
  rr.getOrCreateCachedPaths = mX;
  rr.scope = rr.path = void 0;
  var fu = rr.path = /* @__PURE__ */ new WeakMap(), fX = rr.scope = /* @__PURE__ */ new WeakMap();
  function dX() {
    _E(), IE();
  }
  i(dX, "clear");
  function _E() {
    rr.path = fu = /* @__PURE__ */ new WeakMap();
  }
  i(_E, "clearPath");
  function IE() {
    rr.scope = fX = /* @__PURE__ */ new WeakMap();
  }
  i(IE, "clearScope");
  function hX(e) {
    let {
      parent: t,
      parentPath: r
    } = e;
    return fu.get(t);
  }
  i(hX, "getCachedPaths");
  function mX(e, t) {
    let r = fu.get(e);
    return r || fu.set(e, r = /* @__PURE__ */ new Map()), r;
  }
  i(mX, "getOrCreateCachedPaths");
});

// ../node_modules/@babel/helper-globals/data/builtin-lower.json
var OE = D((Iwe, yX) => {
  yX.exports = [
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "eval",
    "globalThis",
    "isFinite",
    "isNaN",
    "parseFloat",
    "parseInt",
    "undefined",
    "unescape"
  ];
});

// ../node_modules/@babel/helper-globals/data/builtin-upper.json
var NE = D((Owe, bX) => {
  bX.exports = [
    "AggregateError",
    "Array",
    "ArrayBuffer",
    "Atomics",
    "BigInt",
    "BigInt64Array",
    "BigUint64Array",
    "Boolean",
    "DataView",
    "Date",
    "Error",
    "EvalError",
    "FinalizationRegistry",
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Function",
    "Infinity",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Intl",
    "Iterator",
    "JSON",
    "Map",
    "Math",
    "NaN",
    "Number",
    "Object",
    "Promise",
    "Proxy",
    "RangeError",
    "ReferenceError",
    "Reflect",
    "RegExp",
    "Set",
    "SharedArrayBuffer",
    "String",
    "Symbol",
    "SyntaxError",
    "TypeError",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "URIError",
    "WeakMap",
    "WeakRef",
    "WeakSet"
  ];
});

// ../node_modules/@babel/traverse/lib/scope/index.js
var Ph = D((hu) => {
  "use strict";
  Object.defineProperty(hu, "__esModule", {
    value: !0
  });
  hu.default = void 0;
  var gX = CE(), UE = nt(), Nwe = wE(), TX = DE(), $E = ce(), VE = $E, BE = Mn(), xX = OE(), EX = NE(), {
    assignmentExpression: SX,
    callExpression: kE,
    cloneNode: FE,
    getBindingIdentifiers: KE,
    identifier: qn,
    isArrayExpression: WE,
    isBinary: vX,
    isCallExpression: LE,
    isClass: PX,
    isClassBody: AX,
    isClassDeclaration: CX,
    isExportAllDeclaration: YE,
    isExportDefaultDeclaration: wX,
    isExportNamedDeclaration: xh,
    isFunctionDeclaration: DX,
    isIdentifier: Rn,
    isImportDeclaration: Eh,
    isLiteral: _X,
    isMemberExpression: IX,
    isMethod: OX,
    isModuleSpecifier: NX,
    isNullLiteral: BX,
    isObjectExpression: kX,
    isProperty: FX,
    isPureish: LX,
    isRegExpLiteral: jX,
    isSuper: MX,
    isTaggedTemplateExpression: RX,
    isTemplateLiteral: HE,
    isThisExpression: jE,
    isUnaryExpression: qX,
    isVariableDeclaration: UX,
    expressionStatement: $X,
    matchesPattern: ME,
    memberExpression: Sh,
    numericLiteral: VX,
    toIdentifier: KX,
    variableDeclaration: WX,
    variableDeclarator: YX,
    isRecordExpression: HX,
    isTupleExpression: JX,
    isObjectProperty: GX,
    isTopicReference: RE,
    isMetaProperty: XX,
    isPrivateName: zX,
    isExportDeclaration: QX,
    buildUndefinedNode: ZX,
    sequenceExpression: ez
  } = $E;
  function $e(e, t) {
    switch (e?.type) {
      default:
        if (Eh(e) || QX(e)) {
          var r;
          if ((YE(e) || xh(e) || Eh(e)) && e.source)
            $e(e.source, t);
          else if ((xh(e) || Eh(e)) && (r = e.specifiers) != null && r.length)
            for (let s of e.specifiers) $e(s, t);
          else (wX(e) || xh(e)) && e.declaration && $e(e.declaration, t);
        } else NX(e) ? $e(e.local, t) : _X(e) && !BX(e) && !jX(e) && !HE(e) && t.push(e.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        $e(e.object, t), $e(e.property, t);
        break;
      case "Identifier":
      case "JSXIdentifier":
        t.push(e.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        $e(e.callee, t);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        for (let s of e.properties)
          $e(s, t);
        break;
      case "SpreadElement":
      case "RestElement":
        $e(e.argument, t);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        $e(e.key, t);
        break;
      case "ThisExpression":
        t.push("this");
        break;
      case "Super":
        t.push("super");
        break;
      case "Import":
      case "ImportExpression":
        t.push("import");
        break;
      case "DoExpression":
        t.push("do");
        break;
      case "YieldExpression":
        t.push("yield"), $e(e.argument, t);
        break;
      case "AwaitExpression":
        t.push("await"), $e(e.argument, t);
        break;
      case "AssignmentExpression":
        $e(e.left, t);
        break;
      case "VariableDeclarator":
        $e(e.id, t);
        break;
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        $e(e.id, t);
        break;
      case "PrivateName":
        $e(e.id, t);
        break;
      case "ParenthesizedExpression":
        $e(e.expression, t);
        break;
      case "UnaryExpression":
      case "UpdateExpression":
        $e(e.argument, t);
        break;
      case "MetaProperty":
        $e(e.meta, t), $e(e.property, t);
        break;
      case "JSXElement":
        $e(e.openingElement, t);
        break;
      case "JSXOpeningElement":
        $e(e.name, t);
        break;
      case "JSXFragment":
        $e(e.openingFragment, t);
        break;
      case "JSXOpeningFragment":
        t.push("Fragment");
        break;
      case "JSXNamespacedName":
        $e(e.namespace, t), $e(e.name, t);
        break;
    }
  }
  i($e, "gatherNodeParts");
  function qE(e) {
    e.references = /* @__PURE__ */ Object.create(null), e.uids = /* @__PURE__ */ Object.create(null), e.bindings = /* @__PURE__ */ Object.create(
    null), e.globals = /* @__PURE__ */ Object.create(null);
  }
  i(qE, "resetScope");
  function tz(e) {
    return e.isFunctionExpression() && !e.node.id || e.isArrowFunctionExpression();
  }
  i(tz, "isAnonymousFunctionExpression");
  vh = Symbol.for("should not be considered a local binding");
  var vh, rz = {
    ForStatement(e) {
      let t = e.get("init");
      if (t.isVar()) {
        let {
          scope: r
        } = e;
        (r.getFunctionParent() || r.getProgramParent()).registerBinding("var", t);
      }
    },
    Declaration(e) {
      if (e.isBlockScoped() || e.isImportDeclaration() || e.isExportDeclaration()) return;
      (e.scope.getFunctionParent() || e.scope.getProgramParent()).registerDeclaration(e);
    },
    ImportDeclaration(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    TSImportEqualsDeclaration(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    ReferencedIdentifier(e, t) {
      VE.isTSQualifiedName(e.parent) && e.parent.right === e.node || e.parentPath.isTSImportEqualsDeclaration() || t.references.push(e);
    },
    ForXStatement(e, t) {
      let r = e.get("left");
      if (r.isPattern() || r.isIdentifier())
        t.constantViolations.push(e);
      else if (r.isVar()) {
        let {
          scope: s
        } = e;
        (s.getFunctionParent() || s.getProgramParent()).registerBinding("var", r);
      }
    },
    ExportDeclaration: {
      exit(e) {
        let {
          node: t,
          scope: r
        } = e;
        if (YE(t)) return;
        let s = t.declaration;
        if (CX(s) || DX(s)) {
          let n = s.id;
          if (!n) return;
          let a = r.getBinding(n.name);
          a?.reference(e);
        } else if (UX(s))
          for (let n of s.declarations)
            for (let a of Object.keys(KE(n))) {
              let o = r.getBinding(a);
              o?.reference(e);
            }
      }
    },
    LabeledStatement(e) {
      e.scope.getBlockParent().registerDeclaration(e);
    },
    AssignmentExpression(e, t) {
      t.assignments.push(e);
    },
    UpdateExpression(e, t) {
      t.constantViolations.push(e);
    },
    UnaryExpression(e, t) {
      e.node.operator === "delete" && t.constantViolations.push(e);
    },
    BlockScoped(e) {
      let t = e.scope;
      if (t.path === e && (t = t.parent), t.getBlockParent().registerDeclaration(e), e.isClassDeclaration() && e.node.id) {
        let n = e.node.id.name;
        e.scope.bindings[n] = e.scope.parent.getBinding(n);
      }
    },
    CatchClause(e) {
      e.scope.registerBinding("let", e);
    },
    Function(e) {
      let t = e.get("params");
      for (let r of t)
        e.scope.registerBinding("param", r);
      e.isFunctionExpression() && e.node.id && !e.node.id[vh] && e.scope.registerBinding("local", e.get("id"), e);
    },
    ClassExpression(e) {
      e.node.id && !e.node.id[vh] && e.scope.registerBinding("local", e.get("id"), e);
    },
    TSTypeAnnotation(e) {
      e.skip();
    }
  }, du, sz = 0, jr = class e {
    static {
      i(this, "Scope");
    }
    constructor(t) {
      this.uid = void 0, this.path = void 0, this.block = void 0, this.inited = void 0, this.labels = void 0, this.bindings = void 0, this.referencesSet =
      void 0, this.globals = void 0, this.uidsSet = void 0, this.data = void 0, this.crawling = void 0;
      let {
        node: r
      } = t, s = BE.scope.get(r);
      if (s?.path === t)
        return s;
      BE.scope.set(r, this), this.uid = sz++, this.block = r, this.path = t, this.labels = /* @__PURE__ */ new Map(), this.inited = !1, Object.
      defineProperties(this, {
        references: {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: /* @__PURE__ */ Object.create(null)
        },
        uids: {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: /* @__PURE__ */ Object.create(null)
        }
      });
    }
    get parent() {
      var t;
      let r, s = this.path;
      do {
        var n;
        let a = s.key === "key" || s.listKey === "decorators";
        s = s.parentPath, a && s.isMethod() && (s = s.parentPath), (n = s) != null && n.isScope() && (r = s);
      } while (s && !r);
      return (t = r) == null ? void 0 : t.scope;
    }
    get references() {
      throw new Error("Scope#references is not available in Babel 8. Use Scope#referencesSet instead.");
    }
    get uids() {
      throw new Error("Scope#uids is not available in Babel 8. Use Scope#uidsSet instead.");
    }
    generateDeclaredUidIdentifier(t) {
      let r = this.generateUidIdentifier(t);
      return this.push({
        id: r
      }), FE(r);
    }
    generateUidIdentifier(t) {
      return qn(this.generateUid(t));
    }
    generateUid(t = "temp") {
      t = KX(t).replace(/^_+/, "").replace(/\d+$/g, "");
      let r, s = 0;
      do
        r = `_${t}`, s >= 11 ? r += s - 1 : s >= 9 ? r += s - 9 : s >= 1 && (r += s + 1), s++;
      while (this.hasLabel(r) || this.hasBinding(r) || this.hasGlobal(r) || this.hasReference(r));
      let n = this.getProgramParent();
      return n.references[r] = !0, n.uids[r] = !0, r;
    }
    generateUidBasedOnNode(t, r) {
      let s = [];
      $e(t, s);
      let n = s.join("$");
      return n = n.replace(/^_/, "") || r || "ref", this.generateUid(n.slice(0, 20));
    }
    generateUidIdentifierBasedOnNode(t, r) {
      return qn(this.generateUidBasedOnNode(t, r));
    }
    isStatic(t) {
      if (jE(t) || MX(t) || RE(t))
        return !0;
      if (Rn(t)) {
        let r = this.getBinding(t.name);
        return r ? r.constant : this.hasBinding(t.name);
      }
      return !1;
    }
    maybeGenerateMemoised(t, r) {
      if (this.isStatic(t))
        return null;
      {
        let s = this.generateUidIdentifierBasedOnNode(t);
        return r ? s : (this.push({
          id: s
        }), FE(s));
      }
    }
    checkBlockScopedCollisions(t, r, s, n) {
      if (r === "param" || t.kind === "local") return;
      if (r === "let" || t.kind === "let" || t.kind === "const" || t.kind === "module" || t.kind === "param" && r === "const")
        throw this.path.hub.buildError(n, `Duplicate declaration "${s}"`, TypeError);
    }
    rename(t, r) {
      let s = this.getBinding(t);
      s && (r || (r = this.generateUidIdentifier(t).name), new gX.default(s, t, r).rename(arguments[2]));
    }
    dump() {
      let t = "-".repeat(60);
      console.log(t);
      let r = this;
      do {
        console.log("#", r.block.type);
        for (let s of Object.keys(r.bindings)) {
          let n = r.bindings[s];
          console.log(" -", s, {
            constant: n.constant,
            references: n.references,
            violations: n.constantViolations.length,
            kind: n.kind
          });
        }
      } while (r = r.parent);
      console.log(t);
    }
    hasLabel(t) {
      return !!this.getLabel(t);
    }
    getLabel(t) {
      return this.labels.get(t);
    }
    registerLabel(t) {
      this.labels.set(t.node.label.name, t);
    }
    registerDeclaration(t) {
      if (t.isLabeledStatement())
        this.registerLabel(t);
      else if (t.isFunctionDeclaration())
        this.registerBinding("hoisted", t.get("id"), t);
      else if (t.isVariableDeclaration()) {
        let r = t.get("declarations"), {
          kind: s
        } = t.node;
        for (let n of r)
          this.registerBinding(s === "using" || s === "await using" ? "const" : s, n);
      } else if (t.isClassDeclaration()) {
        if (t.node.declare) return;
        this.registerBinding("let", t);
      } else if (t.isImportDeclaration()) {
        let r = t.node.importKind === "type" || t.node.importKind === "typeof", s = t.get("specifiers");
        for (let n of s) {
          let a = r || n.isImportSpecifier() && (n.node.importKind === "type" || n.node.importKind === "typeof");
          this.registerBinding(a ? "unknown" : "module", n);
        }
      } else if (t.isExportDeclaration()) {
        let r = t.get("declaration");
        (r.isClassDeclaration() || r.isFunctionDeclaration() || r.isVariableDeclaration()) && this.registerDeclaration(r);
      } else
        this.registerBinding("unknown", t);
    }
    buildUndefinedNode() {
      return ZX();
    }
    registerConstantViolation(t) {
      let r = t.getAssignmentIdentifiers();
      for (let n of Object.keys(r)) {
        var s;
        (s = this.getBinding(n)) == null || s.reassign(t);
      }
    }
    registerBinding(t, r, s = r) {
      if (!t) throw new ReferenceError("no `kind`");
      if (r.isVariableDeclaration()) {
        let o = r.get("declarations");
        for (let l of o)
          this.registerBinding(t, l);
        return;
      }
      let n = this.getProgramParent(), a = r.getOuterBindingIdentifiers(!0);
      for (let o of Object.keys(a)) {
        n.references[o] = !0;
        for (let l of a[o]) {
          let u = this.getOwnBinding(o);
          if (u) {
            if (u.identifier === l) continue;
            this.checkBlockScopedCollisions(u, t, o, l);
          }
          u ? u.reassign(s) : this.bindings[o] = new TX.default({
            identifier: l,
            scope: this,
            path: s,
            kind: t
          });
        }
      }
    }
    addGlobal(t) {
      this.globals[t.name] = t;
    }
    hasUid(t) {
      {
        let r = this;
        do
          if (r.uids[t]) return !0;
        while (r = r.parent);
        return !1;
      }
    }
    hasGlobal(t) {
      let r = this;
      do
        if (r.globals[t]) return !0;
      while (r = r.parent);
      return !1;
    }
    hasReference(t) {
      return !!this.getProgramParent().references[t];
    }
    isPure(t, r) {
      if (Rn(t)) {
        let o = this.getBinding(t.name);
        return o ? r ? o.constant : !0 : !1;
      } else {
        if (jE(t) || XX(t) || RE(t) || zX(t))
          return !0;
        if (PX(t)) {
          var s;
          return t.superClass && !this.isPure(t.superClass, r) || ((s = t.decorators) == null ? void 0 : s.length) > 0 ? !1 : this.isPure(t.
          body, r);
        } else if (AX(t)) {
          for (let o of t.body)
            if (!this.isPure(o, r)) return !1;
          return !0;
        } else {
          if (vX(t))
            return this.isPure(t.left, r) && this.isPure(t.right, r);
          if (WE(t) || JX(t)) {
            for (let o of t.elements)
              if (o !== null && !this.isPure(o, r)) return !1;
            return !0;
          } else if (kX(t) || HX(t)) {
            for (let o of t.properties)
              if (!this.isPure(o, r)) return !1;
            return !0;
          } else if (OX(t)) {
            var n;
            return !(t.computed && !this.isPure(t.key, r) || ((n = t.decorators) == null ? void 0 : n.length) > 0);
          } else if (FX(t)) {
            var a;
            return !(t.computed && !this.isPure(t.key, r) || ((a = t.decorators) == null ? void 0 : a.length) > 0 || (GX(t) || t.static) && t.
            value !== null && !this.isPure(t.value, r));
          } else {
            if (qX(t))
              return this.isPure(t.argument, r);
            if (HE(t)) {
              for (let o of t.expressions)
                if (!this.isPure(o, r)) return !1;
              return !0;
            } else return RX(t) ? ME(t.tag, "String.raw") && !this.hasBinding("String", {
              noGlobals: !0
            }) && this.isPure(t.quasi, r) : IX(t) ? !t.computed && Rn(t.object) && t.object.name === "Symbol" && Rn(t.property) && t.property.
            name !== "for" && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) : LE(t) ? ME(t.callee, "Symbol.for") && !this.hasBinding("Symbol", {
              noGlobals: !0
            }) && t.arguments.length === 1 && VE.isStringLiteral(t.arguments[0]) : LX(t);
          }
        }
      }
    }
    setData(t, r) {
      return this.data[t] = r;
    }
    getData(t) {
      let r = this;
      do {
        let s = r.data[t];
        if (s != null) return s;
      } while (r = r.parent);
    }
    removeData(t) {
      let r = this;
      do
        r.data[t] != null && (r.data[t] = null);
      while (r = r.parent);
    }
    init() {
      this.inited || (this.inited = !0, this.crawl());
    }
    crawl() {
      let t = this.path;
      qE(this), this.data = /* @__PURE__ */ Object.create(null);
      let r = this;
      do {
        if (r.crawling) return;
        if (r.path.isProgram())
          break;
      } while (r = r.parent);
      let s = r, n = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      if (this.crawling = !0, du || (du = UE.default.visitors.merge([{
        Scope(a) {
          qE(a.scope);
        }
      }, rz])), t.type !== "Program") {
        let a = du[t.type];
        if (a)
          for (let o of a.enter)
            o.call(n, t, n);
      }
      t.traverse(du, n), this.crawling = !1;
      for (let a of n.assignments) {
        let o = a.getAssignmentIdentifiers();
        for (let l of Object.keys(o))
          a.scope.getBinding(l) || s.addGlobal(o[l]);
        a.scope.registerConstantViolation(a);
      }
      for (let a of n.references) {
        let o = a.scope.getBinding(a.node.name);
        o ? o.reference(a) : s.addGlobal(a.node);
      }
      for (let a of n.constantViolations)
        a.scope.registerConstantViolation(a);
    }
    push(t) {
      let r = this.path;
      r.isPattern() ? r = this.getPatternParent().path : !r.isBlockStatement() && !r.isProgram() && (r = this.getBlockParent().path), r.isSwitchStatement() &&
      (r = (this.getFunctionParent() || this.getProgramParent()).path);
      let {
        init: s,
        unique: n,
        kind: a = "var",
        id: o
      } = t;
      if (!s && !n && (a === "var" || a === "let") && tz(r) && LE(r.parent, {
        callee: r.node
      }) && r.parent.arguments.length <= r.node.params.length && Rn(o)) {
        r.pushContainer("params", o), r.scope.registerBinding("param", r.get("params")[r.node.params.length - 1]);
        return;
      }
      (r.isLoop() || r.isCatchClause() || r.isFunction()) && (r.ensureBlock(), r = r.get("body"));
      let l = t._blockHoist == null ? 2 : t._blockHoist, u = `declaration:${a}:${l}`, c = !n && r.getData(u);
      if (!c) {
        let h = WX(a, []);
        h._blockHoist = l, [c] = r.unshiftContainer("body", [h]), n || r.setData(u, c);
      }
      let p = YX(o, s), f = c.node.declarations.push(p);
      r.scope.registerBinding(a, c.get("declarations")[f - 1]);
    }
    getProgramParent() {
      let t = this;
      do
        if (t.path.isProgram())
          return t;
      while (t = t.parent);
      throw new Error("Couldn't find a Program");
    }
    getFunctionParent() {
      let t = this;
      do
        if (t.path.isFunctionParent())
          return t;
      while (t = t.parent);
      return null;
    }
    getBlockParent() {
      let t = this;
      do
        if (t.path.isBlockParent())
          return t;
      while (t = t.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getPatternParent() {
      let t = this;
      do
        if (!t.path.isPattern())
          return t.getBlockParent();
      while (t = t.parent.parent);
      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    }
    getAllBindings() {
      let t = /* @__PURE__ */ Object.create(null), r = this;
      do {
        for (let s of Object.keys(r.bindings))
          s in t || (t[s] = r.bindings[s]);
        r = r.parent;
      } while (r);
      return t;
    }
    bindingIdentifierEquals(t, r) {
      return this.getBindingIdentifier(t) === r;
    }
    getBinding(t) {
      let r = this, s;
      do {
        let a = r.getOwnBinding(t);
        if (a) {
          var n;
          if (!((n = s) != null && n.isPattern() && a.kind !== "param" && a.kind !== "local"))
            return a;
        } else if (!a && t === "arguments" && r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
        s = r.path;
      } while (r = r.parent);
    }
    getOwnBinding(t) {
      return this.bindings[t];
    }
    getBindingIdentifier(t) {
      var r;
      return (r = this.getBinding(t)) == null ? void 0 : r.identifier;
    }
    getOwnBindingIdentifier(t) {
      let r = this.bindings[t];
      return r?.identifier;
    }
    hasOwnBinding(t) {
      return !!this.getOwnBinding(t);
    }
    hasBinding(t, r) {
      if (!t) return !1;
      let s, n, a;
      typeof r == "object" ? (s = r.noGlobals, n = r.noUids, a = r.upToScope) : typeof r == "boolean" && (s = r);
      let o = this;
      do {
        if (a === o)
          break;
        if (o.hasOwnBinding(t))
          return !0;
      } while (o = o.parent);
      return !!(!n && this.hasUid(t) || !s && e.globals.includes(t) || !s && e.contextVariables.includes(t));
    }
    parentHasBinding(t, r) {
      var s;
      return (s = this.parent) == null ? void 0 : s.hasBinding(t, r);
    }
    moveBindingTo(t, r) {
      let s = this.getBinding(t);
      s && (s.scope.removeOwnBinding(t), s.scope = r, r.bindings[t] = s);
    }
    removeOwnBinding(t) {
      delete this.bindings[t];
    }
    removeBinding(t) {
      var r;
      (r = this.getBinding(t)) == null || r.scope.removeOwnBinding(t);
      {
        let s = this;
        do
          s.uids[t] && (s.uids[t] = !1);
        while (s = s.parent);
      }
    }
    hoistVariables(t = (r) => this.push({
      id: r
    })) {
      this.crawl();
      let r = /* @__PURE__ */ new Set();
      for (let s of Object.keys(this.bindings)) {
        let n = this.bindings[s];
        if (!n) continue;
        let {
          path: a
        } = n;
        if (!a.isVariableDeclarator()) continue;
        let {
          parent: o,
          parentPath: l
        } = a;
        if (o.kind !== "var" || r.has(o)) continue;
        r.add(a.parent);
        let u, c = [];
        for (let p of o.declarations) {
          u ?? (u = p.id), p.init && c.push(SX("=", p.id, p.init));
          let f = Object.keys(KE(p, !1, !0, !0));
          for (let h of f)
            t(qn(h), p.init != null);
        }
        if (l.parentPath.isForXStatement({
          left: o
        }))
          l.replaceWith(u);
        else if (c.length === 0)
          l.remove();
        else {
          let p = c.length === 1 ? c[0] : ez(c);
          l.parentPath.isForStatement({
            init: o
          }) ? l.replaceWith(p) : l.replaceWith($X(p));
        }
      }
    }
  };
  hu.default = jr;
  jr.globals = [...xX, ...EX];
  jr.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
  jr.prototype._renameFromMap = /* @__PURE__ */ i(function(t, r, s, n) {
    t[r] && (t[s] = n, t[r] = null);
  }, "_renameFromMap"), jr.prototype.traverse = function(e, t, r) {
    (0, UE.default)(e, t, this, r, this.path);
  }, jr.prototype._generateUid = /* @__PURE__ */ i(function(t, r) {
    let s = t;
    return r > 1 && (s += r), `_${s}`;
  }, "_generateUid"), jr.prototype.toArray = /* @__PURE__ */ i(function(t, r, s) {
    if (Rn(t)) {
      let o = this.getBinding(t.name);
      if (o != null && o.constant && o.path.isGenericType("Array"))
        return t;
    }
    if (WE(t))
      return t;
    if (Rn(t, {
      name: "arguments"
    }))
      return kE(Sh(Sh(Sh(qn("Array"), qn("prototype")), qn("slice")), qn("call")), [t]);
    let n, a = [t];
    return r === !0 ? n = "toConsumableArray" : typeof r == "number" ? (a.push(VX(r)), n = "slicedToArray") : n = "toArray", s && (a.unshift(
    this.path.hub.addHelper(n)), n = "maybeArrayLike"), kE(this.path.hub.addHelper(n), a);
  }, "toArray"), jr.prototype.getAllBindingsOfKind = /* @__PURE__ */ i(function(...t) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let s of t) {
      let n = this;
      do {
        for (let a of Object.keys(n.bindings)) {
          let o = n.bindings[a];
          o.kind === s && (r[a] = o);
        }
        n = n.parent;
      } while (n);
    }
    return r;
  }, "getAllBindingsOfKind"), Object.defineProperties(jr.prototype, {
    parentBlock: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.parent;
      }
    },
    hub: {
      configurable: !0,
      enumerable: !0,
      get() {
        return this.path.hub;
      }
    }
  });
});

// ../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
function io(e, t) {
  let r = 0, s = 0, n = 0;
  do {
    let o = e.next();
    n = eS[o], r |= (n & 31) << s, s += 5;
  } while (n & 32);
  let a = r & 1;
  return r >>>= 1, a && (r = -2147483648 | -r), t + r;
}
function ao(e, t, r) {
  let s = t - r;
  s = s < 0 ? -s << 1 | 1 : s << 1;
  do {
    let n = s & 31;
    s >>>= 5, s > 0 && (n |= 32), e.write(ZE[n]);
  } while (s > 0);
  return t;
}
function GE(e, t) {
  return e.pos >= t ? !1 : e.peek() !== QE;
}
function tS(e) {
  let { length: t } = e, r = new az(e), s = [], n = 0, a = 0, o = 0, l = 0, u = 0;
  do {
    let c = r.indexOf(";"), p = [], f = !0, h = 0;
    for (n = 0; r.pos < c; ) {
      let b;
      n = io(r, n), n < h && (f = !1), h = n, GE(r, c) ? (a = io(r, a), o = io(r, o), l = io(r, l), GE(r, c) ? (u = io(r, u), b = [n, a, o, l,
      u]) : b = [n, a, o, l]) : b = [n], p.push(b), r.pos++;
    }
    f || oz(p), s.push(p), r.pos = c + 1;
  } while (r.pos <= t);
  return s;
}
function oz(e) {
  e.sort(lz);
}
function lz(e, t) {
  return e[0] - t[0];
}
function mu(e) {
  let t = new iz(), r = 0, s = 0, n = 0, a = 0;
  for (let o = 0; o < e.length; o++) {
    let l = e[o];
    if (o > 0 && t.write(nz), l.length === 0) continue;
    let u = 0;
    for (let c = 0; c < l.length; c++) {
      let p = l[c];
      c > 0 && t.write(QE), u = ao(t, p[0], u), p.length !== 1 && (r = ao(t, p[1], r), s = ao(t, p[2], s), n = ao(t, p[3], n), p.length !== 4 &&
      (a = ao(t, p[4], a)));
    }
  }
  return t.flush();
}
var QE, nz, JE, ZE, eS, XE, zE, iz, az, Ah = hl(() => {
  QE = 44, nz = 59, JE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ZE = new Uint8Array(64), eS = new Uint8Array(128);
  for (let e = 0; e < JE.length; e++) {
    let t = JE.charCodeAt(e);
    ZE[e] = t, eS[t] = e;
  }
  i(io, "decodeInteger");
  i(ao, "encodeInteger");
  i(GE, "hasMoreVlq");
  XE = 1024 * 16, zE = typeof TextDecoder < "u" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer < "u" ? {
    decode(e) {
      return Buffer.from(e.buffer, e.byteOffset, e.byteLength).toString();
    }
  } : {
    decode(e) {
      let t = "";
      for (let r = 0; r < e.length; r++)
        t += String.fromCharCode(e[r]);
      return t;
    }
  }, iz = class {
    static {
      i(this, "StringWriter");
    }
    constructor() {
      this.pos = 0, this.out = "", this.buffer = new Uint8Array(XE);
    }
    write(e) {
      let { buffer: t } = this;
      t[this.pos++] = e, this.pos === XE && (this.out += zE.decode(t), this.pos = 0);
    }
    flush() {
      let { buffer: e, out: t, pos: r } = this;
      return r > 0 ? t + zE.decode(e.subarray(0, r)) : t;
    }
  }, az = class {
    static {
      i(this, "StringReader");
    }
    constructor(e) {
      this.pos = 0, this.buffer = e;
    }
    next() {
      return this.buffer.charCodeAt(this.pos++);
    }
    peek() {
      return this.buffer.charCodeAt(this.pos);
    }
    indexOf(e) {
      let { buffer: t, pos: r } = this, s = t.indexOf(e, r);
      return s === -1 ? t.length : s;
    }
  };
  i(tS, "decode");
  i(oz, "sort");
  i(lz, "sortComparator");
  i(mu, "encode");
});

// ../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var rS = D((Ch, wh) => {
  (function(e, t) {
    typeof Ch == "object" && typeof wh < "u" ? wh.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = typeof globalThis <
    "u" ? globalThis : e || self, e.resolveURI = t());
  })(Ch, function() {
    "use strict";
    let e = /^[\w+.-]+:\/\//, t = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/, r = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
    function s(g) {
      return e.test(g);
    }
    i(s, "isAbsoluteUrl");
    function n(g) {
      return g.startsWith("//");
    }
    i(n, "isSchemeRelativeUrl");
    function a(g) {
      return g.startsWith("/");
    }
    i(a, "isAbsolutePath");
    function o(g) {
      return g.startsWith("file:");
    }
    i(o, "isFileUrl");
    function l(g) {
      return /^[.?#]/.test(g);
    }
    i(l, "isRelative");
    function u(g) {
      let E = t.exec(g);
      return p(E[1], E[2] || "", E[3], E[4] || "", E[5] || "/", E[6] || "", E[7] || "");
    }
    i(u, "parseAbsoluteUrl");
    function c(g) {
      let E = r.exec(g), _ = E[2];
      return p("file:", "", E[1] || "", "", a(_) ? _ : "/" + _, E[3] || "", E[4] || "");
    }
    i(c, "parseFileUrl");
    function p(g, E, _, N, k, j, U) {
      return {
        scheme: g,
        user: E,
        host: _,
        port: N,
        path: k,
        query: j,
        hash: U,
        type: 7
      };
    }
    i(p, "makeUrl");
    function f(g) {
      if (n(g)) {
        let _ = u("http:" + g);
        return _.scheme = "", _.type = 6, _;
      }
      if (a(g)) {
        let _ = u("http://foo.com" + g);
        return _.scheme = "", _.host = "", _.type = 5, _;
      }
      if (o(g))
        return c(g);
      if (s(g))
        return u(g);
      let E = u("http://foo.com/" + g);
      return E.scheme = "", E.host = "", E.type = g ? g.startsWith("?") ? 3 : g.startsWith("#") ? 2 : 4 : 1, E;
    }
    i(f, "parseUrl");
    function h(g) {
      if (g.endsWith("/.."))
        return g;
      let E = g.lastIndexOf("/");
      return g.slice(0, E + 1);
    }
    i(h, "stripPathFilename");
    function b(g, E) {
      T(E, E.type), g.path === "/" ? g.path = E.path : g.path = h(E.path) + g.path;
    }
    i(b, "mergePaths");
    function T(g, E) {
      let _ = E <= 4, N = g.path.split("/"), k = 1, j = 0, U = !1;
      for (let K = 1; K < N.length; K++) {
        let G = N[K];
        if (!G) {
          U = !0;
          continue;
        }
        if (U = !1, G !== ".") {
          if (G === "..") {
            j ? (U = !0, j--, k--) : _ && (N[k++] = G);
            continue;
          }
          N[k++] = G, j++;
        }
      }
      let M = "";
      for (let K = 1; K < k; K++)
        M += "/" + N[K];
      (!M || U && !M.endsWith("/..")) && (M += "/"), g.path = M;
    }
    i(T, "normalizePath");
    function d(g, E) {
      if (!g && !E)
        return "";
      let _ = f(g), N = _.type;
      if (E && N !== 7) {
        let j = f(E), U = j.type;
        switch (N) {
          case 1:
            _.hash = j.hash;
          // fall through
          case 2:
            _.query = j.query;
          // fall through
          case 3:
          case 4:
            b(_, j);
          // fall through
          case 5:
            _.user = j.user, _.host = j.host, _.port = j.port;
          // fall through
          case 6:
            _.scheme = j.scheme;
        }
        U > N && (N = U);
      }
      T(_, N);
      let k = _.query + _.hash;
      switch (N) {
        // This is impossible, because of the empty checks at the start of the function.
        // case UrlType.Empty:
        case 2:
        case 3:
          return k;
        case 4: {
          let j = _.path.slice(1);
          return j ? l(E || g) && !l(j) ? "./" + j + k : j + k : k || ".";
        }
        case 5:
          return _.path + k;
        default:
          return _.scheme + "//" + _.user + _.host + _.port + _.path + k;
      }
    }
    return i(d, "resolve"), d;
  });
});

// ../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
var TS = {};
sf(TS, {
  AnyMap: () => bz,
  FlattenMap: () => bz,
  GREATEST_LOWER_BOUND: () => uo,
  LEAST_UPPER_BOUND: () => lo,
  TraceMap: () => Ts,
  allGeneratedPositionsFor: () => Sz,
  decodedMap: () => Cz,
  decodedMappings: () => Rr,
  eachMapping: () => vz,
  encodedMap: () => wz,
  encodedMappings: () => mS,
  generatedPositionFor: () => Ez,
  isIgnored: () => Az,
  originalPositionFor: () => xz,
  presortedDecodedMap: () => bS,
  sourceContentFor: () => Pz,
  traceSegment: () => Bh
});
function uz(e) {
  if (!e) return "";
  let t = e.lastIndexOf("/");
  return e.slice(0, t + 1);
}
function cz(e, t) {
  let r = uz(e), s = t ? t + "/" : "";
  return (n) => (0, nS.default)(s + (n || ""), r);
}
function pz(e, t) {
  let r = sS(e, 0);
  if (r === e.length) return e;
  t || (e = e.slice());
  for (let s = r; s < e.length; s = sS(e, s + 1))
    e[s] = dz(e[s], t);
  return e;
}
function sS(e, t) {
  for (let r = t; r < e.length; r++)
    if (!fz(e[r])) return r;
  return e.length;
}
function fz(e) {
  for (let t = 1; t < e.length; t++)
    if (e[t][Mr] < e[t - 1][Mr])
      return !1;
  return !0;
}
function dz(e, t) {
  return t || (e = e.slice()), e.sort(lS);
}
function lS(e, t) {
  return e[Mr] - t[Mr];
}
function hz(e, t) {
  let r = t.map(() => []);
  for (let s = 0; s < e.length; s++) {
    let n = e[s];
    for (let a = 0; a < n.length; a++) {
      let o = n[a];
      if (o.length === 1) continue;
      let l = o[_h], u = o[Ih], c = o[Oh], p = r[l];
      (p[u] || (p[u] = [])).push([c, s, o[Mr]]);
    }
  }
  for (let s = 0; s < r.length; s++) {
    let n = r[s];
    for (let a = 0; a < n.length; a++) {
      let o = n[a];
      o && o.sort(lS);
    }
  }
  return r;
}
function mz(e, t, r, s) {
  for (; r <= s; ) {
    let n = r + (s - r >> 1), a = e[n][Mr] - t;
    if (a === 0)
      return Un = !0, n;
    a < 0 ? r = n + 1 : s = n - 1;
  }
  return Un = !1, r - 1;
}
function uS(e, t, r) {
  for (let s = r + 1; s < e.length && e[s][Mr] === t; r = s++)
    ;
  return r;
}
function cS(e, t, r) {
  for (let s = r - 1; s >= 0 && e[s][Mr] === t; r = s--)
    ;
  return r;
}
function pS() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function yz(e, t, r, s) {
  let { lastKey: n, lastNeedle: a, lastIndex: o } = r, l = 0, u = e.length - 1;
  if (s === n) {
    if (t === a)
      return Un = o !== -1 && e[o][Mr] === t, o;
    t >= a ? l = o === -1 ? 0 : o : u = o;
  }
  return r.lastKey = s, r.lastNeedle = t, r.lastIndex = mz(e, t, l, u);
}
function Nh(e) {
  return typeof e == "string" ? JSON.parse(e) : e;
}
function fS(e, t, r, s, n, a, o, l, u, c, p) {
  let { sections: f } = e;
  for (let h = 0; h < f.length; h++) {
    let { map: b, offset: T } = f[h], d = c, g = p;
    if (h + 1 < f.length) {
      let E = f[h + 1].offset;
      d = Math.min(c, l + E.line), d === c ? g = Math.min(p, u + E.column) : d < c && (g = u + E.column);
    }
    gz(
      b,
      t,
      r,
      s,
      n,
      a,
      o,
      l + T.line,
      u + T.column,
      d,
      g
    );
  }
}
function gz(e, t, r, s, n, a, o, l, u, c, p) {
  let f = Nh(e);
  if ("sections" in f) return fS(...arguments);
  let h = new Ts(f, t), b = s.length, T = a.length, d = Rr(h), { resolvedSources: g, sourcesContent: E, ignoreList: _ } = h;
  if (Dh(s, g), Dh(a, h.names), E) Dh(n, E);
  else for (let N = 0; N < g.length; N++) n.push(null);
  if (_) for (let N = 0; N < _.length; N++) o.push(_[N] + b);
  for (let N = 0; N < d.length; N++) {
    let k = l + N;
    if (k > c) return;
    let j = Tz(r, k), U = N === 0 ? u : 0, M = d[N];
    for (let K = 0; K < M.length; K++) {
      let G = M[K], ue = U + G[Mr];
      if (k === c && ue >= p) return;
      if (G.length === 1) {
        j.push([ue]);
        continue;
      }
      let te = b + G[_h], De = G[Ih], je = G[Oh];
      j.push(
        G.length === 4 ? [ue, te, De, je] : [ue, te, De, je, T + G[iS]]
      );
    }
  }
}
function Dh(e, t) {
  for (let r = 0; r < t.length; r++) e.push(t[r]);
}
function Tz(e, t) {
  for (let r = e.length; r <= t; r++) e[r] = [];
  return e[t];
}
function mS(e) {
  var t, r;
  return (r = (t = e)._encoded) != null ? r : t._encoded = mu(e._decoded);
}
function Rr(e) {
  var t;
  return (t = e)._decoded || (t._decoded = tS(e._encoded));
}
function Bh(e, t, r) {
  let s = Rr(e);
  if (t >= s.length) return null;
  let n = s[t], a = bu(
    n,
    e._decodedMemo,
    t,
    r,
    uo
  );
  return a === -1 ? null : n[a];
}
function xz(e, t) {
  let { line: r, column: s, bias: n } = t;
  if (r--, r < 0) throw new Error(dS);
  if (s < 0) throw new Error(hS);
  let a = Rr(e);
  if (r >= a.length) return yu(null, null, null, null);
  let o = a[r], l = bu(
    o,
    e._decodedMemo,
    r,
    s,
    n || uo
  );
  if (l === -1) return yu(null, null, null, null);
  let u = o[l];
  if (u.length === 1) return yu(null, null, null, null);
  let { names: c, resolvedSources: p } = e;
  return yu(
    p[u[_h]],
    u[Ih] + 1,
    u[Oh],
    u.length === 5 ? c[u[iS]] : null
  );
}
function Ez(e, t) {
  let { source: r, line: s, column: n, bias: a } = t;
  return gS(e, r, s, n, a || uo, !1);
}
function Sz(e, t) {
  let { source: r, line: s, column: n, bias: a } = t;
  return gS(e, r, s, n, a || lo, !0);
}
function vz(e, t) {
  let r = Rr(e), { names: s, resolvedSources: n } = e;
  for (let a = 0; a < r.length; a++) {
    let o = r[a];
    for (let l = 0; l < o.length; l++) {
      let u = o[l], c = a + 1, p = u[0], f = null, h = null, b = null, T = null;
      u.length !== 1 && (f = n[u[1]], h = u[2] + 1, b = u[3]), u.length === 5 && (T = s[u[4]]), t({
        generatedLine: c,
        generatedColumn: p,
        source: f,
        originalLine: h,
        originalColumn: b,
        name: T
      });
    }
  }
}
function yS(e, t) {
  let { sources: r, resolvedSources: s } = e, n = r.indexOf(t);
  return n === -1 && (n = s.indexOf(t)), n;
}
function Pz(e, t) {
  let { sourcesContent: r } = e;
  if (r == null) return null;
  let s = yS(e, t);
  return s === -1 ? null : r[s];
}
function Az(e, t) {
  let { ignoreList: r } = e;
  if (r == null) return !1;
  let s = yS(e, t);
  return s === -1 ? !1 : r.includes(s);
}
function bS(e, t) {
  let r = new Ts(kh(e, []), t);
  return r._decoded = e.mappings, r;
}
function Cz(e) {
  return kh(e, Rr(e));
}
function wz(e) {
  return kh(e, mS(e));
}
function kh(e, t) {
  return {
    version: e.version,
    file: e.file,
    names: e.names,
    sourceRoot: e.sourceRoot,
    sources: e.sources,
    sourcesContent: e.sourcesContent,
    mappings: t,
    ignoreList: e.ignoreList || e.x_google_ignoreList
  };
}
function yu(e, t, r, s) {
  return { source: e, line: t, column: r, name: s };
}
function oo(e, t) {
  return { line: e, column: t };
}
function bu(e, t, r, s, n) {
  let a = yz(e, s, t, r);
  return Un ? a = (n === lo ? uS : cS)(e, s, a) : n === lo && a++, a === -1 || a === e.length ? -1 : a;
}
function Dz(e, t, r, s, n) {
  let a = bu(e, t, r, s, uo);
  if (!Un && n === lo && a++, a === -1 || a === e.length) return [];
  let o = Un ? s : e[a][Mr];
  Un || (a = cS(e, o, a));
  let l = uS(e, o, a), u = [];
  for (; a <= l; a++) {
    let c = e[a];
    u.push(oo(c[aS] + 1, c[oS]));
  }
  return u;
}
function gS(e, t, r, s, n, a) {
  var o, l;
  if (r--, r < 0) throw new Error(dS);
  if (s < 0) throw new Error(hS);
  let { sources: u, resolvedSources: c } = e, p = u.indexOf(t);
  if (p === -1 && (p = c.indexOf(t)), p === -1) return a ? [] : oo(null, null);
  let f = (o = e)._bySourceMemos || (o._bySourceMemos = u.map(pS)), b = ((l = e)._bySources || (l._bySources = hz(Rr(e), f)))[p][r];
  if (b == null) return a ? [] : oo(null, null);
  let T = f[p];
  if (a) return Dz(b, T, r, s, n);
  let d = bu(b, T, r, s, n);
  if (d === -1) return oo(null, null);
  let g = b[d];
  return oo(g[aS] + 1, g[oS]);
}
var nS, Mr, _h, Ih, Oh, iS, aS, oS, Un, bz, dS, hS, lo, uo, Ts, co = hl(() => {
  Ah();
  nS = ms(rS(), 1);
  i(uz, "stripFilename");
  i(cz, "resolver");
  Mr = 0, _h = 1, Ih = 2, Oh = 3, iS = 4, aS = 1, oS = 2;
  i(pz, "maybeSort");
  i(sS, "nextUnsortedSegmentLine");
  i(fz, "isSorted");
  i(dz, "sortSegments");
  i(lS, "sortComparator");
  i(hz, "buildBySources");
  Un = !1;
  i(mz, "binarySearch");
  i(uS, "upperBound");
  i(cS, "lowerBound");
  i(pS, "memoizedState");
  i(yz, "memoizedBinarySearch");
  i(Nh, "parse");
  bz = /* @__PURE__ */ i(function(e, t) {
    let r = Nh(e);
    if (!("sections" in r))
      return new Ts(r, t);
    let s = [], n = [], a = [], o = [], l = [];
    fS(
      r,
      t,
      s,
      n,
      a,
      o,
      l,
      0,
      0,
      1 / 0,
      1 / 0
    );
    let u = {
      version: 3,
      file: r.file,
      names: o,
      sources: n,
      sourcesContent: a,
      mappings: s,
      ignoreList: l
    };
    return bS(u);
  }, "FlattenMap");
  i(fS, "recurse");
  i(gz, "addSection");
  i(Dh, "append");
  i(Tz, "getLine");
  dS = "`line` must be greater than 0 (lines start at line 1)", hS = "`column` must be greater than or equal to 0 (columns start at column 0\
)", lo = -1, uo = 1, Ts = class {
    static {
      i(this, "TraceMap");
    }
    constructor(e, t) {
      let r = typeof e == "string";
      if (!r && e._decodedMemo) return e;
      let s = Nh(e), { version: n, file: a, names: o, sourceRoot: l, sources: u, sourcesContent: c } = s;
      this.version = n, this.file = a, this.names = o || [], this.sourceRoot = l, this.sources = u, this.sourcesContent = c, this.ignoreList =
      s.ignoreList || s.x_google_ignoreList || void 0;
      let p = cz(t, l);
      this.resolvedSources = u.map(p);
      let { mappings: f } = s;
      if (typeof f == "string")
        this._encoded = f, this._decoded = void 0;
      else if (Array.isArray(f))
        this._encoded = void 0, this._decoded = pz(f, r);
      else throw s.sections ? new Error("TraceMap passed sectioned source map, please use FlattenMap export instead") : new Error(`invalid s\
ource map: ${JSON.stringify(s)}`);
      this._decodedMemo = pS(), this._bySources = void 0, this._bySourceMemos = void 0;
    }
  };
  i(mS, "encodedMappings");
  i(Rr, "decodedMappings");
  i(Bh, "traceSegment");
  i(xz, "originalPositionFor");
  i(Ez, "generatedPositionFor");
  i(Sz, "allGeneratedPositionsFor");
  i(vz, "eachMapping");
  i(yS, "sourceIndex");
  i(Pz, "sourceContentFor");
  i(Az, "isIgnored");
  i(bS, "presortedDecodedMap");
  i(Cz, "decodedMap");
  i(wz, "encodedMap");
  i(kh, "clone");
  i(yu, "OMapping");
  i(oo, "GMapping");
  i(bu, "traceSegmentInternal");
  i(Dz, "sliceGeneratedPositions");
  i(gS, "generatedPosition");
});

// ../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs
var _S = {};
sf(_S, {
  GenMapping: () => Tu,
  addMapping: () => Oz,
  addSegment: () => Iz,
  allMappings: () => kz,
  fromMap: () => Bz,
  maybeAddMapping: () => Nz,
  maybeAddSegment: () => jh,
  setIgnore: () => Rh,
  setSourceContent: () => Mh,
  toDecodedMap: () => xu,
  toEncodedMap: () => qh
});
function ES(e, t) {
  return e._indexes[t];
}
function ki(e, t) {
  let r = ES(e, t);
  if (r !== void 0) return r;
  let { array: s, _indexes: n } = e, a = s.push(t);
  return n[t] = a - 1;
}
function _z(e, t) {
  let r = ES(e, t);
  if (r === void 0) return;
  let { array: s, _indexes: n } = e;
  for (let a = r + 1; a < s.length; a++) {
    let o = s[a];
    s[a - 1] = o, n[o]--;
  }
  n[t] = void 0, s.pop();
}
function Iz(e, t, r, s, n, a, o, l) {
  return gu(
    !1,
    e,
    t,
    r,
    s,
    n,
    a,
    o,
    l
  );
}
function Oz(e, t) {
  return DS(!1, e, t);
}
function Mh(e, t, r) {
  let {
    _sources: s,
    _sourcesContent: n
    // _originalScopes: originalScopes,
  } = e, a = ki(s, t);
  n[a] = r;
}
function Rh(e, t, r = !0) {
  let {
    _sources: s,
    _sourcesContent: n,
    _ignoreList: a
    // _originalScopes: originalScopes,
  } = e, o = ki(s, t);
  o === n.length && (n[o] = null), r ? ki(a, o) : _z(a, o);
}
function xu(e) {
  let {
    _mappings: t,
    _sources: r,
    _sourcesContent: s,
    _names: n,
    _ignoreList: a
    // _originalScopes: originalScopes,
    // _generatedRanges: generatedRanges,
  } = e;
  return jz(t), {
    version: 3,
    file: e.file || void 0,
    names: n.array,
    sourceRoot: e.sourceRoot || void 0,
    sources: r.array,
    sourcesContent: s,
    mappings: t,
    // originalScopes,
    // generatedRanges,
    ignoreList: a.array
  };
}
function qh(e) {
  let t = xu(e);
  return Object.assign({}, t, {
    // originalScopes: decoded.originalScopes.map((os) => encodeOriginalScopes(os)),
    // generatedRanges: encodeGeneratedRanges(decoded.generatedRanges as GeneratedRange[]),
    mappings: mu(t.mappings)
  });
}
function Bz(e) {
  let t = new Ts(e), r = new Tu({ file: t.file, sourceRoot: t.sourceRoot });
  return Lh(r._names, t.names), Lh(r._sources, t.sources), r._sourcesContent = t.sourcesContent || t.sources.map(() => null), r._mappings = Rr(
  t), t.ignoreList && Lh(r._ignoreList, t.ignoreList), r;
}
function kz(e) {
  let t = [], { _mappings: r, _sources: s, _names: n } = e;
  for (let a = 0; a < r.length; a++) {
    let o = r[a];
    for (let l = 0; l < o.length; l++) {
      let u = o[l], c = { line: a + 1, column: u[SS] }, p, f, h;
      u.length !== 1 && (p = s.array[u[vS]], f = { line: u[PS] + 1, column: u[AS] }, u.length === 5 && (h = n.array[u[CS]])), t.push({ generated: c,
      source: p, original: f, name: h });
    }
  }
  return t;
}
function gu(e, t, r, s, n, a, o, l, u) {
  let {
    _mappings: c,
    _sources: p,
    _sourcesContent: f,
    _names: h
    // _originalScopes: originalScopes,
  } = t, b = Fz(c, r), T = Lz(b, s);
  if (!n)
    return e && Mz(b, T) ? void 0 : xS(b, T, [s]);
  let d = ki(p, n), g = l ? ki(h, l) : wS;
  if (d === f.length && (f[d] = u ?? null), !(e && Rz(b, T, d, a, o, g)))
    return xS(
      b,
      T,
      l ? [s, d, a, o, g] : [s, d, a, o]
    );
}
function Fz(e, t) {
  for (let r = e.length; r <= t; r++)
    e[r] = [];
  return e[t];
}
function Lz(e, t) {
  let r = e.length;
  for (let s = r - 1; s >= 0; r = s--) {
    let n = e[s];
    if (t >= n[SS]) break;
  }
  return r;
}
function xS(e, t, r) {
  for (let s = e.length; s > t; s--)
    e[s] = e[s - 1];
  e[t] = r;
}
function jz(e) {
  let { length: t } = e, r = t;
  for (let s = r - 1; s >= 0 && !(e[s].length > 0); r = s, s--)
    ;
  r < t && (e.length = r);
}
function Lh(e, t) {
  for (let r = 0; r < t.length; r++) ki(e, t[r]);
}
function Mz(e, t) {
  return t === 0 ? !0 : e[t - 1].length === 1;
}
function Rz(e, t, r, s, n, a) {
  if (t === 0) return !1;
  let o = e[t - 1];
  return o.length === 1 ? !1 : r === o[vS] && s === o[PS] && n === o[AS] && a === (o.length === 5 ? o[CS] : wS);
}
function DS(e, t, r) {
  let { generated: s, source: n, original: a, name: o, content: l } = r;
  return n ? gu(
    e,
    t,
    s.line - 1,
    s.column,
    n,
    a.line - 1,
    a.column,
    o,
    l
  ) : gu(
    e,
    t,
    s.line - 1,
    s.column,
    null,
    null,
    null,
    null,
    null
  );
}
var Fh, SS, vS, PS, AS, CS, wS, Tu, jh, Nz, Eu = hl(() => {
  Ah();
  co();
  Fh = class {
    static {
      i(this, "SetArray");
    }
    constructor() {
      this._indexes = { __proto__: null }, this.array = [];
    }
  };
  i(ES, "get");
  i(ki, "put");
  i(_z, "remove");
  SS = 0, vS = 1, PS = 2, AS = 3, CS = 4, wS = -1, Tu = class {
    static {
      i(this, "GenMapping");
    }
    constructor({ file: e, sourceRoot: t } = {}) {
      this._names = new Fh(), this._sources = new Fh(), this._sourcesContent = [], this._mappings = [], this.file = e, this.sourceRoot = t, this.
      _ignoreList = new Fh();
    }
  };
  i(Iz, "addSegment");
  i(Oz, "addMapping");
  jh = /* @__PURE__ */ i((e, t, r, s, n, a, o, l) => gu(
    !0,
    e,
    t,
    r,
    s,
    n,
    a,
    o,
    l
  ), "maybeAddSegment"), Nz = /* @__PURE__ */ i((e, t) => DS(!0, e, t), "maybeAddMapping");
  i(Mh, "setSourceContent");
  i(Rh, "setIgnore");
  i(xu, "toDecodedMap");
  i(qh, "toEncodedMap");
  i(Bz, "fromMap");
  i(kz, "allMappings");
  i(gu, "addSegmentInternal");
  i(Fz, "getIndex");
  i(Lz, "getColumnIndex");
  i(xS, "insert");
  i(jz, "removeEmptyFinalLines");
  i(Lh, "putAll");
  i(Mz, "skipSourceless");
  i(Rz, "skipSource");
  i(DS, "addMappingInternal");
});

// ../node_modules/@babel/generator/lib/source-map.js
var IS = D((Su) => {
  "use strict";
  Object.defineProperty(Su, "__esModule", {
    value: !0
  });
  Su.default = void 0;
  var en = (Eu(), nf(_S)), Uh = (co(), nf(TS)), $h = class {
    static {
      i(this, "SourceMap");
    }
    constructor(t, r) {
      var s;
      this._map = void 0, this._rawMappings = void 0, this._sourceFileName = void 0, this._lastGenLine = 0, this._lastSourceLine = 0, this._lastSourceColumn =
      0, this._inputMap = null;
      let n = this._map = new en.GenMapping({
        sourceRoot: t.sourceRoot
      });
      if (this._sourceFileName = (s = t.sourceFileName) == null ? void 0 : s.replace(/\\/g, "/"), this._rawMappings = void 0, t.inputSourceMap) {
        this._inputMap = new Uh.TraceMap(t.inputSourceMap);
        let o = this._inputMap.resolvedSources;
        if (o.length)
          for (let l = 0; l < o.length; l++) {
            var a;
            (0, en.setSourceContent)(n, o[l], (a = this._inputMap.sourcesContent) == null ? void 0 : a[l]);
          }
      }
      if (typeof r == "string" && !t.inputSourceMap)
        (0, en.setSourceContent)(n, this._sourceFileName, r);
      else if (typeof r == "object")
        for (let o of Object.keys(r))
          (0, en.setSourceContent)(n, o.replace(/\\/g, "/"), r[o]);
    }
    get() {
      return (0, en.toEncodedMap)(this._map);
    }
    getDecoded() {
      return (0, en.toDecodedMap)(this._map);
    }
    getRawMappings() {
      return this._rawMappings || (this._rawMappings = (0, en.allMappings)(this._map));
    }
    mark(t, r, s, n, a, o) {
      var l;
      this._rawMappings = void 0;
      let u;
      if (r != null)
        if (this._inputMap) {
          if (u = (0, Uh.originalPositionFor)(this._inputMap, {
            line: r,
            column: s
          }), !u.name && a) {
            let c = (0, Uh.originalPositionFor)(this._inputMap, a);
            c.name && (n = c.name);
          }
        } else
          u = {
            name: null,
            source: o?.replace(/\\/g, "/") || this._sourceFileName,
            line: r,
            column: s
          };
      (0, en.maybeAddMapping)(this._map, {
        name: n,
        generated: t,
        source: (l = u) == null ? void 0 : l.source,
        original: u
      });
    }
  };
  Su.default = $h;
});

// ../node_modules/@babel/generator/lib/buffer.js
var OS = D((vu) => {
  "use strict";
  Object.defineProperty(vu, "__esModule", {
    value: !0
  });
  vu.default = void 0;
  var Vh = class {
    static {
      i(this, "Buffer");
    }
    constructor(t, r) {
      this._map = null, this._buf = "", this._str = "", this._appendCount = 0, this._last = 0, this._queue = [], this._queueCursor = 0, this.
      _canMarkIdName = !0, this._indentChar = "", this._fastIndentations = [], this._position = {
        line: 1,
        column: 0
      }, this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0
      }, this._map = t, this._indentChar = r;
      for (let s = 0; s < 64; s++)
        this._fastIndentations.push(r.repeat(s));
      this._allocQueue();
    }
    _allocQueue() {
      let t = this._queue;
      for (let r = 0; r < 16; r++)
        t.push({
          char: 0,
          repeat: 1,
          line: void 0,
          column: void 0,
          identifierName: void 0,
          identifierNamePos: void 0,
          filename: ""
        });
    }
    _pushQueue(t, r, s, n, a) {
      let o = this._queueCursor;
      o === this._queue.length && this._allocQueue();
      let l = this._queue[o];
      l.char = t, l.repeat = r, l.line = s, l.column = n, l.filename = a, this._queueCursor++;
    }
    _popQueue() {
      if (this._queueCursor === 0)
        throw new Error("Cannot pop from empty queue");
      return this._queue[--this._queueCursor];
    }
    get() {
      this._flush();
      let t = this._map, r = {
        code: (this._buf + this._str).trimRight(),
        decodedMap: t?.getDecoded(),
        get __mergedMap() {
          return this.map;
        },
        get map() {
          let s = t ? t.get() : null;
          return r.map = s, s;
        },
        set map(s) {
          Object.defineProperty(r, "map", {
            value: s,
            writable: !0
          });
        },
        get rawMappings() {
          let s = t?.getRawMappings();
          return r.rawMappings = s, s;
        },
        set rawMappings(s) {
          Object.defineProperty(r, "rawMappings", {
            value: s,
            writable: !0
          });
        }
      };
      return r;
    }
    append(t, r) {
      this._flush(), this._append(t, this._sourcePosition, r);
    }
    appendChar(t) {
      this._flush(), this._appendChar(t, 1, this._sourcePosition);
    }
    queue(t) {
      if (t === 10)
        for (; this._queueCursor !== 0; ) {
          let s = this._queue[this._queueCursor - 1].char;
          if (s !== 32 && s !== 9)
            break;
          this._queueCursor--;
        }
      let r = this._sourcePosition;
      this._pushQueue(t, 1, r.line, r.column, r.filename);
    }
    queueIndentation(t) {
      t !== 0 && this._pushQueue(-1, t, void 0, void 0, void 0);
    }
    _flush() {
      let t = this._queueCursor, r = this._queue;
      for (let s = 0; s < t; s++) {
        let n = r[s];
        this._appendChar(n.char, n.repeat, n);
      }
      this._queueCursor = 0;
    }
    _appendChar(t, r, s) {
      if (this._last = t, t === -1) {
        let n = this._fastIndentations[r];
        n !== void 0 ? this._str += n : this._str += r > 1 ? this._indentChar.repeat(r) : this._indentChar;
      } else
        this._str += r > 1 ? String.fromCharCode(t).repeat(r) : String.fromCharCode(t);
      t !== 10 ? (this._mark(s.line, s.column, s.identifierName, s.identifierNamePos, s.filename), this._position.column += r) : (this._position.
      line++, this._position.column = 0), this._canMarkIdName && (s.identifierName = void 0, s.identifierNamePos = void 0);
    }
    _append(t, r, s) {
      let n = t.length, a = this._position;
      if (this._last = t.charCodeAt(n - 1), ++this._appendCount > 4096 ? (+this._str, this._buf += this._str, this._str = t, this._appendCount =
      0) : this._str += t, !s && !this._map) {
        a.column += n;
        return;
      }
      let {
        column: o,
        identifierName: l,
        identifierNamePos: u,
        filename: c
      } = r, p = r.line;
      (l != null || u != null) && this._canMarkIdName && (r.identifierName = void 0, r.identifierNamePos = void 0);
      let f = t.indexOf(`
`), h = 0;
      for (f !== 0 && this._mark(p, o, l, u, c); f !== -1; )
        a.line++, a.column = 0, h = f + 1, h < n && p !== void 0 && this._mark(++p, 0, void 0, void 0, c), f = t.indexOf(`
`, h);
      a.column += n - h;
    }
    _mark(t, r, s, n, a) {
      var o;
      (o = this._map) == null || o.mark(this._position, t, r, s, n, a);
    }
    removeTrailingNewline() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 10 && this._queueCursor--;
    }
    removeLastSemicolon() {
      let t = this._queueCursor;
      t !== 0 && this._queue[t - 1].char === 59 && this._queueCursor--;
    }
    getLastChar() {
      let t = this._queueCursor;
      return t !== 0 ? this._queue[t - 1].char : this._last;
    }
    getNewlineCount() {
      let t = this._queueCursor, r = 0;
      if (t === 0) return this._last === 10 ? 1 : 0;
      for (let s = t - 1; s >= 0 && this._queue[s].char === 10; s--)
        r++;
      return r === t && this._last === 10 ? r + 1 : r;
    }
    endsWithCharAndNewline() {
      let t = this._queue, r = this._queueCursor;
      if (r !== 0)
        return t[r - 1].char !== 10 ? void 0 : r > 1 ? t[r - 2].char : this._last;
    }
    hasContent() {
      return this._queueCursor !== 0 || !!this._last;
    }
    exactSource(t, r) {
      if (!this._map) {
        r();
        return;
      }
      this.source("start", t);
      let s = t.identifierName, n = this._sourcePosition;
      s && (this._canMarkIdName = !1, n.identifierName = s), r(), s && (this._canMarkIdName = !0, n.identifierName = void 0, n.identifierNamePos =
      void 0), this.source("end", t);
    }
    source(t, r) {
      this._map && this._normalizePosition(t, r, 0);
    }
    sourceWithOffset(t, r, s) {
      this._map && this._normalizePosition(t, r, s);
    }
    _normalizePosition(t, r, s) {
      let n = r[t], a = this._sourcePosition;
      n && (a.line = n.line, a.column = Math.max(n.column + s, 0), a.filename = r.filename);
    }
    getCurrentColumn() {
      let t = this._queue, r = this._queueCursor, s = -1, n = 0;
      for (let a = 0; a < r; a++) {
        let o = t[a];
        o.char === 10 && (s = n), n += o.repeat;
      }
      return s === -1 ? this._position.column + n : n - 1 - s;
    }
    getCurrentLine() {
      let t = 0, r = this._queue;
      for (let s = 0; s < this._queueCursor; s++)
        r[s].char === 10 && t++;
      return this._position.line + t;
    }
  };
  vu.default = Vh;
});

// ../node_modules/@babel/generator/lib/node/whitespace.js
var LS = D((Au) => {
  "use strict";
  Object.defineProperty(Au, "__esModule", {
    value: !0
  });
  Au.nodes = void 0;
  var qz = ce(), {
    FLIPPED_ALIAS_KEYS: Uz,
    isArrayExpression: $z,
    isAssignmentExpression: BS,
    isBinary: kS,
    isBlockStatement: Vz,
    isCallExpression: FS,
    isFunction: po,
    isIdentifier: Pu,
    isLiteral: Kz,
    isMemberExpression: Kh,
    isObjectExpression: Wz,
    isOptionalCallExpression: Yz,
    isOptionalMemberExpression: Hz,
    isStringLiteral: Jz
  } = qz;
  function Fi(e, t) {
    return e && (Kh(e) || Hz(e) ? (Fi(e.object, t), e.computed && Fi(e.property, t)) : kS(e) || BS(e) ? (Fi(e.left, t), Fi(e.right, t)) : FS(
    e) || Yz(e) ? (t.hasCall = !0, Fi(e.callee, t)) : po(e) ? t.hasFunction = !0 : Pu(e) && (t.hasHelper = t.hasHelper || e.callee && xs(e.callee))),
    t;
  }
  i(Fi, "crawlInternal");
  function NS(e) {
    return Fi(e, {
      hasCall: !1,
      hasFunction: !1,
      hasHelper: !1
    });
  }
  i(NS, "crawl");
  function xs(e) {
    return e ? Kh(e) ? xs(e.object) || xs(e.property) : Pu(e) ? e.name === "require" || e.name.charCodeAt(0) === 95 : FS(e) ? xs(e.callee) :
    kS(e) || BS(e) ? Pu(e.left) && xs(e.left) || xs(e.right) : !1 : !1;
  }
  i(xs, "isHelper");
  function Gz(e) {
    return Kz(e) || Wz(e) || $z(e) || Pu(e) || Kh(e);
  }
  i(Gz, "isType");
  var $n = Au.nodes = {
    AssignmentExpression(e) {
      let t = NS(e.right);
      return t.hasCall && t.hasHelper || t.hasFunction ? t.hasFunction ? 3 : 2 : 0;
    },
    SwitchCase(e, t) {
      return (e.consequent.length || t.cases[0] === e ? 1 : 0) | (!e.consequent.length && t.cases[t.cases.length - 1] === e ? 2 : 0);
    },
    LogicalExpression(e) {
      return po(e.left) || po(e.right) ? 2 : 0;
    },
    Literal(e) {
      return Jz(e) && e.value === "use strict" ? 2 : 0;
    },
    CallExpression(e) {
      return po(e.callee) || xs(e) ? 3 : 0;
    },
    OptionalCallExpression(e) {
      return po(e.callee) ? 3 : 0;
    },
    VariableDeclaration(e) {
      for (let t = 0; t < e.declarations.length; t++) {
        let r = e.declarations[t], s = xs(r.id) && !Gz(r.init);
        if (!s && r.init) {
          let n = NS(r.init);
          s = xs(r.init) && n.hasCall || n.hasFunction;
        }
        if (s)
          return 3;
      }
      return 0;
    },
    IfStatement(e) {
      return Vz(e.consequent) ? 3 : 0;
    }
  };
  $n.ObjectProperty = $n.ObjectTypeProperty = $n.ObjectMethod = function(e, t) {
    return t.properties[0] === e ? 1 : 0;
  };
  $n.ObjectTypeCallProperty = function(e, t) {
    var r;
    return t.callProperties[0] === e && !((r = t.properties) != null && r.length) ? 1 : 0;
  };
  $n.ObjectTypeIndexer = function(e, t) {
    var r, s;
    return t.indexers[0] === e && !((r = t.properties) != null && r.length) && !((s = t.callProperties) != null && s.length) ? 1 : 0;
  };
  $n.ObjectTypeInternalSlot = function(e, t) {
    var r, s, n;
    return t.internalSlots[0] === e && !((r = t.properties) != null && r.length) && !((s = t.callProperties) != null && s.length) && !((n = t.
    indexers) != null && n.length) ? 1 : 0;
  };
  [["Function", !0], ["Class", !0], ["Loop", !0], ["LabeledStatement", !0], ["SwitchStatement", !0], ["TryStatement", !0]].forEach(function([
  e, t]) {
    [e].concat(Uz[e] || []).forEach(function(r) {
      let s = t ? 3 : 0;
      $n[r] = () => s;
    });
  });
});

// ../node_modules/@babel/generator/lib/node/parentheses.js
var KS = D((Se) => {
  "use strict";
  Object.defineProperty(Se, "__esModule", {
    value: !0
  });
  Se.AssignmentExpression = wQ;
  Se.Binary = US;
  Se.BinaryExpression = EQ;
  Se.ClassExpression = PQ;
  Se.ArrowFunctionExpression = Se.ConditionalExpression = VS;
  Se.DoExpression = cQ;
  Se.FunctionExpression = AQ;
  Se.FunctionTypeAnnotation = oQ;
  Se.Identifier = _Q;
  Se.LogicalExpression = DQ;
  Se.NullableTypeAnnotation = aQ;
  Se.ObjectExpression = uQ;
  Se.OptionalIndexedAccessType = fQ;
  Se.OptionalCallExpression = Se.OptionalMemberExpression = CQ;
  Se.SequenceExpression = SQ;
  Se.TSSatisfiesExpression = Se.TSAsExpression = dQ;
  Se.TSConditionalType = hQ;
  Se.TSConstructorType = Se.TSFunctionType = xQ;
  Se.TSInferType = bQ;
  Se.TSInstantiationExpression = TQ;
  Se.TSIntersectionType = yQ;
  Se.UnaryLike = Se.TSTypeAssertion = $S;
  Se.TSTypeOperator = gQ;
  Se.TSUnionType = mQ;
  Se.IntersectionTypeAnnotation = Se.UnionTypeAnnotation = pQ;
  Se.UpdateExpression = lQ;
  Se.AwaitExpression = Se.YieldExpression = vQ;
  var Xz = ce(), sr = Vn(), {
    isArrayTypeAnnotation: zz,
    isBinaryExpression: Qz,
    isCallExpression: Zz,
    isForOfStatement: eQ,
    isIndexedAccessType: tQ,
    isMemberExpression: RS,
    isObjectPattern: rQ,
    isOptionalMemberExpression: sQ,
    isYieldExpression: nQ,
    isStatement: iQ
  } = Xz, jS = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!\
=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-",
  8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
  function MS(e, t) {
    if (t === "BinaryExpression" || t === "LogicalExpression")
      return jS.get(e.operator);
    if (t === "TSAsExpression" || t === "TSSatisfiesExpression")
      return jS.get("in");
  }
  i(MS, "getBinaryPrecedence");
  function Wh(e) {
    return e === "TSAsExpression" || e === "TSSatisfiesExpression" || e === "TSTypeAssertion";
  }
  i(Wh, "isTSTypeExpression");
  var Cu = /* @__PURE__ */ i((e, t) => {
    let r = t.type;
    return (r === "ClassDeclaration" || r === "ClassExpression") && t.superClass === e;
  }, "isClassExtendsClause"), wu = /* @__PURE__ */ i((e, t) => {
    let r = t.type;
    return (r === "MemberExpression" || r === "OptionalMemberExpression") && t.object === e || (r === "CallExpression" || r === "OptionalCal\
lExpression" || r === "NewExpression") && t.callee === e || r === "TaggedTemplateExpression" && t.tag === e || r === "TSNonNullExpression";
  }, "hasPostfixPart");
  function aQ(e, t) {
    return zz(t);
  }
  i(aQ, "NullableTypeAnnotation");
  function oQ(e, t, r) {
    let s = t.type;
    return s === "UnionTypeAnnotation" || s === "IntersectionTypeAnnotation" || s === "ArrayTypeAnnotation" || !!(r & sr.TokenContext.arrowFlowReturnType);
  }
  i(oQ, "FunctionTypeAnnotation");
  function lQ(e, t) {
    return wu(e, t) || Cu(e, t);
  }
  i(lQ, "UpdateExpression");
  function qS(e) {
    return !!(e & (sr.TokenContext.expressionStatement | sr.TokenContext.arrowBody));
  }
  i(qS, "needsParenBeforeExpressionBrace");
  function uQ(e, t, r) {
    return qS(r);
  }
  i(uQ, "ObjectExpression");
  function cQ(e, t, r) {
    return !e.async && !!(r & sr.TokenContext.expressionStatement);
  }
  i(cQ, "DoExpression");
  function US(e, t) {
    let r = t.type;
    if (e.type === "BinaryExpression" && e.operator === "**" && r === "BinaryExpression" && t.operator === "**")
      return t.left === e;
    if (Cu(e, t) || wu(e, t) || r === "UnaryExpression" || r === "SpreadElement" || r === "AwaitExpression")
      return !0;
    let s = MS(t, r);
    if (s != null) {
      let n = MS(e, e.type);
      if (s === n && r === "BinaryExpression" && t.right === e || s > n)
        return !0;
    }
  }
  i(US, "Binary");
  function pQ(e, t) {
    let r = t.type;
    return r === "ArrayTypeAnnotation" || r === "NullableTypeAnnotation" || r === "IntersectionTypeAnnotation" || r === "UnionTypeAnnotation";
  }
  i(pQ, "UnionTypeAnnotation");
  function fQ(e, t) {
    return tQ(t) && t.objectType === e;
  }
  i(fQ, "OptionalIndexedAccessType");
  function dQ(e, t) {
    return (t.type === "AssignmentExpression" || t.type === "AssignmentPattern") && t.left === e || t.type === "BinaryExpression" && (t.operator ===
    "|" || t.operator === "&") && e === t.left ? !0 : US(e, t);
  }
  i(dQ, "TSAsExpression");
  function hQ(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType" || r === "TSTypeOperator" || r ===
    "TSTypeParameter" || (r === "TSIntersectionType" || r === "TSUnionType") && t.types[0] === e || r === "TSConditionalType" && (t.checkType ===
    e || t.extendsType === e);
  }
  i(hQ, "TSConditionalType");
  function mQ(e, t) {
    let r = t.type;
    return r === "TSIntersectionType" || r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e ||
    r === "TSOptionalType";
  }
  i(mQ, "TSUnionType");
  function yQ(e, t) {
    let r = t.type;
    return r === "TSTypeOperator" || r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType";
  }
  i(yQ, "TSIntersectionType");
  function bQ(e, t) {
    let r = t.type;
    return !!(r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType" || e.typeParameter.constraint &&
    (r === "TSIntersectionType" || r === "TSUnionType") && t.types[0] === e);
  }
  i(bQ, "TSInferType");
  function gQ(e, t) {
    let r = t.type;
    return r === "TSArrayType" || r === "TSIndexedAccessType" && t.objectType === e || r === "TSOptionalType";
  }
  i(gQ, "TSTypeOperator");
  function TQ(e, t) {
    let r = t.type;
    return (r === "CallExpression" || r === "OptionalCallExpression" || r === "NewExpression" || r === "TSInstantiationExpression") && !!t.typeParameters;
  }
  i(TQ, "TSInstantiationExpression");
  function xQ(e, t) {
    let r = t.type;
    return r === "TSIntersectionType" || r === "TSUnionType" || r === "TSTypeOperator" || r === "TSOptionalType" || r === "TSArrayType" || r ===
    "TSIndexedAccessType" && t.objectType === e || r === "TSConditionalType" && (t.checkType === e || t.extendsType === e);
  }
  i(xQ, "TSFunctionType");
  function EQ(e, t, r) {
    return e.operator === "in" && !!(r & sr.TokenContext.forInOrInitHeadAccumulate);
  }
  i(EQ, "BinaryExpression");
  function SQ(e, t) {
    let r = t.type;
    return r === "SequenceExpression" || r === "ParenthesizedExpression" || r === "MemberExpression" && t.property === e || r === "OptionalM\
emberExpression" && t.property === e || r === "TemplateLiteral" ? !1 : r === "ClassDeclaration" ? !0 : r === "ForOfStatement" ? t.right === e :
    r === "ExportDefaultDeclaration" ? !0 : !iQ(t);
  }
  i(SQ, "SequenceExpression");
  function vQ(e, t) {
    let r = t.type;
    return r === "BinaryExpression" || r === "LogicalExpression" || r === "UnaryExpression" || r === "SpreadElement" || wu(e, t) || r === "A\
waitExpression" && nQ(e) || r === "ConditionalExpression" && e === t.test || Cu(e, t) || Wh(r);
  }
  i(vQ, "YieldExpression");
  function PQ(e, t, r) {
    return !!(r & (sr.TokenContext.expressionStatement | sr.TokenContext.exportDefault));
  }
  i(PQ, "ClassExpression");
  function $S(e, t) {
    return wu(e, t) || Qz(t) && t.operator === "**" && t.left === e || Cu(e, t);
  }
  i($S, "UnaryLike");
  function AQ(e, t, r) {
    return !!(r & (sr.TokenContext.expressionStatement | sr.TokenContext.exportDefault));
  }
  i(AQ, "FunctionExpression");
  function VS(e, t) {
    let r = t.type;
    return r === "UnaryExpression" || r === "SpreadElement" || r === "BinaryExpression" || r === "LogicalExpression" || r === "ConditionalEx\
pression" && t.test === e || r === "AwaitExpression" || Wh(r) ? !0 : $S(e, t);
  }
  i(VS, "ConditionalExpression");
  function CQ(e, t) {
    return Zz(t) && t.callee === e || RS(t) && t.object === e;
  }
  i(CQ, "OptionalMemberExpression");
  function wQ(e, t, r) {
    return qS(r) && rQ(e.left) ? !0 : VS(e, t);
  }
  i(wQ, "AssignmentExpression");
  function DQ(e, t) {
    let r = t.type;
    if (Wh(r)) return !0;
    if (r !== "LogicalExpression") return !1;
    switch (e.operator) {
      case "||":
        return t.operator === "??" || t.operator === "&&";
      case "&&":
        return t.operator === "??";
      case "??":
        return t.operator !== "??";
    }
  }
  i(DQ, "LogicalExpression");
  function _Q(e, t, r, s) {
    var n;
    let a = t.type;
    if ((n = e.extra) != null && n.parenthesized && a === "AssignmentExpression" && t.left === e) {
      let o = t.right.type;
      if ((o === "FunctionExpression" || o === "ClassExpression") && t.right.id == null)
        return !0;
    }
    return s && s(e) !== e.name ? !1 : e.name === "let" ? (RS(t, {
      object: e,
      computed: !0
    }) || sQ(t, {
      object: e,
      computed: !0,
      optional: !1
    })) && r & (sr.TokenContext.expressionStatement | sr.TokenContext.forInitHead | sr.TokenContext.forInHead) ? !0 : !!(r & sr.TokenContext.
    forOfHead) : e.name === "async" && eQ(t, {
      left: e,
      await: !1
    });
  }
  i(_Q, "Identifier");
});

// ../node_modules/@babel/generator/lib/node/index.js
var Vn = D((Es) => {
  "use strict";
  Object.defineProperty(Es, "__esModule", {
    value: !0
  });
  Es.TokenContext = void 0;
  Es.isLastChild = WQ;
  Es.needsParens = KQ;
  Es.needsWhitespace = Hh;
  Es.needsWhitespaceAfter = VQ;
  Es.needsWhitespaceBefore = $Q;
  var IQ = LS(), OQ = KS(), NQ = ce(), {
    FLIPPED_ALIAS_KEYS: BQ,
    VISITOR_KEYS: kQ,
    isCallExpression: WS,
    isDecorator: FQ,
    isExpressionStatement: LQ,
    isMemberExpression: jQ,
    isNewExpression: MQ,
    isParenthesizedExpression: RQ
  } = NQ, rDe = Es.TokenContext = {
    normal: 0,
    expressionStatement: 1,
    arrowBody: 2,
    exportDefault: 4,
    arrowFlowReturnType: 8,
    forInitHead: 16,
    forInHead: 32,
    forOfHead: 64,
    forInOrInitHeadAccumulate: 128,
    forInOrInitHeadAccumulatePassThroughMask: 128
  };
  function YS(e) {
    let t = /* @__PURE__ */ new Map();
    function r(s, n) {
      let a = t.get(s);
      t.set(s, a ? function(o, l, u, c) {
        var p;
        return (p = a(o, l, u, c)) != null ? p : n(o, l, u, c);
      } : n);
    }
    i(r, "add");
    for (let s of Object.keys(e)) {
      let n = BQ[s];
      if (n)
        for (let a of n)
          r(a, e[s]);
      else
        r(s, e[s]);
    }
    return t;
  }
  i(YS, "expandAliases");
  var qQ = YS(OQ), UQ = YS(IQ.nodes);
  function HS(e) {
    return WS(e) ? !0 : jQ(e) && HS(e.object);
  }
  i(HS, "isOrHasCallExpression");
  function Hh(e, t, r) {
    var s;
    if (!e) return !1;
    LQ(e) && (e = e.expression);
    let n = (s = UQ.get(e.type)) == null ? void 0 : s(e, t);
    return typeof n == "number" ? (n & r) !== 0 : !1;
  }
  i(Hh, "needsWhitespace");
  function $Q(e, t) {
    return Hh(e, t, 1);
  }
  i($Q, "needsWhitespaceBefore");
  function VQ(e, t) {
    return Hh(e, t, 2);
  }
  i(VQ, "needsWhitespaceAfter");
  function KQ(e, t, r, s) {
    var n;
    return t ? MQ(t) && t.callee === e && HS(e) ? !0 : FQ(t) ? !Yh(e) && !(WS(e) && Yh(e.callee)) && !RQ(e) : ((n = qQ.get(e.type)) == null ?
    void 0 : n(e, t, r, s)) || !1 : !1;
  }
  i(KQ, "needsParens");
  function Yh(e) {
    switch (e.type) {
      case "Identifier":
        return !0;
      case "MemberExpression":
        return !e.computed && e.property.type === "Identifier" && Yh(e.object);
      default:
        return !1;
    }
  }
  i(Yh, "isDecoratorMemberExpression");
  function WQ(e, t) {
    let r = kQ[e.type];
    for (let s = r.length - 1; s >= 0; s--) {
      let n = e[r[s]];
      if (n === t)
        return !0;
      if (Array.isArray(n)) {
        let a = n.length - 1;
        for (; a >= 0 && n[a] === null; ) a--;
        return a >= 0 && n[a] === t;
      } else if (n)
        return !1;
    }
    return !1;
  }
  i(WQ, "isLastChild");
});

// ../node_modules/@babel/generator/lib/token-map.js
var JS = D((Du) => {
  "use strict";
  Object.defineProperty(Du, "__esModule", {
    value: !0
  });
  Du.TokenMap = void 0;
  var YQ = ce(), {
    traverseFast: HQ,
    VISITOR_KEYS: JQ
  } = YQ, Jh = class {
    static {
      i(this, "TokenMap");
    }
    constructor(t, r, s) {
      this._tokens = void 0, this._source = void 0, this._nodesToTokenIndexes = /* @__PURE__ */ new Map(), this._nodesOccurrencesCountCache =
      /* @__PURE__ */ new Map(), this._tokensCache = /* @__PURE__ */ new Map(), this._tokens = r, this._source = s, HQ(t, (n) => {
        let a = this._getTokensIndexesOfNode(n);
        a.length > 0 && this._nodesToTokenIndexes.set(n, a);
      }), this._tokensCache.clear();
    }
    has(t) {
      return this._nodesToTokenIndexes.has(t);
    }
    getIndexes(t) {
      return this._nodesToTokenIndexes.get(t);
    }
    find(t, r) {
      let s = this._nodesToTokenIndexes.get(t);
      if (s)
        for (let n = 0; n < s.length; n++) {
          let a = s[n], o = this._tokens[a];
          if (r(o, a)) return o;
        }
      return null;
    }
    findLastIndex(t, r) {
      let s = this._nodesToTokenIndexes.get(t);
      if (s)
        for (let n = s.length - 1; n >= 0; n--) {
          let a = s[n], o = this._tokens[a];
          if (r(o, a)) return a;
        }
      return -1;
    }
    findMatching(t, r, s = 0) {
      let n = this._nodesToTokenIndexes.get(t);
      if (n) {
        let a = 0, o = s;
        if (o > 1) {
          let l = this._nodesOccurrencesCountCache.get(t);
          l && l.test === r && l.count < o && (a = l.i + 1, s -= l.count + 1);
        }
        for (; a < n.length; a++) {
          let l = this._tokens[n[a]];
          if (this.matchesOriginal(l, r)) {
            if (s === 0)
              return o > 0 && this._nodesOccurrencesCountCache.set(t, {
                test: r,
                count: o,
                i: a
              }), l;
            s--;
          }
        }
      }
      return null;
    }
    matchesOriginal(t, r) {
      return t.end - t.start !== r.length ? !1 : t.value != null ? t.value === r : this._source.startsWith(r, t.start);
    }
    startMatches(t, r) {
      let s = this._nodesToTokenIndexes.get(t);
      if (!s) return !1;
      let n = this._tokens[s[0]];
      return n.start !== t.start ? !1 : this.matchesOriginal(n, r);
    }
    endMatches(t, r) {
      let s = this._nodesToTokenIndexes.get(t);
      if (!s) return !1;
      let n = this._tokens[s[s.length - 1]];
      return n.end !== t.end ? !1 : this.matchesOriginal(n, r);
    }
    _getTokensIndexesOfNode(t) {
      if (t.start == null || t.end == null) return [];
      let {
        first: r,
        last: s
      } = this._findTokensOfNode(t, 0, this._tokens.length - 1), n = r, a = GQ(t);
      (t.type === "ExportNamedDeclaration" || t.type === "ExportDefaultDeclaration") && t.declaration && t.declaration.type === "ClassDeclar\
ation" && a.next();
      let o = [];
      for (let l of a) {
        if (l == null || l.start == null || l.end == null) continue;
        let u = this._findTokensOfNode(l, n, s), c = u.first;
        for (let p = n; p < c; p++) o.push(p);
        n = u.last + 1;
      }
      for (let l = n; l <= s; l++) o.push(l);
      return o;
    }
    _findTokensOfNode(t, r, s) {
      let n = this._tokensCache.get(t);
      if (n) return n;
      let a = this._findFirstTokenOfNode(t.start, r, s), o = this._findLastTokenOfNode(t.end, a, s);
      return this._tokensCache.set(t, {
        first: a,
        last: o
      }), {
        first: a,
        last: o
      };
    }
    _findFirstTokenOfNode(t, r, s) {
      for (; r <= s; ) {
        let n = s + r >> 1;
        if (t < this._tokens[n].start)
          s = n - 1;
        else if (t > this._tokens[n].start)
          r = n + 1;
        else
          return n;
      }
      return r;
    }
    _findLastTokenOfNode(t, r, s) {
      for (; r <= s; ) {
        let n = s + r >> 1;
        if (t < this._tokens[n].end)
          s = n - 1;
        else if (t > this._tokens[n].end)
          r = n + 1;
        else
          return n;
      }
      return s;
    }
  };
  Du.TokenMap = Jh;
  function* GQ(e) {
    if (e.type === "TemplateLiteral") {
      yield e.quasis[0];
      for (let r = 1; r < e.quasis.length; r++)
        yield e.expressions[r - 1], yield e.quasis[r];
      return;
    }
    let t = JQ[e.type];
    for (let r of t) {
      let s = e[r];
      s && (Array.isArray(s) ? yield* s : yield s);
    }
  }
  i(GQ, "childrenIterator");
});

// ../node_modules/@babel/generator/lib/generators/template-literals.js
var GS = D((Li) => {
  "use strict";
  Object.defineProperty(Li, "__esModule", {
    value: !0
  });
  Li.TaggedTemplateExpression = XQ;
  Li.TemplateElement = zQ;
  Li.TemplateLiteral = ZQ;
  Li._printTemplate = QQ;
  function XQ(e) {
    this.print(e.tag), this.print(e.typeParameters), this.print(e.quasi);
  }
  i(XQ, "TaggedTemplateExpression");
  function zQ() {
    throw new Error("TemplateElement printing is handled in TemplateLiteral");
  }
  i(zQ, "TemplateElement");
  function QQ(e, t) {
    let r = e.quasis, s = "`";
    for (let n = 0; n < r.length - 1; n++)
      if (s += r[n].value.raw, this.token(s + "${", !0), this.print(t[n]), s = "}", this.tokenMap) {
        let a = this.tokenMap.findMatching(e, "}", n);
        a && this._catchUpTo(a.loc.start);
      }
    s += r[r.length - 1].value.raw, this.token(s + "`", !0);
  }
  i(QQ, "_printTemplate");
  function ZQ(e) {
    this._printTemplate(e, e.expressions);
  }
  i(ZQ, "TemplateLiteral");
});

// ../node_modules/@babel/generator/lib/generators/expressions.js
var zS = D((Fe) => {
  "use strict";
  Object.defineProperty(Fe, "__esModule", {
    value: !0
  });
  Fe.LogicalExpression = Fe.BinaryExpression = Fe.AssignmentExpression = AZ;
  Fe.AssignmentPattern = PZ;
  Fe.AwaitExpression = xZ;
  Fe.BindExpression = CZ;
  Fe.CallExpression = gZ;
  Fe.ConditionalExpression = uZ;
  Fe.Decorator = mZ;
  Fe.DoExpression = aZ;
  Fe.EmptyStatement = SZ;
  Fe.ExpressionStatement = vZ;
  Fe.Import = TZ;
  Fe.MemberExpression = wZ;
  Fe.MetaProperty = DZ;
  Fe.ModuleExpression = OZ;
  Fe.NewExpression = cZ;
  Fe.OptionalCallExpression = bZ;
  Fe.OptionalMemberExpression = yZ;
  Fe.ParenthesizedExpression = oZ;
  Fe.PrivateName = _Z;
  Fe.SequenceExpression = pZ;
  Fe.Super = dZ;
  Fe.ThisExpression = fZ;
  Fe.UnaryExpression = iZ;
  Fe.UpdateExpression = lZ;
  Fe.V8IntrinsicIdentifier = IZ;
  Fe.YieldExpression = EZ;
  Fe._shouldPrintDecoratorsBeforeExport = hZ;
  var eZ = ce(), tZ = Vn(), {
    isCallExpression: rZ,
    isLiteral: XS,
    isMemberExpression: Gh,
    isNewExpression: sZ,
    isPattern: nZ
  } = eZ;
  function iZ(e) {
    let {
      operator: t
    } = e;
    t === "void" || t === "delete" || t === "typeof" || t === "throw" ? (this.word(t), this.space()) : this.token(t), this.print(e.argument);
  }
  i(iZ, "UnaryExpression");
  function aZ(e) {
    e.async && (this.word("async", !0), this.space()), this.word("do"), this.space(), this.print(e.body);
  }
  i(aZ, "DoExpression");
  function oZ(e) {
    this.tokenChar(40);
    let t = this.enterDelimited();
    this.print(e.expression), t(), this.rightParens(e);
  }
  i(oZ, "ParenthesizedExpression");
  function lZ(e) {
    e.prefix ? (this.token(e.operator), this.print(e.argument)) : (this.print(e.argument, !0), this.token(e.operator));
  }
  i(lZ, "UpdateExpression");
  function uZ(e) {
    this.print(e.test), this.space(), this.tokenChar(63), this.space(), this.print(e.consequent), this.space(), this.tokenChar(58), this.space(),
    this.print(e.alternate);
  }
  i(uZ, "ConditionalExpression");
  function cZ(e, t) {
    if (this.word("new"), this.space(), this.print(e.callee), this.format.minified && e.arguments.length === 0 && !e.optional && !rZ(t, {
      callee: e
    }) && !Gh(t) && !sZ(t) || (this.print(e.typeArguments), this.print(e.typeParameters), e.optional && this.token("?."), e.arguments.length ===
    0 && this.tokenMap && !this.tokenMap.endMatches(e, ")")))
      return;
    this.tokenChar(40);
    let r = this.enterDelimited();
    this.printList(e.arguments, this.shouldPrintTrailingComma(")")), r(), this.rightParens(e);
  }
  i(cZ, "NewExpression");
  function pZ(e) {
    this.printList(e.expressions);
  }
  i(pZ, "SequenceExpression");
  function fZ() {
    this.word("this");
  }
  i(fZ, "ThisExpression");
  function dZ() {
    this.word("super");
  }
  i(dZ, "Super");
  function hZ(e) {
    return typeof this.format.decoratorsBeforeExport == "boolean" ? this.format.decoratorsBeforeExport : typeof e.start == "number" && e.start ===
    e.declaration.start;
  }
  i(hZ, "_shouldPrintDecoratorsBeforeExport");
  function mZ(e) {
    this.tokenChar(64), this.print(e.expression), this.newline();
  }
  i(mZ, "Decorator");
  function yZ(e) {
    let {
      computed: t
    } = e, {
      optional: r,
      property: s
    } = e;
    if (this.print(e.object), !t && Gh(s))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    XS(s) && typeof s.value == "number" && (t = !0), r && this.token("?."), t ? (this.tokenChar(91), this.print(s), this.tokenChar(93)) : (r ||
    this.tokenChar(46), this.print(s));
  }
  i(yZ, "OptionalMemberExpression");
  function bZ(e) {
    this.print(e.callee), this.print(e.typeParameters), e.optional && this.token("?."), this.print(e.typeArguments), this.tokenChar(40);
    let t = this.enterDelimited();
    this.printList(e.arguments), t(), this.rightParens(e);
  }
  i(bZ, "OptionalCallExpression");
  function gZ(e) {
    this.print(e.callee), this.print(e.typeArguments), this.print(e.typeParameters), this.tokenChar(40);
    let t = this.enterDelimited();
    this.printList(e.arguments, this.shouldPrintTrailingComma(")")), t(), this.rightParens(e);
  }
  i(gZ, "CallExpression");
  function TZ() {
    this.word("import");
  }
  i(TZ, "Import");
  function xZ(e) {
    this.word("await"), this.space(), this.print(e.argument);
  }
  i(xZ, "AwaitExpression");
  function EZ(e) {
    e.delegate ? (this.word("yield", !0), this.tokenChar(42), e.argument && (this.space(), this.print(e.argument))) : e.argument ? (this.word(
    "yield", !0), this.space(), this.print(e.argument)) : this.word("yield");
  }
  i(EZ, "YieldExpression");
  function SZ() {
    this.semicolon(!0);
  }
  i(SZ, "EmptyStatement");
  function vZ(e) {
    this.tokenContext |= tZ.TokenContext.expressionStatement, this.print(e.expression), this.semicolon();
  }
  i(vZ, "ExpressionStatement");
  function PZ(e) {
    this.print(e.left), (e.left.type === "Identifier" || nZ(e.left)) && (e.left.optional && this.tokenChar(63), this.print(e.left.typeAnnotation)),
    this.space(), this.tokenChar(61), this.space(), this.print(e.right);
  }
  i(PZ, "AssignmentPattern");
  function AZ(e) {
    this.print(e.left), this.space(), e.operator === "in" || e.operator === "instanceof" ? this.word(e.operator) : (this.token(e.operator), this.
    _endsWithDiv = e.operator === "/"), this.space(), this.print(e.right);
  }
  i(AZ, "AssignmentExpression");
  function CZ(e) {
    this.print(e.object), this.token("::"), this.print(e.callee);
  }
  i(CZ, "BindExpression");
  function wZ(e) {
    if (this.print(e.object), !e.computed && Gh(e.property))
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    let t = e.computed;
    if (XS(e.property) && typeof e.property.value == "number" && (t = !0), t) {
      let r = this.enterDelimited();
      this.tokenChar(91), this.print(e.property), this.tokenChar(93), r();
    } else
      this.tokenChar(46), this.print(e.property);
  }
  i(wZ, "MemberExpression");
  function DZ(e) {
    this.print(e.meta), this.tokenChar(46), this.print(e.property);
  }
  i(DZ, "MetaProperty");
  function _Z(e) {
    this.tokenChar(35), this.print(e.id);
  }
  i(_Z, "PrivateName");
  function IZ(e) {
    this.tokenChar(37), this.word(e.name);
  }
  i(IZ, "V8IntrinsicIdentifier");
  function OZ(e) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    let {
      body: t
    } = e;
    (t.body.length || t.directives.length) && this.newline(), this.print(t), this.dedent(), this.rightBrace(e);
  }
  i(OZ, "ModuleExpression");
});

// ../node_modules/@babel/generator/lib/generators/statements.js
var tv = D((Ge) => {
  "use strict";
  Object.defineProperty(Ge, "__esModule", {
    value: !0
  });
  Ge.BreakStatement = UZ;
  Ge.CatchClause = HZ;
  Ge.ContinueStatement = $Z;
  Ge.DebuggerStatement = XZ;
  Ge.DoWhileStatement = qZ;
  Ge.ForOfStatement = Ge.ForInStatement = void 0;
  Ge.ForStatement = MZ;
  Ge.IfStatement = jZ;
  Ge.LabeledStatement = WZ;
  Ge.ReturnStatement = VZ;
  Ge.SwitchCase = GZ;
  Ge.SwitchStatement = JZ;
  Ge.ThrowStatement = KZ;
  Ge.TryStatement = YZ;
  Ge.VariableDeclaration = zZ;
  Ge.VariableDeclarator = QZ;
  Ge.WhileStatement = RZ;
  Ge.WithStatement = LZ;
  var NZ = ce(), {
    isFor: QS,
    isForStatement: BZ,
    isIfStatement: kZ,
    isStatement: FZ
  } = NZ;
  function LZ(e) {
    this.word("with"), this.space(), this.tokenChar(40), this.print(e.object), this.tokenChar(41), this.printBlock(e);
  }
  i(LZ, "WithStatement");
  function jZ(e) {
    this.word("if"), this.space(), this.tokenChar(40), this.print(e.test), this.tokenChar(41), this.space();
    let t = e.alternate && kZ(ZS(e.consequent));
    t && (this.tokenChar(123), this.newline(), this.indent()), this.printAndIndentOnComments(e.consequent), t && (this.dedent(), this.newline(),
    this.tokenChar(125)), e.alternate && (this.endsWith(125) && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(
    e.alternate));
  }
  i(jZ, "IfStatement");
  function ZS(e) {
    let {
      body: t
    } = e;
    return FZ(t) === !1 ? e : ZS(t);
  }
  i(ZS, "getLastStatement");
  function MZ(e) {
    this.word("for"), this.space(), this.tokenChar(40);
    {
      let t = this.enterForStatementInit();
      this.print(e.init), t();
    }
    this.tokenChar(59), e.test && (this.space(), this.print(e.test)), this.token(";", !1, 1), e.update && (this.space(), this.print(e.update)),
    this.tokenChar(41), this.printBlock(e);
  }
  i(MZ, "ForStatement");
  function RZ(e) {
    this.word("while"), this.space(), this.tokenChar(40), this.print(e.test), this.tokenChar(41), this.printBlock(e);
  }
  i(RZ, "WhileStatement");
  function ev(e) {
    this.word("for"), this.space();
    let t = e.type === "ForOfStatement";
    t && e.await && (this.word("await"), this.space()), this.noIndentInnerCommentsHere(), this.tokenChar(40);
    {
      let r = this.enterForXStatementInit(t);
      this.print(e.left), r?.();
    }
    this.space(), this.word(t ? "of" : "in"), this.space(), this.print(e.right), this.tokenChar(41), this.printBlock(e);
  }
  i(ev, "ForXStatement");
  var pDe = Ge.ForInStatement = ev, fDe = Ge.ForOfStatement = ev;
  function qZ(e) {
    this.word("do"), this.space(), this.print(e.body), this.space(), this.word("while"), this.space(), this.tokenChar(40), this.print(e.test),
    this.tokenChar(41), this.semicolon();
  }
  i(qZ, "DoWhileStatement");
  function _u(e, t) {
    t && (e.space(), e.printTerminatorless(t)), e.semicolon();
  }
  i(_u, "printStatementAfterKeyword");
  function UZ(e) {
    this.word("break"), _u(this, e.label);
  }
  i(UZ, "BreakStatement");
  function $Z(e) {
    this.word("continue"), _u(this, e.label);
  }
  i($Z, "ContinueStatement");
  function VZ(e) {
    this.word("return"), _u(this, e.argument);
  }
  i(VZ, "ReturnStatement");
  function KZ(e) {
    this.word("throw"), _u(this, e.argument);
  }
  i(KZ, "ThrowStatement");
  function WZ(e) {
    this.print(e.label), this.tokenChar(58), this.space(), this.print(e.body);
  }
  i(WZ, "LabeledStatement");
  function YZ(e) {
    this.word("try"), this.space(), this.print(e.block), this.space(), e.handlers ? this.print(e.handlers[0]) : this.print(e.handler), e.finalizer &&
    (this.space(), this.word("finally"), this.space(), this.print(e.finalizer));
  }
  i(YZ, "TryStatement");
  function HZ(e) {
    this.word("catch"), this.space(), e.param && (this.tokenChar(40), this.print(e.param), this.print(e.param.typeAnnotation), this.tokenChar(
    41), this.space()), this.print(e.body);
  }
  i(HZ, "CatchClause");
  function JZ(e) {
    this.word("switch"), this.space(), this.tokenChar(40), this.print(e.discriminant), this.tokenChar(41), this.space(), this.tokenChar(123),
    this.printSequence(e.cases, !0), this.rightBrace(e);
  }
  i(JZ, "SwitchStatement");
  function GZ(e) {
    e.test ? (this.word("case"), this.space(), this.print(e.test), this.tokenChar(58)) : (this.word("default"), this.tokenChar(58)), e.consequent.
    length && (this.newline(), this.printSequence(e.consequent, !0));
  }
  i(GZ, "SwitchCase");
  function XZ() {
    this.word("debugger"), this.semicolon();
  }
  i(XZ, "DebuggerStatement");
  function zZ(e, t) {
    e.declare && (this.word("declare"), this.space());
    let {
      kind: r
    } = e;
    r === "await using" ? (this.word("await"), this.space(), this.word("using", !0)) : this.word(r, r === "using"), this.space();
    let s = !1;
    if (!QS(t))
      for (let n of e.declarations)
        n.init && (s = !0);
    if (this.printList(e.declarations, void 0, void 0, e.declarations.length > 1, s ? function(n) {
      this.token(",", !1, n), this.newline();
    } : void 0), QS(t)) {
      if (BZ(t)) {
        if (t.init === e) return;
      } else if (t.left === e) return;
    }
    this.semicolon();
  }
  i(zZ, "VariableDeclaration");
  function QZ(e) {
    this.print(e.id), e.definite && this.tokenChar(33), this.print(e.id.typeAnnotation), e.init && (this.space(), this.tokenChar(61), this.space(),
    this.print(e.init));
  }
  i(QZ, "VariableDeclarator");
});

// ../node_modules/@babel/generator/lib/generators/classes.js
var rv = D((gr) => {
  "use strict";
  Object.defineProperty(gr, "__esModule", {
    value: !0
  });
  gr.ClassAccessorProperty = aee;
  gr.ClassBody = see;
  gr.ClassExpression = gr.ClassDeclaration = ree;
  gr.ClassMethod = lee;
  gr.ClassPrivateMethod = uee;
  gr.ClassPrivateProperty = oee;
  gr.ClassProperty = iee;
  gr.StaticBlock = pee;
  gr._classMethodHead = cee;
  var ZZ = ce(), {
    isExportDefaultDeclaration: eee,
    isExportNamedDeclaration: tee
  } = ZZ;
  function ree(e, t) {
    (!(eee(t) || tee(t)) || !this._shouldPrintDecoratorsBeforeExport(t)) && this.printJoin(e.decorators), e.declare && (this.word("declare"),
    this.space()), e.abstract && (this.word("abstract"), this.space()), this.word("class"), e.id && (this.space(), this.print(e.id)), this.print(
    e.typeParameters), e.superClass && (this.space(), this.word("extends"), this.space(), this.print(e.superClass), this.print(e.superTypeParameters)),
    e.implements && (this.space(), this.word("implements"), this.space(), this.printList(e.implements)), this.space(), this.print(e.body);
  }
  i(ree, "ClassDeclaration");
  function see(e) {
    if (this.tokenChar(123), e.body.length === 0)
      this.tokenChar(125);
    else {
      this.newline();
      let t = nee(this, e);
      t?.(-1);
      let r = this.enterDelimited();
      this.printJoin(e.body, !0, !0, t, !0), r(), this.endsWith(10) || this.newline(), this.rightBrace(e);
    }
  }
  i(see, "ClassBody");
  function nee(e, t) {
    if (!e.tokenMap || t.start == null || t.end == null)
      return null;
    let r = e.tokenMap.getIndexes(t);
    if (!r) return null;
    let s = 1, n = 0, a = 0, o = /* @__PURE__ */ i(() => {
      for (; a < t.body.length && t.body[a].start == null; )
        a++;
    }, "advanceNextLocIndex");
    return o(), (l) => {
      a <= l && (a = l + 1, o());
      let u = a === t.body.length ? t.end : t.body[a].start, c;
      for (; s < r.length && e.tokenMap.matchesOriginal(c = e._tokens[r[s]], ";") && c.start < u; )
        e.token(";", void 0, n++), s++;
    };
  }
  i(nee, "classBodyEmptySemicolonsPrinter");
  function iee(e) {
    if (this.printJoin(e.decorators), !e.static && !this.format.preserveFormat) {
      var t;
      let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
      r && this.catchUp(r);
    }
    this.tsPrintClassMemberModifiers(e), e.computed ? (this.tokenChar(91), this.print(e.key), this.tokenChar(93)) : (this._variance(e), this.
    print(e.key)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(33), this.print(e.typeAnnotation), e.value && (this.space(),
    this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
  }
  i(iee, "ClassProperty");
  function aee(e) {
    var t;
    this.printJoin(e.decorators);
    let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
    r && this.catchUp(r), this.tsPrintClassMemberModifiers(e), this.word("accessor", !0), this.space(), e.computed ? (this.tokenChar(91), this.
    print(e.key), this.tokenChar(93)) : (this._variance(e), this.print(e.key)), e.optional && this.tokenChar(63), e.definite && this.tokenChar(
    33), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
  }
  i(aee, "ClassAccessorProperty");
  function oee(e) {
    this.printJoin(e.decorators), this.tsPrintClassMemberModifiers(e), this.print(e.key), e.optional && this.tokenChar(63), e.definite && this.
    tokenChar(33), this.print(e.typeAnnotation), e.value && (this.space(), this.tokenChar(61), this.space(), this.print(e.value)), this.semicolon();
  }
  i(oee, "ClassPrivateProperty");
  function lee(e) {
    this._classMethodHead(e), this.space(), this.print(e.body);
  }
  i(lee, "ClassMethod");
  function uee(e) {
    this._classMethodHead(e), this.space(), this.print(e.body);
  }
  i(uee, "ClassPrivateMethod");
  function cee(e) {
    if (this.printJoin(e.decorators), !this.format.preserveFormat) {
      var t;
      let r = (t = e.key.loc) == null || (t = t.end) == null ? void 0 : t.line;
      r && this.catchUp(r);
    }
    this.tsPrintClassMemberModifiers(e), this._methodHead(e);
  }
  i(cee, "_classMethodHead");
  function pee(e) {
    this.word("static"), this.space(), this.tokenChar(123), e.body.length === 0 ? this.tokenChar(125) : (this.newline(), this.printSequence(
    e.body, !0), this.rightBrace(e));
  }
  i(pee, "StaticBlock");
});

// ../node_modules/@babel/generator/lib/generators/methods.js
var sv = D((Tr) => {
  "use strict";
  Object.defineProperty(Tr, "__esModule", {
    value: !0
  });
  Tr.ArrowFunctionExpression = See;
  Tr.FunctionDeclaration = Tr.FunctionExpression = Eee;
  Tr._functionHead = xee;
  Tr._methodHead = gee;
  Tr._param = bee;
  Tr._parameters = yee;
  Tr._params = mee;
  Tr._predicate = Tee;
  Tr._shouldPrintArrowParamsParens = vee;
  var fee = ce(), dee = Vn(), {
    isIdentifier: hee
  } = fee;
  function mee(e, t, r) {
    this.print(e.typeParameters);
    let s = Pee.call(this, t, r);
    s && this.sourceIdentifierName(s.name, s.pos), this.tokenChar(40), this._parameters(e.params, ")");
    let n = e.type === "ArrowFunctionExpression";
    this.print(e.returnType, n), this._noLineTerminator = n;
  }
  i(mee, "_params");
  function yee(e, t) {
    let r = this.enterDelimited(), s = this.shouldPrintTrailingComma(t), n = e.length;
    for (let a = 0; a < n; a++)
      this._param(e[a]), (s || a < n - 1) && (this.token(",", void 0, a), this.space());
    this.token(t), r();
  }
  i(yee, "_parameters");
  function bee(e) {
    this.printJoin(e.decorators), this.print(e), e.optional && this.tokenChar(63), this.print(e.typeAnnotation);
  }
  i(bee, "_param");
  function gee(e) {
    let t = e.kind, r = e.key;
    (t === "get" || t === "set") && (this.word(t), this.space()), e.async && (this.word("async", !0), this.space()), (t === "method" || t ===
    "init") && e.generator && this.tokenChar(42), e.computed ? (this.tokenChar(91), this.print(r), this.tokenChar(93)) : this.print(r), e.optional &&
    this.tokenChar(63), this._params(e, e.computed && e.key.type !== "StringLiteral" ? void 0 : e.key);
  }
  i(gee, "_methodHead");
  function Tee(e, t) {
    e.predicate && (e.returnType || this.tokenChar(58), this.space(), this.print(e.predicate, t));
  }
  i(Tee, "_predicate");
  function xee(e, t) {
    e.async && (this.word("async"), this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.space()), this.word("function"), e.generator &&
    (this.format.preserveFormat || (this._endsWithInnerRaw = !1), this.tokenChar(42)), this.space(), e.id && this.print(e.id), this._params(
    e, e.id, t), e.type !== "TSDeclareFunction" && this._predicate(e);
  }
  i(xee, "_functionHead");
  function Eee(e, t) {
    this._functionHead(e, t), this.space(), this.print(e.body);
  }
  i(Eee, "FunctionExpression");
  function See(e, t) {
    e.async && (this.word("async", !0), this.space()), this._shouldPrintArrowParamsParens(e) ? this._params(e, void 0, t) : this.print(e.params[0],
    !0), this._predicate(e, !0), this.space(), this.printInnerComments(), this.token("=>"), this.space(), this.tokenContext |= dee.TokenContext.
    arrowBody, this.print(e.body);
  }
  i(See, "ArrowFunctionExpression");
  function vee(e) {
    var t, r;
    if (e.params.length !== 1 || e.typeParameters || e.returnType || e.predicate)
      return !0;
    let s = e.params[0];
    if (!hee(s) || s.typeAnnotation || s.optional || (t = s.leadingComments) != null && t.length || (r = s.trailingComments) != null && r.length)
      return !0;
    if (this.tokenMap) {
      if (e.loc == null || this.tokenMap.findMatching(e, "(") !== null) return !0;
      let n = this.tokenMap.findMatching(e, "=>");
      return n?.loc == null ? !0 : n.loc.start.line !== e.loc.start.line;
    }
    return !!this.format.retainLines;
  }
  i(vee, "_shouldPrintArrowParamsParens");
  function Pee(e, t) {
    let r = e;
    if (!r && t) {
      let u = t.type;
      u === "VariableDeclarator" ? r = t.id : u === "AssignmentExpression" || u === "AssignmentPattern" ? r = t.left : u === "ObjectProperty" ||
      u === "ClassProperty" ? (!t.computed || t.key.type === "StringLiteral") && (r = t.key) : (u === "ClassPrivateProperty" || u === "Class\
AccessorProperty") && (r = t.key);
    }
    if (!r) return;
    let s;
    if (r.type === "Identifier") {
      var n, a;
      s = {
        pos: (n = r.loc) == null ? void 0 : n.start,
        name: ((a = r.loc) == null ? void 0 : a.identifierName) || r.name
      };
    } else if (r.type === "PrivateName") {
      var o;
      s = {
        pos: (o = r.loc) == null ? void 0 : o.start,
        name: "#" + r.id.name
      };
    } else if (r.type === "StringLiteral") {
      var l;
      s = {
        pos: (l = r.loc) == null ? void 0 : l.start,
        name: r.value
      };
    }
    return s;
  }
  i(Pee, "_getFuncIdName");
});

// ../node_modules/@babel/generator/lib/generators/modules.js
var Xh = D((Yt) => {
  "use strict";
  Object.defineProperty(Yt, "__esModule", {
    value: !0
  });
  Yt.ExportAllDeclaration = Mee;
  Yt.ExportDefaultDeclaration = qee;
  Yt.ExportDefaultSpecifier = kee;
  Yt.ExportNamedDeclaration = Ree;
  Yt.ExportNamespaceSpecifier = Lee;
  Yt.ExportSpecifier = Fee;
  Yt.ImportAttribute = $ee;
  Yt.ImportDeclaration = Uee;
  Yt.ImportDefaultSpecifier = Bee;
  Yt.ImportExpression = Kee;
  Yt.ImportNamespaceSpecifier = Vee;
  Yt.ImportSpecifier = Nee;
  Yt._printAttributes = jee;
  var Aee = ce(), Cee = Vn(), {
    isClassDeclaration: wee,
    isExportDefaultSpecifier: Dee,
    isExportNamespaceSpecifier: _ee,
    isImportDefaultSpecifier: Iee,
    isImportNamespaceSpecifier: Oee,
    isStatement: iv
  } = Aee;
  function Nee(e) {
    (e.importKind === "type" || e.importKind === "typeof") && (this.word(e.importKind), this.space()), this.print(e.imported), e.local && e.
    local.name !== e.imported.name && (this.space(), this.word("as"), this.space(), this.print(e.local));
  }
  i(Nee, "ImportSpecifier");
  function Bee(e) {
    this.print(e.local);
  }
  i(Bee, "ImportDefaultSpecifier");
  function kee(e) {
    this.print(e.exported);
  }
  i(kee, "ExportDefaultSpecifier");
  function Fee(e) {
    e.exportKind === "type" && (this.word("type"), this.space()), this.print(e.local), e.exported && e.local.name !== e.exported.name && (this.
    space(), this.word("as"), this.space(), this.print(e.exported));
  }
  i(Fee, "ExportSpecifier");
  function Lee(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.exported);
  }
  i(Lee, "ExportNamespaceSpecifier");
  var nv = !1;
  function jee(e, t) {
    var r;
    let {
      importAttributesKeyword: s
    } = this.format, {
      attributes: n,
      assertions: a
    } = e;
    n && !s && e.extra && (e.extra.deprecatedAssertSyntax || e.extra.deprecatedWithLegacySyntax) && !nv && (nv = !0, console.warn('You are u\
sing import attributes, without specifying the desired output syntax.\nPlease specify the "importAttributesKeyword" generator option, whose v\
alue can be one of:\n - "with"        : `import { a } from "b" with { type: "json" };`\n - "assert"      : `import { a } from "b" assert { typ\
e: "json" };`\n - "with-legacy" : `import { a } from "b" with type: "json";`\n'));
    let o = s === "assert" || !s && a;
    if (this.word(o ? "assert" : "with"), this.space(), !o && (s === "with-legacy" || !s && (r = e.extra) != null && r.deprecatedWithLegacySyntax)) {
      this.printList(n || a);
      return;
    }
    let l = t ? 1 : 0;
    this.token("{", void 0, l), this.space(), this.printList(n || a, this.shouldPrintTrailingComma("}")), this.space(), this.token("}", void 0,
    l);
  }
  i(jee, "_printAttributes");
  function Mee(e) {
    var t, r;
    this.word("export"), this.space(), e.exportKind === "type" && (this.word("type"), this.space()), this.tokenChar(42), this.space(), this.
    word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, !0),
    this.space(), this._printAttributes(e, !1)) : this.print(e.source), this.semicolon();
  }
  i(Mee, "ExportAllDeclaration");
  function av(e, t) {
    wee(t.declaration) && e._shouldPrintDecoratorsBeforeExport(t) && e.printJoin(t.declaration.decorators);
  }
  i(av, "maybePrintDecoratorsBeforeExport");
  function Ree(e) {
    if (av(this, e), this.word("export"), this.space(), e.declaration) {
      let s = e.declaration;
      this.print(s), iv(s) || this.semicolon();
    } else {
      e.exportKind === "type" && (this.word("type"), this.space());
      let s = e.specifiers.slice(0), n = !1;
      for (; ; ) {
        let o = s[0];
        if (Dee(o) || _ee(o))
          n = !0, this.print(s.shift()), s.length && (this.tokenChar(44), this.space());
        else
          break;
      }
      let a = !1;
      if ((s.length || !s.length && !n) && (a = !0, this.tokenChar(123), s.length && (this.space(), this.printList(s, this.shouldPrintTrailingComma(
      "}")), this.space()), this.tokenChar(125)), e.source) {
        var t, r;
        this.space(), this.word("from"), this.space(), (t = e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.
        print(e.source, !0), this.space(), this._printAttributes(e, a)) : this.print(e.source);
      }
      this.semicolon();
    }
  }
  i(Ree, "ExportNamedDeclaration");
  function qee(e) {
    av(this, e), this.word("export"), this.noIndentInnerCommentsHere(), this.space(), this.word("default"), this.space(), this.tokenContext |=
    Cee.TokenContext.exportDefault;
    let t = e.declaration;
    this.print(t), iv(t) || this.semicolon();
  }
  i(qee, "ExportDefaultDeclaration");
  function Uee(e) {
    var t, r;
    this.word("import"), this.space();
    let s = e.importKind === "type" || e.importKind === "typeof";
    s ? (this.noIndentInnerCommentsHere(), this.word(e.importKind), this.space()) : e.module ? (this.noIndentInnerCommentsHere(), this.word(
    "module"), this.space()) : e.phase && (this.noIndentInnerCommentsHere(), this.word(e.phase), this.space());
    let n = e.specifiers.slice(0), a = !!n.length;
    for (; a; ) {
      let l = n[0];
      if (Iee(l) || Oee(l))
        this.print(n.shift()), n.length && (this.tokenChar(44), this.space());
      else
        break;
    }
    let o = !1;
    n.length ? (o = !0, this.tokenChar(123), this.space(), this.printList(n, this.shouldPrintTrailingComma("}")), this.space(), this.tokenChar(
    125)) : s && !a && (o = !0, this.tokenChar(123), this.tokenChar(125)), (a || s) && (this.space(), this.word("from"), this.space()), (t =
    e.attributes) != null && t.length || (r = e.assertions) != null && r.length ? (this.print(e.source, !0), this.space(), this._printAttributes(
    e, o)) : this.print(e.source), this.semicolon();
  }
  i(Uee, "ImportDeclaration");
  function $ee(e) {
    this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
  }
  i($ee, "ImportAttribute");
  function Vee(e) {
    this.tokenChar(42), this.space(), this.word("as"), this.space(), this.print(e.local);
  }
  i(Vee, "ImportNamespaceSpecifier");
  function Kee(e) {
    this.word("import"), e.phase && (this.tokenChar(46), this.word(e.phase)), this.tokenChar(40);
    let t = this.shouldPrintTrailingComma(")");
    this.print(e.source), e.options != null && (this.tokenChar(44), this.space(), this.print(e.options)), t && this.tokenChar(44), this.rightParens(
    e);
  }
  i(Kee, "ImportExpression");
});

// ../node_modules/jsesc/jsesc.js
var cv = D((EDe, uv) => {
  "use strict";
  var ov = {}, Wee = ov.hasOwnProperty, lv = /* @__PURE__ */ i((e, t) => {
    for (let r in e)
      Wee.call(e, r) && t(r, e[r]);
  }, "forOwn"), Yee = /* @__PURE__ */ i((e, t) => (t && lv(t, (r, s) => {
    e[r] = s;
  }), e), "extend"), Hee = /* @__PURE__ */ i((e, t) => {
    let r = e.length, s = -1;
    for (; ++s < r; )
      t(e[s]);
  }, "forEach"), Iu = /* @__PURE__ */ i((e) => "\\u" + ("0000" + e).slice(-4), "fourHexEscape"), fo = /* @__PURE__ */ i((e, t) => {
    let r = e.toString(16);
    return t ? r : r.toUpperCase();
  }, "hexadecimal"), ho = ov.toString, Jee = Array.isArray, Gee = /* @__PURE__ */ i((e) => typeof Buffer == "function" && Buffer.isBuffer(e),
  "isBuffer"), Xee = /* @__PURE__ */ i((e) => ho.call(e) == "[object Object]", "isObject"), zee = /* @__PURE__ */ i((e) => typeof e == "stri\
ng" || ho.call(e) == "[object String]", "isString"), Qee = /* @__PURE__ */ i((e) => typeof e == "number" || ho.call(e) == "[object Number]",
  "isNumber"), zh = /* @__PURE__ */ i((e) => typeof e == "bigint", "isBigInt"), Zee = /* @__PURE__ */ i((e) => typeof e == "function", "isFu\
nction"), ete = /* @__PURE__ */ i((e) => ho.call(e) == "[object Map]", "isMap"), tte = /* @__PURE__ */ i((e) => ho.call(e) == "[object Set]",
  "isSet"), rte = {
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
    // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
    // '\v': '\\x0B'
  }, ste = /[\\\b\f\n\r\t]/, nte = /[0-9]/, ite = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/, ate = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g,
  ote = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g, tn = /* @__PURE__ */ i((e, t) => {
    let r = /* @__PURE__ */ i(() => {
      c = u, ++t.indentLevel, u = t.indent.repeat(t.indentLevel);
    }, "increaseIndentation"), s = {
      escapeEverything: !1,
      minimal: !1,
      isScriptContext: !1,
      quotes: "single",
      wrap: !1,
      es6: !1,
      json: !1,
      compact: !0,
      lowercaseHex: !1,
      numbers: "decimal",
      indent: "	",
      indentLevel: 0,
      __inline1__: !1,
      __inline2__: !1
    }, n = t && t.json;
    n && (s.quotes = "double", s.wrap = !0), t = Yee(s, t), t.quotes != "single" && t.quotes != "double" && t.quotes != "backtick" && (t.quotes =
    "single");
    let a = t.quotes == "double" ? '"' : t.quotes == "backtick" ? "`" : "'", o = t.compact, l = t.lowercaseHex, u = t.indent.repeat(t.indentLevel),
    c = "", p = t.__inline1__, f = t.__inline2__, h = o ? "" : `
`, b, T = !0, d = t.numbers == "binary", g = t.numbers == "octal", E = t.numbers == "decimal", _ = t.numbers == "hexadecimal";
    if (n && e && Zee(e.toJSON) && (e = e.toJSON()), !zee(e)) {
      if (ete(e))
        return e.size == 0 ? "new Map()" : (o || (t.__inline1__ = !0, t.__inline2__ = !1), "new Map(" + tn(Array.from(e), t) + ")");
      if (tte(e))
        return e.size == 0 ? "new Set()" : "new Set(" + tn(Array.from(e), t) + ")";
      if (Gee(e))
        return e.length == 0 ? "Buffer.from([])" : "Buffer.from(" + tn(Array.from(e), t) + ")";
      if (Jee(e))
        return b = [], t.wrap = !0, p && (t.__inline1__ = !1, t.__inline2__ = !0), f || r(), Hee(e, (k) => {
          T = !1, f && (t.__inline2__ = !1), b.push(
            (o || f ? "" : u) + tn(k, t)
          );
        }), T ? "[]" : f ? "[" + b.join(", ") + "]" : "[" + h + b.join("," + h) + h + (o ? "" : c) + "]";
      if (Qee(e) || zh(e)) {
        if (n)
          return JSON.stringify(Number(e));
        let k;
        if (E)
          k = String(e);
        else if (_) {
          let j = e.toString(16);
          l || (j = j.toUpperCase()), k = "0x" + j;
        } else d ? k = "0b" + e.toString(2) : g && (k = "0o" + e.toString(8));
        return zh(e) ? k + "n" : k;
      } else return zh(e) ? n ? JSON.stringify(Number(e)) : e + "n" : Xee(e) ? (b = [], t.wrap = !0, r(), lv(e, (k, j) => {
        T = !1, b.push(
          (o ? "" : u) + tn(k, t) + ":" + (o ? "" : " ") + tn(j, t)
        );
      }), T ? "{}" : "{" + h + b.join("," + h) + h + (o ? "" : c) + "}") : n ? JSON.stringify(e) || "null" : String(e);
    }
    let N = t.escapeEverything ? ate : ote;
    return b = e.replace(N, (k, j, U, M, K, G) => {
      if (j) {
        if (t.minimal) return j;
        let te = j.charCodeAt(0), De = j.charCodeAt(1);
        if (t.es6) {
          let je = (te - 55296) * 1024 + De - 56320 + 65536;
          return "\\u{" + fo(je, l) + "}";
        }
        return Iu(fo(te, l)) + Iu(fo(De, l));
      }
      if (U)
        return Iu(fo(U.charCodeAt(0), l));
      if (k == "\0" && !n && !nte.test(G.charAt(K + 1)))
        return "\\0";
      if (M)
        return M == a || t.escapeEverything ? "\\" + M : M;
      if (ste.test(k))
        return rte[k];
      if (t.minimal && !ite.test(k))
        return k;
      let ue = fo(k.charCodeAt(0), l);
      return n || ue.length > 2 ? Iu(ue) : "\\x" + ("00" + ue).slice(-2);
    }), a == "`" && (b = b.replace(/\$\{/g, "\\${")), t.isScriptContext && (b = b.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, n ?
    "\\u003C!--" : "\\x3C!--")), t.wrap && (b = a + b + a), b;
  }, "jsesc");
  tn.version = "3.0.2";
  uv.exports = tn;
});

// ../node_modules/@babel/generator/lib/generators/types.js
var Zh = D((Ve) => {
  "use strict";
  Object.defineProperty(Ve, "__esModule", {
    value: !0
  });
  Ve.ArgumentPlaceholder = fte;
  Ve.ArrayPattern = Ve.ArrayExpression = bte;
  Ve.BigIntLiteral = Ate;
  Ve.BooleanLiteral = Ete;
  Ve.Identifier = pte;
  Ve.NullLiteral = Ste;
  Ve.NumericLiteral = vte;
  Ve.ObjectPattern = Ve.ObjectExpression = hte;
  Ve.ObjectMethod = mte;
  Ve.ObjectProperty = yte;
  Ve.PipelineBareFunction = Dte;
  Ve.PipelinePrimaryTopicReference = _te;
  Ve.PipelineTopicExpression = wte;
  Ve.RecordExpression = gte;
  Ve.RegExpLiteral = xte;
  Ve.SpreadElement = Ve.RestElement = dte;
  Ve.StringLiteral = Pte;
  Ve.TopicReference = Cte;
  Ve.TupleExpression = Tte;
  Ve.VoidPattern = Ite;
  Ve._getRawIdentifier = cte;
  var lte = ce(), dv = cv(), {
    isAssignmentPattern: ute,
    isIdentifier: Qh
  } = lte, pv = null, Ou = "";
  function cte(e) {
    if (e === pv) return Ou;
    pv = e;
    let {
      name: t
    } = e, r = this.tokenMap.find(e, (s) => s.value === t);
    return r ? (Ou = this._originalCode.slice(r.start, r.end), Ou) : Ou = e.name;
  }
  i(cte, "_getRawIdentifier");
  function pte(e) {
    var t;
    this.sourceIdentifierName(((t = e.loc) == null ? void 0 : t.identifierName) || e.name), this.word(this.tokenMap ? this._getRawIdentifier(
    e) : e.name);
  }
  i(pte, "Identifier");
  function fte() {
    this.tokenChar(63);
  }
  i(fte, "ArgumentPlaceholder");
  function dte(e) {
    this.token("..."), this.print(e.argument);
  }
  i(dte, "RestElement");
  function hte(e) {
    let t = e.properties;
    if (this.tokenChar(123), t.length) {
      let r = this.enterDelimited();
      this.space(), this.printList(t, this.shouldPrintTrailingComma("}"), !0, !0), this.space(), r();
    }
    this.sourceWithOffset("end", e.loc, -1), this.tokenChar(125);
  }
  i(hte, "ObjectExpression");
  function mte(e) {
    this.printJoin(e.decorators), this._methodHead(e), this.space(), this.print(e.body);
  }
  i(mte, "ObjectMethod");
  function yte(e) {
    if (this.printJoin(e.decorators), e.computed)
      this.tokenChar(91), this.print(e.key), this.tokenChar(93);
    else {
      if (ute(e.value) && Qh(e.key) && e.key.name === e.value.left.name) {
        this.print(e.value);
        return;
      }
      if (this.print(e.key), e.shorthand && Qh(e.key) && Qh(e.value) && e.key.name === e.value.name)
        return;
    }
    this.tokenChar(58), this.space(), this.print(e.value);
  }
  i(yte, "ObjectProperty");
  function bte(e) {
    let t = e.elements, r = t.length;
    this.tokenChar(91);
    let s = this.enterDelimited();
    for (let n = 0; n < t.length; n++) {
      let a = t[n];
      a ? (n > 0 && this.space(), this.print(a), (n < r - 1 || this.shouldPrintTrailingComma("]")) && this.token(",", !1, n)) : this.token("\
,", !1, n);
    }
    s(), this.tokenChar(93);
  }
  i(bte, "ArrayExpression");
  function gte(e) {
    let t = e.properties, r, s;
    if (this.format.recordAndTupleSyntaxType === "bar")
      r = "{|", s = "|}";
    else {
      if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null)
        throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)}\
 received).`);
      r = "#{", s = "}";
    }
    this.token(r), t.length && (this.space(), this.printList(t, this.shouldPrintTrailingComma(s), !0, !0), this.space()), this.token(s);
  }
  i(gte, "RecordExpression");
  function Tte(e) {
    let t = e.elements, r = t.length, s, n;
    if (this.format.recordAndTupleSyntaxType === "bar")
      s = "[|", n = "|]";
    else if (this.format.recordAndTupleSyntaxType === "hash")
      s = "#[", n = "]";
    else
      throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
    this.token(s);
    for (let a = 0; a < t.length; a++) {
      let o = t[a];
      o && (a > 0 && this.space(), this.print(o), (a < r - 1 || this.shouldPrintTrailingComma(n)) && this.token(",", !1, a));
    }
    this.token(n);
  }
  i(Tte, "TupleExpression");
  function xte(e) {
    this.word(`/${e.pattern}/${e.flags}`);
  }
  i(xte, "RegExpLiteral");
  function Ete(e) {
    this.word(e.value ? "true" : "false");
  }
  i(Ete, "BooleanLiteral");
  function Ste() {
    this.word("null");
  }
  i(Ste, "NullLiteral");
  function vte(e) {
    let t = this.getPossibleRaw(e), r = this.format.jsescOption, s = e.value, n = s + "";
    r.numbers ? this.number(dv(s, r), s) : t == null ? this.number(n, s) : this.format.minified ? this.number(t.length < n.length ? t : n, s) :
    this.number(t, s);
  }
  i(vte, "NumericLiteral");
  function Pte(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let r = dv(e.value, this.format.jsescOption);
    this.token(r);
  }
  i(Pte, "StringLiteral");
  function Ate(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.word(t);
      return;
    }
    this.word(e.value + "n");
  }
  i(Ate, "BigIntLiteral");
  var fv = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
  function Cte() {
    let {
      topicToken: e
    } = this.format;
    if (fv.has(e))
      this.token(e);
    else {
      let t = JSON.stringify(e), r = Array.from(fv, (s) => JSON.stringify(s));
      throw new Error(`The "topicToken" generator option must be one of ${r.join(", ")} (${t} received instead).`);
    }
  }
  i(Cte, "TopicReference");
  function wte(e) {
    this.print(e.expression);
  }
  i(wte, "PipelineTopicExpression");
  function Dte(e) {
    this.print(e.callee);
  }
  i(Dte, "PipelineBareFunction");
  function _te() {
    this.tokenChar(35);
  }
  i(_te, "PipelinePrimaryTopicReference");
  function Ite() {
    this.word("void");
  }
  i(Ite, "VoidPattern");
});

// ../node_modules/@babel/generator/lib/generators/flow.js
var mv = D((Z) => {
  "use strict";
  Object.defineProperty(Z, "__esModule", {
    value: !0
  });
  Z.AnyTypeAnnotation = Fte;
  Z.ArrayTypeAnnotation = Lte;
  Z.BooleanLiteralTypeAnnotation = Mte;
  Z.BooleanTypeAnnotation = jte;
  Z.DeclareClass = qte;
  Z.DeclareExportAllDeclaration = zte;
  Z.DeclareExportDeclaration = Xte;
  Z.DeclareFunction = Ute;
  Z.DeclareInterface = Kte;
  Z.DeclareModule = Wte;
  Z.DeclareModuleExports = Yte;
  Z.DeclareOpaqueType = Jte;
  Z.DeclareTypeAlias = Hte;
  Z.DeclareVariable = Gte;
  Z.DeclaredPredicate = Vte;
  Z.EmptyTypeAnnotation = Tre;
  Z.EnumBooleanBody = Zte;
  Z.EnumBooleanMember = nre;
  Z.EnumDeclaration = Qte;
  Z.EnumDefaultedMember = sre;
  Z.EnumNumberBody = ere;
  Z.EnumNumberMember = ire;
  Z.EnumStringBody = tre;
  Z.EnumStringMember = are;
  Z.EnumSymbolBody = rre;
  Z.ExistsTypeAnnotation = lre;
  Z.FunctionTypeAnnotation = ure;
  Z.FunctionTypeParam = cre;
  Z.IndexedAccessType = Kre;
  Z.InferredPredicate = $te;
  Z.InterfaceDeclaration = hre;
  Z.GenericTypeAnnotation = Z.ClassImplements = Z.InterfaceExtends = pre;
  Z.InterfaceTypeAnnotation = yre;
  Z.IntersectionTypeAnnotation = bre;
  Z.MixedTypeAnnotation = gre;
  Z.NullLiteralTypeAnnotation = Rte;
  Z.NullableTypeAnnotation = xre;
  Object.defineProperty(Z, "NumberLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return hv.NumericLiteral;
    }, "get")
  });
  Z.NumberTypeAnnotation = Ere;
  Z.ObjectTypeAnnotation = Ore;
  Z.ObjectTypeCallProperty = Bre;
  Z.ObjectTypeIndexer = kre;
  Z.ObjectTypeInternalSlot = Nre;
  Z.ObjectTypeProperty = Fre;
  Z.ObjectTypeSpreadProperty = Lre;
  Z.OpaqueType = Ire;
  Z.OptionalIndexedAccessType = Wre;
  Z.QualifiedTypeIdentifier = jre;
  Object.defineProperty(Z, "StringLiteralTypeAnnotation", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return hv.StringLiteral;
    }, "get")
  });
  Z.StringTypeAnnotation = Sre;
  Z.SymbolTypeAnnotation = Mre;
  Z.ThisTypeAnnotation = vre;
  Z.TupleTypeAnnotation = Pre;
  Z.TypeAlias = Cre;
  Z.TypeAnnotation = wre;
  Z.TypeCastExpression = Ure;
  Z.TypeParameter = _re;
  Z.TypeParameterDeclaration = Z.TypeParameterInstantiation = Dre;
  Z.TypeofTypeAnnotation = Are;
  Z.UnionTypeAnnotation = qre;
  Z.Variance = $re;
  Z.VoidTypeAnnotation = Vre;
  Z._interfaceish = fre;
  Z._variance = dre;
  var Ote = ce(), Nte = Xh(), Bte = Vn(), hv = Zh(), {
    isDeclareExportDeclaration: Nu,
    isStatement: kte
  } = Ote;
  function Fte() {
    this.word("any");
  }
  i(Fte, "AnyTypeAnnotation");
  function Lte(e) {
    this.print(e.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  i(Lte, "ArrayTypeAnnotation");
  function jte() {
    this.word("boolean");
  }
  i(jte, "BooleanTypeAnnotation");
  function Mte(e) {
    this.word(e.value ? "true" : "false");
  }
  i(Mte, "BooleanLiteralTypeAnnotation");
  function Rte() {
    this.word("null");
  }
  i(Rte, "NullLiteralTypeAnnotation");
  function qte(e, t) {
    Nu(t) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e);
  }
  i(qte, "DeclareClass");
  function Ute(e, t) {
    Nu(t) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e.id), this.print(e.id.typeAnnotation.typeAnnotation),
    e.predicate && (this.space(), this.print(e.predicate)), this.semicolon();
  }
  i(Ute, "DeclareFunction");
  function $te() {
    this.tokenChar(37), this.word("checks");
  }
  i($te, "InferredPredicate");
  function Vte(e) {
    this.tokenChar(37), this.word("checks"), this.tokenChar(40), this.print(e.value), this.tokenChar(41);
  }
  i(Vte, "DeclaredPredicate");
  function Kte(e) {
    this.word("declare"), this.space(), this.InterfaceDeclaration(e);
  }
  i(Kte, "DeclareInterface");
  function Wte(e) {
    this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e.id), this.space(), this.print(e.body);
  }
  i(Wte, "DeclareModule");
  function Yte(e) {
    this.word("declare"), this.space(), this.word("module"), this.tokenChar(46), this.word("exports"), this.print(e.typeAnnotation);
  }
  i(Yte, "DeclareModuleExports");
  function Hte(e) {
    this.word("declare"), this.space(), this.TypeAlias(e);
  }
  i(Hte, "DeclareTypeAlias");
  function Jte(e, t) {
    Nu(t) || (this.word("declare"), this.space()), this.OpaqueType(e);
  }
  i(Jte, "DeclareOpaqueType");
  function Gte(e, t) {
    Nu(t) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e.id), this.print(e.id.typeAnnotation), this.semicolon();
  }
  i(Gte, "DeclareVariable");
  function Xte(e) {
    this.word("declare"), this.space(), this.word("export"), this.space(), e.default && (this.word("default"), this.space()), ore.call(this,
    e);
  }
  i(Xte, "DeclareExportDeclaration");
  function zte(e) {
    this.word("declare"), this.space(), Nte.ExportAllDeclaration.call(this, e);
  }
  i(zte, "DeclareExportAllDeclaration");
  function Qte(e) {
    let {
      id: t,
      body: r
    } = e;
    this.word("enum"), this.space(), this.print(t), this.print(r);
  }
  i(Qte, "EnumDeclaration");
  function Bu(e, t, r) {
    r && (e.space(), e.word("of"), e.space(), e.word(t)), e.space();
  }
  i(Bu, "enumExplicitType");
  function ku(e, t) {
    let {
      members: r
    } = t;
    e.token("{"), e.indent(), e.newline();
    for (let s of r)
      e.print(s), e.newline();
    t.hasUnknownMembers && (e.token("..."), e.newline()), e.dedent(), e.token("}");
  }
  i(ku, "enumBody");
  function Zte(e) {
    let {
      explicitType: t
    } = e;
    Bu(this, "boolean", t), ku(this, e);
  }
  i(Zte, "EnumBooleanBody");
  function ere(e) {
    let {
      explicitType: t
    } = e;
    Bu(this, "number", t), ku(this, e);
  }
  i(ere, "EnumNumberBody");
  function tre(e) {
    let {
      explicitType: t
    } = e;
    Bu(this, "string", t), ku(this, e);
  }
  i(tre, "EnumStringBody");
  function rre(e) {
    Bu(this, "symbol", !0), ku(this, e);
  }
  i(rre, "EnumSymbolBody");
  function sre(e) {
    let {
      id: t
    } = e;
    this.print(t), this.tokenChar(44);
  }
  i(sre, "EnumDefaultedMember");
  function e1(e, t) {
    e.print(t.id), e.space(), e.token("="), e.space(), e.print(t.init), e.token(",");
  }
  i(e1, "enumInitializedMember");
  function nre(e) {
    e1(this, e);
  }
  i(nre, "EnumBooleanMember");
  function ire(e) {
    e1(this, e);
  }
  i(ire, "EnumNumberMember");
  function are(e) {
    e1(this, e);
  }
  i(are, "EnumStringMember");
  function ore(e) {
    if (e.declaration) {
      let t = e.declaration;
      this.print(t), kte(t) || this.semicolon();
    } else
      this.tokenChar(123), e.specifiers.length && (this.space(), this.printList(e.specifiers), this.space()), this.tokenChar(125), e.source &&
      (this.space(), this.word("from"), this.space(), this.print(e.source)), this.semicolon();
  }
  i(ore, "FlowExportDeclaration");
  function lre() {
    this.tokenChar(42);
  }
  i(lre, "ExistsTypeAnnotation");
  function ure(e, t) {
    this.print(e.typeParameters), this.tokenChar(40), e.this && (this.word("this"), this.tokenChar(58), this.space(), this.print(e.this.typeAnnotation),
    (e.params.length || e.rest) && (this.tokenChar(44), this.space())), this.printList(e.params), e.rest && (e.params.length && (this.tokenChar(
    44), this.space()), this.token("..."), this.print(e.rest)), this.tokenChar(41);
    let r = t?.type;
    r != null && (r === "ObjectTypeCallProperty" || r === "ObjectTypeInternalSlot" || r === "DeclareFunction" || r === "ObjectTypeProperty" &&
    t.method) ? this.tokenChar(58) : (this.space(), this.token("=>")), this.space(), this.print(e.returnType);
  }
  i(ure, "FunctionTypeAnnotation");
  function cre(e) {
    this.print(e.name), e.optional && this.tokenChar(63), e.name && (this.tokenChar(58), this.space()), this.print(e.typeAnnotation);
  }
  i(cre, "FunctionTypeParam");
  function pre(e) {
    this.print(e.id), this.print(e.typeParameters, !0);
  }
  i(pre, "InterfaceExtends");
  function fre(e) {
    var t;
    if (this.print(e.id), this.print(e.typeParameters), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(),
    this.printList(e.extends)), e.type === "DeclareClass") {
      var r, s;
      (r = e.mixins) != null && r.length && (this.space(), this.word("mixins"), this.space(), this.printList(e.mixins)), (s = e.implements) !=
      null && s.length && (this.space(), this.word("implements"), this.space(), this.printList(e.implements));
    }
    this.space(), this.print(e.body);
  }
  i(fre, "_interfaceish");
  function dre(e) {
    var t;
    let r = (t = e.variance) == null ? void 0 : t.kind;
    r != null && (r === "plus" ? this.tokenChar(43) : r === "minus" && this.tokenChar(45));
  }
  i(dre, "_variance");
  function hre(e) {
    this.word("interface"), this.space(), this._interfaceish(e);
  }
  i(hre, "InterfaceDeclaration");
  function mre(e) {
    this.space(), this.token("&", !1, e), this.space();
  }
  i(mre, "andSeparator");
  function yre(e) {
    var t;
    this.word("interface"), (t = e.extends) != null && t.length && (this.space(), this.word("extends"), this.space(), this.printList(e.extends)),
    this.space(), this.print(e.body);
  }
  i(yre, "InterfaceTypeAnnotation");
  function bre(e) {
    this.printJoin(e.types, void 0, void 0, mre);
  }
  i(bre, "IntersectionTypeAnnotation");
  function gre() {
    this.word("mixed");
  }
  i(gre, "MixedTypeAnnotation");
  function Tre() {
    this.word("empty");
  }
  i(Tre, "EmptyTypeAnnotation");
  function xre(e) {
    this.tokenChar(63), this.print(e.typeAnnotation);
  }
  i(xre, "NullableTypeAnnotation");
  function Ere() {
    this.word("number");
  }
  i(Ere, "NumberTypeAnnotation");
  function Sre() {
    this.word("string");
  }
  i(Sre, "StringTypeAnnotation");
  function vre() {
    this.word("this");
  }
  i(vre, "ThisTypeAnnotation");
  function Pre(e) {
    this.tokenChar(91), this.printList(e.types), this.tokenChar(93);
  }
  i(Pre, "TupleTypeAnnotation");
  function Are(e) {
    this.word("typeof"), this.space(), this.print(e.argument);
  }
  i(Are, "TypeofTypeAnnotation");
  function Cre(e) {
    this.word("type"), this.space(), this.print(e.id), this.print(e.typeParameters), this.space(), this.tokenChar(61), this.space(), this.print(
    e.right), this.semicolon();
  }
  i(Cre, "TypeAlias");
  function wre(e, t) {
    this.tokenChar(58), this.space(), t.type === "ArrowFunctionExpression" ? this.tokenContext |= Bte.TokenContext.arrowFlowReturnType : e.optional &&
    this.tokenChar(63), this.print(e.typeAnnotation);
  }
  i(wre, "TypeAnnotation");
  function Dre(e) {
    this.tokenChar(60), this.printList(e.params), this.tokenChar(62);
  }
  i(Dre, "TypeParameterInstantiation");
  function _re(e) {
    this._variance(e), this.word(e.name), e.bound && this.print(e.bound), e.default && (this.space(), this.tokenChar(61), this.space(), this.
    print(e.default));
  }
  i(_re, "TypeParameter");
  function Ire(e) {
    this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e.id), this.print(e.typeParameters), e.supertype && (this.
    tokenChar(58), this.space(), this.print(e.supertype)), e.impltype && (this.space(), this.tokenChar(61), this.space(), this.print(e.impltype)),
    this.semicolon();
  }
  i(Ire, "OpaqueType");
  function Ore(e) {
    e.exact ? this.token("{|") : this.tokenChar(123);
    let t = [...e.properties, ...e.callProperties || [], ...e.indexers || [], ...e.internalSlots || []];
    t.length && (this.newline(), this.space(), this.printJoin(t, !0, !0, void 0, void 0, () => {
      (t.length !== 1 || e.inexact) && (this.tokenChar(44), this.space());
    }), this.space()), e.inexact && (this.indent(), this.token("..."), t.length && this.newline(), this.dedent()), e.exact ? this.token("|}") :
    this.tokenChar(125);
  }
  i(Ore, "ObjectTypeAnnotation");
  function Nre(e) {
    e.static && (this.word("static"), this.space()), this.tokenChar(91), this.tokenChar(91), this.print(e.id), this.tokenChar(93), this.tokenChar(
    93), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58), this.space()), this.print(e.value);
  }
  i(Nre, "ObjectTypeInternalSlot");
  function Bre(e) {
    e.static && (this.word("static"), this.space()), this.print(e.value);
  }
  i(Bre, "ObjectTypeCallProperty");
  function kre(e) {
    e.static && (this.word("static"), this.space()), this._variance(e), this.tokenChar(91), e.id && (this.print(e.id), this.tokenChar(58), this.
    space()), this.print(e.key), this.tokenChar(93), this.tokenChar(58), this.space(), this.print(e.value);
  }
  i(kre, "ObjectTypeIndexer");
  function Fre(e) {
    e.proto && (this.word("proto"), this.space()), e.static && (this.word("static"), this.space()), (e.kind === "get" || e.kind === "set") &&
    (this.word(e.kind), this.space()), this._variance(e), this.print(e.key), e.optional && this.tokenChar(63), e.method || (this.tokenChar(58),
    this.space()), this.print(e.value);
  }
  i(Fre, "ObjectTypeProperty");
  function Lre(e) {
    this.token("..."), this.print(e.argument);
  }
  i(Lre, "ObjectTypeSpreadProperty");
  function jre(e) {
    this.print(e.qualification), this.tokenChar(46), this.print(e.id);
  }
  i(jre, "QualifiedTypeIdentifier");
  function Mre() {
    this.word("symbol");
  }
  i(Mre, "SymbolTypeAnnotation");
  function Rre(e) {
    this.space(), this.token("|", !1, e), this.space();
  }
  i(Rre, "orSeparator");
  function qre(e) {
    this.printJoin(e.types, void 0, void 0, Rre);
  }
  i(qre, "UnionTypeAnnotation");
  function Ure(e) {
    this.tokenChar(40), this.print(e.expression), this.print(e.typeAnnotation), this.tokenChar(41);
  }
  i(Ure, "TypeCastExpression");
  function $re(e) {
    e.kind === "plus" ? this.tokenChar(43) : this.tokenChar(45);
  }
  i($re, "Variance");
  function Vre() {
    this.word("void");
  }
  i(Vre, "VoidTypeAnnotation");
  function Kre(e) {
    this.print(e.objectType, !0), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
  }
  i(Kre, "IndexedAccessType");
  function Wre(e) {
    this.print(e.objectType), e.optional && this.token("?."), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
  }
  i(Wre, "OptionalIndexedAccessType");
});

// ../node_modules/@babel/generator/lib/generators/base.js
var yv = D((Ss) => {
  "use strict";
  Object.defineProperty(Ss, "__esModule", {
    value: !0
  });
  Ss.BlockStatement = Jre;
  Ss.Directive = Gre;
  Ss.DirectiveLiteral = Qre;
  Ss.File = Yre;
  Ss.InterpreterDirective = Zre;
  Ss.Placeholder = ese;
  Ss.Program = Hre;
  function Yre(e) {
    e.program && this.print(e.program.interpreter), this.print(e.program);
  }
  i(Yre, "File");
  function Hre(e) {
    var t;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    let r = (t = e.directives) == null ? void 0 : t.length;
    if (r) {
      var s;
      let n = e.body.length ? 2 : 1;
      this.printSequence(e.directives, void 0, n), (s = e.directives[r - 1].trailingComments) != null && s.length || this.newline(n);
    }
    this.printSequence(e.body);
  }
  i(Hre, "Program");
  function Jre(e) {
    var t;
    this.tokenChar(123);
    let r = this.enterDelimited(), s = (t = e.directives) == null ? void 0 : t.length;
    if (s) {
      var n;
      let a = e.body.length ? 2 : 1;
      this.printSequence(e.directives, !0, a), (n = e.directives[s - 1].trailingComments) != null && n.length || this.newline(a);
    }
    this.printSequence(e.body, !0), r(), this.rightBrace(e);
  }
  i(Jre, "BlockStatement");
  function Gre(e) {
    this.print(e.value), this.semicolon();
  }
  i(Gre, "Directive");
  var Xre = /(?:^|[^\\])(?:\\\\)*'/, zre = /(?:^|[^\\])(?:\\\\)*"/;
  function Qre(e) {
    let t = this.getPossibleRaw(e);
    if (!this.format.minified && t !== void 0) {
      this.token(t);
      return;
    }
    let {
      value: r
    } = e;
    if (!zre.test(r))
      this.token(`"${r}"`);
    else if (!Xre.test(r))
      this.token(`'${r}'`);
    else
      throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
  }
  i(Qre, "DirectiveLiteral");
  function Zre(e) {
    this.token(`#!${e.value}`), this.newline(1, !0);
  }
  i(Zre, "InterpreterDirective");
  function ese(e) {
    this.token("%%"), this.print(e.name), this.token("%%"), e.expectedNode === "Statement" && this.semicolon();
  }
  i(ese, "Placeholder");
});

// ../node_modules/@babel/generator/lib/generators/jsx.js
var bv = D((Et) => {
  "use strict";
  Object.defineProperty(Et, "__esModule", {
    value: !0
  });
  Et.JSXAttribute = tse;
  Et.JSXClosingElement = fse;
  Et.JSXClosingFragment = yse;
  Et.JSXElement = use;
  Et.JSXEmptyExpression = dse;
  Et.JSXExpressionContainer = ase;
  Et.JSXFragment = hse;
  Et.JSXIdentifier = rse;
  Et.JSXMemberExpression = nse;
  Et.JSXNamespacedName = sse;
  Et.JSXOpeningElement = pse;
  Et.JSXOpeningFragment = mse;
  Et.JSXSpreadAttribute = ise;
  Et.JSXSpreadChild = ose;
  Et.JSXText = lse;
  function tse(e) {
    this.print(e.name), e.value && (this.tokenChar(61), this.print(e.value));
  }
  i(tse, "JSXAttribute");
  function rse(e) {
    this.word(e.name);
  }
  i(rse, "JSXIdentifier");
  function sse(e) {
    this.print(e.namespace), this.tokenChar(58), this.print(e.name);
  }
  i(sse, "JSXNamespacedName");
  function nse(e) {
    this.print(e.object), this.tokenChar(46), this.print(e.property);
  }
  i(nse, "JSXMemberExpression");
  function ise(e) {
    this.tokenChar(123), this.token("..."), this.print(e.argument), this.rightBrace(e);
  }
  i(ise, "JSXSpreadAttribute");
  function ase(e) {
    this.tokenChar(123), this.print(e.expression), this.rightBrace(e);
  }
  i(ase, "JSXExpressionContainer");
  function ose(e) {
    this.tokenChar(123), this.token("..."), this.print(e.expression), this.rightBrace(e);
  }
  i(ose, "JSXSpreadChild");
  function lse(e) {
    let t = this.getPossibleRaw(e);
    t !== void 0 ? this.token(t, !0) : this.token(e.value, !0);
  }
  i(lse, "JSXText");
  function use(e) {
    let t = e.openingElement;
    if (this.print(t), !t.selfClosing) {
      this.indent();
      for (let r of e.children)
        this.print(r);
      this.dedent(), this.print(e.closingElement);
    }
  }
  i(use, "JSXElement");
  function cse() {
    this.space();
  }
  i(cse, "spaceSeparator");
  function pse(e) {
    this.tokenChar(60), this.print(e.name), e.typeArguments && this.print(e.typeArguments), this.print(e.typeParameters), e.attributes.length >
    0 && (this.space(), this.printJoin(e.attributes, void 0, void 0, cse)), e.selfClosing && (this.space(), this.tokenChar(47)), this.tokenChar(
    62);
  }
  i(pse, "JSXOpeningElement");
  function fse(e) {
    this.tokenChar(60), this.tokenChar(47), this.print(e.name), this.tokenChar(62);
  }
  i(fse, "JSXClosingElement");
  function dse() {
    this.printInnerComments();
  }
  i(dse, "JSXEmptyExpression");
  function hse(e) {
    this.print(e.openingFragment), this.indent();
    for (let t of e.children)
      this.print(t);
    this.dedent(), this.print(e.closingFragment);
  }
  i(hse, "JSXFragment");
  function mse() {
    this.tokenChar(60), this.tokenChar(62);
  }
  i(mse, "JSXOpeningFragment");
  function yse() {
    this.token("</"), this.tokenChar(62);
  }
  i(yse, "JSXClosingFragment");
});

// ../node_modules/@babel/generator/lib/generators/typescript.js
var Sv = D((X) => {
  "use strict";
  Object.defineProperty(X, "__esModule", {
    value: !0
  });
  X.TSAnyKeyword = Ise;
  X.TSArrayType = zse;
  X.TSSatisfiesExpression = X.TSAsExpression = yne;
  X.TSBigIntKeyword = Ose;
  X.TSBooleanKeyword = Fse;
  X.TSCallSignatureDeclaration = Pse;
  X.TSInterfaceHeritage = X.TSClassImplements = fne;
  X.TSConditionalType = nne;
  X.TSConstructSignatureDeclaration = Ase;
  X.TSConstructorType = Wse;
  X.TSDeclareFunction = Ese;
  X.TSDeclareMethod = Sse;
  X.TSEnumBody = Ev;
  X.TSEnumDeclaration = Tne;
  X.TSEnumMember = xne;
  X.TSExportAssignment = wne;
  X.TSExternalModuleReference = Ane;
  X.TSFunctionType = Kse;
  X.TSImportEqualsDeclaration = Pne;
  X.TSImportType = vne;
  X.TSIndexSignature = _se;
  X.TSIndexedAccessType = lne;
  X.TSInferType = ine;
  X.TSInstantiationExpression = gne;
  X.TSInterfaceBody = hne;
  X.TSInterfaceDeclaration = dne;
  X.TSIntersectionType = sne;
  X.TSIntrinsicKeyword = $se;
  X.TSLiteralType = pne;
  X.TSMappedType = une;
  X.TSMethodSignature = Dse;
  X.TSModuleBlock = Sne;
  X.TSModuleDeclaration = Ene;
  X.TSNamedTupleMember = tne;
  X.TSNamespaceExportDeclaration = Dne;
  X.TSNeverKeyword = Use;
  X.TSNonNullExpression = Cne;
  X.TSNullKeyword = qse;
  X.TSNumberKeyword = Bse;
  X.TSObjectKeyword = kse;
  X.TSOptionalType = Zse;
  X.TSParameterProperty = xse;
  X.TSParenthesizedType = ane;
  X.TSPropertySignature = Cse;
  X.TSQualifiedName = vse;
  X.TSRestType = ene;
  X.TSStringKeyword = Lse;
  X.TSSymbolKeyword = jse;
  X.TSTemplateLiteralType = cne;
  X.TSThisType = Vse;
  X.TSTupleType = Qse;
  X.TSTypeAliasDeclaration = mne;
  X.TSTypeAnnotation = bse;
  X.TSTypeAssertion = bne;
  X.TSTypeLiteral = Xse;
  X.TSTypeOperator = one;
  X.TSTypeParameter = Tse;
  X.TSTypeParameterDeclaration = X.TSTypeParameterInstantiation = gse;
  X.TSTypePredicate = Jse;
  X.TSTypeQuery = Gse;
  X.TSTypeReference = Hse;
  X.TSUndefinedKeyword = Rse;
  X.TSUnionType = rne;
  X.TSUnknownKeyword = Nse;
  X.TSVoidKeyword = Mse;
  X.tsPrintClassMemberModifiers = Ine;
  X.tsPrintFunctionOrConstructorType = Yse;
  X.tsPrintPropertyOrMethodName = wse;
  X.tsPrintSignatureDeclarationBase = _ne;
  function bse(e, t) {
    this.token((t.type === "TSFunctionType" || t.type === "TSConstructorType") && t.typeAnnotation === e ? "=>" : ":"), this.space(), e.optional &&
    this.tokenChar(63), this.print(e.typeAnnotation);
  }
  i(bse, "TSTypeAnnotation");
  function gse(e, t) {
    this.tokenChar(60);
    let r = t.type === "ArrowFunctionExpression" && e.params.length === 1;
    this.tokenMap && e.start != null && e.end != null && (r && (r = !!this.tokenMap.find(e, (s) => this.tokenMap.matchesOriginal(s, ","))), r ||
    (r = this.shouldPrintTrailingComma(">"))), this.printList(e.params, r), this.tokenChar(62);
  }
  i(gse, "TSTypeParameterInstantiation");
  function Tse(e) {
    e.const && (this.word("const"), this.space()), e.in && (this.word("in"), this.space()), e.out && (this.word("out"), this.space()), this.
    word(e.name), e.constraint && (this.space(), this.word("extends"), this.space(), this.print(e.constraint)), e.default && (this.space(), this.
    tokenChar(61), this.space(), this.print(e.default));
  }
  i(Tse, "TSTypeParameter");
  function xse(e) {
    e.accessibility && (this.word(e.accessibility), this.space()), e.readonly && (this.word("readonly"), this.space()), this._param(e.parameter);
  }
  i(xse, "TSParameterProperty");
  function Ese(e, t) {
    e.declare && (this.word("declare"), this.space()), this._functionHead(e, t), this.semicolon();
  }
  i(Ese, "TSDeclareFunction");
  function Sse(e) {
    this._classMethodHead(e), this.semicolon();
  }
  i(Sse, "TSDeclareMethod");
  function vse(e) {
    this.print(e.left), this.tokenChar(46), this.print(e.right);
  }
  i(vse, "TSQualifiedName");
  function Pse(e) {
    this.tsPrintSignatureDeclarationBase(e), mo(this, e);
  }
  i(Pse, "TSCallSignatureDeclaration");
  function mo(e, t) {
    if (!e.tokenMap || !t.start || !t.end) {
      e.semicolon();
      return;
    }
    e.tokenMap.endMatches(t, ",") ? e.token(",") : e.tokenMap.endMatches(t, ";") && e.semicolon();
  }
  i(mo, "maybePrintTrailingCommaOrSemicolon");
  function Ase(e) {
    this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e), mo(this, e);
  }
  i(Ase, "TSConstructSignatureDeclaration");
  function Cse(e) {
    let {
      readonly: t
    } = e;
    t && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e), this.print(e.typeAnnotation), mo(this, e);
  }
  i(Cse, "TSPropertySignature");
  function wse(e) {
    e.computed && this.tokenChar(91), this.print(e.key), e.computed && this.tokenChar(93), e.optional && this.tokenChar(63);
  }
  i(wse, "tsPrintPropertyOrMethodName");
  function Dse(e) {
    let {
      kind: t
    } = e;
    (t === "set" || t === "get") && (this.word(t), this.space()), this.tsPrintPropertyOrMethodName(e), this.tsPrintSignatureDeclarationBase(
    e), mo(this, e);
  }
  i(Dse, "TSMethodSignature");
  function _se(e) {
    let {
      readonly: t,
      static: r
    } = e;
    r && (this.word("static"), this.space()), t && (this.word("readonly"), this.space()), this.tokenChar(91), this._parameters(e.parameters,
    "]"), this.print(e.typeAnnotation), mo(this, e);
  }
  i(_se, "TSIndexSignature");
  function Ise() {
    this.word("any");
  }
  i(Ise, "TSAnyKeyword");
  function Ose() {
    this.word("bigint");
  }
  i(Ose, "TSBigIntKeyword");
  function Nse() {
    this.word("unknown");
  }
  i(Nse, "TSUnknownKeyword");
  function Bse() {
    this.word("number");
  }
  i(Bse, "TSNumberKeyword");
  function kse() {
    this.word("object");
  }
  i(kse, "TSObjectKeyword");
  function Fse() {
    this.word("boolean");
  }
  i(Fse, "TSBooleanKeyword");
  function Lse() {
    this.word("string");
  }
  i(Lse, "TSStringKeyword");
  function jse() {
    this.word("symbol");
  }
  i(jse, "TSSymbolKeyword");
  function Mse() {
    this.word("void");
  }
  i(Mse, "TSVoidKeyword");
  function Rse() {
    this.word("undefined");
  }
  i(Rse, "TSUndefinedKeyword");
  function qse() {
    this.word("null");
  }
  i(qse, "TSNullKeyword");
  function Use() {
    this.word("never");
  }
  i(Use, "TSNeverKeyword");
  function $se() {
    this.word("intrinsic");
  }
  i($se, "TSIntrinsicKeyword");
  function Vse() {
    this.word("this");
  }
  i(Vse, "TSThisType");
  function Kse(e) {
    this.tsPrintFunctionOrConstructorType(e);
  }
  i(Kse, "TSFunctionType");
  function Wse(e) {
    e.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
  }
  i(Wse, "TSConstructorType");
  function Yse(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t), this.tokenChar(40), this._parameters(r, ")"), this.space();
    let s = e.typeAnnotation;
    this.print(s);
  }
  i(Yse, "tsPrintFunctionOrConstructorType");
  function Hse(e) {
    let t = e.typeParameters;
    this.print(e.typeName, !!t), this.print(t);
  }
  i(Hse, "TSTypeReference");
  function Jse(e) {
    e.asserts && (this.word("asserts"), this.space()), this.print(e.parameterName), e.typeAnnotation && (this.space(), this.word("is"), this.
    space(), this.print(e.typeAnnotation.typeAnnotation));
  }
  i(Jse, "TSTypePredicate");
  function Gse(e) {
    this.word("typeof"), this.space(), this.print(e.exprName);
    let t = e.typeParameters;
    t && this.print(t);
  }
  i(Gse, "TSTypeQuery");
  function Xse(e) {
    Fu(this, e, () => this.printJoin(e.members, !0, !0));
  }
  i(Xse, "TSTypeLiteral");
  function zse(e) {
    this.print(e.elementType, !0), this.tokenChar(91), this.tokenChar(93);
  }
  i(zse, "TSArrayType");
  function Qse(e) {
    this.tokenChar(91), this.printList(e.elementTypes, this.shouldPrintTrailingComma("]")), this.tokenChar(93);
  }
  i(Qse, "TSTupleType");
  function Zse(e) {
    this.print(e.typeAnnotation), this.tokenChar(63);
  }
  i(Zse, "TSOptionalType");
  function ene(e) {
    this.token("..."), this.print(e.typeAnnotation);
  }
  i(ene, "TSRestType");
  function tne(e) {
    this.print(e.label), e.optional && this.tokenChar(63), this.tokenChar(58), this.space(), this.print(e.elementType);
  }
  i(tne, "TSNamedTupleMember");
  function rne(e) {
    xv(this, e, "|");
  }
  i(rne, "TSUnionType");
  function sne(e) {
    xv(this, e, "&");
  }
  i(sne, "TSIntersectionType");
  function xv(e, t, r) {
    var s;
    let n = 0;
    (s = e.tokenMap) != null && s.startMatches(t, r) && (n = 1, e.token(r)), e.printJoin(t.types, void 0, void 0, function(a) {
      this.space(), this.token(r, void 0, a + n), this.space();
    });
  }
  i(xv, "tsPrintUnionOrIntersectionType");
  function nne(e) {
    this.print(e.checkType), this.space(), this.word("extends"), this.space(), this.print(e.extendsType), this.space(), this.tokenChar(63), this.
    space(), this.print(e.trueType), this.space(), this.tokenChar(58), this.space(), this.print(e.falseType);
  }
  i(nne, "TSConditionalType");
  function ine(e) {
    this.word("infer"), this.print(e.typeParameter);
  }
  i(ine, "TSInferType");
  function ane(e) {
    this.tokenChar(40), this.print(e.typeAnnotation), this.tokenChar(41);
  }
  i(ane, "TSParenthesizedType");
  function one(e) {
    this.word(e.operator), this.space(), this.print(e.typeAnnotation);
  }
  i(one, "TSTypeOperator");
  function lne(e) {
    this.print(e.objectType, !0), this.tokenChar(91), this.print(e.indexType), this.tokenChar(93);
  }
  i(lne, "TSIndexedAccessType");
  function une(e) {
    let {
      nameType: t,
      optional: r,
      readonly: s,
      typeAnnotation: n
    } = e;
    this.tokenChar(123);
    let a = this.enterDelimited();
    this.space(), s && (gv(this, s), this.word("readonly"), this.space()), this.tokenChar(91), this.word(e.typeParameter.name), this.space(),
    this.word("in"), this.space(), this.print(e.typeParameter.constraint), t && (this.space(), this.word("as"), this.space(), this.print(t)),
    this.tokenChar(93), r && (gv(this, r), this.tokenChar(63)), n && (this.tokenChar(58), this.space(), this.print(n)), this.space(), a(), this.
    tokenChar(125);
  }
  i(une, "TSMappedType");
  function gv(e, t) {
    t !== !0 && e.token(t);
  }
  i(gv, "tokenIfPlusMinus");
  function cne(e) {
    this._printTemplate(e, e.types);
  }
  i(cne, "TSTemplateLiteralType");
  function pne(e) {
    this.print(e.literal);
  }
  i(pne, "TSLiteralType");
  function fne(e) {
    this.print(e.expression), this.print(e.typeArguments);
  }
  i(fne, "TSClassImplements");
  function dne(e) {
    let {
      declare: t,
      id: r,
      typeParameters: s,
      extends: n,
      body: a
    } = e;
    t && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r), this.print(s), n != null && n.length && (this.
    space(), this.word("extends"), this.space(), this.printList(n)), this.space(), this.print(a);
  }
  i(dne, "TSInterfaceDeclaration");
  function hne(e) {
    Fu(this, e, () => this.printJoin(e.body, !0, !0));
  }
  i(hne, "TSInterfaceBody");
  function mne(e) {
    let {
      declare: t,
      id: r,
      typeParameters: s,
      typeAnnotation: n
    } = e;
    t && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r), this.print(s), this.space(), this.tokenChar(61),
    this.space(), this.print(n), this.semicolon();
  }
  i(mne, "TSTypeAliasDeclaration");
  function yne(e) {
    let {
      type: t,
      expression: r,
      typeAnnotation: s
    } = e;
    this.print(r, !0), this.space(), this.word(t === "TSAsExpression" ? "as" : "satisfies"), this.space(), this.print(s);
  }
  i(yne, "TSTypeExpression");
  function bne(e) {
    let {
      typeAnnotation: t,
      expression: r
    } = e;
    this.tokenChar(60), this.print(t), this.tokenChar(62), this.space(), this.print(r);
  }
  i(bne, "TSTypeAssertion");
  function gne(e) {
    this.print(e.expression), this.print(e.typeParameters);
  }
  i(gne, "TSInstantiationExpression");
  function Tne(e) {
    let {
      declare: t,
      const: r,
      id: s
    } = e;
    t && (this.word("declare"), this.space()), r && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(s), this.
    space(), Ev.call(this, e);
  }
  i(Tne, "TSEnumDeclaration");
  function Ev(e) {
    Fu(this, e, () => {
      var t;
      return this.printList(e.members, (t = this.shouldPrintTrailingComma("}")) != null ? t : !0, !0, !0);
    });
  }
  i(Ev, "TSEnumBody");
  function xne(e) {
    let {
      id: t,
      initializer: r
    } = e;
    this.print(t), r && (this.space(), this.tokenChar(61), this.space(), this.print(r));
  }
  i(xne, "TSEnumMember");
  function Ene(e) {
    let {
      declare: t,
      id: r,
      kind: s
    } = e;
    t && (this.word("declare"), this.space());
    {
      if (e.global || (this.word(s ?? (r.type === "Identifier" ? "namespace" : "module")), this.space()), this.print(r), !e.body) {
        this.semicolon();
        return;
      }
      let n = e.body;
      for (; n.type === "TSModuleDeclaration"; )
        this.tokenChar(46), this.print(n.id), n = n.body;
      this.space(), this.print(n);
    }
  }
  i(Ene, "TSModuleDeclaration");
  function Sne(e) {
    Fu(this, e, () => this.printSequence(e.body, !0));
  }
  i(Sne, "TSModuleBlock");
  function vne(e) {
    let {
      argument: t,
      qualifier: r,
      options: s
    } = e;
    this.word("import"), this.tokenChar(40), this.print(t), s && (this.tokenChar(44), this.print(s)), this.tokenChar(41), r && (this.tokenChar(
    46), this.print(r));
    let n = e.typeParameters;
    n && this.print(n);
  }
  i(vne, "TSImportType");
  function Pne(e) {
    let {
      id: t,
      moduleReference: r
    } = e;
    e.isExport && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(t), this.space(), this.tokenChar(61), this.
    space(), this.print(r), this.semicolon();
  }
  i(Pne, "TSImportEqualsDeclaration");
  function Ane(e) {
    this.token("require("), this.print(e.expression), this.tokenChar(41);
  }
  i(Ane, "TSExternalModuleReference");
  function Cne(e) {
    this.print(e.expression), this.tokenChar(33);
  }
  i(Cne, "TSNonNullExpression");
  function wne(e) {
    this.word("export"), this.space(), this.tokenChar(61), this.space(), this.print(e.expression), this.semicolon();
  }
  i(wne, "TSExportAssignment");
  function Dne(e) {
    this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e.id), this.semicolon();
  }
  i(Dne, "TSNamespaceExportDeclaration");
  function _ne(e) {
    let {
      typeParameters: t
    } = e, r = e.parameters;
    this.print(t), this.tokenChar(40), this._parameters(r, ")");
    let s = e.typeAnnotation;
    this.print(s);
  }
  i(_ne, "tsPrintSignatureDeclarationBase");
  function Ine(e) {
    let t = e.type === "ClassPrivateProperty", r = e.type === "ClassAccessorProperty" || e.type === "ClassProperty";
    Tv(this, e, [r && e.declare && "declare", !t && e.accessibility]), e.static && (this.word("static"), this.space()), Tv(this, e, [!t && e.
    abstract && "abstract", !t && e.override && "override", (r || t) && e.readonly && "readonly"]);
  }
  i(Ine, "tsPrintClassMemberModifiers");
  function Fu(e, t, r) {
    e.token("{");
    let s = e.enterDelimited();
    r(), s(), e.rightBrace(t);
  }
  i(Fu, "printBraced");
  function Tv(e, t, r) {
    var s;
    let n = /* @__PURE__ */ new Set();
    for (let a of r)
      a && n.add(a);
    (s = e.tokenMap) == null || s.find(t, (a) => n.has(a.value) ? (e.token(a.value), e.space(), n.delete(a.value), n.size === 0) : !1);
    for (let a of n)
      e.word(a), e.space();
  }
  i(Tv, "printModifiersList");
});

// ../node_modules/@babel/generator/lib/generators/index.js
var vv = D((we) => {
  "use strict";
  Object.defineProperty(we, "__esModule", {
    value: !0
  });
  var t1 = GS();
  Object.keys(t1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in we && we[e] === t1[e] || Object.defineProperty(we, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return t1[e];
      }, "get")
    });
  });
  var r1 = zS();
  Object.keys(r1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in we && we[e] === r1[e] || Object.defineProperty(we, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return r1[e];
      }, "get")
    });
  });
  var s1 = tv();
  Object.keys(s1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in we && we[e] === s1[e] || Object.defineProperty(we, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return s1[e];
      }, "get")
    });
  });
  var n1 = rv();
  Object.keys(n1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in we && we[e] === n1[e] || Object.defineProperty(we, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return n1[e];
      }, "get")
    });
  });
  var i1 = sv();
  Object.keys(i1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in we && we[e] === i1[e] || Object.defineProperty(we, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return i1[e];
      }, "get")
    });
  });
  var a1 = Xh();
  Object.keys(a1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in we && we[e] === a1[e] || Object.defineProperty(we, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return a1[e];
      }, "get")
    });
  });
  var o1 = Zh();
  Object.keys(o1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in we && we[e] === o1[e] || Object.defineProperty(we, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return o1[e];
      }, "get")
    });
  });
  var l1 = mv();
  Object.keys(l1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in we && we[e] === l1[e] || Object.defineProperty(we, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return l1[e];
      }, "get")
    });
  });
  var u1 = yv();
  Object.keys(u1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in we && we[e] === u1[e] || Object.defineProperty(we, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return u1[e];
      }, "get")
    });
  });
  var c1 = bv();
  Object.keys(c1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in we && we[e] === c1[e] || Object.defineProperty(we, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return c1[e];
      }, "get")
    });
  });
  var p1 = Sv();
  Object.keys(p1).forEach(function(e) {
    e === "default" || e === "__esModule" || e in we && we[e] === p1[e] || Object.defineProperty(we, e, {
      enumerable: !0,
      get: /* @__PURE__ */ i(function() {
        return p1[e];
      }, "get")
    });
  });
});

// ../node_modules/@babel/generator/lib/generators/deprecated.js
var Pv = D((f1) => {
  "use strict";
  Object.defineProperty(f1, "__esModule", {
    value: !0
  });
  f1.addDeprecatedGenerators = One;
  function One(e) {
    {
      let t = {
        Noop() {
        },
        TSExpressionWithTypeArguments(r) {
          this.print(r.expression), this.print(r.typeParameters);
        },
        DecimalLiteral(r) {
          let s = this.getPossibleRaw(r);
          if (!this.format.minified && s !== void 0) {
            this.word(s);
            return;
          }
          this.word(r.value + "m");
        }
      };
      Object.assign(e.prototype, t);
    }
  }
  i(One, "addDeprecatedGenerators");
});

// ../node_modules/@babel/generator/lib/printer.js
var Dv = D((Lu) => {
  "use strict";
  Object.defineProperty(Lu, "__esModule", {
    value: !0
  });
  Lu.default = void 0;
  var Nne = OS(), Bt = Vn(), Cv = Bt, Bne = ce(), kne = JS(), Fne = vv(), Lne = Pv(), {
    isExpression: jne,
    isFunction: Mne,
    isStatement: Rne,
    isClassBody: qne,
    isTSInterfaceBody: Une,
    isTSEnumMember: $ne
  } = Bne, Vne = /e/i, Kne = /\.0+$/, wv = /[\n\r\u2028\u2029]/, Wne = /[\n\r\u2028\u2029]|\*\//;
  function Av(e) {
    return e.type === "CommentLine" || wv.test(e.value);
  }
  i(Av, "commentIsNewline");
  var {
    needsParens: Yne
  } = Cv, yo = class {
    static {
      i(this, "Printer");
    }
    constructor(t, r, s = null, n = null) {
      this.tokenContext = Bt.TokenContext.normal, this._tokens = null, this._originalCode = null, this._currentNode = null, this._indent = 0,
      this._indentRepeat = 0, this._insideAux = !1, this._noLineTerminator = !1, this._noLineTerminatorAfterNode = null, this._printAuxAfterOnNextUserNode =
      !1, this._printedComments = /* @__PURE__ */ new Set(), this._endsWithInteger = !1, this._endsWithWord = !1, this._endsWithDiv = !1, this.
      _lastCommentLine = 0, this._endsWithInnerRaw = !1, this._indentInnerComments = !0, this.tokenMap = null, this._boundGetRawIdentifier =
      this._getRawIdentifier.bind(this), this._printSemicolonBeforeNextNode = -1, this._printSemicolonBeforeNextToken = -1, this.format = t,
      this._tokens = s, this._originalCode = n, this._indentRepeat = t.indent.style.length, this._inputMap = r?._inputMap || null, this._buf =
      new Nne.default(r, t.indent.style[0]);
    }
    enterForStatementInit() {
      return this.tokenContext |= Bt.TokenContext.forInitHead | Bt.TokenContext.forInOrInitHeadAccumulate, () => this.tokenContext = Bt.TokenContext.
      normal;
    }
    enterForXStatementInit(t) {
      return t ? (this.tokenContext |= Bt.TokenContext.forOfHead, null) : (this.tokenContext |= Bt.TokenContext.forInHead | Bt.TokenContext.
      forInOrInitHeadAccumulate, () => this.tokenContext = Bt.TokenContext.normal);
    }
    enterDelimited() {
      let t = this.tokenContext, r = this._noLineTerminatorAfterNode;
      return !(t & Bt.TokenContext.forInOrInitHeadAccumulate) && r === null ? () => {
      } : (this._noLineTerminatorAfterNode = null, this.tokenContext = Bt.TokenContext.normal, () => {
        this._noLineTerminatorAfterNode = r, this.tokenContext = t;
      });
    }
    generate(t) {
      return this.format.preserveFormat && (this.tokenMap = new kne.TokenMap(t, this._tokens, this._originalCode)), this.print(t), this._maybeAddAuxComment(),
      this._buf.get();
    }
    indent() {
      let {
        format: t
      } = this;
      t.preserveFormat || t.compact || t.concise || this._indent++;
    }
    dedent() {
      let {
        format: t
      } = this;
      t.preserveFormat || t.compact || t.concise || this._indent--;
    }
    semicolon(t = !1) {
      if (this._maybeAddAuxComment(), t) {
        this._appendChar(59), this._noLineTerminator = !1;
        return;
      }
      if (this.tokenMap) {
        let r = this._currentNode;
        if (r.start != null && r.end != null) {
          if (!this.tokenMap.endMatches(r, ";")) {
            this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
            return;
          }
          let s = this.tokenMap.getIndexes(this._currentNode);
          this._catchUpTo(this._tokens[s[s.length - 1]].loc.start);
        }
      }
      this._queue(59), this._noLineTerminator = !1;
    }
    rightBrace(t) {
      this.format.minified && this._buf.removeLastSemicolon(), this.sourceWithOffset("end", t.loc, -1), this.tokenChar(125);
    }
    rightParens(t) {
      this.sourceWithOffset("end", t.loc, -1), this.tokenChar(41);
    }
    space(t = !1) {
      let {
        format: r
      } = this;
      if (!(r.compact || r.preserveFormat)) {
        if (t)
          this._space();
        else if (this._buf.hasContent()) {
          let s = this.getLastChar();
          s !== 32 && s !== 10 && this._space();
        }
      }
    }
    word(t, r = !1) {
      this.tokenContext &= Bt.TokenContext.forInOrInitHeadAccumulatePassThroughMask, this._maybePrintInnerComments(t), this._maybeAddAuxComment(),
      this.tokenMap && this._catchUpToCurrentToken(t), (this._endsWithWord || this._endsWithDiv && t.charCodeAt(0) === 47) && this._space(),
      this._append(t, !1), this._endsWithWord = !0, this._noLineTerminator = r;
    }
    number(t, r) {
      function s(n) {
        if (n.length > 2 && n.charCodeAt(0) === 48) {
          let a = n.charCodeAt(1);
          return a === 98 || a === 111 || a === 120;
        }
        return !1;
      }
      i(s, "isNonDecimalLiteral"), this.word(t), this._endsWithInteger = Number.isInteger(r) && !s(t) && !Vne.test(t) && !Kne.test(t) && t.charCodeAt(
      t.length - 1) !== 46;
    }
    token(t, r = !1, s = 0) {
      this.tokenContext &= Bt.TokenContext.forInOrInitHeadAccumulatePassThroughMask, this._maybePrintInnerComments(t, s), this._maybeAddAuxComment(),
      this.tokenMap && this._catchUpToCurrentToken(t, s);
      let n = this.getLastChar(), a = t.charCodeAt(0);
      (n === 33 && (t === "--" || a === 61) || a === 43 && n === 43 || a === 45 && n === 45 || a === 46 && this._endsWithInteger) && this._space(),
      this._append(t, r), this._noLineTerminator = !1;
    }
    tokenChar(t) {
      this.tokenContext &= Bt.TokenContext.forInOrInitHeadAccumulatePassThroughMask;
      let r = String.fromCharCode(t);
      this._maybePrintInnerComments(r), this._maybeAddAuxComment(), this.tokenMap && this._catchUpToCurrentToken(r);
      let s = this.getLastChar();
      (t === 43 && s === 43 || t === 45 && s === 45 || t === 46 && this._endsWithInteger) && this._space(), this._appendChar(t), this._noLineTerminator =
      !1;
    }
    newline(t = 1, r) {
      if (!(t <= 0)) {
        if (!r) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        t > 2 && (t = 2), t -= this._buf.getNewlineCount();
        for (let s = 0; s < t; s++)
          this._newline();
      }
    }
    endsWith(t) {
      return this.getLastChar() === t;
    }
    getLastChar() {
      return this._buf.getLastChar();
    }
    endsWithCharAndNewline() {
      return this._buf.endsWithCharAndNewline();
    }
    removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
    exactSource(t, r) {
      if (!t) {
        r();
        return;
      }
      this._catchUp("start", t), this._buf.exactSource(t, r);
    }
    source(t, r) {
      r && (this._catchUp(t, r), this._buf.source(t, r));
    }
    sourceWithOffset(t, r, s) {
      !r || this.format.preserveFormat || (this._catchUp(t, r), this._buf.sourceWithOffset(t, r, s));
    }
    sourceIdentifierName(t, r) {
      if (!this._buf._canMarkIdName) return;
      let s = this._buf._sourcePosition;
      s.identifierNamePos = r, s.identifierName = t;
    }
    _space() {
      this._queue(32);
    }
    _newline() {
      this._queue(10);
    }
    _catchUpToCurrentToken(t, r = 0) {
      let s = this.tokenMap.findMatching(this._currentNode, t, r);
      s && this._catchUpTo(s.loc.start), this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine() &&
      (this._buf.appendChar(59), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1), this._printSemicolonBeforeNextToken =
      -1, this._printSemicolonBeforeNextNode = -1;
    }
    _append(t, r) {
      this._maybeIndent(t.charCodeAt(0)), this._buf.append(t, r), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _appendChar(t) {
      this._maybeIndent(t), this._buf.appendChar(t), this._endsWithWord = !1, this._endsWithInteger = !1, this._endsWithDiv = !1;
    }
    _queue(t) {
      this._maybeIndent(t), this._buf.queue(t), this._endsWithWord = !1, this._endsWithInteger = !1;
    }
    _maybeIndent(t) {
      this._indent && t !== 10 && this.endsWith(10) && this._buf.queueIndentation(this._getIndent());
    }
    _shouldIndent(t) {
      if (this._indent && t !== 10 && this.endsWith(10))
        return !0;
    }
    catchUp(t) {
      if (!this.format.retainLines) return;
      let r = t - this._buf.getCurrentLine();
      for (let s = 0; s < r; s++)
        this._newline();
    }
    _catchUp(t, r) {
      let {
        format: s
      } = this;
      if (!s.preserveFormat) {
        s.retainLines && r != null && r[t] && this.catchUp(r[t].line);
        return;
      }
      let n = r?.[t];
      n != null && this._catchUpTo(n);
    }
    _catchUpTo({
      line: t,
      column: r,
      index: s
    }) {
      let n = t - this._buf.getCurrentLine();
      if (n > 0 && this._noLineTerminator)
        return;
      for (let o = 0; o < n; o++)
        this._newline();
      let a = n > 0 ? r : r - this._buf.getCurrentColumn();
      if (a > 0) {
        let o = this._originalCode ? this._originalCode.slice(s - a, s).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu,
        " ") : " ".repeat(a);
        this._append(o, !1);
      }
    }
    _getIndent() {
      return this._indentRepeat * this._indent;
    }
    printTerminatorless(t) {
      this._noLineTerminator = !0, this.print(t);
    }
    print(t, r = !1, s) {
      var n, a, o;
      if (!t) return;
      this._endsWithInnerRaw = !1;
      let l = t.type, u = this.format, c = u.concise;
      t._compact && (u.concise = !0);
      let p = this[l];
      if (p === void 0)
        throw new ReferenceError(`unknown node of type ${JSON.stringify(l)} with constructor ${JSON.stringify(t.constructor.name)}`);
      let f = this._currentNode;
      this._currentNode = t, this.tokenMap && (this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode);
      let h = this._insideAux;
      this._insideAux = t.loc == null, this._maybeAddAuxComment(this._insideAux && !h);
      let b = (n = t.extra) == null ? void 0 : n.parenthesized, T = b && u.preserveFormat || b && u.retainFunctionParens && l === "FunctionE\
xpression" || Yne(t, f, this.tokenContext, u.preserveFormat ? this._boundGetRawIdentifier : void 0);
      if (!T && b && (a = t.leadingComments) != null && a.length && t.leadingComments[0].type === "CommentBlock")
        switch (f?.type) {
          case "ExpressionStatement":
          case "VariableDeclarator":
          case "AssignmentExpression":
          case "ReturnStatement":
            break;
          case "CallExpression":
          case "OptionalCallExpression":
          case "NewExpression":
            if (f.callee !== t) break;
          default:
            T = !0;
        }
      let d = !1;
      !T && this._noLineTerminator && ((o = t.leadingComments) != null && o.some(Av) || this.format.retainLines && t.loc && t.loc.start.line >
      this._buf.getCurrentLine()) && (T = !0, d = !0);
      let g, E;
      if (!T && (r || (r = !!f && this._noLineTerminatorAfterNode === f && Cv.isLastChild(f, t)), r)) {
        var _;
        (_ = t.trailingComments) != null && _.some(Av) ? jne(t) && (T = !0) : (g = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode =
        t);
      }
      T && (this.tokenChar(40), d && this.indent(), this._endsWithInnerRaw = !1, this.tokenContext & Bt.TokenContext.forInOrInitHeadAccumulate &&
      (E = this.tokenContext, this.tokenContext = Bt.TokenContext.normal), g = this._noLineTerminatorAfterNode, this._noLineTerminatorAfterNode =
      null), this._lastCommentLine = 0, this._printLeadingComments(t, f);
      let N = l === "Program" || l === "File" ? null : t.loc;
      this.exactSource(N, p.bind(this, t, f)), T ? (this._printTrailingComments(t, f), d && (this.dedent(), this.newline()), this.tokenChar(
      41), this._noLineTerminator = r, E && (this.tokenContext = E)) : r && !this._noLineTerminator ? (this._noLineTerminator = !0, this._printTrailingComments(
      t, f)) : this._printTrailingComments(t, f, s), this._currentNode = f, u.concise = c, this._insideAux = h, g !== void 0 && (this._noLineTerminatorAfterNode =
      g), this._endsWithInnerRaw = !1;
    }
    _maybeAddAuxComment(t) {
      t && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
    }
    _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !0;
      let t = this.format.auxiliaryCommentBefore;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = !1;
      let t = this.format.auxiliaryCommentAfter;
      t && this._printComment({
        type: "CommentBlock",
        value: t
      }, 0);
    }
    getPossibleRaw(t) {
      let r = t.extra;
      if (r?.raw != null && r.rawValue != null && t.value === r.rawValue)
        return r.raw;
    }
    printJoin(t, r, s, n, a, o, l) {
      if (!(t != null && t.length)) return;
      if (s == null && this.format.retainLines) {
        var u;
        let T = (u = t[0].loc) == null ? void 0 : u.start.line;
        T != null && T !== this._buf.getCurrentLine() && (s = !0);
      }
      s && this.indent();
      let c = {
        nextNodeStartLine: 0
      }, p = n?.bind(this), f = t.length;
      for (let T = 0; T < f; T++) {
        let d = t[T];
        if (d && (r && this._printNewline(T === 0, c), this.print(d, void 0, l || 0), o?.(d, T), p != null && (T < f - 1 ? p(T, !1) : a && p(
        T, !0)), r)) {
          var h;
          if ((h = d.trailingComments) != null && h.length || (this._lastCommentLine = 0), T + 1 === f)
            this.newline(1);
          else {
            var b;
            let g = t[T + 1];
            c.nextNodeStartLine = ((b = g.loc) == null ? void 0 : b.start.line) || 0, this._printNewline(!0, c);
          }
        }
      }
      s && this.dedent();
    }
    printAndIndentOnComments(t) {
      let r = t.leadingComments && t.leadingComments.length > 0;
      r && this.indent(), this.print(t), r && this.dedent();
    }
    printBlock(t) {
      let r = t.body;
      r.type !== "EmptyStatement" && this.space(), this.print(r);
    }
    _printTrailingComments(t, r, s) {
      let {
        innerComments: n,
        trailingComments: a
      } = t;
      n != null && n.length && this._printComments(2, n, t, r, s), a != null && a.length && this._printComments(2, a, t, r, s);
    }
    _printLeadingComments(t, r) {
      let s = t.leadingComments;
      s != null && s.length && this._printComments(0, s, t, r);
    }
    _maybePrintInnerComments(t, r) {
      if (this._endsWithInnerRaw) {
        var s;
        this.printInnerComments((s = this.tokenMap) == null ? void 0 : s.findMatching(this._currentNode, t, r));
      }
      this._endsWithInnerRaw = !0, this._indentInnerComments = !0;
    }
    printInnerComments(t) {
      let r = this._currentNode, s = r.innerComments;
      if (!(s != null && s.length)) return;
      let n = this.endsWith(32), a = this._indentInnerComments, o = this._printedComments.size;
      a && this.indent(), this._printComments(1, s, r, void 0, void 0, t), n && o !== this._printedComments.size && this.space(), a && this.
      dedent();
    }
    noIndentInnerCommentsHere() {
      this._indentInnerComments = !1;
    }
    printSequence(t, r, s) {
      this.printJoin(t, !0, r ?? !1, void 0, void 0, void 0, s);
    }
    printList(t, r, s, n, a, o) {
      this.printJoin(t, s, n, a ?? Hne, r, o);
    }
    shouldPrintTrailingComma(t) {
      if (!this.tokenMap) return null;
      let r = this.tokenMap.findLastIndex(this._currentNode, (s) => this.tokenMap.matchesOriginal(s, t));
      return r <= 0 ? null : this.tokenMap.matchesOriginal(this._tokens[r - 1], ",");
    }
    _printNewline(t, r) {
      let s = this.format;
      if (s.retainLines || s.compact) return;
      if (s.concise) {
        this.space();
        return;
      }
      if (!t)
        return;
      let n = r.nextNodeStartLine, a = this._lastCommentLine;
      if (n > 0 && a > 0) {
        let o = n - a;
        if (o >= 0) {
          this.newline(o || 1);
          return;
        }
      }
      this._buf.hasContent() && this.newline(1);
    }
    _shouldPrintComment(t, r) {
      if (t.ignore || this._printedComments.has(t)) return 0;
      if (this._noLineTerminator && Wne.test(t.value))
        return 2;
      if (r && this.tokenMap) {
        let s = this.tokenMap.find(this._currentNode, (n) => n.value === t.value);
        if (s && s.start > r.start)
          return 2;
      }
      return this._printedComments.add(t), this.format.shouldPrintComment(t.value) ? 1 : 0;
    }
    _printComment(t, r) {
      let s = this._noLineTerminator, n = t.type === "CommentBlock", a = n && r !== 1 && !this._noLineTerminator;
      a && this._buf.hasContent() && r !== 2 && this.newline(1);
      let o = this.getLastChar();
      o !== 91 && o !== 123 && o !== 40 && this.space();
      let l;
      if (n) {
        if (l = `/*${t.value}*/`, this.format.indent.adjustMultilineComment) {
          var u;
          let c = (u = t.loc) == null ? void 0 : u.start.column;
          if (c) {
            let p = new RegExp("\\n\\s{1," + c + "}", "g");
            l = l.replace(p, `
`);
          }
          if (this.format.concise)
            l = l.replace(/\n(?!$)/g, `
`);
          else {
            let p = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
            (this._shouldIndent(47) || this.format.retainLines) && (p += this._getIndent()), l = l.replace(/\n(?!$)/g, `
${" ".repeat(p)}`);
          }
        }
      } else s ? l = `/*${t.value}*/` : l = `//${t.value}`;
      if (this._endsWithDiv && this._space(), this.tokenMap) {
        let {
          _printSemicolonBeforeNextToken: c,
          _printSemicolonBeforeNextNode: p
        } = this;
        this._printSemicolonBeforeNextToken = -1, this._printSemicolonBeforeNextNode = -1, this.source("start", t.loc), this._append(l, n), this.
        _printSemicolonBeforeNextNode = p, this._printSemicolonBeforeNextToken = c;
      } else
        this.source("start", t.loc), this._append(l, n);
      !n && !s && this.newline(1, !0), a && r !== 3 && this.newline(1);
    }
    _printComments(t, r, s, n, a = 0, o) {
      let l = s.loc, u = r.length, c = !!l, p = c ? l.start.line : 0, f = c ? l.end.line : 0, h = 0, b = 0, T = this._noLineTerminator ? function() {
      } : this.newline.bind(this);
      for (let d = 0; d < u; d++) {
        let g = r[d], E = this._shouldPrintComment(g, o);
        if (E === 2) {
          c = !1;
          break;
        }
        if (c && g.loc && E === 1) {
          let _ = g.loc.start.line, N = g.loc.end.line;
          if (t === 0) {
            let k = 0;
            d === 0 ? this._buf.hasContent() && (g.type === "CommentLine" || _ !== N) && (k = b = 1) : k = _ - h, h = N, T(k), this._printComment(
            g, 1), d + 1 === u && (T(Math.max(p - h, b)), h = p);
          } else if (t === 1) {
            let k = _ - (d === 0 ? p : h);
            h = N, T(k), this._printComment(g, 1), d + 1 === u && (T(Math.min(1, f - h)), h = f);
          } else {
            let k = _ - (d === 0 ? f - a : h);
            h = N, T(k), this._printComment(g, 1);
          }
        } else {
          if (c = !1, E !== 1)
            continue;
          if (u === 1) {
            let _ = g.loc ? g.loc.start.line === g.loc.end.line : !wv.test(g.value), N = _ && !Rne(s) && !qne(n) && !Une(n) && !$ne(s);
            t === 0 ? this._printComment(g, N && s.type !== "ObjectExpression" || _ && Mne(n, {
              body: s
            }) ? 1 : 0) : N && t === 2 ? this._printComment(g, 1) : this._printComment(g, 0);
          } else t === 1 && !(s.type === "ObjectExpression" && s.properties.length > 1) && s.type !== "ClassBody" && s.type !== "TSInterface\
Body" ? this._printComment(g, d === 0 ? 2 : d === u - 1 ? 3 : 0) : this._printComment(g, 0);
        }
      }
      t === 2 && c && h && (this._lastCommentLine = h);
    }
  };
  Object.assign(yo.prototype, Fne);
  (0, Lne.addDeprecatedGenerators)(yo);
  var jDe = Lu.default = yo;
  function Hne(e, t) {
    this.token(",", !1, e), t || this.space();
  }
  i(Hne, "commaSeparator");
});

// ../node_modules/@babel/generator/lib/index.js
var bo = D((ji) => {
  "use strict";
  Object.defineProperty(ji, "__esModule", {
    value: !0
  });
  ji.default = void 0;
  ji.generate = Nv;
  var _v = IS(), Iv = Dv();
  function Ov(e, t, r) {
    if (t.experimental_preserveFormat) {
      if (typeof e != "string")
        throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
      if (!t.retainLines)
        throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
      if (t.compact && t.compact !== "auto")
        throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
      if (t.minified)
        throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
      if (t.jsescOption)
        throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
      if (!Array.isArray(r.tokens))
        throw new Error("`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable th\
e `tokens: true` parser option.");
    }
    let s = {
      auxiliaryCommentBefore: t.auxiliaryCommentBefore,
      auxiliaryCommentAfter: t.auxiliaryCommentAfter,
      shouldPrintComment: t.shouldPrintComment,
      preserveFormat: t.experimental_preserveFormat,
      retainLines: t.retainLines,
      retainFunctionParens: t.retainFunctionParens,
      comments: t.comments == null || t.comments,
      compact: t.compact,
      minified: t.minified,
      concise: t.concise,
      indent: {
        adjustMultilineComment: !0,
        style: "  "
      },
      jsescOption: Object.assign({
        quotes: "double",
        wrap: !0,
        minimal: !1
      }, t.jsescOption),
      topicToken: t.topicToken,
      importAttributesKeyword: t.importAttributesKeyword
    };
    {
      var n;
      s.decoratorsBeforeExport = t.decoratorsBeforeExport, s.jsescOption.json = t.jsonCompatibleStrings, s.recordAndTupleSyntaxType = (n = t.
      recordAndTupleSyntaxType) != null ? n : "hash";
    }
    s.minified ? (s.compact = !0, s.shouldPrintComment = s.shouldPrintComment || (() => s.comments)) : s.shouldPrintComment = s.shouldPrintComment ||
    ((u) => s.comments || u.includes("@license") || u.includes("@preserve")), s.compact === "auto" && (s.compact = typeof e == "string" && e.
    length > 5e5, s.compact && console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${t.filename} as it exceeds th\
e max of 500KB.`)), (s.compact || s.preserveFormat) && (s.indent.adjustMultilineComment = !1);
    let {
      auxiliaryCommentBefore: a,
      auxiliaryCommentAfter: o,
      shouldPrintComment: l
    } = s;
    return a && !l(a) && (s.auxiliaryCommentBefore = void 0), o && !l(o) && (s.auxiliaryCommentAfter = void 0), s;
  }
  i(Ov, "normalizeOptions");
  ji.CodeGenerator = class {
    static {
      i(this, "CodeGenerator");
    }
    constructor(t, r = {}, s) {
      this._ast = void 0, this._format = void 0, this._map = void 0, this._ast = t, this._format = Ov(s, r, t), this._map = r.sourceMaps ? new _v.
      default(r, s) : null;
    }
    generate() {
      return new Iv.default(this._format, this._map).generate(this._ast);
    }
  };
  function Nv(e, t = {}, r) {
    let s = Ov(r, t, e), n = t.sourceMaps ? new _v.default(t, r) : null;
    return new Iv.default(s, n, e.tokens, typeof r == "string" ? r : null).generate(e);
  }
  i(Nv, "generate");
  var UDe = ji.default = Nv;
});

// ../node_modules/@babel/traverse/lib/path/ancestry.js
var Bv = D((xr) => {
  "use strict";
  Object.defineProperty(xr, "__esModule", {
    value: !0
  });
  xr.find = zne;
  xr.findParent = Xne;
  xr.getAncestry = rie;
  xr.getDeepestCommonAncestorFrom = tie;
  xr.getEarliestCommonAncestorFrom = eie;
  xr.getFunctionParent = Qne;
  xr.getStatementParent = Zne;
  xr.inType = iie;
  xr.isAncestor = sie;
  xr.isDescendant = nie;
  var Jne = ce(), {
    VISITOR_KEYS: Gne
  } = Jne;
  function Xne(e) {
    let t = this;
    for (; t = t.parentPath; )
      if (e(t)) return t;
    return null;
  }
  i(Xne, "findParent");
  function zne(e) {
    let t = this;
    do
      if (e(t)) return t;
    while (t = t.parentPath);
    return null;
  }
  i(zne, "find");
  function Qne() {
    return this.findParent((e) => e.isFunction());
  }
  i(Qne, "getFunctionParent");
  function Zne() {
    let e = this;
    do {
      if (!e.parentPath || Array.isArray(e.container) && e.isStatement())
        break;
      e = e.parentPath;
    } while (e);
    if (e && (e.isProgram() || e.isFile()))
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    return e;
  }
  i(Zne, "getStatementParent");
  function eie(e) {
    return this.getDeepestCommonAncestorFrom(e, function(t, r, s) {
      let n, a = Gne[t.type];
      for (let o of s) {
        let l = o[r + 1];
        if (!n) {
          n = l;
          continue;
        }
        if (l.listKey && n.listKey === l.listKey && l.key < n.key) {
          n = l;
          continue;
        }
        let u = a.indexOf(n.parentKey), c = a.indexOf(l.parentKey);
        u > c && (n = l);
      }
      return n;
    });
  }
  i(eie, "getEarliestCommonAncestorFrom");
  function tie(e, t) {
    if (!e.length)
      return this;
    if (e.length === 1)
      return e[0];
    let r = 1 / 0, s, n, a = e.map((l) => {
      let u = [];
      do
        u.unshift(l);
      while ((l = l.parentPath) && l !== this);
      return u.length < r && (r = u.length), u;
    }), o = a[0];
    e: for (let l = 0; l < r; l++) {
      let u = o[l];
      for (let c of a)
        if (c[l] !== u)
          break e;
      s = l, n = u;
    }
    if (n)
      return t ? t(n, s, a) : n;
    throw new Error("Couldn't find intersection");
  }
  i(tie, "getDeepestCommonAncestorFrom");
  function rie() {
    let e = this, t = [];
    do
      t.push(e);
    while (e = e.parentPath);
    return t;
  }
  i(rie, "getAncestry");
  function sie(e) {
    return e.isDescendant(this);
  }
  i(sie, "isAncestor");
  function nie(e) {
    return !!this.findParent((t) => t === e);
  }
  i(nie, "isDescendant");
  function iie(...e) {
    let t = this;
    for (; t; ) {
      if (e.includes(t.node.type)) return !0;
      t = t.parentPath;
    }
    return !1;
  }
  i(iie, "inType");
});

// ../node_modules/@babel/traverse/lib/path/inference/util.js
var h1 = D((d1) => {
  "use strict";
  Object.defineProperty(d1, "__esModule", {
    value: !0
  });
  d1.createUnionType = cie;
  var aie = ce(), {
    createFlowUnionType: kv,
    createTSUnionType: Fv,
    createUnionTypeAnnotation: oie,
    isFlowType: lie,
    isTSType: uie
  } = aie;
  function cie(e) {
    {
      if (e.every((t) => lie(t)))
        return kv ? kv(e) : oie(e);
      if (e.every((t) => uie(t)) && Fv)
        return Fv(e);
    }
  }
  i(cie, "createUnionType");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var qv = D((m1) => {
  "use strict";
  Object.defineProperty(m1, "__esModule", {
    value: !0
  });
  m1.default = mie;
  var pie = ce(), jv = h1(), {
    BOOLEAN_NUMBER_BINARY_OPERATORS: fie,
    createTypeAnnotationBasedOnTypeof: die,
    numberTypeAnnotation: Mv,
    voidTypeAnnotation: hie
  } = pie;
  function mie(e) {
    if (!this.isReferenced()) return;
    let t = this.scope.getBinding(e.name);
    if (t)
      return t.identifier.typeAnnotation ? t.identifier.typeAnnotation : yie(t, this, e.name);
    if (e.name === "undefined")
      return hie();
    if (e.name === "NaN" || e.name === "Infinity")
      return Mv();
    e.name;
  }
  i(mie, "_default");
  function yie(e, t, r) {
    let s = [], n = [], a = Lv(e, t, n), o = Rv(e, t, r);
    if (o) {
      let l = Lv(e, o.ifStatement);
      a = a.filter((u) => !l.includes(u)), s.push(o.typeAnnotation);
    }
    if (a.length) {
      a.push(...n);
      for (let l of a)
        s.push(l.getTypeAnnotation());
    }
    if (s.length)
      return (0, jv.createUnionType)(s);
  }
  i(yie, "getTypeAnnotationBindingConstantViolations");
  function Lv(e, t, r) {
    let s = e.constantViolations.slice();
    return s.unshift(e.path), s.filter((n) => {
      n = n.resolve();
      let a = n._guessExecutionStatusRelativeTo(t);
      return r && a === "unknown" && r.push(n), a === "before";
    });
  }
  i(Lv, "getConstantViolationsBefore");
  function bie(e, t) {
    let r = t.node.operator, s = t.get("right").resolve(), n = t.get("left").resolve(), a;
    if (n.isIdentifier({
      name: e
    }) ? a = s : s.isIdentifier({
      name: e
    }) && (a = n), a)
      return r === "===" ? a.getTypeAnnotation() : fie.includes(r) ? Mv() : void 0;
    if (r !== "===" && r !== "==") return;
    let o, l;
    if (n.isUnaryExpression({
      operator: "typeof"
    }) ? (o = n, l = s) : s.isUnaryExpression({
      operator: "typeof"
    }) && (o = s, l = n), !o || !o.get("argument").isIdentifier({
      name: e
    }) || (l = l.resolve(), !l.isLiteral())) return;
    let u = l.node.value;
    if (typeof u == "string")
      return die(u);
  }
  i(bie, "inferAnnotationFromBinaryExpression");
  function gie(e, t, r) {
    let s;
    for (; s = t.parentPath; ) {
      if (s.isIfStatement() || s.isConditionalExpression())
        return t.key === "test" ? void 0 : s;
      if (s.isFunction() && (r == null || s.parentPath.scope.getBinding(r) !== e))
        return;
      t = s;
    }
  }
  i(gie, "getParentConditionalPath");
  function Rv(e, t, r) {
    let s = gie(e, t, r);
    if (!s) return;
    let a = [s.get("test")], o = [];
    for (let l = 0; l < a.length; l++) {
      let u = a[l];
      if (u.isLogicalExpression())
        u.node.operator === "&&" && (a.push(u.get("left")), a.push(u.get("right")));
      else if (u.isBinaryExpression()) {
        let c = bie(r, u);
        c && o.push(c);
      }
    }
    return o.length ? {
      typeAnnotation: (0, jv.createUnionType)(o),
      ifStatement: s
    } : Rv(e, s, r);
  }
  i(Rv, "getConditionalAnnotation");
});

// ../node_modules/@babel/traverse/lib/path/inference/inferers.js
var Jv = D((Ie) => {
  "use strict";
  Object.defineProperty(Ie, "__esModule", {
    value: !0
  });
  Ie.ArrayExpression = Wv;
  Ie.AssignmentExpression = Uie;
  Ie.BinaryExpression = Lie;
  Ie.BooleanLiteral = Wie;
  Ie.CallExpression = eae;
  Ie.ConditionalExpression = Mie;
  Ie.ClassDeclaration = Ie.ClassExpression = Ie.FunctionDeclaration = Ie.ArrowFunctionExpression = Ie.FunctionExpression = Gie;
  Object.defineProperty(Ie, "Identifier", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return xie.default;
    }, "get")
  });
  Ie.LogicalExpression = jie;
  Ie.NewExpression = Bie;
  Ie.NullLiteral = Yie;
  Ie.NumericLiteral = Kie;
  Ie.ObjectExpression = Jie;
  Ie.ParenthesizedExpression = qie;
  Ie.RegExpLiteral = Hie;
  Ie.RestElement = Yv;
  Ie.SequenceExpression = Rie;
  Ie.StringLiteral = Vie;
  Ie.TSAsExpression = Kv;
  Ie.TSNonNullExpression = Nie;
  Ie.TaggedTemplateExpression = tae;
  Ie.TemplateLiteral = kie;
  Ie.TypeCastExpression = Vv;
  Ie.UnaryExpression = Fie;
  Ie.UpdateExpression = $ie;
  Ie.VariableDeclarator = Oie;
  var Tie = ce(), xie = qv(), $v = h1(), {
    BOOLEAN_BINARY_OPERATORS: Eie,
    BOOLEAN_UNARY_OPERATORS: Sie,
    NUMBER_BINARY_OPERATORS: vie,
    NUMBER_UNARY_OPERATORS: Pie,
    STRING_UNARY_OPERATORS: Aie,
    anyTypeAnnotation: Uv,
    arrayTypeAnnotation: y1,
    booleanTypeAnnotation: b1,
    buildMatchMemberExpression: ju,
    genericTypeAnnotation: rn,
    identifier: Kn,
    nullLiteralTypeAnnotation: Cie,
    numberTypeAnnotation: Mi,
    stringTypeAnnotation: Wn,
    tupleTypeAnnotation: wie,
    unionTypeAnnotation: Die,
    voidTypeAnnotation: _ie,
    isIdentifier: Iie
  } = Tie;
  function Oie() {
    if (this.get("id").isIdentifier())
      return this.get("init").getTypeAnnotation();
  }
  i(Oie, "VariableDeclarator");
  function Vv(e) {
    return e.typeAnnotation;
  }
  i(Vv, "TypeCastExpression");
  Vv.validParent = !0;
  function Kv(e) {
    return e.typeAnnotation;
  }
  i(Kv, "TSAsExpression");
  Kv.validParent = !0;
  function Nie() {
    return this.get("expression").getTypeAnnotation();
  }
  i(Nie, "TSNonNullExpression");
  function Bie(e) {
    if (e.callee.type === "Identifier")
      return rn(e.callee);
  }
  i(Bie, "NewExpression");
  function kie() {
    return Wn();
  }
  i(kie, "TemplateLiteral");
  function Fie(e) {
    let t = e.operator;
    if (t === "void")
      return _ie();
    if (Pie.includes(t))
      return Mi();
    if (Aie.includes(t))
      return Wn();
    if (Sie.includes(t))
      return b1();
  }
  i(Fie, "UnaryExpression");
  function Lie(e) {
    let t = e.operator;
    if (vie.includes(t))
      return Mi();
    if (Eie.includes(t))
      return b1();
    if (t === "+") {
      let r = this.get("right"), s = this.get("left");
      return s.isBaseType("number") && r.isBaseType("number") ? Mi() : s.isBaseType("string") || r.isBaseType("string") ? Wn() : Die([Wn(), Mi()]);
    }
  }
  i(Lie, "BinaryExpression");
  function jie() {
    let e = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
    return (0, $v.createUnionType)(e);
  }
  i(jie, "LogicalExpression");
  function Mie() {
    let e = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
    return (0, $v.createUnionType)(e);
  }
  i(Mie, "ConditionalExpression");
  function Rie() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  i(Rie, "SequenceExpression");
  function qie() {
    return this.get("expression").getTypeAnnotation();
  }
  i(qie, "ParenthesizedExpression");
  function Uie() {
    return this.get("right").getTypeAnnotation();
  }
  i(Uie, "AssignmentExpression");
  function $ie(e) {
    let t = e.operator;
    if (t === "++" || t === "--")
      return Mi();
  }
  i($ie, "UpdateExpression");
  function Vie() {
    return Wn();
  }
  i(Vie, "StringLiteral");
  function Kie() {
    return Mi();
  }
  i(Kie, "NumericLiteral");
  function Wie() {
    return b1();
  }
  i(Wie, "BooleanLiteral");
  function Yie() {
    return Cie();
  }
  i(Yie, "NullLiteral");
  function Hie() {
    return rn(Kn("RegExp"));
  }
  i(Hie, "RegExpLiteral");
  function Jie() {
    return rn(Kn("Object"));
  }
  i(Jie, "ObjectExpression");
  function Wv() {
    return rn(Kn("Array"));
  }
  i(Wv, "ArrayExpression");
  function Yv() {
    return Wv();
  }
  i(Yv, "RestElement");
  Yv.validParent = !0;
  function Gie() {
    return rn(Kn("Function"));
  }
  i(Gie, "Func");
  var Xie = ju("Array.from"), zie = ju("Object.keys"), Qie = ju("Object.values"), Zie = ju("Object.entries");
  function eae() {
    let {
      callee: e
    } = this.node;
    return zie(e) ? y1(Wn()) : Xie(e) || Qie(e) || Iie(e, {
      name: "Array"
    }) ? y1(Uv()) : Zie(e) ? y1(wie([Wn(), Uv()])) : Hv(this.get("callee"));
  }
  i(eae, "CallExpression");
  function tae() {
    return Hv(this.get("tag"));
  }
  i(tae, "TaggedTemplateExpression");
  function Hv(e) {
    if (e = e.resolve(), e.isFunction()) {
      let {
        node: t
      } = e;
      if (t.async)
        return t.generator ? rn(Kn("AsyncIterator")) : rn(Kn("Promise"));
      if (t.generator)
        return rn(Kn("Iterator"));
      if (e.node.returnType)
        return e.node.returnType;
    }
  }
  i(Hv, "resolveCall");
});

// ../node_modules/@babel/traverse/lib/path/inference/index.js
var Zv = D((sn) => {
  "use strict";
  Object.defineProperty(sn, "__esModule", {
    value: !0
  });
  sn._getTypeAnnotation = Qv;
  sn.baseTypeStrictlyMatches = vae;
  sn.couldBeBaseType = Sae;
  sn.getTypeAnnotation = xae;
  sn.isBaseType = Eae;
  sn.isGenericType = Pae;
  var Gv = Jv(), rae = ce(), {
    anyTypeAnnotation: zv,
    isAnyTypeAnnotation: Mu,
    isArrayTypeAnnotation: sae,
    isBooleanTypeAnnotation: nae,
    isEmptyTypeAnnotation: iae,
    isFlowBaseAnnotation: aae,
    isGenericTypeAnnotation: oae,
    isIdentifier: Xv,
    isMixedTypeAnnotation: lae,
    isNumberTypeAnnotation: uae,
    isStringTypeAnnotation: cae,
    isTSArrayType: pae,
    isTSTypeAnnotation: fae,
    isTSTypeReference: dae,
    isTupleTypeAnnotation: hae,
    isTypeAnnotation: mae,
    isUnionTypeAnnotation: yae,
    isVoidTypeAnnotation: bae,
    stringTypeAnnotation: gae,
    voidTypeAnnotation: Tae
  } = rae;
  function xae() {
    let e = this.getData("typeAnnotation");
    return e != null || (e = Qv.call(this) || zv(), (mae(e) || fae(e)) && (e = e.typeAnnotation), this.setData("typeAnnotation", e)), e;
  }
  i(xae, "getTypeAnnotation");
  var g1 = /* @__PURE__ */ new WeakSet();
  function Qv() {
    let e = this.node;
    if (!e)
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        let r = this.parentPath.parentPath, s = r.parentPath;
        return r.key === "left" && s.isForInStatement() ? gae() : r.key === "left" && s.isForOfStatement() ? zv() : Tae();
      } else
        return;
    if (e.typeAnnotation)
      return e.typeAnnotation;
    if (!g1.has(e)) {
      g1.add(e);
      try {
        var t;
        let r = Gv[e.type];
        if (r)
          return r.call(this, e);
        if (r = Gv[this.parentPath.type], (t = r) != null && t.validParent)
          return this.parentPath.getTypeAnnotation();
      } finally {
        g1.delete(e);
      }
    }
  }
  i(Qv, "_getTypeAnnotation");
  function Eae(e, t) {
    return T1(e, this.getTypeAnnotation(), t);
  }
  i(Eae, "isBaseType");
  function T1(e, t, r) {
    if (e === "string")
      return cae(t);
    if (e === "number")
      return uae(t);
    if (e === "boolean")
      return nae(t);
    if (e === "any")
      return Mu(t);
    if (e === "mixed")
      return lae(t);
    if (e === "empty")
      return iae(t);
    if (e === "void")
      return bae(t);
    if (r)
      return !1;
    throw new Error(`Unknown base type ${e}`);
  }
  i(T1, "_isBaseType");
  function Sae(e) {
    let t = this.getTypeAnnotation();
    if (Mu(t)) return !0;
    if (yae(t)) {
      for (let r of t.types)
        if (Mu(r) || T1(e, r, !0))
          return !0;
      return !1;
    } else
      return T1(e, t, !0);
  }
  i(Sae, "couldBeBaseType");
  function vae(e) {
    let t = this.getTypeAnnotation(), r = e.getTypeAnnotation();
    return !Mu(t) && aae(t) ? r.type === t.type : !1;
  }
  i(vae, "baseTypeStrictlyMatches");
  function Pae(e) {
    let t = this.getTypeAnnotation();
    return e === "Array" && (pae(t) || sae(t) || hae(t)) ? !0 : oae(t) && Xv(t.id, {
      name: e
    }) || dae(t) && Xv(t.typeName, {
      name: e
    });
  }
  i(Pae, "isGenericType");
});

// ../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var eP = D((Ru) => {
  "use strict";
  Object.defineProperty(Ru, "__esModule", {
    value: !0
  });
  Ru.hooks = void 0;
  var e8e = Ru.hooks = [function(e, t) {
    if (e.key === "test" && (t.isWhile() || t.isSwitchCase()) || e.key === "declaration" && t.isExportDeclaration() || e.key === "body" && t.
    isLabeledStatement() || e.listKey === "declarations" && t.isVariableDeclaration() && t.node.declarations.length === 1 || e.key === "expr\
ession" && t.isExpressionStatement())
      return t.remove(), !0;
  }, function(e, t) {
    if (t.isSequenceExpression() && t.node.expressions.length === 1)
      return t.replaceWith(t.node.expressions[0]), !0;
  }, function(e, t) {
    if (t.isBinary())
      return e.key === "left" ? t.replaceWith(t.node.right) : t.replaceWith(t.node.left), !0;
  }, function(e, t) {
    if (t.isIfStatement() && e.key === "consequent" || e.key === "body" && (t.isLoop() || t.isArrowFunctionExpression()))
      return e.replaceWith({
        type: "BlockStatement",
        directives: [],
        body: []
      }), !0;
  }];
});

// ../node_modules/@babel/traverse/lib/path/removal.js
var qu = D((nn) => {
  "use strict";
  Object.defineProperty(nn, "__esModule", {
    value: !0
  });
  nn._assertUnremoved = iP;
  nn._callRemovalHooks = sP;
  nn._markRemoved = x1;
  nn._remove = nP;
  nn._removeFromScope = rP;
  nn.remove = Oae;
  var Aae = eP(), Cae = Mn(), wae = E1(), tP = vs(), Dae = ce(), _ae = Uu(), Iae = br();
  function Oae() {
    var e;
    if (iP.call(this), Iae.resync.call(this), sP.call(this)) {
      x1.call(this);
      return;
    }
    (e = this.opts) != null && e.noScope || rP.call(this), this.shareCommentsWithSiblings(), nP.call(this), x1.call(this);
  }
  i(Oae, "remove");
  function rP() {
    let e = Dae.getBindingIdentifiers(this.node, !1, !1, !0);
    Object.keys(e).forEach((t) => this.scope.removeBinding(t));
  }
  i(rP, "_removeFromScope");
  function sP() {
    if (this.parentPath) {
      for (let e of Aae.hooks)
        if (e(this, this.parentPath)) return !0;
    }
  }
  i(sP, "_callRemovalHooks");
  function nP() {
    Array.isArray(this.container) ? (this.container.splice(this.key, 1), _ae.updateSiblingKeys.call(this, this.key, -1)) : wae._replaceWith.
    call(this, null);
  }
  i(nP, "_remove");
  function x1() {
    if (this._traverseFlags |= tP.SHOULD_SKIP | tP.REMOVED, this.parent) {
      var e;
      (e = (0, Cae.getCachedPaths)(this)) == null || e.delete(this.node);
    }
    this.node = null;
  }
  i(x1, "_markRemoved");
  function iP() {
    if (this.removed)
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
  }
  i(iP, "_assertUnremoved");
});

// ../node_modules/@babel/traverse/lib/path/lib/hoister.js
var oP = D(($u) => {
  "use strict";
  Object.defineProperty($u, "__esModule", {
    value: !0
  });
  $u.default = void 0;
  var aP = ce(), Nae = aP, {
    react: Bae
  } = aP, {
    cloneNode: kae,
    jsxExpressionContainer: Fae,
    variableDeclaration: Lae,
    variableDeclarator: jae
  } = Nae, Mae = {
    ReferencedIdentifier(e, t) {
      if (e.isJSXIdentifier() && Bae.isCompatTag(e.node.name) && !e.parentPath.isJSXMemberExpression())
        return;
      if (e.node.name === "this") {
        let s = e.scope;
        do
          if (s.path.isFunction() && !s.path.isArrowFunctionExpression())
            break;
        while (s = s.parent);
        s && t.breakOnScopePaths.push(s.path);
      }
      let r = e.scope.getBinding(e.node.name);
      if (r) {
        for (let s of r.constantViolations)
          if (s.scope !== r.path.scope) {
            t.mutableBinding = !0, e.stop();
            return;
          }
        r === t.scope.getBinding(e.node.name) && (t.bindings[e.node.name] = r);
      }
    }
  }, S1 = class {
    static {
      i(this, "PathHoister");
    }
    constructor(t, r) {
      this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.
      path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = !1, this.scopes = [],
      this.scope = r, this.path = t, this.attachAfter = !1;
    }
    isCompatibleScope(t) {
      for (let r of Object.keys(this.bindings)) {
        let s = this.bindings[r];
        if (!t.bindingIdentifierEquals(r, s.identifier))
          return !1;
      }
      return !0;
    }
    getCompatibleScopes() {
      let t = this.path.scope;
      do {
        if (this.isCompatibleScope(t))
          this.scopes.push(t);
        else
          break;
        if (this.breakOnScopePaths.includes(t.path))
          break;
      } while (t = t.parent);
    }
    getAttachmentPath() {
      let t = this._getAttachmentPath();
      if (!t) return;
      let r = t.scope;
      if (r.path === t && (r = t.scope.parent), r.path.isProgram() || r.path.isFunction())
        for (let s of Object.keys(this.bindings)) {
          if (!r.hasOwnBinding(s)) continue;
          let n = this.bindings[s];
          if (n.kind === "param" || n.path.parentKey === "params")
            continue;
          if (this.getAttachmentParentForPath(n.path).key >= t.key) {
            this.attachAfter = !0, t = n.path;
            for (let o of n.constantViolations)
              this.getAttachmentParentForPath(o).key > t.key && (t = o);
          }
        }
      return t;
    }
    _getAttachmentPath() {
      let r = this.scopes.pop();
      if (r) {
        if (r.path.isFunction())
          if (this.hasOwnParamBindings(r)) {
            if (this.scope === r) return;
            let s = r.path.get("body").get("body");
            for (let n = 0; n < s.length; n++)
              if (!s[n].node._blockHoist)
                return s[n];
          } else
            return this.getNextScopeAttachmentParent();
        else if (r.path.isProgram())
          return this.getNextScopeAttachmentParent();
      }
    }
    getNextScopeAttachmentParent() {
      let t = this.scopes.pop();
      if (t) return this.getAttachmentParentForPath(t.path);
    }
    getAttachmentParentForPath(t) {
      do
        if (!t.parentPath || Array.isArray(t.container) && t.isStatement())
          return t;
      while (t = t.parentPath);
      return t;
    }
    hasOwnParamBindings(t) {
      for (let r of Object.keys(this.bindings)) {
        if (!t.hasOwnBinding(r)) continue;
        let s = this.bindings[r];
        if (s.kind === "param" && s.constant) return !0;
      }
      return !1;
    }
    run() {
      if (this.path.traverse(Mae, this), this.mutableBinding) return;
      this.getCompatibleScopes();
      let t = this.getAttachmentPath();
      if (!t || t.getFunctionParent() === this.path.getFunctionParent()) return;
      let r = t.scope.generateUidIdentifier("ref"), s = jae(r, this.path.node), n = this.attachAfter ? "insertAfter" : "insertBefore", [a] = t[n](
      [t.isVariableDeclarator() ? s : Lae("var", [s])]), o = this.path.parentPath;
      return o.isJSXElement() && this.path.container === o.node.children && (r = Fae(r)), this.path.replaceWith(kae(r)), a.isVariableDeclarator() ?
      a.get("init") : a.get("declarations.0.init");
    }
  };
  $u.default = S1;
});

// ../node_modules/@babel/traverse/lib/path/modification.js
var Uu = D((Er) => {
  "use strict";
  Object.defineProperty(Er, "__esModule", {
    value: !0
  });
  Er._containerInsert = w1;
  Er._containerInsertAfter = cP;
  Er._containerInsertBefore = D1;
  Er._verifyNodeList = go;
  Er.insertAfter = toe;
  Er.insertBefore = Zae;
  Er.pushContainer = soe;
  Er.unshiftContainer = roe;
  Er.updateSiblingKeys = dP;
  var Rae = Mn(), C1 = vs(), v1 = br(), Vu = qu(), qae = ce(), Uae = oP(), {
    arrowFunctionExpression: $ae,
    assertExpression: Vae,
    assignmentExpression: Kae,
    blockStatement: lP,
    callExpression: Wae,
    cloneNode: P1,
    expressionStatement: A1,
    isAssignmentExpression: Yae,
    isCallExpression: Hae,
    isExportNamedDeclaration: uP,
    isExpression: Jae,
    isIdentifier: Gae,
    isSequenceExpression: Xae,
    isSuper: zae,
    thisExpression: Qae
  } = qae;
  function Zae(e) {
    Vu._assertUnremoved.call(this);
    let t = go.call(this, e), {
      parentPath: r,
      parent: s
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || uP(s) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertBefore(t);
    if (this.isNodeType("Expression") && !this.isJSXElement() || r.isForStatement() && this.key === "init")
      return this.node && t.push(this.node), this.replaceExpressionWithStatements(t);
    if (Array.isArray(this.container))
      return D1.call(this, t);
    if (this.isStatementOrBlock()) {
      let n = this.node, a = n && (!this.isExpressionStatement() || n.expression != null), [o] = this.replaceWith(lP(a ? [n] : []));
      return o.unshiftContainer("body", t);
    } else
      throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
  }
  i(Zae, "insertBefore");
  function w1(e, t) {
    dP.call(this, e, t.length);
    let r = [];
    this.container.splice(e, 0, ...t);
    for (let a = 0; a < t.length; a++) {
      var s;
      let o = e + a, l = this.getSibling(o);
      r.push(l), (s = this.context) != null && s.queue && v1.pushContext.call(l, this.context);
    }
    let n = v1._getQueueContexts.call(this);
    for (let a of r) {
      v1.setScope.call(a), a.debug("Inserted.");
      for (let o of n)
        o.maybeQueue(a, !0);
    }
    return r;
  }
  i(w1, "_containerInsert");
  function D1(e) {
    return w1.call(this, this.key, e);
  }
  i(D1, "_containerInsertBefore");
  function cP(e) {
    return w1.call(this, this.key + 1, e);
  }
  i(cP, "_containerInsertAfter");
  var pP = /* @__PURE__ */ i((e) => e[e.length - 1], "last");
  function fP(e) {
    return Xae(e.parent) && (pP(e.parent.expressions) !== e.node || fP(e.parentPath));
  }
  i(fP, "isHiddenInSequenceExpression");
  function eoe(e, t) {
    if (!Yae(e) || !Gae(e.left))
      return !1;
    let r = t.getBlockParent();
    return r.hasOwnBinding(e.left.name) && r.getOwnBinding(e.left.name).constantViolations.length <= 1;
  }
  i(eoe, "isAlmostConstantAssignment");
  function toe(e) {
    if (Vu._assertUnremoved.call(this), this.isSequenceExpression())
      return pP(this.get("expressions")).insertAfter(e);
    let t = go.call(this, e), {
      parentPath: r,
      parent: s
    } = this;
    if (r.isExpressionStatement() || r.isLabeledStatement() || uP(s) || r.isExportDefaultDeclaration() && this.isDeclaration())
      return r.insertAfter(t.map((n) => Jae(n) ? A1(n) : n));
    if (this.isNodeType("Expression") && !this.isJSXElement() && !r.isJSXElement() || r.isForStatement() && this.key === "init") {
      let n = this;
      if (n.node) {
        let a = n.node, {
          scope: o
        } = this;
        if (o.path.isPattern())
          return Vae(a), n.replaceWith(Wae($ae([], a), [])), n.get("callee.body").insertAfter(t), [n];
        if (fP(n))
          t.unshift(a);
        else if (Hae(a) && zae(a.callee))
          t.unshift(a), t.push(Qae());
        else if (eoe(a, o))
          t.unshift(a), t.push(P1(a.left));
        else if (o.isPure(a, !0))
          t.push(a);
        else {
          r.isMethod({
            computed: !0,
            key: a
          }) && (o = o.parent);
          let l = o.generateDeclaredUidIdentifier();
          t.unshift(A1(Kae("=", P1(l), a))), t.push(A1(P1(l)));
        }
      }
      return this.replaceExpressionWithStatements(t);
    } else {
      if (Array.isArray(this.container))
        return cP.call(this, t);
      if (this.isStatementOrBlock()) {
        let n = this.node, a = n && (!this.isExpressionStatement() || n.expression != null), [o] = this.replaceWith(lP(a ? [n] : []));
        return o.pushContainer("body", t);
      } else
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
    }
  }
  i(toe, "insertAfter");
  function dP(e, t) {
    if (!this.parent) return;
    let r = (0, Rae.getCachedPaths)(this);
    if (r)
      for (let [, s] of r)
        typeof s.key == "number" && s.container === this.container && s.key >= e && (s.key += t);
  }
  i(dP, "updateSiblingKeys");
  function go(e) {
    if (!e)
      return [];
    Array.isArray(e) || (e = [e]);
    for (let t = 0; t < e.length; t++) {
      let r = e[t], s;
      if (r ? typeof r != "object" ? s = "contains a non-object node" : r.type ? r instanceof C1.default && (s = "has a NodePath when it exp\
ected a raw object") : s = "without a type" : s = "has falsy node", s) {
        let n = Array.isArray(r) ? "array" : typeof r;
        throw new Error(`Node list ${s} with the index of ${t} and type of ${n}`);
      }
    }
    return e;
  }
  i(go, "_verifyNodeList");
  function roe(e, t) {
    Vu._assertUnremoved.call(this);
    let r = go.call(this, t), s = this.node[e], n = C1.default.get({
      parentPath: this,
      parent: this.node,
      container: s,
      listKey: e,
      key: 0
    }).setContext(this.context);
    return D1.call(n, r);
  }
  i(roe, "unshiftContainer");
  function soe(e, t) {
    Vu._assertUnremoved.call(this);
    let r = go.call(this, t), s = this.node[e];
    return C1.default.get({
      parentPath: this,
      parent: this.node,
      container: s,
      listKey: e,
      key: s.length
    }).setContext(this.context).replaceWithMultiple(r);
  }
  i(soe, "pushContainer");
  Er.hoist = /* @__PURE__ */ i(function(t = this.scope) {
    return new Uae.default(this, t).run();
  }, "hoist");
});

// ../node_modules/@babel/traverse/lib/path/replacement.js
var E1 = D((an) => {
  "use strict";
  Object.defineProperty(an, "__esModule", {
    value: !0
  });
  an._replaceWith = EP;
  an.replaceExpressionWithStatements = Ooe;
  an.replaceInline = Noe;
  an.replaceWith = Ioe;
  an.replaceWithMultiple = Doe;
  an.replaceWithSourceString = _oe;
  var noe = Za(), I1 = nt(), ioe = vs(), gP = Mn(), O1 = Uu(), aoe = Bn(), ooe = ce(), Ri = br(), {
    FUNCTION_TYPES: hP,
    arrowFunctionExpression: loe,
    assignmentExpression: TP,
    awaitExpression: uoe,
    blockStatement: coe,
    buildUndefinedNode: _1,
    callExpression: poe,
    cloneNode: N1,
    conditionalExpression: foe,
    expressionStatement: doe,
    getBindingIdentifiers: hoe,
    identifier: moe,
    inheritLeadingComments: yoe,
    inheritTrailingComments: boe,
    inheritsComments: goe,
    isBlockStatement: Toe,
    isEmptyStatement: mP,
    isExpression: xP,
    isExpressionStatement: xoe,
    isIfStatement: Eoe,
    isProgram: Soe,
    isStatement: voe,
    isVariableDeclaration: Poe,
    removeComments: Aoe,
    returnStatement: yP,
    sequenceExpression: Coe,
    validate: bP,
    yieldExpression: woe
  } = ooe;
  function Doe(e) {
    var t;
    Ri.resync.call(this);
    let r = O1._verifyNodeList.call(this, e);
    yoe(r[0], this.node), boe(r[r.length - 1], this.node), (t = (0, gP.getCachedPaths)(this)) == null || t.delete(this.node), this.node = this.
    container[this.key] = null;
    let s = this.insertAfter(e);
    return this.node ? this.requeue() : this.remove(), s;
  }
  i(Doe, "replaceWithMultiple");
  function _oe(e) {
    Ri.resync.call(this);
    let t;
    try {
      e = `(${e})`, t = (0, aoe.parse)(e);
    } catch (s) {
      let n = s.loc;
      throw n && (s.message += ` - make sure this is an expression.
` + (0, noe.codeFrameColumns)(e, {
        start: {
          line: n.line,
          column: n.column + 1
        }
      }), s.code = "BABEL_REPLACE_SOURCE_ERROR"), s;
    }
    let r = t.program.body[0].expression;
    return I1.default.removeProperties(r), this.replaceWith(r);
  }
  i(_oe, "replaceWithSourceString");
  function Ioe(e) {
    if (Ri.resync.call(this), this.removed)
      throw new Error("You can't replace this node, we've already removed it");
    let t = e instanceof ioe.default ? e.node : e;
    if (!t)
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    if (this.node === t)
      return [this];
    if (this.isProgram() && !Soe(t))
      throw new Error("You can only replace a Program root node with another Program node");
    if (Array.isArray(t))
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    if (typeof t == "string")
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    let r = "";
    if (this.isNodeType("Statement") && xP(t) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(
    t) && !this.parentPath.isExportDefaultDeclaration() && (t = doe(t), r = "expression"), this.isNodeType("Expression") && voe(t) && !this.
    canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(t))
      return this.replaceExpressionWithStatements([t]);
    let s = this.node;
    return s && (goe(t, s), Aoe(s)), EP.call(this, t), this.type = t.type, Ri.setScope.call(this), this.requeue(), [r ? this.get(r) : this];
  }
  i(Ioe, "replaceWith");
  function EP(e) {
    var t;
    if (!this.container)
      throw new ReferenceError("Container is falsy");
    this.inList ? bP(this.parent, this.key, [e]) : bP(this.parent, this.key, e), this.debug(`Replace with ${e?.type}`), (t = (0, gP.getCachedPaths)(
    this)) == null || t.set(e, this).delete(this.node), this.node = e, this.container[this.key] = e;
  }
  i(EP, "_replaceWith");
  function Ooe(e) {
    Ri.resync.call(this);
    let t = [], r = Ku(e, t);
    if (r) {
      for (let h of t) this.scope.push({
        id: h
      });
      return this.replaceWith(r)[0].get("expressions");
    }
    let s = this.getFunctionParent(), n = s?.node.async, a = s?.node.generator, o = loe([], coe(e));
    this.replaceWith(poe(o, []));
    let l = this.get("callee");
    l.get("body").scope.hoistVariables((h) => this.scope.push({
      id: h
    }));
    let u = l.getCompletionRecords();
    for (let h of u) {
      if (!h.isExpressionStatement()) continue;
      let b = h.findParent((T) => T.isLoop());
      if (b) {
        let T = b.getData("expressionReplacementReturnUid");
        T ? T = moe(T.name) : (T = l.scope.generateDeclaredUidIdentifier("ret"), l.get("body").pushContainer("body", yP(N1(T))), b.setData("\
expressionReplacementReturnUid", T)), h.get("expression").replaceWith(TP("=", N1(T), h.node.expression));
      } else
        h.replaceWith(yP(h.node.expression));
    }
    l.arrowFunctionToExpression();
    let c = l, p = n && I1.default.hasType(this.get("callee.body").node, "AwaitExpression", hP), f = a && I1.default.hasType(this.get("calle\
e.body").node, "YieldExpression", hP);
    return p && (c.set("async", !0), f || this.replaceWith(uoe(this.node))), f && (c.set("generator", !0), this.replaceWith(woe(this.node, !0))),
    c.get("body.body");
  }
  i(Ooe, "replaceExpressionWithStatements");
  function Ku(e, t) {
    let r = [], s = !0;
    for (let n of e)
      if (mP(n) || (s = !1), xP(n))
        r.push(n);
      else if (xoe(n))
        r.push(n.expression);
      else if (Poe(n)) {
        if (n.kind !== "var") return;
        for (let a of n.declarations) {
          let o = hoe(a);
          for (let l of Object.keys(o))
            t.push(N1(o[l]));
          a.init && r.push(TP("=", a.id, a.init));
        }
        s = !0;
      } else if (Eoe(n)) {
        let a = n.consequent ? Ku([n.consequent], t) : _1(), o = n.alternate ? Ku([n.alternate], t) : _1();
        if (!a || !o) return;
        r.push(foe(n.test, a, o));
      } else if (Toe(n)) {
        let a = Ku(n.body, t);
        if (!a) return;
        r.push(a);
      } else if (mP(n))
        e.indexOf(n) === 0 && (s = !0);
      else
        return;
    return s && r.push(_1()), r.length === 1 ? r[0] : Coe(r);
  }
  i(Ku, "gatherSequenceExpressions");
  function Noe(e) {
    if (Ri.resync.call(this), Array.isArray(e))
      if (Array.isArray(this.container)) {
        e = O1._verifyNodeList.call(this, e);
        let t = O1._containerInsertAfter.call(this, e);
        return this.remove(), t;
      } else
        return this.replaceWithMultiple(e);
    else
      return this.replaceWith(e);
  }
  i(Noe, "replaceInline");
});

// ../node_modules/@babel/traverse/lib/path/evaluation.js
var AP = D((Wu) => {
  "use strict";
  Object.defineProperty(Wu, "__esModule", {
    value: !0
  });
  Wu.evaluate = qoe;
  Wu.evaluateTruthy = Moe;
  var Boe = ["Number", "String", "Math"], koe = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeUR\
I", "encodeURIComponent", null, null], Foe = ["random"];
  function SP(e) {
    return Boe.includes(e);
  }
  i(SP, "isValidObjectCallee");
  function Loe(e) {
    return koe.includes(e);
  }
  i(Loe, "isValidIdentifierCallee");
  function joe(e) {
    return Foe.includes(e);
  }
  i(joe, "isInvalidMethod");
  function Moe() {
    let e = this.evaluate();
    if (e.confident) return !!e.value;
  }
  i(Moe, "evaluateTruthy");
  function qr(e, t) {
    t.confident && (t.deoptPath = e, t.confident = !1);
  }
  i(qr, "deopt");
  var vP = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", 1 / 0], ["NaN", NaN]]);
  function Ht(e, t) {
    let {
      node: r
    } = e, {
      seen: s
    } = t;
    if (s.has(r)) {
      let n = s.get(r);
      if (n.resolved)
        return n.value;
      qr(e, t);
      return;
    } else {
      let n = {
        resolved: !1
      };
      s.set(r, n);
      let a = Roe(e, t);
      return t.confident && (n.resolved = !0, n.value = a), a;
    }
  }
  i(Ht, "evaluateCached");
  function Roe(e, t) {
    if (t.confident) {
      if (e.isSequenceExpression()) {
        let s = e.get("expressions");
        return Ht(s[s.length - 1], t);
      }
      if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral())
        return e.node.value;
      if (e.isNullLiteral())
        return null;
      if (e.isTemplateLiteral())
        return PP(e, e.node.quasis, t);
      if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
        let s = e.get("tag.object"), {
          node: {
            name: n
          }
        } = s, a = e.get("tag.property");
        if (s.isIdentifier() && n === "String" && !e.scope.getBinding(n) && a.isIdentifier() && a.node.name === "raw")
          return PP(e, e.node.quasi.quasis, t, !0);
      }
      if (e.isConditionalExpression()) {
        let s = Ht(e.get("test"), t);
        return t.confident ? Ht(s ? e.get("consequent") : e.get("alternate"), t) : void 0;
      }
      if (e.isExpressionWrapper())
        return Ht(e.get("expression"), t);
      if (e.isMemberExpression() && !e.parentPath.isCallExpression({
        callee: e.node
      })) {
        let s = e.get("property"), n = e.get("object");
        if (n.isLiteral()) {
          let a = n.node.value, o = typeof a, l = null;
          if (e.node.computed) {
            if (l = Ht(s, t), !t.confident) return;
          } else s.isIdentifier() && (l = s.node.name);
          if ((o === "number" || o === "string") && l != null && (typeof l == "number" || typeof l == "string"))
            return a[l];
        }
      }
      if (e.isReferencedIdentifier()) {
        let s = e.scope.getBinding(e.node.name);
        if (s) {
          if (s.constantViolations.length > 0 || e.node.start < s.path.node.end) {
            qr(s.path, t);
            return;
          }
          let l = s.path.scope;
          if (s.kind === "var" && l !== s.scope) {
            let u = !l.path.parentPath.isBlockStatement();
            for (let c = l.parent; c; c = c.parent) {
              var r;
              if (c === e.scope) {
                if (u) {
                  qr(s.path, t);
                  return;
                }
                break;
              }
              (r = c.path.parentPath) != null && r.isBlockStatement() && (u = !0);
            }
          }
          if (s.hasValue)
            return s.value;
        }
        let n = e.node.name;
        if (vP.has(n)) {
          if (!s)
            return vP.get(n);
          qr(s.path, t);
          return;
        }
        let a = e.resolve();
        if (a === e) {
          qr(e, t);
          return;
        }
        let o = Ht(a, t);
        if (typeof o == "object" && o !== null && s.references > 1) {
          qr(a, t);
          return;
        }
        return o;
      }
      if (e.isUnaryExpression({
        prefix: !0
      })) {
        if (e.node.operator === "void")
          return;
        let s = e.get("argument");
        if (e.node.operator === "typeof" && (s.isFunction() || s.isClass()))
          return "function";
        let n = Ht(s, t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "!":
            return !n;
          case "+":
            return +n;
          case "-":
            return -n;
          case "~":
            return ~n;
          case "typeof":
            return typeof n;
        }
      }
      if (e.isArrayExpression()) {
        let s = [], n = e.get("elements");
        for (let a of n) {
          let o = a.evaluate();
          if (o.confident)
            s.push(o.value);
          else {
            qr(o.deopt, t);
            return;
          }
        }
        return s;
      }
      if (e.isObjectExpression()) {
        let s = {}, n = e.get("properties");
        for (let a of n) {
          if (a.isObjectMethod() || a.isSpreadElement()) {
            qr(a, t);
            return;
          }
          let o = a.get("key"), l;
          if (a.node.computed) {
            if (l = o.evaluate(), !l.confident) {
              qr(l.deopt, t);
              return;
            }
            l = l.value;
          } else o.isIdentifier() ? l = o.node.name : l = o.node.value;
          let c = a.get("value").evaluate();
          if (!c.confident) {
            qr(c.deopt, t);
            return;
          }
          c = c.value, s[l] = c;
        }
        return s;
      }
      if (e.isLogicalExpression()) {
        let s = t.confident, n = Ht(e.get("left"), t), a = t.confident;
        t.confident = s;
        let o = Ht(e.get("right"), t), l = t.confident;
        switch (e.node.operator) {
          case "||":
            return t.confident = a && (!!n || l), t.confident ? n || o : void 0;
          case "&&":
            return t.confident = a && (!n || l), t.confident ? n && o : void 0;
          case "??":
            return t.confident = a && (n != null || l), t.confident ? n ?? o : void 0;
        }
      }
      if (e.isBinaryExpression()) {
        let s = Ht(e.get("left"), t);
        if (!t.confident) return;
        let n = Ht(e.get("right"), t);
        if (!t.confident) return;
        switch (e.node.operator) {
          case "-":
            return s - n;
          case "+":
            return s + n;
          case "/":
            return s / n;
          case "*":
            return s * n;
          case "%":
            return s % n;
          case "**":
            return Math.pow(s, n);
          case "<":
            return s < n;
          case ">":
            return s > n;
          case "<=":
            return s <= n;
          case ">=":
            return s >= n;
          case "==":
            return s == n;
          case "!=":
            return s != n;
          case "===":
            return s === n;
          case "!==":
            return s !== n;
          case "|":
            return s | n;
          case "&":
            return s & n;
          case "^":
            return s ^ n;
          case "<<":
            return s << n;
          case ">>":
            return s >> n;
          case ">>>":
            return s >>> n;
        }
      }
      if (e.isCallExpression()) {
        let s = e.get("callee"), n, a;
        if (s.isIdentifier() && !e.scope.getBinding(s.node.name) && (SP(s.node.name) || Loe(s.node.name)) && (a = global[s.node.name]), s.isMemberExpression()) {
          let o = s.get("object"), l = s.get("property");
          if (o.isIdentifier() && l.isIdentifier() && SP(o.node.name) && !joe(l.node.name)) {
            n = global[o.node.name];
            let u = l.node.name;
            hasOwnProperty.call(n, u) && (a = n[u]);
          }
          if (o.isLiteral() && l.isIdentifier()) {
            let u = typeof o.node.value;
            (u === "string" || u === "number") && (n = o.node.value, a = n[l.node.name]);
          }
        }
        if (a) {
          let o = e.get("arguments").map((l) => Ht(l, t));
          return t.confident ? a.apply(n, o) : void 0;
        }
      }
      qr(e, t);
    }
  }
  i(Roe, "_evaluate");
  function PP(e, t, r, s = !1) {
    let n = "", a = 0, o = e.isTemplateLiteral() ? e.get("expressions") : e.get("quasi.expressions");
    for (let l of t) {
      if (!r.confident) break;
      n += s ? l.value.raw : l.value.cooked;
      let u = o[a++];
      u && (n += String(Ht(u, r)));
    }
    if (r.confident)
      return n;
  }
  i(PP, "evaluateQuasis");
  function qoe() {
    let e = {
      confident: !0,
      deoptPath: null,
      seen: /* @__PURE__ */ new Map()
    }, t = Ht(this, e);
    return e.confident || (t = void 0), {
      confident: e.confident,
      deopt: e.deoptPath,
      value: t
    };
  }
  i(qoe, "evaluate");
});

// ../node_modules/@babel/traverse/lib/path/conversion.js
var BP = D((Ps) => {
  "use strict";
  Object.defineProperty(Ps, "__esModule", {
    value: !0
  });
  Ps.arrowFunctionToExpression = yle;
  Ps.ensureBlock = dle;
  Ps.ensureFunctionName = Dle;
  Ps.splitExportDeclaration = Cle;
  Ps.toComputedKey = fle;
  Ps.unwrapFunctionEnvironment = hle;
  var Uoe = ce(), $oe = ro(), F1 = no(), Voe = br(), {
    arrowFunctionExpression: L1,
    assignmentExpression: Yn,
    binaryExpression: B1,
    blockStatement: Koe,
    callExpression: qi,
    conditionalExpression: Woe,
    expressionStatement: DP,
    identifier: Le,
    isIdentifier: Yoe,
    jsxIdentifier: Hoe,
    logicalExpression: Joe,
    LOGICAL_OPERATORS: Goe,
    memberExpression: Ur,
    metaProperty: Xoe,
    numericLiteral: zoe,
    objectExpression: Qoe,
    restElement: Zoe,
    returnStatement: ele,
    sequenceExpression: tle,
    spreadElement: rle,
    stringLiteral: _P,
    super: k1,
    thisExpression: To,
    toExpression: IP,
    unaryExpression: sle,
    toBindingIdentifierName: nle,
    isFunction: ile,
    isAssignmentPattern: ale,
    isRestElement: ole,
    getFunctionName: lle,
    cloneNode: Hn,
    variableDeclaration: ule,
    variableDeclarator: cle,
    exportNamedDeclaration: CP,
    exportSpecifier: wP,
    inherits: ple
  } = Uoe;
  function fle() {
    let e;
    if (this.isMemberExpression())
      e = this.node.property;
    else if (this.isProperty() || this.isMethod())
      e = this.node.key;
    else
      throw new ReferenceError("todo");
    return this.node.computed || Yoe(e) && (e = _P(e.name)), e;
  }
  i(fle, "toComputedKey");
  function dle() {
    let e = this.get("body"), t = e.node;
    if (Array.isArray(e))
      throw new Error("Can't convert array path to a block statement");
    if (!t)
      throw new Error("Can't convert node without a body");
    if (e.isBlockStatement())
      return t;
    let r = [], s = "body", n, a;
    e.isStatement() ? (a = "body", n = 0, r.push(e.node)) : (s += ".body.0", this.isFunction() ? (n = "argument", r.push(ele(e.node))) : (n =
    "expression", r.push(DP(e.node)))), this.node.body = Koe(r);
    let o = this.get(s);
    return Voe.setup.call(e, o, a ? o.node[a] : o.node, a, n), this.node;
  }
  i(dle, "ensureBlock");
  Ps.arrowFunctionToShadowed = function() {
    this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
  };
  function hle() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    OP(this);
  }
  i(hle, "unwrapFunctionEnvironment");
  function mle(e, t) {
    e.node.type = t;
  }
  i(mle, "setType");
  function yle({
    allowInsertArrow: e = !0,
    allowInsertArrowWithRest: t = e,
    noNewArrows: r = !((s) => (s = arguments[0]) == null ? void 0 : s.specCompliant)()
  } = {}) {
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    let s = this;
    if (!r) {
      var n;
      s = (n = s.ensureFunctionName(!1)) != null ? n : s;
    }
    let {
      thisBinding: a,
      fnPath: o
    } = OP(s, r, e, t);
    if (o.ensureBlock(), mle(o, "FunctionExpression"), !r) {
      let l = a ? null : o.scope.generateUidIdentifier("arrowCheckId");
      return l && o.parentPath.scope.push({
        id: l,
        init: Qoe([])
      }), o.get("body").unshiftContainer("body", DP(qi(this.hub.addHelper("newArrowCheck"), [To(), Le(l ? l.name : a)]))), o.replaceWith(qi(
      Ur(o.node, Le("bind")), [l ? Le(l.name) : To()])), o.get("callee.object");
    }
    return o;
  }
  i(yle, "arrowFunctionToExpression");
  var ble = (0, F1.environmentVisitor)({
    CallExpression(e, {
      allSuperCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    }
  });
  function OP(e, t = !0, r = !0, s = !0) {
    let n, a = e.findParent((b) => b.isArrowFunctionExpression() ? (n ?? (n = b), !1) : b.isFunction() || b.isProgram() || b.isClassProperty(
    {
      static: !1
    }) || b.isClassPrivateProperty({
      static: !1
    })), o = a.isClassMethod({
      kind: "constructor"
    });
    if (a.isClassProperty() || a.isClassPrivateProperty())
      if (n)
        a = n;
      else if (r)
        e.replaceWith(qi(L1([], IP(e.node)), [])), a = e.get("callee"), e = a.get("body");
      else
        throw e.buildCodeFrameError("Unable to transform arrow inside class property");
    let {
      thisPaths: l,
      argumentsPaths: u,
      newTargetPaths: c,
      superProps: p,
      superCalls: f
    } = Ale(e);
    if (o && f.length > 0) {
      if (!r)
        throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an a\
rrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      if (!s)
        throw f[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow \
function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration\
.");
      let b = [];
      a.traverse(ble, {
        allSuperCalls: b
      });
      let T = Sle(a);
      b.forEach((d) => {
        let g = Le(T);
        g.loc = d.node.callee.loc, d.get("callee").replaceWith(g);
      });
    }
    if (u.length > 0) {
      let b = xo(a, "arguments", () => {
        let T = /* @__PURE__ */ i(() => Le("arguments"), "args");
        return a.scope.path.isProgram() ? Woe(B1("===", sle("typeof", T()), _P("undefined")), a.scope.buildUndefinedNode(), T()) : T();
      });
      u.forEach((T) => {
        let d = Le(b);
        d.loc = T.node.loc, T.replaceWith(d);
      });
    }
    if (c.length > 0) {
      let b = xo(a, "newtarget", () => Xoe(Le("new"), Le("target")));
      c.forEach((T) => {
        let d = Le(b);
        d.loc = T.node.loc, T.replaceWith(d);
      });
    }
    if (p.length > 0) {
      if (!r)
        throw p[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in a\
n arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
      p.reduce((T, d) => T.concat(Tle(d)), []).forEach((T) => {
        let d = T.node.computed ? "" : T.get("property").node.name, g = T.parentPath, E = g.isAssignmentExpression({
          left: T.node
        }), _ = g.isCallExpression({
          callee: T.node
        }), N = g.isTaggedTemplateExpression({
          tag: T.node
        }), k = vle(a, E, d), j = [];
        if (T.node.computed && j.push(T.get("property").node), E) {
          let M = g.node.right;
          j.push(M);
        }
        let U = qi(Le(k), j);
        _ ? (g.unshiftContainer("arguments", To()), T.replaceWith(Ur(U, Le("call"))), l.push(g.get("arguments.0"))) : E ? g.replaceWith(U) :
        N ? (T.replaceWith(qi(Ur(U, Le("bind"), !1), [To()])), l.push(T.get("arguments.0"))) : T.replaceWith(U);
      });
    }
    let h;
    return (l.length > 0 || !t) && (h = Ele(a, o), (t || o && NP(a)) && (l.forEach((b) => {
      let T = b.isJSX() ? Hoe(h) : Le(h);
      T.loc = b.node.loc, b.replaceWith(T);
    }), t || (h = null))), {
      thisBinding: h,
      fnPath: e
    };
  }
  i(OP, "hoistFunctionEnvironment");
  function gle(e) {
    return Goe.includes(e);
  }
  i(gle, "isLogicalOp");
  function Tle(e) {
    if (e.parentPath.isAssignmentExpression() && e.parentPath.node.operator !== "=") {
      let r = e.parentPath, s = r.node.operator.slice(0, -1), n = r.node.right, a = gle(s);
      if (e.node.computed) {
        let o = e.scope.generateDeclaredUidIdentifier("tmp"), {
          object: l,
          property: u
        } = e.node;
        r.get("left").replaceWith(Ur(l, Yn("=", o, u), !0)), r.get("right").replaceWith(t(a ? "=" : s, Ur(l, Le(o.name), !0), n));
      } else {
        let o = e.node.object, l = e.node.property;
        r.get("left").replaceWith(Ur(o, l)), r.get("right").replaceWith(t(a ? "=" : s, Ur(o, Le(l.name)), n));
      }
      return a ? r.replaceWith(Joe(s, r.node.left, r.node.right)) : r.node.operator = "=", [r.get("left"), r.get("right").get("left")];
    } else if (e.parentPath.isUpdateExpression()) {
      let r = e.parentPath, s = e.scope.generateDeclaredUidIdentifier("tmp"), n = e.node.computed ? e.scope.generateDeclaredUidIdentifier("p\
rop") : null, a = [Yn("=", s, Ur(e.node.object, n ? Yn("=", n, e.node.property) : e.node.property, e.node.computed)), Yn("=", Ur(e.node.object,
      n ? Le(n.name) : e.node.property, e.node.computed), B1(e.parentPath.node.operator[0], Le(s.name), zoe(1)))];
      e.parentPath.node.prefix || a.push(Le(s.name)), r.replaceWith(tle(a));
      let o = r.get("expressions.0.right"), l = r.get("expressions.1.left");
      return [o, l];
    }
    return [e];
    function t(r, s, n) {
      return r === "=" ? Yn("=", s, n) : B1(r, s, n);
    }
  }
  i(Tle, "standardizeSuperProperty");
  function NP(e) {
    return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
  }
  i(NP, "hasSuperClass");
  var xle = (0, F1.environmentVisitor)({
    CallExpression(e, {
      supers: t,
      thisBinding: r
    }) {
      e.get("callee").isSuper() && (t.has(e.node) || (t.add(e.node), e.replaceWithMultiple([e.node, Yn("=", Le(r), Le("this"))])));
    }
  });
  function Ele(e, t) {
    return xo(e, "this", (r) => {
      if (!t || !NP(e)) return To();
      e.traverse(xle, {
        supers: /* @__PURE__ */ new WeakSet(),
        thisBinding: r
      });
    });
  }
  i(Ele, "getThisBinding");
  function Sle(e) {
    return xo(e, "supercall", () => {
      let t = e.scope.generateUidIdentifier("args");
      return L1([Zoe(t)], qi(k1(), [rle(Le(t.name))]));
    });
  }
  i(Sle, "getSuperBinding");
  function vle(e, t, r) {
    return xo(e, `superprop_${t ? "set" : "get"}:${r || ""}`, () => {
      let n = [], a;
      if (r)
        a = Ur(k1(), Le(r));
      else {
        let o = e.scope.generateUidIdentifier("prop");
        n.unshift(o), a = Ur(k1(), Le(o.name), !0);
      }
      if (t) {
        let o = e.scope.generateUidIdentifier("value");
        n.push(o), a = Yn("=", a, Le(o.name));
      }
      return L1(n, a);
    });
  }
  i(vle, "getSuperPropBinding");
  function xo(e, t, r) {
    let s = "binding:" + t, n = e.getData(s);
    if (!n) {
      let a = e.scope.generateUidIdentifier(t);
      n = a.name, e.setData(s, n), e.scope.push({
        id: a,
        init: r(n)
      });
    }
    return n;
  }
  i(xo, "getBinding");
  var Ple = (0, F1.environmentVisitor)({
    ThisExpression(e, {
      thisPaths: t
    }) {
      t.push(e);
    },
    JSXIdentifier(e, {
      thisPaths: t
    }) {
      e.node.name === "this" && (!e.parentPath.isJSXMemberExpression({
        object: e.node
      }) && !e.parentPath.isJSXOpeningElement({
        name: e.node
      }) || t.push(e));
    },
    CallExpression(e, {
      superCalls: t
    }) {
      e.get("callee").isSuper() && t.push(e);
    },
    MemberExpression(e, {
      superProps: t
    }) {
      e.get("object").isSuper() && t.push(e);
    },
    Identifier(e, {
      argumentsPaths: t
    }) {
      if (!e.isReferencedIdentifier({
        name: "arguments"
      })) return;
      let r = e.scope;
      do {
        if (r.hasOwnBinding("arguments")) {
          r.rename("arguments");
          return;
        }
        if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
          break;
      } while (r = r.parent);
      t.push(e);
    },
    MetaProperty(e, {
      newTargetPaths: t
    }) {
      e.get("meta").isIdentifier({
        name: "new"
      }) && e.get("property").isIdentifier({
        name: "target"
      }) && t.push(e);
    }
  });
  function Ale(e) {
    let t = [], r = [], s = [], n = [], a = [];
    return e.traverse(Ple, {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: s,
      superProps: n,
      superCalls: a
    }), {
      thisPaths: t,
      argumentsPaths: r,
      newTargetPaths: s,
      superProps: n,
      superCalls: a
    };
  }
  i(Ale, "getScopeInformation");
  function Cle() {
    if (!this.isExportDeclaration() || this.isExportAllDeclaration())
      throw new Error("Only default and named export declarations can be split.");
    if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let e = this.get("declaration");
    if (this.isExportDefaultDeclaration()) {
      let n = e.isFunctionDeclaration() || e.isClassDeclaration(), a = e.isFunctionExpression() || e.isClassExpression(), o = e.isScope() ? e.
      scope.parent : e.scope, l = e.node.id, u = !1;
      l ? a && o.hasBinding(l.name) && (u = !0, l = o.generateUidIdentifier(l.name)) : (u = !0, l = o.generateUidIdentifier("default"), (n ||
      a) && (e.node.id = Hn(l)));
      let c = n ? e.node : ule("var", [cle(Hn(l), e.node)]), p = CP(null, [wP(Hn(l), Le("default"))]);
      return this.insertAfter(p), this.replaceWith(c), u && o.registerDeclaration(this), this;
    } else if (this.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    let t = e.getOuterBindingIdentifiers(), r = Object.keys(t).map((n) => wP(Le(n), Le(n))), s = CP(null, r);
    return this.insertAfter(s), this.replaceWith(e.node), this;
  }
  i(Cle, "splitExportDeclaration");
  var wle = {
    "ReferencedIdentifier|BindingIdentifier"(e, t) {
      e.node.name === t.name && (t.needsRename = !0, e.stop());
    },
    Scope(e, t) {
      e.scope.hasOwnBinding(t.name) && e.skip();
    }
  };
  function Dle(e) {
    if (this.node.id) return this;
    let t = lle(this.node, this.parent);
    if (t == null) return this;
    let {
      name: r
    } = t;
    if (!e && /[\uD800-\uDFFF]/.test(r) || r.startsWith("get ") || r.startsWith("set "))
      return null;
    r = nle(r.replace(/[/ ]/g, "_"));
    let s = Le(r);
    ple(s, t.originalNode);
    let n = {
      needsRename: !1,
      name: r
    }, {
      scope: a
    } = this, o = a.getOwnBinding(r);
    if (o ? o.kind === "param" && (n.needsRename = !0) : (a.parent.hasBinding(r) || a.hasGlobal(r)) && this.traverse(wle, n), !n.needsRename)
      return this.node.id = s, a.getProgramParent().references[s.name] = !0, this;
    if (a.hasBinding(s.name) && !a.hasGlobal(s.name))
      return a.rename(s.name), this.node.id = s, a.getProgramParent().references[s.name] = !0, this;
    if (!ile(this.node)) return null;
    let l = a.generateUidIdentifier(s.name), u = [];
    for (let p = 0, f = _le(this.node); p < f; p++)
      u.push(a.generateUidIdentifier("x"));
    let c = $oe.default.expression.ast`
    (function (${l}) {
      function ${s}(${u}) {
        return ${Hn(l)}.apply(this, arguments);
      }

      ${Hn(s)}.toString = function () {
        return ${Hn(l)}.toString();
      }

      return ${Hn(s)};
    })(${IP(this.node)})
  `;
    return this.replaceWith(c)[0].get("arguments.0");
  }
  i(Dle, "ensureFunctionName");
  function _le(e) {
    let t = e.params.findIndex((r) => ale(r) || ole(r));
    return t === -1 ? e.params.length : t;
  }
  i(_le, "getFunctionArity");
});

// ../node_modules/@babel/traverse/lib/path/introspection.js
var RP = D((Qe) => {
  "use strict";
  Object.defineProperty(Qe, "__esModule", {
    value: !0
  });
  Qe._guessExecutionStatusRelativeTo = Xle;
  Qe._resolve = MP;
  Qe.canHaveVariableDeclarationOrExpression = $le;
  Qe.canSwapBetweenExpressionAndStatement = Vle;
  Qe.getSource = Hle;
  Qe.isCompletionRecord = Kle;
  Qe.isConstantExpression = eue;
  Qe.isInStrictMode = tue;
  Qe.isNodeType = Ule;
  Qe.isStatementOrBlock = Wle;
  Qe.isStatic = qle;
  Qe.matchesPattern = Rle;
  Qe.referencesImport = Yle;
  Qe.resolve = Zle;
  Qe.willIMaybeExecuteBefore = Jle;
  var Ile = ce(), {
    STATEMENT_OR_BLOCK_KEYS: Ole,
    VISITOR_KEYS: Nle,
    isBlockStatement: jP,
    isExpression: Ble,
    isIdentifier: kle,
    isLiteral: Fle,
    isStringLiteral: Lle,
    isType: jle,
    matchesPattern: Mle
  } = Ile;
  function Rle(e, t) {
    return Mle(this.node, e, t);
  }
  i(Rle, "matchesPattern");
  Qe.has = /* @__PURE__ */ i(function(t) {
    var r;
    let s = (r = this.node) == null ? void 0 : r[t];
    return s && Array.isArray(s) ? !!s.length : !!s;
  }, "has");
  function qle() {
    return this.scope.isStatic(this.node);
  }
  i(qle, "isStatic");
  Qe.is = Qe.has, Qe.isnt = /* @__PURE__ */ i(function(t) {
    return !this.has(t);
  }, "isnt"), Qe.equals = /* @__PURE__ */ i(function(t, r) {
    return this.node[t] === r;
  }, "equals");
  function Ule(e) {
    return jle(this.type, e);
  }
  i(Ule, "isNodeType");
  function $le() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  i($le, "canHaveVariableDeclarationOrExpression");
  function Vle(e) {
    return this.key !== "body" || !this.parentPath.isArrowFunctionExpression() ? !1 : this.isExpression() ? jP(e) : this.isBlockStatement() ?
    Ble(e) : !1;
  }
  i(Vle, "canSwapBetweenExpressionAndStatement");
  function Kle(e) {
    let t = this, r = !0;
    do {
      let {
        type: s,
        container: n
      } = t;
      if (!r && (t.isFunction() || s === "StaticBlock"))
        return !!e;
      if (r = !1, Array.isArray(n) && t.key !== n.length - 1)
        return !1;
    } while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
    return !0;
  }
  i(Kle, "isCompletionRecord");
  function Wle() {
    return this.parentPath.isLabeledStatement() || jP(this.container) ? !1 : Ole.includes(this.key);
  }
  i(Wle, "isStatementOrBlock");
  function Yle(e, t) {
    if (!this.isReferencedIdentifier()) {
      if (this.isJSXMemberExpression() && this.node.property.name === t || (this.isMemberExpression() || this.isOptionalMemberExpression()) &&
      (this.node.computed ? Lle(this.node.property, {
        value: t
      }) : this.node.property.name === t)) {
        let a = this.get("object");
        return a.isReferencedIdentifier() && a.referencesImport(e, "*");
      }
      return !1;
    }
    let r = this.scope.getBinding(this.node.name);
    if (!r || r.kind !== "module") return !1;
    let s = r.path, n = s.parentPath;
    if (!n.isImportDeclaration()) return !1;
    if (n.node.source.value === e) {
      if (!t) return !0;
    } else
      return !1;
    return !!(s.isImportDefaultSpecifier() && t === "default" || s.isImportNamespaceSpecifier() && t === "*" || s.isImportSpecifier() && kle(
    s.node.imported, {
      name: t
    }));
  }
  i(Yle, "referencesImport");
  function Hle() {
    let e = this.node;
    if (e.end) {
      let t = this.hub.getCode();
      if (t) return t.slice(e.start, e.end);
    }
    return "";
  }
  i(Hle, "getSource");
  function Jle(e) {
    return this._guessExecutionStatusRelativeTo(e) !== "after";
  }
  i(Jle, "willIMaybeExecuteBefore");
  function kP(e) {
    return e.isProgram() ? e : (e.parentPath.scope.getFunctionParent() || e.parentPath.scope.getProgramParent()).path;
  }
  i(kP, "getOuterFunction");
  function Gle(e, t) {
    switch (e) {
      case "LogicalExpression":
        return t === "right";
      case "ConditionalExpression":
      case "IfStatement":
        return t === "consequent" || t === "alternate";
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return t === "body";
      case "ForStatement":
        return t === "body" || t === "update";
      case "SwitchStatement":
        return t === "cases";
      case "TryStatement":
        return t === "handler";
      case "AssignmentPattern":
        return t === "right";
      case "OptionalMemberExpression":
        return t === "property";
      case "OptionalCallExpression":
        return t === "arguments";
      default:
        return !1;
    }
  }
  i(Gle, "isExecutionUncertain");
  function FP(e, t) {
    for (let r = 0; r < t; r++) {
      let s = e[r];
      if (Gle(s.parent.type, s.parentKey))
        return !0;
    }
    return !1;
  }
  i(FP, "isExecutionUncertainInList");
  var LP = Symbol();
  function Xle(e) {
    return j1(this, e, /* @__PURE__ */ new Map());
  }
  i(Xle, "_guessExecutionStatusRelativeTo");
  function j1(e, t, r) {
    let s = {
      this: kP(e),
      target: kP(t)
    };
    if (s.target.node !== s.this.node)
      return Qle(e, s.target, r);
    let n = {
      target: t.getAncestry(),
      this: e.getAncestry()
    };
    if (n.target.includes(e)) return "after";
    if (n.this.includes(t)) return "before";
    let a, o = {
      target: 0,
      this: 0
    };
    for (; !a && o.this < n.this.length; ) {
      let p = n.this[o.this];
      o.target = n.target.indexOf(p), o.target >= 0 ? a = p : o.this++;
    }
    if (!a)
      throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
    if (FP(n.this, o.this - 1) || FP(n.target, o.target - 1))
      return "unknown";
    let l = {
      this: n.this[o.this - 1],
      target: n.target[o.target - 1]
    };
    if (l.target.listKey && l.this.listKey && l.target.container === l.this.container)
      return l.target.key > l.this.key ? "before" : "after";
    let u = Nle[a.type], c = {
      this: u.indexOf(l.this.parentKey),
      target: u.indexOf(l.target.parentKey)
    };
    return c.target > c.this ? "before" : "after";
  }
  i(j1, "_guessExecutionStatusRelativeToCached");
  function zle(e, t, r) {
    if (t.isFunctionDeclaration()) {
      if (t.parentPath.isExportDeclaration())
        return "unknown";
    } else return j1(e, t, r) === "before" ? "before" : "unknown";
    let s = t.scope.getBinding(t.node.id.name);
    if (!s.references) return "before";
    let n = s.referencePaths, a;
    for (let o of n) {
      if (!!o.find((c) => c.node === t.node)) continue;
      if (o.key !== "callee" || !o.parentPath.isCallExpression())
        return "unknown";
      let u = j1(e, o, r);
      if (a && a !== u)
        return "unknown";
      a = u;
    }
    return a;
  }
  i(zle, "_guessExecutionStatusRelativeToDifferentFunctionsInternal");
  function Qle(e, t, r) {
    let s = r.get(e.node), n;
    if (!s)
      r.set(e.node, s = /* @__PURE__ */ new Map());
    else if (n = s.get(t.node))
      return n === LP ? "unknown" : n;
    s.set(t.node, LP);
    let a = zle(e, t, r);
    return s.set(t.node, a), a;
  }
  i(Qle, "_guessExecutionStatusRelativeToDifferentFunctionsCached");
  function Zle(e, t) {
    return MP.call(this, e, t) || this;
  }
  i(Zle, "resolve");
  function MP(e, t) {
    var r;
    if (!((r = t) != null && r.includes(this)))
      if (t = t || [], t.push(this), this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier())
          return this.get("init").resolve(e, t);
      } else if (this.isReferencedIdentifier()) {
        let s = this.scope.getBinding(this.node.name);
        if (!s || !s.constant || s.kind === "module") return;
        if (s.path !== this) {
          let n = s.path.resolve(e, t);
          return this.find((a) => a.node === n.node) ? void 0 : n;
        }
      } else {
        if (this.isTypeCastExpression())
          return this.get("expression").resolve(e, t);
        if (e && this.isMemberExpression()) {
          let s = this.toComputedKey();
          if (!Fle(s)) return;
          let n = s.value, a = this.get("object").resolve(e, t);
          if (a.isObjectExpression()) {
            let o = a.get("properties");
            for (let l of o) {
              if (!l.isProperty()) continue;
              let u = l.get("key"), c = l.isnt("computed") && u.isIdentifier({
                name: n
              });
              if (c = c || u.isLiteral({
                value: n
              }), c) return l.get("value").resolve(e, t);
            }
          } else if (a.isArrayExpression() && !isNaN(+n)) {
            let l = a.get("elements")[n];
            if (l) return l.resolve(e, t);
          }
        }
      }
  }
  i(MP, "_resolve");
  function eue() {
    if (this.isIdentifier()) {
      let e = this.scope.getBinding(this.node.name);
      return e ? e.constant : !1;
    }
    if (this.isLiteral())
      return this.isRegExpLiteral() ? !1 : this.isTemplateLiteral() ? this.get("expressions").every((e) => e.isConstantExpression()) : !0;
    if (this.isUnaryExpression())
      return this.node.operator !== "void" ? !1 : this.get("argument").isConstantExpression();
    if (this.isBinaryExpression()) {
      let {
        operator: e
      } = this.node;
      return e !== "in" && e !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }
    return this.isMemberExpression() ? !this.node.computed && this.get("object").isIdentifier({
      name: "Symbol"
    }) && !this.scope.hasBinding("Symbol", {
      noGlobals: !0
    }) : this.isCallExpression() ? this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding(
    "Symbol", {
      noGlobals: !0
    }) && this.get("arguments")[0].isStringLiteral() : !1;
  }
  i(eue, "isConstantExpression");
  function tue() {
    return !!(this.isProgram() ? this : this.parentPath).find((r) => {
      if (r.isProgram({
        sourceType: "module"
      }) || r.isClass()) return !0;
      if (r.isArrowFunctionExpression() && !r.get("body").isBlockStatement())
        return !1;
      let s;
      if (r.isFunction())
        s = r.node.body;
      else if (r.isProgram())
        s = r.node;
      else
        return !1;
      for (let n of s.directives)
        if (n.value.value === "use strict")
          return !0;
      return !1;
    });
  }
  i(tue, "isInStrictMode");
});

// ../node_modules/@babel/traverse/lib/path/family.js
var KP = D((St) => {
  "use strict";
  Object.defineProperty(St, "__esModule", {
    value: !0
  });
  St._getKey = $P;
  St._getPattern = VP;
  St.get = gue;
  St.getAllNextSiblings = yue;
  St.getAllPrevSiblings = bue;
  St.getAssignmentIdentifiers = Tue;
  St.getBindingIdentifierPaths = Sue;
  St.getBindingIdentifiers = xue;
  St.getCompletionRecords = fue;
  St.getNextSibling = mue;
  St.getOpposite = uue;
  St.getOuterBindingIdentifierPaths = vue;
  St.getOuterBindingIdentifiers = Eue;
  St.getPrevSibling = hue;
  St.getSibling = due;
  var R1 = vs(), rue = ce(), {
    getAssignmentIdentifiers: sue,
    getBindingIdentifiers: UP,
    getOuterBindingIdentifiers: nue,
    numericLiteral: iue,
    unaryExpression: aue
  } = rue, q1 = 0, Eo = 1;
  function oue(e) {
    return {
      type: q1,
      path: e
    };
  }
  i(oue, "NormalCompletion");
  function lue(e) {
    return {
      type: Eo,
      path: e
    };
  }
  i(lue, "BreakCompletion");
  function uue() {
    return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
  }
  i(uue, "getOpposite");
  function Ui(e, t, r) {
    return e && t.push(...$i(e, r)), t;
  }
  i(Ui, "addCompletionRecords");
  function cue(e, t, r) {
    let s = [];
    for (let n = 0; n < e.length; n++) {
      let a = e[n], o = $i(a, r), l = [], u = [];
      for (let c of o)
        c.type === q1 && l.push(c), c.type === Eo && u.push(c);
      l.length && (s = l), t.push(...u);
    }
    return t.push(...s), t;
  }
  i(cue, "completionRecordForSwitch");
  function pue(e) {
    e.forEach((t) => {
      t.type = Eo;
    });
  }
  i(pue, "normalCompletionToBreak");
  function M1(e, t) {
    e.forEach((r) => {
      r.path.isBreakStatement({
        label: null
      }) && (t ? r.path.replaceWith(aue("void", iue(0))) : r.path.remove());
    });
  }
  i(M1, "replaceBreakStatementInBreakCompletion");
  function qP(e, t) {
    let r = [];
    if (t.canHaveBreak) {
      let s = [];
      for (let n = 0; n < e.length; n++) {
        let a = e[n], o = Object.assign({}, t, {
          inCaseClause: !1
        });
        a.isBlockStatement() && (t.inCaseClause || t.shouldPopulateBreak) ? o.shouldPopulateBreak = !0 : o.shouldPopulateBreak = !1;
        let l = $i(a, o);
        if (l.length > 0 && l.every((u) => u.type === Eo)) {
          s.length > 0 && l.every((u) => u.path.isBreakStatement({
            label: null
          })) ? (pue(s), r.push(...s), s.some((u) => u.path.isDeclaration()) && (r.push(...l), t.shouldPreserveBreak || M1(l, !0)), t.shouldPreserveBreak ||
          M1(l, !1)) : (r.push(...l), !t.shouldPopulateBreak && !t.shouldPreserveBreak && M1(l, !0));
          break;
        }
        if (n === e.length - 1)
          r.push(...l);
        else {
          s = [];
          for (let u = 0; u < l.length; u++) {
            let c = l[u];
            c.type === Eo && r.push(c), c.type === q1 && s.push(c);
          }
        }
      }
    } else if (e.length)
      for (let s = e.length - 1; s >= 0; s--) {
        let n = $i(e[s], t);
        if (n.length > 1 || n.length === 1 && !n[0].path.isVariableDeclaration() && !n[0].path.isEmptyStatement()) {
          r.push(...n);
          break;
        }
      }
    return r;
  }
  i(qP, "getStatementListCompletion");
  function $i(e, t) {
    let r = [];
    if (e.isIfStatement())
      r = Ui(e.get("consequent"), r, t), r = Ui(e.get("alternate"), r, t);
    else {
      if (e.isDoExpression() || e.isFor() || e.isWhile() || e.isLabeledStatement())
        return Ui(e.get("body"), r, t);
      if (e.isProgram() || e.isBlockStatement())
        return qP(e.get("body"), t);
      if (e.isFunction())
        return $i(e.get("body"), t);
      if (e.isTryStatement())
        r = Ui(e.get("block"), r, t), r = Ui(e.get("handler"), r, t);
      else {
        if (e.isCatchClause())
          return Ui(e.get("body"), r, t);
        if (e.isSwitchStatement())
          return cue(e.get("cases"), r, t);
        if (e.isSwitchCase())
          return qP(e.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0,
            shouldPreserveBreak: t.shouldPreserveBreak
          });
        e.isBreakStatement() ? r.push(lue(e)) : r.push(oue(e));
      }
    }
    return r;
  }
  i($i, "_getCompletionRecords");
  function fue(e = !1) {
    return $i(this, {
      canHaveBreak: !1,
      shouldPopulateBreak: !1,
      inCaseClause: !1,
      shouldPreserveBreak: e
    }).map((r) => r.path);
  }
  i(fue, "getCompletionRecords");
  function due(e) {
    return R1.default.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: e
    }).setContext(this.context);
  }
  i(due, "getSibling");
  function hue() {
    return this.getSibling(this.key - 1);
  }
  i(hue, "getPrevSibling");
  function mue() {
    return this.getSibling(this.key + 1);
  }
  i(mue, "getNextSibling");
  function yue() {
    let e = this.key, t = this.getSibling(++e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(++e);
    return r;
  }
  i(yue, "getAllNextSiblings");
  function bue() {
    let e = this.key, t = this.getSibling(--e), r = [];
    for (; t.node; )
      r.push(t), t = this.getSibling(--e);
    return r;
  }
  i(bue, "getAllPrevSiblings");
  function gue(e, t = !0) {
    t === !0 && (t = this.context);
    let r = e.split(".");
    return r.length === 1 ? $P.call(this, e, t) : VP.call(this, r, t);
  }
  i(gue, "get");
  function $P(e, t) {
    let r = this.node, s = r[e];
    return Array.isArray(s) ? s.map((n, a) => R1.default.get({
      listKey: e,
      parentPath: this,
      parent: r,
      container: s,
      key: a
    }).setContext(t)) : R1.default.get({
      parentPath: this,
      parent: r,
      container: r,
      key: e
    }).setContext(t);
  }
  i($P, "_getKey");
  function VP(e, t) {
    let r = this;
    for (let s of e)
      s === "." ? r = r.parentPath : Array.isArray(r) ? r = r[s] : r = r.get(s, t);
    return r;
  }
  i(VP, "_getPattern");
  function Tue() {
    return sue(this.node);
  }
  i(Tue, "getAssignmentIdentifiers");
  function xue(e) {
    return UP(this.node, e);
  }
  i(xue, "getBindingIdentifiers");
  function Eue(e) {
    return nue(this.node, e);
  }
  i(Eue, "getOuterBindingIdentifiers");
  function Sue(e = !1, t = !1) {
    let s = [this], n = /* @__PURE__ */ Object.create(null);
    for (; s.length; ) {
      let a = s.shift();
      if (!a || !a.node) continue;
      let o = UP.keys[a.node.type];
      if (a.isIdentifier()) {
        e ? (n[a.node.name] = n[a.node.name] || []).push(a) : n[a.node.name] = a;
        continue;
      }
      if (a.isExportDeclaration()) {
        let l = a.get("declaration");
        l.isDeclaration() && s.push(l);
        continue;
      }
      if (t) {
        if (a.isFunctionDeclaration()) {
          s.push(a.get("id"));
          continue;
        }
        if (a.isFunctionExpression())
          continue;
      }
      if (o)
        for (let l = 0; l < o.length; l++) {
          let u = o[l], c = a.get(u);
          Array.isArray(c) ? s.push(...c) : c.node && s.push(c);
        }
    }
    return n;
  }
  i(Sue, "getBindingIdentifierPaths");
  function vue(e = !1) {
    return this.getBindingIdentifierPaths(e, !0);
  }
  i(vue, "getOuterBindingIdentifierPaths");
});

// ../node_modules/@babel/traverse/lib/path/comments.js
var YP = D((So) => {
  "use strict";
  Object.defineProperty(So, "__esModule", {
    value: !0
  });
  So.addComment = Due;
  So.addComments = _ue;
  So.shareCommentsWithSiblings = wue;
  var Pue = ce(), {
    addComment: Aue,
    addComments: Cue
  } = Pue;
  function wue() {
    if (typeof this.key == "string") return;
    let e = this.node;
    if (!e) return;
    let t = e.trailingComments, r = e.leadingComments;
    if (!t && !r) return;
    let s = this.getSibling(this.key - 1), n = this.getSibling(this.key + 1), a = !!s.node, o = !!n.node;
    a && (r && s.addComments("trailing", WP(r, s.node.trailingComments)), t && !o && s.addComments("trailing", t)), o && (t && n.addComments(
    "leading", WP(t, n.node.leadingComments)), r && !a && n.addComments("leading", r));
  }
  i(wue, "shareCommentsWithSiblings");
  function WP(e, t) {
    if (!(t != null && t.length)) return e;
    let r = new Set(t);
    return e.filter((s) => !r.has(s));
  }
  i(WP, "removeIfExisting");
  function Due(e, t, r) {
    Aue(this.node, e, t, r);
  }
  i(Due, "addComment");
  function _ue(e, t) {
    Cue(this.node, e, t);
  }
  i(_ue, "addComments");
});

// ../node_modules/@babel/traverse/lib/path/index.js
var vs = D((us) => {
  "use strict";
  Object.defineProperty(us, "__esModule", {
    value: !0
  });
  us.default = us.SHOULD_STOP = us.SHOULD_SKIP = us.REMOVED = void 0;
  var Iue = ph(), Oue = Fn(), Nue = nt(), Bue = Ph(), GP = ce(), Yu = GP, kue = Mn(), Fue = bo(), os = Bv(), Vi = Zv(), Ki = E1(), HP = AP(),
  Jn = BP(), it = RP(), XP = br(), Ze = XP, Wi = qu(), ls = Uu(), Jt = KP(), U1 = YP(), Lue = yh(), {
    validate: jue
  } = GP, JP = Oue("babel"), x8e = us.REMOVED = 1, E8e = us.SHOULD_STOP = 2, S8e = us.SHOULD_SKIP = 4, As = us.default = class zP {
    static {
      i(this, "NodePath");
    }
    constructor(t, r) {
      this.contexts = [], this.state = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.
      listKey = null, this.key = null, this.node = null, this.type = null, this._store = null, this.parent = r, this.hub = t, this.data = null,
      this.context = null, this.scope = null;
    }
    get removed() {
      return (this._traverseFlags & 1) > 0;
    }
    set removed(t) {
      t ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
    }
    get shouldStop() {
      return (this._traverseFlags & 2) > 0;
    }
    set shouldStop(t) {
      t ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
    }
    get shouldSkip() {
      return (this._traverseFlags & 4) > 0;
    }
    set shouldSkip(t) {
      t ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
    }
    static get({
      hub: t,
      parentPath: r,
      parent: s,
      container: n,
      listKey: a,
      key: o
    }) {
      if (!t && r && (t = r.hub), !s)
        throw new Error("To get a node path the parent needs to exist");
      let l = n[o], u = kue.getOrCreateCachedPaths(s, r), c = u.get(l);
      return c || (c = new zP(t, s), l && u.set(l, c)), XP.setup.call(c, r, n, a, o), c;
    }
    getScope(t) {
      return this.isScope() ? new Bue.default(this) : t;
    }
    setData(t, r) {
      return this.data == null && (this.data = /* @__PURE__ */ Object.create(null)), this.data[t] = r;
    }
    getData(t, r) {
      this.data == null && (this.data = /* @__PURE__ */ Object.create(null));
      let s = this.data[t];
      return s === void 0 && r !== void 0 && (s = this.data[t] = r), s;
    }
    hasNode() {
      return this.node != null;
    }
    buildCodeFrameError(t, r = SyntaxError) {
      return this.hub.buildError(this.node, t, r);
    }
    traverse(t, r) {
      (0, Nue.default)(this.node, t, this.scope, r, this);
    }
    set(t, r) {
      jue(this.node, t, r), this.node[t] = r;
    }
    getPathLocation() {
      let t = [], r = this;
      do {
        let s = r.key;
        r.inList && (s = `${r.listKey}[${s}]`), t.unshift(s);
      } while (r = r.parentPath);
      return t.join(".");
    }
    debug(t) {
      JP.enabled && JP(`${this.getPathLocation()} ${this.type}: ${t}`);
    }
    toString() {
      return (0, Fue.default)(this.node).code;
    }
    get inList() {
      return !!this.listKey;
    }
    set inList(t) {
      t || (this.listKey = null);
    }
    get parentKey() {
      return this.listKey || this.key;
    }
  }, Mue = {
    findParent: os.findParent,
    find: os.find,
    getFunctionParent: os.getFunctionParent,
    getStatementParent: os.getStatementParent,
    getEarliestCommonAncestorFrom: os.getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: os.getDeepestCommonAncestorFrom,
    getAncestry: os.getAncestry,
    isAncestor: os.isAncestor,
    isDescendant: os.isDescendant,
    inType: os.inType,
    getTypeAnnotation: Vi.getTypeAnnotation,
    isBaseType: Vi.isBaseType,
    couldBeBaseType: Vi.couldBeBaseType,
    baseTypeStrictlyMatches: Vi.baseTypeStrictlyMatches,
    isGenericType: Vi.isGenericType,
    replaceWithMultiple: Ki.replaceWithMultiple,
    replaceWithSourceString: Ki.replaceWithSourceString,
    replaceWith: Ki.replaceWith,
    replaceExpressionWithStatements: Ki.replaceExpressionWithStatements,
    replaceInline: Ki.replaceInline,
    evaluateTruthy: HP.evaluateTruthy,
    evaluate: HP.evaluate,
    toComputedKey: Jn.toComputedKey,
    ensureBlock: Jn.ensureBlock,
    unwrapFunctionEnvironment: Jn.unwrapFunctionEnvironment,
    arrowFunctionToExpression: Jn.arrowFunctionToExpression,
    splitExportDeclaration: Jn.splitExportDeclaration,
    ensureFunctionName: Jn.ensureFunctionName,
    matchesPattern: it.matchesPattern,
    isStatic: it.isStatic,
    isNodeType: it.isNodeType,
    canHaveVariableDeclarationOrExpression: it.canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: it.canSwapBetweenExpressionAndStatement,
    isCompletionRecord: it.isCompletionRecord,
    isStatementOrBlock: it.isStatementOrBlock,
    referencesImport: it.referencesImport,
    getSource: it.getSource,
    willIMaybeExecuteBefore: it.willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: it._guessExecutionStatusRelativeTo,
    resolve: it.resolve,
    isConstantExpression: it.isConstantExpression,
    isInStrictMode: it.isInStrictMode,
    isDenylisted: Ze.isDenylisted,
    visit: Ze.visit,
    skip: Ze.skip,
    skipKey: Ze.skipKey,
    stop: Ze.stop,
    setContext: Ze.setContext,
    requeue: Ze.requeue,
    requeueComputedKeyAndDecorators: Ze.requeueComputedKeyAndDecorators,
    remove: Wi.remove,
    insertBefore: ls.insertBefore,
    insertAfter: ls.insertAfter,
    unshiftContainer: ls.unshiftContainer,
    pushContainer: ls.pushContainer,
    getOpposite: Jt.getOpposite,
    getCompletionRecords: Jt.getCompletionRecords,
    getSibling: Jt.getSibling,
    getPrevSibling: Jt.getPrevSibling,
    getNextSibling: Jt.getNextSibling,
    getAllNextSiblings: Jt.getAllNextSiblings,
    getAllPrevSiblings: Jt.getAllPrevSiblings,
    get: Jt.get,
    getAssignmentIdentifiers: Jt.getAssignmentIdentifiers,
    getBindingIdentifiers: Jt.getBindingIdentifiers,
    getOuterBindingIdentifiers: Jt.getOuterBindingIdentifiers,
    getBindingIdentifierPaths: Jt.getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: Jt.getOuterBindingIdentifierPaths,
    shareCommentsWithSiblings: U1.shareCommentsWithSiblings,
    addComment: U1.addComment,
    addComments: U1.addComments
  };
  Object.assign(As.prototype, Mue);
  As.prototype.arrowFunctionToShadowed = Jn.arrowFunctionToShadowed, Object.assign(As.prototype, {
    has: it.has,
    is: it.is,
    isnt: it.isnt,
    equals: it.equals,
    hoist: ls.hoist,
    updateSiblingKeys: ls.updateSiblingKeys,
    call: Ze.call,
    isBlacklisted: Ze.isBlacklisted,
    setScope: Ze.setScope,
    resync: Ze.resync,
    popContext: Ze.popContext,
    pushContext: Ze.pushContext,
    setup: Ze.setup,
    setKey: Ze.setKey
  });
  As.prototype._guessExecutionStatusRelativeToDifferentFunctions = it._guessExecutionStatusRelativeTo, As.prototype._guessExecutionStatusRelativeToDifferentFunctions =
  it._guessExecutionStatusRelativeTo, Object.assign(As.prototype, {
    _getTypeAnnotation: Vi._getTypeAnnotation,
    _replaceWith: Ki._replaceWith,
    _resolve: it._resolve,
    _call: Ze._call,
    _resyncParent: Ze._resyncParent,
    _resyncKey: Ze._resyncKey,
    _resyncList: Ze._resyncList,
    _resyncRemoved: Ze._resyncRemoved,
    _getQueueContexts: Ze._getQueueContexts,
    _removeFromScope: Wi._removeFromScope,
    _callRemovalHooks: Wi._callRemovalHooks,
    _remove: Wi._remove,
    _markRemoved: Wi._markRemoved,
    _assertUnremoved: Wi._assertUnremoved,
    _containerInsert: ls._containerInsert,
    _containerInsertBefore: ls._containerInsertBefore,
    _containerInsertAfter: ls._containerInsertAfter,
    _verifyNodeList: ls._verifyNodeList,
    _getKey: Jt._getKey,
    _getPattern: Jt._getPattern
  });
  for (let e of Yu.TYPES) {
    let t = `is${e}`, r = Yu[t];
    As.prototype[t] = function(s) {
      return r(this.node, s);
    }, As.prototype[`assert${e}`] = function(s) {
      if (!r(this.node, s))
        throw new TypeError(`Expected node path of type ${e}`);
    };
  }
  Object.assign(As.prototype, Lue);
  for (let e of Object.keys(Iue))
    e[0] !== "_" && (Yu.TYPES.includes(e) || Yu.TYPES.push(e));
});

// ../node_modules/@babel/traverse/lib/context.js
var QP = D((Hu) => {
  "use strict";
  Object.defineProperty(Hu, "__esModule", {
    value: !0
  });
  Hu.default = void 0;
  var Rue = vs(), que = ce(), $1 = br(), {
    VISITOR_KEYS: Uue
  } = que, V1 = class {
    static {
      i(this, "TraversalContext");
    }
    constructor(t, r, s, n) {
      this.queue = null, this.priorityQueue = null, this.parentPath = n, this.scope = t, this.state = s, this.opts = r;
    }
    shouldVisit(t) {
      let r = this.opts;
      if (r.enter || r.exit || r[t.type]) return !0;
      let s = Uue[t.type];
      if (!(s != null && s.length)) return !1;
      for (let n of s)
        if (t[n])
          return !0;
      return !1;
    }
    create(t, r, s, n) {
      return Rue.default.get({
        parentPath: this.parentPath,
        parent: t,
        container: r,
        key: s,
        listKey: n
      });
    }
    maybeQueue(t, r) {
      this.queue && (r ? this.queue.push(t) : this.priorityQueue.push(t));
    }
    visitMultiple(t, r, s) {
      if (t.length === 0) return !1;
      let n = [];
      for (let a = 0; a < t.length; a++) {
        let o = t[a];
        o && this.shouldVisit(o) && n.push(this.create(r, t, a, s));
      }
      return this.visitQueue(n);
    }
    visitSingle(t, r) {
      return this.shouldVisit(t[r]) ? this.visitQueue([this.create(t, t, r)]) : !1;
    }
    visitQueue(t) {
      this.queue = t, this.priorityQueue = [];
      let r = /* @__PURE__ */ new WeakSet(), s = !1, n = 0;
      for (; n < t.length; ) {
        let a = t[n];
        if (n++, $1.resync.call(a), (a.contexts.length === 0 || a.contexts[a.contexts.length - 1] !== this) && $1.pushContext.call(a, this),
        a.key === null) continue;
        let {
          node: o
        } = a;
        if (!r.has(o)) {
          if (o && r.add(o), a.visit()) {
            s = !0;
            break;
          }
          if (this.priorityQueue.length && (s = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = t, s))
            break;
        }
      }
      for (let a = 0; a < n; a++)
        $1.popContext.call(t[a]);
      return this.queue = null, s;
    }
    visit(t, r) {
      let s = t[r];
      return s ? Array.isArray(s) ? this.visitMultiple(s, t, r) : this.visitSingle(t, r) : !1;
    }
  };
  Hu.default = V1;
});

// ../node_modules/@babel/traverse/lib/traverse-node.js
var cu = D((K1) => {
  "use strict";
  Object.defineProperty(K1, "__esModule", {
    value: !0
  });
  K1.traverseNode = Wue;
  var $ue = QP(), w8e = vs(), Vue = ce(), D8e = br(), {
    VISITOR_KEYS: Kue
  } = Vue;
  function Wue(e, t, r, s, n, a, o) {
    let l = Kue[e.type];
    if (!l) return !1;
    let u = new $ue.default(r, t, s, n);
    if (o)
      return a != null && a[n.parentKey] ? !1 : u.visitQueue([n]);
    for (let c of l)
      if (!(a != null && a[c]) && u.visit(e, c))
        return !0;
    return !1;
  }
  i(Wue, "traverseNode");
});

// ../node_modules/@babel/traverse/lib/path/context.js
var br = D((Je) => {
  "use strict";
  Object.defineProperty(Je, "__esModule", {
    value: !0
  });
  Je._call = Y1;
  Je._getQueueContexts = oce;
  Je._resyncKey = nA;
  Je._resyncList = iA;
  Je._resyncParent = sA;
  Je._resyncRemoved = tce;
  Je.call = W1;
  Je.isDenylisted = tA;
  Je.popContext = rce;
  Je.pushContext = sce;
  Je.requeue = ice;
  Je.requeueComputedKeyAndDecorators = ace;
  Je.resync = ece;
  Je.setContext = Zue;
  Je.setKey = Ju;
  Je.setScope = rA;
  Je.setup = nce;
  Je.skip = Xue;
  Je.skipKey = zue;
  Je.stop = Que;
  Je.visit = Gue;
  var Yue = cu(), ZP = vs(), Hue = qu(), Jue = ce();
  function W1(e) {
    let t = this.opts;
    if (this.debug(e), this.node && Y1.call(this, t[e]))
      return !0;
    if (this.node) {
      var r;
      return Y1.call(this, (r = t[this.node.type]) == null ? void 0 : r[e]);
    }
    return !1;
  }
  i(W1, "call");
  function Y1(e) {
    if (!e) return !1;
    for (let t of e) {
      if (!t) continue;
      let r = this.node;
      if (!r) return !0;
      let s = t.call(this.state, this, this.state);
      if (s && typeof s == "object" && typeof s.then == "function")
        throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not suppo\
rt. If you're using a published plugin, you may need to upgrade your @babel/core version.");
      if (s)
        throw new Error(`Unexpected return value from visitor method ${t}`);
      if (this.node !== r || this._traverseFlags > 0) return !0;
    }
    return !1;
  }
  i(Y1, "_call");
  function tA() {
    var e;
    let t = (e = this.opts.denylist) != null ? e : this.opts.blacklist;
    return t?.includes(this.node.type);
  }
  i(tA, "isDenylisted");
  Je.isBlacklisted = tA;
  function eA(e, t) {
    e.context !== t && (e.context = t, e.state = t.state, e.opts = t.opts);
  }
  i(eA, "restoreContext");
  function Gue() {
    var e, t;
    if (!this.node || this.isDenylisted() || (e = (t = this.opts).shouldSkip) != null && e.call(t, this))
      return !1;
    let r = this.context;
    return this.shouldSkip || W1.call(this, "enter") ? (this.debug("Skip..."), this.shouldStop) : (eA(this, r), this.debug("Recursing into..\
."), this.shouldStop = (0, Yue.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys), eA(this, r), W1.call(this, "\
exit"), this.shouldStop);
  }
  i(Gue, "visit");
  function Xue() {
    this.shouldSkip = !0;
  }
  i(Xue, "skip");
  function zue(e) {
    this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[e] = !0;
  }
  i(zue, "skipKey");
  function Que() {
    this._traverseFlags |= ZP.SHOULD_SKIP | ZP.SHOULD_STOP;
  }
  i(Que, "stop");
  function rA() {
    var e, t;
    if ((e = this.opts) != null && e.noScope) return;
    let r = this.parentPath;
    ((this.key === "key" || this.listKey === "decorators") && r.isMethod() || this.key === "discriminant" && r.isSwitchStatement()) && (r = r.
    parentPath);
    let s;
    for (; r && !s; ) {
      var n;
      if ((n = r.opts) != null && n.noScope) return;
      s = r.scope, r = r.parentPath;
    }
    this.scope = this.getScope(s), (t = this.scope) == null || t.init();
  }
  i(rA, "setScope");
  function Zue(e) {
    return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, e && (this.context = e, this.state = e.state, this.opts =
    e.opts), rA.call(this), this;
  }
  i(Zue, "setContext");
  function ece() {
    this.removed || (sA.call(this), iA.call(this), nA.call(this));
  }
  i(ece, "resync");
  function sA() {
    this.parentPath && (this.parent = this.parentPath.node);
  }
  i(sA, "_resyncParent");
  function nA() {
    if (this.container && this.node !== this.container[this.key]) {
      if (Array.isArray(this.container)) {
        for (let e = 0; e < this.container.length; e++)
          if (this.container[e] === this.node) {
            Ju.call(this, e);
            return;
          }
      } else
        for (let e of Object.keys(this.container))
          if (this.container[e] === this.node) {
            Ju.call(this, e);
            return;
          }
      this.key = null;
    }
  }
  i(nA, "_resyncKey");
  function iA() {
    if (!this.parent || !this.inList) return;
    let e = this.parent[this.listKey];
    this.container !== e && (this.container = e || null);
  }
  i(iA, "_resyncList");
  function tce() {
    (this.key == null || !this.container || this.container[this.key] !== this.node) && Hue._markRemoved.call(this);
  }
  i(tce, "_resyncRemoved");
  function rce() {
    this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
  }
  i(rce, "popContext");
  function sce(e) {
    this.contexts.push(e), this.setContext(e);
  }
  i(sce, "pushContext");
  function nce(e, t, r, s) {
    this.listKey = r, this.container = t, this.parentPath = e || this.parentPath, Ju.call(this, s);
  }
  i(nce, "setup");
  function Ju(e) {
    var t;
    this.key = e, this.node = this.container[this.key], this.type = (t = this.node) == null ? void 0 : t.type;
  }
  i(Ju, "setKey");
  function ice(e = this) {
    if (e.removed) return;
    let t = this.contexts;
    for (let r of t)
      r.maybeQueue(e);
  }
  i(ice, "requeue");
  function ace() {
    let {
      context: e,
      node: t
    } = this;
    if (!Jue.isPrivate(t) && t.computed && e.maybeQueue(this.get("key")), t.decorators)
      for (let r of this.get("decorators"))
        e.maybeQueue(r);
  }
  i(ace, "requeueComputedKeyAndDecorators");
  function oce() {
    let e = this, t = this.contexts;
    for (; !t.length && (e = e.parentPath, !!e); )
      t = e.contexts;
    return t;
  }
  i(oce, "_getQueueContexts");
});

// ../node_modules/@babel/traverse/lib/hub.js
var aA = D((Gu) => {
  "use strict";
  Object.defineProperty(Gu, "__esModule", {
    value: !0
  });
  Gu.default = void 0;
  var H1 = class {
    static {
      i(this, "Hub");
    }
    getCode() {
    }
    getScope() {
    }
    addHelper() {
      throw new Error("Helpers are not supported by the default hub.");
    }
    buildError(t, r, s = TypeError) {
      return new s(r);
    }
  };
  Gu.default = H1;
});

// ../node_modules/@babel/traverse/lib/index.js
var nt = D((Cs) => {
  "use strict";
  Object.defineProperty(Cs, "__esModule", {
    value: !0
  });
  Object.defineProperty(Cs, "Hub", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fce.default;
    }, "get")
  });
  Object.defineProperty(Cs, "NodePath", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return cce.default;
    }, "get")
  });
  Object.defineProperty(Cs, "Scope", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return pce.default;
    }, "get")
  });
  Cs.visitors = Cs.default = void 0;
  br();
  var Po = no();
  Cs.visitors = Po;
  var lce = ce(), uce = Mn(), oA = cu(), cce = vs(), pce = Ph(), fce = aA(), {
    VISITOR_KEYS: dce,
    removeProperties: hce,
    traverseFast: vo
  } = lce;
  function $r(e, t = {}, r, s, n, a) {
    if (e) {
      if (!t.noScope && !r && e.type !== "Program" && e.type !== "File")
        throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e.
        type} node without passing scope and parentPath.`);
      if (!n && a)
        throw new Error("visitSelf can only be used when providing a NodePath.");
      dce[e.type] && (Po.explode(t), (0, oA.traverseNode)(e, t, r, s, n, void 0, a));
    }
  }
  i($r, "traverse");
  var F8e = Cs.default = $r;
  $r.visitors = Po;
  $r.verify = Po.verify;
  $r.explode = Po.explode;
  $r.cheap = function(e, t) {
    vo(e, t);
  };
  $r.node = function(e, t, r, s, n, a) {
    (0, oA.traverseNode)(e, t, r, s, n, a);
  };
  $r.clearNode = function(e, t) {
    hce(e, t);
  };
  $r.removeProperties = function(e, t) {
    return vo(e, $r.clearNode, t), e;
  };
  $r.hasType = function(e, t, r) {
    return r != null && r.includes(e.type) ? !1 : e.type === t ? !0 : vo(e, function(s) {
      if (r != null && r.includes(s.type))
        return vo.skip;
      if (s.type === t)
        return vo.stop;
    });
  };
  $r.cache = uce;
});

// ../node_modules/@babel/helper-module-imports/lib/import-builder.js
var cA = D((zu) => {
  "use strict";
  Object.defineProperty(zu, "__esModule", {
    value: !0
  });
  zu.default = void 0;
  var Vr = z("assert"), mce = ce(), {
    callExpression: J1,
    cloneNode: Xu,
    expressionStatement: lA,
    identifier: Ao,
    importDeclaration: yce,
    importDefaultSpecifier: bce,
    importNamespaceSpecifier: gce,
    importSpecifier: Tce,
    memberExpression: G1,
    stringLiteral: uA,
    variableDeclaration: xce,
    variableDeclarator: Ece
  } = mce, X1 = class {
    static {
      i(this, "ImportBuilder");
    }
    constructor(t, r, s) {
      this._statements = [], this._resultName = null, this._importedSource = void 0, this._scope = r, this._hub = s, this._importedSource = t;
    }
    done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    }
    import() {
      return this._statements.push(yce([], uA(this._importedSource))), this;
    }
    require() {
      return this._statements.push(lA(J1(Ao("require"), [uA(this._importedSource)]))), this;
    }
    namespace(t = "namespace") {
      let r = this._scope.generateUidIdentifier(t), s = this._statements[this._statements.length - 1];
      return Vr(s.type === "ImportDeclaration"), Vr(s.specifiers.length === 0), s.specifiers = [gce(r)], this._resultName = Xu(r), this;
    }
    default(t) {
      let r = this._scope.generateUidIdentifier(t), s = this._statements[this._statements.length - 1];
      return Vr(s.type === "ImportDeclaration"), Vr(s.specifiers.length === 0), s.specifiers = [bce(r)], this._resultName = Xu(r), this;
    }
    named(t, r) {
      if (r === "default") return this.default(t);
      let s = this._scope.generateUidIdentifier(t), n = this._statements[this._statements.length - 1];
      return Vr(n.type === "ImportDeclaration"), Vr(n.specifiers.length === 0), n.specifiers = [Tce(s, Ao(r))], this._resultName = Xu(s), this;
    }
    var(t) {
      let r = this._scope.generateUidIdentifier(t), s = this._statements[this._statements.length - 1];
      return s.type !== "ExpressionStatement" && (Vr(this._resultName), s = lA(this._resultName), this._statements.push(s)), this._statements[this.
      _statements.length - 1] = xce("var", [Ece(r, s.expression)]), this._resultName = Xu(r), this;
    }
    defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    }
    wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    }
    _interop(t) {
      let r = this._statements[this._statements.length - 1];
      return r.type === "ExpressionStatement" ? r.expression = J1(t, [r.expression]) : r.type === "VariableDeclaration" ? (Vr(r.declarations.
      length === 1), r.declarations[0].init = J1(t, [r.declarations[0].init])) : Vr.fail("Unexpected type."), this;
    }
    prop(t) {
      let r = this._statements[this._statements.length - 1];
      return r.type === "ExpressionStatement" ? r.expression = G1(r.expression, Ao(t)) : r.type === "VariableDeclaration" ? (Vr(r.declarations.
      length === 1), r.declarations[0].init = G1(r.declarations[0].init, Ao(t))) : Vr.fail("Unexpected type:" + r.type), this;
    }
    read(t) {
      this._resultName = G1(this._resultName, Ao(t));
    }
  };
  zu.default = X1;
});

// ../node_modules/@babel/helper-module-imports/lib/is-module.js
var Q1 = D((z1) => {
  "use strict";
  Object.defineProperty(z1, "__esModule", {
    value: !0
  });
  z1.default = Sce;
  function Sce(e) {
    return e.node.sourceType === "module";
  }
  i(Sce, "isModule");
});

// ../node_modules/@babel/helper-module-imports/lib/import-injector.js
var yA = D((Zu) => {
  "use strict";
  Object.defineProperty(Zu, "__esModule", {
    value: !0
  });
  Zu.default = void 0;
  var pA = z("assert"), vce = ce(), Pce = cA(), Ace = Q1(), {
    identifier: Cce,
    importSpecifier: wce,
    numericLiteral: Dce,
    sequenceExpression: _ce,
    isImportDeclaration: fA
  } = vce, Z1 = class {
    static {
      i(this, "ImportInjector");
    }
    constructor(t, r, s) {
      this._defaultOpts = {
        importedSource: null,
        importedType: "commonjs",
        importedInterop: "babel",
        importingInterop: "babel",
        ensureLiveReference: !1,
        ensureNoContext: !1,
        importPosition: "before"
      };
      let n = t.find((a) => a.isProgram());
      this._programPath = n, this._programScope = n.scope, this._hub = n.hub, this._defaultOpts = this._applyDefaults(r, s, !0);
    }
    addDefault(t, r) {
      return this.addNamed("default", t, r);
    }
    addNamed(t, r, s) {
      return pA(typeof t == "string"), this._generateImport(this._applyDefaults(r, s), t);
    }
    addNamespace(t, r) {
      return this._generateImport(this._applyDefaults(t, r), null);
    }
    addSideEffect(t, r) {
      return this._generateImport(this._applyDefaults(t, r), void 0);
    }
    _applyDefaults(t, r, s = !1) {
      let n;
      return typeof t == "string" ? n = Object.assign({}, this._defaultOpts, {
        importedSource: t
      }, r) : (pA(!r, "Unexpected secondary arguments."), n = Object.assign({}, this._defaultOpts, t)), !s && r && (r.nameHint !== void 0 &&
      (n.nameHint = r.nameHint), r.blockHoist !== void 0 && (n.blockHoist = r.blockHoist)), n;
    }
    _generateImport(t, r) {
      let s = r === "default", n = !!r && !s, a = r === null, {
        importedSource: o,
        importedType: l,
        importedInterop: u,
        importingInterop: c,
        ensureLiveReference: p,
        ensureNoContext: f,
        nameHint: h,
        importPosition: b,
        blockHoist: T
      } = t, d = h || r, g = (0, Ace.default)(this._programPath), E = g && c === "node", _ = g && c === "babel";
      if (b === "after" && !g)
        throw new Error('"importPosition": "after" is only supported in modules');
      let N = new Pce.default(o, this._programScope, this._hub);
      if (l === "es6") {
        if (!E && !_)
          throw new Error("Cannot import an ES6 module from CommonJS");
        N.import(), a ? N.namespace(h || o) : (s || n) && N.named(d, r);
      } else {
        if (l !== "commonjs")
          throw new Error(`Unexpected interopType "${l}"`);
        if (u === "babel")
          if (E) {
            d = d !== "default" ? d : o;
            let U = `${o}$es6Default`;
            N.import(), a ? N.default(U).var(d || o).wildcardInterop() : s ? p ? N.default(U).var(d || o).defaultInterop().read("default") :
            N.default(U).var(d).defaultInterop().prop(r) : n && N.default(U).read(r);
          } else _ ? (N.import(), a ? N.namespace(d || o) : (s || n) && N.named(d, r)) : (N.require(), a ? N.var(d || o).wildcardInterop() :
          (s || n) && p ? s ? (d = d !== "default" ? d : o, N.var(d).read(r), N.defaultInterop()) : N.var(o).read(r) : s ? N.var(d).defaultInterop().
          prop(r) : n && N.var(d).prop(r));
        else if (u === "compiled")
          E ? (N.import(), a ? N.default(d || o) : (s || n) && N.default(o).read(d)) : _ ? (N.import(), a ? N.namespace(d || o) : (s || n) &&
          N.named(d, r)) : (N.require(), a ? N.var(d || o) : (s || n) && (p ? N.var(o).read(d) : N.prop(r).var(d)));
        else if (u === "uncompiled") {
          if (s && p)
            throw new Error("No live reference for commonjs default");
          E ? (N.import(), a ? N.default(d || o) : s ? N.default(d) : n && N.default(o).read(d)) : _ ? (N.import(), a ? N.default(d || o) : s ?
          N.default(d) : n && N.named(d, r)) : (N.require(), a ? N.var(d || o) : s ? N.var(d) : n && (p ? N.var(o).read(d) : N.var(d).prop(r)));
        } else
          throw new Error(`Unknown importedInterop "${u}".`);
      }
      let {
        statements: k,
        resultName: j
      } = N.done();
      return this._insertStatements(k, b, T), (s || n) && f && j.type !== "Identifier" ? _ce([Dce(0), j]) : j;
    }
    _insertStatements(t, r = "before", s = 3) {
      if (r === "after") {
        if (this._insertStatementsAfter(t)) return;
      } else if (this._insertStatementsBefore(t, s)) return;
      this._programPath.unshiftContainer("body", t);
    }
    _insertStatementsBefore(t, r) {
      if (t.length === 1 && fA(t[0]) && Qu(t[0])) {
        let n = this._programPath.get("body").find((a) => a.isImportDeclaration() && Qu(a.node));
        if (n?.node.source.value === t[0].source.value && mA(n.node, t[0]))
          return !0;
      }
      t.forEach((n) => {
        n._blockHoist = r;
      });
      let s = this._programPath.get("body").find((n) => {
        let a = n.node._blockHoist;
        return Number.isFinite(a) && a < 4;
      });
      return s ? (s.insertBefore(t), !0) : !1;
    }
    _insertStatementsAfter(t) {
      let r = new Set(t), s = /* @__PURE__ */ new Map();
      for (let a of t)
        if (fA(a) && Qu(a)) {
          let o = a.source.value;
          s.has(o) || s.set(o, []), s.get(o).push(a);
        }
      let n = null;
      for (let a of this._programPath.get("body"))
        if (a.isImportDeclaration() && Qu(a.node)) {
          n = a;
          let o = a.node.source.value, l = s.get(o);
          if (!l) continue;
          for (let u of l)
            r.has(u) && mA(a.node, u) && r.delete(u);
        }
      return r.size === 0 ? !0 : (n && n.insertAfter(Array.from(r)), !!n);
    }
  };
  Zu.default = Z1;
  function Qu(e) {
    return e.importKind !== "type" && e.importKind !== "typeof";
  }
  i(Qu, "isValueImport");
  function dA(e) {
    return e.specifiers.length === 1 && e.specifiers[0].type === "ImportNamespaceSpecifier" || e.specifiers.length === 2 && e.specifiers[1].
    type === "ImportNamespaceSpecifier";
  }
  i(dA, "hasNamespaceImport");
  function hA(e) {
    return e.specifiers.length > 0 && e.specifiers[0].type === "ImportDefaultSpecifier";
  }
  i(hA, "hasDefaultImport");
  function mA(e, t) {
    return e.specifiers.length ? t.specifiers.length ? dA(e) || dA(t) ? !1 : (hA(t) && (hA(e) ? t.specifiers[0] = wce(t.specifiers[0].local,
    Cce("default")) : e.specifiers.unshift(t.specifiers.shift())), e.specifiers.push(...t.specifiers), !0) : !0 : (e.specifiers = t.specifiers,
    !0);
  }
  i(mA, "maybeAppendImportSpecifiers");
});

// ../node_modules/@babel/helper-module-imports/lib/index.js
var bA = D((on) => {
  "use strict";
  Object.defineProperty(on, "__esModule", {
    value: !0
  });
  Object.defineProperty(on, "ImportInjector", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Co.default;
    }, "get")
  });
  on.addDefault = Oce;
  on.addNamed = Nce;
  on.addNamespace = Bce;
  on.addSideEffect = kce;
  Object.defineProperty(on, "isModule", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ice.default;
    }, "get")
  });
  var Co = yA(), Ice = Q1();
  function Oce(e, t, r) {
    return new Co.default(e).addDefault(t, r);
  }
  i(Oce, "addDefault");
  function Nce(e, t, r, s) {
    return new Co.default(e).addNamed(t, r, s);
  }
  i(Nce, "addNamed");
  function Bce(e, t, r) {
    return new Co.default(e).addNamespace(t, r);
  }
  i(Bce, "addNamespace");
  function kce(e, t, r) {
    return new Co.default(e).addSideEffect(t, r);
  }
  i(kce, "addSideEffect");
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-this.js
var xA = D((em) => {
  "use strict";
  Object.defineProperty(em, "__esModule", {
    value: !0
  });
  em.default = Fce;
  var gA = et(), TA = nt(), ec;
  function Fce(e) {
    ec || (ec = TA.visitors.environmentVisitor({
      ThisExpression(t) {
        t.replaceWith(gA.types.unaryExpression("void", gA.types.numericLiteral(0), !0));
      }
    }), ec.noScope = !0), (0, TA.default)(e.node, ec);
  }
  i(Fce, "rewriteThis");
});

// ../node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js
var EA = D((tm) => {
  "use strict";
  Object.defineProperty(tm, "__esModule", {
    value: !0
  });
  tm.default = jce;
  var pe = et();
  function Lce(e) {
    do
      switch (e.parent.type) {
        case "TSTypeAnnotation":
        case "TSTypeAliasDeclaration":
        case "TSTypeReference":
        case "TypeAnnotation":
        case "TypeAlias":
          return !0;
        case "ExportSpecifier":
          return e.parentPath.parent.exportKind === "type";
        default:
          if (e.parentPath.isStatement() || e.parentPath.isExpression())
            return !1;
      }
    while (e = e.parentPath);
  }
  i(Lce, "isInType");
  function jce(e, t, r) {
    let s = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ i((u) => {
      e.requeue(u);
    }, "requeueInParent");
    for (let [u, c] of t.source) {
      for (let [p, f] of c.imports)
        s.set(p, [u, f, null]);
      for (let p of c.importsNamespace)
        s.set(p, [u, null, p]);
    }
    for (let [u, c] of t.local) {
      let p = n.get(u);
      p || (p = [], n.set(u, p)), p.push(...c.names);
    }
    let o = {
      metadata: t,
      requeueInParent: a,
      scope: e.scope,
      exported: n
    };
    e.traverse(Mce, o);
    let l = {
      seen: /* @__PURE__ */ new WeakSet(),
      metadata: t,
      requeueInParent: a,
      scope: e.scope,
      imported: s,
      exported: n,
      buildImportReference([u, c, p], f) {
        let h = t.source.get(u);
        if (h.referenced = !0, p) {
          if (h.wrap) {
            var b;
            f = (b = r(f, h.wrap)) != null ? b : f;
          }
          return f;
        }
        let T = pe.types.identifier(h.name);
        if (h.wrap) {
          var d;
          T = (d = r(T, h.wrap)) != null ? d : T;
        }
        if (c === "default" && h.interop === "node-default")
          return T;
        let g = t.stringSpecifiers.has(c);
        return pe.types.memberExpression(T, g ? pe.types.stringLiteral(c) : pe.types.identifier(c), g);
      }
    };
    e.traverse(Rce, l);
  }
  i(jce, "rewriteLiveReferences");
  var Mce = {
    Scope(e) {
      e.skip();
    },
    ClassDeclaration(e) {
      let {
        requeueInParent: t,
        exported: r,
        metadata: s
      } = this, {
        id: n
      } = e.node;
      if (!n) throw new Error("Expected class to have a name");
      let a = n.name, o = r.get(a) || [];
      if (o.length > 0) {
        let l = pe.types.expressionStatement(Gn(s, o, pe.types.identifier(a), e.scope));
        l._blockHoist = e.node._blockHoist, t(e.insertAfter(l)[0]);
      }
    },
    VariableDeclaration(e) {
      let {
        requeueInParent: t,
        exported: r,
        metadata: s
      } = this, n = e.node.kind === "var";
      for (let a of e.get("declarations")) {
        let {
          id: o
        } = a.node, {
          init: l
        } = a.node;
        if (pe.types.isIdentifier(o) && r.has(o.name) && !pe.types.isArrowFunctionExpression(l) && (!pe.types.isFunctionExpression(l) || l.id) &&
        (!pe.types.isClassExpression(l) || l.id)) {
          if (!l) {
            if (n)
              continue;
            l = e.scope.buildUndefinedNode();
          }
          a.node.init = Gn(s, r.get(o.name), l, e.scope), t(a.get("init"));
        } else
          for (let u of Object.keys(a.getOuterBindingIdentifiers()))
            if (r.has(u)) {
              let c = pe.types.expressionStatement(Gn(s, r.get(u), pe.types.identifier(u), e.scope));
              c._blockHoist = e.node._blockHoist, t(e.insertAfter(c)[0]);
            }
      }
    }
  }, Gn = /* @__PURE__ */ i((e, t, r, s) => {
    let n = e.exportName;
    for (let a = s; a != null; a = a.parent)
      a.hasOwnBinding(n) && a.rename(n);
    return (t || []).reduce((a, o) => {
      let {
        stringSpecifiers: l
      } = e, u = l.has(o);
      return pe.types.assignmentExpression("=", pe.types.memberExpression(pe.types.identifier(n), u ? pe.types.stringLiteral(o) : pe.types.identifier(
      o), u), a);
    }, r);
  }, "buildBindingExportAssignmentExpression"), tc = /* @__PURE__ */ i((e) => pe.template.expression.ast`
    (function() {
      throw new Error('"' + '${e}' + '" is read-only.');
    })()
  `, "buildImportThrow"), Rce = {
    ReferencedIdentifier(e) {
      let {
        seen: t,
        buildImportReference: r,
        scope: s,
        imported: n,
        requeueInParent: a
      } = this;
      if (t.has(e.node)) return;
      t.add(e.node);
      let o = e.node.name, l = n.get(o);
      if (l) {
        if (Lce(e))
          throw e.buildCodeFrameError(`Cannot transform the imported binding "${o}" since it's also used in a type annotation. Please strip \
type annotations using @babel/preset-typescript or @babel/preset-flow.`);
        let u = e.scope.getBinding(o);
        if (s.getBinding(o) !== u) return;
        let p = r(l, e.node);
        if (p.loc = e.node.loc, (e.parentPath.isCallExpression({
          callee: e.node
        }) || e.parentPath.isOptionalCallExpression({
          callee: e.node
        }) || e.parentPath.isTaggedTemplateExpression({
          tag: e.node
        })) && pe.types.isMemberExpression(p))
          e.replaceWith(pe.types.sequenceExpression([pe.types.numericLiteral(0), p]));
        else if (e.isJSXIdentifier() && pe.types.isMemberExpression(p)) {
          let {
            object: f,
            property: h
          } = p;
          e.replaceWith(pe.types.jsxMemberExpression(pe.types.jsxIdentifier(f.name), pe.types.jsxIdentifier(h.name)));
        } else
          e.replaceWith(p);
        a(e), e.skip();
      }
    },
    UpdateExpression(e) {
      let {
        scope: t,
        seen: r,
        imported: s,
        exported: n,
        requeueInParent: a,
        buildImportReference: o
      } = this;
      if (r.has(e.node)) return;
      r.add(e.node);
      let l = e.get("argument");
      if (l.isMemberExpression()) return;
      let u = e.node;
      if (l.isIdentifier()) {
        let c = l.node.name;
        if (t.getBinding(c) !== e.scope.getBinding(c))
          return;
        let p = n.get(c), f = s.get(c);
        if (p?.length > 0 || f)
          if (f)
            e.replaceWith(pe.types.assignmentExpression(u.operator[0] + "=", o(f, l.node), tc(c)));
          else if (u.prefix)
            e.replaceWith(Gn(this.metadata, p, pe.types.cloneNode(u), e.scope));
          else {
            let h = t.generateDeclaredUidIdentifier(c);
            e.replaceWith(pe.types.sequenceExpression([pe.types.assignmentExpression("=", pe.types.cloneNode(h), pe.types.cloneNode(u)), Gn(
            this.metadata, p, pe.types.identifier(c), e.scope), pe.types.cloneNode(h)]));
          }
      }
      a(e), e.skip();
    },
    AssignmentExpression: {
      exit(e) {
        let {
          scope: t,
          seen: r,
          imported: s,
          exported: n,
          requeueInParent: a,
          buildImportReference: o
        } = this;
        if (r.has(e.node)) return;
        r.add(e.node);
        let l = e.get("left");
        if (!l.isMemberExpression())
          if (l.isIdentifier()) {
            let u = l.node.name;
            if (t.getBinding(u) !== e.scope.getBinding(u))
              return;
            let c = n.get(u), p = s.get(u);
            if (c?.length > 0 || p) {
              let f = e.node;
              p && (f.left = o(p, l.node), f.right = pe.types.sequenceExpression([f.right, tc(u)]));
              let {
                operator: h
              } = f, b;
              h === "=" ? b = f : h === "&&=" || h === "||=" || h === "??=" ? b = pe.types.assignmentExpression("=", f.left, pe.types.logicalExpression(
              h.slice(0, -1), pe.types.cloneNode(f.left), f.right)) : b = pe.types.assignmentExpression("=", f.left, pe.types.binaryExpression(
              h.slice(0, -1), pe.types.cloneNode(f.left), f.right)), e.replaceWith(Gn(this.metadata, c, b, e.scope)), a(e), e.skip();
            }
          } else {
            let u = l.getOuterBindingIdentifiers(), c = Object.keys(u).filter((h) => t.getBinding(h) === e.scope.getBinding(h)), p = c.find(
            (h) => s.has(h));
            p && (e.node.right = pe.types.sequenceExpression([e.node.right, tc(p)]));
            let f = [];
            if (c.forEach((h) => {
              let b = n.get(h) || [];
              b.length > 0 && f.push(Gn(this.metadata, b, pe.types.identifier(h), e.scope));
            }), f.length > 0) {
              let h = pe.types.sequenceExpression(f);
              e.parentPath.isExpressionStatement() && (h = pe.types.expressionStatement(h), h._blockHoist = e.parentPath.node._blockHoist);
              let b = e.insertAfter(h)[0];
              a(b);
            }
          }
      }
    },
    ForXStatement(e) {
      let {
        scope: t,
        node: r
      } = e, {
        left: s
      } = r, {
        exported: n,
        imported: a,
        scope: o
      } = this;
      if (!pe.types.isVariableDeclaration(s)) {
        let l = !1, u, c = e.get("body").scope;
        for (let h of Object.keys(pe.types.getOuterBindingIdentifiers(s)))
          o.getBinding(h) === t.getBinding(h) && (n.has(h) && (l = !0, c.hasOwnBinding(h) && c.rename(h)), a.has(h) && !u && (u = h));
        if (!l && !u)
          return;
        e.ensureBlock();
        let p = e.get("body"), f = t.generateUidIdentifierBasedOnNode(s);
        e.get("left").replaceWith(pe.types.variableDeclaration("let", [pe.types.variableDeclarator(pe.types.cloneNode(f))])), t.registerDeclaration(
        e.get("left")), l && p.unshiftContainer("body", pe.types.expressionStatement(pe.types.assignmentExpression("=", s, f))), u && p.unshiftContainer(
        "body", pe.types.expressionStatement(tc(u)));
      }
    }
  };
});

// ../node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js
var rm = D((Yi) => {
  "use strict";
  Object.defineProperty(Yi, "__esModule", {
    value: !0
  });
  Yi.default = Kce;
  Yi.hasExports = Uce;
  Yi.isSideEffectImport = $ce;
  Yi.validateImportInteropOption = vA;
  var SA = z("path"), qce = bi();
  function Uce(e) {
    return e.hasExports;
  }
  i(Uce, "hasExports");
  function $ce(e) {
    return e.imports.size === 0 && e.importsNamespace.size === 0 && e.reexports.size === 0 && e.reexportNamespace.size === 0 && !e.reexportAll;
  }
  i($ce, "isSideEffectImport");
  function vA(e) {
    if (typeof e != "function" && e !== "none" && e !== "babel" && e !== "node")
      throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${e}).`);
    return e;
  }
  i(vA, "validateImportInteropOption");
  function Vce(e, t, r) {
    return typeof e == "function" ? vA(e(t, r)) : e;
  }
  i(Vce, "resolveImportInterop");
  function Kce(e, t, {
    importInterop: r,
    initializeReexports: s = !1,
    getWrapperPayload: n,
    esNamespaceOnly: a = !1,
    filename: o
  }) {
    t || (t = e.scope.generateUidIdentifier("exports").name);
    let l = /* @__PURE__ */ new Set();
    Hce(e);
    let {
      local: u,
      sources: c,
      hasExports: p
    } = Wce(e, {
      initializeReexports: s,
      getWrapperPayload: n
    }, l);
    Jce(e);
    for (let [f, h] of c) {
      let {
        importsNamespace: b,
        imports: T
      } = h;
      if (b.size > 0 && T.size === 0) {
        let [g] = b;
        h.name = g;
      }
      let d = Vce(r, f, o);
      d === "none" ? h.interop = "none" : d === "node" && h.interop === "namespace" ? h.interop = "node-namespace" : d === "node" && h.interop ===
      "default" ? h.interop = "node-default" : a && h.interop === "namespace" && (h.interop = "default");
    }
    return {
      exportName: t,
      exportNameListName: null,
      hasExports: p,
      local: u,
      source: c,
      stringSpecifiers: l
    };
  }
  i(Kce, "normalizeModuleAndLoadMetadata");
  function rc(e, t) {
    if (e.isIdentifier())
      return e.node.name;
    if (e.isStringLiteral()) {
      let r = e.node.value;
      return (0, qce.isIdentifierName)(r) || t.add(r), r;
    } else
      throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${e.node.type}`);
  }
  i(rc, "getExportSpecifierName");
  function PA(e) {
    if (!e.isExportSpecifier())
      throw e.isExportNamespaceSpecifier() ? e.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform\
-export-namespace-from`.") : e.buildCodeFrameError("Unexpected export specifier type");
  }
  i(PA, "assertExportSpecifier");
  function Wce(e, {
    getWrapperPayload: t,
    initializeReexports: r
  }, s) {
    let n = Yce(e, r, s), a = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ i((c, p) => {
      let f = c.value, h = o.get(f);
      return h ? a.get(f).push(p) : (h = {
        name: e.scope.generateUidIdentifier((0, SA.basename)(f, (0, SA.extname)(f))).name,
        interop: "none",
        loc: null,
        imports: /* @__PURE__ */ new Map(),
        importsNamespace: /* @__PURE__ */ new Set(),
        reexports: /* @__PURE__ */ new Map(),
        reexportNamespace: /* @__PURE__ */ new Set(),
        reexportAll: null,
        wrap: null,
        get lazy() {
          return this.wrap === "lazy";
        },
        referenced: !1
      }, o.set(f, h), a.set(f, [p])), h;
    }, "getData"), u = !1;
    e.get("body").forEach((c) => {
      if (c.isImportDeclaration()) {
        let p = l(c.node.source, c.node);
        p.loc || (p.loc = c.node.loc), c.get("specifiers").forEach((f) => {
          if (f.isImportDefaultSpecifier()) {
            let h = f.get("local").node.name;
            p.imports.set(h, "default");
            let b = n.get(h);
            b && (n.delete(h), b.names.forEach((T) => {
              p.reexports.set(T, "default");
            }), p.referenced = !0);
          } else if (f.isImportNamespaceSpecifier()) {
            let h = f.get("local").node.name;
            p.importsNamespace.add(h);
            let b = n.get(h);
            b && (n.delete(h), b.names.forEach((T) => {
              p.reexportNamespace.add(T);
            }), p.referenced = !0);
          } else if (f.isImportSpecifier()) {
            let h = rc(f.get("imported"), s), b = f.get("local").node.name;
            p.imports.set(b, h);
            let T = n.get(b);
            T && (n.delete(b), T.names.forEach((d) => {
              p.reexports.set(d, h);
            }), p.referenced = !0);
          }
        });
      } else if (c.isExportAllDeclaration()) {
        u = !0;
        let p = l(c.node.source, c.node);
        p.loc || (p.loc = c.node.loc), p.reexportAll = {
          loc: c.node.loc
        }, p.referenced = !0;
      } else if (c.isExportNamedDeclaration() && c.node.source) {
        u = !0;
        let p = l(c.node.source, c.node);
        p.loc || (p.loc = c.node.loc), c.get("specifiers").forEach((f) => {
          PA(f);
          let h = rc(f.get("local"), s), b = rc(f.get("exported"), s);
          if (p.reexports.set(b, h), p.referenced = !0, b === "__esModule")
            throw f.get("exported").buildCodeFrameError('Illegal export "__esModule".');
        });
      } else (c.isExportNamedDeclaration() || c.isExportDefaultDeclaration()) && (u = !0);
    });
    for (let c of o.values()) {
      let p = !1, f = !1;
      c.importsNamespace.size > 0 && (p = !0, f = !0), c.reexportAll && (f = !0);
      for (let h of c.imports.values())
        h === "default" ? p = !0 : f = !0;
      for (let h of c.reexports.values())
        h === "default" ? p = !0 : f = !0;
      p && f ? c.interop = "namespace" : p && (c.interop = "default");
    }
    if (t)
      for (let [c, p] of o)
        p.wrap = t(c, p, a.get(c));
    return {
      hasExports: u,
      local: n,
      sources: o
    };
  }
  i(Wce, "getModuleMetadata");
  function Yce(e, t, r) {
    let s = /* @__PURE__ */ new Map(), n = e.scope, a = e.get("body");
    a.forEach((u) => {
      let c;
      if (u.isImportDeclaration())
        c = "import";
      else {
        if (u.isExportDefaultDeclaration() && (u = u.get("declaration")), u.isExportNamedDeclaration()) {
          if (u.node.declaration)
            u = u.get("declaration");
          else if (t && u.node.source && u.get("source").isStringLiteral()) {
            u.get("specifiers").forEach((p) => {
              PA(p), s.set(p.get("local").node.name, "block");
            });
            return;
          }
        }
        if (u.isFunctionDeclaration())
          c = "hoisted";
        else if (u.isClassDeclaration())
          c = "block";
        else if (u.isVariableDeclaration({
          kind: "var"
        }))
          c = "var";
        else if (u.isVariableDeclaration())
          c = "block";
        else
          return;
      }
      Object.keys(u.getOuterBindingIdentifiers()).forEach((p) => {
        s.set(p, c);
      });
    });
    let o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ i((u) => {
      let c = u.node.name, p = o.get(c);
      if (!p) {
        var f, h;
        let b = (f = s.get(c)) != null ? f : (h = n.getBinding(c)) == null ? void 0 : h.kind;
        if (b === void 0)
          throw u.buildCodeFrameError(`Exporting local "${c}", which is not declared.`);
        p = {
          names: [],
          kind: b
        }, o.set(c, p);
      }
      return p;
    }, "getLocalMetadata");
    return a.forEach((u) => {
      if (u.isExportNamedDeclaration() && (t || !u.node.source))
        if (u.node.declaration) {
          let c = u.get("declaration"), p = c.getOuterBindingIdentifierPaths();
          Object.keys(p).forEach((f) => {
            if (f === "__esModule")
              throw c.buildCodeFrameError('Illegal export "__esModule".');
            l(p[f]).names.push(f);
          });
        } else
          u.get("specifiers").forEach((c) => {
            let p = c.get("local"), f = c.get("exported"), h = l(p), b = rc(f, r);
            if (b === "__esModule")
              throw f.buildCodeFrameError('Illegal export "__esModule".');
            h.names.push(b);
          });
      else if (u.isExportDefaultDeclaration()) {
        let c = u.get("declaration");
        if (c.isFunctionDeclaration() || c.isClassDeclaration())
          l(c.get("id")).names.push("default");
        else
          throw c.buildCodeFrameError("Unexpected default expression export.");
      }
    }), o;
  }
  i(Yce, "getLocalExportMetadata");
  function Hce(e) {
    e.get("body").forEach((t) => {
      if (t.isExportDefaultDeclaration()) {
        {
          var r;
          (r = t.splitExportDeclaration) != null || (t.splitExportDeclaration = nt().NodePath.prototype.splitExportDeclaration);
        }
        t.splitExportDeclaration();
      }
    });
  }
  i(Hce, "nameAnonymousExports");
  function Jce(e) {
    e.get("body").forEach((t) => {
      if (t.isImportDeclaration())
        t.remove();
      else if (t.isExportNamedDeclaration())
        t.node.declaration ? (t.node.declaration._blockHoist = t.node._blockHoist, t.replaceWith(t.node.declaration)) : t.remove();
      else if (t.isExportDefaultDeclaration()) {
        let r = t.get("declaration");
        if (r.isFunctionDeclaration() || r.isClassDeclaration())
          r._blockHoist = t.node._blockHoist, t.replaceWith(r);
        else
          throw r.buildCodeFrameError("Unexpected default expression export.");
      } else t.isExportAllDeclaration() && t.remove();
    });
  }
  i(Jce, "removeImportExportDeclarations");
});

// ../node_modules/@babel/helper-module-transforms/lib/lazy-modules.js
var AA = D((sc) => {
  "use strict";
  Object.defineProperty(sc, "__esModule", {
    value: !0
  });
  sc.toGetWrapperPayload = zce;
  sc.wrapReference = Qce;
  var Gce = et(), Xce = rm();
  function zce(e) {
    return (t, r) => {
      if (e === !1 || (0, Xce.isSideEffectImport)(r) || r.reexportAll) return null;
      if (e === !0)
        return t.includes(".") ? null : "lazy";
      if (Array.isArray(e))
        return e.includes(t) ? "lazy" : null;
      if (typeof e == "function")
        return e(t) ? "lazy" : null;
      throw new Error(".lazy must be a boolean, string array, or function");
    };
  }
  i(zce, "toGetWrapperPayload");
  function Qce(e, t) {
    return t === "lazy" ? Gce.types.callExpression(e, []) : null;
  }
  i(Qce, "wrapReference");
});

// ../node_modules/@babel/helper-module-transforms/lib/dynamic-import.js
var sm = D((nc) => {
  "use strict";
  Object.defineProperty(nc, "__esModule", {
    value: !0
  });
  nc.buildDynamicImport = Zce;
  var vt = et();
  nc.getDynamicImportSource = /* @__PURE__ */ i(function(t) {
    let [r] = t.arguments;
    return vt.types.isStringLiteral(r) || vt.types.isTemplateLiteral(r) ? r : vt.template.expression.ast`\`\${${r}}\``;
  }, "getDynamicImportSource");
  function Zce(e, t, r, s) {
    let n = vt.types.isCallExpression(e) ? e.arguments[0] : e.source;
    if (vt.types.isStringLiteral(n) || vt.types.isTemplateLiteral(n) && n.quasis.length === 0)
      return t ? vt.template.expression.ast`
        Promise.resolve().then(() => ${s(n)})
      ` : s(n);
    let a = vt.types.isTemplateLiteral(n) ? vt.types.identifier("specifier") : vt.types.templateLiteral([vt.types.templateElement({
      raw: ""
    }), vt.types.templateElement({
      raw: ""
    })], [vt.types.identifier("specifier")]);
    return t ? vt.template.expression.ast`
      (specifier =>
        new Promise(r => r(${a}))
          .then(s => ${s(vt.types.identifier("s"))})
      )(${n})
    ` : r ? vt.template.expression.ast`
      (specifier =>
        new Promise(r => r(${s(a)}))
      )(${n})
    ` : vt.template.expression.ast`
      (specifier => ${s(a)})(${n})
    `;
  }
  i(Zce, "buildDynamicImport");
});

// ../node_modules/@babel/helper-module-transforms/lib/get-module-name.js
var CA = D((ic) => {
  "use strict";
  Object.defineProperty(ic, "__esModule", {
    value: !0
  });
  ic.default = nm;
  {
    let e = nm;
    ic.default = nm = /* @__PURE__ */ i(function(r, s) {
      var n, a, o, l;
      return e(r, {
        moduleId: (n = s.moduleId) != null ? n : r.moduleId,
        moduleIds: (a = s.moduleIds) != null ? a : r.moduleIds,
        getModuleId: (o = s.getModuleId) != null ? o : r.getModuleId,
        moduleRoot: (l = s.moduleRoot) != null ? l : r.moduleRoot
      });
    }, "getModuleName");
  }
  function nm(e, t) {
    let {
      filename: r,
      filenameRelative: s = r,
      sourceRoot: n = t.moduleRoot
    } = e, {
      moduleId: a,
      moduleIds: o = !!a,
      getModuleId: l,
      moduleRoot: u = n
    } = t;
    if (!o) return null;
    if (a != null && !l)
      return a;
    let c = u != null ? u + "/" : "";
    if (s) {
      let p = n != null ? new RegExp("^" + n + "/?") : "";
      c += s.replace(p, "").replace(/\.\w*$/, "");
    }
    return c = c.replace(/\\/g, "/"), l && l(c) || c;
  }
  i(nm, "getModuleName");
});

// ../node_modules/@babel/helper-module-transforms/lib/index.js
var Do = D((nr) => {
  "use strict";
  Object.defineProperty(nr, "__esModule", {
    value: !0
  });
  Object.defineProperty(nr, "buildDynamicImport", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return rpe.buildDynamicImport;
    }, "get")
  });
  nr.buildNamespaceInitStatements = ope;
  nr.ensureStatementsHoisted = ipe;
  Object.defineProperty(nr, "getModuleName", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return spe.default;
    }, "get")
  });
  Object.defineProperty(nr, "hasExports", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return wo.hasExports;
    }, "get")
  });
  Object.defineProperty(nr, "isModule", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return wA.isModule;
    }, "get")
  });
  Object.defineProperty(nr, "isSideEffectImport", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return wo.isSideEffectImport;
    }, "get")
  });
  nr.rewriteModuleStatementsAndPrepareHeader = npe;
  Object.defineProperty(nr, "rewriteThis", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return DA.default;
    }, "get")
  });
  nr.wrapInterop = ape;
  var epe = z("assert"), ve = et(), wA = bA(), DA = xA(), tpe = EA(), wo = rm(), lm = AA(), rpe = sm(), spe = CA();
  nr.getDynamicImportSource = sm().getDynamicImportSource;
  function npe(e, {
    exportName: t,
    strict: r,
    allowTopLevelThis: s,
    strictMode: n,
    noInterop: a,
    importInterop: o = a ? "none" : "babel",
    lazy: l,
    getWrapperPayload: u = lm.toGetWrapperPayload(l ?? !1),
    wrapReference: c = lm.wrapReference,
    esNamespaceOnly: p,
    filename: f,
    constantReexports: h = arguments[1].loose,
    enumerableModuleMeta: b = arguments[1].loose,
    noIncompleteNsImportDetection: T
  }) {
    (0, wo.validateImportInteropOption)(o), epe((0, wA.isModule)(e), "Cannot process module statements in a script"), e.node.sourceType = "s\
cript";
    let d = (0, wo.default)(e, t, {
      importInterop: o,
      initializeReexports: h,
      getWrapperPayload: u,
      esNamespaceOnly: p,
      filename: f
    });
    s || (0, DA.default)(e), (0, tpe.default)(e, d, c), n !== !1 && (e.node.directives.some((N) => N.value.value === "use strict") || e.unshiftContainer(
    "directives", ve.types.directive(ve.types.directiveLiteral("use strict"))));
    let g = [];
    (0, wo.hasExports)(d) && !r && g.push(lpe(d, b));
    let E = cpe(e, d);
    return E && (d.exportNameListName = E.name, g.push(E.statement)), g.push(...ppe(e, d, c, h, T)), {
      meta: d,
      headers: g
    };
  }
  i(npe, "rewriteModuleStatementsAndPrepareHeader");
  function ipe(e) {
    e.forEach((t) => {
      t._blockHoist = 3;
    });
  }
  i(ipe, "ensureStatementsHoisted");
  function ape(e, t, r) {
    if (r === "none")
      return null;
    if (r === "node-namespace")
      return ve.types.callExpression(e.hub.addHelper("interopRequireWildcard"), [t, ve.types.booleanLiteral(!0)]);
    if (r === "node-default")
      return null;
    let s;
    if (r === "default")
      s = "interopRequireDefault";
    else if (r === "namespace")
      s = "interopRequireWildcard";
    else
      throw new Error(`Unknown interop: ${r}`);
    return ve.types.callExpression(e.hub.addHelper(s), [t]);
  }
  i(ape, "wrapInterop");
  function ope(e, t, r = !1, s = lm.wrapReference) {
    var n;
    let a = [], o = ve.types.identifier(t.name);
    for (let u of t.importsNamespace)
      u !== t.name && a.push(ve.template.statement`var NAME = SOURCE;`({
        NAME: u,
        SOURCE: ve.types.cloneNode(o)
      }));
    let l = (n = s(o, t.wrap)) != null ? n : o;
    r && a.push(..._A(e, t, !0, s));
    for (let u of t.reexportNamespace)
      a.push((ve.types.isIdentifier(l) ? ve.template.statement`EXPORTS.NAME = NAMESPACE;` : ve.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          `)({
        EXPORTS: e.exportName,
        NAME: u,
        NAMESPACE: ve.types.cloneNode(l)
      }));
    if (t.reexportAll) {
      let u = upe(e, ve.types.cloneNode(l), r);
      u.loc = t.reexportAll.loc, a.push(u);
    }
    return a;
  }
  i(ope, "buildNamespaceInitStatements");
  var im = {
    constant: /* @__PURE__ */ i(({
      exports: e,
      exportName: t,
      namespaceImport: r
    }) => ve.template.statement.ast`
      ${e}.${t} = ${r};
    `, "constant"),
    constantComputed: /* @__PURE__ */ i(({
      exports: e,
      exportName: t,
      namespaceImport: r
    }) => ve.template.statement.ast`
      ${e}["${t}"] = ${r};
    `, "constantComputed"),
    spec: /* @__PURE__ */ i(({
      exports: e,
      exportName: t,
      namespaceImport: r
    }) => ve.template.statement.ast`
      Object.defineProperty(${e}, "${t}", {
        enumerable: true,
        get: function() {
          return ${r};
        },
      });
    `, "spec")
  };
  function _A(e, t, r, s) {
    var n;
    let a = ve.types.identifier(t.name);
    a = (n = s(a, t.wrap)) != null ? n : a;
    let {
      stringSpecifiers: o
    } = e;
    return Array.from(t.reexports, ([l, u]) => {
      let c = ve.types.cloneNode(a);
      u === "default" && t.interop === "node-default" || (o.has(u) ? c = ve.types.memberExpression(c, ve.types.stringLiteral(u), !0) : c = ve.
      types.memberExpression(c, ve.types.identifier(u)));
      let p = {
        exports: e.exportName,
        exportName: l,
        namespaceImport: c
      };
      return r || ve.types.isIdentifier(c) ? o.has(l) ? im.constantComputed(p) : im.constant(p) : im.spec(p);
    });
  }
  i(_A, "buildReexportsFromMeta");
  function lpe(e, t = !1) {
    return (t ? ve.template.statement`
        EXPORTS.__esModule = true;
      ` : ve.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
      EXPORTS: e.exportName
    });
  }
  i(lpe, "buildESModuleHeader");
  function upe(e, t, r) {
    return (r ? ve.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : ve.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
      NAMESPACE: t,
      EXPORTS: e.exportName,
      VERIFY_NAME_LIST: e.exportNameListName ? (0, ve.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
        EXPORTS_LIST: e.exportNameListName
      }) : null
    });
  }
  i(upe, "buildNamespaceReexport");
  function cpe(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    for (let a of t.local.values())
      for (let o of a.names)
        r[o] = !0;
    let s = !1;
    for (let a of t.source.values()) {
      for (let o of a.reexports.keys())
        r[o] = !0;
      for (let o of a.reexportNamespace)
        r[o] = !0;
      s = s || !!a.reexportAll;
    }
    if (!s || Object.keys(r).length === 0) return null;
    let n = e.scope.generateUidIdentifier("exportNames");
    return delete r.default, {
      name: n.name,
      statement: ve.types.variableDeclaration("var", [ve.types.variableDeclarator(n, ve.types.valueToNode(r))])
    };
  }
  i(cpe, "buildExportNameListDeclaration");
  function ppe(e, t, r, s = !1, n = !1) {
    let a = [];
    for (let [l, u] of t.local)
      if (u.kind !== "import") {
        if (u.kind === "hoisted")
          a.push([u.names[0], om(t, u.names, ve.types.identifier(l))]);
        else if (!n)
          for (let c of u.names)
            a.push([c, null]);
      }
    for (let l of t.source.values()) {
      if (!s) {
        let u = _A(t, l, !1, r), c = [...l.reexports.keys()];
        for (let p = 0; p < u.length; p++)
          a.push([c[p], u[p]]);
      }
      if (!n)
        for (let u of l.reexportNamespace)
          a.push([u, null]);
    }
    a.sort(([l], [u]) => l < u ? -1 : u < l ? 1 : 0);
    let o = [];
    if (n)
      for (let [, l] of a)
        o.push(l);
    else
      for (let u = 0; u < a.length; u += 100) {
        let c = [];
        for (let p = 0; p < 100 && u + p < a.length; p++) {
          let [f, h] = a[u + p];
          h !== null ? (c.length > 0 && (o.push(om(t, c, e.scope.buildUndefinedNode())), c = []), o.push(h)) : c.push(f);
        }
        c.length > 0 && o.push(om(t, c, e.scope.buildUndefinedNode()));
      }
    return o;
  }
  i(ppe, "buildExportInitializationStatements");
  var am = {
    computed: /* @__PURE__ */ i(({
      exports: e,
      name: t,
      value: r
    }) => ve.template.expression.ast`${e}["${t}"] = ${r}`, "computed"),
    default: /* @__PURE__ */ i(({
      exports: e,
      name: t,
      value: r
    }) => ve.template.expression.ast`${e}.${t} = ${r}`, "default"),
    define: /* @__PURE__ */ i(({
      exports: e,
      name: t,
      value: r
    }) => ve.template.expression.ast`
      Object.defineProperty(${e}, "${t}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${t}"] = ${r}`, "define")
  };
  function om(e, t, r) {
    let {
      stringSpecifiers: s,
      exportName: n
    } = e;
    return ve.types.expressionStatement(t.reduce((a, o) => {
      let l = {
        exports: n,
        name: o,
        value: a
      };
      return o === "__proto__" ? am.define(l) : s.has(o) ? am.computed(l) : am.default(l);
    }, r));
  }
  i(om, "buildInitStatement");
});

// ../node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs
var OA = D((IA) => {
  IA.getModuleName = () => Do().getModuleName;
});

// ../node_modules/@babel/core/lib/transformation/file/file.js
var cm = D((oc) => {
  "use strict";
  Object.defineProperty(oc, "__esModule", {
    value: !0
  });
  oc.default = void 0;
  function Xn() {
    let e = ch();
    return Xn = /* @__PURE__ */ i(function() {
      return e;
    }, "helpers"), e;
  }
  i(Xn, "helpers");
  function um() {
    let e = nt();
    return um = /* @__PURE__ */ i(function() {
      return e;
    }, "_traverse"), e;
  }
  i(um, "_traverse");
  function NA() {
    let e = Za();
    return NA = /* @__PURE__ */ i(function() {
      return e;
    }, "_codeFrame"), e;
  }
  i(NA, "_codeFrame");
  function BA() {
    let e = ce();
    return BA = /* @__PURE__ */ i(function() {
      return e;
    }, "_t"), e;
  }
  i(BA, "_t");
  function ac() {
    let e = z("semver");
    return ac = /* @__PURE__ */ i(function() {
      return e;
    }, "_semver"), e;
  }
  i(ac, "_semver");
  var fpe = OA(), {
    cloneNode: dpe,
    interpreterDirective: hpe
  } = BA(), mpe = {
    enter(e, t) {
      let r = e.node.loc;
      r && (t.loc = r, e.stop());
    }
  }, Hi = class {
    static {
      i(this, "File");
    }
    constructor(t, {
      code: r,
      ast: s,
      inputMap: n
    }) {
      this._map = /* @__PURE__ */ new Map(), this.opts = void 0, this.declarations = {}, this.path = void 0, this.ast = void 0, this.scope =
      void 0, this.metadata = {}, this.code = "", this.inputMap = void 0, this.hub = {
        file: this,
        getCode: /* @__PURE__ */ i(() => this.code, "getCode"),
        getScope: /* @__PURE__ */ i(() => this.scope, "getScope"),
        addHelper: this.addHelper.bind(this),
        buildError: this.buildCodeFrameError.bind(this)
      }, this.opts = t, this.code = r, this.ast = s, this.inputMap = n, this.path = um().NodePath.get({
        hub: this.hub,
        parentPath: null,
        parent: this.ast,
        container: this.ast,
        key: "program"
      }).setContext(), this.scope = this.path.scope;
    }
    get shebang() {
      let {
        interpreter: t
      } = this.path.node;
      return t ? t.value : "";
    }
    set shebang(t) {
      t ? this.path.get("interpreter").replaceWith(hpe(t)) : this.path.get("interpreter").remove();
    }
    set(t, r) {
      if (t === "helpersNamespace")
        throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-\
helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to \
explore using 'helperGenerator' alongside 'file.availableHelper()'.");
      this._map.set(t, r);
    }
    get(t) {
      return this._map.get(t);
    }
    has(t) {
      return this._map.has(t);
    }
    availableHelper(t, r) {
      if (Xn().isInternal(t)) return !1;
      let s;
      try {
        s = Xn().minVersion(t);
      } catch (n) {
        if (n.code !== "BABEL_HELPER_UNKNOWN") throw n;
        return !1;
      }
      return typeof r != "string" ? !0 : (ac().valid(r) && (r = `^${r}`), !ac().intersects(`<${s}`, r) && !ac().intersects(">=8.0.0", r));
    }
    addHelper(t) {
      if (Xn().isInternal(t))
        throw new Error("Cannot use internal helper " + t);
      return this._addHelper(t);
    }
    _addHelper(t) {
      let r = this.declarations[t];
      if (r) return dpe(r);
      let s = this.get("helperGenerator");
      if (s) {
        let c = s(t);
        if (c) return c;
      }
      Xn().minVersion(t);
      let n = this.declarations[t] = this.scope.generateUidIdentifier(t), a = {};
      for (let c of Xn().getDependencies(t))
        a[c] = this._addHelper(c);
      let {
        nodes: o,
        globals: l
      } = Xn().get(t, (c) => a[c], n.name, Object.keys(this.scope.getAllBindings()));
      l.forEach((c) => {
        this.path.scope.hasBinding(c, !0) && this.path.scope.rename(c);
      }), o.forEach((c) => {
        c._compact = !0;
      });
      let u = this.path.unshiftContainer("body", o);
      for (let c of u)
        c.isVariableDeclaration() && this.scope.registerDeclaration(c);
      return n;
    }
    buildCodeFrameError(t, r, s = SyntaxError) {
      let n = t?.loc;
      if (!n && t) {
        let a = {
          loc: null
        };
        (0, um().default)(t, mpe, this.scope, a), n = a.loc;
        let o = "This is an error on an internal node. Probably an internal error.";
        n && (o += " Location has been estimated."), r += ` (${o})`;
      }
      if (n) {
        let {
          highlightCode: a = !0
        } = this.opts;
        r += `
` + (0, NA().codeFrameColumns)(this.code, {
          start: {
            line: n.start.line,
            column: n.start.column + 1
          },
          end: n.end && n.start.line === n.end.line ? {
            line: n.end.line,
            column: n.end.column + 1
          } : void 0
        }, {
          highlightCode: a
        });
      }
      return new s(r);
    }
  };
  oc.default = Hi;
  Hi.prototype.addImport = /* @__PURE__ */ i(function() {
    throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-mo\
dule-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
  }, "addImport"), Hi.prototype.addTemplateObject = /* @__PURE__ */ i(function() {
    throw new Error("This function has been moved into the template literal transform itself.");
  }, "addTemplateObject"), Hi.prototype.getModuleName = /* @__PURE__ */ i(function() {
    return fpe.getModuleName()(this.opts, this.opts);
  }, "getModuleName");
});

// ../node_modules/@babel/core/lib/tools/build-external-helpers.js
var MA = D((bm) => {
  "use strict";
  Object.defineProperty(bm, "__esModule", {
    value: !0
  });
  bm.default = Ope;
  function pm() {
    let e = ch();
    return pm = /* @__PURE__ */ i(function() {
      return e;
    }, "helpers"), e;
  }
  i(pm, "helpers");
  function kA() {
    let e = bo();
    return kA = /* @__PURE__ */ i(function() {
      return e;
    }, "_generator"), e;
  }
  i(kA, "_generator");
  function FA() {
    let e = ro();
    return FA = /* @__PURE__ */ i(function() {
      return e;
    }, "_template"), e;
  }
  i(FA, "_template");
  function LA() {
    let e = ce();
    return LA = /* @__PURE__ */ i(function() {
      return e;
    }, "_t"), e;
  }
  i(LA, "_t");
  var {
    arrayExpression: ype,
    assignmentExpression: lc,
    binaryExpression: bpe,
    blockStatement: gpe,
    callExpression: Tpe,
    cloneNode: xpe,
    conditionalExpression: Epe,
    exportNamedDeclaration: Spe,
    exportSpecifier: vpe,
    expressionStatement: fm,
    functionExpression: Ppe,
    identifier: Pt,
    memberExpression: dm,
    objectExpression: hm,
    program: uc,
    stringLiteral: jA,
    unaryExpression: Ape,
    variableDeclaration: mm,
    variableDeclarator: ym
  } = LA(), Cpe = /* @__PURE__ */ i((e) => FA().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(e), "buildUmdWrapper");
  function wpe(e) {
    let t = Pt("babelHelpers"), r = [], s = Ppe(null, [Pt("global")], gpe(r)), n = uc([fm(Tpe(s, [Epe(bpe("===", Ape("typeof", Pt("global")),
    jA("undefined")), Pt("self"), Pt("global"))]))]);
    return r.push(mm("var", [ym(t, lc("=", dm(Pt("global"), t), hm([])))])), cc(r, t, e), n;
  }
  i(wpe, "buildGlobal");
  function Dpe(e) {
    let t = [], r = cc(t, null, e);
    return t.unshift(Spe(null, Object.keys(r).map((s) => vpe(xpe(r[s]), Pt(s))))), uc(t, [], "module");
  }
  i(Dpe, "buildModule");
  function _pe(e) {
    let t = Pt("babelHelpers"), r = [];
    return r.push(mm("var", [ym(t, Pt("global"))])), cc(r, t, e), uc([Cpe({
      FACTORY_PARAMETERS: Pt("global"),
      BROWSER_ARGUMENTS: lc("=", dm(Pt("root"), t), hm([])),
      COMMON_ARGUMENTS: Pt("exports"),
      AMD_ARGUMENTS: ype([jA("exports")]),
      FACTORY_BODY: r,
      UMD_ROOT: Pt("this")
    })]);
  }
  i(_pe, "buildUmd");
  function Ipe(e) {
    let t = Pt("babelHelpers"), r = [];
    r.push(mm("var", [ym(t, hm([]))]));
    let s = uc(r);
    return cc(r, t, e), r.push(fm(t)), s;
  }
  i(Ipe, "buildVar");
  function cc(e, t, r) {
    let s = /* @__PURE__ */ i((a) => t ? dm(t, Pt(a)) : Pt(`_${a}`), "getHelperReference"), n = {};
    return pm().list.forEach(function(a) {
      if (r && !r.includes(a)) return;
      let o = n[a] = s(a), {
        nodes: l
      } = pm().get(a, s, t ? null : `_${a}`, [], t ? (u, c, p) => {
        p((f) => lc("=", o, f)), u.body.push(fm(lc("=", o, Pt(c))));
      } : null);
      e.push(...l);
    }), n;
  }
  i(cc, "buildHelpers");
  function Ope(e, t = "global") {
    let r, s = {
      global: wpe,
      module: Dpe,
      umd: _pe,
      var: Ipe
    }[t];
    if (s)
      r = s(e);
    else
      throw new Error(`Unsupported output type ${t}`);
    return (0, kA().default)(r).code;
  }
  i(Ope, "_default");
});

// ../node_modules/gensync/index.js
var ir = D((p5e, YA) => {
  "use strict";
  var qA = Symbol.for("gensync:v1:start"), UA = Symbol.for("gensync:v1:suspend"), Npe = "GENSYNC_EXPECTED_START", Bpe = "GENSYNC_EXPECTED_SU\
SPEND", $A = "GENSYNC_OPTIONS_ERROR", RA = "GENSYNC_RACE_NONEMPTY", kpe = "GENSYNC_ERRBACK_NO_CALLBACK";
  YA.exports = Object.assign(
    /* @__PURE__ */ i(function(t) {
      let r = t;
      return typeof t != "function" ? r = Lpe(t) : r = jpe(t), Object.assign(r, Fpe(r));
    }, "gensync"),
    {
      all: gm({
        name: "all",
        arity: 1,
        sync: /* @__PURE__ */ i(function(e) {
          return Array.from(e[0]).map((r) => Tm(r));
        }, "sync"),
        async: /* @__PURE__ */ i(function(e, t, r) {
          let s = Array.from(e[0]);
          if (s.length === 0) {
            Promise.resolve().then(() => t([]));
            return;
          }
          let n = 0, a = s.map(() => {
          });
          s.forEach((o, l) => {
            pc(
              o,
              (u) => {
                a[l] = u, n += 1, n === a.length && t(a);
              },
              r
            );
          });
        }, "async")
      }),
      race: gm({
        name: "race",
        arity: 1,
        sync: /* @__PURE__ */ i(function(e) {
          let t = Array.from(e[0]);
          if (t.length === 0)
            throw zn("Must race at least 1 item", RA);
          return Tm(t[0]);
        }, "sync"),
        async: /* @__PURE__ */ i(function(e, t, r) {
          let s = Array.from(e[0]);
          if (s.length === 0)
            throw zn("Must race at least 1 item", RA);
          for (let n of s)
            pc(n, t, r);
        }, "async")
      })
    }
  );
  function Fpe(e) {
    return {
      sync: /* @__PURE__ */ i(function(...r) {
        return Tm(e.apply(this, r));
      }, "sync"),
      async: /* @__PURE__ */ i(function(...r) {
        return new Promise((s, n) => {
          pc(e.apply(this, r), s, n);
        });
      }, "async"),
      errback: /* @__PURE__ */ i(function(...r) {
        let s = r.pop();
        if (typeof s != "function")
          throw zn(
            "Asynchronous function called without callback",
            kpe
          );
        let n;
        try {
          n = e.apply(this, r);
        } catch (a) {
          s(a);
          return;
        }
        pc(n, (a) => s(void 0, a), (a) => s(a));
      }, "errback")
    };
  }
  i(Fpe, "makeFunctionAPI");
  function _o(e, t, r, s) {
    if (typeof r === e || s && typeof r > "u")
      return;
    let n;
    throw s ? n = `Expected opts.${t} to be either a ${e}, or undefined.` : n = `Expected opts.${t} to be a ${e}.`, zn(n, $A);
  }
  i(_o, "assertTypeof");
  function zn(e, t) {
    return Object.assign(new Error(e), { code: t });
  }
  i(zn, "makeError");
  function Lpe({ name: e, arity: t, sync: r, async: s, errback: n }) {
    if (_o(
      "string",
      "name",
      e,
      !0
      /* allowUndefined */
    ), _o(
      "number",
      "arity",
      t,
      !0
      /* allowUndefined */
    ), _o("function", "sync", r), _o(
      "function",
      "async",
      s,
      !0
      /* allowUndefined */
    ), _o(
      "function",
      "errback",
      n,
      !0
      /* allowUndefined */
    ), s && n)
      throw zn(
        "Expected one of either opts.async or opts.errback, but got _both_.",
        $A
      );
    if (typeof e != "string") {
      let a;
      n && n.name && n.name !== "errback" && (a = n.name), s && s.name && s.name !== "async" && (a = s.name.replace(/Async$/, "")), r && r.name &&
      r.name !== "sync" && (a = r.name.replace(/Sync$/, "")), typeof a == "string" && (e = a);
    }
    return typeof t != "number" && (t = r.length), gm({
      name: e,
      arity: t,
      sync: /* @__PURE__ */ i(function(a) {
        return r.apply(this, a);
      }, "sync"),
      async: /* @__PURE__ */ i(function(a, o, l) {
        s ? s.apply(this, a).then(o, l) : n ? n.call(this, ...a, (u, c) => {
          u == null ? o(c) : l(u);
        }) : o(r.apply(this, a));
      }, "async")
    });
  }
  i(Lpe, "newGenerator");
  function jpe(e) {
    return WA(e.name, e.length, function(...t) {
      return e.apply(this, t);
    });
  }
  i(jpe, "wrapGenerator");
  function gm({ name: e, arity: t, sync: r, async: s }) {
    return WA(e, t, function* (...n) {
      let a = yield qA;
      if (!a)
        return r.call(this, n);
      let o;
      try {
        s.call(
          this,
          n,
          (l) => {
            o || (o = { value: l }, a());
          },
          (l) => {
            o || (o = { err: l }, a());
          }
        );
      } catch (l) {
        o = { err: l }, a();
      }
      if (yield UA, o.hasOwnProperty("err"))
        throw o.err;
      return o.value;
    });
  }
  i(gm, "buildOperation");
  function Tm(e) {
    let t;
    for (; !({ value: t } = e.next()).done; )
      VA(t, e);
    return t;
  }
  i(Tm, "evaluateSync");
  function pc(e, t, r) {
    (/* @__PURE__ */ i(function s() {
      try {
        let n;
        for (; !({ value: n } = e.next()).done; ) {
          VA(n, e);
          let a = !0, o = !1, l = e.next(() => {
            a ? o = !0 : s();
          });
          if (a = !1, Mpe(l, e), !o)
            return;
        }
        return t(n);
      } catch (n) {
        return r(n);
      }
    }, "step"))();
  }
  i(pc, "evaluateAsync");
  function VA(e, t) {
    e !== qA && KA(
      t,
      zn(
        `Got unexpected yielded value in gensync generator: ${JSON.stringify(
          e
        )}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,
        Npe
      )
    );
  }
  i(VA, "assertStart");
  function Mpe({ value: e, done: t }, r) {
    !t && e === UA || KA(
      r,
      zn(
        t ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(
          e
        )}. If you get this, it is probably a gensync bug.`,
        Bpe
      )
    );
  }
  i(Mpe, "assertSuspend");
  function KA(e, t) {
    throw e.throw && e.throw(t), t;
  }
  i(KA, "throwError");
  function WA(e, t, r) {
    if (typeof e == "string") {
      let s = Object.getOwnPropertyDescriptor(r, "name");
      (!s || s.configurable) && Object.defineProperty(
        r,
        "name",
        Object.assign(s || {}, {
          configurable: !0,
          value: e
        })
      );
    }
    if (typeof t == "number") {
      let s = Object.getOwnPropertyDescriptor(r, "length");
      (!s || s.configurable) && Object.defineProperty(
        r,
        "length",
        Object.assign(s || {}, {
          configurable: !0,
          value: t
        })
      );
    }
    return r;
  }
  i(WA, "setFunctionMetadata");
});

// ../node_modules/@babel/core/lib/gensync-utils/async.js
var un = D((Kr) => {
  "use strict";
  Object.defineProperty(Kr, "__esModule", {
    value: !0
  });
  Kr.forwardAsync = Upe;
  Kr.isAsync = void 0;
  Kr.isThenable = XA;
  Kr.maybeAsync = Rpe;
  Kr.waitFor = Kr.onFirstPause = void 0;
  function ln() {
    let e = ir();
    return ln = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(ln, "_gensync");
  function HA(e, t, r, s, n, a, o) {
    try {
      var l = e[a](o), u = l.value;
    } catch (c) {
      return void r(c);
    }
    l.done ? t(u) : Promise.resolve(u).then(s, n);
  }
  i(HA, "asyncGeneratorStep");
  function GA(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(s, n) {
        var a = e.apply(t, r);
        function o(u) {
          HA(a, s, n, o, l, "next", u);
        }
        i(o, "_next");
        function l(u) {
          HA(a, s, n, o, l, "throw", u);
        }
        i(l, "_throw"), o(void 0);
      });
    };
  }
  i(GA, "_asyncToGenerator");
  var JA = ln()(function* (e) {
    return yield* e;
  }), d5e = Kr.isAsync = ln()({
    sync: /* @__PURE__ */ i(() => !1, "sync"),
    errback: /* @__PURE__ */ i((e) => e(null, !0), "errback")
  });
  function Rpe(e, t) {
    return ln()({
      sync(...r) {
        let s = e.apply(this, r);
        if (XA(s)) throw new Error(t);
        return s;
      },
      async(...r) {
        return Promise.resolve(e.apply(this, r));
      }
    });
  }
  i(Rpe, "maybeAsync");
  var qpe = ln()({
    sync: /* @__PURE__ */ i((e) => e("sync"), "sync"),
    async: function() {
      var e = GA(function* (t) {
        return t("async");
      });
      return /* @__PURE__ */ i(function(r) {
        return e.apply(this, arguments);
      }, "async");
    }()
  });
  function Upe(e, t) {
    let r = ln()(e);
    return qpe((s) => {
      let n = r[s];
      return t(n);
    });
  }
  i(Upe, "forwardAsync");
  var h5e = Kr.onFirstPause = ln()({
    name: "onFirstPause",
    arity: 2,
    sync: /* @__PURE__ */ i(function(e) {
      return JA.sync(e);
    }, "sync"),
    errback: /* @__PURE__ */ i(function(e, t, r) {
      let s = !1;
      JA.errback(e, (n, a) => {
        s = !0, r(n, a);
      }), s || t();
    }, "errback")
  }), m5e = Kr.waitFor = ln()({
    sync: /* @__PURE__ */ i((e) => e, "sync"),
    async: function() {
      var e = GA(function* (t) {
        return t;
      });
      return /* @__PURE__ */ i(function(r) {
        return e.apply(this, arguments);
      }, "async");
    }()
  });
  function XA(e) {
    return !!e && (typeof e == "object" || typeof e == "function") && !!e.then && typeof e.then == "function";
  }
  i(XA, "isThenable");
});

// ../node_modules/@babel/core/lib/config/util.js
var dc = D((fc) => {
  "use strict";
  Object.defineProperty(fc, "__esModule", {
    value: !0
  });
  fc.isIterableIterator = Kpe;
  fc.mergeOptions = $pe;
  function $pe(e, t) {
    for (let r of Object.keys(t))
      if ((r === "parserOpts" || r === "generatorOpts" || r === "assumptions") && t[r]) {
        let s = t[r], n = e[r] || (e[r] = {});
        Vpe(n, s);
      } else {
        let s = t[r];
        s !== void 0 && (e[r] = s);
      }
  }
  i($pe, "mergeOptions");
  function Vpe(e, t) {
    for (let r of Object.keys(t)) {
      let s = t[r];
      s !== void 0 && (e[r] = s);
    }
  }
  i(Vpe, "mergeDefaultFields");
  function Kpe(e) {
    return !!e && typeof e.next == "function" && typeof e[Symbol.iterator] == "function";
  }
  i(Kpe, "isIterableIterator");
});

// ../node_modules/@babel/core/lib/config/caching.js
var Zn = D((Qn) => {
  "use strict";
  Object.defineProperty(Qn, "__esModule", {
    value: !0
  });
  Qn.assertSimpleType = hc;
  Qn.makeStrongCache = t3;
  Qn.makeStrongCacheSync = Jpe;
  Qn.makeWeakCache = e3;
  Qn.makeWeakCacheSync = Hpe;
  function QA() {
    let e = ir();
    return QA = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(QA, "_gensync");
  var Ji = un(), Wpe = dc(), ZA = /* @__PURE__ */ i((e) => QA()(e).sync, "synchronize");
  function* Ype() {
    return !0;
  }
  i(Ype, "genTrue");
  function e3(e) {
    return r3(WeakMap, e);
  }
  i(e3, "makeWeakCache");
  function Hpe(e) {
    return ZA(e3(e));
  }
  i(Hpe, "makeWeakCacheSync");
  function t3(e) {
    return r3(Map, e);
  }
  i(t3, "makeStrongCache");
  function Jpe(e) {
    return ZA(t3(e));
  }
  i(Jpe, "makeStrongCacheSync");
  function r3(e, t) {
    let r = new e(), s = new e(), n = new e();
    return /* @__PURE__ */ i(function* (o, l) {
      let u = yield* (0, Ji.isAsync)(), c = u ? s : r, p = yield* Gpe(u, c, n, o, l);
      if (p.valid) return p.value;
      let f = new xm(l), h = t(o, f), b, T;
      return (0, Wpe.isIterableIterator)(h) ? T = yield* (0, Ji.onFirstPause)(h, () => {
        b = Xpe(f, n, o);
      }) : T = h, s3(c, f, o, T), b && (n.delete(o), b.release(T)), T;
    }, "cachedFunction");
  }
  i(r3, "makeCachedFunction");
  function* zA(e, t, r) {
    let s = e.get(t);
    if (s) {
      for (let {
        value: n,
        valid: a
      } of s)
        if (yield* a(r)) return {
          valid: !0,
          value: n
        };
    }
    return {
      valid: !1,
      value: null
    };
  }
  i(zA, "getCachedValue");
  function* Gpe(e, t, r, s, n) {
    let a = yield* zA(t, s, n);
    if (a.valid)
      return a;
    if (e) {
      let o = yield* zA(r, s, n);
      if (o.valid)
        return {
          valid: !0,
          value: yield* (0, Ji.waitFor)(o.value.promise)
        };
    }
    return {
      valid: !1,
      value: null
    };
  }
  i(Gpe, "getCachedValueOrWait");
  function Xpe(e, t, r) {
    let s = new Em();
    return s3(t, e, r, s), s;
  }
  i(Xpe, "setupAsyncLocks");
  function s3(e, t, r, s) {
    t.configured() || t.forever();
    let n = e.get(r);
    switch (t.deactivate(), t.mode()) {
      case "forever":
        n = [{
          value: s,
          valid: Ype
        }], e.set(r, n);
        break;
      case "invalidate":
        n = [{
          value: s,
          valid: t.validator()
        }], e.set(r, n);
        break;
      case "valid":
        n ? n.push({
          value: s,
          valid: t.validator()
        }) : (n = [{
          value: s,
          valid: t.validator()
        }], e.set(r, n));
    }
  }
  i(s3, "updateFunctionCache");
  var xm = class {
    static {
      i(this, "CacheConfigurator");
    }
    constructor(t) {
      this._active = !0, this._never = !1, this._forever = !1, this._invalidate = !1, this._configured = !1, this._pairs = [], this._data = void 0,
      this._data = t;
    }
    simple() {
      return zpe(this);
    }
    mode() {
      return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
    }
    forever() {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never)
        throw new Error("Caching has already been configured with .never()");
      this._forever = !0, this._configured = !0;
    }
    never() {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._forever)
        throw new Error("Caching has already been configured with .forever()");
      this._never = !0, this._configured = !0;
    }
    using(t) {
      if (!this._active)
        throw new Error("Cannot change caching after evaluation has completed.");
      if (this._never || this._forever)
        throw new Error("Caching has already been configured with .never or .forever()");
      this._configured = !0;
      let r = t(this._data), s = (0, Ji.maybeAsync)(t, "You appear to be using an async cache handler, but Babel has been called synchronous\
ly");
      return (0, Ji.isThenable)(r) ? r.then((n) => (this._pairs.push([n, s]), n)) : (this._pairs.push([r, s]), r);
    }
    invalidate(t) {
      return this._invalidate = !0, this.using(t);
    }
    validator() {
      let t = this._pairs;
      return function* (r) {
        for (let [s, n] of t)
          if (s !== (yield* n(r))) return !1;
        return !0;
      };
    }
    deactivate() {
      this._active = !1;
    }
    configured() {
      return this._configured;
    }
  };
  function zpe(e) {
    function t(r) {
      if (typeof r == "boolean") {
        r ? e.forever() : e.never();
        return;
      }
      return e.using(() => hc(r()));
    }
    return i(t, "cacheFn"), t.forever = () => e.forever(), t.never = () => e.never(), t.using = (r) => e.using(() => hc(r())), t.invalidate =
    (r) => e.invalidate(() => hc(r())), t;
  }
  i(zpe, "makeSimpleConfigurator");
  function hc(e) {
    if ((0, Ji.isThenable)(e))
      throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add suppo\
rt for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchron\
ously handle your caching logic.");
    if (e != null && typeof e != "string" && typeof e != "boolean" && typeof e != "number")
      throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    return e;
  }
  i(hc, "assertSimpleType");
  var Em = class {
    static {
      i(this, "Lock");
    }
    constructor() {
      this.released = !1, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((t) => {
        this._resolve = t;
      });
    }
    release(t) {
      this.released = !0, this._resolve(t);
    }
  };
});

// ../node_modules/@babel/core/lib/gensync-utils/fs.js
var mc = D((Gi) => {
  "use strict";
  Object.defineProperty(Gi, "__esModule", {
    value: !0
  });
  Gi.stat = Gi.readFile = void 0;
  function Io() {
    let e = z("fs");
    return Io = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs"), e;
  }
  i(Io, "_fs");
  function Sm() {
    let e = ir();
    return Sm = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(Sm, "_gensync");
  var S5e = Gi.readFile = Sm()({
    sync: Io().readFileSync,
    errback: Io().readFile
  }), v5e = Gi.stat = Sm()({
    sync: Io().statSync,
    errback: Io().stat
  });
});

// ../node_modules/@babel/core/lib/config/files/utils.js
var Am = D((Pm) => {
  "use strict";
  Object.defineProperty(Pm, "__esModule", {
    value: !0
  });
  Pm.makeStaticFileCache = efe;
  var Qpe = Zn(), Zpe = mc();
  function vm() {
    let e = z("fs");
    return vm = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs2"), e;
  }
  i(vm, "_fs2");
  function efe(e) {
    return (0, Qpe.makeStrongCache)(function* (t, r) {
      return r.invalidate(() => tfe(t)) === null ? null : e(t, yield* Zpe.readFile(t, "utf8"));
    });
  }
  i(efe, "makeStaticFileCache");
  function tfe(e) {
    if (!vm().existsSync(e)) return null;
    try {
      return +vm().statSync(e).mtime;
    } catch (t) {
      if (t.code !== "ENOENT" && t.code !== "ENOTDIR") throw t;
    }
    return null;
  }
  i(tfe, "fileMtime");
});

// ../node_modules/@babel/core/lib/errors/rewrite-stack-trace.js
var ws = D((Xi) => {
  "use strict";
  Object.defineProperty(Xi, "__esModule", {
    value: !0
  });
  Xi.beginHiddenCallStack = ife;
  Xi.endHiddenCallStack = afe;
  Xi.expectedError = nfe;
  Xi.injectVirtualStackFrame = sfe;
  var n3, i3 = Function.call.bind(Error.prototype.toString), bc = !!Error.captureStackTrace && ((n3 = Object.getOwnPropertyDescriptor(Error,
  "stackTraceLimit")) == null ? void 0 : n3.writable) === !0, a3 = "startHiding - secret - don't use this - v1", o3 = "stopHiding - secret -\
 don't use this - v1", l3 = /* @__PURE__ */ new WeakSet(), yc = /* @__PURE__ */ new WeakMap();
  function rfe(e) {
    return /* @__PURE__ */ Object.create({
      isNative: /* @__PURE__ */ i(() => !1, "isNative"),
      isConstructor: /* @__PURE__ */ i(() => !1, "isConstructor"),
      isToplevel: /* @__PURE__ */ i(() => !0, "isToplevel"),
      getFileName: /* @__PURE__ */ i(() => e, "getFileName"),
      getLineNumber: /* @__PURE__ */ i(() => {
      }, "getLineNumber"),
      getColumnNumber: /* @__PURE__ */ i(() => {
      }, "getColumnNumber"),
      getFunctionName: /* @__PURE__ */ i(() => {
      }, "getFunctionName"),
      getMethodName: /* @__PURE__ */ i(() => {
      }, "getMethodName"),
      getTypeName: /* @__PURE__ */ i(() => {
      }, "getTypeName"),
      toString: /* @__PURE__ */ i(() => e, "toString")
    });
  }
  i(rfe, "CallSite");
  function sfe(e, t) {
    if (!bc) return;
    let r = yc.get(e);
    return r || yc.set(e, r = []), r.push(rfe(t)), e;
  }
  i(sfe, "injectVirtualStackFrame");
  function nfe(e) {
    if (bc)
      return l3.add(e), e;
  }
  i(nfe, "expectedError");
  function ife(e) {
    return bc ? Object.defineProperty(function(...t) {
      return u3(), e(...t);
    }, "name", {
      value: o3
    }) : e;
  }
  i(ife, "beginHiddenCallStack");
  function afe(e) {
    return bc ? Object.defineProperty(function(...t) {
      return e(...t);
    }, "name", {
      value: a3
    }) : e;
  }
  i(afe, "endHiddenCallStack");
  function u3() {
    u3 = /* @__PURE__ */ i(() => {
    }, "setupPrepareStackTrace");
    let {
      prepareStackTrace: e = ofe
    } = Error, t = 50;
    Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, t)), Error.prepareStackTrace = /* @__PURE__ */ i(function(s, n) {
      let a = [], l = l3.has(s) ? "hiding" : "unknown";
      for (let u = 0; u < n.length; u++) {
        let c = n[u].getFunctionName();
        if (c === a3)
          l = "hiding";
        else if (c === o3) {
          if (l === "hiding")
            l = "showing", yc.has(s) && a.unshift(...yc.get(s));
          else if (l === "unknown") {
            a = n;
            break;
          }
        } else l !== "hiding" && a.push(n[u]);
      }
      return e(s, a);
    }, "stackTraceRewriter");
  }
  i(u3, "setupPrepareStackTrace");
  function ofe(e, t) {
    return t.length === 0 ? i3(e) : `${i3(e)}
    at ${t.join(`
    at `)}`;
  }
  i(ofe, "defaultPrepareStackTrace");
});

// ../node_modules/@babel/core/lib/errors/config-error.js
var ei = D((gc) => {
  "use strict";
  Object.defineProperty(gc, "__esModule", {
    value: !0
  });
  gc.default = void 0;
  var c3 = ws(), Cm = class extends Error {
    static {
      i(this, "ConfigError");
    }
    constructor(t, r) {
      super(t), (0, c3.expectedError)(this), r && (0, c3.injectVirtualStackFrame)(this, r);
    }
  };
  gc.default = Cm;
});

// ../node_modules/@babel/core/lib/config/files/package.js
var p3 = D((Dm) => {
  "use strict";
  Object.defineProperty(Dm, "__esModule", {
    value: !0
  });
  Dm.findPackageData = pfe;
  function zi() {
    let e = z("path");
    return zi = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(zi, "_path");
  var lfe = Am(), wm = ei(), ufe = "package.json", cfe = (0, lfe.makeStaticFileCache)((e, t) => {
    let r;
    try {
      r = JSON.parse(t);
    } catch (s) {
      throw new wm.default(`Error while parsing JSON - ${s.message}`, e);
    }
    if (!r) throw new Error(`${e}: No config detected`);
    if (typeof r != "object")
      throw new wm.default(`Config returned typeof ${typeof r}`, e);
    if (Array.isArray(r))
      throw new wm.default("Expected config object but found array", e);
    return {
      filepath: e,
      dirname: zi().dirname(e),
      options: r
    };
  });
  function* pfe(e) {
    let t = null, r = [], s = !0, n = zi().dirname(e);
    for (; !t && zi().basename(n) !== "node_modules"; ) {
      r.push(n), t = yield* cfe(zi().join(n, ufe));
      let a = zi().dirname(n);
      if (n === a) {
        s = !1;
        break;
      }
      n = a;
    }
    return {
      filepath: e,
      directories: r,
      pkg: t,
      isPackage: s
    };
  }
  i(pfe, "findPackageData");
});

// ../node_modules/json5/lib/unicode.js
var f3 = D((k5e, Tc) => {
  Tc.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
  Tc.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
  Tc.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
});

// ../node_modules/json5/lib/util.js
var Im = D((F5e, d3) => {
  var _m = f3();
  d3.exports = {
    isSpaceSeparator(e) {
      return typeof e == "string" && _m.Space_Separator.test(e);
    },
    isIdStartChar(e) {
      return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e === "$" || e === "_" || _m.ID_Start.test(e));
    },
    isIdContinueChar(e) {
      return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e >= "0" && e <= "9" || e === "$" || e === "_" || e ===
      "\u200C" || e === "\u200D" || _m.ID_Continue.test(e));
    },
    isDigit(e) {
      return typeof e == "string" && /[0-9]/.test(e);
    },
    isHexDigit(e) {
      return typeof e == "string" && /[0-9A-Fa-f]/.test(e);
    }
  };
});

// ../node_modules/json5/lib/parse.js
var g3 = D((L5e, b3) => {
  var ht = Im(), Nm, Gt, _s, Ec, cn, Wr, mt, Fm, No;
  b3.exports = /* @__PURE__ */ i(function(t, r) {
    Nm = String(t), Gt = "start", _s = [], Ec = 0, cn = 1, Wr = 0, mt = void 0, Fm = void 0, No = void 0;
    do
      mt = ffe(), mfe[Gt]();
    while (mt.type !== "eof");
    return typeof r == "function" ? Bm({ "": No }, "", r) : No;
  }, "parse");
  function Bm(e, t, r) {
    let s = e[t];
    if (s != null && typeof s == "object")
      if (Array.isArray(s))
        for (let n = 0; n < s.length; n++) {
          let a = String(n), o = Bm(s, a, r);
          o === void 0 ? delete s[a] : Object.defineProperty(s, a, {
            value: o,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
      else
        for (let n in s) {
          let a = Bm(s, n, r);
          a === void 0 ? delete s[n] : Object.defineProperty(s, n, {
            value: a,
            writable: !0,
            enumerable: !0,
            configurable: !0
          });
        }
    return r.call(e, t, s);
  }
  i(Bm, "internalize");
  var ge, de, Oo, Ds, Pe;
  function ffe() {
    for (ge = "default", de = "", Oo = !1, Ds = 1; ; ) {
      Pe = Is();
      let e = m3[ge]();
      if (e)
        return e;
    }
  }
  i(ffe, "lex");
  function Is() {
    if (Nm[Ec])
      return String.fromCodePoint(Nm.codePointAt(Ec));
  }
  i(Is, "peek");
  function $() {
    let e = Is();
    return e === `
` ? (cn++, Wr = 0) : e ? Wr += e.length : Wr++, e && (Ec += e.length), e;
  }
  i($, "read");
  var m3 = {
    default() {
      switch (Pe) {
        case "	":
        case "\v":
        case "\f":
        case " ":
        case "\xA0":
        case "\uFEFF":
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          $();
          return;
        case "/":
          $(), ge = "comment";
          return;
        case void 0:
          return $(), Ke("eof");
      }
      if (ht.isSpaceSeparator(Pe)) {
        $();
        return;
      }
      return m3[Gt]();
    },
    comment() {
      switch (Pe) {
        case "*":
          $(), ge = "multiLineComment";
          return;
        case "/":
          $(), ge = "singleLineComment";
          return;
      }
      throw We($());
    },
    multiLineComment() {
      switch (Pe) {
        case "*":
          $(), ge = "multiLineCommentAsterisk";
          return;
        case void 0:
          throw We($());
      }
      $();
    },
    multiLineCommentAsterisk() {
      switch (Pe) {
        case "*":
          $();
          return;
        case "/":
          $(), ge = "default";
          return;
        case void 0:
          throw We($());
      }
      $(), ge = "multiLineComment";
    },
    singleLineComment() {
      switch (Pe) {
        case `
`:
        case "\r":
        case "\u2028":
        case "\u2029":
          $(), ge = "default";
          return;
        case void 0:
          return $(), Ke("eof");
      }
      $();
    },
    value() {
      switch (Pe) {
        case "{":
        case "[":
          return Ke("punctuator", $());
        case "n":
          return $(), ti("ull"), Ke("null", null);
        case "t":
          return $(), ti("rue"), Ke("boolean", !0);
        case "f":
          return $(), ti("alse"), Ke("boolean", !1);
        case "-":
        case "+":
          $() === "-" && (Ds = -1), ge = "sign";
          return;
        case ".":
          de = $(), ge = "decimalPointLeading";
          return;
        case "0":
          de = $(), ge = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          de = $(), ge = "decimalInteger";
          return;
        case "I":
          return $(), ti("nfinity"), Ke("numeric", 1 / 0);
        case "N":
          return $(), ti("aN"), Ke("numeric", NaN);
        case '"':
        case "'":
          Oo = $() === '"', de = "", ge = "string";
          return;
      }
      throw We($());
    },
    identifierNameStartEscape() {
      if (Pe !== "u")
        throw We($());
      $();
      let e = km();
      switch (e) {
        case "$":
        case "_":
          break;
        default:
          if (!ht.isIdStartChar(e))
            throw h3();
          break;
      }
      de += e, ge = "identifierName";
    },
    identifierName() {
      switch (Pe) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          de += $();
          return;
        case "\\":
          $(), ge = "identifierNameEscape";
          return;
      }
      if (ht.isIdContinueChar(Pe)) {
        de += $();
        return;
      }
      return Ke("identifier", de);
    },
    identifierNameEscape() {
      if (Pe !== "u")
        throw We($());
      $();
      let e = km();
      switch (e) {
        case "$":
        case "_":
        case "\u200C":
        case "\u200D":
          break;
        default:
          if (!ht.isIdContinueChar(e))
            throw h3();
          break;
      }
      de += e, ge = "identifierName";
    },
    sign() {
      switch (Pe) {
        case ".":
          de = $(), ge = "decimalPointLeading";
          return;
        case "0":
          de = $(), ge = "zero";
          return;
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          de = $(), ge = "decimalInteger";
          return;
        case "I":
          return $(), ti("nfinity"), Ke("numeric", Ds * (1 / 0));
        case "N":
          return $(), ti("aN"), Ke("numeric", NaN);
      }
      throw We($());
    },
    zero() {
      switch (Pe) {
        case ".":
          de += $(), ge = "decimalPoint";
          return;
        case "e":
        case "E":
          de += $(), ge = "decimalExponent";
          return;
        case "x":
        case "X":
          de += $(), ge = "hexadecimal";
          return;
      }
      return Ke("numeric", Ds * 0);
    },
    decimalInteger() {
      switch (Pe) {
        case ".":
          de += $(), ge = "decimalPoint";
          return;
        case "e":
        case "E":
          de += $(), ge = "decimalExponent";
          return;
      }
      if (ht.isDigit(Pe)) {
        de += $();
        return;
      }
      return Ke("numeric", Ds * Number(de));
    },
    decimalPointLeading() {
      if (ht.isDigit(Pe)) {
        de += $(), ge = "decimalFraction";
        return;
      }
      throw We($());
    },
    decimalPoint() {
      switch (Pe) {
        case "e":
        case "E":
          de += $(), ge = "decimalExponent";
          return;
      }
      if (ht.isDigit(Pe)) {
        de += $(), ge = "decimalFraction";
        return;
      }
      return Ke("numeric", Ds * Number(de));
    },
    decimalFraction() {
      switch (Pe) {
        case "e":
        case "E":
          de += $(), ge = "decimalExponent";
          return;
      }
      if (ht.isDigit(Pe)) {
        de += $();
        return;
      }
      return Ke("numeric", Ds * Number(de));
    },
    decimalExponent() {
      switch (Pe) {
        case "+":
        case "-":
          de += $(), ge = "decimalExponentSign";
          return;
      }
      if (ht.isDigit(Pe)) {
        de += $(), ge = "decimalExponentInteger";
        return;
      }
      throw We($());
    },
    decimalExponentSign() {
      if (ht.isDigit(Pe)) {
        de += $(), ge = "decimalExponentInteger";
        return;
      }
      throw We($());
    },
    decimalExponentInteger() {
      if (ht.isDigit(Pe)) {
        de += $();
        return;
      }
      return Ke("numeric", Ds * Number(de));
    },
    hexadecimal() {
      if (ht.isHexDigit(Pe)) {
        de += $(), ge = "hexadecimalInteger";
        return;
      }
      throw We($());
    },
    hexadecimalInteger() {
      if (ht.isHexDigit(Pe)) {
        de += $();
        return;
      }
      return Ke("numeric", Ds * Number(de));
    },
    string() {
      switch (Pe) {
        case "\\":
          $(), de += dfe();
          return;
        case '"':
          if (Oo)
            return $(), Ke("string", de);
          de += $();
          return;
        case "'":
          if (!Oo)
            return $(), Ke("string", de);
          de += $();
          return;
        case `
`:
        case "\r":
          throw We($());
        case "\u2028":
        case "\u2029":
          yfe(Pe);
          break;
        case void 0:
          throw We($());
      }
      de += $();
    },
    start() {
      switch (Pe) {
        case "{":
        case "[":
          return Ke("punctuator", $());
      }
      ge = "value";
    },
    beforePropertyName() {
      switch (Pe) {
        case "$":
        case "_":
          de = $(), ge = "identifierName";
          return;
        case "\\":
          $(), ge = "identifierNameStartEscape";
          return;
        case "}":
          return Ke("punctuator", $());
        case '"':
        case "'":
          Oo = $() === '"', ge = "string";
          return;
      }
      if (ht.isIdStartChar(Pe)) {
        de += $(), ge = "identifierName";
        return;
      }
      throw We($());
    },
    afterPropertyName() {
      if (Pe === ":")
        return Ke("punctuator", $());
      throw We($());
    },
    beforePropertyValue() {
      ge = "value";
    },
    afterPropertyValue() {
      switch (Pe) {
        case ",":
        case "}":
          return Ke("punctuator", $());
      }
      throw We($());
    },
    beforeArrayValue() {
      if (Pe === "]")
        return Ke("punctuator", $());
      ge = "value";
    },
    afterArrayValue() {
      switch (Pe) {
        case ",":
        case "]":
          return Ke("punctuator", $());
      }
      throw We($());
    },
    end() {
      throw We($());
    }
  };
  function Ke(e, t) {
    return {
      type: e,
      value: t,
      line: cn,
      column: Wr
    };
  }
  i(Ke, "newToken");
  function ti(e) {
    for (let t of e) {
      if (Is() !== t)
        throw We($());
      $();
    }
  }
  i(ti, "literal");
  function dfe() {
    switch (Is()) {
      case "b":
        return $(), "\b";
      case "f":
        return $(), "\f";
      case "n":
        return $(), `
`;
      case "r":
        return $(), "\r";
      case "t":
        return $(), "	";
      case "v":
        return $(), "\v";
      case "0":
        if ($(), ht.isDigit(Is()))
          throw We($());
        return "\0";
      case "x":
        return $(), hfe();
      case "u":
        return $(), km();
      case `
`:
      case "\u2028":
      case "\u2029":
        return $(), "";
      case "\r":
        return $(), Is() === `
` && $(), "";
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        throw We($());
      case void 0:
        throw We($());
    }
    return $();
  }
  i(dfe, "escape");
  function hfe() {
    let e = "", t = Is();
    if (!ht.isHexDigit(t) || (e += $(), t = Is(), !ht.isHexDigit(t)))
      throw We($());
    return e += $(), String.fromCodePoint(parseInt(e, 16));
  }
  i(hfe, "hexEscape");
  function km() {
    let e = "", t = 4;
    for (; t-- > 0; ) {
      let r = Is();
      if (!ht.isHexDigit(r))
        throw We($());
      e += $();
    }
    return String.fromCodePoint(parseInt(e, 16));
  }
  i(km, "unicodeEscape");
  var mfe = {
    start() {
      if (mt.type === "eof")
        throw ri();
      Om();
    },
    beforePropertyName() {
      switch (mt.type) {
        case "identifier":
        case "string":
          Fm = mt.value, Gt = "afterPropertyName";
          return;
        case "punctuator":
          xc();
          return;
        case "eof":
          throw ri();
      }
    },
    afterPropertyName() {
      if (mt.type === "eof")
        throw ri();
      Gt = "beforePropertyValue";
    },
    beforePropertyValue() {
      if (mt.type === "eof")
        throw ri();
      Om();
    },
    beforeArrayValue() {
      if (mt.type === "eof")
        throw ri();
      if (mt.type === "punctuator" && mt.value === "]") {
        xc();
        return;
      }
      Om();
    },
    afterPropertyValue() {
      if (mt.type === "eof")
        throw ri();
      switch (mt.value) {
        case ",":
          Gt = "beforePropertyName";
          return;
        case "}":
          xc();
      }
    },
    afterArrayValue() {
      if (mt.type === "eof")
        throw ri();
      switch (mt.value) {
        case ",":
          Gt = "beforeArrayValue";
          return;
        case "]":
          xc();
      }
    },
    end() {
    }
  };
  function Om() {
    let e;
    switch (mt.type) {
      case "punctuator":
        switch (mt.value) {
          case "{":
            e = {};
            break;
          case "[":
            e = [];
            break;
        }
        break;
      case "null":
      case "boolean":
      case "numeric":
      case "string":
        e = mt.value;
        break;
    }
    if (No === void 0)
      No = e;
    else {
      let t = _s[_s.length - 1];
      Array.isArray(t) ? t.push(e) : Object.defineProperty(t, Fm, {
        value: e,
        writable: !0,
        enumerable: !0,
        configurable: !0
      });
    }
    if (e !== null && typeof e == "object")
      _s.push(e), Array.isArray(e) ? Gt = "beforeArrayValue" : Gt = "beforePropertyName";
    else {
      let t = _s[_s.length - 1];
      t == null ? Gt = "end" : Array.isArray(t) ? Gt = "afterArrayValue" : Gt = "afterPropertyValue";
    }
  }
  i(Om, "push");
  function xc() {
    _s.pop();
    let e = _s[_s.length - 1];
    e == null ? Gt = "end" : Array.isArray(e) ? Gt = "afterArrayValue" : Gt = "afterPropertyValue";
  }
  i(xc, "pop");
  function We(e) {
    return Sc(e === void 0 ? `JSON5: invalid end of input at ${cn}:${Wr}` : `JSON5: invalid character '${y3(e)}' at ${cn}:${Wr}`);
  }
  i(We, "invalidChar");
  function ri() {
    return Sc(`JSON5: invalid end of input at ${cn}:${Wr}`);
  }
  i(ri, "invalidEOF");
  function h3() {
    return Wr -= 5, Sc(`JSON5: invalid identifier character at ${cn}:${Wr}`);
  }
  i(h3, "invalidIdentifier");
  function yfe(e) {
    console.warn(`JSON5: '${y3(e)}' in strings is not valid ECMAScript; consider escaping`);
  }
  i(yfe, "separatorChar");
  function y3(e) {
    let t = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    if (t[e])
      return t[e];
    if (e < " ") {
      let r = e.charCodeAt(0).toString(16);
      return "\\x" + ("00" + r).substring(r.length);
    }
    return e;
  }
  i(y3, "formatChar");
  function Sc(e) {
    let t = new SyntaxError(e);
    return t.lineNumber = cn, t.columnNumber = Wr, t;
  }
  i(Sc, "syntaxError");
});

// ../node_modules/json5/lib/stringify.js
var x3 = D((M5e, T3) => {
  var Lm = Im();
  T3.exports = /* @__PURE__ */ i(function(t, r, s) {
    let n = [], a = "", o, l, u = "", c;
    if (r != null && typeof r == "object" && !Array.isArray(r) && (s = r.space, c = r.quote, r = r.replacer), typeof r == "function")
      l = r;
    else if (Array.isArray(r)) {
      o = [];
      for (let d of r) {
        let g;
        typeof d == "string" ? g = d : (typeof d == "number" || d instanceof String || d instanceof Number) && (g = String(d)), g !== void 0 &&
        o.indexOf(g) < 0 && o.push(g);
      }
    }
    return s instanceof Number ? s = Number(s) : s instanceof String && (s = String(s)), typeof s == "number" ? s > 0 && (s = Math.min(10, Math.
    floor(s)), u = "          ".substr(0, s)) : typeof s == "string" && (u = s.substr(0, 10)), p("", { "": t });
    function p(d, g) {
      let E = g[d];
      switch (E != null && (typeof E.toJSON5 == "function" ? E = E.toJSON5(d) : typeof E.toJSON == "function" && (E = E.toJSON(d))), l && (E =
      l.call(g, d, E)), E instanceof Number ? E = Number(E) : E instanceof String ? E = String(E) : E instanceof Boolean && (E = E.valueOf()),
      E) {
        case null:
          return "null";
        case !0:
          return "true";
        case !1:
          return "false";
      }
      if (typeof E == "string")
        return f(E, !1);
      if (typeof E == "number")
        return String(E);
      if (typeof E == "object")
        return Array.isArray(E) ? T(E) : h(E);
    }
    i(p, "serializeProperty");
    function f(d) {
      let g = {
        "'": 0.1,
        '"': 0.2
      }, E = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      }, _ = "";
      for (let k = 0; k < d.length; k++) {
        let j = d[k];
        switch (j) {
          case "'":
          case '"':
            g[j]++, _ += j;
            continue;
          case "\0":
            if (Lm.isDigit(d[k + 1])) {
              _ += "\\x00";
              continue;
            }
        }
        if (E[j]) {
          _ += E[j];
          continue;
        }
        if (j < " ") {
          let U = j.charCodeAt(0).toString(16);
          _ += "\\x" + ("00" + U).substring(U.length);
          continue;
        }
        _ += j;
      }
      let N = c || Object.keys(g).reduce((k, j) => g[k] < g[j] ? k : j);
      return _ = _.replace(new RegExp(N, "g"), E[N]), N + _ + N;
    }
    i(f, "quoteString");
    function h(d) {
      if (n.indexOf(d) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      n.push(d);
      let g = a;
      a = a + u;
      let E = o || Object.keys(d), _ = [];
      for (let k of E) {
        let j = p(k, d);
        if (j !== void 0) {
          let U = b(k) + ":";
          u !== "" && (U += " "), U += j, _.push(U);
        }
      }
      let N;
      if (_.length === 0)
        N = "{}";
      else {
        let k;
        if (u === "")
          k = _.join(","), N = "{" + k + "}";
        else {
          let j = `,
` + a;
          k = _.join(j), N = `{
` + a + k + `,
` + g + "}";
        }
      }
      return n.pop(), a = g, N;
    }
    i(h, "serializeObject");
    function b(d) {
      if (d.length === 0)
        return f(d, !0);
      let g = String.fromCodePoint(d.codePointAt(0));
      if (!Lm.isIdStartChar(g))
        return f(d, !0);
      for (let E = g.length; E < d.length; E++)
        if (!Lm.isIdContinueChar(String.fromCodePoint(d.codePointAt(E))))
          return f(d, !0);
      return d;
    }
    i(b, "serializeKey");
    function T(d) {
      if (n.indexOf(d) >= 0)
        throw TypeError("Converting circular structure to JSON5");
      n.push(d);
      let g = a;
      a = a + u;
      let E = [];
      for (let N = 0; N < d.length; N++) {
        let k = p(String(N), d);
        E.push(k !== void 0 ? k : "null");
      }
      let _;
      if (E.length === 0)
        _ = "[]";
      else if (u === "")
        _ = "[" + E.join(",") + "]";
      else {
        let N = `,
` + a, k = E.join(N);
        _ = `[
` + a + k + `,
` + g + "]";
      }
      return n.pop(), a = g, _;
    }
    i(T, "serializeArray");
  }, "stringify");
});

// ../node_modules/json5/lib/index.js
var S3 = D((q5e, E3) => {
  var bfe = g3(), gfe = x3(), Tfe = {
    parse: bfe,
    stringify: gfe
  };
  E3.exports = Tfe;
});

// ../node_modules/@babel/core/lib/config/helpers/config-api.js
var jm = D((Bo) => {
  "use strict";
  Object.defineProperty(Bo, "__esModule", {
    value: !0
  });
  Bo.makeConfigAPI = A3;
  Bo.makePluginAPI = xfe;
  Bo.makePresetAPI = C3;
  function P3() {
    let e = z("semver");
    return P3 = /* @__PURE__ */ i(function() {
      return e;
    }, "_semver"), e;
  }
  i(P3, "_semver");
  var vc = et(), v3 = Zn();
  function A3(e) {
    let t = /* @__PURE__ */ i((s) => e.using((n) => s === void 0 ? n.envName : typeof s == "function" ? (0, v3.assertSimpleType)(s(n.envName)) :
    (Array.isArray(s) ? s : [s]).some((a) => {
      if (typeof a != "string")
        throw new Error("Unexpected non-string value");
      return a === n.envName;
    })), "env"), r = /* @__PURE__ */ i((s) => e.using((n) => (0, v3.assertSimpleType)(s(n.caller))), "caller");
    return {
      version: vc.version,
      cache: e.simple(),
      env: t,
      async: /* @__PURE__ */ i(() => !1, "async"),
      caller: r,
      assertVersion: Efe
    };
  }
  i(A3, "makeConfigAPI");
  function C3(e, t) {
    let r = /* @__PURE__ */ i(() => JSON.parse(e.using((n) => JSON.stringify(n.targets))), "targets"), s = /* @__PURE__ */ i((n) => {
      t.push(n);
    }, "addExternalDependency");
    return Object.assign({}, A3(e), {
      targets: r,
      addExternalDependency: s
    });
  }
  i(C3, "makePresetAPI");
  function xfe(e, t) {
    let r = /* @__PURE__ */ i((s) => e.using((n) => n.assumptions[s]), "assumption");
    return Object.assign({}, C3(e, t), {
      assumption: r
    });
  }
  i(xfe, "makePluginAPI");
  function Efe(e) {
    if (typeof e == "number") {
      if (!Number.isInteger(e))
        throw new Error("Expected string or integer value.");
      e = `^${e}.0.0-0`;
    }
    if (typeof e != "string")
      throw new Error("Expected string or integer value.");
    if (e === "*" || P3().satisfies(vc.version, e)) return;
    let t = Error.stackTraceLimit;
    typeof t == "number" && t < 25 && (Error.stackTraceLimit = 25);
    let r = new Error(`Requires Babel "${e}", but was loaded with "${vc.version}". If you are sure you have a compatible version of @babel/c\
ore, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the f\
irst entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
    throw typeof t == "number" && (Error.stackTraceLimit = t), Object.assign(r, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: vc.version,
      range: e
    });
  }
  i(Efe, "assertVersion");
});

// ../node_modules/@babel/core/lib/config/helpers/deep-array.js
var Ac = D((Pc) => {
  "use strict";
  Object.defineProperty(Pc, "__esModule", {
    value: !0
  });
  Pc.finalize = Sfe;
  Pc.flattenToSet = vfe;
  function Sfe(e) {
    return Object.freeze(e);
  }
  i(Sfe, "finalize");
  function vfe(e) {
    let t = /* @__PURE__ */ new Set(), r = [e];
    for (; r.length > 0; )
      for (let s of r.pop())
        Array.isArray(s) ? r.push(s) : t.add(s);
    return t;
  }
  i(vfe, "flattenToSet");
});

// ../node_modules/@babel/core/lib/config/plugin.js
var wc = D((Cc) => {
  "use strict";
  Object.defineProperty(Cc, "__esModule", {
    value: !0
  });
  Cc.default = void 0;
  var Pfe = Ac(), Mm = class {
    static {
      i(this, "Plugin");
    }
    constructor(t, r, s, n = (0, Pfe.finalize)([])) {
      this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride =
      void 0, this.generatorOverride = void 0, this.options = void 0, this.externalDependencies = void 0, this.key = t.name || s, this.manipulateOptions =
      t.manipulateOptions, this.post = t.post, this.pre = t.pre, this.visitor = t.visitor || {}, this.parserOverride = t.parserOverride, this.
      generatorOverride = t.generatorOverride, this.options = r, this.externalDependencies = n;
    }
  };
  Cc.default = Mm;
});

// ../node_modules/@babel/core/lib/gensync-utils/functional.js
var D3 = D((Rm) => {
  "use strict";
  Object.defineProperty(Rm, "__esModule", {
    value: !0
  });
  Rm.once = Afe;
  var w3 = un();
  function Afe(e) {
    let t, r, s = !1;
    return function* () {
      if (!t) {
        if (r)
          return s = !0, yield* (0, w3.waitFor)(r);
        if (yield* (0, w3.isAsync)()) {
          let n, a;
          r = new Promise((o, l) => {
            n = o, a = l;
          });
          try {
            t = {
              ok: !0,
              value: yield* e()
            }, r = null, s && n(t.value);
          } catch (o) {
            t = {
              ok: !1,
              value: o
            }, r = null, s && a(o);
          }
        } else
          try {
            t = {
              ok: !0,
              value: yield* e()
            };
          } catch (n) {
            t = {
              ok: !1,
              value: n
            };
          }
      }
      if (t.ok) return t.value;
      throw t.value;
    };
  }
  i(Afe, "once");
});

// ../node_modules/baseline-browser-mapping/dist/index.cjs
var M3 = D((qm) => {
  "use strict";
  var Cfe = { chrome: { releases: [["1", "2008-12-11", "r", "w", "528"], ["2", "2009-05-21", "r", "w", "530"], ["3", "2009-09-15", "r", "w",
  "532"], ["4", "2010-01-25", "r", "w", "532.5"], ["5", "2010-05-25", "r", "w", "533"], ["6", "2010-09-02", "r", "w", "534.3"], ["7", "2010-\
10-19", "r", "w", "534.7"], ["8", "2010-12-02", "r", "w", "534.10"], ["9", "2011-02-03", "r", "w", "534.13"], ["10", "2011-03-08", "r", "w",
  "534.16"], ["11", "2011-04-27", "r", "w", "534.24"], ["12", "2011-06-07", "r", "w", "534.30"], ["13", "2011-08-02", "r", "w", "535.1"], ["\
14", "2011-09-16", "r", "w", "535.1"], ["15", "2011-10-25", "r", "w", "535.2"], ["16", "2011-12-13", "r", "w", "535.7"], ["17", "2012-02-08",
  "r", "w", "535.11"], ["18", "2012-03-28", "r", "w", "535.19"], ["19", "2012-05-15", "r", "w", "536.5"], ["20", "2012-06-26", "r", "w", "53\
6.10"], ["21", "2012-07-31", "r", "w", "537.1"], ["22", "2012-09-25", "r", "w", "537.4"], ["23", "2012-11-06", "r", "w", "537.11"], ["24", "\
2013-01-10", "r", "w", "537.17"], ["25", "2013-02-21", "r", "w", "537.22"], ["26", "2013-03-26", "r", "w", "537.31"], ["27", "2013-05-21", "\
r", "w", "537.36"], ["28", "2013-07-09", "r", "b", "28"], ["29", "2013-08-20", "r", "b", "29"], ["30", "2013-10-01", "r", "b", "30"], ["31",
  "2013-11-12", "r", "b", "31"], ["32", "2014-01-14", "r", "b", "32"], ["33", "2014-02-20", "r", "b", "33"], ["34", "2014-04-08", "r", "b", "\
34"], ["35", "2014-05-20", "r", "b", "35"], ["36", "2014-07-16", "r", "b", "36"], ["37", "2014-08-26", "r", "b", "37"], ["38", "2014-10-07",
  "r", "b", "38"], ["39", "2014-11-18", "r", "b", "39"], ["40", "2015-01-21", "r", "b", "40"], ["41", "2015-03-03", "r", "b", "41"], ["42", "\
2015-04-14", "r", "b", "42"], ["43", "2015-05-19", "r", "b", "43"], ["44", "2015-07-21", "r", "b", "44"], ["45", "2015-09-01", "r", "b", "45"],
  ["46", "2015-10-13", "r", "b", "46"], ["47", "2015-12-01", "r", "b", "47"], ["48", "2016-01-20", "r", "b", "48"], ["49", "2016-03-02", "r",
  "b", "49"], ["50", "2016-04-13", "r", "b", "50"], ["51", "2016-05-25", "r", "b", "51"], ["52", "2016-07-20", "r", "b", "52"], ["53", "2016\
-08-31", "r", "b", "53"], ["54", "2016-10-12", "r", "b", "54"], ["55", "2016-12-01", "r", "b", "55"], ["56", "2017-01-25", "r", "b", "56"], [
  "57", "2017-03-09", "r", "b", "57"], ["58", "2017-04-19", "r", "b", "58"], ["59", "2017-06-05", "r", "b", "59"], ["60", "2017-07-25", "r",
  "b", "60"], ["61", "2017-09-05", "r", "b", "61"], ["62", "2017-10-17", "r", "b", "62"], ["63", "2017-12-06", "r", "b", "63"], ["64", "2018\
-01-23", "r", "b", "64"], ["65", "2018-03-06", "r", "b", "65"], ["66", "2018-04-17", "r", "b", "66"], ["67", "2018-05-29", "r", "b", "67"], [
  "68", "2018-07-24", "r", "b", "68"], ["69", "2018-09-04", "r", "b", "69"], ["70", "2018-10-16", "r", "b", "70"], ["71", "2018-12-04", "r",
  "b", "71"], ["72", "2019-01-29", "r", "b", "72"], ["73", "2019-03-12", "r", "b", "73"], ["74", "2019-04-23", "r", "b", "74"], ["75", "2019\
-06-04", "r", "b", "75"], ["76", "2019-07-30", "r", "b", "76"], ["77", "2019-09-10", "r", "b", "77"], ["78", "2019-10-22", "r", "b", "78"], [
  "79", "2019-12-10", "r", "b", "79"], ["80", "2020-02-04", "r", "b", "80"], ["81", "2020-04-07", "r", "b", "81"], ["83", "2020-05-19", "r",
  "b", "83"], ["84", "2020-07-27", "r", "b", "84"], ["85", "2020-08-25", "r", "b", "85"], ["86", "2020-10-20", "r", "b", "86"], ["87", "2020\
-11-17", "r", "b", "87"], ["88", "2021-01-19", "r", "b", "88"], ["89", "2021-03-02", "r", "b", "89"], ["90", "2021-04-13", "r", "b", "90"], [
  "91", "2021-05-25", "r", "b", "91"], ["92", "2021-07-20", "r", "b", "92"], ["93", "2021-08-31", "r", "b", "93"], ["94", "2021-09-21", "r",
  "b", "94"], ["95", "2021-10-19", "r", "b", "95"], ["96", "2021-11-15", "r", "b", "96"], ["97", "2022-01-04", "r", "b", "97"], ["98", "2022\
-02-01", "r", "b", "98"], ["99", "2022-03-01", "r", "b", "99"], ["100", "2022-03-29", "r", "b", "100"], ["101", "2022-04-26", "r", "b", "101"],
  ["102", "2022-05-24", "r", "b", "102"], ["103", "2022-06-21", "r", "b", "103"], ["104", "2022-08-02", "r", "b", "104"], ["105", "2022-09-0\
2", "r", "b", "105"], ["106", "2022-09-27", "r", "b", "106"], ["107", "2022-10-25", "r", "b", "107"], ["108", "2022-11-29", "r", "b", "108"],
  ["109", "2023-01-10", "r", "b", "109"], ["110", "2023-02-07", "r", "b", "110"], ["111", "2023-03-07", "r", "b", "111"], ["112", "2023-04-0\
4", "r", "b", "112"], ["113", "2023-05-02", "r", "b", "113"], ["114", "2023-05-30", "r", "b", "114"], ["115", "2023-07-18", "r", "b", "115"],
  ["116", "2023-08-15", "r", "b", "116"], ["117", "2023-09-12", "r", "b", "117"], ["118", "2023-10-10", "r", "b", "118"], ["119", "2023-10-3\
1", "r", "b", "119"], ["120", "2023-12-05", "r", "b", "120"], ["121", "2024-01-23", "r", "b", "121"], ["122", "2024-02-20", "r", "b", "122"],
  ["123", "2024-03-19", "r", "b", "123"], ["124", "2024-04-16", "r", "b", "124"], ["125", "2024-05-14", "r", "b", "125"], ["126", "2024-06-1\
1", "r", "b", "126"], ["127", "2024-07-23", "r", "b", "127"], ["128", "2024-08-20", "r", "b", "128"], ["129", "2024-09-17", "r", "b", "129"],
  ["130", "2024-10-15", "r", "b", "130"], ["131", "2024-11-12", "r", "b", "131"], ["132", "2025-01-14", "r", "b", "132"], ["133", "2025-02-0\
4", "r", "b", "133"], ["134", "2025-03-04", "r", "b", "134"], ["135", "2025-04-01", "r", "b", "135"], ["136", "2025-04-29", "r", "b", "136"],
  ["137", "2025-05-27", "r", "b", "137"], ["138", "2025-06-24", "r", "b", "138"], ["139", "2025-08-05", "r", "b", "139"], ["140", "2025-09-0\
2", "c", "b", "140"], ["141", "2025-09-30", "b", "b", "141"], ["142", "2025-10-28", "n", "b", "142"], ["143", null, "p", "b", "143"]] }, chrome_android: {
  releases: [["18", "2012-06-27", "r", "w", "535.19"], ["25", "2013-02-27", "r", "w", "537.22"], ["26", "2013-04-03", "r", "w", "537.31"], [
  "27", "2013-05-22", "r", "w", "537.36"], ["28", "2013-07-10", "r", "b", "28"], ["29", "2013-08-21", "r", "b", "29"], ["30", "2013-10-02", "\
r", "b", "30"], ["31", "2013-11-14", "r", "b", "31"], ["32", "2014-01-15", "r", "b", "32"], ["33", "2014-02-26", "r", "b", "33"], ["34", "20\
14-04-02", "r", "b", "34"], ["35", "2014-05-20", "r", "b", "35"], ["36", "2014-07-16", "r", "b", "36"], ["37", "2014-09-03", "r", "b", "37"],
  ["38", "2014-10-08", "r", "b", "38"], ["39", "2014-11-12", "r", "b", "39"], ["40", "2015-01-21", "r", "b", "40"], ["41", "2015-03-11", "r",
  "b", "41"], ["42", "2015-04-15", "r", "b", "42"], ["43", "2015-05-27", "r", "b", "43"], ["44", "2015-07-29", "r", "b", "44"], ["45", "2015\
-09-01", "r", "b", "45"], ["46", "2015-10-14", "r", "b", "46"], ["47", "2015-12-02", "r", "b", "47"], ["48", "2016-01-26", "r", "b", "48"], [
  "49", "2016-03-09", "r", "b", "49"], ["50", "2016-04-13", "r", "b", "50"], ["51", "2016-06-08", "r", "b", "51"], ["52", "2016-07-27", "r",
  "b", "52"], ["53", "2016-09-07", "r", "b", "53"], ["54", "2016-10-19", "r", "b", "54"], ["55", "2016-12-06", "r", "b", "55"], ["56", "2017\
-02-01", "r", "b", "56"], ["57", "2017-03-16", "r", "b", "57"], ["58", "2017-04-25", "r", "b", "58"], ["59", "2017-06-06", "r", "b", "59"], [
  "60", "2017-08-01", "r", "b", "60"], ["61", "2017-09-05", "r", "b", "61"], ["62", "2017-10-24", "r", "b", "62"], ["63", "2017-12-05", "r",
  "b", "63"], ["64", "2018-01-23", "r", "b", "64"], ["65", "2018-03-06", "r", "b", "65"], ["66", "2018-04-17", "r", "b", "66"], ["67", "2018\
-05-31", "r", "b", "67"], ["68", "2018-07-24", "r", "b", "68"], ["69", "2018-09-04", "r", "b", "69"], ["70", "2018-10-17", "r", "b", "70"], [
  "71", "2018-12-04", "r", "b", "71"], ["72", "2019-01-29", "r", "b", "72"], ["73", "2019-03-12", "r", "b", "73"], ["74", "2019-04-24", "r",
  "b", "74"], ["75", "2019-06-04", "r", "b", "75"], ["76", "2019-07-30", "r", "b", "76"], ["77", "2019-09-10", "r", "b", "77"], ["78", "2019\
-10-22", "r", "b", "78"], ["79", "2019-12-17", "r", "b", "79"], ["80", "2020-02-04", "r", "b", "80"], ["81", "2020-04-07", "r", "b", "81"], [
  "83", "2020-05-19", "r", "b", "83"], ["84", "2020-07-27", "r", "b", "84"], ["85", "2020-08-25", "r", "b", "85"], ["86", "2020-10-20", "r",
  "b", "86"], ["87", "2020-11-17", "r", "b", "87"], ["88", "2021-01-19", "r", "b", "88"], ["89", "2021-03-02", "r", "b", "89"], ["90", "2021\
-04-13", "r", "b", "90"], ["91", "2021-05-25", "r", "b", "91"], ["92", "2021-07-20", "r", "b", "92"], ["93", "2021-08-31", "r", "b", "93"], [
  "94", "2021-09-21", "r", "b", "94"], ["95", "2021-10-19", "r", "b", "95"], ["96", "2021-11-15", "r", "b", "96"], ["97", "2022-01-04", "r",
  "b", "97"], ["98", "2022-02-01", "r", "b", "98"], ["99", "2022-03-01", "r", "b", "99"], ["100", "2022-03-29", "r", "b", "100"], ["101", "2\
022-04-26", "r", "b", "101"], ["102", "2022-05-24", "r", "b", "102"], ["103", "2022-06-21", "r", "b", "103"], ["104", "2022-08-02", "r", "b",
  "104"], ["105", "2022-09-02", "r", "b", "105"], ["106", "2022-09-27", "r", "b", "106"], ["107", "2022-10-25", "r", "b", "107"], ["108", "2\
022-11-29", "r", "b", "108"], ["109", "2023-01-10", "r", "b", "109"], ["110", "2023-02-07", "r", "b", "110"], ["111", "2023-03-07", "r", "b",
  "111"], ["112", "2023-04-04", "r", "b", "112"], ["113", "2023-05-02", "r", "b", "113"], ["114", "2023-05-30", "r", "b", "114"], ["115", "2\
023-07-21", "r", "b", "115"], ["116", "2023-08-15", "r", "b", "116"], ["117", "2023-09-12", "r", "b", "117"], ["118", "2023-10-10", "r", "b",
  "118"], ["119", "2023-10-31", "r", "b", "119"], ["120", "2023-12-05", "r", "b", "120"], ["121", "2024-01-23", "r", "b", "121"], ["122", "2\
024-02-20", "r", "b", "122"], ["123", "2024-03-19", "r", "b", "123"], ["124", "2024-04-16", "r", "b", "124"], ["125", "2024-05-14", "r", "b",
  "125"], ["126", "2024-06-11", "r", "b", "126"], ["127", "2024-07-23", "r", "b", "127"], ["128", "2024-08-20", "r", "b", "128"], ["129", "2\
024-09-17", "r", "b", "129"], ["130", "2024-10-15", "r", "b", "130"], ["131", "2024-11-12", "r", "b", "131"], ["132", "2025-01-14", "r", "b",
  "132"], ["133", "2025-02-04", "r", "b", "133"], ["134", "2025-03-04", "r", "b", "134"], ["135", "2025-04-01", "r", "b", "135"], ["136", "2\
025-04-29", "r", "b", "136"], ["137", "2025-05-27", "r", "b", "137"], ["138", "2025-06-24", "r", "b", "138"], ["139", "2025-08-05", "r", "b",
  "139"], ["140", "2025-09-02", "c", "b", "140"], ["141", "2025-09-30", "b", "b", "141"], ["142", "2025-10-28", "n", "b", "142"], ["143", null,
  "p", "b", "143"]] }, edge: { releases: [["12", "2015-07-29", "r", null, "12"], ["13", "2015-11-12", "r", null, "13"], ["14", "2016-08-02",
  "r", null, "14"], ["15", "2017-04-05", "r", null, "15"], ["16", "2017-10-17", "r", null, "16"], ["17", "2018-04-30", "r", null, "17"], ["1\
8", "2018-10-02", "r", null, "18"], ["79", "2020-01-15", "r", "b", "79"], ["80", "2020-02-07", "r", "b", "80"], ["81", "2020-04-13", "r", "b",
  "81"], ["83", "2020-05-21", "r", "b", "83"], ["84", "2020-07-16", "r", "b", "84"], ["85", "2020-08-27", "r", "b", "85"], ["86", "2020-10-0\
9", "r", "b", "86"], ["87", "2020-11-19", "r", "b", "87"], ["88", "2021-01-21", "r", "b", "88"], ["89", "2021-03-04", "r", "b", "89"], ["90",
  "2021-04-15", "r", "b", "90"], ["91", "2021-05-27", "r", "b", "91"], ["92", "2021-07-22", "r", "b", "92"], ["93", "2021-09-02", "r", "b", "\
93"], ["94", "2021-09-24", "r", "b", "94"], ["95", "2021-10-21", "r", "b", "95"], ["96", "2021-11-19", "r", "b", "96"], ["97", "2022-01-06",
  "r", "b", "97"], ["98", "2022-02-03", "r", "b", "98"], ["99", "2022-03-03", "r", "b", "99"], ["100", "2022-04-01", "r", "b", "100"], ["101",
  "2022-04-28", "r", "b", "101"], ["102", "2022-05-31", "r", "b", "102"], ["103", "2022-06-23", "r", "b", "103"], ["104", "2022-08-05", "r",
  "b", "104"], ["105", "2022-09-01", "r", "b", "105"], ["106", "2022-10-03", "r", "b", "106"], ["107", "2022-10-27", "r", "b", "107"], ["108",
  "2022-12-05", "r", "b", "108"], ["109", "2023-01-12", "r", "b", "109"], ["110", "2023-02-09", "r", "b", "110"], ["111", "2023-03-13", "r",
  "b", "111"], ["112", "2023-04-06", "r", "b", "112"], ["113", "2023-05-05", "r", "b", "113"], ["114", "2023-06-02", "r", "b", "114"], ["115",
  "2023-07-21", "r", "b", "115"], ["116", "2023-08-21", "r", "b", "116"], ["117", "2023-09-15", "r", "b", "117"], ["118", "2023-10-13", "r",
  "b", "118"], ["119", "2023-11-02", "r", "b", "119"], ["120", "2023-12-07", "r", "b", "120"], ["121", "2024-01-25", "r", "b", "121"], ["122",
  "2024-02-23", "r", "b", "122"], ["123", "2024-03-22", "r", "b", "123"], ["124", "2024-04-18", "r", "b", "124"], ["125", "2024-05-17", "r",
  "b", "125"], ["126", "2024-06-13", "r", "b", "126"], ["127", "2024-07-25", "r", "b", "127"], ["128", "2024-08-22", "r", "b", "128"], ["129",
  "2024-09-19", "r", "b", "129"], ["130", "2024-10-17", "r", "b", "130"], ["131", "2024-11-14", "r", "b", "131"], ["132", "2025-01-17", "r",
  "b", "132"], ["133", "2025-02-06", "r", "b", "133"], ["134", "2025-03-06", "r", "b", "134"], ["135", "2025-04-04", "r", "b", "135"], ["136",
  "2025-05-01", "r", "b", "136"], ["137", "2025-05-29", "r", "b", "137"], ["138", "2025-06-26", "r", "b", "138"], ["139", "2025-08-07", "r",
  "b", "139"], ["140", "2025-09-05", "c", "b", "140"], ["141", "2025-10-02", "b", "b", "141"], ["142", "2025-10-30", "n", "b", "142"], ["143",
  "2025-12-04", "p", "b", "143"]] }, firefox: { releases: [["1", "2004-11-09", "r", "g", "1.7"], ["2", "2006-10-24", "r", "g", "1.8.1"], ["3",
  "2008-06-17", "r", "g", "1.9"], ["4", "2011-03-22", "r", "g", "2"], ["5", "2011-06-21", "r", "g", "5"], ["6", "2011-08-16", "r", "g", "6"],
  ["7", "2011-09-27", "r", "g", "7"], ["8", "2011-11-08", "r", "g", "8"], ["9", "2011-12-20", "r", "g", "9"], ["10", "2012-01-31", "r", "g",
  "10"], ["11", "2012-03-13", "r", "g", "11"], ["12", "2012-04-24", "r", "g", "12"], ["13", "2012-06-05", "r", "g", "13"], ["14", "2012-07-1\
7", "r", "g", "14"], ["15", "2012-08-28", "r", "g", "15"], ["16", "2012-10-09", "r", "g", "16"], ["17", "2012-11-20", "r", "g", "17"], ["18",
  "2013-01-08", "r", "g", "18"], ["19", "2013-02-19", "r", "g", "19"], ["20", "2013-04-02", "r", "g", "20"], ["21", "2013-05-14", "r", "g", "\
21"], ["22", "2013-06-25", "r", "g", "22"], ["23", "2013-08-06", "r", "g", "23"], ["24", "2013-09-17", "r", "g", "24"], ["25", "2013-10-29",
  "r", "g", "25"], ["26", "2013-12-10", "r", "g", "26"], ["27", "2014-02-04", "r", "g", "27"], ["28", "2014-03-18", "r", "g", "28"], ["29", "\
2014-04-29", "r", "g", "29"], ["30", "2014-06-10", "r", "g", "30"], ["31", "2014-07-22", "r", "g", "31"], ["32", "2014-09-02", "r", "g", "32"],
  ["33", "2014-10-14", "r", "g", "33"], ["34", "2014-12-01", "r", "g", "34"], ["35", "2015-01-13", "r", "g", "35"], ["36", "2015-02-24", "r",
  "g", "36"], ["37", "2015-03-31", "r", "g", "37"], ["38", "2015-05-12", "r", "g", "38"], ["39", "2015-07-02", "r", "g", "39"], ["40", "2015\
-08-11", "r", "g", "40"], ["41", "2015-09-22", "r", "g", "41"], ["42", "2015-11-03", "r", "g", "42"], ["43", "2015-12-15", "r", "g", "43"], [
  "44", "2016-01-26", "r", "g", "44"], ["45", "2016-03-08", "r", "g", "45"], ["46", "2016-04-26", "r", "g", "46"], ["47", "2016-06-07", "r",
  "g", "47"], ["48", "2016-08-02", "r", "g", "48"], ["49", "2016-09-20", "r", "g", "49"], ["50", "2016-11-15", "r", "g", "50"], ["51", "2017\
-01-24", "r", "g", "51"], ["52", "2017-03-07", "r", "g", "52"], ["53", "2017-04-19", "r", "g", "53"], ["54", "2017-06-13", "r", "g", "54"], [
  "55", "2017-08-08", "r", "g", "55"], ["56", "2017-09-28", "r", "g", "56"], ["57", "2017-11-14", "r", "g", "57"], ["58", "2018-01-23", "r",
  "g", "58"], ["59", "2018-03-13", "r", "g", "59"], ["60", "2018-05-09", "r", "g", "60"], ["61", "2018-06-26", "r", "g", "61"], ["62", "2018\
-09-05", "r", "g", "62"], ["63", "2018-10-23", "r", "g", "63"], ["64", "2018-12-11", "r", "g", "64"], ["65", "2019-01-29", "r", "g", "65"], [
  "66", "2019-03-19", "r", "g", "66"], ["67", "2019-05-21", "r", "g", "67"], ["68", "2019-07-09", "r", "g", "68"], ["69", "2019-09-03", "r",
  "g", "69"], ["70", "2019-10-22", "r", "g", "70"], ["71", "2019-12-10", "r", "g", "71"], ["72", "2020-01-07", "r", "g", "72"], ["73", "2020\
-02-11", "r", "g", "73"], ["74", "2020-03-10", "r", "g", "74"], ["75", "2020-04-07", "r", "g", "75"], ["76", "2020-05-05", "r", "g", "76"], [
  "77", "2020-06-02", "r", "g", "77"], ["78", "2020-06-30", "r", "g", "78"], ["79", "2020-07-28", "r", "g", "79"], ["80", "2020-08-25", "r",
  "g", "80"], ["81", "2020-09-22", "r", "g", "81"], ["82", "2020-10-20", "r", "g", "82"], ["83", "2020-11-17", "r", "g", "83"], ["84", "2020\
-12-15", "r", "g", "84"], ["85", "2021-01-26", "r", "g", "85"], ["86", "2021-02-23", "r", "g", "86"], ["87", "2021-03-23", "r", "g", "87"], [
  "88", "2021-04-19", "r", "g", "88"], ["89", "2021-06-01", "r", "g", "89"], ["90", "2021-07-13", "r", "g", "90"], ["91", "2021-08-10", "r",
  "g", "91"], ["92", "2021-09-07", "r", "g", "92"], ["93", "2021-10-05", "r", "g", "93"], ["94", "2021-11-02", "r", "g", "94"], ["95", "2021\
-12-07", "r", "g", "95"], ["96", "2022-01-11", "r", "g", "96"], ["97", "2022-02-08", "r", "g", "97"], ["98", "2022-03-08", "r", "g", "98"], [
  "99", "2022-04-05", "r", "g", "99"], ["100", "2022-05-03", "r", "g", "100"], ["101", "2022-05-31", "r", "g", "101"], ["102", "2022-06-28",
  "r", "g", "102"], ["103", "2022-07-26", "r", "g", "103"], ["104", "2022-08-23", "r", "g", "104"], ["105", "2022-09-20", "r", "g", "105"], [
  "106", "2022-10-18", "r", "g", "106"], ["107", "2022-11-15", "r", "g", "107"], ["108", "2022-12-13", "r", "g", "108"], ["109", "2023-01-17",
  "r", "g", "109"], ["110", "2023-02-14", "r", "g", "110"], ["111", "2023-03-14", "r", "g", "111"], ["112", "2023-04-11", "r", "g", "112"], [
  "113", "2023-05-09", "r", "g", "113"], ["114", "2023-06-06", "r", "g", "114"], ["115", "2023-07-04", "r", "g", "115"], ["116", "2023-08-01",
  "r", "g", "116"], ["117", "2023-08-29", "r", "g", "117"], ["118", "2023-09-26", "r", "g", "118"], ["119", "2023-10-24", "r", "g", "119"], [
  "120", "2023-11-21", "r", "g", "120"], ["121", "2023-12-19", "r", "g", "121"], ["122", "2024-01-23", "r", "g", "122"], ["123", "2024-02-20",
  "r", "g", "123"], ["124", "2024-03-19", "r", "g", "124"], ["125", "2024-04-16", "r", "g", "125"], ["126", "2024-05-14", "r", "g", "126"], [
  "127", "2024-06-11", "r", "g", "127"], ["128", "2024-07-09", "r", "g", "128"], ["129", "2024-08-06", "r", "g", "129"], ["130", "2024-09-03",
  "r", "g", "130"], ["131", "2024-10-01", "r", "g", "131"], ["132", "2024-10-29", "r", "g", "132"], ["133", "2024-11-26", "r", "g", "133"], [
  "134", "2025-01-07", "r", "g", "134"], ["135", "2025-02-04", "r", "g", "135"], ["136", "2025-03-04", "r", "g", "136"], ["137", "2025-04-01",
  "r", "g", "137"], ["138", "2025-04-29", "r", "g", "138"], ["139", "2025-05-27", "r", "g", "139"], ["140", "2025-06-24", "e", "g", "140"], [
  "141", "2025-07-22", "r", "g", "141"], ["142", "2025-08-19", "c", "g", "142"], ["143", "2025-09-16", "b", "g", "143"], ["144", "2025-10-14",
  "n", "g", "144"], ["145", "2025-11-11", "p", "g", "145"], ["1.5", "2005-11-29", "r", "g", "1.8"], ["3.5", "2009-06-30", "r", "g", "1.9.1"],
  ["3.6", "2010-01-21", "r", "g", "1.9.2"]] }, firefox_android: { releases: [["4", "2011-03-29", "r", "g", "2"], ["5", "2011-06-21", "r", "g",
  "5"], ["6", "2011-08-16", "r", "g", "6"], ["7", "2011-09-27", "r", "g", "7"], ["8", "2011-11-08", "r", "g", "8"], ["9", "2011-12-21", "r",
  "g", "9"], ["10", "2012-01-31", "r", "g", "10"], ["14", "2012-06-26", "r", "g", "14"], ["15", "2012-08-28", "r", "g", "15"], ["16", "2012-\
10-09", "r", "g", "16"], ["17", "2012-11-20", "r", "g", "17"], ["18", "2013-01-08", "r", "g", "18"], ["19", "2013-02-19", "r", "g", "19"], [
  "20", "2013-04-02", "r", "g", "20"], ["21", "2013-05-14", "r", "g", "21"], ["22", "2013-06-25", "r", "g", "22"], ["23", "2013-08-06", "r",
  "g", "23"], ["24", "2013-09-17", "r", "g", "24"], ["25", "2013-10-29", "r", "g", "25"], ["26", "2013-12-10", "r", "g", "26"], ["27", "2014\
-02-04", "r", "g", "27"], ["28", "2014-03-18", "r", "g", "28"], ["29", "2014-04-29", "r", "g", "29"], ["30", "2014-06-10", "r", "g", "30"], [
  "31", "2014-07-22", "r", "g", "31"], ["32", "2014-09-02", "r", "g", "32"], ["33", "2014-10-14", "r", "g", "33"], ["34", "2014-12-01", "r",
  "g", "34"], ["35", "2015-01-13", "r", "g", "35"], ["36", "2015-02-27", "r", "g", "36"], ["37", "2015-03-31", "r", "g", "37"], ["38", "2015\
-05-12", "r", "g", "38"], ["39", "2015-07-02", "r", "g", "39"], ["40", "2015-08-11", "r", "g", "40"], ["41", "2015-09-22", "r", "g", "41"], [
  "42", "2015-11-03", "r", "g", "42"], ["43", "2015-12-15", "r", "g", "43"], ["44", "2016-01-26", "r", "g", "44"], ["45", "2016-03-08", "r",
  "g", "45"], ["46", "2016-04-26", "r", "g", "46"], ["47", "2016-06-07", "r", "g", "47"], ["48", "2016-08-02", "r", "g", "48"], ["49", "2016\
-09-20", "r", "g", "49"], ["50", "2016-11-15", "r", "g", "50"], ["51", "2017-01-24", "r", "g", "51"], ["52", "2017-03-07", "r", "g", "52"], [
  "53", "2017-04-19", "r", "g", "53"], ["54", "2017-06-13", "r", "g", "54"], ["55", "2017-08-08", "r", "g", "55"], ["56", "2017-09-28", "r",
  "g", "56"], ["57", "2017-11-28", "r", "g", "57"], ["58", "2018-01-22", "r", "g", "58"], ["59", "2018-03-13", "r", "g", "59"], ["60", "2018\
-05-09", "r", "g", "60"], ["61", "2018-06-26", "r", "g", "61"], ["62", "2018-09-05", "r", "g", "62"], ["63", "2018-10-23", "r", "g", "63"], [
  "64", "2018-12-11", "r", "g", "64"], ["65", "2019-01-29", "r", "g", "65"], ["66", "2019-03-19", "r", "g", "66"], ["67", "2019-05-21", "r",
  "g", "67"], ["68", "2019-07-09", "r", "g", "68"], ["79", "2020-07-28", "r", "g", "79"], ["80", "2020-08-31", "r", "g", "80"], ["81", "2020\
-09-22", "r", "g", "81"], ["82", "2020-10-20", "r", "g", "82"], ["83", "2020-11-17", "r", "g", "83"], ["84", "2020-12-15", "r", "g", "84"], [
  "85", "2021-01-26", "r", "g", "85"], ["86", "2021-02-23", "r", "g", "86"], ["87", "2021-03-23", "r", "g", "87"], ["88", "2021-04-19", "r",
  "g", "88"], ["89", "2021-06-01", "r", "g", "89"], ["90", "2021-07-13", "r", "g", "90"], ["91", "2021-08-10", "r", "g", "91"], ["92", "2021\
-09-07", "r", "g", "92"], ["93", "2021-10-05", "r", "g", "93"], ["94", "2021-11-02", "r", "g", "94"], ["95", "2021-12-07", "r", "g", "95"], [
  "96", "2022-01-11", "r", "g", "96"], ["97", "2022-02-08", "r", "g", "97"], ["98", "2022-03-08", "r", "g", "98"], ["99", "2022-04-05", "r",
  "g", "99"], ["100", "2022-05-03", "r", "g", "100"], ["101", "2022-05-31", "r", "g", "101"], ["102", "2022-06-28", "r", "g", "102"], ["103",
  "2022-07-26", "r", "g", "103"], ["104", "2022-08-23", "r", "g", "104"], ["105", "2022-09-20", "r", "g", "105"], ["106", "2022-10-18", "r",
  "g", "106"], ["107", "2022-11-15", "r", "g", "107"], ["108", "2022-12-13", "r", "g", "108"], ["109", "2023-01-17", "r", "g", "109"], ["110",
  "2023-02-14", "r", "g", "110"], ["111", "2023-03-14", "r", "g", "111"], ["112", "2023-04-11", "r", "g", "112"], ["113", "2023-05-09", "r",
  "g", "113"], ["114", "2023-06-06", "r", "g", "114"], ["115", "2023-07-04", "r", "g", "115"], ["116", "2023-08-01", "r", "g", "116"], ["117",
  "2023-08-29", "r", "g", "117"], ["118", "2023-09-26", "r", "g", "118"], ["119", "2023-10-24", "r", "g", "119"], ["120", "2023-11-21", "r",
  "g", "120"], ["121", "2023-12-19", "r", "g", "121"], ["122", "2024-01-23", "r", "g", "122"], ["123", "2024-02-20", "r", "g", "123"], ["124",
  "2024-03-19", "r", "g", "124"], ["125", "2024-04-16", "r", "g", "125"], ["126", "2024-05-14", "r", "g", "126"], ["127", "2024-06-11", "r",
  "g", "127"], ["128", "2024-07-09", "r", "g", "128"], ["129", "2024-08-06", "r", "g", "129"], ["130", "2024-09-03", "r", "g", "130"], ["131",
  "2024-10-01", "r", "g", "131"], ["132", "2024-10-29", "r", "g", "132"], ["133", "2024-11-26", "r", "g", "133"], ["134", "2025-01-07", "r",
  "g", "134"], ["135", "2025-02-04", "r", "g", "135"], ["136", "2025-03-04", "r", "g", "136"], ["137", "2025-04-01", "r", "g", "137"], ["138",
  "2025-04-29", "r", "g", "138"], ["139", "2025-05-27", "r", "g", "139"], ["140", "2025-06-24", "e", "g", "140"], ["141", "2025-07-22", "r",
  "g", "141"], ["142", "2025-08-19", "c", "g", "142"], ["143", "2025-09-16", "b", "g", "143"], ["144", "2025-10-14", "n", "g", "144"], ["145",
  "2025-11-11", "p", "g", "145"]] }, opera: { releases: [["2", "1996-07-14", "r", null, null], ["3", "1997-12-01", "r", null, null], ["4", "\
2000-06-28", "r", null, null], ["5", "2000-12-06", "r", null, null], ["6", "2001-12-18", "r", null, null], ["7", "2003-01-28", "r", "p", "1"],
  ["8", "2005-04-19", "r", "p", "1"], ["9", "2006-06-20", "r", "p", "2"], ["10", "2009-09-01", "r", "p", "2.2"], ["11", "2010-12-16", "r", "\
p", "2.7"], ["12", "2012-06-14", "r", "p", "2.10"], ["15", "2013-07-02", "r", "b", "28"], ["16", "2013-08-27", "r", "b", "29"], ["17", "2013\
-10-08", "r", "b", "30"], ["18", "2013-11-19", "r", "b", "31"], ["19", "2014-01-28", "r", "b", "32"], ["20", "2014-03-04", "r", "b", "33"], [
  "21", "2014-05-06", "r", "b", "34"], ["22", "2014-06-03", "r", "b", "35"], ["23", "2014-07-22", "r", "b", "36"], ["24", "2014-09-02", "r",
  "b", "37"], ["25", "2014-10-15", "r", "b", "38"], ["26", "2014-12-03", "r", "b", "39"], ["27", "2015-01-27", "r", "b", "40"], ["28", "2015\
-03-10", "r", "b", "41"], ["29", "2015-04-28", "r", "b", "42"], ["30", "2015-06-09", "r", "b", "43"], ["31", "2015-08-04", "r", "b", "44"], [
  "32", "2015-09-15", "r", "b", "45"], ["33", "2015-10-27", "r", "b", "46"], ["34", "2015-12-08", "r", "b", "47"], ["35", "2016-02-02", "r",
  "b", "48"], ["36", "2016-03-15", "r", "b", "49"], ["37", "2016-05-04", "r", "b", "50"], ["38", "2016-06-08", "r", "b", "51"], ["39", "2016\
-08-02", "r", "b", "52"], ["40", "2016-09-20", "r", "b", "53"], ["41", "2016-10-25", "r", "b", "54"], ["42", "2016-12-13", "r", "b", "55"], [
  "43", "2017-02-07", "r", "b", "56"], ["44", "2017-03-21", "r", "b", "57"], ["45", "2017-05-10", "r", "b", "58"], ["46", "2017-06-22", "r",
  "b", "59"], ["47", "2017-08-09", "r", "b", "60"], ["48", "2017-09-27", "r", "b", "61"], ["49", "2017-11-08", "r", "b", "62"], ["50", "2018\
-01-04", "r", "b", "63"], ["51", "2018-02-07", "r", "b", "64"], ["52", "2018-03-22", "r", "b", "65"], ["53", "2018-05-10", "r", "b", "66"], [
  "54", "2018-06-28", "r", "b", "67"], ["55", "2018-08-16", "r", "b", "68"], ["56", "2018-09-25", "r", "b", "69"], ["57", "2018-11-28", "r",
  "b", "70"], ["58", "2019-01-23", "r", "b", "71"], ["60", "2019-04-09", "r", "b", "73"], ["62", "2019-06-27", "r", "b", "75"], ["63", "2019\
-08-20", "r", "b", "76"], ["64", "2019-10-07", "r", "b", "77"], ["65", "2019-11-13", "r", "b", "78"], ["66", "2020-01-07", "r", "b", "79"], [
  "67", "2020-03-03", "r", "b", "80"], ["68", "2020-04-22", "r", "b", "81"], ["69", "2020-06-24", "r", "b", "83"], ["70", "2020-07-27", "r",
  "b", "84"], ["71", "2020-09-15", "r", "b", "85"], ["72", "2020-10-21", "r", "b", "86"], ["73", "2020-12-09", "r", "b", "87"], ["74", "2021\
-02-02", "r", "b", "88"], ["75", "2021-03-24", "r", "b", "89"], ["76", "2021-04-28", "r", "b", "90"], ["77", "2021-06-09", "r", "b", "91"], [
  "78", "2021-08-03", "r", "b", "92"], ["79", "2021-09-14", "r", "b", "93"], ["80", "2021-10-05", "r", "b", "94"], ["81", "2021-11-04", "r",
  "b", "95"], ["82", "2021-12-02", "r", "b", "96"], ["83", "2022-01-19", "r", "b", "97"], ["84", "2022-02-16", "r", "b", "98"], ["85", "2022\
-03-23", "r", "b", "99"], ["86", "2022-04-20", "r", "b", "100"], ["87", "2022-05-17", "r", "b", "101"], ["88", "2022-06-08", "r", "b", "102"],
  ["89", "2022-07-07", "r", "b", "103"], ["90", "2022-08-18", "r", "b", "104"], ["91", "2022-09-14", "r", "b", "105"], ["92", "2022-10-19", "\
r", "b", "106"], ["93", "2022-11-17", "r", "b", "107"], ["94", "2022-12-15", "r", "b", "108"], ["95", "2023-02-01", "r", "b", "109"], ["96",
  "2023-02-22", "r", "b", "110"], ["97", "2023-03-22", "r", "b", "111"], ["98", "2023-04-20", "r", "b", "112"], ["99", "2023-05-16", "r", "b",
  "113"], ["100", "2023-06-29", "r", "b", "114"], ["101", "2023-07-26", "r", "b", "115"], ["102", "2023-08-23", "r", "b", "116"], ["103", "2\
023-10-03", "r", "b", "117"], ["104", "2023-10-23", "r", "b", "118"], ["105", "2023-11-14", "r", "b", "119"], ["106", "2023-12-19", "r", "b",
  "120"], ["107", "2024-02-07", "r", "b", "121"], ["108", "2024-03-05", "r", "b", "122"], ["109", "2024-03-27", "r", "b", "123"], ["110", "2\
024-05-14", "r", "b", "124"], ["111", "2024-06-12", "r", "b", "125"], ["112", "2024-07-11", "r", "b", "126"], ["113", "2024-08-22", "r", "b",
  "127"], ["114", "2024-09-25", "r", "b", "128"], ["115", "2024-11-27", "r", "b", "130"], ["116", "2025-01-08", "r", "b", "131"], ["117", "2\
025-02-13", "r", "b", "132"], ["118", "2025-04-15", "r", "b", "133"], ["119", "2025-05-13", "r", "b", "134"], ["120", "2025-07-02", "r", "b",
  "135"], ["121", "2025-08-27", "r", "b", "137"], ["122", "2025-09-11", "c", "b", "138"], ["123", null, "b", "b", "139"], ["124", null, "n",
  "b", "140"], ["10.1", "2009-11-23", "r", "p", "2.2"], ["10.5", "2010-03-02", "r", "p", "2.5"], ["10.6", "2010-07-01", "r", "p", "2.6"], ["\
11.1", "2011-04-12", "r", "p", "2.8"], ["11.5", "2011-06-28", "r", "p", "2.9"], ["11.6", "2011-12-06", "r", "p", "2.10"], ["12.1", "2012-11-\
20", "r", "p", "2.12"], ["3.5", "1998-11-18", "r", null, null], ["3.6", "1999-05-06", "r", null, null], ["5.1", "2001-04-10", "r", null, null],
  ["7.1", "2003-04-11", "r", "p", "1"], ["7.2", "2003-09-23", "r", "p", "1"], ["7.5", "2004-05-12", "r", "p", "1"], ["8.5", "2005-09-20", "r",
  "p", "1"], ["9.1", "2006-12-18", "r", "p", "2"], ["9.2", "2007-04-11", "r", "p", "2"], ["9.5", "2008-06-12", "r", "p", "2.1"], ["9.6", "20\
08-10-08", "r", "p", "2.1"]] }, opera_android: { releases: [["11", "2011-03-22", "r", "p", "2.7"], ["12", "2012-02-25", "r", "p", "2.10"], [
  "14", "2013-05-21", "r", "w", "537.31"], ["15", "2013-07-08", "r", "b", "28"], ["16", "2013-09-18", "r", "b", "29"], ["18", "2013-11-20", "\
r", "b", "31"], ["19", "2014-01-28", "r", "b", "32"], ["20", "2014-03-06", "r", "b", "33"], ["21", "2014-04-22", "r", "b", "34"], ["22", "20\
14-06-17", "r", "b", "35"], ["24", "2014-09-10", "r", "b", "37"], ["25", "2014-10-16", "r", "b", "38"], ["26", "2014-12-02", "r", "b", "39"],
  ["27", "2015-01-29", "r", "b", "40"], ["28", "2015-03-10", "r", "b", "41"], ["29", "2015-04-28", "r", "b", "42"], ["30", "2015-06-10", "r",
  "b", "43"], ["32", "2015-09-23", "r", "b", "45"], ["33", "2015-11-03", "r", "b", "46"], ["34", "2015-12-16", "r", "b", "47"], ["35", "2016\
-02-04", "r", "b", "48"], ["36", "2016-03-31", "r", "b", "49"], ["37", "2016-06-16", "r", "b", "50"], ["41", "2016-10-25", "r", "b", "54"], [
  "42", "2017-01-21", "r", "b", "55"], ["43", "2017-09-27", "r", "b", "59"], ["44", "2017-12-11", "r", "b", "60"], ["45", "2018-02-15", "r",
  "b", "61"], ["46", "2018-05-14", "r", "b", "63"], ["47", "2018-07-23", "r", "b", "66"], ["48", "2018-11-08", "r", "b", "69"], ["49", "2018\
-12-07", "r", "b", "70"], ["50", "2019-02-18", "r", "b", "71"], ["51", "2019-03-21", "r", "b", "72"], ["52", "2019-05-17", "r", "b", "73"], [
  "53", "2019-07-11", "r", "b", "74"], ["54", "2019-10-18", "r", "b", "76"], ["55", "2019-12-03", "r", "b", "77"], ["56", "2020-02-06", "r",
  "b", "78"], ["57", "2020-03-30", "r", "b", "80"], ["58", "2020-05-13", "r", "b", "81"], ["59", "2020-06-30", "r", "b", "83"], ["60", "2020\
-09-23", "r", "b", "85"], ["61", "2020-12-07", "r", "b", "86"], ["62", "2021-02-16", "r", "b", "87"], ["63", "2021-04-16", "r", "b", "89"], [
  "64", "2021-05-25", "r", "b", "91"], ["65", "2021-10-20", "r", "b", "92"], ["66", "2021-12-15", "r", "b", "94"], ["67", "2022-01-31", "r",
  "b", "96"], ["68", "2022-03-30", "r", "b", "99"], ["69", "2022-05-09", "r", "b", "100"], ["70", "2022-06-29", "r", "b", "102"], ["71", "20\
22-09-16", "r", "b", "104"], ["72", "2022-10-21", "r", "b", "106"], ["73", "2023-01-17", "r", "b", "108"], ["74", "2023-03-13", "r", "b", "1\
10"], ["75", "2023-05-17", "r", "b", "112"], ["76", "2023-06-26", "r", "b", "114"], ["77", "2023-08-31", "r", "b", "115"], ["78", "2023-10-2\
3", "r", "b", "117"], ["79", "2023-12-06", "r", "b", "119"], ["80", "2024-01-25", "r", "b", "120"], ["81", "2024-03-14", "r", "b", "122"], [
  "82", "2024-05-02", "r", "b", "124"], ["83", "2024-06-25", "r", "b", "126"], ["84", "2024-08-26", "r", "b", "127"], ["85", "2024-10-29", "\
r", "b", "128"], ["86", "2024-12-02", "r", "b", "130"], ["87", "2025-01-22", "r", "b", "132"], ["88", "2025-03-19", "r", "b", "134"], ["89",
  "2025-04-29", "r", "b", "135"], ["90", "2025-06-18", "r", "b", "137"], ["91", "2025-08-19", "c", "b", "139"], ["10.1", "2010-11-09", "r", "\
p", "2.5"], ["11.1", "2011-06-30", "r", "p", "2.8"], ["11.5", "2011-10-12", "r", "p", "2.9"], ["12.1", "2012-10-09", "r", "p", "2.11"]] }, safari: {
  releases: [["1", "2003-06-23", "r", "w", "85"], ["2", "2005-04-29", "r", "w", "412"], ["3", "2007-10-26", "r", "w", "523.10"], ["4", "2009\
-06-08", "r", "w", "530.17"], ["5", "2010-06-07", "r", "w", "533.16"], ["6", "2012-07-25", "r", "w", "536.25"], ["7", "2013-10-22", "r", "w",
  "537.71"], ["8", "2014-10-16", "r", "w", "538.35"], ["9", "2015-09-30", "r", "w", "601.1.56"], ["10", "2016-09-20", "r", "w", "602.1.50"],
  ["11", "2017-09-19", "r", "w", "604.2.4"], ["12", "2018-09-17", "r", "w", "606.1.36"], ["13", "2019-09-19", "r", "w", "608.2.11"], ["14", "\
2020-09-16", "r", "w", "610.1.28"], ["15", "2021-09-20", "r", "w", "612.1.27"], ["16", "2022-09-12", "r", "w", "614.1.25"], ["17", "2023-09-\
18", "r", "w", "616.1.27"], ["18", "2024-09-16", "r", "w", "619.1.26"], ["26", null, "b", "w", "622.1.22"], ["1.1", "2003-10-24", "r", "w", "\
100"], ["1.2", "2004-02-02", "r", "w", "125"], ["1.3", "2005-04-15", "r", "w", "312"], ["10.1", "2017-03-27", "r", "w", "603.2.1"], ["11.1",
  "2018-04-12", "r", "w", "605.1.33"], ["12.1", "2019-03-25", "r", "w", "607.1.40"], ["13.1", "2020-03-24", "r", "w", "609.1.20"], ["14.1", "\
2021-04-26", "r", "w", "611.1.21"], ["15.1", "2021-10-25", "r", "w", "612.2.9"], ["15.2", "2021-12-13", "r", "w", "612.3.6"], ["15.3", "2022\
-01-26", "r", "w", "612.4.9"], ["15.4", "2022-03-14", "r", "w", "613.1.17"], ["15.5", "2022-05-16", "r", "w", "613.2.7"], ["15.6", "2022-07-\
20", "r", "w", "613.3.9"], ["16.1", "2022-10-24", "r", "w", "614.2.9"], ["16.2", "2022-12-13", "r", "w", "614.3.7"], ["16.3", "2023-01-23", "\
r", "w", "614.4.6"], ["16.4", "2023-03-27", "r", "w", "615.1.26"], ["16.5", "2023-05-18", "r", "w", "615.2.9"], ["16.6", "2023-07-24", "r", "\
w", "615.3.12"], ["17.1", "2023-10-25", "r", "w", "616.2.9"], ["17.2", "2023-12-11", "r", "w", "617.1.17"], ["17.3", "2024-01-22", "r", "w",
  "617.2.4"], ["17.4", "2024-03-05", "r", "w", "618.1.15"], ["17.5", "2024-05-13", "r", "w", "618.2.12"], ["17.6", "2024-07-29", "r", "w", "\
618.3.11"], ["18.1", "2024-10-28", "r", "w", "619.2.8"], ["18.2", "2024-12-11", "r", "w", "620.1.16"], ["18.3", "2025-01-27", "r", "w", "620\
.2.4"], ["18.4", "2025-03-31", "r", "w", "621.1.15"], ["18.5", "2025-05-12", "r", "w", "621.2.5"], ["18.6", "2025-07-29", "c", "w", "621.3.1\
1"], ["3.1", "2008-03-18", "r", "w", "525.13"], ["5.1", "2011-07-20", "r", "w", "534.48"], ["9.1", "2016-03-21", "r", "w", "601.5.17"]] }, safari_ios: {
  releases: [["1", "2007-06-29", "r", "w", "522.11"], ["2", "2008-07-11", "r", "w", "525.18"], ["3", "2009-06-17", "r", "w", "528.18"], ["4",
  "2010-06-21", "r", "w", "532.9"], ["5", "2011-10-12", "r", "w", "534.46"], ["6", "2012-09-10", "r", "w", "536.26"], ["7", "2013-09-18", "r",
  "w", "537.51"], ["8", "2014-09-17", "r", "w", "600.1.4"], ["9", "2015-09-16", "r", "w", "601.1.56"], ["10", "2016-09-13", "r", "w", "602.1\
.50"], ["11", "2017-09-19", "r", "w", "604.2.4"], ["12", "2018-09-17", "r", "w", "606.1.36"], ["13", "2019-09-19", "r", "w", "608.2.11"], ["\
14", "2020-09-16", "r", "w", "610.1.28"], ["15", "2021-09-20", "r", "w", "612.1.27"], ["16", "2022-09-12", "r", "w", "614.1.25"], ["17", "20\
23-09-18", "r", "w", "616.1.27"], ["18", "2024-09-16", "r", "w", "619.1.26"], ["26", null, "b", "w", "622.1.22"], ["10.3", "2017-03-27", "r",
  "w", "603.2.1"], ["11.3", "2018-03-29", "r", "w", "605.1.33"], ["12.2", "2019-03-25", "r", "w", "607.1.40"], ["13.4", "2020-03-24", "r", "\
w", "609.1.20"], ["14.5", "2021-04-26", "r", "w", "611.1.21"], ["15.1", "2021-10-25", "r", "w", "612.2.9"], ["15.2", "2021-12-13", "r", "w",
  "612.3.6"], ["15.3", "2022-01-26", "r", "w", "612.4.9"], ["15.4", "2022-03-14", "r", "w", "613.1.17"], ["15.5", "2022-05-16", "r", "w", "6\
13.2.7"], ["15.6", "2022-07-20", "r", "w", "613.3.9"], ["16.1", "2022-10-24", "r", "w", "614.2.9"], ["16.2", "2022-12-13", "r", "w", "614.3.\
7"], ["16.3", "2023-01-23", "r", "w", "614.4.6"], ["16.4", "2023-03-27", "r", "w", "615.1.26"], ["16.5", "2023-05-18", "r", "w", "615.2.9"],
  ["16.6", "2023-07-24", "r", "w", "615.3.12"], ["17.1", "2023-10-25", "r", "w", "616.2.9"], ["17.2", "2023-12-11", "r", "w", "617.1.17"], [
  "17.3", "2024-01-22", "r", "w", "617.2.4"], ["17.4", "2024-03-05", "r", "w", "618.1.15"], ["17.5", "2024-05-13", "r", "w", "618.2.12"], ["\
17.6", "2024-07-29", "r", "w", "618.3.11"], ["18.1", "2024-10-28", "r", "w", "619.2.8"], ["18.2", "2024-12-11", "r", "w", "620.1.16"], ["18.\
3", "2025-01-27", "r", "w", "620.2.4"], ["18.4", "2025-03-31", "r", "w", "621.1.15"], ["18.5", "2025-05-12", "r", "w", "621.2.5"], ["18.6", "\
2025-07-29", "c", "w", "621.3.11"], ["3.2", "2010-04-03", "r", "w", "531.21"], ["4.2", "2010-11-22", "r", "w", "533.17"], ["9.3", "2016-03-2\
1", "r", "w", "601.5.17"]] }, samsunginternet_android: { releases: [["1.0", "2013-04-27", "r", "w", "535.19"], ["1.5", "2013-09-25", "r", "b",
  "28"], ["1.6", "2014-04-11", "r", "b", "28"], ["10.0", "2019-08-22", "r", "b", "71"], ["10.2", "2019-10-09", "r", "b", "71"], ["11.0", "20\
19-12-05", "r", "b", "75"], ["11.2", "2020-03-22", "r", "b", "75"], ["12.0", "2020-06-19", "r", "b", "79"], ["12.1", "2020-07-07", "r", "b",
  "79"], ["13.0", "2020-12-02", "r", "b", "83"], ["13.2", "2021-01-20", "r", "b", "83"], ["14.0", "2021-04-17", "r", "b", "87"], ["14.2", "2\
021-06-25", "r", "b", "87"], ["15.0", "2021-08-13", "r", "b", "90"], ["16.0", "2021-11-25", "r", "b", "92"], ["16.2", "2022-03-06", "r", "b",
  "92"], ["17.0", "2022-05-04", "r", "b", "96"], ["18.0", "2022-08-08", "r", "b", "99"], ["18.1", "2022-09-09", "r", "b", "99"], ["19.0", "2\
022-11-01", "r", "b", "102"], ["19.1", "2022-11-08", "r", "b", "102"], ["2.0", "2014-10-17", "r", "b", "34"], ["2.1", "2015-01-07", "r", "b",
  "34"], ["20.0", "2023-02-10", "r", "b", "106"], ["21.0", "2023-05-19", "r", "b", "110"], ["22.0", "2023-07-14", "r", "b", "111"], ["23.0",
  "2023-10-18", "r", "b", "115"], ["24.0", "2024-01-25", "r", "b", "117"], ["25.0", "2024-04-24", "r", "b", "121"], ["26.0", "2024-06-07", "\
r", "b", "122"], ["27.0", "2024-11-06", "r", "b", "125"], ["28.0", "2025-04-02", "c", "b", "130"], ["3.0", "2015-04-10", "r", "b", "38"], ["\
3.2", "2015-08-24", "r", "b", "38"], ["4.0", "2016-03-11", "r", "b", "44"], ["4.2", "2016-08-02", "r", "b", "44"], ["5.0", "2016-12-15", "r",
  "b", "51"], ["5.2", "2017-04-21", "r", "b", "51"], ["5.4", "2017-05-17", "r", "b", "51"], ["6.0", "2017-08-23", "r", "b", "56"], ["6.2", "\
2017-10-26", "r", "b", "56"], ["6.4", "2018-02-19", "r", "b", "56"], ["7.0", "2018-03-16", "r", "b", "59"], ["7.2", "2018-06-20", "r", "b", "\
59"], ["7.4", "2018-09-12", "r", "b", "59"], ["8.0", "2018-07-18", "r", "b", "63"], ["8.2", "2018-12-21", "r", "b", "63"], ["9.0", "2018-09-\
15", "r", "b", "67"], ["9.2", "2019-04-02", "r", "b", "67"], ["9.4", "2019-07-25", "r", "b", "67"]] }, webview_android: { releases: [["1", "\
2008-09-23", "r", "w", "523.12"], ["2", "2009-10-26", "r", "w", "530.17"], ["3", "2011-02-22", "r", "w", "534.13"], ["4", "2011-10-18", "r",
  "w", "534.30"], ["37", "2014-09-03", "r", "b", "37"], ["38", "2014-10-08", "r", "b", "38"], ["39", "2014-11-12", "r", "b", "39"], ["40", "\
2015-01-21", "r", "b", "40"], ["41", "2015-03-11", "r", "b", "41"], ["42", "2015-04-15", "r", "b", "42"], ["43", "2015-05-27", "r", "b", "43"],
  ["44", "2015-07-29", "r", "b", "44"], ["45", "2015-09-01", "r", "b", "45"], ["46", "2015-10-14", "r", "b", "46"], ["47", "2015-12-02", "r",
  "b", "47"], ["48", "2016-01-26", "r", "b", "48"], ["49", "2016-03-09", "r", "b", "49"], ["50", "2016-04-13", "r", "b", "50"], ["51", "2016\
-06-08", "r", "b", "51"], ["52", "2016-07-27", "r", "b", "52"], ["53", "2016-09-07", "r", "b", "53"], ["54", "2016-10-19", "r", "b", "54"], [
  "55", "2016-12-06", "r", "b", "55"], ["56", "2017-02-01", "r", "b", "56"], ["57", "2017-03-16", "r", "b", "57"], ["58", "2017-04-25", "r",
  "b", "58"], ["59", "2017-06-06", "r", "b", "59"], ["60", "2017-08-01", "r", "b", "60"], ["61", "2017-09-05", "r", "b", "61"], ["62", "2017\
-10-24", "r", "b", "62"], ["63", "2017-12-05", "r", "b", "63"], ["64", "2018-01-23", "r", "b", "64"], ["65", "2018-03-06", "r", "b", "65"], [
  "66", "2018-04-17", "r", "b", "66"], ["67", "2018-05-31", "r", "b", "67"], ["68", "2018-07-24", "r", "b", "68"], ["69", "2018-09-04", "r",
  "b", "69"], ["70", "2018-10-17", "r", "b", "70"], ["71", "2018-12-04", "r", "b", "71"], ["72", "2019-01-29", "r", "b", "72"], ["73", "2019\
-03-12", "r", "b", "73"], ["74", "2019-04-24", "r", "b", "74"], ["75", "2019-06-04", "r", "b", "75"], ["76", "2019-07-30", "r", "b", "76"], [
  "77", "2019-09-10", "r", "b", "77"], ["78", "2019-10-22", "r", "b", "78"], ["79", "2019-12-17", "r", "b", "79"], ["80", "2020-02-04", "r",
  "b", "80"], ["81", "2020-04-07", "r", "b", "81"], ["83", "2020-05-19", "r", "b", "83"], ["84", "2020-07-27", "r", "b", "84"], ["85", "2020\
-08-25", "r", "b", "85"], ["86", "2020-10-20", "r", "b", "86"], ["87", "2020-11-17", "r", "b", "87"], ["88", "2021-01-19", "r", "b", "88"], [
  "89", "2021-03-02", "r", "b", "89"], ["90", "2021-04-13", "r", "b", "90"], ["91", "2021-05-25", "r", "b", "91"], ["92", "2021-07-20", "r",
  "b", "92"], ["93", "2021-08-31", "r", "b", "93"], ["94", "2021-09-21", "r", "b", "94"], ["95", "2021-10-19", "r", "b", "95"], ["96", "2021\
-11-15", "r", "b", "96"], ["97", "2022-01-04", "r", "b", "97"], ["98", "2022-02-01", "r", "b", "98"], ["99", "2022-03-01", "r", "b", "99"], [
  "100", "2022-03-29", "r", "b", "100"], ["101", "2022-04-26", "r", "b", "101"], ["102", "2022-05-24", "r", "b", "102"], ["103", "2022-06-21",
  "r", "b", "103"], ["104", "2022-08-02", "r", "b", "104"], ["105", "2022-09-02", "r", "b", "105"], ["106", "2022-09-27", "r", "b", "106"], [
  "107", "2022-10-25", "r", "b", "107"], ["108", "2022-11-29", "r", "b", "108"], ["109", "2023-01-10", "r", "b", "109"], ["110", "2023-02-07",
  "r", "b", "110"], ["111", "2023-03-01", "r", "b", "111"], ["112", "2023-04-04", "r", "b", "112"], ["113", "2023-05-02", "r", "b", "113"], [
  "114", "2023-05-30", "r", "b", "114"], ["115", "2023-07-21", "r", "b", "115"], ["116", "2023-08-15", "r", "b", "116"], ["117", "2023-09-12",
  "r", "b", "117"], ["118", "2023-10-10", "r", "b", "118"], ["119", "2023-10-31", "r", "b", "119"], ["120", "2023-12-05", "r", "b", "120"], [
  "121", "2024-01-23", "r", "b", "121"], ["122", "2024-02-20", "r", "b", "122"], ["123", "2024-03-19", "r", "b", "123"], ["124", "2024-04-16",
  "r", "b", "124"], ["125", "2024-05-14", "r", "b", "125"], ["126", "2024-06-11", "r", "b", "126"], ["127", "2024-07-23", "r", "b", "127"], [
  "128", "2024-08-20", "r", "b", "128"], ["129", "2024-09-17", "r", "b", "129"], ["130", "2024-10-15", "r", "b", "130"], ["131", "2024-11-12",
  "r", "b", "131"], ["132", "2025-01-14", "r", "b", "132"], ["133", "2025-02-04", "r", "b", "133"], ["134", "2025-03-04", "r", "b", "134"], [
  "135", "2025-04-01", "r", "b", "135"], ["136", "2025-04-29", "r", "b", "136"], ["137", "2025-05-27", "r", "b", "137"], ["138", "2025-06-24",
  "r", "b", "138"], ["139", "2025-08-05", "r", "b", "139"], ["140", "2025-09-02", "c", "b", "140"], ["141", "2025-09-30", "b", "b", "141"], [
  "142", "2025-10-28", "n", "b", "142"], ["143", null, "p", "b", "143"], ["1.5", "2009-04-27", "r", "w", "525.20"], ["2.2", "2010-05-20", "r",
  "w", "533.1"], ["4.4", "2013-12-09", "r", "b", "30"], ["4.4.3", "2014-06-02", "r", "b", "33"]] } }, wfe = { ya_android: { releases: [["1.0",
  "u", "u", "b", "25"], ["1.5", "u", "u", "b", "22"], ["1.6", "u", "u", "b", "25"], ["1.7", "u", "u", "b", "25"], ["1.20", "u", "u", "b", "2\
5"], ["2.5", "u", "u", "b", "25"], ["3.2", "u", "u", "b", "25"], ["4.6", "u", "u", "b", "25"], ["5.3", "u", "u", "b", "25"], ["5.4", "u", "u",
  "b", "25"], ["7.4", "u", "u", "b", "25"], ["9.6", "u", "u", "b", "25"], ["10.5", "u", "u", "b", "25"], ["11.4", "u", "u", "b", "25"], ["11\
.5", "u", "u", "b", "25"], ["12.7", "u", "u", "b", "25"], ["13.9", "u", "u", "b", "28"], ["13.10", "u", "u", "b", "28"], ["13.11", "u", "u",
  "b", "28"], ["13.12", "u", "u", "b", "30"], ["14.2", "u", "u", "b", "32"], ["14.4", "u", "u", "b", "33"], ["14.5", "u", "u", "b", "34"], [
  "14.7", "u", "u", "b", "35"], ["14.8", "u", "u", "b", "36"], ["14.10", "u", "u", "b", "37"], ["14.12", "u", "u", "b", "38"], ["15.2", "u",
  "u", "b", "40"], ["15.4", "u", "u", "b", "41"], ["15.6", "u", "u", "b", "42"], ["15.7", "u", "u", "b", "43"], ["15.9", "u", "u", "b", "44"],
  ["15.10", "u", "u", "b", "45"], ["15.12", "u", "u", "b", "46"], ["16.2", "u", "u", "b", "47"], ["16.3", "u", "u", "b", "47"], ["16.4", "u",
  "u", "b", "49"], ["16.6", "u", "u", "b", "50"], ["16.7", "u", "u", "b", "51"], ["16.9", "u", "u", "b", "52"], ["16.10", "u", "u", "b", "53"],
  ["16.11", "u", "u", "b", "54"], ["17.1", "u", "u", "b", "55"], ["17.3", "u", "u", "b", "56"], ["17.4", "u", "u", "b", "57"], ["17.6", "u",
  "u", "b", "58"], ["17.7", "u", "u", "b", "59"], ["17.9", "u", "u", "b", "60"], ["17.10", "u", "u", "b", "61"], ["17.11", "u", "u", "b", "6\
2"], ["18.1", "u", "u", "b", "63"], ["18.2", "u", "u", "b", "63"], ["18.3", "u", "u", "b", "64"], ["18.4", "u", "u", "b", "65"], ["18.6", "u",
  "u", "b", "66"], ["18.7", "u", "u", "b", "67"], ["18.9", "u", "u", "b", "68"], ["18.10", "u", "u", "b", "69"], ["18.11", "u", "u", "b", "7\
0"], ["19.1", "u", "u", "b", "71"], ["19.3", "u", "u", "b", "72"], ["19.4", "u", "u", "b", "73"], ["19.5", "u", "u", "b", "75"], ["19.6", "u",
  "u", "b", "75"], ["19.7", "u", "u", "b", "75"], ["19.9", "u", "u", "b", "76"], ["19.10", "u", "u", "b", "77"], ["19.11", "u", "u", "b", "7\
8"], ["19.12", "u", "u", "b", "78"], ["20.2", "u", "u", "b", "79"], ["20.3", "u", "u", "b", "80"], ["20.4", "u", "u", "b", "81"], ["20.6", "\
u", "u", "b", "81"], ["20.7", "u", "u", "b", "83"], ["20.8", "2020-09-02", "u", "b", "84"], ["20.9", "2020-09-27", "u", "b", "85"], ["20.11",
  "2020-11-11", "u", "b", "86"], ["20.12", "2020-12-20", "u", "b", "87"], ["21.1", "2021-12-31", "u", "b", "88"], ["21.2", "u", "u", "b", "8\
8"], ["21.3", "2021-04-04", "u", "b", "89"], ["21.5", "u", "u", "b", "90"], ["21.6", "2021-09-28", "u", "b", "91"], ["21.8", "2021-09-28", "\
u", "b", "92"], ["21.9", "2021-09-29", "u", "b", "93"], ["21.11", "2021-10-29", "u", "b", "94"], ["22.1", "2021-12-31", "u", "b", "96"], ["2\
2.3", "2022-03-25", "u", "b", "98"], ["22.4", "u", "u", "b", "92"], ["22.5", "2022-05-20", "u", "b", "100"], ["22.7", "2022-07-07", "u", "b",
  "102"], ["22.8", "u", "u", "b", "104"], ["22.9", "2022-08-27", "u", "b", "104"], ["22.11", "2022-11-11", "u", "b", "106"], ["23.1", "2023-\
01-10", "u", "b", "108"], ["23.3", "2023-03-26", "u", "b", "110"], ["23.5", "2023-05-19", "u", "b", "112"], ["23.7", "2023-07-06", "u", "b",
  "114"], ["23.9", "2023-09-13", "u", "b", "116"], ["23.11", "2023-11-15", "u", "b", "118"], ["24.1", "2024-01-18", "u", "b", "120"], ["24.2",
  "2024-03-25", "u", "b", "120"], ["24.4", "2024-03-27", "u", "b", "122"], ["24.6", "2024-06-04", "u", "b", "124"], ["24.7", "2024-07-18", "\
u", "b", "126"], ["24.9", "2024-10-01", "u", "b", "126"], ["24.10", "2024-10-11", "u", "b", "128"], ["24.12", "2024-11-30", "u", "b", "130"],
  ["25.2", "2025-04-24", "u", "b", "132"], ["25.3", "2025-04-23", "u", "b", "132"], ["25.4", "2025-04-23", "u", "b", "134"], ["25.6", "2025-\
09-04", "u", "b", "136"], ["25.8", "2025-08-30", "u", "b", "138"]] }, uc_android: { releases: [["10.5", "u", "u", "b", "31"], ["10.7", "u", "\
u", "b", "31"], ["10.8", "u", "u", "b", "31"], ["10.10", "u", "u", "b", "31"], ["11.0", "u", "u", "b", "31"], ["11.1", "u", "u", "b", "40"],
  ["11.2", "u", "u", "b", "40"], ["11.3", "u", "u", "b", "40"], ["11.4", "u", "u", "b", "40"], ["11.5", "u", "u", "b", "40"], ["11.6", "u", "\
u", "b", "57"], ["11.8", "u", "u", "b", "57"], ["11.9", "u", "u", "b", "57"], ["12.0", "u", "u", "b", "57"], ["12.1", "u", "u", "b", "57"], [
  "12.2", "u", "u", "b", "57"], ["12.3", "u", "u", "b", "57"], ["12.4", "u", "u", "b", "57"], ["12.5", "u", "u", "b", "57"], ["12.6", "u", "\
u", "b", "57"], ["12.7", "u", "u", "b", "57"], ["12.8", "u", "u", "b", "57"], ["12.9", "u", "u", "b", "57"], ["12.10", "u", "u", "b", "57"],
  ["12.11", "u", "u", "b", "57"], ["12.12", "u", "u", "b", "57"], ["12.13", "u", "u", "b", "57"], ["12.14", "u", "u", "b", "57"], ["13.0", "\
u", "u", "b", "57"], ["13.1", "u", "u", "b", "57"], ["13.2", "u", "u", "b", "57"], ["13.3", "2020-09-09", "u", "b", "78"], ["13.4", "2021-09\
-28", "u", "b", "78"], ["13.5", "2023-08-25", "u", "b", "78"], ["13.6", "2023-12-17", "u", "b", "78"], ["13.7", "2023-06-24", "u", "b", "78"],
  ["13.8", "2022-04-30", "u", "b", "78"], ["13.9", "2022-05-18", "u", "b", "78"], ["15.0", "2022-08-24", "u", "b", "78"], ["15.1", "2022-11-\
11", "u", "b", "78"], ["15.2", "2023-04-23", "u", "b", "78"], ["15.3", "2023-03-17", "u", "b", "100"], ["15.4", "2023-10-25", "u", "b", "100"],
  ["15.5", "2023-08-22", "u", "b", "100"], ["16.0", "2023-08-24", "u", "b", "100"], ["16.1", "2023-10-15", "u", "b", "100"], ["16.2", "2023-\
12-09", "u", "b", "100"], ["16.3", "2024-03-08", "u", "b", "100"], ["16.4", "2024-10-03", "u", "b", "100"], ["16.5", "2024-05-30", "u", "b",
  "100"], ["16.6", "2024-07-23", "u", "b", "100"], ["17.0", "2024-08-24", "u", "b", "100"], ["17.1", "2024-09-26", "u", "b", "100"], ["17.2",
  "2024-11-29", "u", "b", "100"], ["17.3", "2025-01-07", "u", "b", "100"], ["17.4", "2025-02-26", "u", "b", "100"], ["17.5", "2025-04-08", "\
u", "b", "100"], ["17.6", "2025-05-15", "u", "b", "123"], ["17.7", "2025-06-11", "u", "b", "123"], ["17.8", "2025-07-30", "u", "b", "123"], [
  "18.0", "2025-08-17", "u", "b", "123"]] }, qq_android: { releases: [["6.0", "u", "u", "b", "37"], ["6.1", "u", "u", "b", "37"], ["6.2", "u",
  "u", "b", "37"], ["6.3", "u", "u", "b", "37"], ["6.4", "u", "u", "b", "37"], ["6.6", "u", "u", "b", "37"], ["6.7", "u", "u", "b", "37"], [
  "6.8", "u", "u", "b", "37"], ["6.9", "u", "u", "b", "37"], ["7.0", "u", "u", "b", "37"], ["7.1", "u", "u", "b", "37"], ["7.2", "u", "u", "\
b", "37"], ["7.3", "u", "u", "b", "37"], ["7.4", "u", "u", "b", "37"], ["7.5", "u", "u", "b", "37"], ["7.6", "u", "u", "b", "37"], ["7.7", "\
u", "u", "b", "37"], ["7.8", "u", "u", "b", "37"], ["7.9", "u", "u", "b", "37"], ["8.0", "u", "u", "b", "37"], ["8.1", "u", "u", "b", "57"],
  ["8.2", "u", "u", "b", "57"], ["8.3", "u", "u", "b", "57"], ["8.4", "u", "u", "b", "57"], ["8.5", "u", "u", "b", "57"], ["8.6", "u", "u", "\
b", "57"], ["8.7", "u", "u", "b", "57"], ["8.8", "u", "u", "b", "57"], ["8.9", "u", "u", "b", "57"], ["9.1", "u", "u", "b", "57"], ["9.6", "\
u", "u", "b", "66"], ["9.7", "u", "u", "b", "66"], ["9.8", "u", "u", "b", "66"], ["10.0", "u", "u", "b", "66"], ["10.1", "u", "u", "b", "66"],
  ["10.2", "u", "u", "b", "66"], ["10.3", "u", "u", "b", "66"], ["10.4", "u", "u", "b", "66"], ["10.5", "u", "u", "b", "66"], ["10.7", "2020\
-09-09", "u", "b", "66"], ["10.9", "2020-11-22", "u", "b", "77"], ["11.0", "u", "u", "b", "77"], ["11.2", "2021-01-30", "u", "b", "77"], ["1\
1.3", "2021-03-31", "u", "b", "77"], ["11.7", "2021-11-02", "u", "b", "89"], ["11.9", "u", "u", "b", "89"], ["12.0", "2021-11-04", "u", "b",
  "89"], ["12.1", "2021-11-05", "u", "b", "89"], ["12.2", "2021-12-07", "u", "b", "89"], ["12.5", "2022-04-07", "u", "b", "89"], ["12.7", "2\
022-05-21", "u", "b", "89"], ["12.8", "2022-06-30", "u", "b", "89"], ["12.9", "2022-07-26", "u", "b", "89"], ["13.0", "2022-08-15", "u", "b",
  "89"], ["13.1", "2022-09-10", "u", "b", "89"], ["13.2", "2022-10-26", "u", "b", "89"], ["13.3", "2022-11-09", "u", "b", "89"], ["13.4", "2\
023-04-26", "u", "b", "98"], ["13.5", "2023-02-06", "u", "b", "98"], ["13.6", "2023-02-09", "u", "b", "98"], ["13.7", "2023-04-21", "u", "b",
  "98"], ["13.8", "2023-04-21", "u", "b", "98"], ["14.0", "2023-12-12", "u", "b", "98"], ["14.1", "2023-07-16", "u", "b", "98"], ["14.2", "2\
023-10-14", "u", "b", "109"], ["14.3", "2023-09-13", "u", "b", "109"], ["14.4", "2023-10-31", "u", "b", "109"], ["14.5", "2023-11-12", "u", "\
b", "109"], ["14.6", "2023-12-24", "u", "b", "109"], ["14.7", "2024-01-18", "u", "b", "109"], ["14.8", "2024-03-04", "u", "b", "109"], ["14.\
9", "2024-04-09", "u", "b", "109"], ["15.0", "2024-04-17", "u", "b", "109"], ["15.1", "2024-05-18", "u", "b", "109"], ["15.2", "2024-10-24",
  "u", "b", "109"], ["15.3", "2024-07-28", "u", "b", "109"], ["15.4", "2024-09-07", "u", "b", "109"], ["15.5", "2024-09-24", "u", "b", "109"],
  ["15.6", "2024-10-24", "u", "b", "109"], ["15.7", "2024-12-03", "u", "b", "109"], ["15.8", "2024-12-11", "u", "b", "109"], ["15.9", "2025-\
02-01", "u", "b", "109"], ["19.1", "2025-07-08", "u", "b", "121"], ["19.2", "2025-07-15", "u", "b", "121"], ["19.3", "2025-08-31", "u", "b",
  "121"]] }, kai_os: { releases: [["1.0", "2017-03-01", "u", "g", "37"], ["2.0", "2017-07-01", "u", "g", "48"], ["2.5", "2017-07-01", "u", "\
g", "48"], ["3.0", "2021-09-01", "u", "g", "84"], ["3.1", "2022-03-01", "u", "g", "84"], ["4.0", "2025-05-01", "u", "g", "123"]] }, facebook_android: {
  releases: [["66", "u", "u", "b", "48"], ["68", "u", "u", "b", "48"], ["74", "u", "u", "b", "50"], ["75", "u", "u", "b", "50"], ["76", "u",
  "u", "b", "50"], ["77", "u", "u", "b", "50"], ["78", "u", "u", "b", "50"], ["79", "u", "u", "b", "50"], ["80", "u", "u", "b", "51"], ["81",
  "u", "u", "b", "51"], ["82", "u", "u", "b", "51"], ["83", "u", "u", "b", "51"], ["84", "u", "u", "b", "51"], ["86", "u", "u", "b", "51"], [
  "87", "u", "u", "b", "52"], ["88", "u", "u", "b", "52"], ["89", "u", "u", "b", "52"], ["90", "u", "u", "b", "52"], ["91", "u", "u", "b", "\
52"], ["92", "u", "u", "b", "52"], ["93", "u", "u", "b", "52"], ["94", "u", "u", "b", "52"], ["95", "u", "u", "b", "53"], ["96", "u", "u", "\
b", "53"], ["97", "u", "u", "b", "53"], ["98", "u", "u", "b", "53"], ["99", "u", "u", "b", "53"], ["100", "u", "u", "b", "54"], ["101", "u",
  "u", "b", "54"], ["103", "u", "u", "b", "54"], ["104", "u", "u", "b", "54"], ["105", "u", "u", "b", "54"], ["106", "u", "u", "b", "55"], [
  "107", "u", "u", "b", "55"], ["108", "u", "u", "b", "55"], ["109", "u", "u", "b", "55"], ["110", "u", "u", "b", "55"], ["111", "u", "u", "\
b", "55"], ["112", "u", "u", "b", "56"], ["113", "u", "u", "b", "56"], ["114", "u", "u", "b", "56"], ["115", "u", "u", "b", "56"], ["116", "\
u", "u", "b", "56"], ["117", "u", "u", "b", "57"], ["118", "u", "u", "b", "57"], ["119", "u", "u", "b", "57"], ["120", "u", "u", "b", "57"],
  ["121", "u", "u", "b", "57"], ["122", "u", "u", "b", "58"], ["123", "u", "u", "b", "58"], ["124", "u", "u", "b", "58"], ["125", "u", "u", "\
b", "58"], ["126", "u", "u", "b", "58"], ["127", "u", "u", "b", "58"], ["128", "u", "u", "b", "58"], ["129", "u", "u", "b", "58"], ["130", "\
u", "u", "b", "59"], ["131", "u", "u", "b", "59"], ["132", "u", "u", "b", "59"], ["133", "u", "u", "b", "59"], ["134", "u", "u", "b", "59"],
  ["135", "u", "u", "b", "59"], ["136", "u", "u", "b", "59"], ["137", "u", "u", "b", "59"], ["138", "u", "u", "b", "60"], ["140", "u", "u", "\
b", "60"], ["142", "u", "u", "b", "61"], ["143", "u", "u", "b", "61"], ["144", "u", "u", "b", "61"], ["145", "u", "u", "b", "61"], ["146", "\
u", "u", "b", "61"], ["147", "u", "u", "b", "61"], ["148", "u", "u", "b", "61"], ["149", "u", "u", "b", "62"], ["150", "u", "u", "b", "62"],
  ["151", "u", "u", "b", "62"], ["152", "u", "u", "b", "62"], ["153", "u", "u", "b", "63"], ["154", "u", "u", "b", "63"], ["155", "u", "u", "\
b", "63"], ["156", "u", "u", "b", "63"], ["157", "u", "u", "b", "64"], ["158", "u", "u", "b", "64"], ["159", "u", "u", "b", "64"], ["160", "\
u", "u", "b", "64"], ["161", "u", "u", "b", "64"], ["162", "u", "u", "b", "64"], ["163", "u", "u", "b", "65"], ["164", "u", "u", "b", "65"],
  ["165", "u", "u", "b", "65"], ["166", "u", "u", "b", "65"], ["167", "u", "u", "b", "65"], ["168", "u", "u", "b", "65"], ["169", "u", "u", "\
b", "66"], ["170", "u", "u", "b", "66"], ["171", "u", "u", "b", "66"], ["172", "u", "u", "b", "66"], ["173", "u", "u", "b", "66"], ["174", "\
u", "u", "b", "66"], ["175", "u", "u", "b", "67"], ["176", "u", "u", "b", "67"], ["177", "u", "u", "b", "67"], ["178", "u", "u", "b", "67"],
  ["180", "u", "u", "b", "67"], ["181", "u", "u", "b", "67"], ["182", "u", "u", "b", "67"], ["183", "u", "u", "b", "68"], ["184", "u", "u", "\
b", "68"], ["185", "u", "u", "b", "68"], ["186", "u", "u", "b", "68"], ["187", "u", "u", "b", "68"], ["188", "u", "u", "b", "68"], ["202", "\
u", "u", "b", "71"], ["227", "u", "u", "b", "75"], ["228", "u", "u", "b", "75"], ["229", "u", "u", "b", "75"], ["230", "u", "u", "b", "75"],
  ["231", "u", "u", "b", "75"], ["233", "u", "u", "b", "76"], ["235", "u", "u", "b", "76"], ["236", "u", "u", "b", "76"], ["237", "u", "u", "\
b", "76"], ["238", "u", "u", "b", "76"], ["240", "u", "u", "b", "77"], ["241", "u", "u", "b", "77"], ["242", "u", "u", "b", "77"], ["243", "\
u", "u", "b", "77"], ["244", "u", "u", "b", "78"], ["245", "u", "u", "b", "78"], ["246", "u", "u", "b", "78"], ["247", "u", "u", "b", "78"],
  ["248", "u", "u", "b", "78"], ["249", "u", "u", "b", "78"], ["250", "u", "u", "b", "78"], ["251", "u", "u", "b", "79"], ["252", "u", "u", "\
b", "79"], ["253", "u", "u", "b", "79"], ["254", "u", "u", "b", "79"], ["255", "u", "u", "b", "79"], ["256", "u", "u", "b", "80"], ["257", "\
u", "u", "b", "80"], ["258", "u", "u", "b", "80"], ["259", "u", "u", "b", "80"], ["260", "u", "u", "b", "80"], ["261", "u", "u", "b", "80"],
  ["262", "u", "u", "b", "80"], ["263", "u", "u", "b", "80"], ["264", "u", "u", "b", "80"], ["265", "u", "u", "b", "80"], ["266", "u", "u", "\
b", "81"], ["267", "u", "u", "b", "81"], ["268", "u", "u", "b", "81"], ["269", "u", "u", "b", "81"], ["270", "u", "u", "b", "81"], ["271", "\
u", "u", "b", "81"], ["272", "u", "u", "b", "83"], ["273", "u", "u", "b", "83"], ["274", "u", "u", "b", "83"], ["275", "u", "u", "b", "83"],
  ["297", "2020-12-02", "u", "b", "86"], ["348", "2021-12-19", "u", "b", "96"], ["399", "2023-02-04", "u", "b", "109"], ["400", "2023-02-10",
  "u", "b", "109"], ["420", "2023-06-28", "u", "b", "114"], ["430", "2023-09-03", "u", "b", "116"], ["434", "2023-10-05", "u", "b", "117"], [
  "436", "2023-10-13", "u", "b", "117"], ["437", "u", "u", "b", "118"], ["438", "2023-10-28", "u", "b", "118"], ["439", "2023-11-11", "u", "\
b", "119"], ["440", "2023-11-12", "u", "b", "119"], ["441", "2023-11-20", "u", "b", "119"], ["442", "2023-11-29", "u", "b", "119"], ["443", "\
2023-12-07", "u", "b", "120"], ["444", "2023-12-13", "u", "b", "120"], ["445", "2023-12-21", "u", "b", "120"], ["446", "2024-01-06", "u", "b",
  "120"], ["447", "2024-01-12", "u", "b", "120"], ["448", "2024-01-29", "u", "b", "121"], ["449", "2024-02-02", "u", "b", "121"], ["450", "2\
024-02-05", "u", "b", "121"], ["451", "2024-02-17", "u", "b", "121"], ["452", "2024-02-25", "u", "b", "122"], ["453", "2024-02-28", "u", "b",
  "122"], ["454", "2024-03-04", "u", "b", "122"], ["465", "2024-07-07", "u", "b", "126"], ["466", "u", "u", "b", "126"], ["469", "u", "u", "\
b", "126"], ["471", "2024-07-10", "u", "b", "126"], ["472", "2024-07-11", "u", "b", "126"], ["474", "2024-07-30", "u", "b", "127"], ["475", "\
2024-08-01", "u", "b", "127"], ["476", "2024-08-09", "u", "b", "127"], ["477", "2024-08-16", "u", "b", "127"], ["478", "2024-08-21", "u", "b",
  "128"], ["479", "2024-08-31", "u", "b", "128"], ["480", "2024-09-07", "u", "b", "128"], ["481", "2024-09-14", "u", "b", "128"], ["482", "2\
024-09-20", "u", "b", "129"], ["483", "2024-09-27", "u", "b", "129"], ["484", "2024-10-04", "u", "b", "129"], ["485", "2024-10-11", "u", "b",
  "129"], ["486", "2024-10-18", "u", "b", "130"], ["487", "2024-10-26", "u", "b", "130"], ["488", "2024-11-02", "u", "b", "130"], ["489", "2\
024-11-09", "u", "b", "130"], ["494", "2024-12-26", "u", "b", "131"], ["497", "2025-01-26", "u", "b", "132"], ["503", "2025-03-12", "u", "b",
  "134"], ["514", "2025-05-28", "u", "b", "136"], ["515", "2025-05-31", "u", "b", "137"]] }, instagram_android: { releases: [["23", "u", "u",
  "b", "62"], ["24", "u", "u", "b", "62"], ["25", "u", "u", "b", "62"], ["26", "u", "u", "b", "63"], ["27", "u", "u", "b", "63"], ["28", "u",
  "u", "b", "63"], ["29", "u", "u", "b", "63"], ["30", "u", "u", "b", "63"], ["31", "u", "u", "b", "64"], ["32", "u", "u", "b", "64"], ["33",
  "u", "u", "b", "64"], ["34", "u", "u", "b", "64"], ["35", "u", "u", "b", "65"], ["36", "u", "u", "b", "65"], ["37", "u", "u", "b", "65"], [
  "38", "u", "u", "b", "65"], ["39", "u", "u", "b", "65"], ["40", "u", "u", "b", "65"], ["41", "u", "u", "b", "65"], ["42", "u", "u", "b", "\
66"], ["43", "u", "u", "b", "66"], ["44", "u", "u", "b", "66"], ["45", "u", "u", "b", "66"], ["46", "u", "u", "b", "66"], ["47", "u", "u", "\
b", "66"], ["48", "u", "u", "b", "67"], ["49", "u", "u", "b", "67"], ["50", "u", "u", "b", "67"], ["51", "u", "u", "b", "67"], ["52", "u", "\
u", "b", "67"], ["53", "u", "u", "b", "67"], ["54", "u", "u", "b", "67"], ["55", "u", "u", "b", "67"], ["56", "u", "u", "b", "68"], ["57", "\
u", "u", "b", "68"], ["58", "u", "u", "b", "68"], ["59", "u", "u", "b", "68"], ["60", "u", "u", "b", "68"], ["61", "u", "u", "b", "68"], ["6\
5", "u", "u", "b", "69"], ["66", "u", "u", "b", "69"], ["68", "u", "u", "b", "69"], ["72", "u", "u", "b", "70"], ["74", "u", "u", "b", "71"],
  ["75", "u", "u", "b", "71"], ["79", "u", "u", "b", "71"], ["81", "u", "u", "b", "72"], ["82", "u", "u", "b", "72"], ["83", "u", "u", "b", "\
72"], ["84", "u", "u", "b", "73"], ["86", "u", "u", "b", "73"], ["95", "u", "u", "b", "74"], ["96", "u", "u", "b", "80"], ["97", "u", "u", "\
b", "80"], ["98", "u", "u", "b", "80"], ["103", "u", "u", "b", "80"], ["104", "u", "u", "b", "80"], ["117", "u", "u", "b", "80"], ["118", "u",
  "u", "b", "80"], ["119", "u", "u", "b", "80"], ["120", "u", "u", "b", "80"], ["121", "u", "u", "b", "80"], ["127", "u", "u", "b", "80"], [
  "128", "u", "u", "b", "80"], ["129", "u", "u", "b", "80"], ["130", "u", "u", "b", "80"], ["131", "u", "u", "b", "80"], ["132", "u", "u", "\
b", "80"], ["133", "u", "u", "b", "80"], ["134", "u", "u", "b", "80"], ["135", "u", "u", "b", "80"], ["136", "u", "u", "b", "80"], ["137", "\
u", "u", "b", "81"], ["138", "u", "u", "b", "81"], ["139", "u", "u", "b", "81"], ["140", "u", "u", "b", "81"], ["141", "u", "u", "b", "81"],
  ["142", "u", "u", "b", "81"], ["143", "u", "u", "b", "83"], ["144", "u", "u", "b", "83"], ["145", "u", "u", "b", "83"], ["146", "u", "u", "\
b", "83"], ["153", "u", "u", "b", "84"], ["163", "u", "u", "b", "92"], ["164", "u", "u", "b", "92"], ["230", "u", "u", "b", "92"], ["258", "\
2022-11-04", "u", "b", "106"], ["259", "2022-11-04", "u", "b", "106"], ["279", "2023-12-31", "u", "b", "109"], ["281", "u", "u", "b", "109"],
  ["288", "u", "u", "b", "114"], ["289", "2023-12-21", "u", "b", "114"], ["290", "2023-12-30", "u", "b", "114"], ["292", "u", "u", "b", "115"],
  ["295", "u", "u", "b", "115"], ["296", "u", "u", "b", "115"], ["297", "u", "u", "b", "115"], ["298", "2024-01-11", "u", "b", "115"], ["299",
  "u", "u", "b", "115"], ["300", "u", "u", "b", "116"], ["301", "2024-01-12", "u", "b", "116"], ["302", "u", "u", "b", "117"], ["303", "u", "\
u", "b", "117"], ["304", "u", "u", "b", "117"], ["305", "u", "u", "b", "117"], ["306", "2024-01-17", "u", "b", "118"], ["307", "u", "u", "b",
  "118"], ["308", "2024-01-19", "u", "b", "118"], ["309", "u", "u", "b", "119"], ["310", "u", "u", "b", "119"], ["311", "u", "u", "b", "120"],
  ["312", "u", "u", "b", "120"], ["313", "u", "u", "b", "120"], ["314", "u", "u", "b", "120"], ["315", "2024-01-19", "u", "b", "120"], ["316",
  "2024-01-25", "u", "b", "120"], ["317", "2024-02-03", "u", "b", "121"], ["318", "2024-02-16", "u", "b", "121"], ["320", "2024-03-04", "u",
  "b", "121"], ["321", "2024-03-07", "u", "b", "122"], ["338", "2024-07-06", "u", "b", "126"], ["346", "2024-09-01", "u", "b", "127"], ["347",
  "2024-09-11", "u", "b", "127"], ["349", "2024-09-20", "u", "b", "128"], ["355", "2024-11-06", "u", "b", "130"], ["366", "u", "u", "b", "13\
2"], ["367", "2025-02-15", "u", "b", "132"], ["378", "2025-05-03", "u", "b", "135"], ["381", "2025-06-19", "u", "b", "137"], ["382", "2025-0\
6-19", "u", "b", "137"], ["383", "2025-06-18", "u", "b", "137"], ["384", "2025-06-16", "u", "b", "137"], ["385", "2025-06-27", "u", "b", "13\
7"], ["387", "2025-07-09", "u", "b", "137"], ["390", "2025-07-26", "u", "b", "138"], ["392", "2025-08-12", "u", "b", "138"], ["394", "2025-0\
8-26", "u", "b", "139"], ["395", "2025-09-13", "u", "b", "139"]] } }, Dfe = [["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\
1", si: "1" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1", fa: "4", s: "4", si: "3.2" }], ["2019-03-25", { c: "66", ca: "66", e: "1\
6", f: "57", fa: "57", s: "12.1", si: "12.2" }], ["2019-03-25", { c: "66", ca: "66", e: "16", f: "57", fa: "57", s: "12.1", si: "12.2" }], [
  "2024-03-19", { c: "116", ca: "116", e: "116", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2025-06-26", { c: "138", ca: "138", e: "13\
8", f: "118", fa: "118", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-0\
7-29", { c: "17", ca: "18", e: "12", f: "5", fa: "5", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1",
  si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-04-16", { c: "123", ca: "123", e: "123",
  f: "125", fa: "125", s: "17.4", si: "17.4" }], ["2020-01-15", { c: "37", ca: "37", e: "79", f: "27", fa: "27", s: "9.1", si: "9.3" }], ["2\
024-07-09", { c: "77", ca: "77", e: "79", f: "128", fa: "128", s: "17.4", si: "17.4" }], ["2016-06-07", { c: "32", ca: "30", e: "12", f: "47",
  fa: "47", s: "8", si: "8" }], ["2023-07-04", { c: "112", ca: "112", e: "112", f: "115", fa: "115", s: "16", si: "16" }], ["2015-09-30", { c: "\
43", ca: "43", e: "12", f: "16", fa: "16", s: "9", si: "9" }], ["2022-03-14", { c: "84", ca: "84", e: "84", f: "80", fa: "80", s: "15.4", si: "\
15.4" }], ["2023-10-24", { c: "103", ca: "103", e: "103", f: "119", fa: "119", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "\
12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-03-14", { c: "92", ca: "92", e: "92", f: "90", fa: "90", s: "15.4", si: "15.4" }], ["2023-0\
7-04", { c: "110", ca: "110", e: "110", f: "115", fa: "115", s: "16", si: "16" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "34", fa: "\
34", s: "10", si: "10" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "37", fa: "37", s: "10", si: "10" }], ["2016-09-20", { c: "45", ca: "\
45", e: "12", f: "37", fa: "37", s: "10", si: "10" }], ["2022-08-23", { c: "97", ca: "97", e: "97", f: "104", fa: "104", s: "15.4", si: "15.\
4" }], ["2020-01-15", { c: "69", ca: "69", e: "79", f: "62", fa: "62", s: "12", si: "12" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "\
38", fa: "38", s: "10", si: "10" }], ["2024-01-25", { c: "121", ca: "121", e: "121", f: "115", fa: "115", s: "16.4", si: "16.4" }], ["2024-0\
3-05", { c: "117", ca: "117", e: "117", f: "119", fa: "119", s: "17.4", si: "17.4" }], ["2016-09-20", { c: "47", ca: "47", e: "14", f: "43",
  fa: "43", s: "10", si: "10" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "5" }], ["2015-07-29", { c: "3", ca: "\
18", e: "12", f: "3", fa: "4", s: "4", si: "3.2" }], ["2018-05-09", { c: "66", ca: "66", e: "14", f: "60", fa: "60", s: "10", si: "10" }], [
  "2016-09-20", { c: "45", ca: "45", e: "12", f: "38", fa: "38", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "5", ca: "18",
  e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2021-09-20", { c: "88", ca: "88", e: "88", f: "89", fa: "89", s: "15", si: "15" }], ["20\
17-04-05", { c: "55", ca: "55", e: "15", f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2024-06-11", { c: "76", ca: "76", e: "79", f: "127",
  fa: "127", s: "13.1", si: "13.4" }], ["2020-01-15", { c: "63", ca: "63", e: "79", f: "55", fa: "55", s: "12", si: "12" }], ["2020-01-15", {
  c: "63", ca: "63", e: "79", f: "57", fa: "57", s: "12", si: "12" }], ["2025-04-01", { c: "133", ca: "133", e: "133", f: "137", fa: "137", s: "\
18.4", si: "18.4" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "3", ca: "18", e: "\
12", f: "3.5", fa: "4", s: "3.1", si: "3" }], ["2021-04-26", { c: "66", ca: "66", e: "79", f: "76", fa: "79", s: "14.1", si: "14.5" }], ["20\
23-02-09", { c: "110", ca: "110", e: "110", f: "86", fa: "86", s: "15", si: "15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "4", si: "3.2" }], ["2020-01-15", { c: "54", ca: "54", e: "79", f: "63", fa: "63", s: "10.1", si: "10.3" }], ["2024-01-26", { c: "85",
  ca: "85", e: "121", f: "93", fa: "93", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }],
  ["2022-03-14", { c: "37", ca: "37", e: "79", f: "47", fa: "47", s: "15.4", si: "15.4" }], ["2024-09-16", { c: "76", ca: "76", e: "79", f: "\
103", fa: "103", s: "18", si: "18" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "3.6", fa: "4", s: "1.3", si: "1" }], ["2022-03-14", {
  c: "1", ca: "18", e: "12", f: "25", fa: "25", s: "15.4", si: "15.4" }], ["2020-01-15", { c: "35", ca: "59", e: "79", f: "30", fa: "54", s: "\
8", si: "8" }], ["2015-07-29", { c: "21", ca: "25", e: "12", f: "22", fa: "22", s: "5.1", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "\
12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "3.6", fa: "4", s: "1.3", si: "1" }], ["2015-07-29",
  { c: "21", ca: "25", e: "12", f: "22", fa: "22", s: "5.1", si: "4" }], ["2015-07-29", { c: "25", ca: "25", e: "12", f: "13", fa: "14", s: "\
7", si: "7" }], ["2016-09-20", { c: "30", ca: "30", e: "12", f: "49", fa: "49", s: "8", si: "8" }], ["2015-07-29", { c: "21", ca: "25", e: "\
12", f: "9", fa: "18", s: "5.1", si: "4.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29",
  { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2016-09-20", { c: "30", ca: "30", e: "12", f: "4", fa: "4", s: "10", si: "\
10" }], ["2020-01-15", { c: "16", ca: "18", e: "79", f: "10", fa: "10", s: "6", si: "6" }], ["2015-07-29", { c: "\u226415", ca: "18", e: "12",
  f: "10", fa: "10", s: "\u22644", si: "\u22643.2" }], ["2018-04-12", { c: "39", ca: "42", e: "14", f: "31", fa: "31", s: "11.1", si: "11.3" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1.5", fa: "4", s: "4", si: "3.2" }], ["2020-09-16", { c: "67", ca: "67", e: "79", f: "68",
  fa: "68", s: "14", si: "14" }], ["2021-09-20", { c: "67", ca: "67", e: "79", f: "68", fa: "68", s: "15", si: "15" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3",
  si: "1" }], ["2017-02-01", { c: "56", ca: "56", e: "12", f: "50", fa: "50", s: "9.1", si: "9.3" }], ["2015-07-29", { c: "4", ca: "18", e: "\
12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "14", s: "1", si: "3" }], ["2015-07-29",
  { c: "10", ca: "18", e: "12", f: "4", fa: "4", s: "5.1", si: "5" }], ["2015-07-29", { c: "10", ca: "18", e: "12", f: "29", fa: "29", s: "5\
.1", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2022-03-14", { c: "54", ca: "54", e: "79",
  f: "38", fa: "38", s: "15.4", si: "15.4" }], ["2017-09-19", { c: "50", ca: "51", e: "15", f: "44", fa: "44", s: "11", si: "11" }], ["2015-\
07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "26", ca: "28", e: "12", f: "16", fa: "16", s: "\
7", si: "7" }], ["2023-06-06", { c: "110", ca: "110", e: "110", f: "114", fa: "114", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18",
  e: "12", f: "1.5", fa: "4", s: "2", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1.5", fa: "4", s: "2", si: "1" }], ["2024-\
09-16", { c: "99", ca: "99", e: "99", f: "28", fa: "28", s: "18", si: "18" }], ["2023-04-11", { c: "99", ca: "99", e: "99", f: "112", fa: "1\
12", s: "16.4", si: "16.4" }], ["2023-12-11", { c: "99", ca: "99", e: "99", f: "113", fa: "113", s: "17.2", si: "17.2" }], ["2023-04-11", { c: "\
99", ca: "99", e: "99", f: "112", fa: "112", s: "16.4", si: "16.4" }], ["2023-12-11", { c: "118", ca: "118", e: "118", f: "97", fa: "97", s: "\
17.2", si: "17.2" }], ["2020-01-15", { c: "51", ca: "51", e: "79", f: "43", fa: "43", s: "11", si: "11" }], ["2020-01-15", { c: "57", ca: "5\
7", e: "79", f: "53", fa: "53", s: "11.1", si: "11.3" }], ["2022-03-14", { c: "99", ca: "99", e: "99", f: "97", fa: "97", s: "15.4", si: "15\
.4" }], ["2020-01-15", { c: "49", ca: "49", e: "79", f: "47", fa: "47", s: "9", si: "9" }], ["2015-07-29", { c: "27", ca: "27", e: "12", f: "\
1", fa: "4", s: "7", si: "7" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2015-09-22", { c: "4", ca: "\
18", e: "12", f: "41", fa: "41", s: "5", si: "4.2" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1.5", fa: "4", s: "4", si: "4" }], ["\
2024-03-05", { c: "105", ca: "105", e: "105", f: "106", fa: "106", s: "17.4", si: "17.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2016-03-08", { c: "42", ca: "42", e: "13", f: "45", fa: "45", s: "9", si: "9" }], ["2023-09\
-18", { c: "117", ca: "117", e: "117", f: "63", fa: "63", s: "17", si: "17" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "71", fa: "7\
9", s: "13.1", si: "13" }], ["2020-01-15", { c: "55", ca: "55", e: "79", f: "49", fa: "49", s: "12.1", si: "12.2" }], ["2023-11-02", { c: "1\
19", ca: "119", e: "119", f: "54", fa: "54", s: "13.1", si: "13.4" }], ["2017-03-27", { c: "41", ca: "41", e: "12", f: "22", fa: "22", s: "1\
0.1", si: "10.3" }], ["2025-03-31", { c: "121", ca: "121", e: "121", f: "127", fa: "127", s: "18.4", si: "18.4" }], ["2015-07-29", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1",
  si: "1" }], ["2023-05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "15", si: "15" }], ["2023-02-14", { c: "58", ca: "58",
  e: "79", f: "110", fa: "110", s: "10", si: "10" }], ["2023-05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "16.2", si: "1\
6.2" }], ["2022-02-03", { c: "98", ca: "98", e: "98", f: "96", fa: "96", s: "13", si: "13" }], ["2020-01-15", { c: "53", ca: "53", e: "79", f: "\
31", fa: "31", s: "11.1", si: "11.3" }], ["2017-03-07", { c: "50", ca: "50", e: "12", f: "52", fa: "52", s: "9", si: "9" }], ["2020-07-28", {
  c: "50", ca: "50", e: "12", f: "71", fa: "79", s: "9", si: "9" }], ["2025-08-19", { c: "137", ca: "137", e: "137", f: "142", fa: "142", s: "\
17", si: "17" }], ["2017-04-19", { c: "26", ca: "26", e: "12", f: "53", fa: "53", s: "7", si: "7" }], ["2023-05-09", { c: "80", ca: "80", e: "\
80", f: "113", fa: "113", s: "16.4", si: "16.4" }], ["2020-11-17", { c: "69", ca: "69", e: "79", f: "83", fa: "83", s: "12.1", si: "12.2" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "4", fa: "4", s: "3", si: "1" }], ["2018-12-11", { c: "40", ca: "40", e: "18", f: "51", fa: "\
64", s: "10.1", si: "10.3" }], ["2023-03-27", { c: "73", ca: "73", e: "79", f: "101", fa: "101", s: "16.4", si: "16.4" }], ["2022-03-14", { c: "\
52", ca: "52", e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }], ["2022-09-12", { c: "105", ca: "105", e: "105", f: "101", fa: "101", s: "\
16", si: "16" }], ["2023-09-18", { c: "83", ca: "83", e: "83", f: "107", fa: "107", s: "17", si: "17" }], ["2022-03-14", { c: "52", ca: "52",
  e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }], ["2022-03-14", { c: "52", ca: "52", e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }],
  ["2022-03-14", { c: "52", ca: "52", e: "79", f: "69", fa: "79", s: "15.4", si: "15.4" }], ["2022-07-26", { c: "52", ca: "52", e: "79", f: "\
103", fa: "103", s: "15.4", si: "15.4" }], ["2023-02-14", { c: "105", ca: "105", e: "105", f: "110", fa: "110", s: "16", si: "16" }], ["2015\
-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "4", fa: "4", s: "\
\u22644", si: "\u22643.2" }], ["2025-03-04", { c: "51", ca: "51", e: "12", f: "136", fa: "136", s: "5.1", si: "5" }], ["2024-09-16", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "18", si: "18" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }],
  ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "3.2" }], ["2023-12-11", { c: "85", ca: "85", e: "85", f: "68",
  fa: "68", s: "17.2", si: "17.2" }], ["2023-09-18", { c: "91", ca: "91", e: "91", f: "33", fa: "33", s: "17", si: "17" }], ["2015-07-29", {
  c: "2", ca: "18", e: "12", f: "1", fa: "25", s: "3", si: "1" }], ["2023-12-11", { c: "59", ca: "59", e: "79", f: "98", fa: "98", s: "17.2",
  si: "17.2" }], ["2020-01-15", { c: "60", ca: "60", e: "79", f: "60", fa: "60", s: "13", si: "13" }], ["2016-08-02", { c: "25", ca: "25", e: "\
14", f: "23", fa: "23", s: "7", si: "7" }], ["2020-01-15", { c: "46", ca: "46", e: "79", f: "31", fa: "31", s: "10.1", si: "10.3" }], ["2015\
-09-30", { c: "28", ca: "28", e: "12", f: "22", fa: "22", s: "9", si: "9" }], ["2020-01-15", { c: "61", ca: "61", e: "79", f: "55", fa: "55",
  s: "11", si: "11" }], ["2015-07-29", { c: "16", ca: "18", e: "12", f: "4", fa: "4", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18",
  e: "12", f: "1.5", fa: "4", s: "4", si: "3.2" }], ["2017-04-05", { c: "49", ca: "49", e: "15", f: "31", fa: "31", s: "9.1", si: "9.3" }], [
  "2017-10-24", { c: "62", ca: "62", e: "14", f: "22", fa: "22", s: "10", si: "10" }], ["2015-07-29", { c: "\u22644", ca: "18", e: "12", f: "\
\u22642", fa: "4", s: "\u22643.1", si: "\u22642" }], ["2015-07-29", { c: "7", ca: "18", e: "12", f: "6", fa: "6", s: "5.1", si: "5" }], ["20\
15-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-02-20", { c: "111", ca: "111", e: "111", f: "123", fa: "\
123", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "4", fa: "4", s: "4", si: "5" }], ["2020-01-15", { c: "10", ca: "\
18", e: "79", f: "4", fa: "4", s: "5", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "60", ca: "60", e: "79",
  f: "55", fa: "55", s: "11.1", si: "11.3" }], ["2020-01-15", { c: "12", ca: "18", e: "79", f: "49", fa: "49", s: "6", si: "6" }], ["2024-09\
-03", { c: "120", ca: "120", e: "120", f: "130", fa: "130", s: "17.2", si: "17.2" }], ["2023-09-18", { c: "31", ca: "31", e: "12", f: "6", fa: "\
6", s: "17", si: "4.2" }], ["2015-07-29", { c: "15", ca: "18", e: "12", f: "1", fa: "4", s: "6", si: "6" }], ["2022-03-14", { c: "37", ca: "\
37", e: "79", f: "98", fa: "98", s: "15.4", si: "15.4" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "49", fa: "49", s: "16.4", si: "\
16.4" }], ["2023-08-01", { c: "17", ca: "18", e: "79", f: "116", fa: "116", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "58", ca: "58", e: "79", f: "53", fa: "53", s: "13", si: "13" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["\u22642017-04-05", { c: "1", ca: "18", e: "\u226415", f: "3", fa: "4", s: "\u22644",
  si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "\
12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "61", ca: "61", e: "79", f: "33", fa: "33", s: "11", si: "11" }], ["2020-01-15",
  { c: "1", ca: "18", e: "79", f: "1", fa: "4", s: "4", si: "3.2" }], ["2016-03-21", { c: "31", ca: "31", e: "12", f: "12", fa: "14", s: "9.\
1", si: "9.3" }], ["2019-09-19", { c: "14", ca: "18", e: "18", f: "20", fa: "20", s: "10.1", si: "13" }], ["2015-07-29", { c: "3", ca: "18",
  e: "12", f: "3.5", fa: "4", s: "4", si: "3.2" }], ["2022-05-03", { c: "98", ca: "98", e: "98", f: "100", fa: "100", s: "13.1", si: "13.4" }],
  ["2020-01-15", { c: "43", ca: "43", e: "79", f: "46", fa: "46", s: "11.1", si: "11.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15",
  { c: "1", ca: "18", e: "79", f: "1.5", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "3.1", si: "2" }], ["2019-03-25", { c: "42", ca: "42", e: "13", f: "38", fa: "38", s: "12.1", si: "12.2" }], ["2021-11-02", { c: "77",
  ca: "77", e: "79", f: "94", fa: "94", s: "13.1", si: "13.4" }], ["2021-09-20", { c: "93", ca: "93", e: "93", f: "91", fa: "91", s: "15", si: "\
15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1",
  fa: "4", s: "1", si: "1" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "118", fa: "118", s: "15.4", si: "15.4" }], ["2017-03-27",
  { c: "52", ca: "52", e: "14", f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2018-04-30", { c: "38", ca: "38", e: "17", f: "47", fa: "35",
  s: "9", si: "9" }], ["2021-09-20", { c: "56", ca: "56", e: "79", f: "51", fa: "51", s: "15", si: "15" }], ["2020-09-16", { c: "63", ca: "6\
3", e: "17", f: "47", fa: "36", s: "14", si: "14" }], ["2020-02-07", { c: "40", ca: "40", e: "80", f: "58", fa: "28", s: "9", si: "9" }], ["\
2016-06-07", { c: "34", ca: "34", e: "12", f: "47", fa: "47", s: "9.1", si: "9.3" }], ["2017-03-27", { c: "42", ca: "42", e: "14", f: "39", fa: "\
39", s: "10.1", si: "10.3" }], ["2023-03-27", { c: "80", ca: "80", e: "80", f: "90", fa: "90", s: "16.4", si: "16.4" }], ["2024-10-29", { c: "\
103", ca: "103", e: "103", f: "132", fa: "132", s: "17.2", si: "17.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u2264\
4", si: "\u22643.2" }], ["2015-07-29", { c: "8", ca: "18", e: "12", f: "4", fa: "4", s: "5.1", si: "5" }], ["2020-01-15", { c: "38", ca: "38",
  e: "79", f: "28", fa: "28", s: "10.1", si: "10.3" }], ["2021-04-26", { c: "89", ca: "89", e: "89", f: "82", fa: "82", s: "14.1", si: "14.5" }],
  ["2016-09-07", { c: "53", ca: "53", e: "12", f: "35", fa: "35", s: "9.1", si: "9.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1",
  fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2021-11-02", { c: "46", ca: "\
46", e: "79", f: "94", fa: "94", s: "11", si: "11" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["20\
15-09-30", { c: "29", ca: "29", e: "12", f: "20", fa: "20", s: "9", si: "9" }], ["2021-04-26", { c: "84", ca: "84", e: "84", f: "63", fa: "6\
3", s: "14.1", si: "14.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2025-04-04", { c: "135", ca: "\
135", e: "135", f: "129", fa: "129", s: "18.2", si: "18.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "24", fa: "24", s: "3.1", si: "\
2" }], ["2022-03-14", { c: "86", ca: "86", e: "86", f: "85", fa: "85", s: "15.4", si: "15.4" }], ["2020-01-15", { c: "60", ca: "60", e: "79",
  f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2020-01-15", { c: "60", ca: "60", e: "79", f: "58", fa: "58", s: "11.1", si: "11.3" }], ["2\
016-09-20", { c: "36", ca: "36", e: "14", f: "39", fa: "39", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1", si: "1" }], ["2021-09-07", { c: "56", ca: "56", e: "79", f: "92", fa: "92", s: "11", si: "11" }], ["2017-04-05", { c: "48", ca: "\
48", e: "15", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "33", ca: "33", e: "79", f: "32", fa: "32", s: "9", si: "9" }],
  ["2020-01-15", { c: "35", ca: "35", e: "79", f: "41", fa: "41", s: "10", si: "10" }], ["2020-03-24", { c: "79", ca: "79", e: "17", f: "62",
  fa: "62", s: "13.1", si: "13.4" }], ["2022-11-15", { c: "101", ca: "101", e: "101", f: "107", fa: "107", s: "15.4", si: "15.4" }], ["2015-\
07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1",
  si: "1" }], ["2024-07-25", { c: "127", ca: "127", e: "127", f: "118", fa: "118", s: "17", si: "17" }], ["2015-07-29", { c: "1", ca: "18", e: "\
12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-01-06", { c: "97", ca: "97", e: "97", f: "34", fa: "34", s: "9", si: "9" }], ["2023-03-27",
  { c: "97", ca: "97", e: "97", f: "111", fa: "111", s: "16.4", si: "16.4" }], ["2023-03-27", { c: "97", ca: "97", e: "97", f: "111", fa: "1\
11", s: "16.4", si: "16.4" }], ["2023-03-27", { c: "97", ca: "97", e: "97", f: "111", fa: "111", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-03-13", { c: "111", ca: "111", e: "111", f: "34", fa: "34", s: "9.1", si: "\
9.3" }], ["2020-01-15", { c: "52", ca: "52", e: "79", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "63", ca: "63", e: "79",
  f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "34", ca: "34", e: "79", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2020-\
01-15", { c: "52", ca: "52", e: "79", f: "34", fa: "34", s: "9.1", si: "9.3" }], ["2018-09-05", { c: "62", ca: "62", e: "17", f: "62", fa: "\
62", s: "11", si: "11" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-09-12", { c: "89", ca: "8\
9", e: "79", f: "89", fa: "89", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["202\
3-03-27", { c: "77", ca: "77", e: "79", f: "98", fa: "98", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "10", ca: "18", e: "12", f: "4", fa: "\
4", s: "5", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-27", { c: "35", ca: "35",
  e: "12", f: "29", fa: "32", s: "10.1", si: "10.3" }], ["2016-09-20", { c: "39", ca: "39", e: "13", f: "26", fa: "26", s: "10", si: "10" }],
  ["2015-07-29", { c: "5", ca: "18", e: "12", f: "3.5", fa: "4", s: "5", si: "\u22643" }], ["2015-07-29", { c: "11", ca: "18", e: "12", f: "\
3.5", fa: "4", s: "5.1", si: "5" }], ["2024-09-16", { c: "125", ca: "125", e: "125", f: "128", fa: "128", s: "18", si: "18" }], ["2020-01-15",
  { c: "71", ca: "71", e: "79", f: "65", fa: "65", s: "12.1", si: "12.2" }], ["2024-06-11", { c: "111", ca: "111", e: "111", f: "127", fa: "\
127", s: "16.2", si: "16.2" }], ["2015-07-29", { c: "26", ca: "26", e: "12", f: "3.6", fa: "4", s: "7", si: "7" }], ["2017-10-17", { c: "57",
  ca: "57", e: "16", f: "52", fa: "52", s: "10.1", si: "10.3" }], ["2022-10-27", { c: "107", ca: "107", e: "107", f: "66", fa: "66", s: "16",
  si: "16" }], ["2022-03-14", { c: "37", ca: "37", e: "15", f: "48", fa: "48", s: "15.4", si: "15.4" }], ["2023-12-19", { c: "105", ca: "105",
  e: "105", f: "121", fa: "121", s: "15.4", si: "15.4" }], ["2020-03-24", { c: "74", ca: "74", e: "79", f: "67", fa: "67", s: "13.1", si: "1\
3.4" }], ["2015-07-29", { c: "16", ca: "18", e: "12", f: "11", fa: "14", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }],
  ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4" }], ["2020-01-15", { c: "54", ca: "54", e: "79", f: "63", fa: "\
63", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2020-01-15", { c: "65", ca: "6\
5", e: "79", f: "52", fa: "52", s: "12.1", si: "12.2" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "4", fa: "4", s: "7", si: "7" }], [
  "2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4",
  s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-09-30", { c: "41", ca: "41", e: "\
12", f: "36", fa: "36", s: "9", si: "9" }], ["2024-09-16", { c: "87", ca: "87", e: "87", f: "88", fa: "88", s: "18", si: "18" }], ["2022-04-\
28", { c: "101", ca: "101", e: "101", f: "96", fa: "96", s: "15", si: "15" }], ["2023-09-18", { c: "106", ca: "106", e: "106", f: "98", fa: "\
98", s: "17", si: "17" }], ["2023-09-18", { c: "88", ca: "55", e: "88", f: "43", fa: "43", s: "17", si: "17" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-10-03", { c: "106", ca: "106", e: "106", f: "97", fa: "97", s: "15.4", si: "15.4" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "5", ca: "18", e: "12",
  f: "17", fa: "17", s: "5", si: "4" }], ["2020-01-15", { c: "20", ca: "25", e: "79", f: "25", fa: "25", s: "6", si: "6" }], ["2015-07-29", {
  c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-04-13", { c: "81", ca: "81", e: "81", f: "26", fa: "26", s: "13.1",
  si: "13.4" }], ["2021-10-05", { c: "41", ca: "41", e: "79", f: "93", fa: "93", s: "10", si: "10" }], ["2023-09-18", { c: "113", ca: "113",
  e: "113", f: "89", fa: "89", s: "17", si: "17" }], ["2020-01-15", { c: "66", ca: "66", e: "79", f: "50", fa: "50", s: "11.1", si: "11.3" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1", si: "1" }], ["2023-03-27", { c: "89", ca: "89", e: "89", f: "108", fa: "108", s: "16.4", si: "16.4" }], ["2020-01-15", { c: "39",
  ca: "39", e: "79", f: "51", fa: "51", s: "10", si: "10" }], ["2021-09-20", { c: "58", ca: "58", e: "79", f: "51", fa: "51", s: "15", si: "\
15" }], ["2022-08-05", { c: "104", ca: "104", e: "104", f: "72", fa: "79", s: "14.1", si: "14.5" }], ["2023-04-11", { c: "102", ca: "102", e: "\
102", f: "112", fa: "112", s: "15.5", si: "15.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015\
-11-12", { c: "1", ca: "18", e: "13", f: "19", fa: "19", s: "1.2", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\
1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12",
  f: "3.6", fa: "4", s: "3", si: "1" }], ["2021-04-26", { c: "20", ca: "25", e: "12", f: "57", fa: "57", s: "14.1", si: "5" }], ["2015-07-29",
  { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "3" }], ["2020-01-15", { c: "1", ca: "18", e: "79", f: "6", fa: "6", s: "3.1", si: "\
2" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "3", fa: "4", s: "4", si: "3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "7", ca: "18", e: "\
12", f: "29", fa: "29", s: "5.1", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29",
  { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-16", { c: "4", ca: "57", e: "12", f: "23", fa: "52", s: "3.1",
  si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2021-12-07", { c: "66",
  ca: "66", e: "79", f: "95", fa: "79", s: "12.1", si: "12.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644",
  si: "\u22643.2" }], ["2018-12-11", { c: "41", ca: "41", e: "12", f: "64", fa: "64", s: "9", si: "9" }], ["2019-03-25", { c: "58", ca: "58",
  e: "16", f: "55", fa: "55", s: "12.1", si: "12.2" }], ["2017-09-28", { c: "24", ca: "25", e: "12", f: "29", fa: "56", s: "10", si: "10" }],
  ["2021-04-26", { c: "81", ca: "81", e: "81", f: "86", fa: "86", s: "14.1", si: "14.5" }], ["2025-03-04", { c: "129", ca: "129", e: "129", f: "\
136", fa: "136", s: "16.4", si: "16.4" }], ["2021-04-26", { c: "72", ca: "72", e: "79", f: "78", fa: "79", s: "14.1", si: "14.5" }], ["2020-\
09-16", { c: "74", ca: "74", e: "79", f: "75", fa: "79", s: "14", si: "14" }], ["2019-09-19", { c: "63", ca: "63", e: "18", f: "58", fa: "58",
  s: "13", si: "13" }], ["2020-09-16", { c: "71", ca: "71", e: "79", f: "76", fa: "79", s: "14", si: "14" }], ["2024-04-16", { c: "87", ca: "\
87", e: "87", f: "125", fa: "125", s: "14.1", si: "14.5" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "82", fa: "82", s: "14", si: "1\
4" }], ["2018-04-12", { c: "55", ca: "55", e: "15", f: "52", fa: "52", s: "11.1", si: "11.3" }], ["2020-01-15", { c: "41", ca: "41", e: "79",
  f: "36", fa: "36", s: "8", si: "8" }], ["2025-03-31", { c: "122", ca: "122", e: "122", f: "131", fa: "131", s: "18.4", si: "18.4" }], ["20\
15-07-29", { c: "38", ca: "38", e: "12", f: "13", fa: "14", s: "7", si: "7" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "1", fa: "4",
  s: "5", si: "4.2" }], ["2018-05-09", { c: "61", ca: "61", e: "16", f: "60", fa: "60", s: "11", si: "11" }], ["2023-06-06", { c: "80", ca: "\
80", e: "80", f: "114", fa: "114", s: "15", si: "15" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "4" }], [
  "2025-04-29", { c: "123", ca: "123", e: "123", f: "138", fa: "138", s: "17.2", si: "17.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "6", fa: "6", s: "1.2", si: "1" }], ["2023-05-\
09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "15", si: "15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4",
  s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1",
  si: "1" }], ["2020-01-15", { c: "48", ca: "48", e: "79", f: "50", fa: "50", s: "11", si: "11" }], ["2016-09-20", { c: "49", ca: "49", e: "\
14", f: "44", fa: "44", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-11-21",
  { c: "109", ca: "109", e: "109", f: "120", fa: "120", s: "16.4", si: "16.4" }], ["2024-05-13", { c: "123", ca: "123", e: "123", f: "120", fa: "\
120", s: "17.5", si: "17.5" }], ["2020-07-28", { c: "83", ca: "83", e: "83", f: "69", fa: "79", s: "13", si: "13" }], ["2015-07-29", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-12-11", { c: "113", ca: "113", e: "113", f: "112", fa: "112", s: "17.2", si: "\
17.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "46", ca: "46",
  e: "79", f: "39", fa: "39", s: "11.1", si: "11.3" }], ["2021-01-26", { c: "50", ca: "50", e: "79", f: "85", fa: "85", s: "11.1", si: "11.3" }],
  ["2020-01-15", { c: "65", ca: "65", e: "79", f: "50", fa: "50", s: "9", si: "9" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "\u22644", si: "\u22643.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-12-19", { c: "\
77", ca: "77", e: "79", f: "121", fa: "121", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "6", s: "4",
  si: "3.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-09-16", { c: "85", ca: "85", e: "85",
  f: "79", fa: "79", s: "14", si: "14" }], ["2021-09-20", { c: "89", ca: "89", e: "89", f: "66", fa: "66", s: "15", si: "15" }], ["2015-07-2\
9", { c: "26", ca: "26", e: "12", f: "21", fa: "21", s: "7", si: "7" }], ["2015-07-29", { c: "38", ca: "38", e: "12", f: "13", fa: "14", s: "\
8", si: "8" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "7", ca: "18", e: "12",
  f: "4", fa: "4", s: "5.1", si: "5" }], ["2020-01-15", { c: "24", ca: "25", e: "79", f: "35", fa: "35", s: "7", si: "7" }], ["2023-12-07", {
  c: "120", ca: "120", e: "120", f: "53", fa: "53", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "9", ca: "18", e: "12", f: "6", fa: "6", s: "\
5.1", si: "5" }], ["2023-01-12", { c: "109", ca: "109", e: "109", f: "4", fa: "4", s: "5.1", si: "5" }], ["2022-04-28", { c: "101", ca: "101",
  e: "101", f: "63", fa: "63", s: "15.4", si: "15.4" }], ["2017-09-19", { c: "53", ca: "53", e: "12", f: "36", fa: "36", s: "11", si: "11" }],
  ["2020-02-04", { c: "80", ca: "80", e: "12", f: "42", fa: "42", s: "8", si: "12.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1",
  fa: "4", s: "3", si: "1" }], ["2023-03-27", { c: "104", ca: "104", e: "104", f: "102", fa: "102", s: "16.4", si: "16.4" }], ["2021-04-26",
  { c: "49", ca: "49", e: "79", f: "25", fa: "25", s: "14.1", si: "14" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\
3", si: "1" }], ["2023-03-27", { c: "60", ca: "60", e: "18", f: "57", fa: "57", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18",
  e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2018-10-02", { c: "6", ca: "18", e: "18", f: "56", fa: "56", s: "6", si: "10.3" }], ["2020\
-07-28", { c: "79", ca: "79", e: "79", f: "75", fa: "79", s: "13.1", si: "13.4" }], ["2020-01-15", { c: "46", ca: "46", e: "79", f: "66", fa: "\
66", s: "11", si: "11" }], ["2015-07-29", { c: "18", ca: "18", e: "12", f: "1", fa: "4", s: "1.3", si: "1" }], ["2020-01-15", { c: "41", ca: "\
41", e: "79", f: "32", fa: "32", s: "8", si: "8" }], ["2020-01-15", { c: "\u226479", ca: "\u226479", e: "79", f: "\u226423", fa: "\u226423",
  s: "\u22649.1", si: "\u22649.3" }], ["2022-09-02", { c: "105", ca: "105", e: "105", f: "103", fa: "103", s: "15.6", si: "15.6" }], ["2023-\
09-18", { c: "66", ca: "66", e: "79", f: "115", fa: "115", s: "17", si: "17" }], ["2022-09-12", { c: "55", ca: "55", e: "79", f: "72", fa: "\
79", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-07", { c: "50", ca: "5\
0", e: "12", f: "52", fa: "52", s: "9", si: "9" }], ["2015-07-29", { c: "26", ca: "26", e: "12", f: "14", fa: "14", s: "7", si: "7" }], ["20\
15-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\
1", si: "1" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2021-10-25", { c: "57", ca: "57", e: "1\
2", f: "58", fa: "58", s: "15", si: "15.1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-12-11",
  { c: "120", ca: "120", e: "120", f: "117", fa: "117", s: "17.2", si: "17.2" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "84", fa: "\
84", s: "9", si: "9" }], ["2023-03-27", { c: "20", ca: "42", e: "14", f: "22", fa: "22", s: "7", si: "16.4" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "3.5", fa: "4", s: "3.1", si: "2" }], ["2023-05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "9", si: "9" }],
  ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "4", s: "3.1", si: "2" }], ["2020-09-16", { c: "85", ca: "85", e: "85", f: "79",
  fa: "79", s: "14", si: "14" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-07-28", { c: "75",
  ca: "75", e: "79", f: "70", fa: "79", s: "13", si: "13" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }],
  ["2020-01-15", { c: "32", ca: "32", e: "79", f: "36", fa: "36", s: "10", si: "10" }], ["2022-03-14", { c: "93", ca: "93", e: "93", f: "92",
  fa: "92", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "\
32", ca: "32", e: "79", f: "36", fa: "36", s: "10", si: "10" }], ["2015-07-29", { c: "24", ca: "25", e: "12", f: "24", fa: "24", s: "8", si: "\
8" }], ["2021-04-26", { c: "80", ca: "80", e: "80", f: "71", fa: "79", s: "14.1", si: "14.5" }], ["2015-07-29", { c: "10", ca: "18", e: "12",
  f: "10", fa: "10", s: "8", si: "8" }], ["2015-07-29", { c: "10", ca: "18", e: "12", f: "6", fa: "6", s: "8", si: "8" }], ["2015-07-29", { c: "\
29", ca: "29", e: "12", f: "24", fa: "24", s: "8", si: "8" }], ["2016-08-02", { c: "27", ca: "27", e: "14", f: "29", fa: "29", s: "8", si: "\
8" }], ["2018-04-30", { c: "24", ca: "25", e: "17", f: "25", fa: "25", s: "8", si: "9" }], ["2021-04-26", { c: "35", ca: "35", e: "12", f: "\
25", fa: "25", s: "14.1", si: "14.5" }], ["2023-03-27", { c: "69", ca: "69", e: "79", f: "105", fa: "105", s: "16.4", si: "16.4" }], ["2023-\
05-09", { c: "111", ca: "111", e: "111", f: "113", fa: "113", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "1.5",
  fa: "4", s: "4", si: "3.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "2", si: "1" }], ["\u22642020-03-24", { c: "\
\u226480", ca: "\u226480", e: "\u226480", f: "1.5", fa: "4", s: "\u226413.1", si: "\u226413.4" }], ["2020-01-15", { c: "66", ca: "66", e: "7\
9", f: "58", fa: "58", s: "11.1", si: "11.3" }], ["2023-03-27", { c: "108", ca: "109", e: "108", f: "111", fa: "111", s: "16.4", si: "16.4" }],
  ["2023-03-27", { c: "94", ca: "94", e: "94", f: "88", fa: "88", s: "16.4", si: "16.4" }], ["2017-04-05", { c: "1", ca: "18", e: "15", f: "\
1.5", fa: "4", s: "1.2", si: "1" }], ["\u22642018-10-02", { c: "10", ca: "18", e: "\u226418", f: "4", fa: "4", s: "7", si: "7" }], ["2023-09\
-18", { c: "113", ca: "113", e: "113", f: "66", fa: "66", s: "17", si: "17" }], ["2022-09-12", { c: "90", ca: "90", e: "90", f: "81", fa: "8\
1", s: "16", si: "16" }], ["2020-03-24", { c: "68", ca: "68", e: "79", f: "61", fa: "61", s: "13.1", si: "13.4" }], ["2018-10-02", { c: "23",
  ca: "25", e: "18", f: "49", fa: "49", s: "7", si: "7" }], ["2022-09-12", { c: "63", ca: "63", e: "18", f: "59", fa: "59", s: "16", si: "16" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1", si: "1" }], ["2019-01-29", { c: "50", ca: "50", e: "12", f: "65", fa: "65", s: "10", si: "10" }], ["2024-12-11", { c: "15", ca: "\
18", e: "79", f: "95", fa: "95", s: "18.2", si: "18.2" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "1.5", fa: "4", s: "5", si: "4" }],
  ["2015-07-29", { c: "33", ca: "33", e: "12", f: "18", fa: "18", s: "7", si: "7" }], ["2023-03-27", { c: "94", ca: "94", e: "94", f: "99", fa: "\
99", s: "16.4", si: "16.4" }], ["2015-09-16", { c: "6", ca: "18", e: "12", f: "7", fa: "7", s: "8", si: "9" }], ["2022-09-12", { c: "44", ca: "\
44", e: "79", f: "46", fa: "46", s: "16", si: "16" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["20\
16-03-21", { c: "38", ca: "38", e: "13", f: "38", fa: "38", s: "9.1", si: "9.3" }], ["2020-01-15", { c: "57", ca: "57", e: "79", f: "51", fa: "\
51", s: "10.1", si: "10.3" }], ["2020-01-15", { c: "47", ca: "47", e: "79", f: "51", fa: "51", s: "9", si: "9" }], ["2015-07-29", { c: "2", ca: "\
18", e: "12", f: "3.6", fa: "4", s: "4", si: "3.2" }], ["2020-07-28", { c: "55", ca: "55", e: "12", f: "59", fa: "79", s: "13", si: "13" }],
  ["2025-01-27", { c: "116", ca: "116", e: "116", f: "125", fa: "125", s: "17", si: "18.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "3", fa: "4", s: "4", si: "3.2" }], ["2015-07-29", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "76", ca: "76", e: "79", f: "67", fa: "67", s: "\
12.1", si: "13" }], ["2022-05-31", { c: "96", ca: "96", e: "96", f: "101", fa: "101", s: "14.1", si: "14.5" }], ["2020-01-15", { c: "74", ca: "\
74", e: "79", f: "63", fa: "64", s: "10.1", si: "10.3" }], ["2023-12-11", { c: "73", ca: "73", e: "79", f: "78", fa: "79", s: "17.2", si: "1\
7.2" }], ["2023-12-11", { c: "86", ca: "86", e: "86", f: "101", fa: "101", s: "17.2", si: "17.2" }], ["2023-06-06", { c: "1", ca: "18", e: "\
12", f: "1", fa: "114", s: "1.1", si: "1" }], ["2025-05-01", { c: "136", ca: "136", e: "136", f: "97", fa: "97", s: "15.4", si: "15.4" }], [
  "2019-09-19", { c: "63", ca: "63", e: "12", f: "6", fa: "6", s: "13", si: "13" }], ["2015-07-29", { c: "6", ca: "18", e: "12", f: "6", fa: "\
6", s: "6", si: "7" }], ["2015-07-29", { c: "32", ca: "32", e: "12", f: "29", fa: "29", s: "8", si: "8" }], ["2020-07-28", { c: "76", ca: "7\
6", e: "79", f: "71", fa: "79", s: "13", si: "13" }], ["2020-09-16", { c: "85", ca: "85", e: "85", f: "79", fa: "79", s: "14", si: "14" }], [
  "2018-10-02", { c: "63", ca: "63", e: "18", f: "58", fa: "58", s: "11.1", si: "11.3" }], ["2025-01-07", { c: "128", ca: "128", e: "128", f: "\
134", fa: "134", s: "18.2", si: "18.2" }], ["2024-03-05", { c: "119", ca: "119", e: "119", f: "121", fa: "121", s: "17.4", si: "17.4" }], ["\
2016-09-20", { c: "49", ca: "49", e: "12", f: "18", fa: "18", s: "10", si: "10" }], ["2023-03-27", { c: "50", ca: "50", e: "17", f: "44", fa: "\
48", s: "16", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2020-03-24", { c: "63", ca: "\
63", e: "79", f: "49", fa: "49", s: "13.1", si: "13.4" }], ["2021-04-26", { c: "87", ca: "87", e: "87", f: "70", fa: "79", s: "14.1", si: "1\
4.5" }], ["2020-07-28", { c: "1", ca: "18", e: "13", f: "78", fa: "79", s: "4", si: "3.2" }], ["2021-09-20", { c: "85", ca: "85", e: "85", f: "\
87", fa: "87", s: "15", si: "15" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2025-05-01", { c: "1\
36", ca: "136", e: "136", f: "134", fa: "134", s: "18.2", si: "18.2" }], ["2024-07-09", { c: "85", ca: "85", e: "85", f: "128", fa: "128", s: "\
16.4", si: "16.4" }], ["2024-09-16", { c: "125", ca: "125", e: "125", f: "128", fa: "128", s: "18", si: "18" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.6", fa: "4", s: "5", si: "4" }], ["2015\
-07-29", { c: "24", ca: "25", e: "12", f: "23", fa: "23", s: "7", si: "7" }], ["2023-03-27", { c: "69", ca: "69", e: "79", f: "99", fa: "99",
  s: "16.4", si: "16.4" }], ["2024-10-29", { c: "83", ca: "83", e: "83", f: "132", fa: "132", s: "15.4", si: "15.4" }], ["2025-05-27", { c: "\
134", ca: "134", e: "134", f: "139", fa: "139", s: "18.4", si: "18.4" }], ["2024-07-09", { c: "111", ca: "111", e: "111", f: "128", fa: "128",
  s: "16.4", si: "16.4" }], ["2020-07-28", { c: "64", ca: "64", e: "79", f: "69", fa: "79", s: "13.1", si: "13.4" }], ["2022-09-12", { c: "6\
8", ca: "68", e: "79", f: "62", fa: "62", s: "16", si: "16" }], ["2018-10-23", { c: "1", ca: "18", e: "12", f: "63", fa: "63", s: "3", si: "\
1" }], ["2023-03-27", { c: "54", ca: "54", e: "17", f: "45", fa: "45", s: "16.4", si: "16.4" }], ["2017-09-19", { c: "29", ca: "29", e: "12",
  f: "35", fa: "35", s: "11", si: "11" }], ["2020-07-27", { c: "84", ca: "84", e: "84", f: "67", fa: "67", s: "9.1", si: "9.3" }], ["2020-01\
-15", { c: "65", ca: "65", e: "79", f: "52", fa: "52", s: "12.1", si: "12.2" }], ["2023-11-21", { c: "111", ca: "111", e: "111", f: "120", fa: "\
120", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-05-17", { c: "125", ca: "\
125", e: "125", f: "118", fa: "118", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "38", fa: "38", s: "5", si: "4\
.2" }], ["2024-12-11", { c: "128", ca: "128", e: "128", f: "38", fa: "38", s: "18.2", si: "18.2" }], ["2024-12-11", { c: "84", ca: "84", e: "\
84", f: "38", fa: "38", s: "18.2", si: "18.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }],
  ["2020-01-15", { c: "69", ca: "69", e: "79", f: "65", fa: "65", s: "11.1", si: "11.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2020-01-15", { c: "27", ca: "27", e: "79", f: "32", fa: "32", s: "7", si: "7" }], ["2015-07\
-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2023-03-27", { c: "38", ca: "39", e: "79", f: "43", fa: "43", s: "\
16.4", si: "16.4" }], ["2025-03-31", { c: "84", ca: "84", e: "84", f: "126", fa: "126", s: "16.4", si: "18.4" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "3", si: "2" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "113", fa: "113", s: "17", si: "17" }],
  ["2022-03-14", { c: "61", ca: "61", e: "79", f: "36", fa: "36", s: "15.4", si: "15.4" }], ["2020-09-16", { c: "61", ca: "61", e: "79", f: "\
36", fa: "36", s: "14", si: "14" }], ["2020-01-15", { c: "1", ca: "18", e: "79", f: "1", fa: "4", s: "3", si: "1" }], ["2020-01-15", { c: "6\
9", ca: "69", e: "79", f: "68", fa: "68", s: "11", si: "11" }], ["2024-10-01", { c: "80", ca: "80", e: "80", f: "131", fa: "131", s: "16.1",
  si: "16.1" }], ["2024-12-11", { c: "94", ca: "94", e: "94", f: "97", fa: "97", s: "18.2", si: "18.2" }], ["2024-12-11", { c: "121", ca: "1\
21", e: "121", f: "64", fa: "64", s: "18.2", si: "18.2" }], ["2023-10-13", { c: "118", ca: "118", e: "118", f: "118", fa: "118", s: "17", si: "\
17" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4", fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "4",
  fa: "4", s: "5", si: "4.2" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-07", { c: "11", ca: "\
18", e: "12", f: "52", fa: "52", s: "5.1", si: "5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["20\
20-01-15", { c: "6", ca: "18", e: "79", f: "6", fa: "45", s: "5", si: "5" }], ["2023-03-27", { c: "65", ca: "65", e: "79", f: "61", fa: "61",
  s: "16.4", si: "16.4" }], ["2018-04-30", { c: "45", ca: "45", e: "17", f: "44", fa: "44", s: "11.1", si: "11.3" }], ["2015-07-29", { c: "3\
8", ca: "38", e: "12", f: "13", fa: "14", s: "8", si: "8" }], ["2024-06-11", { c: "122", ca: "122", e: "122", f: "127", fa: "127", s: "17", si: "\
17" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "5" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3\
.5", fa: "4", s: "4", si: "5" }], ["2020-01-15", { c: "53", ca: "53", e: "79", f: "63", fa: "63", s: "10", si: "10" }], ["2020-07-28", { c: "\
73", ca: "73", e: "79", f: "72", fa: "79", s: "13.1", si: "13.4" }], ["2020-01-15", { c: "37", ca: "37", e: "79", f: "62", fa: "62", s: "10.\
1", si: "10.3" }], ["2020-01-15", { c: "37", ca: "37", e: "79", f: "54", fa: "54", s: "10.1", si: "10.3" }], ["2021-12-13", { c: "68", ca: "\
89", e: "79", f: "79", fa: "79", s: "15.2", si: "15.2" }], ["2025-04-04", { c: "135", ca: "135", e: "135", f: "136", fa: "136", s: "18.4", si: "\
18.4" }], ["2020-01-15", { c: "53", ca: "53", e: "79", f: "63", fa: "63", s: "10", si: "10" }], ["2023-03-27", { c: "92", ca: "92", e: "92",
  f: "92", fa: "92", s: "16.4", si: "16.4" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }],
  ["2020-01-15", { c: "19", ca: "25", e: "79", f: "4", fa: "4", s: "6", si: "6" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "\
4", s: "3.1", si: "2" }], ["2020-01-15", { c: "18", ca: "18", e: "79", f: "55", fa: "55", s: "7", si: "7" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2018-09-05", { c: "33", ca: "33", e: "14", f: "49", fa: "62", s: "7", si: "7" }], ["201\
7-11-28", { c: "9", ca: "47", e: "12", f: "2", fa: "57", s: "5.1", si: "5" }], ["2020-01-15", { c: "60", ca: "60", e: "79", f: "55", fa: "55",
  s: "11.1", si: "11.3" }], ["2017-03-27", { c: "38", ca: "38", e: "13", f: "38", fa: "38", s: "10.1", si: "10.3" }], ["2020-01-15", { c: "7\
0", ca: "70", e: "79", f: "3", fa: "4", s: "10.1", si: "10.3" }], ["2024-08-06", { c: "117", ca: "117", e: "117", f: "129", fa: "129", s: "1\
7.5", si: "17.5" }], ["2024-05-17", { c: "125", ca: "125", e: "125", f: "126", fa: "126", s: "17.4", si: "17.4" }], ["2015-07-29", { c: "1",
  ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-09-16", { c: "77", ca: "77", e: "79", f: "65", fa: "65", s: "14", si: "14" }],
  ["2019-09-19", { c: "56", ca: "56", e: "16", f: "59", fa: "59", s: "13", si: "13" }], ["2023-12-05", { c: "119", ca: "120", e: "85", f: "6\
5", fa: "65", s: "11.1", si: "11.3" }], ["2023-09-18", { c: "61", ca: "61", e: "79", f: "57", fa: "57", s: "17", si: "17" }], ["2022-06-28",
  { c: "67", ca: "67", e: "79", f: "102", fa: "102", s: "14.1", si: "14.5" }], ["2022-03-14", { c: "92", ca: "92", e: "92", f: "90", fa: "90",
  s: "15.4", si: "15.4" }], ["2015-09-30", { c: "41", ca: "41", e: "12", f: "29", fa: "29", s: "9", si: "9" }], ["2015-09-30", { c: "41", ca: "\
41", e: "12", f: "40", fa: "40", s: "9", si: "9" }], ["2020-01-15", { c: "73", ca: "73", e: "79", f: "67", fa: "67", s: "13", si: "13" }], [
  "2016-09-20", { c: "34", ca: "34", e: "12", f: "31", fa: "31", s: "10", si: "10" }], ["2017-04-05", { c: "57", ca: "57", e: "15", f: "48",
  fa: "48", s: "10", si: "10" }], ["2015-09-30", { c: "41", ca: "41", e: "12", f: "34", fa: "34", s: "9", si: "9" }], ["2015-09-30", { c: "4\
1", ca: "36", e: "12", f: "24", fa: "24", s: "9", si: "9" }], ["2020-08-27", { c: "85", ca: "85", e: "85", f: "77", fa: "79", s: "13.1", si: "\
13.4" }], ["2015-09-30", { c: "41", ca: "36", e: "12", f: "17", fa: "17", s: "9", si: "9" }], ["2020-01-15", { c: "66", ca: "66", e: "79", f: "\
61", fa: "61", s: "12", si: "12" }], ["2023-10-24", { c: "111", ca: "111", e: "111", f: "119", fa: "119", s: "16.4", si: "16.4" }], ["2015-0\
7-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644",
  si: "\u22643.2" }], ["2022-03-14", { c: "98", ca: "98", e: "98", f: "94", fa: "94", s: "15.4", si: "15.4" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-0\
7-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2023-09-15", { c: "117", ca: "117", e: "117", f: "7\
1", fa: "79", s: "16", si: "16" }], ["2015-09-30", { c: "28", ca: "28", e: "12", f: "22", fa: "22", s: "9", si: "9" }], ["2016-09-20", { c: "\
2", ca: "18", e: "12", f: "49", fa: "49", s: "4", si: "3.2" }], ["2020-01-15", { c: "1", ca: "18", e: "79", f: "3", fa: "4", s: "3", si: "2" }],
  ["2015-07-29", { c: "5", ca: "18", e: "12", f: "3", fa: "4", s: "6", si: "6" }], ["2015-09-30", { c: "38", ca: "38", e: "12", f: "36", fa: "\
36", s: "9", si: "9" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2021-08-10", { c: "42", ca: "42",
  e: "79", f: "91", fa: "91", s: "13.1", si: "13.4" }], ["2018-10-02", { c: "1", ca: "18", e: "18", f: "1.5", fa: "4", s: "3.1", si: "2" }],
  ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "1.3", si: "2" }], ["2024-12-11", { c: "89", ca: "89", e: "89", f: "131", fa: "131", s: "18.2", si: "18.2" }], ["2015-11-12", { c: "2\
6", ca: "26", e: "13", f: "22", fa: "22", s: "8", si: "8" }], ["2020-01-15", { c: "62", ca: "62", e: "79", f: "53", fa: "53", s: "11", si: "\
11" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-09-12", { c: "47", ca: "47", e: "12", f: "49",
  fa: "49", s: "16", si: "16" }], ["2022-03-14", { c: "48", ca: "48", e: "79", f: "48", fa: "48", s: "15.4", si: "15.4" }], ["2015-07-29", {
  c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2022-03-03", { c: "99", ca: "99", e: "99", f: "46", fa: "46", s: "7", si: "\
7" }], ["2020-01-15", { c: "38", ca: "38", e: "79", f: "19", fa: "19", s: "10.1", si: "10.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12",
  f: "1", fa: "4", s: "1", si: "1" }], ["2020-09-16", { c: "48", ca: "48", e: "79", f: "41", fa: "41", s: "14", si: "14" }], ["2015-07-29", {
  c: "1", ca: "18", e: "12", f: "7", fa: "7", s: "1.3", si: "1" }], ["2015-07-29", { c: "2", ca: "18", e: "12", f: "3.5", fa: "4", s: "1.1",
  si: "1" }], ["2017-04-05", { c: "4", ca: "18", e: "15", f: "49", fa: "49", s: "3", si: "2" }], ["2015-07-29", { c: "23", ca: "25", e: "12",
  f: "31", fa: "31", s: "6", si: "6" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-11-19", { c: "\
87", ca: "87", e: "87", f: "70", fa: "79", s: "12.1", si: "12.2" }], ["2020-07-28", { c: "33", ca: "33", e: "12", f: "74", fa: "79", s: "12.\
1", si: "12.2" }], ["2024-03-19", { c: "114", ca: "114", e: "114", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2024-05-13", { c: "114",
  ca: "114", e: "114", f: "121", fa: "121", s: "17.5", si: "17.5" }], ["2024-10-17", { c: "130", ca: "130", e: "130", f: "124", fa: "124", s: "\
17.4", si: "17.4" }], ["2024-03-19", { c: "114", ca: "114", e: "114", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2024-10-17", { c: "13\
0", ca: "130", e: "130", f: "121", fa: "121", s: "17.5", si: "17.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644",
  si: "\u22643" }], ["2017-10-24", { c: "62", ca: "62", e: "14", f: "22", fa: "22", s: "10", si: "10" }], ["2015-07-29", { c: "1", ca: "18",
  e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }],
  ["2021-09-20", { c: "89", ca: "89", e: "89", f: "89", fa: "89", s: "15", si: "15" }], ["2019-09-19", { c: "36", ca: "36", e: "12", f: "52",
  fa: "52", s: "13", si: "9.3" }], ["2024-03-05", { c: "114", ca: "114", e: "114", f: "122", fa: "122", s: "17.4", si: "17.4" }], ["2024-04-\
16", { c: "118", ca: "118", e: "118", f: "125", fa: "125", s: "13.1", si: "13.4" }], ["2015-09-30", { c: "36", ca: "36", e: "12", f: "16", fa: "\
16", s: "9", si: "9" }], ["2022-03-14", { c: "36", ca: "36", e: "12", f: "16", fa: "16", s: "15.4", si: "15.4" }], ["2024-08-06", { c: "117",
  ca: "117", e: "117", f: "129", fa: "129", s: "17.4", si: "17.4" }], ["2015-09-30", { c: "26", ca: "26", e: "12", f: "16", fa: "16", s: "9",
  si: "9" }], ["2023-03-14", { c: "19", ca: "25", e: "79", f: "111", fa: "111", s: "6", si: "6" }], ["2023-03-13", { c: "111", ca: "111", e: "\
111", f: "108", fa: "108", s: "15.4", si: "15.4" }], ["2023-07-21", { c: "115", ca: "115", e: "115", f: "70", fa: "79", s: "15", si: "15" }],
  ["2016-09-20", { c: "45", ca: "45", e: "12", f: "38", fa: "38", s: "10", si: "10" }], ["2016-09-20", { c: "45", ca: "45", e: "12", f: "37",
  fa: "37", s: "10", si: "10" }], ["2015-07-29", { c: "7", ca: "18", e: "12", f: "4", fa: "4", s: "5.1", si: "4.2" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2025-09-05", { c: "140", ca: "140", e: "140", f: "133", fa: "133", s: "18.2", si: "\
18.2" }], ["2015-09-30", { c: "44", ca: "44", e: "12", f: "40", fa: "40", s: "9", si: "9" }], ["2016-03-21", { c: "41", ca: "41", e: "13", f: "\
27", fa: "27", s: "9.1", si: "9.3" }], ["2023-09-18", { c: "113", ca: "113", e: "113", f: "102", fa: "102", s: "17", si: "17" }], ["2018-04-\
30", { c: "44", ca: "44", e: "17", f: "48", fa: "48", s: "10.1", si: "10.3" }], ["2015-07-29", { c: "32", ca: "32", e: "12", f: "19", fa: "1\
9", s: "7", si: "7" }], ["2023-12-07", { c: "120", ca: "120", e: "120", f: "115", fa: "115", s: "17", si: "17" }], ["2015-07-29", { c: "1", ca: "\
18", e: "12", f: "1", fa: "4", s: "2", si: "1" }], ["2023-11-21", { c: "72", ca: "72", e: "79", f: "120", fa: "120", s: "16.4", si: "16.4" }],
  ["2015-07-29", { c: "4", ca: "18", e: "12", f: "3.5", fa: "4", s: "4", si: "5" }], ["2023-11-02", { c: "119", ca: "119", e: "119", f: "88",
  fa: "88", s: "16.5", si: "16.5" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "\u22644", si: "\u22643.2" }], ["2015-\
07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2024-04-18", { c: "124", ca: "124", e: "124", f: "120", fa: "120",
  s: "17.4", si: "17.4" }], ["2015-07-29", { c: "3", ca: "18", e: "12", f: "3.5", fa: "4", s: "3.1", si: "3" }], ["2022-12-05", { c: "108", ca: "\
108", e: "108", f: "101", fa: "101", s: "15.4", si: "15.4" }], ["2017-10-17", { c: "26", ca: "26", e: "16", f: "19", fa: "19", s: "7", si: "\
7" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1.3", si: "1" }], ["2021-08-10", { c: "61", ca: "61", e: "79", f: "9\
1", fa: "68", s: "13", si: "13" }], ["2017-10-17", { c: "57", ca: "57", e: "16", f: "52", fa: "52", s: "11", si: "11" }], ["2021-04-26", { c: "\
85", ca: "85", e: "85", f: "78", fa: "79", s: "14.1", si: "14.5" }], ["2021-10-25", { c: "75", ca: "75", e: "79", f: "78", fa: "79", s: "15.\
1", si: "15.1" }], ["2022-05-03", { c: "95", ca: "95", e: "95", f: "100", fa: "100", s: "15.2", si: "15.2" }], ["2024-03-05", { c: "114", ca: "\
114", e: "114", f: "112", fa: "112", s: "17.4", si: "17.4" }], ["2024-12-11", { c: "119", ca: "119", e: "119", f: "120", fa: "120", s: "18.2",
  si: "18.2" }], ["2020-10-20", { c: "86", ca: "86", e: "86", f: "78", fa: "79", s: "13.1", si: "13.4" }], ["2020-03-24", { c: "69", ca: "69",
  e: "79", f: "62", fa: "62", s: "13.1", si: "13.4" }], ["2021-10-25", { c: "75", ca: "75", e: "18", f: "64", fa: "64", s: "15.1", si: "15.1" }],
  ["2021-11-19", { c: "96", ca: "96", e: "96", f: "79", fa: "79", s: "15.1", si: "15.1" }], ["2021-04-26", { c: "69", ca: "69", e: "18", f: "\
62", fa: "62", s: "14.1", si: "14.5" }], ["2023-03-27", { c: "91", ca: "91", e: "91", f: "89", fa: "89", s: "16.4", si: "16.4" }], ["2024-12\
-11", { c: "112", ca: "112", e: "112", f: "121", fa: "121", s: "18.2", si: "18.2" }], ["2021-12-13", { c: "74", ca: "88", e: "79", f: "79", fa: "\
79", s: "15.2", si: "15.2" }], ["2024-09-16", { c: "119", ca: "119", e: "119", f: "120", fa: "120", s: "18", si: "18" }], ["2015-07-29", { c: "\
1", ca: "18", e: "12", f: "1", fa: "4", s: "4", si: "3.2" }], ["2021-04-26", { c: "84", ca: "84", e: "84", f: "79", fa: "79", s: "14.1", si: "\
14.5" }], ["2015-07-29", { c: "36", ca: "36", e: "12", f: "6", fa: "6", s: "8", si: "8" }], ["2015-09-30", { c: "36", ca: "36", e: "12", f: "\
34", fa: "34", s: "9", si: "9" }], ["2020-09-16", { c: "84", ca: "84", e: "84", f: "75", fa: "79", s: "14", si: "14" }], ["2021-04-26", { c: "\
35", ca: "35", e: "12", f: "25", fa: "25", s: "14.1", si: "14.5" }], ["2015-07-29", { c: "37", ca: "37", e: "12", f: "34", fa: "34", s: "11",
  si: "11" }], ["2022-03-14", { c: "69", ca: "69", e: "79", f: "96", fa: "96", s: "15.4", si: "15.4" }], ["2021-09-07", { c: "67", ca: "70",
  e: "18", f: "60", fa: "92", s: "13", si: "13" }], ["2023-10-24", { c: "85", ca: "85", e: "85", f: "119", fa: "119", s: "16", si: "16" }], [
  "2015-07-29", { c: "9", ca: "25", e: "12", f: "4", fa: "4", s: "5.1", si: "8" }], ["2021-09-20", { c: "63", ca: "63", e: "17", f: "30", fa: "\
30", s: "14", si: "15" }], ["2024-10-29", { c: "104", ca: "104", e: "104", f: "132", fa: "132", s: "16.4", si: "16.4" }], ["2020-01-15", { c: "\
47", ca: "47", e: "79", f: "53", fa: "53", s: "12", si: "12" }], ["2017-04-19", { c: "33", ca: "33", e: "12", f: "53", fa: "53", s: "9.1", si: "\
9.3" }], ["2020-09-16", { c: "47", ca: "47", e: "79", f: "56", fa: "56", s: "14", si: "14" }], ["2015-07-29", { c: "26", ca: "26", e: "12", f: "\
22", fa: "22", s: "8", si: "8" }], ["2018-04-30", { c: "26", ca: "26", e: "17", f: "22", fa: "22", s: "8", si: "8" }], ["2022-12-13", { c: "\
100", ca: "100", e: "100", f: "108", fa: "108", s: "16", si: "16" }], ["2021-09-20", { c: "56", ca: "58", e: "79", f: "51", fa: "51", s: "15",
  si: "15" }], ["2024-10-29", { c: "104", ca: "104", e: "104", f: "132", fa: "132", s: "16.4", si: "16.4" }], ["2020-09-16", { c: "9", ca: "\
18", e: "18", f: "65", fa: "65", s: "14", si: "14" }], ["2020-01-15", { c: "56", ca: "56", e: "79", f: "22", fa: "24", s: "11", si: "11" }],
  ["2023-05-09", { c: "76", ca: "76", e: "79", f: "113", fa: "113", s: "15.4", si: "15.4" }], ["2020-01-15", { c: "58", ca: "58", e: "79", f: "\
44", fa: "44", s: "11", si: "11" }], ["2015-07-29", { c: "5", ca: "18", e: "12", f: "11", fa: "14", s: "5", si: "4.2" }], ["2015-07-29", { c: "\
23", ca: "25", e: "12", f: "31", fa: "31", s: "6", si: "8" }], ["2020-01-15", { c: "23", ca: "25", e: "79", f: "31", fa: "31", s: "6", si: "\
8" }], ["2021-01-21", { c: "88", ca: "88", e: "88", f: "82", fa: "82", s: "14", si: "14" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "\
1", fa: "4", s: "1", si: "1" }], ["2024-03-19", { c: "114", ca: "114", e: "114", f: "124", fa: "124", s: "17.4", si: "17.4" }], ["2015-07-29",
  { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2020-01-15", { c: "36", ca: "36", e: "79", f: "36", fa: "36", s: "9.1",
  si: "9.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2015-09-30", { c: "44", ca: "44", e: "12",
  f: "15", fa: "15", s: "9", si: "9" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "1", si: "1" }], ["2017-03-27", { c: "\
48", ca: "48", e: "12", f: "41", fa: "41", s: "10.1", si: "10.3" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "\
1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "\
4", s: "3", si: "1" }], ["2015-07-29", { c: "1", ca: "18", e: "12", f: "1", fa: "4", s: "3.1", si: "2" }], ["2015-07-29", { c: "1", ca: "18",
  e: "12", f: "3", fa: "4", s: "1", si: "1" }], ["2024-05-14", { c: "1", ca: "18", e: "12", f: "126", fa: "126", s: "3.1", si: "3" }]];
  1757772428821 < (/* @__PURE__ */ new Date()).setMonth((/* @__PURE__ */ new Date()).getMonth() - 2) && console.warn("[baseline-browser-mapp\
ing] The data in this module is over two months old.  To ensure accurate Baseline data, please update: `npm i baseline-browser-mapping@lates\
t -D`");
  var _fe = Dfe, Ife = { w: "WebKit", g: "Gecko", p: "Presto", b: "Blink" }, Ofe = { r: "retired", c: "current", b: "beta", n: "nightly", p: "\
planned", u: "unknown", e: "esr" }, O3 = /* @__PURE__ */ i((e) => {
    let t = {};
    return Object.entries(e).forEach(([r, s]) => {
      if (s.releases) {
        t[r] || (t[r] = { releases: {} });
        let n = t[r].releases;
        s.releases.forEach((a) => {
          n[a[0]] = { version: a[0], release_date: a[1] == "u" ? "unknown" : a[1], status: Ofe[a[2]], engine: a[3] ? Ife[a[3]] : void 0, engine_version: a[4] };
        });
      }
    }), t;
  }, "b"), Nfe = (() => {
    let e = [];
    return _fe.forEach((t) => {
      var r;
      e.push({ status: { baseline_low_date: t[0], support: (r = t[1], { chrome: r.c, chrome_android: r.ca, edge: r.e, firefox: r.f, firefox_android: r.
      fa, safari: r.s, safari_ios: r.si }) } });
    }), e;
  })(), N3 = O3(Cfe), Bfe = O3(wfe), B3 = ["chrome", "chrome_android", "edge", "firefox", "firefox_android", "safari", "safari_ios"], k3 = Object.
  entries(N3).filter(([e]) => B3.includes(e)), kfe = ["webview_android", "samsunginternet_android", "opera_android", "opera"], Ffe = [...Object.
  entries(N3).filter(([e]) => kfe.includes(e)), ...Object.entries(Bfe)], _3 = ["current", "esr", "retired", "unknown", "beta", "nightly"], F3 = !1,
  L3 = /* @__PURE__ */ i((e) => {
    e.includeDownstreamBrowsers === !1 && e.includeKaiOS === !0 && (console.log(new Error("KaiOS is a downstream browser and can only be inc\
luded if you include other downstream browsers. Please ensure you use `includeDownstreamBrowsers: true`.")), process.exit(1));
  }, "p"), I3 = /* @__PURE__ */ i((e) => e && e.startsWith("\u2264") ? e.slice(1) : e, "v"), ar = /* @__PURE__ */ i((e, t) => {
    if (e === t) return 0;
    let [r = 0, s = 0] = e.split(".", 2).map(Number), [n = 0, a = 0] = t.split(".", 2).map(Number);
    if (isNaN(r) || isNaN(s)) throw new Error(`Invalid version: ${e}`);
    if (isNaN(n) || isNaN(a)) throw new Error(`Invalid version: ${t}`);
    return r !== n ? r > n ? 1 : -1 : s !== a ? s > a ? 1 : -1 : 0;
  }, "_"), Lfe = /* @__PURE__ */ i((e) => {
    let t = [];
    return e.forEach((r) => {
      let s = k3.find((n) => n[0] === r.browser);
      s && Object.entries(s[1].releases).filter(([, n]) => _3.includes(n.status)).sort((n, a) => ar(n[0], a[0])).forEach(([n, a]) => !!_3.includes(
      a.status) && ar(n, r.version) === 1 && (t.push({ browser: r.browser, version: n, release_date: a.release_date ? a.release_date : "unkn\
own" }), !0));
    }), t;
  }, "h"), jfe = /* @__PURE__ */ i((e, t = !1) => {
    if (e.getFullYear() < 2015 && !F3 && console.warn(new Error("There are no browser versions compatible with Baseline before 2015.  You ma\
y receive unexpected results.")), e.getFullYear() < 2002) throw new Error("None of the browsers in the core set were released before 2002.  \
Please use a date after 2002.");
    if (e.getFullYear() > (/* @__PURE__ */ new Date()).getFullYear()) throw new Error("There are no browser versions compatible with Baselin\
e in the future");
    let r = ((n) => Nfe.filter((a) => a.status.baseline_low_date && new Date(a.status.baseline_low_date) <= n).map((a) => ({ baseline_low_date: a.
    status.baseline_low_date, support: a.status.support })))(e), s = ((n) => {
      let a = {};
      return Object.entries(k3).forEach(([, o]) => {
        a[o[0]] = { browser: o[0], version: "0", release_date: "" };
      }), n.forEach((o) => {
        Object.entries(o.support).forEach((l) => {
          let u = l[0], c = I3(l[1]);
          a[u] && ar(c, I3(a[u].version)) === 1 && (a[u] = { browser: u, version: c, release_date: o.baseline_low_date });
        });
      }), Object.values(a);
    })(r);
    return t ? [...s, ...Lfe(s)].sort((n, a) => n.browser < a.browser ? -1 : n.browser > a.browser ? 1 : ar(n.version, a.version)) : s;
  }, "m"), j3 = /* @__PURE__ */ i((e = [], t = !0, r = !1) => {
    let s = /* @__PURE__ */ i((l) => {
      var u;
      return e && e.length > 0 ? (u = e.filter((c) => c.browser === l).sort((c, p) => ar(c.version, p.version))[0]) === null || u === void 0 ?
      void 0 : u.version : void 0;
    }, "r"), n = s("chrome"), a = s("firefox");
    if (!n && !a) throw new Error("There are no browser versions compatible with Baseline before Chrome and Firefox");
    let o = [];
    return Ffe.filter(([l]) => !(l === "kai_os" && !r)).forEach(([l, u]) => {
      var c;
      if (!u.releases) return;
      let p = Object.entries(u.releases).filter(([, f]) => {
        let { engine: h, engine_version: b } = f;
        return !(!h || !b) && (h === "Blink" && n ? ar(b, n) >= 0 : !(h !== "Gecko" || !a) && ar(b, a) >= 0);
      }).sort((f, h) => ar(f[0], h[0]));
      for (let f = 0; f < p.length; f++) {
        let h = p[f];
        if (h) {
          let [b, T] = h, d = { browser: l, version: b, release_date: (c = T.release_date) !== null && c !== void 0 ? c : "unknown" };
          if (T.engine && T.engine_version && (d.engine = T.engine, d.engine_version = T.engine_version), o.push(d), !t) break;
        }
      }
    }), o;
  }, "y");
  function ko(e) {
    var t, r, s, n, a;
    let o = e ?? {}, l = { listAllCompatibleVersions: (t = o.listAllCompatibleVersions) !== null && t !== void 0 && t, includeDownstreamBrowsers: (r =
    o.includeDownstreamBrowsers) !== null && r !== void 0 && r, widelyAvailableOnDate: (s = o.widelyAvailableOnDate) !== null && s !== void 0 ?
    s : void 0, targetYear: (n = o.targetYear) !== null && n !== void 0 ? n : void 0, includeKaiOS: (a = o.includeKaiOS) !== null && a !== void 0 &&
    a }, u = /* @__PURE__ */ new Date();
    L3(l), l.widelyAvailableOnDate || l.targetYear ? l.targetYear && l.widelyAvailableOnDate ? (console.log(new Error("You cannot use target\
Year and widelyAvailableOnDate at the same time.  Please remove one of these options and try again.")), process.exit(1)) : l.widelyAvailableOnDate ?
    u = new Date(l.widelyAvailableOnDate) : l.targetYear && (u = /* @__PURE__ */ new Date(`${l.targetYear}-12-31`)) : u = /* @__PURE__ */ new Date(),
    (l.widelyAvailableOnDate || l.targetYear === void 0) && u.setMonth(u.getMonth() - 30);
    let c = jfe(u, l.listAllCompatibleVersions);
    return l.includeDownstreamBrowsers === !1 ? c : [...c, ...j3(c, l.listAllCompatibleVersions, l.includeKaiOS)];
  }
  i(ko, "O");
  qm.getAllVersions = function(e) {
    var t, r, s, n;
    F3 = !0;
    let a = e ?? {}, o = { outputFormat: (t = a.outputFormat) !== null && t !== void 0 ? t : "array", includeDownstreamBrowsers: (r = a.includeDownstreamBrowsers) !==
    null && r !== void 0 && r, useSupports: (s = a.useSupports) !== null && s !== void 0 && s, includeKaiOS: (n = a.includeKaiOS) !== null &&
    n !== void 0 && n };
    L3(o);
    let l = (/* @__PURE__ */ new Date()).getFullYear() + 1, u = [...Array(l).keys()].slice(2002), c = {};
    u.forEach((E) => {
      c[E] = {}, ko({ targetYear: E }).forEach((_) => {
        c[E] && (c[E][_.browser] = _);
      });
    });
    let p = ko({}), f = {};
    p.forEach((E) => {
      f[E.browser] = E;
    });
    let h = /* @__PURE__ */ new Date();
    h.setMonth(h.getMonth() + 30);
    let b = ko({ widelyAvailableOnDate: h.toISOString().slice(0, 10) }), T = {};
    b.forEach((E) => {
      T[E.browser] = E;
    });
    let d = ko({ targetYear: 2002, listAllCompatibleVersions: !0 }), g = [];
    if (B3.forEach((E) => {
      var _, N, k, j;
      let U = d.filter((G) => G.browser == E).sort((G, ue) => ar(G.version, ue.version)), M = (N = (_ = f[E]) === null || _ === void 0 ? void 0 :
      _.version) !== null && N !== void 0 ? N : "0", K = (j = (k = T[E]) === null || k === void 0 ? void 0 : k.version) !== null && j !== void 0 ?
      j : "0";
      u.forEach((G) => {
        var ue;
        if (c[G]) {
          let te = ((ue = c[G][E]) !== null && ue !== void 0 ? ue : { version: "0" }).version, De = U.findIndex((je) => ar(je.version, te) ===
          0);
          (G === l - 1 ? U : U.slice(0, De)).forEach((je) => {
            let wt = ar(je.version, M) >= 0, pr = ar(je.version, K) >= 0, Rt = Object.assign(Object.assign({}, je), { year: G <= 2015 ? "pre\
_baseline" : G - 1 });
            o.useSupports ? (wt && (Rt.supports = "widely"), pr && (Rt.supports = "newly")) : Rt = Object.assign(Object.assign({}, Rt), { wa_compatible: wt }),
            g.push(Rt);
          }), U = U.slice(De, U.length);
        }
      });
    }), o.includeDownstreamBrowsers && j3(g, !0, o.includeKaiOS).forEach((E) => {
      let _ = g.find((N) => N.browser === "chrome" && N.version === E.engine_version);
      _ && (o.useSupports ? g.push(Object.assign(Object.assign({}, E), { year: _.year, supports: _.supports })) : g.push(Object.assign(Object.
      assign({}, E), { year: _.year, wa_compatible: _.wa_compatible })));
    }), g.sort((E, _) => {
      if (E.year === "pre_baseline" && _.year !== "pre_baseline") return -1;
      if (_.year === "pre_baseline" && E.year !== "pre_baseline") return 1;
      if (E.year !== "pre_baseline" && _.year !== "pre_baseline") {
        if (E.year < _.year) return -1;
        if (E.year > _.year) return 1;
      }
      return E.browser < _.browser ? -1 : E.browser > _.browser ? 1 : ar(E.version, _.version);
    }), o.outputFormat === "object") {
      let E = {};
      return g.forEach((_) => {
        E[_.browser] || (E[_.browser] = {});
        let N = { year: _.year, release_date: _.release_date, engine: _.engine, engine_version: _.engine_version };
        E[_.browser][_.version] = o.useSupports ? _.supports ? Object.assign(Object.assign({}, N), { supports: _.supports }) : N : Object.assign(
        Object.assign({}, N), { wa_compatible: _.wa_compatible });
      }), E ?? {};
    }
    if (o.outputFormat === "csv") {
      let E = `"browser","version","year","${o.useSupports ? "supports" : "wa_compatible"}","release_date","engine","engine_version"`;
      return g.forEach((_) => {
        var N, k, j, U;
        let M = { browser: _.browser, version: _.version, year: _.year, release_date: (N = _.release_date) !== null && N !== void 0 ? N : "N\
ULL", engine: (k = _.engine) !== null && k !== void 0 ? k : "NULL", engine_version: (j = _.engine_version) !== null && j !== void 0 ? j : "N\
ULL" };
        M = o.useSupports ? Object.assign(Object.assign({}, M), { supports: (U = _.supports) !== null && U !== void 0 ? U : "" }) : Object.assign(
        Object.assign({}, M), { wa_compatible: _.wa_compatible }), E += `
"${M.browser}","${M.version}","${M.year}","${o.useSupports ? M.supports : M.wa_compatible}","${M.release_date}","${M.engine}","${M.engine_version}\
"`;
      }), E;
    }
    return g;
  }, qm.getCompatibleVersions = ko;
});

// ../node_modules/node-releases/data/processed/envs.json
var R3 = D((z5e, Mfe) => {
  Mfe.exports = [{ name: "nodejs", version: "0.2.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.3.8.0" }, { name: "nodejs", version: "\
0.3.0", date: "2011-08-26", lts: !1, security: !1, v8: "2.5.1.0" }, { name: "nodejs", version: "0.4.0", date: "2011-08-26", lts: !1, security: !1,
  v8: "3.1.2.0" }, { name: "nodejs", version: "0.5.0", date: "2011-08-26", lts: !1, security: !1, v8: "3.1.8.25" }, { name: "nodejs", version: "\
0.6.0", date: "2011-11-04", lts: !1, security: !1, v8: "3.6.6.6" }, { name: "nodejs", version: "0.7.0", date: "2012-01-17", lts: !1, security: !1,
  v8: "3.8.6.0" }, { name: "nodejs", version: "0.8.0", date: "2012-06-22", lts: !1, security: !1, v8: "3.11.10.10" }, { name: "nodejs", version: "\
0.9.0", date: "2012-07-20", lts: !1, security: !1, v8: "3.11.10.15" }, { name: "nodejs", version: "0.10.0", date: "2013-03-11", lts: !1, security: !1,
  v8: "3.14.5.8" }, { name: "nodejs", version: "0.11.0", date: "2013-03-28", lts: !1, security: !1, v8: "3.17.13.0" }, { name: "nodejs", version: "\
0.12.0", date: "2015-02-06", lts: !1, security: !1, v8: "3.28.73.0" }, { name: "nodejs", version: "4.0.0", date: "2015-09-08", lts: !1, security: !1,
  v8: "4.5.103.30" }, { name: "nodejs", version: "4.1.0", date: "2015-09-17", lts: !1, security: !1, v8: "4.5.103.33" }, { name: "nodejs", version: "\
4.2.0", date: "2015-10-12", lts: "Argon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.3.0", date: "2016-02-09", lts: "Ar\
gon", security: !1, v8: "4.5.103.35" }, { name: "nodejs", version: "4.4.0", date: "2016-03-08", lts: "Argon", security: !1, v8: "4.5.103.35" },
  { name: "nodejs", version: "4.5.0", date: "2016-08-16", lts: "Argon", security: !1, v8: "4.5.103.37" }, { name: "nodejs", version: "4.6.0",
  date: "2016-09-27", lts: "Argon", security: !0, v8: "4.5.103.37" }, { name: "nodejs", version: "4.7.0", date: "2016-12-06", lts: "Argon", security: !1,
  v8: "4.5.103.43" }, { name: "nodejs", version: "4.8.0", date: "2017-02-21", lts: "Argon", security: !1, v8: "4.5.103.45" }, { name: "nodej\
s", version: "4.9.0", date: "2018-03-28", lts: "Argon", security: !0, v8: "4.5.103.53" }, { name: "nodejs", version: "5.0.0", date: "2015-10\
-29", lts: !1, security: !1, v8: "4.6.85.28" }, { name: "nodejs", version: "5.1.0", date: "2015-11-17", lts: !1, security: !1, v8: "4.6.85.3\
1" }, { name: "nodejs", version: "5.2.0", date: "2015-12-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.3.0", date: "\
2015-12-15", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.4.0", date: "2016-01-06", lts: !1, security: !1, v8: "4\
.6.85.31" }, { name: "nodejs", version: "5.5.0", date: "2016-01-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5\
.6.0", date: "2016-02-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.7.0", date: "2016-02-23", lts: !1, security: !1,
  v8: "4.6.85.31" }, { name: "nodejs", version: "5.8.0", date: "2016-03-09", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "\
5.9.0", date: "2016-03-16", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "5.10.0", date: "2016-04-01", lts: !1, security: !1,
  v8: "4.6.85.31" }, { name: "nodejs", version: "5.11.0", date: "2016-04-21", lts: !1, security: !1, v8: "4.6.85.31" }, { name: "nodejs", version: "\
5.12.0", date: "2016-06-23", lts: !1, security: !1, v8: "4.6.85.32" }, { name: "nodejs", version: "6.0.0", date: "2016-04-26", lts: !1, security: !1,
  v8: "5.0.71.35" }, { name: "nodejs", version: "6.1.0", date: "2016-05-05", lts: !1, security: !1, v8: "5.0.71.35" }, { name: "nodejs", version: "\
6.2.0", date: "2016-05-17", lts: !1, security: !1, v8: "5.0.71.47" }, { name: "nodejs", version: "6.3.0", date: "2016-07-06", lts: !1, security: !1,
  v8: "5.0.71.52" }, { name: "nodejs", version: "6.4.0", date: "2016-08-12", lts: !1, security: !1, v8: "5.0.71.60" }, { name: "nodejs", version: "\
6.5.0", date: "2016-08-26", lts: !1, security: !1, v8: "5.1.281.81" }, { name: "nodejs", version: "6.6.0", date: "2016-09-14", lts: !1, security: !1,
  v8: "5.1.281.83" }, { name: "nodejs", version: "6.7.0", date: "2016-09-27", lts: !1, security: !0, v8: "5.1.281.83" }, { name: "nodejs", version: "\
6.8.0", date: "2016-10-12", lts: !1, security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.9.0", date: "2016-10-18", lts: "Boron",
  security: !1, v8: "5.1.281.84" }, { name: "nodejs", version: "6.10.0", date: "2017-02-21", lts: "Boron", security: !1, v8: "5.1.281.93" },
  { name: "nodejs", version: "6.11.0", date: "2017-06-06", lts: "Boron", security: !1, v8: "5.1.281.102" }, { name: "nodejs", version: "6.12\
.0", date: "2017-11-06", lts: "Boron", security: !1, v8: "5.1.281.108" }, { name: "nodejs", version: "6.13.0", date: "2018-02-10", lts: "Bor\
on", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.14.0", date: "2018-03-28", lts: "Boron", security: !0, v8: "5.1.281.11\
1" }, { name: "nodejs", version: "6.15.0", date: "2018-11-27", lts: "Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "\
6.16.0", date: "2018-12-26", lts: "Boron", security: !1, v8: "5.1.281.111" }, { name: "nodejs", version: "6.17.0", date: "2019-02-28", lts: "\
Boron", security: !0, v8: "5.1.281.111" }, { name: "nodejs", version: "7.0.0", date: "2016-10-25", lts: !1, security: !1, v8: "5.4.500.36" },
  { name: "nodejs", version: "7.1.0", date: "2016-11-08", lts: !1, security: !1, v8: "5.4.500.36" }, { name: "nodejs", version: "7.2.0", date: "\
2016-11-22", lts: !1, security: !1, v8: "5.4.500.43" }, { name: "nodejs", version: "7.3.0", date: "2016-12-20", lts: !1, security: !1, v8: "\
5.4.500.45" }, { name: "nodejs", version: "7.4.0", date: "2017-01-04", lts: !1, security: !1, v8: "5.4.500.45" }, { name: "nodejs", version: "\
7.5.0", date: "2017-01-31", lts: !1, security: !1, v8: "5.4.500.48" }, { name: "nodejs", version: "7.6.0", date: "2017-02-21", lts: !1, security: !1,
  v8: "5.5.372.40" }, { name: "nodejs", version: "7.7.0", date: "2017-02-28", lts: !1, security: !1, v8: "5.5.372.41" }, { name: "nodejs", version: "\
7.8.0", date: "2017-03-29", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "7.9.0", date: "2017-04-11", lts: !1, security: !1,
  v8: "5.5.372.43" }, { name: "nodejs", version: "7.10.0", date: "2017-05-02", lts: !1, security: !1, v8: "5.5.372.43" }, { name: "nodejs", version: "\
8.0.0", date: "2017-05-30", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "8.1.0", date: "2017-06-08", lts: !1, security: !1,
  v8: "5.8.283.41" }, { name: "nodejs", version: "8.2.0", date: "2017-07-19", lts: !1, security: !1, v8: "5.8.283.41" }, { name: "nodejs", version: "\
8.3.0", date: "2017-08-08", lts: !1, security: !1, v8: "6.0.286.52" }, { name: "nodejs", version: "8.4.0", date: "2017-08-15", lts: !1, security: !1,
  v8: "6.0.286.52" }, { name: "nodejs", version: "8.5.0", date: "2017-09-12", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "\
8.6.0", date: "2017-09-26", lts: !1, security: !1, v8: "6.0.287.53" }, { name: "nodejs", version: "8.7.0", date: "2017-10-11", lts: !1, security: !1,
  v8: "6.1.534.42" }, { name: "nodejs", version: "8.8.0", date: "2017-10-24", lts: !1, security: !1, v8: "6.1.534.42" }, { name: "nodejs", version: "\
8.9.0", date: "2017-10-31", lts: "Carbon", security: !1, v8: "6.1.534.46" }, { name: "nodejs", version: "8.10.0", date: "2018-03-06", lts: "\
Carbon", security: !1, v8: "6.2.414.50" }, { name: "nodejs", version: "8.11.0", date: "2018-03-28", lts: "Carbon", security: !0, v8: "6.2.41\
4.50" }, { name: "nodejs", version: "8.12.0", date: "2018-09-10", lts: "Carbon", security: !1, v8: "6.2.414.66" }, { name: "nodejs", version: "\
8.13.0", date: "2018-11-20", lts: "Carbon", security: !1, v8: "6.2.414.72" }, { name: "nodejs", version: "8.14.0", date: "2018-11-27", lts: "\
Carbon", security: !0, v8: "6.2.414.72" }, { name: "nodejs", version: "8.15.0", date: "2018-12-26", lts: "Carbon", security: !1, v8: "6.2.41\
4.75" }, { name: "nodejs", version: "8.16.0", date: "2019-04-16", lts: "Carbon", security: !1, v8: "6.2.414.77" }, { name: "nodejs", version: "\
8.17.0", date: "2019-12-17", lts: "Carbon", security: !0, v8: "6.2.414.78" }, { name: "nodejs", version: "9.0.0", date: "2017-10-31", lts: !1,
  security: !1, v8: "6.2.414.32" }, { name: "nodejs", version: "9.1.0", date: "2017-11-07", lts: !1, security: !1, v8: "6.2.414.32" }, { name: "\
nodejs", version: "9.2.0", date: "2017-11-14", lts: !1, security: !1, v8: "6.2.414.44" }, { name: "nodejs", version: "9.3.0", date: "2017-12\
-12", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.4.0", date: "2018-01-10", lts: !1, security: !1, v8: "6.2.414\
.46" }, { name: "nodejs", version: "9.5.0", date: "2018-01-31", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.6.0",
  date: "2018-02-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.7.0", date: "2018-03-01", lts: !1, security: !1,
  v8: "6.2.414.46" }, { name: "nodejs", version: "9.8.0", date: "2018-03-07", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "\
9.9.0", date: "2018-03-21", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "9.10.0", date: "2018-03-28", lts: !1, security: !0,
  v8: "6.2.414.46" }, { name: "nodejs", version: "9.11.0", date: "2018-04-04", lts: !1, security: !1, v8: "6.2.414.46" }, { name: "nodejs", version: "\
10.0.0", date: "2018-04-24", lts: !1, security: !1, v8: "6.6.346.24" }, { name: "nodejs", version: "10.1.0", date: "2018-05-08", lts: !1, security: !1,
  v8: "6.6.346.27" }, { name: "nodejs", version: "10.2.0", date: "2018-05-23", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "\
10.3.0", date: "2018-05-29", lts: !1, security: !1, v8: "6.6.346.32" }, { name: "nodejs", version: "10.4.0", date: "2018-06-06", lts: !1, security: !1,
  v8: "6.7.288.43" }, { name: "nodejs", version: "10.5.0", date: "2018-06-20", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "\
10.6.0", date: "2018-07-04", lts: !1, security: !1, v8: "6.7.288.46" }, { name: "nodejs", version: "10.7.0", date: "2018-07-18", lts: !1, security: !1,
  v8: "6.7.288.49" }, { name: "nodejs", version: "10.8.0", date: "2018-08-01", lts: !1, security: !1, v8: "6.7.288.49" }, { name: "nodejs", version: "\
10.9.0", date: "2018-08-15", lts: !1, security: !1, v8: "6.8.275.24" }, { name: "nodejs", version: "10.10.0", date: "2018-09-06", lts: !1, security: !1,
  v8: "6.8.275.30" }, { name: "nodejs", version: "10.11.0", date: "2018-09-19", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs",
  version: "10.12.0", date: "2018-10-10", lts: !1, security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.13.0", date: "2018-10-30",
  lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.14.0", date: "2018-11-27", lts: "Dubnium", security: !0, v8: "\
6.8.275.32" }, { name: "nodejs", version: "10.15.0", date: "2018-12-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs",
  version: "10.16.0", date: "2019-05-28", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.17.0", date: "201\
9-10-22", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.18.0", date: "2019-12-17", lts: "Dubnium", security: !0,
  v8: "6.8.275.32" }, { name: "nodejs", version: "10.19.0", date: "2020-02-05", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "n\
odejs", version: "10.20.0", date: "2020-03-26", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "nodejs", version: "10.21.0", date: "\
2020-06-02", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "10.22.0", date: "2020-07-21", lts: "Dubnium", security: !1,
  v8: "6.8.275.32" }, { name: "nodejs", version: "10.23.0", date: "2020-10-27", lts: "Dubnium", security: !1, v8: "6.8.275.32" }, { name: "n\
odejs", version: "10.24.0", date: "2021-02-23", lts: "Dubnium", security: !0, v8: "6.8.275.32" }, { name: "nodejs", version: "11.0.0", date: "\
2018-10-23", lts: !1, security: !1, v8: "7.0.276.28" }, { name: "nodejs", version: "11.1.0", date: "2018-10-30", lts: !1, security: !1, v8: "\
7.0.276.32" }, { name: "nodejs", version: "11.2.0", date: "2018-11-15", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.3.0", date: "2018-11-27", lts: !1, security: !0, v8: "7.0.276.38" }, { name: "nodejs", version: "11.4.0", date: "2018-12-07", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.5.0", date: "2018-12-18", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.6.0", date: "2018-12-26", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.7.0", date: "2019-01-17", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.8.0", date: "2019-01-24", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "\
11.9.0", date: "2019-01-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.10.0", date: "2019-02-14", lts: !1, security: !1,
  v8: "7.0.276.38" }, { name: "nodejs", version: "11.11.0", date: "2019-03-05", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs",
  version: "11.12.0", date: "2019-03-14", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.13.0", date: "2019-03-28",
  lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "11.14.0", date: "2019-04-10", lts: !1, security: !1, v8: "7.0.276.3\
8" }, { name: "nodejs", version: "11.15.0", date: "2019-04-30", lts: !1, security: !1, v8: "7.0.276.38" }, { name: "nodejs", version: "12.0.\
0", date: "2019-04-23", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "12.1.0", date: "2019-04-29", lts: !1, security: !1,
  v8: "7.4.288.21" }, { name: "nodejs", version: "12.2.0", date: "2019-05-07", lts: !1, security: !1, v8: "7.4.288.21" }, { name: "nodejs", version: "\
12.3.0", date: "2019-05-21", lts: !1, security: !1, v8: "7.4.288.27" }, { name: "nodejs", version: "12.4.0", date: "2019-06-04", lts: !1, security: !1,
  v8: "7.4.288.27" }, { name: "nodejs", version: "12.5.0", date: "2019-06-26", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "\
12.6.0", date: "2019-07-03", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "12.7.0", date: "2019-07-23", lts: !1, security: !1,
  v8: "7.5.288.22" }, { name: "nodejs", version: "12.8.0", date: "2019-08-06", lts: !1, security: !1, v8: "7.5.288.22" }, { name: "nodejs", version: "\
12.9.0", date: "2019-08-20", lts: !1, security: !1, v8: "7.6.303.29" }, { name: "nodejs", version: "12.10.0", date: "2019-09-04", lts: !1, security: !1,
  v8: "7.6.303.29" }, { name: "nodejs", version: "12.11.0", date: "2019-09-25", lts: !1, security: !1, v8: "7.7.299.11" }, { name: "nodejs",
  version: "12.12.0", date: "2019-10-11", lts: !1, security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.13.0", date: "2019-10-21",
  lts: "Erbium", security: !1, v8: "7.7.299.13" }, { name: "nodejs", version: "12.14.0", date: "2019-12-17", lts: "Erbium", security: !0, v8: "\
7.7.299.13" }, { name: "nodejs", version: "12.15.0", date: "2020-02-05", lts: "Erbium", security: !0, v8: "7.7.299.13" }, { name: "nodejs", version: "\
12.16.0", date: "2020-02-11", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.17.0", date: "2020-05-26", lts: "\
Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.18.0", date: "2020-06-02", lts: "Erbium", security: !0, v8: "7.8.2\
79.23" }, { name: "nodejs", version: "12.19.0", date: "2020-10-06", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "\
12.20.0", date: "2020-11-24", lts: "Erbium", security: !1, v8: "7.8.279.23" }, { name: "nodejs", version: "12.21.0", date: "2021-02-23", lts: "\
Erbium", security: !0, v8: "7.8.279.23" }, { name: "nodejs", version: "12.22.0", date: "2021-03-30", lts: "Erbium", security: !1, v8: "7.8.2\
79.23" }, { name: "nodejs", version: "13.0.0", date: "2019-10-22", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13\
.1.0", date: "2019-11-05", lts: !1, security: !1, v8: "7.8.279.17" }, { name: "nodejs", version: "13.2.0", date: "2019-11-21", lts: !1, security: !1,
  v8: "7.9.317.23" }, { name: "nodejs", version: "13.3.0", date: "2019-12-03", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.4.0", date: "2019-12-17", lts: !1, security: !0, v8: "7.9.317.25" }, { name: "nodejs", version: "13.5.0", date: "2019-12-18", lts: !1, security: !1,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.6.0", date: "2020-01-07", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.7.0", date: "2020-01-21", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.8.0", date: "2020-02-05", lts: !1, security: !0,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.9.0", date: "2020-02-18", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "\
13.10.0", date: "2020-03-04", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.11.0", date: "2020-03-12", lts: !1, security: !1,
  v8: "7.9.317.25" }, { name: "nodejs", version: "13.12.0", date: "2020-03-26", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs",
  version: "13.13.0", date: "2020-04-14", lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "13.14.0", date: "2020-04-29",
  lts: !1, security: !1, v8: "7.9.317.25" }, { name: "nodejs", version: "14.0.0", date: "2020-04-21", lts: !1, security: !1, v8: "8.1.307.30" },
  { name: "nodejs", version: "14.1.0", date: "2020-04-29", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.2.0", date: "\
2020-05-05", lts: !1, security: !1, v8: "8.1.307.31" }, { name: "nodejs", version: "14.3.0", date: "2020-05-19", lts: !1, security: !1, v8: "\
8.1.307.31" }, { name: "nodejs", version: "14.4.0", date: "2020-06-02", lts: !1, security: !0, v8: "8.1.307.31" }, { name: "nodejs", version: "\
14.5.0", date: "2020-06-30", lts: !1, security: !1, v8: "8.3.110.9" }, { name: "nodejs", version: "14.6.0", date: "2020-07-20", lts: !1, security: !1,
  v8: "8.4.371.19" }, { name: "nodejs", version: "14.7.0", date: "2020-07-29", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "\
14.8.0", date: "2020-08-11", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.9.0", date: "2020-08-27", lts: !1, security: !1,
  v8: "8.4.371.19" }, { name: "nodejs", version: "14.10.0", date: "2020-09-08", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs",
  version: "14.11.0", date: "2020-09-15", lts: !1, security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.12.0", date: "2020-09-22",
  lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.13.0", date: "2020-09-29", lts: !1, security: !1, v8: "8.4.371.1\
9" }, { name: "nodejs", version: "14.14.0", date: "2020-10-15", lts: !1, security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.15\
.0", date: "2020-10-27", lts: "Fermium", security: !1, v8: "8.4.371.19" }, { name: "nodejs", version: "14.16.0", date: "2021-02-23", lts: "F\
ermium", security: !0, v8: "8.4.371.19" }, { name: "nodejs", version: "14.17.0", date: "2021-05-11", lts: "Fermium", security: !1, v8: "8.4.\
371.23" }, { name: "nodejs", version: "14.18.0", date: "2021-09-28", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "\
14.19.0", date: "2022-02-01", lts: "Fermium", security: !1, v8: "8.4.371.23" }, { name: "nodejs", version: "14.20.0", date: "2022-07-07", lts: "\
Fermium", security: !0, v8: "8.4.371.23" }, { name: "nodejs", version: "14.21.0", date: "2022-11-01", lts: "Fermium", security: !1, v8: "8.4\
.371.23" }, { name: "nodejs", version: "15.0.0", date: "2020-10-20", lts: !1, security: !1, v8: "8.6.395.16" }, { name: "nodejs", version: "\
15.1.0", date: "2020-11-04", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.2.0", date: "2020-11-10", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.3.0", date: "2020-11-24", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.4.0", date: "2020-12-09", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.5.0", date: "2020-12-22", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.6.0", date: "2021-01-14", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.7.0", date: "2021-01-25", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.8.0", date: "2021-02-02", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.9.0", date: "2021-02-18", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "\
15.10.0", date: "2021-02-23", lts: !1, security: !0, v8: "8.6.395.17" }, { name: "nodejs", version: "15.11.0", date: "2021-03-03", lts: !1, security: !1,
  v8: "8.6.395.17" }, { name: "nodejs", version: "15.12.0", date: "2021-03-17", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs",
  version: "15.13.0", date: "2021-03-31", lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "15.14.0", date: "2021-04-06",
  lts: !1, security: !1, v8: "8.6.395.17" }, { name: "nodejs", version: "16.0.0", date: "2021-04-20", lts: !1, security: !1, v8: "9.0.257.17" },
  { name: "nodejs", version: "16.1.0", date: "2021-05-04", lts: !1, security: !1, v8: "9.0.257.24" }, { name: "nodejs", version: "16.2.0", date: "\
2021-05-19", lts: !1, security: !1, v8: "9.0.257.25" }, { name: "nodejs", version: "16.3.0", date: "2021-06-03", lts: !1, security: !1, v8: "\
9.0.257.25" }, { name: "nodejs", version: "16.4.0", date: "2021-06-23", lts: !1, security: !1, v8: "9.1.269.36" }, { name: "nodejs", version: "\
16.5.0", date: "2021-07-14", lts: !1, security: !1, v8: "9.1.269.38" }, { name: "nodejs", version: "16.6.0", date: "2021-07-29", lts: !1, security: !0,
  v8: "9.2.230.21" }, { name: "nodejs", version: "16.7.0", date: "2021-08-18", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "\
16.8.0", date: "2021-08-25", lts: !1, security: !1, v8: "9.2.230.21" }, { name: "nodejs", version: "16.9.0", date: "2021-09-07", lts: !1, security: !1,
  v8: "9.3.345.16" }, { name: "nodejs", version: "16.10.0", date: "2021-09-22", lts: !1, security: !1, v8: "9.3.345.19" }, { name: "nodejs",
  version: "16.11.0", date: "2021-10-08", lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.12.0", date: "2021-10-20",
  lts: !1, security: !1, v8: "9.4.146.19" }, { name: "nodejs", version: "16.13.0", date: "2021-10-26", lts: "Gallium", security: !1, v8: "9.\
4.146.19" }, { name: "nodejs", version: "16.14.0", date: "2022-02-08", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "\
16.15.0", date: "2022-04-26", lts: "Gallium", security: !1, v8: "9.4.146.24" }, { name: "nodejs", version: "16.16.0", date: "2022-07-07", lts: "\
Gallium", security: !0, v8: "9.4.146.24" }, { name: "nodejs", version: "16.17.0", date: "2022-08-16", lts: "Gallium", security: !1, v8: "9.4\
.146.26" }, { name: "nodejs", version: "16.18.0", date: "2022-10-12", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "\
16.19.0", date: "2022-12-13", lts: "Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "16.20.0", date: "2023-03-28", lts: "\
Gallium", security: !1, v8: "9.4.146.26" }, { name: "nodejs", version: "17.0.0", date: "2021-10-19", lts: !1, security: !1, v8: "9.5.172.21" },
  { name: "nodejs", version: "17.1.0", date: "2021-11-09", lts: !1, security: !1, v8: "9.5.172.25" }, { name: "nodejs", version: "17.2.0", date: "\
2021-11-30", lts: !1, security: !1, v8: "9.6.180.14" }, { name: "nodejs", version: "17.3.0", date: "2021-12-17", lts: !1, security: !1, v8: "\
9.6.180.15" }, { name: "nodejs", version: "17.4.0", date: "2022-01-18", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "\
17.5.0", date: "2022-02-10", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.6.0", date: "2022-02-22", lts: !1, security: !1,
  v8: "9.6.180.15" }, { name: "nodejs", version: "17.7.0", date: "2022-03-09", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "\
17.8.0", date: "2022-03-22", lts: !1, security: !1, v8: "9.6.180.15" }, { name: "nodejs", version: "17.9.0", date: "2022-04-07", lts: !1, security: !1,
  v8: "9.6.180.15" }, { name: "nodejs", version: "18.0.0", date: "2022-04-18", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "\
18.1.0", date: "2022-05-03", lts: !1, security: !1, v8: "10.1.124.8" }, { name: "nodejs", version: "18.2.0", date: "2022-05-17", lts: !1, security: !1,
  v8: "10.1.124.8" }, { name: "nodejs", version: "18.3.0", date: "2022-06-02", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "\
18.4.0", date: "2022-06-16", lts: !1, security: !1, v8: "10.2.154.4" }, { name: "nodejs", version: "18.5.0", date: "2022-07-06", lts: !1, security: !0,
  v8: "10.2.154.4" }, { name: "nodejs", version: "18.6.0", date: "2022-07-13", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs",
  version: "18.7.0", date: "2022-07-26", lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.8.0", date: "2022-08-24",
  lts: !1, security: !1, v8: "10.2.154.13" }, { name: "nodejs", version: "18.9.0", date: "2022-09-07", lts: !1, security: !1, v8: "10.2.154.\
15" }, { name: "nodejs", version: "18.10.0", date: "2022-09-28", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.\
11.0", date: "2022-10-13", lts: !1, security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.12.0", date: "2022-10-25", lts: "Hydro\
gen", security: !1, v8: "10.2.154.15" }, { name: "nodejs", version: "18.13.0", date: "2023-01-05", lts: "Hydrogen", security: !1, v8: "10.2.\
154.23" }, { name: "nodejs", version: "18.14.0", date: "2023-02-01", lts: "Hydrogen", security: !1, v8: "10.2.154.23" }, { name: "nodejs", version: "\
18.15.0", date: "2023-03-05", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.16.0", date: "2023-04-12", lts: "\
Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.17.0", date: "2023-07-18", lts: "Hydrogen", security: !1, v8: "\
10.2.154.26" }, { name: "nodejs", version: "18.18.0", date: "2023-09-18", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodej\
s", version: "18.19.0", date: "2023-11-29", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "18.20.0", date: "\
2024-03-26", lts: "Hydrogen", security: !1, v8: "10.2.154.26" }, { name: "nodejs", version: "19.0.0", date: "2022-10-17", lts: !1, security: !1,
  v8: "10.7.193.13" }, { name: "nodejs", version: "19.1.0", date: "2022-11-14", lts: !1, security: !1, v8: "10.7.193.20" }, { name: "nodejs",
  version: "19.2.0", date: "2022-11-29", lts: !1, security: !1, v8: "10.8.168.20" }, { name: "nodejs", version: "19.3.0", date: "2022-12-14",
  lts: !1, security: !1, v8: "10.8.168.21" }, { name: "nodejs", version: "19.4.0", date: "2023-01-05", lts: !1, security: !1, v8: "10.8.168.\
25" }, { name: "nodejs", version: "19.5.0", date: "2023-01-24", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.6\
.0", date: "2023-02-01", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "19.7.0", date: "2023-02-21", lts: !1, security: !1,
  v8: "10.8.168.25" }, { name: "nodejs", version: "19.8.0", date: "2023-03-14", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs",
  version: "19.9.0", date: "2023-04-10", lts: !1, security: !1, v8: "10.8.168.25" }, { name: "nodejs", version: "20.0.0", date: "2023-04-17",
  lts: !1, security: !1, v8: "11.3.244.4" }, { name: "nodejs", version: "20.1.0", date: "2023-05-03", lts: !1, security: !1, v8: "11.3.244.8" },
  { name: "nodejs", version: "20.2.0", date: "2023-05-16", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.3.0", date: "\
2023-06-08", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.4.0", date: "2023-07-04", lts: !1, security: !1, v8: "\
11.3.244.8" }, { name: "nodejs", version: "20.5.0", date: "2023-07-19", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "\
20.6.0", date: "2023-08-23", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.7.0", date: "2023-09-18", lts: !1, security: !1,
  v8: "11.3.244.8" }, { name: "nodejs", version: "20.8.0", date: "2023-09-28", lts: !1, security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "\
20.9.0", date: "2023-10-24", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.10.0", date: "2023-11-22", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.11.0", date: "2024-01-09", lts: "Iron", security: !1, v8: "11.3.244.\
8" }, { name: "nodejs", version: "20.12.0", date: "2024-03-26", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "2\
0.13.0", date: "2024-05-07", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.14.0", date: "2024-05-28", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.15.0", date: "2024-06-20", lts: "Iron", security: !1, v8: "11.3.244.\
8" }, { name: "nodejs", version: "20.16.0", date: "2024-07-24", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "2\
0.17.0", date: "2024-08-21", lts: "Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.18.0", date: "2024-10-03", lts: "\
Iron", security: !1, v8: "11.3.244.8" }, { name: "nodejs", version: "20.19.0", date: "2025-03-13", lts: "Iron", security: !1, v8: "11.3.244.\
8" }, { name: "nodejs", version: "21.0.0", date: "2023-10-17", lts: !1, security: !1, v8: "11.8.172.13" }, { name: "nodejs", version: "21.1.\
0", date: "2023-10-24", lts: !1, security: !1, v8: "11.8.172.15" }, { name: "nodejs", version: "21.2.0", date: "2023-11-14", lts: !1, security: !1,
  v8: "11.8.172.17" }, { name: "nodejs", version: "21.3.0", date: "2023-11-30", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs",
  version: "21.4.0", date: "2023-12-05", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.5.0", date: "2023-12-19",
  lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "21.6.0", date: "2024-01-14", lts: !1, security: !1, v8: "11.8.172.\
17" }, { name: "nodejs", version: "21.7.0", date: "2024-03-06", lts: !1, security: !1, v8: "11.8.172.17" }, { name: "nodejs", version: "22.0\
.0", date: "2024-04-24", lts: !1, security: !1, v8: "12.4.254.14" }, { name: "nodejs", version: "22.1.0", date: "2024-05-02", lts: !1, security: !1,
  v8: "12.4.254.14" }, { name: "nodejs", version: "22.2.0", date: "2024-05-15", lts: !1, security: !1, v8: "12.4.254.14" }, { name: "nodejs",
  version: "22.3.0", date: "2024-06-11", lts: !1, security: !1, v8: "12.4.254.20" }, { name: "nodejs", version: "22.4.0", date: "2024-07-02",
  lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.5.0", date: "2024-07-17", lts: !1, security: !1, v8: "12.4.254.\
21" }, { name: "nodejs", version: "22.6.0", date: "2024-08-06", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.7\
.0", date: "2024-08-21", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.8.0", date: "2024-09-03", lts: !1, security: !1,
  v8: "12.4.254.21" }, { name: "nodejs", version: "22.9.0", date: "2024-09-17", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs",
  version: "22.10.0", date: "2024-10-16", lts: !1, security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.11.0", date: "2024-10-2\
9", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.12.0", date: "2024-12-02", lts: "Jod", security: !1, v8: "\
12.4.254.21" }, { name: "nodejs", version: "22.13.0", date: "2025-01-06", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "\
22.14.0", date: "2025-02-11", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.15.0", date: "2025-04-22", lts: "\
Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.16.0", date: "2025-05-20", lts: "Jod", security: !1, v8: "12.4.254.2\
1" }, { name: "nodejs", version: "22.17.0", date: "2025-06-24", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "2\
2.18.0", date: "2025-07-31", lts: "Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "22.19.0", date: "2025-08-28", lts: "\
Jod", security: !1, v8: "12.4.254.21" }, { name: "nodejs", version: "23.0.0", date: "2024-10-16", lts: !1, security: !1, v8: "12.9.202.26" },
  { name: "nodejs", version: "23.1.0", date: "2024-10-24", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.2.0", date: "\
2024-11-11", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.3.0", date: "2024-11-20", lts: !1, security: !1, v8: "\
12.9.202.28" }, { name: "nodejs", version: "23.4.0", date: "2024-12-10", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "\
23.5.0", date: "2024-12-19", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.6.0", date: "2025-01-07", lts: !1, security: !1,
  v8: "12.9.202.28" }, { name: "nodejs", version: "23.7.0", date: "2025-01-30", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs",
  version: "23.8.0", date: "2025-02-13", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.9.0", date: "2025-02-26",
  lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "23.10.0", date: "2025-03-13", lts: !1, security: !1, v8: "12.9.202\
.28" }, { name: "nodejs", version: "23.11.0", date: "2025-04-01", lts: !1, security: !1, v8: "12.9.202.28" }, { name: "nodejs", version: "24\
.0.0", date: "2025-05-06", lts: !1, security: !1, v8: "13.6.233.8" }, { name: "nodejs", version: "24.1.0", date: "2025-05-20", lts: !1, security: !1,
  v8: "13.6.233.10" }, { name: "nodejs", version: "24.2.0", date: "2025-06-09", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs",
  version: "24.3.0", date: "2025-06-24", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.4.0", date: "2025-07-09",
  lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.5.0", date: "2025-07-31", lts: !1, security: !1, v8: "13.6.233.\
10" }, { name: "nodejs", version: "24.6.0", date: "2025-08-14", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.7\
.0", date: "2025-08-27", lts: !1, security: !1, v8: "13.6.233.10" }, { name: "nodejs", version: "24.8.0", date: "2025-09-10", lts: !1, security: !1,
  v8: "13.6.233.10" }];
});

// ../node_modules/caniuse-lite/data/browsers.js
var U3 = D((Q5e, q3) => {
  q3.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "\
op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
});

// ../node_modules/caniuse-lite/dist/unpacker/browsers.js
var Dc = D((Z5e, $3) => {
  $3.exports.browsers = U3();
});

// ../node_modules/caniuse-lite/data/browserVersions.js
var K3 = D((e6e, V3) => {
  V3.exports = { 0: "117", 1: "118", 2: "119", 3: "120", 4: "121", 5: "122", 6: "20", 7: "21", 8: "22", 9: "23", A: "10", B: "11", C: "12", D: "\
7", E: "8", F: "9", G: "15", H: "80", I: "139", J: "4", K: "6", L: "13", M: "14", N: "16", O: "17", P: "18", Q: "79", R: "81", S: "83", T: "\
84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "99", j: "\
100", k: "101", l: "102", m: "103", n: "104", o: "105", p: "106", q: "107", r: "108", s: "109", t: "110", u: "111", v: "112", w: "113", x: "\
114", y: "115", z: "116", AB: "24", BB: "25", CB: "26", DB: "27", EB: "28", FB: "123", GB: "124", HB: "125", IB: "126", JB: "127", KB: "128",
  LB: "129", MB: "130", NB: "131", OB: "132", PB: "133", QB: "134", RB: "135", SB: "136", TB: "137", UB: "138", VB: "140", WB: "5", XB: "19",
  YB: "29", ZB: "30", aB: "31", bB: "32", cB: "33", dB: "34", eB: "35", fB: "36", gB: "37", hB: "38", iB: "39", jB: "40", kB: "41", lB: "42",
  mB: "43", nB: "44", oB: "45", pB: "46", qB: "47", rB: "48", sB: "49", tB: "50", uB: "51", vB: "52", wB: "53", xB: "54", yB: "55", zB: "56",
  "0B": "57", "1B": "58", "2B": "60", "3B": "62", "4B": "63", "5B": "64", "6B": "65", "7B": "66", "8B": "67", "9B": "68", AC: "69", BC: "70",
  CC: "71", DC: "72", EC: "73", FC: "74", GC: "75", HC: "76", IC: "77", JC: "78", KC: "142", LC: "11.1", MC: "12.1", NC: "15.5", OC: "16.0",
  PC: "17.0", QC: "18.0", RC: "3", SC: "59", TC: "61", UC: "82", VC: "141", WC: "143", XC: "3.2", YC: "10.1", ZC: "15.2-15.3", aC: "15.4", bC: "\
16.1", cC: "16.2", dC: "16.3", eC: "16.4", fC: "16.5", gC: "17.1", hC: "17.2", iC: "17.3", jC: "17.4", kC: "17.5", lC: "18.1", mC: "18.2", nC: "\
18.3", oC: "18.4", pC: "18.5-18.6", qC: "26.0", rC: "26.1", sC: "11.5", tC: "4.2-4.3", uC: "5.5", vC: "2", wC: "144", xC: "145", yC: "3.5", zC: "\
3.6", "0C": "3.1", "1C": "5.1", "2C": "6.1", "3C": "7.1", "4C": "9.1", "5C": "13.1", "6C": "14.1", "7C": "15.1", "8C": "15.6", "9C": "16.6",
  AD: "17.6", BD: "TP", CD: "9.5-9.6", DD: "10.0-10.1", ED: "10.5", FD: "10.6", GD: "11.6", HD: "4.0-4.1", ID: "5.0-5.1", JD: "6.0-6.1", KD: "\
7.0-7.1", LD: "8.1-8.4", MD: "9.0-9.2", ND: "9.3", OD: "10.0-10.2", PD: "10.3", QD: "11.0-11.2", RD: "11.3-11.4", SD: "12.0-12.1", TD: "12.2\
-12.5", UD: "13.0-13.1", VD: "13.2", WD: "13.3", XD: "13.4-13.7", YD: "14.0-14.4", ZD: "14.5-14.8", aD: "15.0-15.1", bD: "15.6-15.8", cD: "1\
6.6-16.7", dD: "17.6-17.7", eD: "all", fD: "2.1", gD: "2.2", hD: "2.3", iD: "4.1", jD: "4.4", kD: "4.4.3-4.4.4", lD: "5.0-5.4", mD: "6.2-6.4",
  nD: "7.2-7.4", oD: "8.2", pD: "9.2", qD: "11.1-11.2", rD: "12.0", sD: "13.0", tD: "14.0", uD: "15.0", vD: "19.0", wD: "14.9", xD: "13.52",
  yD: "2.5", zD: "3.0-3.1" };
});

// ../node_modules/caniuse-lite/dist/unpacker/browserVersions.js
var Um = D((t6e, W3) => {
  W3.exports.browserVersions = K3();
});

// ../node_modules/caniuse-lite/data/agents.js
var H3 = D((r6e, Y3) => {
  Y3.exports = { A: { A: { K: 0, D: 0, E: 0.0379299, F: 0.0303439, A: 758598e-8, B: 0.675152, uC: 0 }, B: "ms", C: ["", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "uC", "K", "D", "E", "F", "A", "B", "", "",
  ""], E: "IE", F: { uC: 962323200, K: 998870400, D: 1161129600, E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { 0: 0,
  1: 0, 2: 0, 3: 0.031456, 4: 3932e-6, 5: 0.011796, C: 0, L: 0, M: 0, G: 0, N: 0, O: 0, P: 3932e-6, Q: 0, H: 0, R: 0, S: 0, T: 0, U: 0, V: 0,
  W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0.011796, c: 0, d: 0, e: 0, f: 3932e-6, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 0,
  r: 0, s: 0.03932, t: 0, u: 0, v: 0, w: 7864e-6, x: 0.023592, y: 3932e-6, z: 0, FB: 3932e-6, GB: 7864e-6, HB: 3932e-6, IB: 0.011796, JB: 0.011796,
  KB: 7864e-6, LB: 7864e-6, MB: 0.011796, NB: 0.031456, OB: 0.011796, PB: 0.015728, QB: 0.043252, RB: 0.023592, SB: 0.027524, TB: 0.043252, UB: 1.44698,
  I: 2.72094, VB: 7864e-6 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "L", "M", "G", "N", "O", "P", "Q", "H", "R", "S", "T", "U", "V", "W",
  "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y",
  "z", "0", "1", "2", "3", "4", "5", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "I", "V\
B", "", "", ""], E: "Edge", F: { 0: 1694649600, 1: 1697155200, 2: 1698969600, 3: 1701993600, 4: 1706227200, 5: 1708732800, C: 1438128e3, L: 1447286400,
  M: 1470096e3, G: 1491868800, N: 1508198400, O: 1525046400, P: 1542067200, Q: 1579046400, H: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600,
  U: 1598486400, V: 1602201600, W: 1605830400, X: 161136e4, Y: 1614816e3, Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600,
  e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, i: 1646265600, j: 1649635200, k: 1651190400, l: 1653955200, m: 1655942400, n: 1659657600,
  o: 1661990400, p: 1664755200, q: 1666915200, r: 1670198400, s: 1673481600, t: 1675900800, u: 1678665600, v: 1680825600, w: 1683158400, x: 1685664e3,
  y: 1689897600, z: 1692576e3, FB: 1711152e3, GB: 1713398400, HB: 1715990400, IB: 1718841600, JB: 1721865600, KB: 1724371200, LB: 1726704e3,
  MB: 1729123200, NB: 1731542400, OB: 1737417600, PB: 1740614400, QB: 1741219200, RB: 1743984e3, SB: 1746316800, TB: 1748476800, UB: 1750896e3,
  I: 1754611200, VB: 1756944e3 }, D: { C: "ms", L: "ms", M: "ms", G: "ms", N: "ms", O: "ms", P: "ms" } }, C: { A: { 0: 0, 1: 0.121892, 2: 0,
  3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, vC: 0, RC: 0, J: 0, WB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0.031456, C: 0, L: 0, M: 0, G: 0, N: 0,
  O: 0, P: 0, XB: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0,
  lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, vB: 0.027524, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 0, "1B": 0, SC: 3932e-6,
  "2B": 0, TC: 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0, "8B": 0, "9B": 0, AC: 0, BC: 0, CC: 0, DC: 0, EC: 0, FC: 0, GC: 0, HC: 0, IC: 0,
  JC: 7864e-6, Q: 0, H: 0, R: 0, UC: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0,
  j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 0, r: 0, s: 0, t: 0, u: 0, v: 0, w: 0, x: 0, y: 0.169076, z: 0, FB: 0, GB: 0, HB: 3932e-6, IB: 0,
  JB: 0, KB: 0.07864, LB: 0, MB: 0, NB: 0, OB: 0, PB: 0.015728, QB: 7864e-6, RB: 0.011796, SB: 0.011796, TB: 7864e-6, UB: 0.011796, I: 0.01966,
  VB: 0.047184, VC: 0.868972, KC: 0.404996, WC: 0, wC: 0, xC: 0, yC: 0, zC: 0 }, B: "moz", C: ["vC", "RC", "yC", "zC", "J", "WB", "K", "D", "\
E", "F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "XB", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "YB", "ZB", "aB", "bB", "cB", "\
dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B",
  "1B", "SC", "2B", "TC", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "Q", "H", "R",
  "UC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s",
  "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "\
RB", "SB", "TB", "UB", "I", "VB", "VC", "KC", "WC", "wC", "xC"], E: "Firefox", F: { 0: 1693267200, 1: 1695686400, 2: 1698105600, 3: 1700524800,
  4: 1702944e3, 5: 1705968e3, 6: 1361232e3, 7: 1364860800, 8: 1368489600, 9: 1372118400, vC: 1161648e3, RC: 1213660800, yC: 124632e4, zC: 1264032e3,
  J: 1300752e3, WB: 1308614400, K: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800, L: 1335225600,
  M: 1338854400, G: 1342483200, N: 1346112e3, O: 1349740800, P: 1353628800, XB: 1357603200, AB: 1375747200, BB: 1379376e3, CB: 1386633600, DB: 1391472e3,
  EB: 1395100800, YB: 1398729600, ZB: 1402358400, aB: 1405987200, bB: 1409616e3, cB: 1413244800, dB: 1417392e3, eB: 1421107200, fB: 1424736e3,
  gB: 1428278400, hB: 1431475200, iB: 1435881600, jB: 1439251200, kB: 144288e4, lB: 1446508800, mB: 1450137600, nB: 1453852800, oB: 1457395200,
  pB: 1461628800, qB: 1465257600, rB: 1470096e3, sB: 1474329600, tB: 1479168e3, uB: 1485216e3, vB: 1488844800, wB: 149256e4, xB: 1497312e3, yB: 1502150400,
  zB: 1506556800, "0B": 1510617600, "1B": 1516665600, SC: 1520985600, "2B": 1525824e3, TC: 1529971200, "3B": 1536105600, "4B": 1540252800, "\
5B": 1544486400, "6B": 154872e4, "7B": 1552953600, "8B": 1558396800, "9B": 1562630400, AC: 1567468800, BC: 1571788800, CC: 1575331200, DC: 1578355200,
  EC: 1581379200, FC: 1583798400, GC: 1586304e3, HC: 1588636800, IC: 1591056e3, JC: 1593475200, Q: 1595894400, H: 1598313600, R: 1600732800,
  UC: 1603152e3, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600,
  b: 1630972800, c: 1633392e3, d: 1635811200, e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536e3, k: 1653955200,
  l: 1656374400, m: 1658793600, n: 1661212800, o: 1663632e3, p: 1666051200, q: 1668470400, r: 1670889600, s: 1673913600, t: 1676332800, u: 1678752e3,
  v: 1681171200, w: 1683590400, x: 1686009600, y: 1688428800, z: 1690848e3, FB: 1708387200, GB: 1710806400, HB: 1713225600, IB: 1715644800, JB: 1718064e3,
  KB: 1720483200, LB: 1722902400, MB: 1725321600, NB: 1727740800, OB: 173016e4, PB: 1732579200, QB: 1736208e3, RB: 1738627200, SB: 1741046400,
  TB: 1743465600, UB: 1745884800, I: 1748304e3, VB: 1750723200, VC: 1753142400, KC: 1755561600, WC: null, wC: null, xC: null } }, D: { A: { 0: 0.11796,
  1: 0.05898, 2: 0.051116, 3: 0.106164, 4: 0.043252, 5: 0.070776, 6: 0, 7: 0, 8: 0, 9: 0, J: 0, WB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0,
  L: 0, M: 0, G: 0, N: 0, O: 0, P: 0, XB: 0, AB: 0, BB: 0, CB: 0, DB: 0, EB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0,
  hB: 0, iB: 7864e-6, jB: 7864e-6, kB: 7864e-6, lB: 7864e-6, mB: 7864e-6, nB: 7864e-6, oB: 0.011796, pB: 7864e-6, qB: 0.011796, rB: 0.01966,
  sB: 0.01966, tB: 7864e-6, uB: 7864e-6, vB: 0.011796, wB: 7864e-6, xB: 7864e-6, yB: 7864e-6, zB: 0.015728, "0B": 7864e-6, "1B": 0.011796, SC: 7864e-6,
  "2B": 7864e-6, TC: 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0.023592, "8B": 0, "9B": 3932e-6, AC: 7864e-6, BC: 7864e-6, CC: 0, DC: 0, EC: 0,
  FC: 3932e-6, GC: 3932e-6, HC: 3932e-6, IC: 0, JC: 7864e-6, Q: 0.070776, H: 7864e-6, R: 0.035388, S: 0.043252, T: 0, U: 7864e-6, V: 0.011796,
  W: 0.03932, X: 7864e-6, Y: 3932e-6, Z: 7864e-6, a: 0.01966, b: 0.011796, c: 0.011796, d: 3932e-6, e: 0, f: 7864e-6, g: 0.015728, h: 0.043252,
  i: 0.015728, j: 0.011796, k: 0.01966, l: 0.015728, m: 0.090436, n: 0.031456, o: 0.813924, p: 7864e-6, q: 0.011796, r: 0.031456, s: 0.723488,
  t: 7864e-6, u: 0.027524, v: 2.94114, w: 0.011796, x: 0.047184, y: 0.082572, z: 0.066844, FB: 0.074708, GB: 0.062912, HB: 0.428588, IB: 0.467908,
  JB: 0.035388, KB: 0.07864, LB: 0.03932, MB: 0.106164, NB: 0.25558, OB: 0.17694, PB: 0.070776, QB: 0.35388, RB: 0.129756, SB: 0.161212, TB: 0.542616,
  UB: 7.16804, I: 7.30566, VB: 0.01966, VC: 7864e-6, KC: 0, WC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "J", "WB", "K", "D", "E", "\
F", "A", "B", "C", "L", "M", "G", "N", "O", "P", "XB", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "YB", "ZB", "aB", "bB", "cB", "dB",
  "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "\
1B", "SC", "2B", "TC", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "Q", "H", "R", "\
S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "\
u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB",
  "TB", "UB", "I", "VB", "VC", "KC", "WC"], E: "Chrome", F: { 0: 1694476800, 1: 1696896e3, 2: 1698710400, 3: 1701993600, 4: 1705968e3, 5: 1708387200,
  6: 133704e4, 7: 1340668800, 8: 1343692800, 9: 1348531200, J: 1264377600, WB: 1274745600, K: 1283385600, D: 1287619200, E: 1291248e3, F: 1296777600,
  A: 1299542400, B: 1303862400, C: 1307404800, L: 1312243200, M: 1316131200, G: 1316131200, N: 1319500800, O: 1323734400, P: 1328659200, XB: 1332892800,
  AB: 1352246400, BB: 1357862400, CB: 1361404800, DB: 1364428800, EB: 1369094400, YB: 1374105600, ZB: 1376956800, aB: 1384214400, bB: 1389657600,
  cB: 1392940800, dB: 1397001600, eB: 1400544e3, fB: 1405468800, gB: 1409011200, hB: 141264e4, iB: 1416268800, jB: 1421798400, kB: 1425513600,
  lB: 1429401600, mB: 143208e4, nB: 1437523200, oB: 1441152e3, pB: 1444780800, qB: 1449014400, rB: 1453248e3, sB: 1456963200, tB: 1460592e3,
  uB: 1464134400, vB: 1469059200, wB: 1472601600, xB: 1476230400, yB: 1480550400, zB: 1485302400, "0B": 1489017600, "1B": 149256e4, SC: 1496707200,
  "2B": 1500940800, TC: 1504569600, "3B": 1508198400, "4B": 1512518400, "5B": 1516752e3, "6B": 1520294400, "7B": 1523923200, "8B": 1527552e3,
  "9B": 1532390400, AC: 1536019200, BC: 1539648e3, CC: 1543968e3, DC: 154872e4, EC: 1552348800, FC: 1555977600, GC: 1559606400, HC: 1564444800,
  IC: 1568073600, JC: 1571702400, Q: 1575936e3, H: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200,
  X: 1611014400, Y: 1614556800, Z: 1618272e3, a: 1621987200, b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800,
  h: 1643673600, i: 1646092800, j: 1648512e3, k: 1650931200, l: 1653350400, m: 1655769600, n: 1659398400, o: 1661817600, p: 1664236800, q: 1666656e3,
  r: 166968e4, s: 1673308800, t: 1675728e3, u: 1678147200, v: 1680566400, w: 1682985600, x: 1685404800, y: 1689724800, z: 1692057600, FB: 1710806400,
  GB: 1713225600, HB: 1715644800, IB: 1718064e3, JB: 1721174400, KB: 1724112e3, LB: 1726531200, MB: 1728950400, NB: 1731369600, OB: 1736812800,
  PB: 1738627200, QB: 1741046400, RB: 1743465600, SB: 1745884800, TB: 1748304e3, UB: 1750723200, I: 1754352e3, VB: 1756771200, VC: null, KC: null,
  WC: null } }, E: { A: { J: 0, WB: 0, K: 0, D: 0, E: 0, F: 0, A: 0, B: 0, C: 0, L: 0, M: 0.011796, G: 0, "0C": 0, XC: 0, "1C": 0, "2C": 0, "\
3C": 0, "4C": 0, YC: 0, LC: 3932e-6, MC: 3932e-6, "5C": 0.027524, "6C": 0.027524, "7C": 0.023592, ZC: 0, aC: 7864e-6, NC: 7864e-6, "8C": 0.106164,
  OC: 0.01966, bC: 0.015728, cC: 0.011796, dC: 0.023592, eC: 7864e-6, fC: 0.015728, "9C": 0.153348, PC: 3932e-6, gC: 0.106164, hC: 0.011796,
  iC: 0.011796, jC: 0.023592, kC: 0.043252, AD: 0.141552, QC: 0.015728, lC: 0.031456, mC: 0.015728, nC: 0.066844, oC: 0.043252, pC: 0.585868,
  qC: 0.01966, rC: 0, BD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "0C", "XC", "J", "WB", "1C", "K", "2C", "D", "3C", "E", "F", "4C", "A", "YC", "B", "LC", "C", "MC", "L", "5C", "M", "6C", "G", "7C", "ZC",
  "aC", "NC", "8C", "OC", "bC", "cC", "dC", "eC", "fC", "9C", "PC", "gC", "hC", "iC", "jC", "kC", "AD", "QC", "lC", "mC", "nC", "oC", "pC", "\
qC", "rC", "BD", ""], E: "Safari", F: { "0C": 1205798400, XC: 1226534400, J: 1244419200, WB: 1275868800, "1C": 131112e4, K: 1343174400, "2C": 13824e5,
  D: 13824e5, "3C": 1410998400, E: 1413417600, F: 1443657600, "4C": 1458518400, A: 1474329600, YC: 1490572800, B: 1505779200, LC: 1522281600,
  C: 1537142400, MC: 1553472e3, L: 1568851200, "5C": 1585008e3, M: 1600214400, "6C": 1619395200, G: 1632096e3, "7C": 1635292800, ZC: 1639353600,
  aC: 1647216e3, NC: 1652745600, "8C": 1658275200, OC: 1662940800, bC: 1666569600, cC: 1670889600, dC: 1674432e3, eC: 1679875200, fC: 1684368e3,
  "9C": 1690156800, PC: 1695686400, gC: 1698192e3, hC: 1702252800, iC: 1705881600, jC: 1709596800, kC: 1715558400, AD: 1722211200, QC: 1726444800,
  lC: 1730073600, mC: 1733875200, nC: 1737936e3, oC: 1743379200, pC: 1747008e3, qC: 1757894400, rC: null, BD: null } }, F: { A: { 0: 0, 1: 0,
  2: 0.011796, 3: 0.636984, 4: 3932e-6, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0, F: 0, B: 0, C: 0, G: 0, N: 0, O: 0, P: 0, XB: 0, AB: 0, BB: 0, CB: 0, DB: 0,
  EB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 7864e-6,
  qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 0, "1B": 0, "2B": 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0,
  "8B": 0, "9B": 0, AC: 0, BC: 0, CC: 0, DC: 0, EC: 0, FC: 0, GC: 0, HC: 0, IC: 0, JC: 0, Q: 0, H: 0, R: 0, UC: 0, S: 0, T: 0, U: 0, V: 0, W: 0,
  X: 0, Y: 0, Z: 0.051116, a: 0.01966, b: 0, c: 0, d: 0, e: 0.027524, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 0,
  r: 0, s: 0, t: 0, u: 0, v: 0, w: 0, x: 0, y: 0, z: 0, CD: 0, DD: 0, ED: 0, FD: 0, LC: 0, sC: 0, GD: 0, MC: 0 }, B: "webkit", C: ["", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "CD", "DD", "ED", "FD", "B", "LC", "s\
C", "GD", "C", "MC", "G", "N", "O", "P", "XB", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "\
fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B",
  "3B", "4B", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "Q", "H", "R", "UC", "S", "T", "U", "\
V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "\
x", "y", "z", "0", "1", "2", "3", "4", "5", "", ""], E: "Opera", F: { 0: 1739404800, 1: 1744675200, 2: 1747094400, 3: 1751414400, 4: 1756339200,
  5: null, 6: 1393891200, 7: 1399334400, 8: 1401753600, 9: 1405987200, F: 1150761600, CD: 1223424e3, DD: 1251763200, ED: 1267488e3, FD: 1277942400,
  B: 1292457600, LC: 1302566400, sC: 1309219200, GD: 1323129600, C: 1323129600, MC: 1352073600, G: 1372723200, N: 1377561600, O: 1381104e3, P: 1386288e3,
  XB: 1390867200, AB: 1409616e3, BB: 1413331200, CB: 1417132800, DB: 1422316800, EB: 1425945600, YB: 1430179200, ZB: 1433808e3, aB: 1438646400,
  bB: 1442448e3, cB: 1445904e3, dB: 1449100800, eB: 1454371200, fB: 1457308800, gB: 146232e4, hB: 1465344e3, iB: 1470096e3, jB: 1474329600, kB: 1477267200,
  lB: 1481587200, mB: 1486425600, nB: 1490054400, oB: 1494374400, pB: 1498003200, qB: 1502236800, rB: 1506470400, sB: 1510099200, tB: 1515024e3,
  uB: 1517961600, vB: 1521676800, wB: 1525910400, xB: 1530144e3, yB: 1534982400, zB: 1537833600, "0B": 1543363200, "1B": 1548201600, "2B": 1554768e3,
  "3B": 1561593600, "4B": 1566259200, "5B": 1570406400, "6B": 1573689600, "7B": 1578441600, "8B": 1583971200, "9B": 1587513600, AC: 1592956800,
  BC: 1595894400, CC: 1600128e3, DC: 1603238400, EC: 161352e4, FC: 1612224e3, GC: 1616544e3, HC: 1619568e3, IC: 1623715200, JC: 1627948800, Q: 1631577600,
  H: 1633392e3, R: 1635984e3, UC: 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3,
  Z: 1660780800, a: 1663113600, b: 1668816e3, c: 1668643200, d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800, i: 1684195200,
  j: 1687219200, k: 1690329600, l: 1692748800, m: 1696204800, n: 169992e4, o: 169992e4, p: 1702944e3, q: 1707264e3, r: 1710115200, s: 1711497600,
  t: 1716336e3, u: 1719273600, v: 1721088e3, w: 1724284800, x: 1727222400, y: 1732665600, z: 1736294400 }, D: { F: "o", B: "o", C: "o", CD: "\
o", DD: "o", ED: "o", FD: "o", LC: "o", sC: "o", GD: "o", MC: "o" } }, G: { A: { E: 0, XC: 0, HD: 0, tC: 24628e-7, ID: 0, JD: 6157e-6, KD: 49256e-7,
  LD: 0, MD: 0, ND: 0.012314, OD: 12314e-7, PD: 0.0221652, QD: 0.472858, RD: 73884e-7, SD: 24628e-7, TD: 0.0714212, UD: 0, VD: 36942e-7, WD: 24628e-7,
  XD: 0.012314, YD: 0.024628, ZD: 0.0258594, aD: 0.0221652, ZC: 0.0197024, aC: 0.0221652, NC: 0.024628, bD: 0.322627, OC: 0.0394048, bC: 0.0812724,
  cC: 0.0418676, dC: 0.0775782, eC: 0.0172396, fC: 0.0320164, cD: 0.416213, PC: 0.0233966, gC: 0.0406362, hC: 0.0295536, iC: 0.0455618, jC: 0.067727,
  kC: 0.147768, dD: 0.364494, QC: 0.092355, lC: 0.187173, mC: 0.104669, nC: 0.357106, oC: 0.205644, pC: 8.76141, qC: 0.0480246, rC: 0 }, B: "\
webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "XC", "HD", "tC", "ID", "J\
D", "KD", "E", "LD", "MD", "ND", "OD", "PD", "QD", "RD", "SD", "TD", "UD", "VD", "WD", "XD", "YD", "ZD", "aD", "ZC", "aC", "NC", "bD", "OC",
  "bC", "cC", "dC", "eC", "fC", "cD", "PC", "gC", "hC", "iC", "jC", "kC", "dD", "QC", "lC", "mC", "nC", "oC", "pC", "qC", "rC", "", ""], E: "\
Safari on iOS", F: { XC: 1270252800, HD: 1283904e3, tC: 1299628800, ID: 1331078400, JD: 1359331200, KD: 1394409600, E: 1410912e3, LD: 1413763200,
  MD: 1442361600, ND: 1458518400, OD: 1473724800, PD: 1490572800, QD: 1505779200, RD: 1522281600, SD: 1537142400, TD: 1553472e3, UD: 1568851200,
  VD: 1572220800, WD: 1580169600, XD: 1585008e3, YD: 1600214400, ZD: 1619395200, aD: 1632096e3, ZC: 1639353600, aC: 1647216e3, NC: 1652659200,
  bD: 1658275200, OC: 1662940800, bC: 1666569600, cC: 1670889600, dC: 1674432e3, eC: 1679875200, fC: 1684368e3, cD: 1690156800, PC: 1694995200,
  gC: 1698192e3, hC: 1702252800, iC: 1705881600, jC: 1709596800, kC: 1715558400, dD: 1722211200, QC: 1726444800, lC: 1730073600, mC: 1733875200,
  nC: 1737936e3, oC: 1743379200, pC: 1747008e3, qC: 1757894400, rC: null } }, H: { A: { eD: 0.05 }, B: "o", C: ["", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "eD", "", "", ""], E: "\
Opera Mini", F: { eD: 1426464e3 } }, I: { A: { RC: 0, J: 0, I: 1.02412, fD: 0, gD: 0, hD: 0, iD: 102566e-9, tC: 205132e-9, jD: 0, kD: 717963e-9 },
  B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "fD", "gD",
  "hD", "RC", "J", "iD", "tC", "jD", "kD", "I", "", "", ""], E: "Android Browser", F: { fD: 1256515200, gD: 1274313600, hD: 1291593600, RC: 1298332800,
  J: 1318896e3, iD: 1341792e3, tC: 1374624e3, jD: 1386547200, kD: 1401667200, I: 1754352e3 } }, J: { A: { D: 0, A: 0 }, B: "webkit", C: ["",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "D", "A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, H: 0.999937, LC: 0, sC: 0,
  MC: 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "A", "B", "LC", "sC", "C", "MC", "H", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, LC: 1314835200, sC: 1318291200,
  C: 1330300800, MC: 1349740800, H: 1709769600 }, D: { H: "webkit" } }, L: { A: { I: 46.0235 }, B: "webkit", C: ["", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "", "", ""], E: "\
Chrome for Android", F: { I: 1754352e3 } }, M: { A: { KC: 0.327726 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "KC", "", "", ""], E: "Firefox for Android", F: { KC: 1755648e3 } },
  N: { A: { A: 0, B: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { NC: 0.819315 },
  B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "NC", "", "", ""], E: "UC Browser for Android", F: { NC: 1710115200 }, D: { NC: "webkit" } }, P: { A: { 6: 0, 7: 0.0108655,
  8: 0.0108655, 9: 0.0217309, J: 0, AB: 0.0217309, BB: 0.0325964, CB: 0.0543273, DB: 0.0760583, EB: 1.77107, lD: 0, mD: 0, nD: 0.0217309, oD: 0,
  pD: 0, YC: 0, qD: 0, rD: 0, sD: 0, tD: 0, uD: 0, OC: 0, PC: 0, QC: 0, vD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "J", "lD", "mD", "nD", "oD", "pD", "YC", "qD", "rD", "sD", "tD", "uD", "OC", "PC", "QC", "vD", "6", "7", "8", "9", "AB", "BB", "CB",
  "DB", "EB", "", "", ""], E: "Samsung Internet", F: { 6: 1677369600, 7: 1684454400, 8: 1689292800, 9: 1697587200, J: 1461024e3, lD: 1481846400,
  mD: 1509408e3, nD: 1528329600, oD: 1546128e3, pD: 1554163200, YC: 1567900800, qD: 1582588800, rD: 1593475200, sD: 1605657600, tD: 1618531200,
  uD: 1629072e3, OC: 1640736e3, PC: 1651708800, QC: 1659657600, vD: 1667260800, AB: 1711497600, BB: 1715126400, CB: 1717718400, DB: 1725667200,
  EB: 1746057600 } }, Q: { A: { wD: 0.176001 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "wD", "", "", ""], E: "QQ Browser", F: { wD: 1710288e3 } }, R: { A: {
  xD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "xD", "", "", ""], E: "Baidu Browser", F: { xD: 1710201600 } }, S: { A: { yD: 0.012138, zD: 0 }, B: "moz",
  C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
  "", "", "yD", "zD", "", "", ""], E: "KaiOS Browser", F: { yD: 1527811200, zD: 1631664e3 } } };
});

// ../node_modules/caniuse-lite/dist/unpacker/agents.js
var z3 = D((s6e, X3) => {
  "use strict";
  var Rfe = Dc().browsers, $m = Um().browserVersions, J3 = H3();
  function G3(e) {
    return Object.keys(e).reduce((t, r) => (t[$m[r]] = e[r], t), {});
  }
  i(G3, "unpackBrowserVersions");
  X3.exports.agents = Object.keys(J3).reduce((e, t) => {
    let r = J3[t];
    return e[Rfe[t]] = Object.keys(r).reduce((s, n) => (n === "A" ? s.usage_global = G3(r[n]) : n === "C" ? s.versions = r[n].reduce((a, o) => (o ===
    "" ? a.push(null) : a.push($m[o]), a), []) : n === "D" ? s.prefix_exceptions = G3(r[n]) : n === "E" ? s.browser = r[n] : n === "F" ? s.release_date =
    Object.keys(r[n]).reduce(
      (a, o) => (a[$m[o]] = r[n][o], a),
      {}
    ) : s.prefix = r[n], s), {}), e;
  }, {});
});

// ../node_modules/electron-to-chromium/versions.js
var Z3 = D((i6e, Q3) => {
  Q3.exports = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "9.4": "83",
    "10.0": "85",
    "10.1": "85",
    "10.2": "85",
    "10.3": "85",
    "10.4": "85",
    "11.0": "87",
    "11.1": "87",
    "11.2": "87",
    "11.3": "87",
    "11.4": "87",
    "11.5": "87",
    "12.0": "89",
    "12.1": "89",
    "12.2": "89",
    "13.0": "91",
    "13.1": "91",
    "13.2": "91",
    "13.3": "91",
    "13.4": "91",
    "13.5": "91",
    "13.6": "91",
    "14.0": "93",
    "14.1": "93",
    "14.2": "93",
    "15.0": "94",
    "15.1": "94",
    "15.2": "94",
    "15.3": "94",
    "15.4": "94",
    "15.5": "94",
    "16.0": "96",
    "16.1": "96",
    "16.2": "96",
    "17.0": "98",
    "17.1": "98",
    "17.2": "98",
    "17.3": "98",
    "17.4": "98",
    "18.0": "100",
    "18.1": "100",
    "18.2": "100",
    "18.3": "100",
    "19.0": "102",
    "19.1": "102",
    "20.0": "104",
    "20.1": "104",
    "20.2": "104",
    "20.3": "104",
    "21.0": "106",
    "21.1": "106",
    "21.2": "106",
    "21.3": "106",
    "21.4": "106",
    "22.0": "108",
    "22.1": "108",
    "22.2": "108",
    "22.3": "108",
    "23.0": "110",
    "23.1": "110",
    "23.2": "110",
    "23.3": "110",
    "24.0": "112",
    "24.1": "112",
    "24.2": "112",
    "24.3": "112",
    "24.4": "112",
    "24.5": "112",
    "24.6": "112",
    "24.7": "112",
    "24.8": "112",
    "25.0": "114",
    "25.1": "114",
    "25.2": "114",
    "25.3": "114",
    "25.4": "114",
    "25.5": "114",
    "25.6": "114",
    "25.7": "114",
    "25.8": "114",
    "25.9": "114",
    "26.0": "116",
    "26.1": "116",
    "26.2": "116",
    "26.3": "116",
    "26.4": "116",
    "26.5": "116",
    "26.6": "116",
    "27.0": "118",
    "27.1": "118",
    "27.2": "118",
    "27.3": "118",
    "28.0": "120",
    "28.1": "120",
    "28.2": "120",
    "28.3": "120",
    "29.0": "122",
    "29.1": "122",
    "29.2": "122",
    "29.3": "122",
    "29.4": "122",
    "30.0": "124",
    "30.1": "124",
    "30.2": "124",
    "30.3": "124",
    "30.4": "124",
    "30.5": "124",
    "31.0": "126",
    "31.1": "126",
    "31.2": "126",
    "31.3": "126",
    "31.4": "126",
    "31.5": "126",
    "31.6": "126",
    "31.7": "126",
    "32.0": "128",
    "32.1": "128",
    "32.2": "128",
    "32.3": "128",
    "33.0": "130",
    "33.1": "130",
    "33.2": "130",
    "33.3": "130",
    "33.4": "130",
    "34.0": "132",
    "34.1": "132",
    "34.2": "132",
    "34.3": "132",
    "34.4": "132",
    "34.5": "132",
    "35.0": "134",
    "35.1": "134",
    "35.2": "134",
    "35.3": "134",
    "35.4": "134",
    "35.5": "134",
    "35.6": "134",
    "35.7": "134",
    "36.0": "136",
    "36.1": "136",
    "36.2": "136",
    "36.3": "136",
    "36.4": "136",
    "36.5": "136",
    "36.6": "136",
    "36.7": "136",
    "36.8": "136",
    "36.9": "136",
    "37.0": "138",
    "37.1": "138",
    "37.2": "138",
    "37.3": "138",
    "37.4": "138",
    "37.5": "138",
    "38.0": "140",
    "38.1": "140",
    "39.0": "141"
  };
});

// ../node_modules/node-releases/data/release-schedule/release-schedule.json
var eC = D((a6e, qfe) => {
  qfe.exports = { "v0.8": { start: "2012-06-25", end: "2014-07-31" }, "v0.10": { start: "2013-03-11", end: "2016-10-31" }, "v0.12": { start: "\
2015-02-06", end: "2016-12-31" }, v4: { start: "2015-09-08", lts: "2015-10-12", maintenance: "2017-04-01", end: "2018-04-30", codename: "Arg\
on" }, v5: { start: "2015-10-29", maintenance: "2016-04-30", end: "2016-06-30" }, v6: { start: "2016-04-26", lts: "2016-10-18", maintenance: "\
2018-04-30", end: "2019-04-30", codename: "Boron" }, v7: { start: "2016-10-25", maintenance: "2017-04-30", end: "2017-06-30" }, v8: { start: "\
2017-05-30", lts: "2017-10-31", maintenance: "2019-01-01", end: "2019-12-31", codename: "Carbon" }, v9: { start: "2017-10-01", maintenance: "\
2018-04-01", end: "2018-06-30" }, v10: { start: "2018-04-24", lts: "2018-10-30", maintenance: "2020-05-19", end: "2021-04-30", codename: "Du\
bnium" }, v11: { start: "2018-10-23", maintenance: "2019-04-22", end: "2019-06-01" }, v12: { start: "2019-04-23", lts: "2019-10-21", maintenance: "\
2020-11-30", end: "2022-04-30", codename: "Erbium" }, v13: { start: "2019-10-22", maintenance: "2020-04-01", end: "2020-06-01" }, v14: { start: "\
2020-04-21", lts: "2020-10-27", maintenance: "2021-10-19", end: "2023-04-30", codename: "Fermium" }, v15: { start: "2020-10-20", maintenance: "\
2021-04-01", end: "2021-06-01" }, v16: { start: "2021-04-20", lts: "2021-10-26", maintenance: "2022-10-18", end: "2023-09-11", codename: "Ga\
llium" }, v17: { start: "2021-10-19", maintenance: "2022-04-01", end: "2022-06-01" }, v18: { start: "2022-04-19", lts: "2022-10-25", maintenance: "\
2023-10-18", end: "2025-04-30", codename: "Hydrogen" }, v19: { start: "2022-10-18", maintenance: "2023-04-01", end: "2023-06-01" }, v20: { start: "\
2023-04-18", lts: "2023-10-24", maintenance: "2024-10-22", end: "2026-04-30", codename: "Iron" }, v21: { start: "2023-10-17", maintenance: "\
2024-04-01", end: "2024-06-01" }, v22: { start: "2024-04-24", lts: "2024-10-29", maintenance: "2025-10-21", end: "2027-04-30", codename: "Jo\
d" }, v23: { start: "2024-10-16", maintenance: "2025-04-01", end: "2025-06-01" }, v24: { start: "2025-05-06", lts: "2025-10-28", maintenance: "\
2026-10-20", end: "2028-04-30", codename: "" }, v25: { start: "2025-10-15", maintenance: "2026-04-01", end: "2026-06-01" }, v26: { start: "2\
026-04-22", lts: "2026-10-28", maintenance: "2027-10-20", end: "2029-04-30", codename: "" } };
});

// ../node_modules/browserslist/error.js
var Km = D((o6e, tC) => {
  function Vm(e) {
    this.name = "BrowserslistError", this.message = e, this.browserslist = !0, Error.captureStackTrace && Error.captureStackTrace(this, Vm);
  }
  i(Vm, "BrowserslistError");
  Vm.prototype = Error.prototype;
  tC.exports = Vm;
});

// ../node_modules/caniuse-lite/dist/lib/statuses.js
var sC = D((u6e, rC) => {
  rC.exports = {
    1: "ls",
    // WHATWG Living Standard
    2: "rec",
    // W3C Recommendation
    3: "pr",
    // W3C Proposed Recommendation
    4: "cr",
    // W3C Candidate Recommendation
    5: "wd",
    // W3C Working Draft
    6: "other",
    // Non-W3C, but reputable
    7: "unoff"
    // Unofficial, Editor's Draft or W3C "Note"
  };
});

// ../node_modules/caniuse-lite/dist/lib/supported.js
var iC = D((c6e, nC) => {
  nC.exports = {
    y: 1,
    n: 2,
    a: 4,
    p: 8,
    u: 16,
    x: 32,
    d: 64
  };
});

// ../node_modules/caniuse-lite/dist/unpacker/feature.js
var lC = D((p6e, Wm) => {
  "use strict";
  var Ufe = sC(), aC = iC(), $fe = Dc().browsers, Vfe = Um().browserVersions, Kfe = Math.log(2);
  function Wfe(e) {
    let t = Object.keys(aC).reduce((n, a) => (e & aC[a] && n.push(a), n), []), r = e >> 7, s = [];
    for (; r; ) {
      let n = Math.floor(Math.log(r) / Kfe) + 1;
      s.unshift(`#${n}`), r -= Math.pow(2, n - 1);
    }
    return t.concat(s).join(" ");
  }
  i(Wfe, "unpackSupport");
  function oC(e) {
    let t = {
      status: Ufe[e.B],
      title: e.C,
      shown: e.D
    };
    return t.stats = Object.keys(e.A).reduce((r, s) => {
      let n = e.A[s];
      return r[$fe[s]] = Object.keys(n).reduce(
        (a, o) => {
          let l = n[o].split(" "), u = Wfe(o);
          return l.forEach((c) => a[Vfe[c]] = u), a;
        },
        {}
      ), r;
    }, {}), t;
  }
  i(oC, "unpackFeature");
  Wm.exports = oC;
  Wm.exports.default = oC;
});

// ../node_modules/caniuse-lite/dist/unpacker/region.js
var cC = D((d6e, Ym) => {
  "use strict";
  var Yfe = Dc().browsers;
  function uC(e) {
    return Object.keys(e).reduce((t, r) => {
      let s = e[r];
      return t[Yfe[r]] = Object.keys(s).reduce((n, a) => {
        let o = s[a];
        return a === "_" ? o.split(" ").forEach((l) => n[l] = null) : n[a] = o, n;
      }, {}), t;
    }, {});
  }
  i(uC, "unpackRegion");
  Ym.exports = uC;
  Ym.exports.default = uC;
});

// ../node_modules/browserslist/node.js
var vC = D((m6e, Fo) => {
  var Hfe = lC().default, Jfe = cC().default, Qi = z("fs"), Yr = z("path"), kt = Km(), pC = /^\s*\[(.+)]\s*$/, Gfe = /^browserslist-config-/,
  Xfe = /@[^/]+(?:\/[^/]+)?\/browserslist-config(?:-|$|\/)/, fC = "Browserslist config should be a string or an array of strings with browse\
r queries", zfe = "unknown", TC = "directory", xC = "file", Hm = !1, dC = {}, hC = {}, _c = {};
  function mC(e) {
    var t = " Use `dangerousExtend` option to disable.";
    if (!Gfe.test(e) && !Xfe.test(e))
      throw new kt(
        "Browserslist config needs `browserslist-config-` prefix. " + t
      );
    if (e.replace(/^@[^/]+\//, "").indexOf(".") !== -1)
      throw new kt(
        "`.` not allowed in Browserslist config name. " + t
      );
    if (e.indexOf("node_modules") !== -1)
      throw new kt(
        "`node_modules` not allowed in Browserslist config." + t
      );
  }
  i(mC, "checkExtend");
  function EC(e) {
    var t;
    try {
      t = Qi.existsSync(e) && Qi.statSync(e);
    } catch (r) {
      if (r.code !== "ENOENT" && r.code !== "EACCES" && r.code !== "ERR_ACCESS_DENIED")
        throw r;
    }
    return t && t.isDirectory() ? TC : t && t.isFile() ? xC : zfe;
  }
  i(EC, "getPathType");
  function Os(e) {
    return EC(e) === xC;
  }
  i(Os, "isFile");
  function Qfe(e) {
    return EC(e) === TC;
  }
  i(Qfe, "isDirectory");
  function yC(e, t, r) {
    var s = Yr.resolve(e), n = [], a;
    do {
      if (!Zfe(s))
        break;
      if (r && s in r) {
        a = r[s];
        break;
      }
      if (n.push(s), !!Qfe(s)) {
        var o = t(s);
        if (typeof o < "u") {
          a = o;
          break;
        }
      }
    } while (s !== (s = Yr.dirname(s)));
    return r && !process.env.BROWSERSLIST_DISABLE_CACHE && n.forEach(function(l) {
      r[l] = a;
    }), a;
  }
  i(yC, "eachParent");
  function Zfe(e) {
    if (!process.env.BROWSERSLIST_ROOT_PATH) return !0;
    var t = Yr.resolve(process.env.BROWSERSLIST_ROOT_PATH);
    return Yr.relative(t, e).substring(0, 2) !== "..";
  }
  i(Zfe, "pathInRoot");
  function ede(e) {
    if (Array.isArray(e)) {
      for (var t = 0; t < e.length; t++)
        if (typeof e[t] != "string")
          throw new kt(fC);
    } else if (typeof e != "string")
      throw new kt(fC);
  }
  i(ede, "check");
  function Jm(e, t) {
    if (typeof e != "object") return e;
    var r;
    if (typeof t.env == "string" ? r = t.env : process.env.BROWSERSLIST_ENV ? r = process.env.BROWSERSLIST_ENV : process.env.NODE_ENV ? r = process.
    env.NODE_ENV : r = "production", t.throwOnMissing && r && r !== "defaults" && !e[r])
      throw new kt(
        "Missing config for Browserslist environment `" + r + "`"
      );
    return e[r] || e.defaults;
  }
  i(Jm, "pickEnv");
  function SC(e) {
    var t = Qi.readFileSync(e).toString().replace(/^\uFEFF/m, ""), r;
    if (t.indexOf('"browserslist"') >= 0)
      r = JSON.parse(t).browserslist;
    else if (t.indexOf('"browserlist"') >= 0) {
      var s = JSON.parse(t);
      if (s.browserlist && !s.browserslist)
        throw new kt(
          "`browserlist` key instead of `browserslist` in " + e
        );
    }
    (Array.isArray(r) || typeof r == "string") && (r = { defaults: r });
    for (var n in r)
      ede(r[n]);
    return r;
  }
  i(SC, "parsePackage");
  function bC(e) {
    if (e in _c)
      return _c[e];
    var t = Yr.basename(e) === "package.json", r = t ? SC(e) : Fo.exports.readConfig(e);
    return process.env.BROWSERSLIST_DISABLE_CACHE || (_c[e] = r), r;
  }
  i(bC, "parsePackageOrReadConfig");
  function tde(e) {
    var t = 0;
    for (var r in e) {
      var s = e[r].releaseDate || {};
      for (var n in s)
        t < s[n] && (t = s[n]);
    }
    return t * 1e3;
  }
  i(tde, "latestReleaseTime");
  function rde(e) {
    var t = /* @__PURE__ */ new Date(), r = new Date(e), s = t.getFullYear() - r.getFullYear(), n = t.getMonth() - r.getMonth();
    return s * 12 + n;
  }
  i(rde, "getMonthsPassed");
  function gC(e, t) {
    if (e || (e = {}), t && "dataByBrowser" in t && (t = t.dataByBrowser), typeof t == "object") {
      var r = {};
      for (var s in t) {
        var n = Object.keys(t[s]);
        if (n.length === 1 && e[s] && e[s].versions.length === 1) {
          var a = e[s].versions[0];
          r[s] = {}, r[s][a] = t[s][n[0]];
        } else
          r[s] = t[s];
      }
      return r;
    }
  }
  i(gC, "normalizeStats");
  function sde(e, t) {
    for (var r in e) {
      var s = e[r];
      if ("0" in s) {
        var n = t[r].versions;
        s[n[n.length - 1]] = s[0], delete s[0];
      }
    }
  }
  i(sde, "normalizeUsageData");
  Fo.exports = {
    loadQueries: /* @__PURE__ */ i(function(t, r) {
      !t.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && mC(r);
      var s = z(z.resolve(r, { paths: [".", t.path] }));
      if (typeof s == "object" && s !== null && s.__esModule && (s = s.default), s) {
        if (Array.isArray(s))
          return s;
        if (typeof s == "object")
          return s.defaults || (s.defaults = []), Jm(s, t, r);
      }
      throw new kt(
        "`" + r + "` config exports not an array of queries or an object of envs"
      );
    }, "loadQueries"),
    loadStat: /* @__PURE__ */ i(function(t, r, s) {
      !t.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND && mC(r);
      var n = z(
        // Use forward slashes for module paths, also on Windows.
        z.resolve(Yr.posix.join(r, "browserslist-stats.json"), {
          paths: ["."]
        })
      );
      return gC(s, n);
    }, "loadStat"),
    getStat: /* @__PURE__ */ i(function(t, r) {
      var s;
      if (t.stats ? s = t.stats : process.env.BROWSERSLIST_STATS ? s = process.env.BROWSERSLIST_STATS : t.path && Yr.resolve && Qi.existsSync &&
      (s = yC(
        t.path,
        function(n) {
          var a = Yr.join(n, "browserslist-stats.json");
          return Os(a) ? a : void 0;
        },
        dC
      )), typeof s == "string")
        try {
          s = JSON.parse(Qi.readFileSync(s));
        } catch {
          throw new kt("Can't read " + s);
        }
      return gC(r, s);
    }, "getStat"),
    loadConfig: /* @__PURE__ */ i(function(t) {
      if (process.env.BROWSERSLIST)
        return process.env.BROWSERSLIST;
      if (t.config || process.env.BROWSERSLIST_CONFIG) {
        var r = t.config || process.env.BROWSERSLIST_CONFIG;
        return Jm(bC(r), t);
      } else return t.path ? Jm(Fo.exports.findConfig(t.path), t) : void 0;
    }, "loadConfig"),
    loadCountry: /* @__PURE__ */ i(function(t, r, s) {
      var n = r.replace(/[^\w-]/g, "");
      if (!t[n]) {
        var a;
        try {
          a = z("caniuse-lite/data/regions/" + n + ".js");
        } catch {
          throw new kt("Unknown region name `" + n + "`.");
        }
        var o = Jfe(a);
        sde(o, s), t[r] = {};
        for (var l in o)
          for (var u in o[l])
            t[r][l + " " + u] = o[l][u];
      }
    }, "loadCountry"),
    loadFeature: /* @__PURE__ */ i(function(t, r) {
      if (r = r.replace(/[^\w-]/g, ""), !t[r]) {
        var s;
        try {
          s = z("caniuse-lite/data/features/" + r + ".js");
        } catch {
          throw new kt("Unknown feature name `" + r + "`.");
        }
        var n = Hfe(s).stats;
        t[r] = {};
        for (var a in n) {
          t[r][a] = {};
          for (var o in n[a])
            t[r][a][o] = n[a][o];
        }
      }
    }, "loadFeature"),
    parseConfig: /* @__PURE__ */ i(function(t) {
      var r = { defaults: [] }, s = ["defaults"];
      return t.toString().replace(/#[^\n]*/g, "").split(/\n|,/).map(function(n) {
        return n.trim();
      }).filter(function(n) {
        return n !== "";
      }).forEach(function(n) {
        pC.test(n) ? (s = n.match(pC)[1].trim().split(" "), s.forEach(function(a) {
          if (r[a])
            throw new kt(
              "Duplicate section " + a + " in Browserslist config"
            );
          r[a] = [];
        })) : s.forEach(function(a) {
          r[a].push(n);
        });
      }), r;
    }, "parseConfig"),
    readConfig: /* @__PURE__ */ i(function(t) {
      if (!Os(t))
        throw new kt("Can't read " + t + " config");
      return Fo.exports.parseConfig(Qi.readFileSync(t));
    }, "readConfig"),
    findConfigFile: /* @__PURE__ */ i(function(t) {
      return yC(
        t,
        function(r) {
          var s = Yr.join(r, "browserslist"), n = Yr.join(r, "package.json"), a = Yr.join(r, ".browserslistrc"), o;
          if (Os(n))
            try {
              o = SC(n);
            } catch (l) {
              if (l.name === "BrowserslistError") throw l;
              console.warn(
                "[Browserslist] Could not parse " + n + ". Ignoring it."
              );
            }
          if (Os(s) && o)
            throw new kt(
              r + " contains both browserslist and package.json with browsers"
            );
          if (Os(a) && o)
            throw new kt(
              r + " contains both .browserslistrc and package.json with browsers"
            );
          if (Os(s) && Os(a))
            throw new kt(
              r + " contains both .browserslistrc and browserslist"
            );
          if (Os(s))
            return s;
          if (Os(a))
            return a;
          if (o)
            return n;
        },
        hC
      );
    }, "findConfigFile"),
    findConfig: /* @__PURE__ */ i(function(t) {
      var r = this.findConfigFile(t);
      return r ? bC(r) : void 0;
    }, "findConfig"),
    clearCaches: /* @__PURE__ */ i(function() {
      Hm = !1, dC = {}, hC = {}, _c = {}, this.cache = {};
    }, "clearCaches"),
    oldDataWarning: /* @__PURE__ */ i(function(t) {
      if (!Hm && (Hm = !0, !process.env.BROWSERSLIST_IGNORE_OLD_DATA)) {
        var r = tde(t), s = rde(r);
        if (r !== 0 && s >= 6) {
          var n = s + " " + (s > 1 ? "months" : "month");
          console.warn(
            "Browserslist: browsers data (caniuse-lite) is " + n + ` old. Please run:
  npx update-browserslist-db@latest
  Why you should do it regularly: https://github.com/browserslist/update-db#readme`
          );
        }
      }
    }, "oldDataWarning"),
    currentNode: /* @__PURE__ */ i(function() {
      return "node " + process.versions.node;
    }, "currentNode"),
    env: process.env
  };
});

// ../node_modules/browserslist/parse.js
var DC = D((b6e, wC) => {
  var PC = /^\s+and\s+(.*)/i, AC = /^(?:,\s*|\s+or\s+)(.*)/i;
  function CC(e) {
    return Array.isArray(e) ? e.reduce(function(t, r) {
      return t.concat(CC(r));
    }, []) : [e];
  }
  i(CC, "flatten");
  function nde(e, t) {
    for (var r = e.length, s = 1; s <= r; s++) {
      var n = e.substr(-s, s);
      if (t(n, s, r))
        return e.slice(0, -s);
    }
    return "";
  }
  i(nde, "find");
  function Gm(e, t) {
    var r = { query: t };
    t.indexOf("not ") === 0 && (r.not = !0, t = t.slice(4));
    for (var s in e) {
      var n = e[s], a = t.match(n.regexp);
      if (a) {
        r.type = s;
        for (var o = 0; o < n.matches.length; o++)
          r[n.matches[o]] = a[o + 1];
        return r;
      }
    }
    return r.type = "unknown", r;
  }
  i(Gm, "matchQuery");
  function ide(e, t, r) {
    var s;
    return nde(t, function(n, a, o) {
      return PC.test(n) ? (s = Gm(e, n.match(PC)[1]), s.compose = "and", r.unshift(s), !0) : AC.test(n) ? (s = Gm(e, n.match(AC)[1]), s.compose =
      "or", r.unshift(s), !0) : a === o ? (s = Gm(e, n.trim()), s.compose = "or", r.unshift(s), !0) : !1;
    });
  }
  i(ide, "matchBlock");
  wC.exports = /* @__PURE__ */ i(function(t, r) {
    return Array.isArray(r) || (r = [r]), CC(
      r.map(function(s) {
        var n = [];
        do
          s = ide(t, s, n);
        while (s);
        return n;
      })
    );
  }, "parse");
});

// ../node_modules/browserslist/index.js
var WC = D((T6e, KC) => {
  var Ic = M3(), ade = R3(), Ns = z3().agents, Hr = Z3(), Xm = eC(), Lc = z("path"), Xt = Km(), yt = vC(), ode = DC(), lde = 365.259641 * 24 *
  60 * 60 * 1e3, LC = "37", ude = 14;
  function jC(e, t) {
    return (e + ".").indexOf(t + ".") === 0;
  }
  i(jC, "isVersionsMatch");
  function cde(e) {
    var t = e.slice(1);
    return ne.nodeVersions.some(function(r) {
      return jC(r, t);
    });
  }
  i(cde, "isEolReleased");
  function _C(e) {
    return e.filter(function(t) {
      return typeof t == "string";
    });
  }
  i(_C, "normalize");
  function Oc(e) {
    var t = e;
    return e.split(".").length === 3 && (t = e.split(".").slice(0, -1).join(".")), t;
  }
  i(Oc, "normalizeElectron");
  function pn(e) {
    return /* @__PURE__ */ i(function(r) {
      return e + " " + r;
    }, "mapName");
  }
  i(pn, "nameMapper");
  function ry(e) {
    return parseInt(e.split(".")[0]);
  }
  i(ry, "getMajor");
  function Nc(e, t) {
    if (e.length === 0) return [];
    var r = MC(e.map(ry)), s = r[r.length - t];
    if (!s)
      return e;
    for (var n = [], a = e.length - 1; a >= 0 && !(s > ry(e[a])); a--)
      n.unshift(e[a]);
    return n;
  }
  i(Nc, "getMajorVersions");
  function MC(e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.indexOf(e[r]) === -1 && t.push(e[r]);
    return t;
  }
  i(MC, "uniq");
  function jc(e, t, r) {
    for (var s in r)
      e[t + " " + s] = r[s];
  }
  i(jc, "fillUsage");
  function IC(e, t) {
    if (t = parseFloat(t), e === ">")
      return function(s) {
        return r(s) > t;
      };
    return e === ">=" ? function(s) {
      return r(s) >= t;
    } : e === "<" ? function(s) {
      return parseFloat(s) < t;
    } : function(s) {
      return parseFloat(s) <= t;
    };
    function r(s) {
      return parseFloat(s.split("-")[1] || s);
    }
  }
  i(IC, "generateFilter");
  function pde(e, t) {
    return t = t.split(".").map(fn), t[1] = t[1] || 0, t[2] = t[2] || 0, e === ">" ? function(r) {
      return r = r.split(".").map(fn), Lo(r, t) > 0;
    } : e === ">=" ? function(r) {
      return r = r.split(".").map(fn), Lo(r, t) >= 0;
    } : e === "<" ? function(r) {
      return r = r.split(".").map(fn), Lo(t, r) > 0;
    } : function(r) {
      return r = r.split(".").map(fn), Lo(t, r) >= 0;
    };
  }
  i(pde, "generateSemverFilter");
  function fn(e) {
    return parseInt(e);
  }
  i(fn, "parseSimpleInt");
  function Fc(e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
  }
  i(Fc, "compare");
  function Lo(e, t) {
    return Fc(parseInt(e[0]), parseInt(t[0])) || Fc(parseInt(e[1] || "0"), parseInt(t[1] || "0")) || Fc(parseInt(e[2] || "0"), parseInt(t[2] ||
    "0"));
  }
  i(Lo, "compareSemver");
  function OC(e, t) {
    switch (t = t.split(".").map(fn), typeof t[1] > "u" && (t[1] = "x"), e) {
      case "<=":
        return function(r) {
          return r = r.split(".").map(fn), NC(r, t) <= 0;
        };
      case ">=":
      default:
        return function(r) {
          return r = r.split(".").map(fn), NC(r, t) >= 0;
        };
    }
  }
  i(OC, "semverFilterLoose");
  function NC(e, t) {
    return e[0] !== t[0] ? e[0] < t[0] ? -1 : 1 : t[1] === "x" ? 0 : e[1] !== t[1] ? e[1] < t[1] ? -1 : 1 : 0;
  }
  i(NC, "compareSemverLoose");
  function fde(e, t) {
    return e.versions.indexOf(t) !== -1 ? t : ne.versionAliases[e.name][t] ? ne.versionAliases[e.name][t] : !1;
  }
  i(fde, "resolveVersion");
  function Bc(e, t) {
    var r = fde(e, t);
    return r || (e.versions.length === 1 ? e.versions[0] : !1);
  }
  i(Bc, "normalizeVersion");
  function RC(e, t) {
    return e = e / 1e3, Object.keys(Ns).reduce(function(r, s) {
      var n = dn(s, t);
      if (!n) return r;
      var a = Object.keys(n.releaseDate).filter(function(o) {
        var l = n.releaseDate[o];
        return l !== null && l >= e;
      });
      return r.concat(a.map(pn(n.name)));
    }, []);
  }
  i(RC, "filterByYear");
  function BC(e) {
    return {
      name: e.name,
      versions: e.versions,
      released: e.released,
      releaseDate: e.releaseDate
    };
  }
  i(BC, "cloneData");
  function dn(e, t) {
    if (e = e.toLowerCase(), e = ne.aliases[e] || e, t.mobileToDesktop && ne.desktopNames[e]) {
      var r = ne.data[ne.desktopNames[e]];
      if (e === "android")
        return hde(BC(ne.data[e]), r);
      var s = BC(r);
      return s.name = e, s;
    }
    return ne.data[e];
  }
  i(dn, "byName");
  function kC(e, t) {
    var r = t.indexOf(LC);
    return e.filter(function(s) {
      return /^(?:[2-4]\.|[34]$)/.test(s);
    }).concat(t.slice(r));
  }
  i(kC, "normalizeAndroidVersions");
  function dde(e) {
    var t = {};
    for (var r in e)
      t[r] = e[r];
    return t;
  }
  i(dde, "copyObject");
  function hde(e, t) {
    return e.released = kC(e.released, t.released), e.versions = kC(e.versions, t.versions), e.releaseDate = dde(e.releaseDate), e.released.
    forEach(function(r) {
      e.releaseDate[r] === void 0 && (e.releaseDate[r] = t.releaseDate[r]);
    }), e;
  }
  i(hde, "normalizeAndroidData");
  function Zi(e, t) {
    var r = dn(e, t);
    if (!r) throw new Xt("Unknown browser " + e);
    return r;
  }
  i(Zi, "checkName");
  function mde(e) {
    return new Xt(
      "Unknown browser query `" + e + "`. Maybe you are using old Browserslist or made typo in query."
    );
  }
  i(mde, "unknownQuery");
  function kc(e, t, r, s) {
    var n = 1;
    switch (t) {
      case "android":
        if (s.mobileToDesktop) return e;
        var a = ne.data.chrome.released;
        n = a.length - a.indexOf(LC);
        break;
      case "op_mob":
        var o = ne.data.op_mob.released.slice(-1)[0];
        n = ry(o) - ude + 1;
        break;
      default:
        return e;
    }
    return r <= n ? e.slice(-1) : e.slice(n - 1 - r);
  }
  i(kc, "filterJumps");
  function FC(e, t) {
    return typeof e == "string" && (e.indexOf("y") >= 0 || t && e.indexOf("a") >= 0);
  }
  i(FC, "isSupported");
  function si(e, t) {
    return sy(e).reduce(function(r, s, n) {
      if (s.not && n === 0)
        throw new Xt(
          "Write any browsers query (for instance, `defaults`) before `" + s.query + "`"
        );
      var a = ny[s.type], o = a.select.call(ne, t, s).map(function(u) {
        var c = u.split(" ");
        return c[1] === "0" ? c[0] + " " + dn(c[0], t).versions[0] : u;
      });
      if (s.compose === "and")
        return s.not ? r.filter(function(u) {
          return o.indexOf(u) === -1;
        }) : r.filter(function(u) {
          return o.indexOf(u) !== -1;
        });
      if (s.not) {
        var l = {};
        return o.forEach(function(u) {
          l[u] = !0;
        }), r.filter(function(u) {
          return !l[u];
        });
      }
      return r.concat(o);
    }, []);
  }
  i(si, "resolve");
  function qC(e) {
    return typeof e > "u" && (e = {}), typeof e.path > "u" && (e.path = Lc.resolve ? Lc.resolve(".") : "."), e;
  }
  i(qC, "prepareOpts");
  function UC(e, t) {
    if (typeof e > "u" || e === null) {
      var r = ne.loadConfig(t);
      r ? e = r : e = ne.defaults;
    }
    return e;
  }
  i(UC, "prepareQueries");
  function $C(e) {
    if (!(typeof e == "string" || Array.isArray(e)))
      throw new Xt(
        "Browser queries must be an array or string. Got " + typeof e + "."
      );
  }
  i($C, "checkQueries");
  var zm = {}, Qm = {};
  function ne(e, t) {
    t = qC(t), e = UC(e, t), $C(e);
    var r = sy(e).some(function(u) {
      return ny[u.type].needsPath;
    }), s = {
      ignoreUnknownVersions: t.ignoreUnknownVersions,
      dangerousExtend: t.dangerousExtend,
      mobileToDesktop: t.mobileToDesktop,
      env: t.env
    };
    r && (s.path = t.path), yt.oldDataWarning(ne.data);
    var n = yt.getStat(t, ne.data);
    if (n) {
      s.customUsage = {};
      for (var a in n)
        jc(s.customUsage, a, n[a]);
    }
    var o = JSON.stringify([e, s]);
    if (zm[o]) return zm[o];
    var l = MC(si(e, s)).sort(function(u, c) {
      if (u = u.split(" "), c = c.split(" "), u[0] === c[0]) {
        var p = u[1].split("-")[0], f = c[1].split("-")[0];
        return Lo(f.split("."), p.split("."));
      } else
        return Fc(u[0], c[0]);
    });
    return yt.env.BROWSERSLIST_DISABLE_CACHE || (zm[o] = l), l;
  }
  i(ne, "browserslist");
  function sy(e) {
    var t = JSON.stringify(e);
    if (t in Qm) return Qm[t];
    var r = ode(ny, e);
    return yt.env.BROWSERSLIST_DISABLE_CACHE || (Qm[t] = r), r;
  }
  i(sy, "parseQueries");
  function VC(e, t) {
    var r = yt.loadStat(e, t, ne.data);
    if (r) {
      e.customUsage = {};
      for (var s in r)
        jc(e.customUsage, s, r[s]);
    }
    if (!e.customUsage)
      throw new Xt("Custom usage statistics was not provided");
    return e.customUsage;
  }
  i(VC, "loadCustomUsage");
  ne.parse = function(e, t) {
    return t = qC(t), e = UC(e, t), $C(e), sy(e);
  };
  ne.cache = {};
  ne.data = {};
  ne.usage = {
    global: {},
    custom: null
  };
  ne.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
  ne.aliases = {
    fx: "firefox",
    ff: "firefox",
    ios: "ios_saf",
    explorer: "ie",
    blackberry: "bb",
    explorermobile: "ie_mob",
    operamini: "op_mini",
    operamobile: "op_mob",
    chromeandroid: "and_chr",
    firefoxandroid: "and_ff",
    ucandroid: "and_uc",
    qqandroid: "and_qq"
  };
  ne.desktopNames = {
    and_chr: "chrome",
    and_ff: "firefox",
    ie_mob: "ie",
    android: "chrome"
    // has extra processing logic
  };
  ne.versionAliases = {};
  ne.clearCaches = yt.clearCaches;
  ne.parseConfig = yt.parseConfig;
  ne.readConfig = yt.readConfig;
  ne.findConfigFile = yt.findConfigFile;
  ne.findConfig = yt.findConfig;
  ne.loadConfig = yt.loadConfig;
  ne.coverage = function(e, t) {
    var r;
    if (typeof t > "u")
      r = ne.usage.global;
    else if (t === "my stats") {
      var s = {};
      s.path = Lc.resolve ? Lc.resolve(".") : ".";
      var n = yt.getStat(s);
      if (!n)
        throw new Xt("Custom usage statistics was not provided");
      r = {};
      for (var a in n)
        jc(r, a, n[a]);
    } else if (typeof t == "string")
      t.length > 2 ? t = t.toLowerCase() : t = t.toUpperCase(), yt.loadCountry(ne.usage, t, ne.data), r = ne.usage[t];
    else {
      "dataByBrowser" in t && (t = t.dataByBrowser), r = {};
      for (var o in t)
        for (var l in t[o])
          r[o + " " + l] = t[o][l];
    }
    return e.reduce(function(u, c) {
      var p = r[c];
      return p === void 0 && (p = r[c.replace(/ \S+$/, " 0")]), u + (p || 0);
    }, 0);
  };
  function Zm(e, t) {
    var r = ne.nodeVersions.filter(function(s) {
      return jC(s, t.version);
    });
    if (r.length === 0) {
      if (e.ignoreUnknownVersions)
        return [];
      throw new Xt(
        "Unknown version " + t.version + " of Node.js"
      );
    }
    return ["node " + r[r.length - 1]];
  }
  i(Zm, "nodeQuery");
  function ey(e, t) {
    var r = parseInt(t.year), s = parseInt(t.month || "01") - 1, n = parseInt(t.day || "01");
    return RC(Date.UTC(r, s, n, 0, 0, 0), e);
  }
  i(ey, "sinceQuery");
  function yde(e) {
    var t = {
      chrome: "chrome",
      chrome_android: "and_chr",
      edge: "edge",
      firefox: "firefox",
      firefox_android: "and_ff",
      safari: "safari",
      safari_ios: "ios_saf",
      webview_android: "android",
      samsunginternet_android: "samsung",
      opera_android: "op_mob",
      opera: "opera",
      qq_android: "and_qq",
      uc_android: "and_uc",
      kai_os: "kaios"
    };
    return e.filter(function(r) {
      return Object.keys(t).indexOf(r.browser) !== -1;
    }).map(function(r) {
      return t[r.browser] + " >= " + r.version;
    });
  }
  i(yde, "bbmTransform");
  function ty(e, t) {
    var r = parseFloat(t.coverage), s = ne.usage.global;
    if (t.place)
      if (t.place.match(/^my\s+stats$/i)) {
        if (!e.customUsage)
          throw new Xt("Custom usage statistics was not provided");
        s = e.customUsage;
      } else {
        var n;
        t.place.length === 2 ? n = t.place.toUpperCase() : n = t.place.toLowerCase(), yt.loadCountry(ne.usage, n, ne.data), s = ne.usage[n];
      }
    else t.config && (s = VC(e, t.config));
    for (var a = Object.keys(s).sort(function(p, f) {
      return s[f] - s[p];
    }), o = 0, l = [], u, c = 0; c < a.length && (u = a[c], !(s[u] === 0 || (o += s[u], l.push(u), o >= r))); c++)
      ;
    return l;
  }
  i(ty, "coverQuery");
  var ny = {
    last_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return Object.keys(Ns).reduce(function(r, s) {
          var n = dn(s, e);
          if (!n) return r;
          var a = Nc(n.released, t.versions);
          return a = a.map(pn(n.name)), a = kc(a, n.name, t.versions, e), r.concat(a);
        }, []);
      }, "select")
    },
    last_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return Object.keys(Ns).reduce(function(r, s) {
          var n = dn(s, e);
          if (!n) return r;
          var a = n.released.slice(-t.versions);
          return a = a.map(pn(n.name)), a = kc(a, n.name, t.versions, e), r.concat(a);
        }, []);
      }, "select")
    },
    last_electron_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Nc(Object.keys(Hr), t.versions);
        return r.map(function(s) {
          return "chrome " + Hr[s];
        });
      }, "select")
    },
    last_node_major_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return Nc(ne.nodeVersions, t.versions).map(
          function(r) {
            return "node " + r;
          }
        );
      }, "select")
    },
    last_browser_major_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Zi(t.browser, e), s = Nc(r.released, t.versions), n = s.map(pn(r.name));
        return n = kc(n, r.name, t.versions, e), n;
      }, "select")
    },
    last_electron_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return Object.keys(Hr).slice(-t.versions).map(function(r) {
          return "chrome " + Hr[r];
        });
      }, "select")
    },
    last_node_versions: {
      matches: ["versions"],
      regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return ne.nodeVersions.slice(-t.versions).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    last_browser_versions: {
      matches: ["versions", "browser"],
      regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Zi(t.browser, e), s = r.released.slice(-t.versions).map(pn(r.name));
        return s = kc(s, r.name, t.versions, e), s;
      }, "select")
    },
    unreleased_versions: {
      matches: [],
      regexp: /^unreleased\s+versions$/i,
      select: /* @__PURE__ */ i(function(e) {
        return Object.keys(Ns).reduce(function(t, r) {
          var s = dn(r, e);
          if (!s) return t;
          var n = s.versions.filter(function(a) {
            return s.released.indexOf(a) === -1;
          });
          return n = n.map(pn(s.name)), t.concat(n);
        }, []);
      }, "select")
    },
    unreleased_electron_versions: {
      matches: [],
      regexp: /^unreleased\s+electron\s+versions?$/i,
      select: /* @__PURE__ */ i(function() {
        return [];
      }, "select")
    },
    unreleased_browser_versions: {
      matches: ["browser"],
      regexp: /^unreleased\s+(\w+)\s+versions?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Zi(t.browser, e);
        return r.versions.filter(function(s) {
          return r.released.indexOf(s) === -1;
        }).map(pn(r.name));
      }, "select")
    },
    last_years: {
      matches: ["years"],
      regexp: /^last\s+((\d+\.)?\d+)\s+years?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return RC(Date.now() - lde * t.years, e);
      }, "select")
    },
    since_y: {
      matches: ["year"],
      regexp: /^since (\d+)$/i,
      select: ey
    },
    since_y_m: {
      matches: ["year", "month"],
      regexp: /^since (\d+)-(\d+)$/i,
      select: ey
    },
    since_y_m_d: {
      matches: ["year", "month", "day"],
      regexp: /^since (\d+)-(\d+)-(\d+)$/i,
      select: ey
    },
    baseline: {
      matches: ["year", "availability", "date", "downstream", "kaios"],
      // Matches:
      //   baseline 2024
      //   baseline newly available
      //   baseline widely available
      //   baseline widely available on 2024-06-01
      //   ...with downstream
      //   ...including kaios
      regexp: /^baseline\s+(?:(\d+)|(newly|widely)\s+available(?:\s+on\s+(\d{4}-\d{2}-\d{2}))?)?(\s+with\s+downstream)?(\s+including\s+kaios)?$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r, s = !!t.downstream, n = !!t.kaios;
        if (t.availability === "newly" && t.date)
          throw new Xt(
            'Using newly available with a date is not supported, please use "widely available on YYYY-MM-DD" and add 30 months to the date y\
ou specified.'
          );
        if (t.year)
          r = Ic.getCompatibleVersions({
            targetYear: t.year,
            includeDownstreamBrowsers: s,
            includeKaiOS: n
          });
        else if (t.date)
          r = Ic.getCompatibleVersions({
            widelyAvailableOnDate: t.date,
            includeDownstreamBrowsers: s,
            includeKaiOS: n
          });
        else if (t.availability === "newly") {
          var a = (/* @__PURE__ */ new Date()).setMonth((/* @__PURE__ */ new Date()).getMonth() + 30);
          r = Ic.getCompatibleVersions({
            widelyAvailableOnDate: a,
            includeDownstreamBrowsers: s,
            includeKaiOS: n
          });
        } else
          r = Ic.getCompatibleVersions({
            includeDownstreamBrowsers: s,
            includeKaiOS: n
          });
        return si(yde(r), e);
      }, "select")
    },
    popularity: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = parseFloat(t.popularity), s = ne.usage.global;
        return Object.keys(s).reduce(function(n, a) {
          return t.sign === ">" ? s[a] > r && n.push(a) : t.sign === "<" ? s[a] < r && n.push(a) : t.sign === "<=" ? s[a] <= r && n.push(a) :
          s[a] >= r && n.push(a), n;
        }, []);
      }, "select")
    },
    popularity_in_my_stats: {
      matches: ["sign", "popularity"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = parseFloat(t.popularity);
        if (!e.customUsage)
          throw new Xt("Custom usage statistics was not provided");
        var s = e.customUsage;
        return Object.keys(s).reduce(function(n, a) {
          var o = s[a];
          return o == null || (t.sign === ">" ? o > r && n.push(a) : t.sign === "<" ? o < r && n.push(a) : t.sign === "<=" ? o <= r && n.push(
          a) : o >= r && n.push(a)), n;
        }, []);
      }, "select")
    },
    popularity_in_config_stats: {
      matches: ["sign", "popularity", "config"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = parseFloat(t.popularity), s = VC(e, t.config);
        return Object.keys(s).reduce(function(n, a) {
          var o = s[a];
          return o == null || (t.sign === ">" ? o > r && n.push(a) : t.sign === "<" ? o < r && n.push(a) : t.sign === "<=" ? o <= r && n.push(
          a) : o >= r && n.push(a)), n;
        }, []);
      }, "select")
    },
    popularity_in_place: {
      matches: ["sign", "popularity", "place"],
      regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = parseFloat(t.popularity), s = t.place;
        s.length === 2 ? s = s.toUpperCase() : s = s.toLowerCase(), yt.loadCountry(ne.usage, s, ne.data);
        var n = ne.usage[s];
        return Object.keys(n).reduce(function(a, o) {
          var l = n[o];
          return l == null || (t.sign === ">" ? l > r && a.push(o) : t.sign === "<" ? l < r && a.push(o) : t.sign === "<=" ? l <= r && a.push(
          o) : l >= r && a.push(o)), a;
        }, []);
      }, "select")
    },
    cover: {
      matches: ["coverage"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
      select: ty
    },
    cover_in: {
      matches: ["coverage", "place"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
      select: ty
    },
    cover_config: {
      matches: ["coverage", "config"],
      regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/i,
      select: ty
    },
    supports: {
      matches: ["supportType", "feature"],
      regexp: /^(?:(fully|partially)\s+)?supports\s+([\w-]+)$/,
      select: /* @__PURE__ */ i(function(e, t) {
        yt.loadFeature(ne.cache, t.feature);
        var r = t.supportType !== "fully", s = ne.cache[t.feature], n = [];
        for (var a in s) {
          for (var o = dn(a, e), l = o.released.length - 1; l >= 0 && !(o.released[l] in s[a]); )
            l--;
          var u = e.mobileToDesktop && a in ne.desktopNames && FC(s[a][o.released[l]], r);
          o.versions.forEach(function(c) {
            var p = s[a][c];
            p === void 0 && u && (p = s[ne.desktopNames[a]][c]), FC(p, r) && n.push(a + " " + c);
          });
        }
        return n;
      }, "select")
    },
    electron_range: {
      matches: ["from", "to"],
      regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Oc(t.from), s = Oc(t.to), n = parseFloat(t.from), a = parseFloat(t.to);
        if (!Hr[r])
          throw new Xt("Unknown version " + n + " of electron");
        if (!Hr[s])
          throw new Xt("Unknown version " + a + " of electron");
        return Object.keys(Hr).filter(function(o) {
          var l = parseFloat(o);
          return l >= n && l <= a;
        }).map(function(o) {
          return "chrome " + Hr[o];
        });
      }, "select")
    },
    node_range: {
      matches: ["from", "to"],
      regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return ne.nodeVersions.filter(OC(">=", t.from)).filter(OC("<=", t.to)).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    browser_range: {
      matches: ["browser", "from", "to"],
      regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Zi(t.browser, e), s = parseFloat(Bc(r, t.from) || t.from), n = parseFloat(Bc(r, t.to) || t.to);
        function a(o) {
          var l = parseFloat(o);
          return l >= s && l <= n;
        }
        return i(a, "filter"), r.released.filter(a).map(pn(r.name));
      }, "select")
    },
    electron_ray: {
      matches: ["sign", "version"],
      regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Oc(t.version);
        return Object.keys(Hr).filter(IC(t.sign, r)).map(function(s) {
          return "chrome " + Hr[s];
        });
      }, "select")
    },
    node_ray: {
      matches: ["sign", "version"],
      regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        return ne.nodeVersions.filter(pde(t.sign, t.version)).map(function(r) {
          return "node " + r;
        });
      }, "select")
    },
    browser_ray: {
      matches: ["browser", "sign", "version"],
      regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = t.version, s = Zi(t.browser, e), n = ne.versionAliases[s.name][r];
        return n && (r = n), s.released.filter(IC(t.sign, r)).map(function(a) {
          return s.name + " " + a;
        });
      }, "select")
    },
    firefox_esr: {
      matches: [],
      regexp: /^(firefox|ff|fx)\s+esr$/i,
      select: /* @__PURE__ */ i(function() {
        return ["firefox 140"];
      }, "select")
    },
    opera_mini_all: {
      matches: [],
      regexp: /(operamini|op_mini)\s+all/i,
      select: /* @__PURE__ */ i(function() {
        return ["op_mini all"];
      }, "select")
    },
    electron_version: {
      matches: ["version"],
      regexp: /^electron\s+([\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = Oc(t.version), s = Hr[r];
        if (!s)
          throw new Xt(
            "Unknown version " + t.version + " of electron"
          );
        return ["chrome " + s];
      }, "select")
    },
    node_major_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+)$/i,
      select: Zm
    },
    node_minor_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+)$/i,
      select: Zm
    },
    node_patch_version: {
      matches: ["version"],
      regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
      select: Zm
    },
    current_node: {
      matches: [],
      regexp: /^current\s+node$/i,
      select: /* @__PURE__ */ i(function(e) {
        return [yt.currentNode(si, e)];
      }, "select")
    },
    maintained_node: {
      matches: [],
      regexp: /^maintained\s+node\s+versions$/i,
      select: /* @__PURE__ */ i(function(e) {
        var t = Date.now(), r = Object.keys(Xm).filter(function(s) {
          return t < Date.parse(Xm[s].end) && t > Date.parse(Xm[s].start) && cde(s);
        }).map(function(s) {
          return "node " + s.slice(1);
        });
        return si(r, e);
      }, "select")
    },
    phantomjs_1_9: {
      matches: [],
      regexp: /^phantomjs\s+1.9$/i,
      select: /* @__PURE__ */ i(function() {
        return ["safari 5"];
      }, "select")
    },
    phantomjs_2_1: {
      matches: [],
      regexp: /^phantomjs\s+2.1$/i,
      select: /* @__PURE__ */ i(function() {
        return ["safari 6"];
      }, "select")
    },
    browser_version: {
      matches: ["browser", "version"],
      regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        var r = t.version;
        /^tp$/i.test(r) && (r = "TP");
        var s = Zi(t.browser, e), n = Bc(s, r);
        if (n)
          r = n;
        else if (r.indexOf(".") === -1 ? n = r + ".0" : n = r.replace(/\.0$/, ""), n = Bc(s, n), n)
          r = n;
        else {
          if (e.ignoreUnknownVersions)
            return [];
          throw new Xt(
            "Unknown version " + r + " of " + t.browser
          );
        }
        return [s.name + " " + r];
      }, "select")
    },
    browserslist_config: {
      matches: [],
      regexp: /^browserslist config$/i,
      needsPath: !0,
      select: /* @__PURE__ */ i(function(e) {
        return ne(void 0, e);
      }, "select")
    },
    extends: {
      matches: ["config"],
      regexp: /^extends (.+)$/i,
      needsPath: !0,
      select: /* @__PURE__ */ i(function(e, t) {
        return si(yt.loadQueries(e, t.config), e);
      }, "select")
    },
    defaults: {
      matches: [],
      regexp: /^defaults$/i,
      select: /* @__PURE__ */ i(function(e) {
        return si(ne.defaults, e);
      }, "select")
    },
    dead: {
      matches: [],
      regexp: /^dead$/i,
      select: /* @__PURE__ */ i(function(e) {
        var t = [
          "Baidu >= 0",
          "ie <= 11",
          "ie_mob <= 11",
          "bb <= 10",
          "op_mob <= 12.1",
          "samsung 4"
        ];
        return si(t, e);
      }, "select")
    },
    unknown: {
      matches: [],
      regexp: /^(\w+)$/i,
      select: /* @__PURE__ */ i(function(e, t) {
        throw dn(t.query, e) ? new Xt(
          "Specify versions in Browserslist query for browser " + t.query
        ) : mde(t.query);
      }, "select")
    }
  };
  (function() {
    for (var e in Ns) {
      var t = Ns[e];
      ne.data[e] = {
        name: e,
        versions: _C(Ns[e].versions),
        released: _C(Ns[e].versions.slice(0, -3)),
        releaseDate: Ns[e].release_date
      }, jc(ne.usage.global, e, t.usage_global), ne.versionAliases[e] = {};
      for (var r = 0; r < t.versions.length; r++) {
        var s = t.versions[r];
        if (s && s.indexOf("-") !== -1)
          for (var n = s.split("-"), a = 0; a < n.length; a++)
            ne.versionAliases[e][n[a]] = s;
      }
    }
    ne.nodeVersions = ade.map(function(o) {
      return o.version;
    });
  })();
  KC.exports = ne;
});

// ../node_modules/@babel/helper-validator-option/lib/find-suggestion.js
var ay = D((iy) => {
  "use strict";
  Object.defineProperty(iy, "__esModule", {
    value: !0
  });
  iy.findSuggestion = gde;
  var {
    min: YC
  } = Math;
  function bde(e, t) {
    let r = [], s = [], n, a, o = e.length, l = t.length;
    if (!o)
      return l;
    if (!l)
      return o;
    for (a = 0; a <= l; a++)
      r[a] = a;
    for (n = 1; n <= o; n++) {
      for (s = [n], a = 1; a <= l; a++)
        s[a] = e[n - 1] === t[a - 1] ? r[a - 1] : YC(r[a - 1], r[a], s[a - 1]) + 1;
      r = s;
    }
    return s[l];
  }
  i(bde, "levenshtein");
  function gde(e, t) {
    let r = t.map((s) => bde(s, e));
    return t[r.indexOf(YC(...r))];
  }
  i(gde, "findSuggestion");
});

// ../node_modules/@babel/helper-validator-option/lib/validator.js
var HC = D((Mc) => {
  "use strict";
  Object.defineProperty(Mc, "__esModule", {
    value: !0
  });
  Mc.OptionValidator = void 0;
  var Tde = ay(), oy = class {
    static {
      i(this, "OptionValidator");
    }
    constructor(t) {
      this.descriptor = t;
    }
    validateTopLevelOptions(t, r) {
      let s = Object.keys(r);
      for (let n of Object.keys(t))
        if (!s.includes(n))
          throw new Error(this.formatMessage(`'${n}' is not a valid top-level option.
- Did you mean '${(0, Tde.findSuggestion)(n, s)}'?`));
    }
    validateBooleanOption(t, r, s) {
      return r === void 0 ? s : (this.invariant(typeof r == "boolean", `'${t}' option must be a boolean.`), r);
    }
    validateStringOption(t, r, s) {
      return r === void 0 ? s : (this.invariant(typeof r == "string", `'${t}' option must be a string.`), r);
    }
    invariant(t, r) {
      if (!t)
        throw new Error(this.formatMessage(r));
    }
    formatMessage(t) {
      return `${this.descriptor}: ${t}`;
    }
  };
  Mc.OptionValidator = oy;
});

// ../node_modules/@babel/helper-validator-option/lib/index.js
var qc = D((Rc) => {
  "use strict";
  Object.defineProperty(Rc, "__esModule", {
    value: !0
  });
  Object.defineProperty(Rc, "OptionValidator", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return xde.OptionValidator;
    }, "get")
  });
  Object.defineProperty(Rc, "findSuggestion", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ede.findSuggestion;
    }, "get")
  });
  var xde = HC(), Ede = ay();
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/iterator.js
var GC = D((w6e, JC) => {
  "use strict";
  JC.exports = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  };
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/yallist/yallist.js
var zC = D((D6e, XC) => {
  "use strict";
  XC.exports = Oe;
  Oe.Node = ni;
  Oe.create = Oe;
  function Oe(e) {
    var t = this;
    if (t instanceof Oe || (t = new Oe()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
      e.forEach(function(n) {
        t.push(n);
      });
    else if (arguments.length > 0)
      for (var r = 0, s = arguments.length; r < s; r++)
        t.push(arguments[r]);
    return t;
  }
  i(Oe, "Yallist");
  Oe.prototype.removeNode = function(e) {
    if (e.list !== this)
      throw new Error("removing node which does not belong to this list");
    var t = e.next, r = e.prev;
    return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.
    next = null, e.prev = null, e.list = null, t;
  };
  Oe.prototype.unshiftNode = function(e) {
    if (e !== this.head) {
      e.list && e.list.removeNode(e);
      var t = this.head;
      e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
    }
  };
  Oe.prototype.pushNode = function(e) {
    if (e !== this.tail) {
      e.list && e.list.removeNode(e);
      var t = this.tail;
      e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
    }
  };
  Oe.prototype.push = function() {
    for (var e = 0, t = arguments.length; e < t; e++)
      vde(this, arguments[e]);
    return this.length;
  };
  Oe.prototype.unshift = function() {
    for (var e = 0, t = arguments.length; e < t; e++)
      Pde(this, arguments[e]);
    return this.length;
  };
  Oe.prototype.pop = function() {
    if (this.tail) {
      var e = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
    }
  };
  Oe.prototype.shift = function() {
    if (this.head) {
      var e = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
    }
  };
  Oe.prototype.forEach = function(e, t) {
    t = t || this;
    for (var r = this.head, s = 0; r !== null; s++)
      e.call(t, r.value, s, this), r = r.next;
  };
  Oe.prototype.forEachReverse = function(e, t) {
    t = t || this;
    for (var r = this.tail, s = this.length - 1; r !== null; s--)
      e.call(t, r.value, s, this), r = r.prev;
  };
  Oe.prototype.get = function(e) {
    for (var t = 0, r = this.head; r !== null && t < e; t++)
      r = r.next;
    if (t === e && r !== null)
      return r.value;
  };
  Oe.prototype.getReverse = function(e) {
    for (var t = 0, r = this.tail; r !== null && t < e; t++)
      r = r.prev;
    if (t === e && r !== null)
      return r.value;
  };
  Oe.prototype.map = function(e, t) {
    t = t || this;
    for (var r = new Oe(), s = this.head; s !== null; )
      r.push(e.call(t, s.value, this)), s = s.next;
    return r;
  };
  Oe.prototype.mapReverse = function(e, t) {
    t = t || this;
    for (var r = new Oe(), s = this.tail; s !== null; )
      r.push(e.call(t, s.value, this)), s = s.prev;
    return r;
  };
  Oe.prototype.reduce = function(e, t) {
    var r, s = this.head;
    if (arguments.length > 1)
      r = t;
    else if (this.head)
      s = this.head.next, r = this.head.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var n = 0; s !== null; n++)
      r = e(r, s.value, n), s = s.next;
    return r;
  };
  Oe.prototype.reduceReverse = function(e, t) {
    var r, s = this.tail;
    if (arguments.length > 1)
      r = t;
    else if (this.tail)
      s = this.tail.prev, r = this.tail.value;
    else
      throw new TypeError("Reduce of empty list with no initial value");
    for (var n = this.length - 1; s !== null; n--)
      r = e(r, s.value, n), s = s.prev;
    return r;
  };
  Oe.prototype.toArray = function() {
    for (var e = new Array(this.length), t = 0, r = this.head; r !== null; t++)
      e[t] = r.value, r = r.next;
    return e;
  };
  Oe.prototype.toArrayReverse = function() {
    for (var e = new Array(this.length), t = 0, r = this.tail; r !== null; t++)
      e[t] = r.value, r = r.prev;
    return e;
  };
  Oe.prototype.slice = function(e, t) {
    t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
    var r = new Oe();
    if (t < e || t < 0)
      return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var s = 0, n = this.head; n !== null && s < e; s++)
      n = n.next;
    for (; n !== null && s < t; s++, n = n.next)
      r.push(n.value);
    return r;
  };
  Oe.prototype.sliceReverse = function(e, t) {
    t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
    var r = new Oe();
    if (t < e || t < 0)
      return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var s = this.length, n = this.tail; n !== null && s > t; s--)
      n = n.prev;
    for (; n !== null && s > e; s--, n = n.prev)
      r.push(n.value);
    return r;
  };
  Oe.prototype.splice = function(e, t) {
    e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
    for (var r = 0, s = this.head; s !== null && r < e; r++)
      s = s.next;
    for (var n = [], r = 0; s && r < t; r++)
      n.push(s.value), s = this.removeNode(s);
    s === null && (s = this.tail), s !== this.head && s !== this.tail && (s = s.prev);
    for (var r = 2; r < arguments.length; r++)
      s = Sde(this, s, arguments[r]);
    return n;
  };
  Oe.prototype.reverse = function() {
    for (var e = this.head, t = this.tail, r = e; r !== null; r = r.prev) {
      var s = r.prev;
      r.prev = r.next, r.next = s;
    }
    return this.head = t, this.tail = e, this;
  };
  function Sde(e, t, r) {
    var s = t === e.head ? new ni(r, null, t, e) : new ni(r, t, t.next, e);
    return s.next === null && (e.tail = s), s.prev === null && (e.head = s), e.length++, s;
  }
  i(Sde, "insert");
  function vde(e, t) {
    e.tail = new ni(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
  }
  i(vde, "push");
  function Pde(e, t) {
    e.head = new ni(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
  }
  i(Pde, "unshift");
  function ni(e, t, r, s) {
    if (!(this instanceof ni))
      return new ni(e, t, r, s);
    this.list = s, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null;
  }
  i(ni, "Node");
  try {
    GC()(Oe);
  } catch {
  }
});

// ../node_modules/@babel/helper-compilation-targets/node_modules/lru-cache/index.js
var r4 = D((I6e, t4) => {
  "use strict";
  var Ade = zC(), ii = Symbol("max"), ks = Symbol("length"), ea = Symbol("lengthCalculator"), Mo = Symbol("allowStale"), ai = Symbol("maxAge"),
  Bs = Symbol("dispose"), QC = Symbol("noDisposeOnSet"), bt = Symbol("lruList"), Jr = Symbol("cache"), e4 = Symbol("updateAgeOnGet"), ly = /* @__PURE__ */ i(
  () => 1, "naiveLength"), cy = class {
    static {
      i(this, "LRUCache");
    }
    constructor(t) {
      if (typeof t == "number" && (t = { max: t }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
        throw new TypeError("max must be a non-negative number");
      let r = this[ii] = t.max || 1 / 0, s = t.length || ly;
      if (this[ea] = typeof s != "function" ? ly : s, this[Mo] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
        throw new TypeError("maxAge must be a number");
      this[ai] = t.maxAge || 0, this[Bs] = t.dispose, this[QC] = t.noDisposeOnSet || !1, this[e4] = t.updateAgeOnGet || !1, this.reset();
    }
    // resize the cache when the max changes.
    set max(t) {
      if (typeof t != "number" || t < 0)
        throw new TypeError("max must be a non-negative number");
      this[ii] = t || 1 / 0, jo(this);
    }
    get max() {
      return this[ii];
    }
    set allowStale(t) {
      this[Mo] = !!t;
    }
    get allowStale() {
      return this[Mo];
    }
    set maxAge(t) {
      if (typeof t != "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[ai] = t, jo(this);
    }
    get maxAge() {
      return this[ai];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(t) {
      typeof t != "function" && (t = ly), t !== this[ea] && (this[ea] = t, this[ks] = 0, this[bt].forEach((r) => {
        r.length = this[ea](r.value, r.key), this[ks] += r.length;
      })), jo(this);
    }
    get lengthCalculator() {
      return this[ea];
    }
    get length() {
      return this[ks];
    }
    get itemCount() {
      return this[bt].length;
    }
    rforEach(t, r) {
      r = r || this;
      for (let s = this[bt].tail; s !== null; ) {
        let n = s.prev;
        ZC(this, t, s, r), s = n;
      }
    }
    forEach(t, r) {
      r = r || this;
      for (let s = this[bt].head; s !== null; ) {
        let n = s.next;
        ZC(this, t, s, r), s = n;
      }
    }
    keys() {
      return this[bt].toArray().map((t) => t.key);
    }
    values() {
      return this[bt].toArray().map((t) => t.value);
    }
    reset() {
      this[Bs] && this[bt] && this[bt].length && this[bt].forEach((t) => this[Bs](t.key, t.value)), this[Jr] = /* @__PURE__ */ new Map(), this[bt] =
      new Ade(), this[ks] = 0;
    }
    dump() {
      return this[bt].map((t) => Uc(this, t) ? !1 : {
        k: t.key,
        v: t.value,
        e: t.now + (t.maxAge || 0)
      }).toArray().filter((t) => t);
    }
    dumpLru() {
      return this[bt];
    }
    set(t, r, s) {
      if (s = s || this[ai], s && typeof s != "number")
        throw new TypeError("maxAge must be a number");
      let n = s ? Date.now() : 0, a = this[ea](r, t);
      if (this[Jr].has(t)) {
        if (a > this[ii])
          return ta(this, this[Jr].get(t)), !1;
        let u = this[Jr].get(t).value;
        return this[Bs] && (this[QC] || this[Bs](t, u.value)), u.now = n, u.maxAge = s, u.value = r, this[ks] += a - u.length, u.length = a,
        this.get(t), jo(this), !0;
      }
      let o = new py(t, r, a, n, s);
      return o.length > this[ii] ? (this[Bs] && this[Bs](t, r), !1) : (this[ks] += o.length, this[bt].unshift(o), this[Jr].set(t, this[bt].head),
      jo(this), !0);
    }
    has(t) {
      if (!this[Jr].has(t)) return !1;
      let r = this[Jr].get(t).value;
      return !Uc(this, r);
    }
    get(t) {
      return uy(this, t, !0);
    }
    peek(t) {
      return uy(this, t, !1);
    }
    pop() {
      let t = this[bt].tail;
      return t ? (ta(this, t), t.value) : null;
    }
    del(t) {
      ta(this, this[Jr].get(t));
    }
    load(t) {
      this.reset();
      let r = Date.now();
      for (let s = t.length - 1; s >= 0; s--) {
        let n = t[s], a = n.e || 0;
        if (a === 0)
          this.set(n.k, n.v);
        else {
          let o = a - r;
          o > 0 && this.set(n.k, n.v, o);
        }
      }
    }
    prune() {
      this[Jr].forEach((t, r) => uy(this, r, !1));
    }
  }, uy = /* @__PURE__ */ i((e, t, r) => {
    let s = e[Jr].get(t);
    if (s) {
      let n = s.value;
      if (Uc(e, n)) {
        if (ta(e, s), !e[Mo])
          return;
      } else
        r && (e[e4] && (s.value.now = Date.now()), e[bt].unshiftNode(s));
      return n.value;
    }
  }, "get"), Uc = /* @__PURE__ */ i((e, t) => {
    if (!t || !t.maxAge && !e[ai])
      return !1;
    let r = Date.now() - t.now;
    return t.maxAge ? r > t.maxAge : e[ai] && r > e[ai];
  }, "isStale"), jo = /* @__PURE__ */ i((e) => {
    if (e[ks] > e[ii])
      for (let t = e[bt].tail; e[ks] > e[ii] && t !== null; ) {
        let r = t.prev;
        ta(e, t), t = r;
      }
  }, "trim"), ta = /* @__PURE__ */ i((e, t) => {
    if (t) {
      let r = t.value;
      e[Bs] && e[Bs](r.key, r.value), e[ks] -= r.length, e[Jr].delete(r.key), e[bt].removeNode(t);
    }
  }, "del"), py = class {
    static {
      i(this, "Entry");
    }
    constructor(t, r, s, n, a) {
      this.key = t, this.value = r, this.length = s, this.now = n, this.maxAge = a || 0;
    }
  }, ZC = /* @__PURE__ */ i((e, t, r, s) => {
    let n = r.value;
    Uc(e, n) && (ta(e, r), e[Mo] || (n = void 0)), n && t.call(s, n.value, n.key, e);
  }, "forEachStep");
  t4.exports = cy;
});

// ../node_modules/@babel/helper-compilation-targets/lib/targets.js
var $c = D((ra) => {
  "use strict";
  Object.defineProperty(ra, "__esModule", {
    value: !0
  });
  ra.unreleasedLabels = ra.browserNameMap = void 0;
  var N6e = ra.unreleasedLabels = {
    safari: "tp"
  }, B6e = ra.browserNameMap = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    deno: "deno",
    op_mob: "opera_mobile",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
  };
});

// ../node_modules/@babel/helper-compilation-targets/lib/utils.js
var Vc = D((hn) => {
  "use strict";
  Object.defineProperty(hn, "__esModule", {
    value: !0
  });
  hn.getHighestUnreleased = Ode;
  hn.getLowestImplementedVersion = Nde;
  hn.getLowestUnreleased = a4;
  hn.isUnreleasedVersion = Ide;
  hn.semverMin = i4;
  hn.semverify = _de;
  var s4 = z("semver"), Cde = qc(), n4 = $c(), wde = /^(?:\d+|\d(?:\d?[^\d\n\r\u2028\u2029]\d+|\d{2,}(?:[^\d\n\r\u2028\u2029]\d+)?))$/, Dde = new Cde.
  OptionValidator("@babel/helper-compilation-targets");
  function i4(e, t) {
    return e && s4.lt(e, t) ? e : t;
  }
  i(i4, "semverMin");
  function _de(e) {
    if (typeof e == "string" && s4.valid(e))
      return e;
    Dde.invariant(typeof e == "number" || typeof e == "string" && wde.test(e), `'${e}' is not a valid version`), e = e.toString();
    let t = 0, r = 0;
    for (; (t = e.indexOf(".", t + 1)) > 0; )
      r++;
    return e + ".0".repeat(2 - r);
  }
  i(_de, "semverify");
  function Ide(e, t) {
    let r = n4.unreleasedLabels[t];
    return !!r && r === e.toString().toLowerCase();
  }
  i(Ide, "isUnreleasedVersion");
  function a4(e, t, r) {
    let s = n4.unreleasedLabels[r];
    return e === s ? t : t === s ? e : i4(e, t);
  }
  i(a4, "getLowestUnreleased");
  function Ode(e, t, r) {
    return a4(e, t, r) === e ? t : e;
  }
  i(Ode, "getHighestUnreleased");
  function Nde(e, t) {
    let r = e[t];
    return !r && t === "android" ? e.chrome : r;
  }
  i(Nde, "getLowestImplementedVersion");
});

// ../node_modules/@babel/helper-compilation-targets/lib/options.js
var o4 = D((Kc) => {
  "use strict";
  Object.defineProperty(Kc, "__esModule", {
    value: !0
  });
  Kc.TargetNames = void 0;
  var j6e = Kc.TargetNames = {
    node: "node",
    deno: "deno",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung",
    rhino: "rhino",
    opera_mobile: "opera_mobile"
  };
});

// ../node_modules/@babel/helper-compilation-targets/lib/pretty.js
var fy = D((Wc) => {
  "use strict";
  Object.defineProperty(Wc, "__esModule", {
    value: !0
  });
  Wc.prettifyTargets = Fde;
  Wc.prettifyVersion = l4;
  var Bde = z("semver"), kde = $c();
  function l4(e) {
    if (typeof e != "string")
      return e;
    let {
      major: t,
      minor: r,
      patch: s
    } = Bde.parse(e), n = [t];
    return (r || s) && n.push(r), s && n.push(s), n.join(".");
  }
  i(l4, "prettifyVersion");
  function Fde(e) {
    return Object.keys(e).reduce((t, r) => {
      let s = e[r], n = kde.unreleasedLabels[r];
      return typeof s == "string" && n !== s && (s = l4(s)), t[r] = s, t;
    }, {});
  }
  i(Fde, "prettifyTargets");
});

// ../node_modules/@babel/helper-compilation-targets/lib/debug.js
var c4 = D((dy) => {
  "use strict";
  Object.defineProperty(dy, "__esModule", {
    value: !0
  });
  dy.getInclusionReasons = jde;
  var Lde = z("semver"), u4 = fy(), Yc = Vc();
  function jde(e, t, r) {
    let s = r[e] || {};
    return Object.keys(t).reduce((n, a) => {
      let o = (0, Yc.getLowestImplementedVersion)(s, a), l = t[a];
      if (!o)
        n[a] = (0, u4.prettifyVersion)(l);
      else {
        let u = (0, Yc.isUnreleasedVersion)(o, a);
        !(0, Yc.isUnreleasedVersion)(l, a) && (u || Lde.lt(l.toString(), (0, Yc.semverify)(o))) && (n[a] = (0, u4.prettifyVersion)(l));
      }
      return n;
    }, {});
  }
  i(jde, "getInclusionReasons");
});

// ../node_modules/@babel/compat-data/data/plugins.json
var p4 = D((V6e, Mde) => {
  Mde.exports = {
    "transform-explicit-resource-management": {
      chrome: "134",
      edge: "134",
      firefox: "141",
      node: "24",
      electron: "35.0"
    },
    "transform-duplicate-named-capturing-groups-regex": {
      chrome: "126",
      opera: "112",
      edge: "126",
      firefox: "129",
      safari: "17.4",
      node: "23",
      ios: "17.4",
      electron: "31.0"
    },
    "transform-regexp-modifiers": {
      chrome: "125",
      opera: "111",
      edge: "125",
      firefox: "132",
      node: "23",
      samsung: "27",
      electron: "31.0"
    },
    "transform-unicode-sets-regex": {
      chrome: "112",
      opera: "98",
      edge: "112",
      firefox: "116",
      safari: "17",
      node: "20",
      deno: "1.32",
      ios: "17",
      samsung: "23",
      opera_mobile: "75",
      electron: "24.0"
    },
    "bugfix/transform-v8-static-class-fields-redefine-readonly": {
      chrome: "98",
      opera: "84",
      edge: "98",
      firefox: "75",
      safari: "15",
      node: "12",
      deno: "1.18",
      ios: "15",
      samsung: "11",
      opera_mobile: "52",
      electron: "17.0"
    },
    "bugfix/transform-firefox-class-in-computed-class-key": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "126",
      safari: "16",
      node: "12",
      deno: "1",
      ios: "16",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "bugfix/transform-safari-class-field-initializer-scope": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "69",
      safari: "16",
      node: "12",
      deno: "1",
      ios: "16",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "transform-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "proposal-class-static-block": {
      chrome: "94",
      opera: "80",
      edge: "94",
      firefox: "93",
      safari: "16.4",
      node: "16.11",
      deno: "1.14",
      ios: "16.4",
      samsung: "17",
      opera_mobile: "66",
      electron: "15.0"
    },
    "transform-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-private-property-in-object": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "90",
      safari: "15",
      node: "16.9",
      deno: "1.9",
      ios: "15",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "proposal-class-properties": {
      chrome: "74",
      opera: "62",
      edge: "79",
      firefox: "90",
      safari: "14.1",
      node: "12",
      deno: "1",
      ios: "14.5",
      samsung: "11",
      opera_mobile: "53",
      electron: "6.0"
    },
    "transform-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-private-methods": {
      chrome: "84",
      opera: "70",
      edge: "84",
      firefox: "90",
      safari: "15",
      node: "14.6",
      deno: "1",
      ios: "15",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "proposal-numeric-separator": {
      chrome: "75",
      opera: "62",
      edge: "79",
      firefox: "70",
      safari: "13",
      node: "12.5",
      deno: "1",
      ios: "13",
      samsung: "11",
      rhino: "1.7.14",
      opera_mobile: "54",
      electron: "6.0"
    },
    "transform-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "proposal-logical-assignment-operators": {
      chrome: "85",
      opera: "71",
      edge: "85",
      firefox: "79",
      safari: "14",
      node: "15",
      deno: "1.2",
      ios: "14",
      samsung: "14",
      opera_mobile: "60",
      electron: "10.0"
    },
    "transform-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      rhino: "1.8",
      opera_mobile: "57",
      electron: "8.0"
    },
    "proposal-nullish-coalescing-operator": {
      chrome: "80",
      opera: "67",
      edge: "80",
      firefox: "72",
      safari: "13.1",
      node: "14",
      deno: "1",
      ios: "13.4",
      samsung: "13",
      rhino: "1.8",
      opera_mobile: "57",
      electron: "8.0"
    },
    "transform-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "proposal-optional-chaining": {
      chrome: "91",
      opera: "77",
      edge: "91",
      firefox: "74",
      safari: "13.1",
      node: "16.9",
      deno: "1.9",
      ios: "13.4",
      samsung: "16",
      opera_mobile: "64",
      electron: "13.0"
    },
    "transform-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-json-strings": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "62",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "9",
      rhino: "1.7.14",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-optional-catch-binding": {
      chrome: "66",
      opera: "53",
      edge: "79",
      firefox: "58",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-parameters": {
      chrome: "49",
      opera: "36",
      edge: "18",
      firefox: "52",
      safari: "16.3",
      node: "6",
      deno: "1",
      ios: "16.3",
      samsung: "5",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "proposal-async-generator-functions": {
      chrome: "63",
      opera: "50",
      edge: "79",
      firefox: "57",
      safari: "12",
      node: "10",
      deno: "1",
      ios: "12",
      samsung: "8",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "proposal-object-rest-spread": {
      chrome: "60",
      opera: "47",
      edge: "79",
      firefox: "55",
      safari: "11.1",
      node: "8.3",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      opera_mobile: "44",
      electron: "2.0"
    },
    "transform-dotall-regex": {
      chrome: "62",
      opera: "49",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "8.10",
      deno: "1",
      ios: "11.3",
      samsung: "8",
      rhino: "1.7.15",
      opera_mobile: "46",
      electron: "3.0"
    },
    "transform-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "proposal-unicode-property-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-named-capturing-groups-regex": {
      chrome: "64",
      opera: "51",
      edge: "79",
      firefox: "78",
      safari: "11.1",
      node: "10",
      deno: "1",
      ios: "11.3",
      samsung: "9",
      opera_mobile: "47",
      electron: "3.0"
    },
    "transform-async-to-generator": {
      chrome: "55",
      opera: "42",
      edge: "15",
      firefox: "52",
      safari: "11",
      node: "7.6",
      deno: "1",
      ios: "11",
      samsung: "6",
      opera_mobile: "42",
      electron: "1.6"
    },
    "transform-exponentiation-operator": {
      chrome: "52",
      opera: "39",
      edge: "14",
      firefox: "52",
      safari: "10.1",
      node: "7",
      deno: "1",
      ios: "10.3",
      samsung: "6",
      rhino: "1.7.14",
      opera_mobile: "41",
      electron: "1.3"
    },
    "transform-template-literals": {
      chrome: "41",
      opera: "28",
      edge: "13",
      firefox: "34",
      safari: "13",
      node: "4",
      deno: "1",
      ios: "13",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-literals": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.15",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-function-name": {
      chrome: "51",
      opera: "38",
      edge: "79",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-arrow-functions": {
      chrome: "47",
      opera: "34",
      edge: "13",
      firefox: "43",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      rhino: "1.7.13",
      opera_mobile: "34",
      electron: "0.36"
    },
    "transform-block-scoped-functions": {
      chrome: "41",
      opera: "28",
      edge: "12",
      firefox: "46",
      safari: "10",
      node: "4",
      deno: "1",
      ie: "11",
      ios: "10",
      samsung: "3.4",
      opera_mobile: "28",
      electron: "0.21"
    },
    "transform-classes": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-object-super": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-shorthand-properties": {
      chrome: "43",
      opera: "30",
      edge: "12",
      firefox: "33",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.14",
      opera_mobile: "30",
      electron: "0.27"
    },
    "transform-duplicate-keys": {
      chrome: "42",
      opera: "29",
      edge: "12",
      firefox: "34",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "3.4",
      opera_mobile: "29",
      electron: "0.25"
    },
    "transform-computed-properties": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "34",
      safari: "7.1",
      node: "4",
      deno: "1",
      ios: "8",
      samsung: "4",
      rhino: "1.8",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-for-of": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-sticky-regex": {
      chrome: "49",
      opera: "36",
      edge: "13",
      firefox: "3",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      rhino: "1.7.15",
      opera_mobile: "36",
      electron: "0.37"
    },
    "transform-unicode-escapes": {
      chrome: "44",
      opera: "31",
      edge: "12",
      firefox: "53",
      safari: "9",
      node: "4",
      deno: "1",
      ios: "9",
      samsung: "4",
      rhino: "1.7.15",
      opera_mobile: "32",
      electron: "0.30"
    },
    "transform-unicode-regex": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "46",
      safari: "12",
      node: "6",
      deno: "1",
      ios: "12",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-spread": {
      chrome: "46",
      opera: "33",
      edge: "13",
      firefox: "45",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-destructuring": {
      chrome: "51",
      opera: "38",
      edge: "15",
      firefox: "53",
      safari: "10",
      node: "6.5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "41",
      electron: "1.2"
    },
    "transform-block-scoping": {
      chrome: "50",
      opera: "37",
      edge: "14",
      firefox: "53",
      safari: "11",
      node: "6",
      deno: "1",
      ios: "11",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-typeof-symbol": {
      chrome: "48",
      opera: "35",
      edge: "12",
      firefox: "36",
      safari: "9",
      node: "6",
      deno: "1",
      ios: "9",
      samsung: "5",
      rhino: "1.8",
      opera_mobile: "35",
      electron: "0.37"
    },
    "transform-new-target": {
      chrome: "46",
      opera: "33",
      edge: "14",
      firefox: "41",
      safari: "10",
      node: "5",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "33",
      electron: "0.36"
    },
    "transform-regenerator": {
      chrome: "50",
      opera: "37",
      edge: "13",
      firefox: "53",
      safari: "10",
      node: "6",
      deno: "1",
      ios: "10",
      samsung: "5",
      opera_mobile: "37",
      electron: "1.1"
    },
    "transform-member-expression-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-property-literals": {
      chrome: "7",
      opera: "12",
      edge: "12",
      firefox: "2",
      safari: "5.1",
      node: "0.4",
      deno: "1",
      ie: "9",
      android: "4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "12",
      electron: "0.20"
    },
    "transform-reserved-words": {
      chrome: "13",
      opera: "10.50",
      edge: "12",
      firefox: "2",
      safari: "3.1",
      node: "0.6",
      deno: "1",
      ie: "9",
      android: "4.4",
      ios: "6",
      phantom: "1.9",
      samsung: "1",
      rhino: "1.7.13",
      opera_mobile: "10.1",
      electron: "0.20"
    },
    "transform-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2.0",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    },
    "proposal-export-namespace-from": {
      chrome: "72",
      deno: "1.0",
      edge: "79",
      firefox: "80",
      node: "13.2.0",
      opera: "60",
      opera_mobile: "51",
      safari: "14.1",
      ios: "14.5",
      samsung: "11.0",
      android: "72",
      electron: "5.0"
    }
  };
});

// ../node_modules/@babel/compat-data/plugins.js
var d4 = D((K6e, f4) => {
  f4.exports = p4();
});

// ../node_modules/@babel/helper-compilation-targets/lib/filter-items.js
var b4 = D((Ro) => {
  "use strict";
  Object.defineProperty(Ro, "__esModule", {
    value: !0
  });
  Ro.default = qde;
  Ro.isRequired = y4;
  Ro.targetsSupported = m4;
  var h4 = z("semver"), Hc = Vc(), Rde = d4();
  function m4(e, t) {
    let r = Object.keys(e);
    return r.length === 0 ? !1 : r.filter((n) => {
      let a = (0, Hc.getLowestImplementedVersion)(t, n);
      if (!a)
        return !0;
      let o = e[n];
      if ((0, Hc.isUnreleasedVersion)(o, n))
        return !1;
      if ((0, Hc.isUnreleasedVersion)(a, n))
        return !0;
      if (!h4.valid(o.toString()))
        throw new Error(`Invalid version passed for target "${n}": "${o}". Versions must be in semver format (major.minor.patch)`);
      return h4.gt((0, Hc.semverify)(a), o.toString());
    }).length === 0;
  }
  i(m4, "targetsSupported");
  function y4(e, t, {
    compatData: r = Rde,
    includes: s,
    excludes: n
  } = {}) {
    return n != null && n.has(e) ? !1 : s != null && s.has(e) ? !0 : !m4(t, r[e]);
  }
  i(y4, "isRequired");
  function qde(e, t, r, s, n, a, o) {
    let l = /* @__PURE__ */ new Set(), u = {
      compatData: e,
      includes: t,
      excludes: r
    };
    for (let c in e)
      if (y4(c, s, u))
        l.add(c);
      else if (o) {
        let p = o.get(c);
        p && l.add(p);
      }
    return n?.forEach((c) => !r.has(c) && l.add(c)), a?.forEach((c) => !t.has(c) && l.delete(c)), l;
  }
  i(qde, "filterItems");
});

// ../node_modules/@babel/compat-data/data/native-modules.json
var g4 = D((H6e, Ude) => {
  Ude.exports = {
    "es6.module": {
      chrome: "61",
      and_chr: "61",
      edge: "16",
      firefox: "60",
      and_ff: "60",
      node: "13.2.0",
      opera: "48",
      op_mob: "45",
      safari: "10.1",
      ios: "10.3",
      samsung: "8.2",
      android: "61",
      electron: "2.0",
      ios_saf: "10.3"
    }
  };
});

// ../node_modules/@babel/compat-data/native-modules.js
var x4 = D((J6e, T4) => {
  T4.exports = g4();
});

// ../node_modules/@babel/helper-compilation-targets/lib/index.js
var gy = D((cs) => {
  "use strict";
  Object.defineProperty(cs, "__esModule", {
    value: !0
  });
  Object.defineProperty(cs, "TargetNames", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return yy.TargetNames;
    }, "get")
  });
  cs.default = t0e;
  Object.defineProperty(cs, "filterItems", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return P4.default;
    }, "get")
  });
  Object.defineProperty(cs, "getInclusionReasons", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Kde.getInclusionReasons;
    }, "get")
  });
  cs.isBrowsersQueryValid = A4;
  Object.defineProperty(cs, "isRequired", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return P4.isRequired;
    }, "get")
  });
  Object.defineProperty(cs, "prettifyTargets", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vde.prettifyTargets;
    }, "get")
  });
  Object.defineProperty(cs, "unreleasedLabels", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return v4.unreleasedLabels;
    }, "get")
  });
  var my = WC(), S4 = qc(), $de = r4(), Gr = Vc(), v4 = $c(), yy = o4(), Vde = fy(), Kde = c4(), P4 = b4(), Wde = x4(), hy = Wde["es6.module"],
  by = new S4.OptionValidator("@babel/helper-compilation-targets");
  function Yde(e) {
    let t = Object.keys(yy.TargetNames);
    for (let r of Object.keys(e))
      if (!(r in yy.TargetNames))
        throw new Error(by.formatMessage(`'${r}' is not a valid target
- Did you mean '${(0, S4.findSuggestion)(r, t)}'?`));
    return e;
  }
  i(Yde, "validateTargetNames");
  function A4(e) {
    return typeof e == "string" || Array.isArray(e) && e.every((t) => typeof t == "string");
  }
  i(A4, "isBrowsersQueryValid");
  function Hde(e) {
    return by.invariant(e === void 0 || A4(e), `'${String(e)}' is not a valid browserslist query`), e;
  }
  i(Hde, "validateBrowsers");
  function Jde(e) {
    return e.reduce((t, r) => {
      let [s, n] = r.split(" "), a = v4.browserNameMap[s];
      if (!a)
        return t;
      try {
        let o = n.split("-")[0].toLowerCase(), l = (0, Gr.isUnreleasedVersion)(o, a);
        if (!t[a])
          return t[a] = l ? o : (0, Gr.semverify)(o), t;
        let u = t[a], c = (0, Gr.isUnreleasedVersion)(u, a);
        if (c && l)
          t[a] = (0, Gr.getLowestUnreleased)(u, o, a);
        else if (c)
          t[a] = (0, Gr.semverify)(o);
        else if (!c && !l) {
          let p = (0, Gr.semverify)(o);
          t[a] = (0, Gr.semverMin)(u, p);
        }
      } catch {
      }
      return t;
    }, {});
  }
  i(Jde, "getLowestVersions");
  function Gde(e) {
    e.length && (console.warn(`Warning, the following targets are using a decimal version:
`), e.forEach(({
      target: t,
      value: r
    }) => console.warn(`  ${t}: ${r}`)), console.warn(`
We recommend using a string for minor/patch versions to avoid numbers like 6.10
getting parsed as 6.1, which can lead to unexpected behavior.
`));
  }
  i(Gde, "outputDecimalWarning");
  function C4(e, t) {
    try {
      return (0, Gr.semverify)(t);
    } catch {
      throw new Error(by.formatMessage(`'${t}' is not a valid value for 'targets.${e}'.`));
    }
  }
  i(C4, "semverifyTarget");
  function Xde(e) {
    return ["node", e === !0 || e === "current" ? process.versions.node.split("-")[0] : C4("node", e)];
  }
  i(Xde, "nodeTargetParser");
  function zde(e, t) {
    let r = (0, Gr.isUnreleasedVersion)(t, e) ? t.toLowerCase() : C4(e, t);
    return [e, r];
  }
  i(zde, "defaultTargetParser");
  function Qde(e) {
    let t = Object.assign({}, e);
    return delete t.esmodules, delete t.browsers, t;
  }
  i(Qde, "generateTargets");
  function Zde(e, t) {
    let r = my(e, {
      mobileToDesktop: !0,
      env: t
    });
    return Jde(r);
  }
  i(Zde, "resolveTargets");
  var E4 = new $de({
    max: 64
  });
  function e0e(e, t) {
    let r = typeof e == "string" ? e : e.join() + t, s = E4.get(r);
    return s || (s = Zde(e, t), E4.set(r, s)), Object.assign({}, s);
  }
  i(e0e, "resolveTargetsCached");
  function t0e(e = {}, t = {}) {
    var r, s;
    let {
      browsers: n,
      esmodules: a
    } = e, {
      configPath: o = ".",
      onBrowserslistConfigFound: l
    } = t;
    Hde(n);
    let u = Qde(e), c = Yde(u), f = !!n || Object.keys(c).length > 0, h = !t.ignoreBrowserslistConfig && !f;
    if (!n && h) {
      if (n = process.env.BROWSERSLIST, !n) {
        let d = t.configFile || process.env.BROWSERSLIST_CONFIG || my.findConfigFile(o);
        d != null && (l?.(d), n = my.loadConfig({
          config: d,
          env: t.browserslistEnv
        }));
      }
      n == null && (n = []);
    }
    if (a && (a !== "intersect" || !((r = n) != null && r.length)) && (n = Object.keys(hy).map((d) => `${d} >= ${hy[d]}`).join(", "), a = !1),
    (s = n) != null && s.length) {
      let d = e0e(n, t.browserslistEnv);
      if (a === "intersect")
        for (let g of Object.keys(d))
          if (g !== "deno" && g !== "ie") {
            let E = hy[g === "opera_mobile" ? "op_mob" : g];
            if (E) {
              let _ = d[g];
              d[g] = (0, Gr.getHighestUnreleased)(_, (0, Gr.semverify)(E), g);
            } else
              delete d[g];
          } else
            delete d[g];
      c = Object.assign(d, c);
    }
    let b = {}, T = [];
    for (let d of Object.keys(c).sort()) {
      let g = c[d];
      typeof g == "number" && g % 1 !== 0 && T.push({
        target: d,
        value: g
      });
      let [E, _] = d === "node" ? Xde(g) : zde(d, g);
      _ && (b[E] = _);
    }
    return Gde(T), b;
  }
  i(t0e, "getTargets");
});

// ../node_modules/@babel/core/lib/config/resolve-targets.js
var Ty = D((Jc) => {
  "use strict";
  Object.defineProperty(Jc, "__esModule", {
    value: !0
  });
  Jc.resolveBrowserslistConfigFile = r0e;
  Jc.resolveTargets = s0e;
  function w4() {
    let e = z("path");
    return w4 = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(w4, "_path");
  function D4() {
    let e = gy();
    return D4 = /* @__PURE__ */ i(function() {
      return e;
    }, "_helperCompilationTargets"), e;
  }
  i(D4, "_helperCompilationTargets");
  function r0e(e, t) {
    return w4().resolve(t, e);
  }
  i(r0e, "resolveBrowserslistConfigFile");
  function s0e(e, t) {
    let r = e.targets, s;
    typeof r == "string" || Array.isArray(r) ? s = {
      browsers: r
    } : r && ("esmodules" in r ? s = Object.assign({}, r, {
      esmodules: "intersect"
    }) : s = r);
    let {
      browserslistConfigFile: n
    } = e, a, o = !1;
    return typeof n == "string" ? a = n : o = n === !1, (0, D4().default)(s, {
      ignoreBrowserslistConfig: o,
      configFile: a,
      configPath: t,
      browserslistEnv: e.browserslistEnv
    });
  }
  i(s0e, "resolveTargets");
});

// ../node_modules/@babel/core/lib/config/config-descriptors.js
var xy = D((Uo) => {
  "use strict";
  Object.defineProperty(Uo, "__esModule", {
    value: !0
  });
  Uo.createCachedDescriptors = o0e;
  Uo.createDescriptor = M4;
  Uo.createUncachedDescriptors = l0e;
  function N4() {
    let e = ir();
    return N4 = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(N4, "_gensync");
  var _4 = D3(), I4 = Vo(), n0e = $o(), qo = Zn(), i0e = Ty();
  function a0e(e, t) {
    var r, s, n, a;
    return e.name === t.name && e.value === t.value && e.options === t.options && e.dirname === t.dirname && e.alias === t.alias && e.ownPass ===
    t.ownPass && ((r = e.file) == null ? void 0 : r.request) === ((s = t.file) == null ? void 0 : s.request) && ((n = e.file) == null ? void 0 :
    n.resolved) === ((a = t.file) == null ? void 0 : a.resolved);
  }
  i(a0e, "isEqualDescriptor");
  function* O4(e) {
    return e;
  }
  i(O4, "handlerOf");
  function B4(e, t) {
    return typeof e.browserslistConfigFile == "string" && (e.browserslistConfigFile = (0, i0e.resolveBrowserslistConfigFile)(e.browserslistConfigFile,
    t)), e;
  }
  i(B4, "optionsWithResolvedBrowserslistConfigFile");
  function o0e(e, t, r) {
    let {
      plugins: s,
      presets: n,
      passPerPreset: a
    } = t;
    return {
      options: B4(t, e),
      plugins: s ? () => f0e(s, e)(r) : () => O4([]),
      presets: n ? () => c0e(n, e)(r)(!!a) : () => O4([])
    };
  }
  i(o0e, "createCachedDescriptors");
  function l0e(e, t, r) {
    return {
      options: B4(t, e),
      plugins: (0, _4.once)(() => L4(t.plugins || [], e, r)),
      presets: (0, _4.once)(() => F4(t.presets || [], e, r, !!t.passPerPreset))
    };
  }
  i(l0e, "createUncachedDescriptors");
  var u0e = /* @__PURE__ */ new WeakMap(), c0e = (0, qo.makeWeakCacheSync)((e, t) => {
    let r = t.using((s) => s);
    return (0, qo.makeStrongCacheSync)((s) => (0, qo.makeStrongCache)(function* (n) {
      return (yield* F4(e, r, s, n)).map((o) => k4(u0e, o));
    }));
  }), p0e = /* @__PURE__ */ new WeakMap(), f0e = (0, qo.makeWeakCacheSync)((e, t) => {
    let r = t.using((s) => s);
    return (0, qo.makeStrongCache)(function* (s) {
      return (yield* L4(e, r, s)).map((a) => k4(p0e, a));
    });
  }), d0e = {};
  function k4(e, t) {
    let {
      value: r,
      options: s = d0e
    } = t;
    if (s === !1) return t;
    let n = e.get(r);
    n || (n = /* @__PURE__ */ new WeakMap(), e.set(r, n));
    let a = n.get(s);
    if (a || (a = [], n.set(s, a)), !a.includes(t)) {
      let o = a.filter((l) => a0e(l, t));
      if (o.length > 0)
        return o[0];
      a.push(t);
    }
    return t;
  }
  i(k4, "loadCachedDescriptor");
  function* F4(e, t, r, s) {
    return yield* j4("preset", e, t, r, s);
  }
  i(F4, "createPresetDescriptors");
  function* L4(e, t, r) {
    return yield* j4("plugin", e, t, r);
  }
  i(L4, "createPluginDescriptors");
  function* j4(e, t, r, s, n) {
    let a = yield* N4().all(t.map((o, l) => M4(o, r, {
      type: e,
      alias: `${s}$${l}`,
      ownPass: !!n
    })));
    return h0e(a), a;
  }
  i(j4, "createDescriptors");
  function* M4(e, t, {
    type: r,
    alias: s,
    ownPass: n
  }) {
    let a = (0, n0e.getItemDescriptor)(e);
    if (a)
      return a;
    let o, l, u = e;
    Array.isArray(u) && (u.length === 3 ? [u, l, o] = u : [u, l] = u);
    let c, p = null;
    if (typeof u == "string") {
      if (typeof r != "string")
        throw new Error("To resolve a string-based item, the type of item must be given");
      let f = r === "plugin" ? I4.loadPlugin : I4.loadPreset, h = u;
      ({
        filepath: p,
        value: u
      } = yield* f(u, t)), c = {
        request: h,
        resolved: p
      };
    }
    if (!u)
      throw new Error(`Unexpected falsy value: ${String(u)}`);
    if (typeof u == "object" && u.__esModule)
      if (u.default)
        u = u.default;
      else
        throw new Error("Must export a default export when using ES6 modules.");
    if (typeof u != "object" && typeof u != "function")
      throw new Error(`Unsupported format: ${typeof u}. Expected an object or a function.`);
    if (p !== null && typeof u == "object" && u)
      throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${p}`);
    return {
      name: o,
      alias: p || s,
      value: u,
      options: l,
      dirname: t,
      ownPass: n,
      file: c
    };
  }
  i(M4, "createDescriptor");
  function h0e(e) {
    let t = /* @__PURE__ */ new Map();
    for (let r of e) {
      if (typeof r.value != "function") continue;
      let s = t.get(r.value);
      if (s || (s = /* @__PURE__ */ new Set(), t.set(r.value, s)), s.has(r.name)) {
        let n = e.filter((a) => a.value === r.value);
        throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separat\
e names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detec\
ted are:", `${JSON.stringify(n, null, 2)}`].join(`
`));
      }
      s.add(r.name);
    }
  }
  i(h0e, "assertNoDuplicates");
});

// ../node_modules/@babel/core/lib/config/item.js
var $o = D((Ko) => {
  "use strict";
  Object.defineProperty(Ko, "__esModule", {
    value: !0
  });
  Ko.createConfigItem = y0e;
  Ko.createItemFromDescriptor = q4;
  Ko.getItemDescriptor = b0e;
  function R4() {
    let e = z("path");
    return R4 = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(R4, "_path");
  var m0e = xy();
  function q4(e) {
    return new Gc(e);
  }
  i(q4, "createItemFromDescriptor");
  function* y0e(e, {
    dirname: t = ".",
    type: r
  } = {}) {
    let s = yield* (0, m0e.createDescriptor)(e, R4().resolve(t), {
      type: r,
      alias: "programmatic item"
    });
    return q4(s);
  }
  i(y0e, "createConfigItem");
  var Ey = Symbol.for("@babel/core@7 - ConfigItem");
  function b0e(e) {
    if (e != null && e[Ey])
      return e._descriptor;
  }
  i(b0e, "getItemDescriptor");
  var Gc = class {
    static {
      i(this, "ConfigItem");
    }
    constructor(t) {
      this._descriptor = void 0, this[Ey] = !0, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.
      file = void 0, this._descriptor = t, Object.defineProperty(this, "_descriptor", {
        enumerable: !1
      }), Object.defineProperty(this, Ey, {
        enumerable: !1
      }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name =
      this._descriptor.name, this.file = this._descriptor.file ? {
        request: this._descriptor.file.request,
        resolved: this._descriptor.file.resolved
      } : void 0, Object.freeze(this);
    }
  };
  Object.freeze(Gc.prototype);
});

// ../node_modules/@babel/core/lib/config/validation/removed.js
var U4 = D((Xc) => {
  "use strict";
  Object.defineProperty(Xc, "__esModule", {
    value: !0
  });
  Xc.default = void 0;
  var s_e = Xc.default = {
    auxiliaryComment: {
      message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
    },
    blacklist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    breakConfig: {
      message: "This is not a necessary option in Babel 6"
    },
    experimental: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    externalHelpers: {
      message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
    },
    extra: {
      message: ""
    },
    jsxPragma: {
      message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
    },
    loose: {
      message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
    },
    metadataUsedHelpers: {
      message: "Not required anymore as this is enabled by default"
    },
    modules: {
      message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
    },
    nonStandard: {
      message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.i\
o/docs/plugins/preset-react/"
    },
    optional: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    sourceMapName: {
      message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file\
` themselves."
    },
    stage: {
      message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
    },
    whitelist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    resolveModuleSource: {
      version: 6,
      message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
    },
    metadata: {
      version: 6,
      message: "Generated plugin metadata is always included in the output result"
    },
    sourceMapTarget: {
      version: 6,
      message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.fi\
le` themselves."
    }
  };
});

// ../node_modules/@babel/core/lib/config/validation/option-assertions.js
var Py = D((tt) => {
  "use strict";
  Object.defineProperty(tt, "__esModule", {
    value: !0
  });
  tt.access = or;
  tt.assertArray = vy;
  tt.assertAssumptions = L0e;
  tt.assertBabelrcSearch = O0e;
  tt.assertBoolean = Sy;
  tt.assertCallerMetadata = v0e;
  tt.assertCompact = E0e;
  tt.assertConfigApplicableTest = _0e;
  tt.assertConfigFileSearch = I0e;
  tt.assertFunction = C0e;
  tt.assertIgnoreList = w0e;
  tt.assertInputSourceMap = P0e;
  tt.assertObject = K4;
  tt.assertPluginList = N0e;
  tt.assertRootMode = T0e;
  tt.assertSourceMaps = x0e;
  tt.assertSourceType = S0e;
  tt.assertString = A0e;
  tt.assertTargets = k0e;
  tt.msg = Ae;
  function Wo() {
    let e = gy();
    return Wo = /* @__PURE__ */ i(function() {
      return e;
    }, "_helperCompilationTargets"), e;
  }
  i(Wo, "_helperCompilationTargets");
  var g0e = Yo();
  function Ae(e) {
    switch (e.type) {
      case "root":
        return "";
      case "env":
        return `${Ae(e.parent)}.env["${e.name}"]`;
      case "overrides":
        return `${Ae(e.parent)}.overrides[${e.index}]`;
      case "option":
        return `${Ae(e.parent)}.${e.name}`;
      case "access":
        return `${Ae(e.parent)}[${JSON.stringify(e.name)}]`;
      default:
        throw new Error(`Assertion failure: Unknown type ${e.type}`);
    }
  }
  i(Ae, "msg");
  function or(e, t) {
    return {
      type: "access",
      name: t,
      parent: e
    };
  }
  i(or, "access");
  function T0e(e, t) {
    if (t !== void 0 && t !== "root" && t !== "upward" && t !== "upward-optional")
      throw new Error(`${Ae(e)} must be a "root", "upward", "upward-optional" or undefined`);
    return t;
  }
  i(T0e, "assertRootMode");
  function x0e(e, t) {
    if (t !== void 0 && typeof t != "boolean" && t !== "inline" && t !== "both")
      throw new Error(`${Ae(e)} must be a boolean, "inline", "both", or undefined`);
    return t;
  }
  i(x0e, "assertSourceMaps");
  function E0e(e, t) {
    if (t !== void 0 && typeof t != "boolean" && t !== "auto")
      throw new Error(`${Ae(e)} must be a boolean, "auto", or undefined`);
    return t;
  }
  i(E0e, "assertCompact");
  function S0e(e, t) {
    if (t !== void 0 && t !== "module" && t !== "commonjs" && t !== "script" && t !== "unambiguous")
      throw new Error(`${Ae(e)} must be "module", "commonjs", "script", "unambiguous", or undefined`);
    return t;
  }
  i(S0e, "assertSourceType");
  function v0e(e, t) {
    let r = K4(e, t);
    if (r) {
      if (typeof r.name != "string")
        throw new Error(`${Ae(e)} set but does not contain "name" property string`);
      for (let s of Object.keys(r)) {
        let n = or(e, s), a = r[s];
        if (a != null && typeof a != "boolean" && typeof a != "string" && typeof a != "number")
          throw new Error(`${Ae(n)} must be null, undefined, a boolean, a string, or a number.`);
      }
    }
    return t;
  }
  i(v0e, "assertCallerMetadata");
  function P0e(e, t) {
    if (t !== void 0 && typeof t != "boolean" && (typeof t != "object" || !t))
      throw new Error(`${Ae(e)} must be a boolean, object, or undefined`);
    return t;
  }
  i(P0e, "assertInputSourceMap");
  function A0e(e, t) {
    if (t !== void 0 && typeof t != "string")
      throw new Error(`${Ae(e)} must be a string, or undefined`);
    return t;
  }
  i(A0e, "assertString");
  function C0e(e, t) {
    if (t !== void 0 && typeof t != "function")
      throw new Error(`${Ae(e)} must be a function, or undefined`);
    return t;
  }
  i(C0e, "assertFunction");
  function Sy(e, t) {
    if (t !== void 0 && typeof t != "boolean")
      throw new Error(`${Ae(e)} must be a boolean, or undefined`);
    return t;
  }
  i(Sy, "assertBoolean");
  function K4(e, t) {
    if (t !== void 0 && (typeof t != "object" || Array.isArray(t) || !t))
      throw new Error(`${Ae(e)} must be an object, or undefined`);
    return t;
  }
  i(K4, "assertObject");
  function vy(e, t) {
    if (t != null && !Array.isArray(t))
      throw new Error(`${Ae(e)} must be an array, or undefined`);
    return t;
  }
  i(vy, "assertArray");
  function w0e(e, t) {
    let r = vy(e, t);
    return r?.forEach((s, n) => D0e(or(e, n), s)), r;
  }
  i(w0e, "assertIgnoreList");
  function D0e(e, t) {
    if (typeof t != "string" && typeof t != "function" && !(t instanceof RegExp))
      throw new Error(`${Ae(e)} must be an array of string/Function/RegExp values, or undefined`);
    return t;
  }
  i(D0e, "assertIgnoreItem");
  function _0e(e, t) {
    if (t === void 0)
      return t;
    if (Array.isArray(t))
      t.forEach((r, s) => {
        if (!zc(r))
          throw new Error(`${Ae(or(e, s))} must be a string/Function/RegExp.`);
      });
    else if (!zc(t))
      throw new Error(`${Ae(e)} must be a string/Function/RegExp, or an array of those`);
    return t;
  }
  i(_0e, "assertConfigApplicableTest");
  function zc(e) {
    return typeof e == "string" || typeof e == "function" || e instanceof RegExp;
  }
  i(zc, "checkValidTest");
  function I0e(e, t) {
    if (t !== void 0 && typeof t != "boolean" && typeof t != "string")
      throw new Error(`${Ae(e)} must be a undefined, a boolean, a string, got ${JSON.stringify(t)}`);
    return t;
  }
  i(I0e, "assertConfigFileSearch");
  function O0e(e, t) {
    if (t === void 0 || typeof t == "boolean")
      return t;
    if (Array.isArray(t))
      t.forEach((r, s) => {
        if (!zc(r))
          throw new Error(`${Ae(or(e, s))} must be a string/Function/RegExp.`);
      });
    else if (!zc(t))
      throw new Error(`${Ae(e)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(t)}`);
    return t;
  }
  i(O0e, "assertBabelrcSearch");
  function N0e(e, t) {
    let r = vy(e, t);
    return r && r.forEach((s, n) => B0e(or(e, n), s)), r;
  }
  i(N0e, "assertPluginList");
  function B0e(e, t) {
    if (Array.isArray(t)) {
      if (t.length === 0)
        throw new Error(`${Ae(e)} must include an object`);
      if (t.length > 3)
        throw new Error(`${Ae(e)} may only be a two-tuple or three-tuple`);
      if ($4(or(e, 0), t[0]), t.length > 1) {
        let r = t[1];
        if (r !== void 0 && r !== !1 && (typeof r != "object" || Array.isArray(r) || r === null))
          throw new Error(`${Ae(or(e, 1))} must be an object, false, or undefined`);
      }
      if (t.length === 3) {
        let r = t[2];
        if (r !== void 0 && typeof r != "string")
          throw new Error(`${Ae(or(e, 2))} must be a string, or undefined`);
      }
    } else
      $4(e, t);
    return t;
  }
  i(B0e, "assertPluginItem");
  function $4(e, t) {
    if ((typeof t != "object" || !t) && typeof t != "string" && typeof t != "function")
      throw new Error(`${Ae(e)} must be a string, object, function`);
    return t;
  }
  i($4, "assertPluginTarget");
  function k0e(e, t) {
    if ((0, Wo().isBrowsersQueryValid)(t)) return t;
    if (typeof t != "object" || !t || Array.isArray(t))
      throw new Error(`${Ae(e)} must be a string, an array of strings or an object`);
    let r = or(e, "browsers"), s = or(e, "esmodules");
    V4(r, t.browsers), Sy(s, t.esmodules);
    for (let n of Object.keys(t)) {
      let a = t[n], o = or(e, n);
      if (n === "esmodules") Sy(o, a);
      else if (n === "browsers") V4(o, a);
      else if (hasOwnProperty.call(Wo().TargetNames, n))
        F0e(o, a);
      else {
        let l = Object.keys(Wo().TargetNames).join(", ");
        throw new Error(`${Ae(o)} is not a valid target. Supported targets are ${l}`);
      }
    }
    return t;
  }
  i(k0e, "assertTargets");
  function V4(e, t) {
    if (t !== void 0 && !(0, Wo().isBrowsersQueryValid)(t))
      throw new Error(`${Ae(e)} must be undefined, a string or an array of strings`);
  }
  i(V4, "assertBrowsersList");
  function F0e(e, t) {
    if (!(typeof t == "number" && Math.round(t) === t) && typeof t != "string")
      throw new Error(`${Ae(e)} must be a string or an integer number`);
  }
  i(F0e, "assertBrowserVersion");
  function L0e(e, t) {
    if (t === void 0) return;
    if (typeof t != "object" || t === null)
      throw new Error(`${Ae(e)} must be an object or undefined.`);
    let r = e;
    do
      r = r.parent;
    while (r.type !== "root");
    let s = r.source === "preset";
    for (let n of Object.keys(t)) {
      let a = or(e, n);
      if (!g0e.assumptionsNames.has(n))
        throw new Error(`${Ae(a)} is not a supported assumption.`);
      if (typeof t[n] != "boolean")
        throw new Error(`${Ae(a)} must be a boolean.`);
      if (s && t[n] === !1)
        throw new Error(`${Ae(a)} cannot be set to 'false' inside presets.`);
    }
    return t;
  }
  i(L0e, "assertAssumptions");
});

// ../node_modules/@babel/core/lib/config/validation/options.js
var Yo = D((sa) => {
  "use strict";
  Object.defineProperty(sa, "__esModule", {
    value: !0
  });
  sa.assumptionsNames = void 0;
  sa.checkNoUnwrappedItemOptionPairs = K0e;
  sa.validate = R0e;
  var W4 = U4(), se = Py(), j0e = ei(), Y4 = {
    cwd: se.assertString,
    root: se.assertString,
    rootMode: se.assertRootMode,
    configFile: se.assertConfigFileSearch,
    caller: se.assertCallerMetadata,
    filename: se.assertString,
    filenameRelative: se.assertString,
    code: se.assertBoolean,
    ast: se.assertBoolean,
    cloneInputAst: se.assertBoolean,
    envName: se.assertString
  }, H4 = {
    babelrc: se.assertBoolean,
    babelrcRoots: se.assertBabelrcSearch
  }, J4 = {
    extends: se.assertString,
    ignore: se.assertIgnoreList,
    only: se.assertIgnoreList,
    targets: se.assertTargets,
    browserslistConfigFile: se.assertConfigFileSearch,
    browserslistEnv: se.assertString
  }, G4 = {
    inputSourceMap: se.assertInputSourceMap,
    presets: se.assertPluginList,
    plugins: se.assertPluginList,
    passPerPreset: se.assertBoolean,
    assumptions: se.assertAssumptions,
    env: $0e,
    overrides: V0e,
    test: se.assertConfigApplicableTest,
    include: se.assertConfigApplicableTest,
    exclude: se.assertConfigApplicableTest,
    retainLines: se.assertBoolean,
    comments: se.assertBoolean,
    shouldPrintComment: se.assertFunction,
    compact: se.assertCompact,
    minified: se.assertBoolean,
    auxiliaryCommentBefore: se.assertString,
    auxiliaryCommentAfter: se.assertString,
    sourceType: se.assertSourceType,
    wrapPluginVisitorMethod: se.assertFunction,
    highlightCode: se.assertBoolean,
    sourceMaps: se.assertSourceMaps,
    sourceMap: se.assertSourceMaps,
    sourceFileName: se.assertString,
    sourceRoot: se.assertString,
    parserOpts: se.assertObject,
    generatorOpts: se.assertObject
  };
  Object.assign(G4, {
    getModuleId: se.assertFunction,
    moduleRoot: se.assertString,
    moduleIds: se.assertBoolean,
    moduleId: se.assertString
  });
  var M0e = ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitive\
Hint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUnini\
tializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods",
  "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"], o_e = sa.
  assumptionsNames = new Set(M0e);
  function X4(e) {
    return e.type === "root" ? e.source : X4(e.parent);
  }
  i(X4, "getSource");
  function R0e(e, t, r) {
    try {
      return Ay({
        type: "root",
        source: e
      }, t);
    } catch (s) {
      let n = new j0e.default(s.message, r);
      throw s.code && (n.code = s.code), n;
    }
  }
  i(R0e, "validate");
  function Ay(e, t) {
    let r = X4(e);
    return U0e(t), Object.keys(t).forEach((s) => {
      let n = {
        type: "option",
        name: s,
        parent: e
      };
      if (r === "preset" && J4[s])
        throw new Error(`${(0, se.msg)(n)} is not allowed in preset options`);
      if (r !== "arguments" && Y4[s])
        throw new Error(`${(0, se.msg)(n)} is only allowed in root programmatic options`);
      if (r !== "arguments" && r !== "configfile" && H4[s])
        throw r === "babelrcfile" || r === "extendsfile" ? new Error(`${(0, se.msg)(n)} is not allowed in .babelrc or "extends"ed files, onl\
y in root programmatic options, or babel.config.js/config file options`) : new Error(`${(0, se.msg)(n)} is only allowed in root programmatic\
 options, or babel.config.js/config file options`);
      (G4[s] || J4[s] || H4[s] || Y4[s] || q0e)(n, t[s]);
    }), t;
  }
  i(Ay, "validateNested");
  function q0e(e) {
    let t = e.name;
    if (W4.default[t]) {
      let {
        message: r,
        version: s = 5
      } = W4.default[t];
      throw new Error(`Using removed Babel ${s} option: ${(0, se.msg)(e)} - ${r}`);
    } else {
      let r = new Error(`Unknown option: ${(0, se.msg)(e)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information ab\
out options.`);
      throw r.code = "BABEL_UNKNOWN_OPTION", r;
    }
  }
  i(q0e, "throwUnknownError");
  function U0e(e) {
    if (hasOwnProperty.call(e, "sourceMap") && hasOwnProperty.call(e, "sourceMaps"))
      throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
  }
  i(U0e, "assertNoDuplicateSourcemap");
  function $0e(e, t) {
    if (e.parent.type === "env")
      throw new Error(`${(0, se.msg)(e)} is not allowed inside of another .env block`);
    let r = e.parent, s = (0, se.assertObject)(e, t);
    if (s)
      for (let n of Object.keys(s)) {
        let a = (0, se.assertObject)((0, se.access)(e, n), s[n]);
        if (!a) continue;
        Ay({
          type: "env",
          name: n,
          parent: r
        }, a);
      }
    return s;
  }
  i($0e, "assertEnvSet");
  function V0e(e, t) {
    if (e.parent.type === "env")
      throw new Error(`${(0, se.msg)(e)} is not allowed inside an .env block`);
    if (e.parent.type === "overrides")
      throw new Error(`${(0, se.msg)(e)} is not allowed inside an .overrides block`);
    let r = e.parent, s = (0, se.assertArray)(e, t);
    if (s)
      for (let [n, a] of s.entries()) {
        let o = (0, se.access)(e, n), l = (0, se.assertObject)(o, a);
        if (!l) throw new Error(`${(0, se.msg)(o)} must be an object`);
        Ay({
          type: "overrides",
          index: n,
          parent: r
        }, l);
      }
    return s;
  }
  i(V0e, "assertOverridesList");
  function K0e(e, t, r, s) {
    if (t === 0) return;
    let n = e[t - 1], a = e[t];
    n.file && n.options === void 0 && typeof a.value == "object" && (s.message += `
- Maybe you meant to use
"${r}s": [
  ["${n.file.request}", ${JSON.stringify(a.value, void 0, 2)}]
]
To be a valid ${r}, its name and options should be wrapped in a pair of brackets`);
  }
  i(K0e, "checkNoUnwrappedItemOptionPairs");
});

// ../node_modules/@babel/core/lib/config/pattern-to-regex.js
var Iy = D((_y) => {
  "use strict";
  Object.defineProperty(_y, "__esModule", {
    value: !0
  });
  _y.default = H0e;
  function Qc() {
    let e = z("path");
    return Qc = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(Qc, "_path");
  var Ho = `\\${Qc().sep}`, Cy = `(?:${Ho}|$)`, wy = `[^${Ho}]+`, Dy = `(?:${wy}${Ho})`, Q4 = `(?:${wy}${Cy})`, W0e = `${Dy}*?`, Y0e = `${Dy}\
*?${Q4}?`;
  function z4(e) {
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  }
  i(z4, "escapeRegExp");
  function H0e(e, t) {
    let r = Qc().resolve(t, e).split(Qc().sep);
    return new RegExp(["^", ...r.map((s, n) => {
      let a = n === r.length - 1;
      return s === "**" ? a ? Y0e : W0e : s === "*" ? a ? Q4 : Dy : s.indexOf("*.") === 0 ? wy + z4(s.slice(1)) + (a ? Cy : Ho) : z4(s) + (a ?
      Cy : Ho);
    })].join(""));
  }
  i(H0e, "pathToPattern");
});

// ../node_modules/@babel/core/lib/config/printer.js
var tw = D((na) => {
  "use strict";
  Object.defineProperty(na, "__esModule", {
    value: !0
  });
  na.ConfigPrinter = na.ChainFormatter = void 0;
  function ew() {
    let e = ir();
    return ew = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(ew, "_gensync");
  var J0e = na.ChainFormatter = {
    Programmatic: 0,
    Config: 1
  }, Oy = {
    title(e, t, r) {
      let s = "";
      return e === J0e.Programmatic ? (s = "programmatic options", t && (s += " from " + t)) : s = "config " + r, s;
    },
    loc(e, t) {
      let r = "";
      return e != null && (r += `.overrides[${e}]`), t != null && (r += `.env["${t}"]`), r;
    },
    *optionsAndDescriptors(e) {
      let t = Object.assign({}, e.options);
      delete t.overrides, delete t.env;
      let r = [...yield* e.plugins()];
      r.length && (t.plugins = r.map((n) => Z4(n)));
      let s = [...yield* e.presets()];
      return s.length && (t.presets = [...s].map((n) => Z4(n))), JSON.stringify(t, void 0, 2);
    }
  };
  function Z4(e) {
    var t;
    let r = (t = e.file) == null ? void 0 : t.request;
    return r == null && (typeof e.value == "object" ? r = e.value : typeof e.value == "function" && (r = `[Function: ${e.value.toString().slice(
    0, 50)} ... ]`)), r == null && (r = "[Unknown]"), e.options === void 0 ? r : e.name == null ? [r, e.options] : [r, e.options, e.name];
  }
  i(Z4, "descriptorToConfig");
  var Ny = class e {
    static {
      i(this, "ConfigPrinter");
    }
    constructor() {
      this._stack = [];
    }
    configure(t, r, {
      callerName: s,
      filepath: n
    }) {
      return t ? (a, o, l) => {
        this._stack.push({
          type: r,
          callerName: s,
          filepath: n,
          content: a,
          index: o,
          envName: l
        });
      } : () => {
      };
    }
    static *format(t) {
      let r = Oy.title(t.type, t.callerName, t.filepath), s = Oy.loc(t.index, t.envName);
      s && (r += ` ${s}`);
      let n = yield* Oy.optionsAndDescriptors(t.content);
      return `${r}
${n}`;
    }
    *output() {
      return this._stack.length === 0 ? "" : (yield* ew().all(this._stack.map((r) => e.format(r)))).join(`

`);
    }
  };
  na.ConfigPrinter = Ny;
});

// ../node_modules/@babel/core/lib/config/config-chain.js
var $y = D((aa) => {
  "use strict";
  Object.defineProperty(aa, "__esModule", {
    value: !0
  });
  aa.buildPresetChain = z0e;
  aa.buildPresetChainWalker = void 0;
  aa.buildRootChain = she;
  function nw() {
    let e = z("path");
    return nw = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(nw, "_path");
  function iw() {
    let e = Fn();
    return iw = /* @__PURE__ */ i(function() {
      return e;
    }, "_debug"), e;
  }
  i(iw, "_debug");
  var Ly = Yo(), aw = Iy(), Go = tw(), G0e = ws(), X0e = ei(), Jo = Vo(), ct = Zn(), Sr = xy(), rw = iw()("babel:config:config-chain");
  function* z0e(e, t) {
    let r = yield* Q0e(e, t);
    return r ? {
      plugins: tp(r.plugins),
      presets: tp(r.presets),
      options: r.options.map((s) => ow(s)),
      files: /* @__PURE__ */ new Set()
    } : null;
  }
  i(z0e, "buildPresetChain");
  var Q0e = aa.buildPresetChainWalker = Uy({
    root: /* @__PURE__ */ i((e) => Z0e(e), "root"),
    env: /* @__PURE__ */ i((e, t) => ehe(e)(t), "env"),
    overrides: /* @__PURE__ */ i((e, t) => the(e)(t), "overrides"),
    overridesEnv: /* @__PURE__ */ i((e, t, r) => rhe(e)(t)(r), "overridesEnv"),
    createLogger: /* @__PURE__ */ i(() => () => {
    }, "createLogger")
  }), Z0e = (0, ct.makeWeakCacheSync)((e) => jy(e, e.alias, Sr.createUncachedDescriptors)), ehe = (0, ct.makeWeakCacheSync)((e) => (0, ct.makeStrongCacheSync)(
  (t) => My(e, e.alias, Sr.createUncachedDescriptors, t))), the = (0, ct.makeWeakCacheSync)((e) => (0, ct.makeStrongCacheSync)((t) => Ry(e, e.
  alias, Sr.createUncachedDescriptors, t))), rhe = (0, ct.makeWeakCacheSync)((e) => (0, ct.makeStrongCacheSync)((t) => (0, ct.makeStrongCacheSync)(
  (r) => qy(e, e.alias, Sr.createUncachedDescriptors, t, r))));
  function* she(e, t) {
    let r, s, n = new Go.ConfigPrinter(), a = yield* lhe({
      options: e,
      dirname: t.cwd
    }, t, void 0, n);
    if (!a) return null;
    let o = yield* n.output(), l;
    typeof e.configFile == "string" ? l = yield* (0, Jo.loadConfig)(e.configFile, t.cwd, t.envName, t.caller) : e.configFile !== !1 && (l = yield* (0, Jo.
    findRootConfig)(t.root, t.envName, t.caller));
    let {
      babelrc: u,
      babelrcRoots: c
    } = e, p = t.cwd, f = ep(), h = new Go.ConfigPrinter();
    if (l) {
      let _ = ihe(l), N = yield* ky(_, t, void 0, h);
      if (!N) return null;
      r = yield* h.output(), u === void 0 && (u = _.options.babelrc), c === void 0 && (p = _.dirname, c = _.options.babelrcRoots), ia(f, N);
    }
    let b, T, d = !1, g = ep();
    if ((u === !0 || u === void 0) && typeof t.filename == "string") {
      let _ = yield* (0, Jo.findPackageData)(t.filename);
      if (_ && nhe(t, _, c, p)) {
        if ({
          ignore: b,
          config: T
        } = yield* (0, Jo.findRelativeConfig)(_, t.envName, t.caller), b && g.files.add(b.filepath), b && lw(t, b.ignore, null, b.dirname) &&
        (d = !0), T && !d) {
          let N = ahe(T), k = new Go.ConfigPrinter(), j = yield* ky(N, t, void 0, k);
          j ? (s = yield* k.output(), ia(g, j)) : d = !0;
        }
        T && d && g.files.add(T.filepath);
      }
    }
    t.showConfig && console.log(`Babel configs on "${t.filename}" (ascending priority):
` + [r, s, o].filter((_) => !!_).join(`

`) + `
-----End Babel configs-----`);
    let E = ia(ia(ia(ep(), f), g), a);
    return {
      plugins: d ? [] : tp(E.plugins),
      presets: d ? [] : tp(E.presets),
      options: d ? [] : E.options.map((_) => ow(_)),
      fileHandling: d ? "ignored" : "transpile",
      ignore: b || void 0,
      babelrc: T || void 0,
      config: l || void 0,
      files: E.files
    };
  }
  i(she, "buildRootChain");
  function nhe(e, t, r, s) {
    if (typeof r == "boolean") return r;
    let n = e.root;
    if (r === void 0)
      return t.directories.includes(n);
    let a = r;
    return Array.isArray(a) || (a = [a]), a = a.map((o) => typeof o == "string" ? nw().resolve(s, o) : o), a.length === 1 && a[0] === n ? t.
    directories.includes(n) : a.some((o) => (typeof o == "string" && (o = (0, aw.default)(o, s)), t.directories.some((l) => uw(o, s, l, e))));
  }
  i(nhe, "babelrcLoadEnabled");
  var ihe = (0, ct.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, Ly.validate)("configfile", e.options, e.filepath)
  })), ahe = (0, ct.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, Ly.validate)("babelrcfile", e.options, e.filepath)
  })), ohe = (0, ct.makeWeakCacheSync)((e) => ({
    filepath: e.filepath,
    dirname: e.dirname,
    options: (0, Ly.validate)("extendsfile", e.options, e.filepath)
  })), lhe = Uy({
    root: /* @__PURE__ */ i((e) => jy(e, "base", Sr.createCachedDescriptors), "root"),
    env: /* @__PURE__ */ i((e, t) => My(e, "base", Sr.createCachedDescriptors, t), "env"),
    overrides: /* @__PURE__ */ i((e, t) => Ry(e, "base", Sr.createCachedDescriptors, t), "overrides"),
    overridesEnv: /* @__PURE__ */ i((e, t, r) => qy(e, "base", Sr.createCachedDescriptors, t, r), "overridesEnv"),
    createLogger: /* @__PURE__ */ i((e, t, r) => mhe(e, t, r), "createLogger")
  }), uhe = Uy({
    root: /* @__PURE__ */ i((e) => che(e), "root"),
    env: /* @__PURE__ */ i((e, t) => phe(e)(t), "env"),
    overrides: /* @__PURE__ */ i((e, t) => fhe(e)(t), "overrides"),
    overridesEnv: /* @__PURE__ */ i((e, t, r) => dhe(e)(t)(r), "overridesEnv"),
    createLogger: /* @__PURE__ */ i((e, t, r) => hhe(e.filepath, t, r), "createLogger")
  });
  function* ky(e, t, r, s) {
    let n = yield* uhe(e, t, r, s);
    return n?.files.add(e.filepath), n;
  }
  i(ky, "loadFileChain");
  var che = (0, ct.makeWeakCacheSync)((e) => jy(e, e.filepath, Sr.createUncachedDescriptors)), phe = (0, ct.makeWeakCacheSync)((e) => (0, ct.
  makeStrongCacheSync)((t) => My(e, e.filepath, Sr.createUncachedDescriptors, t))), fhe = (0, ct.makeWeakCacheSync)((e) => (0, ct.makeStrongCacheSync)(
  (t) => Ry(e, e.filepath, Sr.createUncachedDescriptors, t))), dhe = (0, ct.makeWeakCacheSync)((e) => (0, ct.makeStrongCacheSync)((t) => (0, ct.
  makeStrongCacheSync)((r) => qy(e, e.filepath, Sr.createUncachedDescriptors, t, r))));
  function hhe(e, t, r) {
    return r ? r.configure(t.showConfig, Go.ChainFormatter.Config, {
      filepath: e
    }) : () => {
    };
  }
  i(hhe, "buildFileLogger");
  function jy({
    dirname: e,
    options: t
  }, r, s) {
    return s(e, t, r);
  }
  i(jy, "buildRootDescriptors");
  function mhe(e, t, r) {
    var s;
    return r ? r.configure(t.showConfig, Go.ChainFormatter.Programmatic, {
      callerName: (s = t.caller) == null ? void 0 : s.name
    }) : () => {
    };
  }
  i(mhe, "buildProgrammaticLogger");
  function My({
    dirname: e,
    options: t
  }, r, s, n) {
    var a;
    let o = (a = t.env) == null ? void 0 : a[n];
    return o ? s(e, o, `${r}.env["${n}"]`) : null;
  }
  i(My, "buildEnvDescriptors");
  function Ry({
    dirname: e,
    options: t
  }, r, s, n) {
    var a;
    let o = (a = t.overrides) == null ? void 0 : a[n];
    if (!o) throw new Error("Assertion failure - missing override");
    return s(e, o, `${r}.overrides[${n}]`);
  }
  i(Ry, "buildOverrideDescriptors");
  function qy({
    dirname: e,
    options: t
  }, r, s, n, a) {
    var o, l;
    let u = (o = t.overrides) == null ? void 0 : o[n];
    if (!u) throw new Error("Assertion failure - missing override");
    let c = (l = u.env) == null ? void 0 : l[a];
    return c ? s(e, c, `${r}.overrides[${n}].env["${a}"]`) : null;
  }
  i(qy, "buildOverrideEnvDescriptors");
  function Uy({
    root: e,
    env: t,
    overrides: r,
    overridesEnv: s,
    createLogger: n
  }) {
    return /* @__PURE__ */ i(function* (o, l, u = /* @__PURE__ */ new Set(), c) {
      let {
        dirname: p
      } = o, f = [], h = e(o);
      if (Zc(h, p, l, o.filepath)) {
        f.push({
          config: h,
          envName: void 0,
          index: void 0
        });
        let d = t(o, l.envName);
        d && Zc(d, p, l, o.filepath) && f.push({
          config: d,
          envName: l.envName,
          index: void 0
        }), (h.options.overrides || []).forEach((g, E) => {
          let _ = r(o, E);
          if (Zc(_, p, l, o.filepath)) {
            f.push({
              config: _,
              index: E,
              envName: void 0
            });
            let N = s(o, E, l.envName);
            N && Zc(N, p, l, o.filepath) && f.push({
              config: N,
              index: E,
              envName: l.envName
            });
          }
        });
      }
      if (f.some(({
        config: {
          options: {
            ignore: d,
            only: g
          }
        }
      }) => lw(l, d, g, p)))
        return null;
      let b = ep(), T = n(o, l, c);
      for (let {
        config: d,
        index: g,
        envName: E
      } of f) {
        if (!(yield* yhe(b, d.options, p, l, u, c)))
          return null;
        T(d, g, E), yield* bhe(b, d);
      }
      return b;
    }, "chainWalker");
  }
  i(Uy, "makeChainWalker");
  function* yhe(e, t, r, s, n, a) {
    if (t.extends === void 0) return !0;
    let o = yield* (0, Jo.loadConfig)(t.extends, r, s.envName, s.caller);
    if (n.has(o))
      throw new Error(`Configuration cycle detected loading ${o.filepath}.
File already loaded following the config chain:
` + Array.from(n, (u) => ` - ${u.filepath}`).join(`
`));
    n.add(o);
    let l = yield* ky(ohe(o), s, n, a);
    return n.delete(o), l ? (ia(e, l), !0) : !1;
  }
  i(yhe, "mergeExtendsChain");
  function ia(e, t) {
    e.options.push(...t.options), e.plugins.push(...t.plugins), e.presets.push(...t.presets);
    for (let r of t.files)
      e.files.add(r);
    return e;
  }
  i(ia, "mergeChain");
  function* bhe(e, {
    options: t,
    plugins: r,
    presets: s
  }) {
    return e.options.push(t), e.plugins.push(...yield* r()), e.presets.push(...yield* s()), e;
  }
  i(bhe, "mergeChainOpts");
  function ep() {
    return {
      options: [],
      presets: [],
      plugins: [],
      files: /* @__PURE__ */ new Set()
    };
  }
  i(ep, "emptyChain");
  function ow(e) {
    let t = Object.assign({}, e);
    return delete t.extends, delete t.env, delete t.overrides, delete t.plugins, delete t.presets, delete t.passPerPreset, delete t.ignore, delete t.
    only, delete t.test, delete t.include, delete t.exclude, hasOwnProperty.call(t, "sourceMap") && (t.sourceMaps = t.sourceMap, delete t.sourceMap),
    t;
  }
  i(ow, "normalizeOptions");
  function tp(e) {
    let t = /* @__PURE__ */ new Map(), r = [];
    for (let s of e)
      if (typeof s.value == "function") {
        let n = s.value, a = t.get(n);
        a || (a = /* @__PURE__ */ new Map(), t.set(n, a));
        let o = a.get(s.name);
        o ? o.value = s : (o = {
          value: s
        }, r.push(o), s.ownPass || a.set(s.name, o));
      } else
        r.push({
          value: s
        });
    return r.reduce((s, n) => (s.push(n.value), s), []);
  }
  i(tp, "dedupDescriptors");
  function Zc({
    options: e
  }, t, r, s) {
    return (e.test === void 0 || By(r, e.test, t, s)) && (e.include === void 0 || By(r, e.include, t, s)) && (e.exclude === void 0 || !By(r,
    e.exclude, t, s));
  }
  i(Zc, "configIsApplicable");
  function By(e, t, r, s) {
    let n = Array.isArray(t) ? t : [t];
    return Fy(e, n, r, s);
  }
  i(By, "configFieldIsApplicable");
  function sw(e, t) {
    return t instanceof RegExp ? String(t) : t;
  }
  i(sw, "ignoreListReplacer");
  function lw(e, t, r, s) {
    if (t && Fy(e, t, s)) {
      var n;
      let o = `No config is applied to "${(n = e.filename) != null ? n : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(
      t, sw)}\` from "${s}"`;
      return rw(o), e.showConfig && console.log(o), !0;
    }
    if (r && !Fy(e, r, s)) {
      var a;
      let o = `No config is applied to "${(a = e.filename) != null ? a : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(
      r, sw)}\` from "${s}"`;
      return rw(o), e.showConfig && console.log(o), !0;
    }
    return !1;
  }
  i(lw, "shouldIgnore");
  function Fy(e, t, r, s) {
    return t.some((n) => uw(n, r, e.filename, e, s));
  }
  i(Fy, "matchesPatterns");
  function uw(e, t, r, s, n) {
    if (typeof e == "function")
      return !!(0, G0e.endHiddenCallStack)(e)(r, {
        dirname: t,
        envName: s.envName,
        caller: s.caller
      });
    if (typeof r != "string")
      throw new X0e.default("Configuration contains string/RegExp pattern, but no filename was passed to Babel", n);
    return typeof e == "string" && (e = (0, aw.default)(e, t)), e.test(r);
  }
  i(uw, "matchPattern");
});

// ../node_modules/@babel/core/lib/config/validation/plugins.js
var cw = D((Vy) => {
  "use strict";
  Object.defineProperty(Vy, "__esModule", {
    value: !0
  });
  Vy.validatePluginObject = Ehe;
  var Fs = Py(), ghe = {
    name: Fs.assertString,
    manipulateOptions: Fs.assertFunction,
    pre: Fs.assertFunction,
    post: Fs.assertFunction,
    inherits: Fs.assertFunction,
    visitor: The,
    parserOverride: Fs.assertFunction,
    generatorOverride: Fs.assertFunction
  };
  function The(e, t) {
    let r = (0, Fs.assertObject)(e, t);
    if (r && (Object.keys(r).forEach((s) => {
      s !== "_exploded" && s !== "_verified" && xhe(s, r[s]);
    }), r.enter || r.exit))
      throw new Error(`${(0, Fs.msg)(e)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
    return r;
  }
  i(The, "assertVisitorMap");
  function xhe(e, t) {
    if (t && typeof t == "object")
      Object.keys(t).forEach((r) => {
        if (r !== "enter" && r !== "exit")
          throw new Error(`.visitor["${e}"] may only have .enter and/or .exit handlers.`);
      });
    else if (typeof t != "function")
      throw new Error(`.visitor["${e}"] must be a function`);
  }
  i(xhe, "assertVisitorHandler");
  function Ehe(e) {
    let t = {
      type: "root",
      source: "plugin"
    };
    return Object.keys(e).forEach((r) => {
      let s = ghe[r];
      if (s)
        s({
          type: "option",
          name: r,
          parent: t
        }, e[r]);
      else {
        let n = new Error(`.${r} is not a valid Plugin property`);
        throw n.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", n;
      }
    }), e;
  }
  i(Ehe, "validatePluginObject");
});

// ../node_modules/@babel/core/lib/config/helpers/environment.js
var Wy = D((Ky) => {
  "use strict";
  Object.defineProperty(Ky, "__esModule", {
    value: !0
  });
  Ky.getEnv = She;
  function She(e = "development") {
    return process.env.BABEL_ENV || process.env.NODE_ENV || e;
  }
  i(She, "getEnv");
});

// ../node_modules/@babel/core/lib/config/partial.js
var Yy = D((ip) => {
  "use strict";
  Object.defineProperty(ip, "__esModule", {
    value: !0
  });
  ip.default = fw;
  ip.loadPartialConfig = Nhe;
  function rp() {
    let e = z("path");
    return rp = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(rp, "_path");
  var vhe = wc(), Phe = dc(), pw = $o(), Ahe = $y(), Che = Wy(), whe = Yo(), sp = Vo(), Dhe = Ty(), _he = ["showIgnoredFiles"];
  function Ihe(e, t) {
    if (e == null) return {};
    var r = {};
    for (var s in e) if ({}.hasOwnProperty.call(e, s)) {
      if (t.indexOf(s) !== -1) continue;
      r[s] = e[s];
    }
    return r;
  }
  i(Ihe, "_objectWithoutPropertiesLoose");
  function Ohe(e, t) {
    switch (t) {
      case "root":
        return e;
      case "upward-optional": {
        let r = (0, sp.findConfigUpwards)(e);
        return r === null ? e : r;
      }
      case "upward": {
        let r = (0, sp.findConfigUpwards)(e);
        if (r !== null) return r;
        throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${e}".\

One of the following config files must be in the directory tree: "${sp.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
          code: "BABEL_ROOT_NOT_FOUND",
          dirname: e
        });
      }
      default:
        throw new Error("Assertion failure - unknown rootMode value.");
    }
  }
  i(Ohe, "resolveRootMode");
  function* fw(e) {
    if (e != null && (typeof e != "object" || Array.isArray(e)))
      throw new Error("Babel options must be an object, null, or undefined");
    let t = e ? (0, whe.validate)("arguments", e) : {}, {
      envName: r = (0, Che.getEnv)(),
      cwd: s = ".",
      root: n = ".",
      rootMode: a = "root",
      caller: o,
      cloneInputAst: l = !0
    } = t, u = rp().resolve(s), c = Ohe(rp().resolve(u, n), a), p = typeof t.filename == "string" ? rp().resolve(s, t.filename) : void 0, f = yield* (0, sp.
    resolveShowConfigPath)(u), h = {
      filename: p,
      cwd: u,
      root: c,
      envName: r,
      caller: o,
      showConfig: f === p
    }, b = yield* (0, Ahe.buildRootChain)(t, h);
    if (!b) return null;
    let T = {
      assumptions: {}
    };
    return b.options.forEach((g) => {
      (0, Phe.mergeOptions)(T, g);
    }), {
      options: Object.assign({}, T, {
        targets: (0, Dhe.resolveTargets)(T, c),
        cloneInputAst: l,
        babelrc: !1,
        configFile: !1,
        browserslistConfigFile: !1,
        passPerPreset: !1,
        envName: h.envName,
        cwd: h.cwd,
        root: h.root,
        rootMode: "root",
        filename: typeof h.filename == "string" ? h.filename : void 0,
        plugins: b.plugins.map((g) => (0, pw.createItemFromDescriptor)(g)),
        presets: b.presets.map((g) => (0, pw.createItemFromDescriptor)(g))
      }),
      context: h,
      fileHandling: b.fileHandling,
      ignore: b.ignore,
      babelrc: b.babelrc,
      config: b.config,
      files: b.files
    };
  }
  i(fw, "loadPrivatePartialConfig");
  function* Nhe(e) {
    let t = !1;
    if (typeof e == "object" && e !== null && !Array.isArray(e)) {
      var r = e;
      ({
        showIgnoredFiles: t
      } = r), e = Ihe(r, _he);
    }
    let s = yield* fw(e);
    if (!s) return null;
    let {
      options: n,
      babelrc: a,
      ignore: o,
      config: l,
      fileHandling: u,
      files: c
    } = s;
    return u === "ignored" && !t ? null : ((n.plugins || []).forEach((p) => {
      if (p.value instanceof vhe.default)
        throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
    }), new np(n, a ? a.filepath : void 0, o ? o.filepath : void 0, l ? l.filepath : void 0, u, c));
  }
  i(Nhe, "loadPartialConfig");
  var np = class {
    static {
      i(this, "PartialConfig");
    }
    constructor(t, r, s, n, a, o) {
      this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files =
      void 0, this.options = t, this.babelignore = s, this.babelrc = r, this.config = n, this.fileHandling = a, this.files = o, Object.freeze(
      this);
    }
    hasFilesystemConfig() {
      return this.babelrc !== void 0 || this.config !== void 0;
    }
  };
  Object.freeze(np.prototype);
});

// ../node_modules/@babel/core/lib/config/full.js
var Ew = D((ap) => {
  "use strict";
  Object.defineProperty(ap, "__esModule", {
    value: !0
  });
  ap.default = void 0;
  function yw() {
    let e = ir();
    return yw = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(yw, "_gensync");
  var Gy = un(), dw = dc(), Bhe = et(), bw = wc(), khe = $o(), Fhe = $y(), Qy = Ac();
  function Xy() {
    let e = nt();
    return Xy = /* @__PURE__ */ i(function() {
      return e;
    }, "_traverse"), e;
  }
  i(Xy, "_traverse");
  var Zy = Zn(), zy = Yo(), Lhe = cw(), gw = jm(), jhe = Yy(), Mhe = ei(), S_e = ap.default = yw()(/* @__PURE__ */ i(function* (t) {
    var r;
    let s = yield* (0, jhe.default)(t);
    if (!s)
      return null;
    let {
      options: n,
      context: a,
      fileHandling: o
    } = s;
    if (o === "ignored")
      return null;
    let l = {}, {
      plugins: u,
      presets: c
    } = n;
    if (!u || !c)
      throw new Error("Assertion failure - plugins and presets exist");
    let p = Object.assign({}, a, {
      targets: n.targets
    }), f = /* @__PURE__ */ i((k) => {
      let j = (0, khe.getItemDescriptor)(k);
      if (!j)
        throw new Error("Assertion failure - must be config item");
      return j;
    }, "toDescriptor"), h = c.map(f), b = u.map(f), T = [[]], d = [], g = [];
    if (yield* hw(a, /* @__PURE__ */ i(function* k(j, U) {
      let M = [];
      for (let G = 0; G < j.length; G++) {
        let ue = j[G];
        if (ue.options !== !1) {
          try {
            var K = yield* Khe(ue, p);
          } catch (te) {
            throw te.code === "BABEL_UNKNOWN_OPTION" && (0, zy.checkNoUnwrappedItemOptionPairs)(j, G, "preset", te), te;
          }
          g.push(K.externalDependencies), ue.ownPass ? M.push({
            preset: K.chain,
            pass: []
          }) : M.unshift({
            preset: K.chain,
            pass: U
          });
        }
      }
      if (M.length > 0) {
        T.splice(1, 0, ...M.map((G) => G.pass).filter((G) => G !== U));
        for (let {
          preset: G,
          pass: ue
        } of M) {
          if (!G || (ue.push(...G.plugins), yield* k(G.presets, ue))) return !0;
          G.options.forEach((De) => {
            (0, dw.mergeOptions)(l, De);
          });
        }
      }
    }, "recursePresetDescriptors"))(h, T[0])) return null;
    let _ = l;
    (0, dw.mergeOptions)(_, n);
    let N = Object.assign({}, p, {
      assumptions: (r = _.assumptions) != null ? r : {}
    });
    return yield* hw(a, /* @__PURE__ */ i(function* () {
      T[0].unshift(...b);
      for (let U of T) {
        let M = [];
        d.push(M);
        for (let K = 0; K < U.length; K++) {
          let G = U[K];
          if (G.options !== !1) {
            try {
              var j = yield* xw(G, N);
            } catch (ue) {
              throw ue.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, zy.checkNoUnwrappedItemOptionPairs)(U, K, "plugin", ue), ue;
            }
            M.push(j), g.push(j.externalDependencies);
          }
        }
      }
    }, "loadPluginDescriptors"))(), _.plugins = d[0], _.presets = d.slice(1).filter((k) => k.length > 0).map((k) => ({
      plugins: k
    })), _.passPerPreset = _.presets.length > 0, {
      options: _,
      passes: d,
      externalDependencies: (0, Qy.finalize)(g)
    };
  }, "loadFullConfig"));
  function hw(e, t) {
    return function* (r, s) {
      try {
        return yield* t(r, s);
      } catch (a) {
        if (!/^\[BABEL\]/.test(a.message)) {
          var n;
          a.message = `[BABEL] ${(n = e.filename) != null ? n : "unknown file"}: ${a.message}`;
        }
        throw a;
      }
    };
  }
  i(hw, "enhanceError");
  var Tw = /* @__PURE__ */ i((e) => (0, Zy.makeWeakCache)(function* ({
    value: t,
    options: r,
    dirname: s,
    alias: n
  }, a) {
    if (r === !1) throw new Error("Assertion failure");
    r = r || {};
    let o = [], l = t;
    if (typeof t == "function") {
      let u = (0, Gy.maybeAsync)(t, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), c = Object.assign(
      {}, Bhe, e(a, o));
      try {
        l = yield* u(c, r, s);
      } catch (p) {
        throw n && (p.message += ` (While processing: ${JSON.stringify(n)})`), p;
      }
    }
    if (!l || typeof l != "object")
      throw new Error("Plugin/Preset did not return an object.");
    if ((0, Gy.isThenable)(l))
      throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you\
're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". \
(While processing: ${JSON.stringify(n)})`);
    if (o.length > 0 && (!a.configured() || a.mode() === "forever")) {
      let u = `A plugin/preset has external untracked dependencies (${o[0]}), but the cache `;
      throw a.configured() ? u += " has been configured to never be invalidated. " : u += "has not been configured to be invalidated when th\
e external dependencies change. ", u += `Plugins/presets should configure their cache to be invalidated when the external dependencies chang\
e, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(n)})`, new Error(u);
    }
    return {
      value: l,
      options: r,
      dirname: s,
      alias: n,
      externalDependencies: (0, Qy.finalize)(o)
    };
  }), "makeDescriptorLoader"), Rhe = Tw(gw.makePluginAPI), qhe = Tw(gw.makePresetAPI), Uhe = (0, Zy.makeWeakCache)(function* ({
    value: e,
    options: t,
    dirname: r,
    alias: s,
    externalDependencies: n
  }, a) {
    let o = (0, Lhe.validatePluginObject)(e), l = Object.assign({}, o);
    if (l.visitor && (l.visitor = Xy().default.explode(Object.assign({}, l.visitor))), l.inherits) {
      let u = {
        name: void 0,
        alias: `${s}$inherits`,
        value: l.inherits,
        options: t,
        dirname: r
      }, c = yield* (0, Gy.forwardAsync)(xw, (p) => a.invalidate((f) => p(u, f)));
      l.pre = Jy(c.pre, l.pre), l.post = Jy(c.post, l.post), l.manipulateOptions = Jy(c.manipulateOptions, l.manipulateOptions), l.visitor =
      Xy().default.visitors.merge([c.visitor || {}, l.visitor || {}]), c.externalDependencies.length > 0 && (n.length === 0 ? n = c.externalDependencies :
      n = (0, Qy.finalize)([n, c.externalDependencies]));
    }
    return new bw.default(l, t, s, n);
  });
  function* xw(e, t) {
    if (e.value instanceof bw.default) {
      if (e.options)
        throw new Error("Passed options to an existing Plugin instance will not work.");
      return e.value;
    }
    return yield* Uhe(yield* Rhe(e, t), t);
  }
  i(xw, "loadPluginDescriptor");
  var Hy = /* @__PURE__ */ i((e) => e && typeof e != "function", "needsFilename"), mw = /* @__PURE__ */ i((e, t) => {
    if (Hy(e.test) || Hy(e.include) || Hy(e.exclude)) {
      let r = t.name ? `"${t.name}"` : "/* your preset */";
      throw new Mhe.default([`Preset ${r} requires a filename to be set when babel is called directly,`, "```", `babel.transformSync(code, {\
 filename: 'file.ts', presets: [${r}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join(`
`));
    }
  }, "validateIfOptionNeedsFilename"), $he = /* @__PURE__ */ i((e, t, r) => {
    if (!t.filename) {
      var s;
      let {
        options: n
      } = e;
      mw(n, r), (s = n.overrides) == null || s.forEach((a) => mw(a, r));
    }
  }, "validatePreset"), Vhe = (0, Zy.makeWeakCacheSync)(({
    value: e,
    dirname: t,
    alias: r,
    externalDependencies: s
  }) => ({
    options: (0, zy.validate)("preset", e),
    alias: r,
    dirname: t,
    externalDependencies: s
  }));
  function* Khe(e, t) {
    let r = Vhe(yield* qhe(e, t));
    return $he(r, t, e), {
      chain: yield* (0, Fhe.buildPresetChain)(r, t),
      externalDependencies: r.externalDependencies
    };
  }
  i(Khe, "loadPresetDescriptor");
  function Jy(e, t) {
    return e ? t ? function(...r) {
      let s = e.apply(this, r);
      return s && typeof s.then == "function" ? s.then(() => t.apply(this, r)) : t.apply(this, r);
    } : e : t;
  }
  i(Jy, "chainMaybeAsync");
});

// ../node_modules/@babel/core/lib/config/index.js
var oa = D((Pr) => {
  "use strict";
  Object.defineProperty(Pr, "__esModule", {
    value: !0
  });
  Pr.createConfigItem = Zhe;
  Pr.createConfigItemAsync = Qhe;
  Pr.createConfigItemSync = Aw;
  Object.defineProperty(Pr, "default", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Sw.default;
    }, "get")
  });
  Pr.loadOptions = zhe;
  Pr.loadOptionsAsync = Xhe;
  Pr.loadOptionsSync = Pw;
  Pr.loadPartialConfig = Jhe;
  Pr.loadPartialConfigAsync = Hhe;
  Pr.loadPartialConfigSync = vw;
  function cp() {
    let e = ir();
    return cp = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(cp, "_gensync");
  var Sw = Ew(), Whe = Yy(), Yhe = $o(), vr = ws(), op = cp()(Whe.loadPartialConfig);
  function Hhe(...e) {
    return (0, vr.beginHiddenCallStack)(op.async)(...e);
  }
  i(Hhe, "loadPartialConfigAsync");
  function vw(...e) {
    return (0, vr.beginHiddenCallStack)(op.sync)(...e);
  }
  i(vw, "loadPartialConfigSync");
  function Jhe(e, t) {
    if (t !== void 0)
      (0, vr.beginHiddenCallStack)(op.errback)(e, t);
    else if (typeof e == "function")
      (0, vr.beginHiddenCallStack)(op.errback)(void 0, e);
    else
      return vw(e);
  }
  i(Jhe, "loadPartialConfig");
  function* Ghe(e) {
    var t;
    let r = yield* (0, Sw.default)(e);
    return (t = r?.options) != null ? t : null;
  }
  i(Ghe, "loadOptionsImpl");
  var lp = cp()(Ghe);
  function Xhe(...e) {
    return (0, vr.beginHiddenCallStack)(lp.async)(...e);
  }
  i(Xhe, "loadOptionsAsync");
  function Pw(...e) {
    return (0, vr.beginHiddenCallStack)(lp.sync)(...e);
  }
  i(Pw, "loadOptionsSync");
  function zhe(e, t) {
    if (t !== void 0)
      (0, vr.beginHiddenCallStack)(lp.errback)(e, t);
    else if (typeof e == "function")
      (0, vr.beginHiddenCallStack)(lp.errback)(void 0, e);
    else
      return Pw(e);
  }
  i(zhe, "loadOptions");
  var up = cp()(Yhe.createConfigItem);
  function Qhe(...e) {
    return (0, vr.beginHiddenCallStack)(up.async)(...e);
  }
  i(Qhe, "createConfigItemAsync");
  function Aw(...e) {
    return (0, vr.beginHiddenCallStack)(up.sync)(...e);
  }
  i(Aw, "createConfigItemSync");
  function Zhe(e, t, r) {
    if (r !== void 0)
      (0, vr.beginHiddenCallStack)(up.errback)(e, t, r);
    else if (typeof t == "function")
      (0, vr.beginHiddenCallStack)(up.errback)(e, void 0, r);
    else
      return Aw(e, t);
  }
  i(Zhe, "createConfigItem");
});

// ../node_modules/@babel/core/lib/transformation/plugin-pass.js
var Cw = D((pp) => {
  "use strict";
  Object.defineProperty(pp, "__esModule", {
    value: !0
  });
  pp.default = void 0;
  var Xo = class {
    static {
      i(this, "PluginPass");
    }
    constructor(t, r, s, n) {
      this._map = /* @__PURE__ */ new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0,
      this.isAsync = void 0, this.key = r, this.file = t, this.opts = s || {}, this.cwd = t.opts.cwd, this.filename = t.opts.filename, this.
      isAsync = n;
    }
    set(t, r) {
      this._map.set(t, r);
    }
    get(t) {
      return this._map.get(t);
    }
    availableHelper(t, r) {
      return this.file.availableHelper(t, r);
    }
    addHelper(t) {
      return this.file.addHelper(t);
    }
    buildCodeFrameError(t, r, s) {
      return this.file.buildCodeFrameError(t, r, s);
    }
  };
  pp.default = Xo;
  Xo.prototype.getModuleName = /* @__PURE__ */ i(function() {
    return this.file.getModuleName();
  }, "getModuleName"), Xo.prototype.addImport = /* @__PURE__ */ i(function() {
    this.file.addImport();
  }, "addImport");
});

// ../node_modules/@babel/core/lib/transformation/block-hoist-plugin.js
var Ow = D((t2) => {
  "use strict";
  Object.defineProperty(t2, "__esModule", {
    value: !0
  });
  t2.default = t1e;
  function _w() {
    let e = nt();
    return _w = /* @__PURE__ */ i(function() {
      return e;
    }, "_traverse"), e;
  }
  i(_w, "_traverse");
  var e1e = wc(), e2, ww = {
    name: "internal.blockHoist",
    visitor: {
      Block: {
        exit({
          node: e
        }) {
          e.body = Dw(e.body);
        }
      },
      SwitchCase: {
        exit({
          node: e
        }) {
          e.consequent = Dw(e.consequent);
        }
      }
    }
  };
  function Dw(e) {
    let t = Math.pow(2, 30) - 1, r = !1;
    for (let s = 0; s < e.length; s++) {
      let n = e[s], a = Iw(n);
      if (a > t) {
        r = !0;
        break;
      }
      t = a;
    }
    return r ? r1e(e.slice()) : e;
  }
  i(Dw, "performHoisting");
  function t1e() {
    return e2 || (e2 = new e1e.default(Object.assign({}, ww, {
      visitor: _w().default.explode(ww.visitor)
    }), {})), e2;
  }
  i(t1e, "loadBlockHoistPlugin");
  function Iw(e) {
    let t = e?._blockHoist;
    return t == null ? 1 : t === !0 ? 2 : t;
  }
  i(Iw, "priority");
  function r1e(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let n = 0; n < e.length; n++) {
      let a = e[n], o = Iw(a);
      (t[o] || (t[o] = [])).push(a);
    }
    let r = Object.keys(t).map((n) => +n).sort((n, a) => a - n), s = 0;
    for (let n of r) {
      let a = t[n];
      for (let o of a)
        e[s++] = o;
    }
    return e;
  }
  i(r1e, "stableSort");
});

// ../node_modules/@babel/core/lib/transformation/normalize-opts.js
var s2 = D((r2) => {
  "use strict";
  Object.defineProperty(r2, "__esModule", {
    value: !0
  });
  r2.default = s1e;
  function fp() {
    let e = z("path");
    return fp = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(fp, "_path");
  function s1e(e) {
    let {
      filename: t,
      cwd: r,
      filenameRelative: s = typeof t == "string" ? fp().relative(r, t) : "unknown",
      sourceType: n = "module",
      inputSourceMap: a,
      sourceMaps: o = !!a,
      sourceRoot: l = e.options.moduleRoot,
      sourceFileName: u = fp().basename(s),
      comments: c = !0,
      compact: p = "auto"
    } = e.options, f = e.options, h = Object.assign({}, f, {
      parserOpts: Object.assign({
        sourceType: fp().extname(s) === ".mjs" ? "module" : n,
        sourceFileName: t,
        plugins: []
      }, f.parserOpts),
      generatorOpts: Object.assign({
        filename: t,
        auxiliaryCommentBefore: f.auxiliaryCommentBefore,
        auxiliaryCommentAfter: f.auxiliaryCommentAfter,
        retainLines: f.retainLines,
        comments: c,
        shouldPrintComment: f.shouldPrintComment,
        compact: p,
        minified: f.minified,
        sourceMaps: !!o,
        sourceRoot: l,
        sourceFileName: u
      }, f.generatorOpts)
    });
    for (let b of e.passes)
      for (let T of b)
        T.manipulateOptions && T.manipulateOptions(h, h.parserOpts);
    return h;
  }
  i(s1e, "normalizeOptions");
});

// ../node_modules/convert-source-map/index.js
var n2 = D((rt) => {
  "use strict";
  Object.defineProperty(rt, "commentRegex", {
    get: /* @__PURE__ */ i(function() {
      return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
    }, "getCommentRegex")
  });
  Object.defineProperty(rt, "mapFileCommentRegex", {
    get: /* @__PURE__ */ i(function() {
      return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
    }, "getMapFileCommentRegex")
  });
  var dp;
  typeof Buffer < "u" ? typeof Buffer.from == "function" ? dp = n1e : dp = i1e : dp = a1e;
  function n1e(e) {
    return Buffer.from(e, "base64").toString();
  }
  i(n1e, "decodeBase64WithBufferFrom");
  function i1e(e) {
    if (typeof value == "number")
      throw new TypeError("The value to decode must not be of type number.");
    return new Buffer(e, "base64").toString();
  }
  i(i1e, "decodeBase64WithNewBuffer");
  function a1e(e) {
    return decodeURIComponent(escape(atob(e)));
  }
  i(a1e, "decodeBase64WithAtob");
  function o1e(e) {
    return e.split(",").pop();
  }
  i(o1e, "stripComment");
  function l1e(e, t) {
    var r = rt.mapFileCommentRegex.exec(e), s = r[1] || r[2];
    try {
      var e = t(s);
      return e != null && typeof e.catch == "function" ? e.catch(n) : e;
    } catch (a) {
      n(a);
    }
    function n(a) {
      throw new Error("An error occurred while trying to read the map file at " + s + `
` + a.stack);
    }
    i(n, "throwError");
  }
  i(l1e, "readFromFileMap");
  function Ft(e, t) {
    t = t || {}, t.hasComment && (e = o1e(e)), t.encoding === "base64" ? e = dp(e) : t.encoding === "uri" && (e = decodeURIComponent(e)), (t.
    isJSON || t.encoding) && (e = JSON.parse(e)), this.sourcemap = e;
  }
  i(Ft, "Converter");
  Ft.prototype.toJSON = function(e) {
    return JSON.stringify(this.sourcemap, null, e);
  };
  typeof Buffer < "u" ? typeof Buffer.from == "function" ? Ft.prototype.toBase64 = u1e : Ft.prototype.toBase64 = c1e : Ft.prototype.toBase64 =
  p1e;
  function u1e() {
    var e = this.toJSON();
    return Buffer.from(e, "utf8").toString("base64");
  }
  i(u1e, "encodeBase64WithBufferFrom");
  function c1e() {
    var e = this.toJSON();
    if (typeof e == "number")
      throw new TypeError("The json to encode must not be of type number.");
    return new Buffer(e, "utf8").toString("base64");
  }
  i(c1e, "encodeBase64WithNewBuffer");
  function p1e() {
    var e = this.toJSON();
    return btoa(unescape(encodeURIComponent(e)));
  }
  i(p1e, "encodeBase64WithBtoa");
  Ft.prototype.toURI = function() {
    var e = this.toJSON();
    return encodeURIComponent(e);
  };
  Ft.prototype.toComment = function(e) {
    var t, r, s;
    return e != null && e.encoding === "uri" ? (t = "", r = this.toURI()) : (t = ";base64", r = this.toBase64()), s = "sourceMappingURL=data\
:application/json;charset=utf-8" + t + "," + r, e != null && e.multiline ? "/*# " + s + " */" : "//# " + s;
  };
  Ft.prototype.toObject = function() {
    return JSON.parse(this.toJSON());
  };
  Ft.prototype.addProperty = function(e, t) {
    if (this.sourcemap.hasOwnProperty(e)) throw new Error('property "' + e + '" already exists on the sourcemap, use set property instead');
    return this.setProperty(e, t);
  };
  Ft.prototype.setProperty = function(e, t) {
    return this.sourcemap[e] = t, this;
  };
  Ft.prototype.getProperty = function(e) {
    return this.sourcemap[e];
  };
  rt.fromObject = function(e) {
    return new Ft(e);
  };
  rt.fromJSON = function(e) {
    return new Ft(e, { isJSON: !0 });
  };
  rt.fromURI = function(e) {
    return new Ft(e, { encoding: "uri" });
  };
  rt.fromBase64 = function(e) {
    return new Ft(e, { encoding: "base64" });
  };
  rt.fromComment = function(e) {
    var t, r;
    return e = e.replace(/^\/\*/g, "//").replace(/\*\/$/g, ""), t = rt.commentRegex.exec(e), r = t && t[4] || "uri", new Ft(e, { encoding: r,
    hasComment: !0 });
  };
  function Nw(e) {
    return new Ft(e, { isJSON: !0 });
  }
  i(Nw, "makeConverter");
  rt.fromMapFileComment = function(e, t) {
    if (typeof t == "string")
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://githu\
b.com/thlorenz/convert-source-map#upgrading"
      );
    var r = l1e(e, t);
    return r != null && typeof r.then == "function" ? r.then(Nw) : Nw(r);
  };
  rt.fromSource = function(e) {
    var t = e.match(rt.commentRegex);
    return t ? rt.fromComment(t.pop()) : null;
  };
  rt.fromMapFileSource = function(e, t) {
    if (typeof t == "string")
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github\
.com/thlorenz/convert-source-map#upgrading"
      );
    var r = e.match(rt.mapFileCommentRegex);
    return r ? rt.fromMapFileComment(r.pop(), t) : null;
  };
  rt.removeComments = function(e) {
    return e.replace(rt.commentRegex, "");
  };
  rt.removeMapFileComments = function(e) {
    return e.replace(rt.mapFileCommentRegex, "");
  };
  rt.generateMapFileComment = function(e, t) {
    var r = "sourceMappingURL=" + e;
    return t && t.multiline ? "/*# " + r + " */" : "//# " + r;
  };
});

// ../node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js
var Fw = D((i2) => {
  "use strict";
  Object.defineProperty(i2, "__esModule", {
    value: !0
  });
  i2.default = f1e;
  var kw = {
    asyncDoExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-async-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
      }
    },
    decimal: {
      syntax: {
        name: "@babel/plugin-syntax-decimal",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
      }
    },
    decorators: {
      syntax: {
        name: "@babel/plugin-syntax-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
      },
      transform: {
        name: "@babel/plugin-proposal-decorators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
      }
    },
    doExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-do-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
      }
    },
    exportDefaultFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
      },
      transform: {
        name: "@babel/plugin-proposal-export-default-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
      }
    },
    flow: {
      syntax: {
        name: "@babel/plugin-syntax-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
      },
      transform: {
        name: "@babel/preset-flow",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
      }
    },
    functionBind: {
      syntax: {
        name: "@babel/plugin-syntax-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
      },
      transform: {
        name: "@babel/plugin-proposal-function-bind",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
      }
    },
    functionSent: {
      syntax: {
        name: "@babel/plugin-syntax-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
      },
      transform: {
        name: "@babel/plugin-proposal-function-sent",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
      }
    },
    jsx: {
      syntax: {
        name: "@babel/plugin-syntax-jsx",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
      },
      transform: {
        name: "@babel/preset-react",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
      }
    },
    pipelineOperator: {
      syntax: {
        name: "@babel/plugin-syntax-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
      },
      transform: {
        name: "@babel/plugin-proposal-pipeline-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
      }
    },
    recordAndTuple: {
      syntax: {
        name: "@babel/plugin-syntax-record-and-tuple",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
      }
    },
    throwExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
      },
      transform: {
        name: "@babel/plugin-proposal-throw-expressions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
      }
    },
    typescript: {
      syntax: {
        name: "@babel/plugin-syntax-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
      },
      transform: {
        name: "@babel/preset-typescript",
        url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
      }
    }
  };
  Object.assign(kw, {
    asyncGenerators: {
      syntax: {
        name: "@babel/plugin-syntax-async-generators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
      },
      transform: {
        name: "@babel/plugin-transform-async-generator-functions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
      }
    },
    classProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
      }
    },
    classPrivateProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
      }
    },
    classPrivateMethods: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
      },
      transform: {
        name: "@babel/plugin-transform-private-methods",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
      }
    },
    classStaticBlock: {
      syntax: {
        name: "@babel/plugin-syntax-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
      },
      transform: {
        name: "@babel/plugin-transform-class-static-block",
        url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
      }
    },
    dynamicImport: {
      syntax: {
        name: "@babel/plugin-syntax-dynamic-import",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
      }
    },
    exportNamespaceFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
      },
      transform: {
        name: "@babel/plugin-transform-export-namespace-from",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
      }
    },
    importAssertions: {
      syntax: {
        name: "@babel/plugin-syntax-import-assertions",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
      }
    },
    importAttributes: {
      syntax: {
        name: "@babel/plugin-syntax-import-attributes",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
      }
    },
    importMeta: {
      syntax: {
        name: "@babel/plugin-syntax-import-meta",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
      }
    },
    logicalAssignment: {
      syntax: {
        name: "@babel/plugin-syntax-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
      },
      transform: {
        name: "@babel/plugin-transform-logical-assignment-operators",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
      }
    },
    moduleStringNames: {
      syntax: {
        name: "@babel/plugin-syntax-module-string-names",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
      }
    },
    numericSeparator: {
      syntax: {
        name: "@babel/plugin-syntax-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
      },
      transform: {
        name: "@babel/plugin-transform-numeric-separator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
      }
    },
    nullishCoalescingOperator: {
      syntax: {
        name: "@babel/plugin-syntax-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
      },
      transform: {
        name: "@babel/plugin-transform-nullish-coalescing-operator",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
      }
    },
    objectRestSpread: {
      syntax: {
        name: "@babel/plugin-syntax-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
      },
      transform: {
        name: "@babel/plugin-transform-object-rest-spread",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
      }
    },
    optionalCatchBinding: {
      syntax: {
        name: "@babel/plugin-syntax-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
      },
      transform: {
        name: "@babel/plugin-transform-optional-catch-binding",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
      }
    },
    optionalChaining: {
      syntax: {
        name: "@babel/plugin-syntax-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
      },
      transform: {
        name: "@babel/plugin-transform-optional-chaining",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
      }
    },
    privateIn: {
      syntax: {
        name: "@babel/plugin-syntax-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
      },
      transform: {
        name: "@babel/plugin-transform-private-property-in-object",
        url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
      }
    },
    regexpUnicodeSets: {
      syntax: {
        name: "@babel/plugin-syntax-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
      },
      transform: {
        name: "@babel/plugin-transform-unicode-sets-regex",
        url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
      }
    }
  });
  var Bw = /* @__PURE__ */ i(({
    name: e,
    url: t
  }) => `${e} (${t})`, "getNameURLCombination");
  function f1e(e, t, r, s) {
    let n = `Support for the experimental syntax '${e}' isn't currently enabled (${t.line}:${t.column + 1}):

` + r, a = kw[e];
    if (a) {
      let {
        syntax: l,
        transform: u
      } = a;
      if (l) {
        let c = Bw(l);
        if (u) {
          let p = Bw(u), f = u.name.startsWith("@babel/plugin") ? "plugins" : "presets";
          n += `

Add ${p} to the '${f}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${c} to the 'plugins' section to enable parsing.`;
        } else
          n += `

Add ${c} to the 'plugins' section of your Babel config to enable parsing.`;
      }
    }
    return n += `

If you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${s === "unknown" ? "<name of the input file>" : s} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.
`, n;
  }
  i(f1e, "generateMissingPluginMessage");
});

// ../node_modules/@babel/core/lib/parser/index.js
var l2 = D((o2) => {
  "use strict";
  Object.defineProperty(o2, "__esModule", {
    value: !0
  });
  o2.default = h1e;
  function a2() {
    let e = Bn();
    return a2 = /* @__PURE__ */ i(function() {
      return e;
    }, "_parser"), e;
  }
  i(a2, "_parser");
  function Lw() {
    let e = Za();
    return Lw = /* @__PURE__ */ i(function() {
      return e;
    }, "_codeFrame"), e;
  }
  i(Lw, "_codeFrame");
  var d1e = Fw();
  function* h1e(e, {
    parserOpts: t,
    highlightCode: r = !0,
    filename: s = "unknown"
  }, n) {
    try {
      let a = [];
      for (let o of e)
        for (let l of o) {
          let {
            parserOverride: u
          } = l;
          if (u) {
            let c = u(n, t, a2().parse);
            c !== void 0 && a.push(c);
          }
        }
      if (a.length === 0)
        return (0, a2().parse)(n, t);
      if (a.length === 1) {
        if (yield* [], typeof a[0].then == "function")
          throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're us\
ing a published plugin, you may need to upgrade your @babel/core version.");
        return a[0];
      }
      throw new Error("More than one plugin attempted to override parsing.");
    } catch (a) {
      a.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (a.message += `
Consider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.`);
      let {
        loc: o,
        missingPlugin: l
      } = a;
      if (o) {
        let u = (0, Lw().codeFrameColumns)(n, {
          start: {
            line: o.line,
            column: o.column + 1
          }
        }, {
          highlightCode: r
        });
        l ? a.message = `${s}: ` + (0, d1e.default)(l[0], o, u, s) : a.message = `${s}: ${a.message}

` + u, a.code = "BABEL_PARSE_ERROR";
      }
      throw a;
    }
  }
  i(h1e, "parser");
});

// ../node_modules/@babel/core/lib/transformation/util/clone-deep.js
var jw = D((p2) => {
  "use strict";
  Object.defineProperty(p2, "__esModule", {
    value: !0
  });
  p2.default = m1e;
  var hp = /* @__PURE__ */ new Set(), u2 = 0;
  function c2(e, t, r) {
    if (e !== null) {
      if (r) {
        if (t.has(e)) return t.get(e);
      } else if (++u2 > 250) {
        if (hp.has(e))
          throw u2 = 0, hp.clear(), new Error("Babel-deepClone: Cycles are not allowed in AST");
        hp.add(e);
      }
      let s;
      if (Array.isArray(e)) {
        s = new Array(e.length), r && t.set(e, s);
        for (let n = 0; n < e.length; n++)
          s[n] = typeof e[n] != "object" ? e[n] : c2(e[n], t, r);
      } else {
        s = {}, r && t.set(e, s);
        let n = Object.keys(e);
        for (let a = 0; a < n.length; a++) {
          let o = n[a];
          s[o] = typeof e[o] != "object" ? e[o] : c2(e[o], t, r || o === "leadingComments" || o === "innerComments" || o === "trailingCommen\
ts" || o === "extra");
        }
      }
      return r || u2-- > 250 && hp.delete(e), s;
    }
    return e;
  }
  i(c2, "deepClone");
  function m1e(e) {
    if (typeof e != "object") return e;
    try {
      return c2(e, /* @__PURE__ */ new Map(), !0);
    } catch {
      return structuredClone(e);
    }
  }
  i(m1e, "_default");
});

// ../node_modules/@babel/core/lib/transformation/normalize-file.js
var Vw = D((m2) => {
  "use strict";
  Object.defineProperty(m2, "__esModule", {
    value: !0
  });
  m2.default = S1e;
  function qw() {
    let e = z("fs");
    return qw = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs"), e;
  }
  i(qw, "_fs");
  function h2() {
    let e = z("path");
    return h2 = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(h2, "_path");
  function Uw() {
    let e = Fn();
    return Uw = /* @__PURE__ */ i(function() {
      return e;
    }, "_debug"), e;
  }
  i(Uw, "_debug");
  function $w() {
    let e = ce();
    return $w = /* @__PURE__ */ i(function() {
      return e;
    }, "_t"), e;
  }
  i($w, "_t");
  function mp() {
    let e = n2();
    return mp = /* @__PURE__ */ i(function() {
      return e;
    }, "_convertSourceMap"), e;
  }
  i(mp, "_convertSourceMap");
  var y1e = cm(), b1e = l2(), g1e = jw(), {
    file: T1e,
    traverseFast: x1e
  } = $w(), f2 = Uw()("babel:transform:file"), E1e = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,.*$/,
  Mw = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
  function* S1e(e, t, r, s) {
    if (r = `${r || ""}`, s) {
      if (s.type === "Program")
        s = T1e(s, [], []);
      else if (s.type !== "File")
        throw new Error("AST root must be a Program or File node");
      t.cloneInputAst && (s = (0, g1e.default)(s));
    } else
      s = yield* (0, b1e.default)(e, t, r);
    let n = null;
    if (t.inputSourceMap !== !1) {
      if (typeof t.inputSourceMap == "object" && (n = mp().fromObject(t.inputSourceMap)), !n) {
        let a = Rw(E1e, s);
        if (a)
          try {
            n = mp().fromComment("//" + a);
          } catch {
            f2("discarding unknown inline input sourcemap");
          }
      }
      if (!n) {
        let a = Rw(Mw, s);
        if (typeof t.filename == "string" && a)
          try {
            let o = Mw.exec(a), l = qw().readFileSync(h2().resolve(h2().dirname(t.filename), o[1]), "utf8");
            n = mp().fromJSON(l);
          } catch (o) {
            f2("discarding unknown file input sourcemap", o);
          }
        else a && f2("discarding un-loadable file input sourcemap");
      }
    }
    return new y1e.default(t, {
      code: r,
      ast: s,
      inputMap: n
    });
  }
  i(S1e, "normalizeFile");
  function d2(e, t, r) {
    return t && (t = t.filter(({
      value: s
    }) => e.test(s) ? (r = s, !1) : !0)), [t, r];
  }
  i(d2, "extractCommentsFromList");
  function Rw(e, t) {
    let r = null;
    return x1e(t, (s) => {
      [s.leadingComments, r] = d2(e, s.leadingComments, r), [s.innerComments, r] = d2(e, s.innerComments, r), [s.trailingComments, r] = d2(e,
      s.trailingComments, r);
    }), r;
  }
  i(Rw, "extractComments");
});

// ../node_modules/@jridgewell/remapping/dist/remapping.mjs
var Xw = {};
sf(Xw, {
  default: () => _1e
});
function Ww(e, t, r, s, n, a) {
  return { source: e, line: t, column: r, name: s, content: n, ignore: a };
}
function Yw(e, t, r, s, n) {
  return {
    map: e,
    sources: t,
    source: r,
    content: s,
    ignore: n
  };
}
function Hw(e, t) {
  return Yw(e, t, "", null, !1);
}
function P1e(e, t, r) {
  return Yw(null, v1e, e, t, r);
}
function A1e(e) {
  let t = new Tu({ file: e.map.file }), { sources: r, map: s } = e, n = s.names, a = Rr(s);
  for (let o = 0; o < a.length; o++) {
    let l = a[o];
    for (let u = 0; u < l.length; u++) {
      let c = l[u], p = c[0], f = Kw;
      if (c.length !== 1) {
        let _ = r[c[1]];
        if (f = Jw(
          _,
          c[2],
          c[3],
          c.length === 5 ? n[c[4]] : ""
        ), f == null) continue;
      }
      let { column: h, line: b, name: T, content: d, source: g, ignore: E } = f;
      jh(t, o, p, g, b, h, T), g && d != null && Mh(t, g, d), E && Rh(t, g, !0);
    }
  }
  return t;
}
function Jw(e, t, r, s) {
  if (!e.map)
    return Ww(e.source, t, r, s, e.content, e.ignore);
  let n = Bh(e.map, t, r);
  return n == null ? null : n.length === 1 ? Kw : Jw(
    e.sources[n[1]],
    n[2],
    n[3],
    n.length === 5 ? e.map.names[n[4]] : s
  );
}
function C1e(e) {
  return Array.isArray(e) ? e : [e];
}
function w1e(e, t) {
  let r = C1e(e).map((a) => new Ts(a, "")), s = r.pop();
  for (let a = 0; a < r.length; a++)
    if (r[a].sources.length > 1)
      throw new Error(
        `Transformation map ${a} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`
      );
  let n = Gw(s, t, "", 0);
  for (let a = r.length - 1; a >= 0; a--)
    n = Hw(r[a], [n]);
  return n;
}
function Gw(e, t, r, s) {
  let { resolvedSources: n, sourcesContent: a, ignoreList: o } = e, l = s + 1, u = n.map((c, p) => {
    let f = {
      importer: r,
      depth: l,
      source: c || "",
      content: void 0,
      ignore: void 0
    }, h = t(f.source, f), { source: b, content: T, ignore: d } = f;
    if (h) return Gw(new Ts(h, b), t, b, l);
    let g = T !== void 0 ? T : a ? a[p] : null, E = d !== void 0 ? d : o ? o.includes(p) : !1;
    return P1e(b, g, E);
  });
  return Hw(e, u);
}
function _1e(e, t, r) {
  let s = typeof r == "object" ? r : { excludeContent: !!r, decodedMappings: !1 }, n = w1e(e, t);
  return new D1e(A1e(n), s);
}
var Kw, v1e, D1e, zw = hl(() => {
  co();
  Eu();
  co();
  Eu();
  Kw = /* @__PURE__ */ Ww("", -1, -1, "", null, !1), v1e = [];
  i(Ww, "SegmentObject");
  i(Yw, "Source");
  i(Hw, "MapSource");
  i(P1e, "OriginalSource");
  i(A1e, "traceMappings");
  i(Jw, "originalPositionFor");
  i(C1e, "asArray");
  i(w1e, "buildSourceMapTree");
  i(Gw, "build");
  D1e = class {
    static {
      i(this, "SourceMap");
    }
    constructor(e, t) {
      let r = t.decodedMappings ? xu(e) : qh(e);
      this.version = r.version, this.file = r.file, this.mappings = r.mappings, this.names = r.names, this.ignoreList = r.ignoreList, this.sourceRoot =
      r.sourceRoot, this.sources = r.sources, t.excludeContent || (this.sourcesContent = r.sourcesContent);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  i(_1e, "remapping");
});

// ../node_modules/@babel/core/lib/transformation/file/merge-map.js
var eD = D((y2) => {
  "use strict";
  Object.defineProperty(y2, "__esModule", {
    value: !0
  });
  y2.default = I1e;
  function Zw() {
    let e = (zw(), nf(Xw));
    return Zw = /* @__PURE__ */ i(function() {
      return e;
    }, "_remapping"), e;
  }
  i(Zw, "_remapping");
  function I1e(e, t, r) {
    let s = r.replace(/\\/g, "/"), n = !1, a = Zw()(Qw(t), (o, l) => o === s && !n ? (n = !0, l.source = "", Qw(e)) : null);
    return typeof e.sourceRoot == "string" && (a.sourceRoot = e.sourceRoot), Object.assign({}, a);
  }
  i(I1e, "mergeSourceMap");
  function Qw(e) {
    return Object.assign({}, e, {
      sourceRoot: null
    });
  }
  i(Qw, "rootless");
});

// ../node_modules/@babel/core/lib/transformation/file/generate.js
var rD = D((g2) => {
  "use strict";
  Object.defineProperty(g2, "__esModule", {
    value: !0
  });
  g2.default = N1e;
  function tD() {
    let e = n2();
    return tD = /* @__PURE__ */ i(function() {
      return e;
    }, "_convertSourceMap"), e;
  }
  i(tD, "_convertSourceMap");
  function b2() {
    let e = bo();
    return b2 = /* @__PURE__ */ i(function() {
      return e;
    }, "_generator"), e;
  }
  i(b2, "_generator");
  var O1e = eD();
  function N1e(e, t) {
    let {
      opts: r,
      ast: s,
      code: n,
      inputMap: a
    } = t, {
      generatorOpts: o
    } = r;
    o.inputSourceMap = a?.toObject();
    let l = [];
    for (let f of e)
      for (let h of f) {
        let {
          generatorOverride: b
        } = h;
        if (b) {
          let T = b(s, o, n, b2().default);
          T !== void 0 && l.push(T);
        }
      }
    let u;
    if (l.length === 0)
      u = (0, b2().default)(s, o, n);
    else if (l.length === 1) {
      if (u = l[0], typeof u.then == "function")
        throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're usi\
ng a published plugin, you may need to upgrade your @babel/core version.");
    } else
      throw new Error("More than one plugin attempted to override codegen.");
    let {
      code: c,
      decodedMap: p = u.map
    } = u;
    return u.__mergedMap ? p = Object.assign({}, u.map) : p && (a ? p = (0, O1e.default)(a.toObject(), p, o.sourceFileName) : p = u.map), (r.
    sourceMaps === "inline" || r.sourceMaps === "both") && (c += `
` + tD().fromObject(p).toComment()), r.sourceMaps === "inline" && (p = null), {
      outputCode: c,
      outputMap: p
    };
  }
  i(N1e, "generateCode");
});

// ../node_modules/@babel/core/lib/transformation/index.js
var yp = D((E2) => {
  "use strict";
  Object.defineProperty(E2, "__esModule", {
    value: !0
  });
  E2.run = R1e;
  function x2() {
    let e = nt();
    return x2 = /* @__PURE__ */ i(function() {
      return e;
    }, "_traverse"), e;
  }
  i(x2, "_traverse");
  var B1e = Cw(), k1e = Ow(), F1e = s2(), L1e = Vw(), j1e = rD(), M1e = Ac(), T2 = un();
  function* R1e(e, t, r) {
    let s = yield* (0, L1e.default)(e.passes, (0, F1e.default)(e), t, r), n = s.opts;
    try {
      yield* q1e(s, e.passes);
    } catch (c) {
      var a;
      throw c.message = `${(a = n.filename) != null ? a : "unknown file"}: ${c.message}`, c.code || (c.code = "BABEL_TRANSFORM_ERROR"), c;
    }
    let o, l;
    try {
      n.code !== !1 && ({
        outputCode: o,
        outputMap: l
      } = (0, j1e.default)(e.passes, s));
    } catch (c) {
      var u;
      throw c.message = `${(u = n.filename) != null ? u : "unknown file"}: ${c.message}`, c.code || (c.code = "BABEL_GENERATE_ERROR"), c;
    }
    return {
      metadata: s.metadata,
      options: n,
      ast: n.ast === !0 ? s.ast : null,
      code: o === void 0 ? null : o,
      map: l === void 0 ? null : l,
      sourceType: s.ast.program.sourceType,
      externalDependencies: (0, M1e.flattenToSet)(e.externalDependencies)
    };
  }
  i(R1e, "run");
  function* q1e(e, t) {
    let r = yield* (0, T2.isAsync)();
    for (let s of t) {
      let n = [], a = [], o = [];
      for (let u of s.concat([(0, k1e.default)()])) {
        let c = new B1e.default(e, u.key, u.options, r);
        n.push([u, c]), a.push(c), o.push(u.visitor);
      }
      for (let [u, c] of n)
        u.pre && (yield* (0, T2.maybeAsync)(u.pre, "You appear to be using an async plugin/preset, but Babel has been called synchronously").
        call(c, e));
      let l = x2().default.visitors.merge(o, a, e.opts.wrapPluginVisitorMethod);
      (0, x2().default)(e.ast, l, e.scope);
      for (let [u, c] of n)
        u.post && (yield* (0, T2.maybeAsync)(u.post, "You appear to be using an async plugin/preset, but Babel has been called synchronously").
        call(c, e));
    }
  }
  i(q1e, "transformFile");
});

// ../node_modules/@babel/core/lib/transform-file.js
var v2 = D((zo) => {
  "use strict";
  Object.defineProperty(zo, "__esModule", {
    value: !0
  });
  zo.transformFile = K1e;
  zo.transformFileAsync = Y1e;
  zo.transformFileSync = W1e;
  function sD() {
    let e = ir();
    return sD = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(sD, "_gensync");
  var U1e = oa(), $1e = yp(), V1e = mc(), S2 = sD()(function* (e, t) {
    let r = Object.assign({}, t, {
      filename: e
    }), s = yield* (0, U1e.default)(r);
    if (s === null) return null;
    let n = yield* V1e.readFile(e, "utf8");
    return yield* (0, $1e.run)(s, n);
  });
  function K1e(...e) {
    S2.errback(...e);
  }
  i(K1e, "transformFile");
  function W1e(...e) {
    return S2.sync(...e);
  }
  i(W1e, "transformFileSync");
  function Y1e(...e) {
    return S2.async(...e);
  }
  i(Y1e, "transformFileAsync");
});

// ../node_modules/@babel/core/lib/config/files/import.cjs
var iD = D((sIe, nD) => {
  nD.exports = /* @__PURE__ */ i(function(t) {
    return import(t);
  }, "import_");
});

// ../node_modules/@babel/preset-typescript/package.json
var aD = D((iIe, H1e) => {
  H1e.exports = {
    name: "@babel/preset-typescript",
    version: "7.27.0",
    description: "Babel preset for TypeScript.",
    repository: {
      type: "git",
      url: "https://github.com/babel/babel.git",
      directory: "packages/babel-preset-typescript"
    },
    license: "MIT",
    publishConfig: {
      access: "public"
    },
    main: "./lib/index.js",
    keywords: [
      "babel-preset",
      "typescript"
    ],
    dependencies: {
      "@babel/helper-plugin-utils": "^7.26.5",
      "@babel/helper-validator-option": "^7.25.9",
      "@babel/plugin-syntax-jsx": "^7.25.9",
      "@babel/plugin-transform-modules-commonjs": "^7.26.3",
      "@babel/plugin-transform-typescript": "^7.27.0"
    },
    peerDependencies: {
      "@babel/core": "^7.0.0-0"
    },
    devDependencies: {
      "@babel/core": "^7.26.10",
      "@babel/helper-plugin-test-runner": "^7.25.9"
    },
    homepage: "https://babel.dev/docs/en/next/babel-preset-typescript",
    bugs: "https://github.com/babel/babel/issues?utf8=%E2%9C%93&q=is%3Aissue+label%3A%22area%3A%20typescript%22+is%3Aopen",
    engines: {
      node: ">=6.9.0"
    },
    author: "The Babel Team (https://babel.dev/team)",
    type: "commonjs"
  };
});

// ../node_modules/@babel/helper-plugin-utils/lib/index.js
var la = D((Qo) => {
  "use strict";
  Object.defineProperty(Qo, "__esModule", {
    value: !0
  });
  Qo.declare = oD;
  Qo.declarePreset = void 0;
  var P2 = {
    assertVersion: /* @__PURE__ */ i((e) => (t) => {
      G1e(t, e.version);
    }, "assertVersion")
  };
  Object.assign(P2, {
    targets: /* @__PURE__ */ i(() => () => ({}), "targets"),
    assumption: /* @__PURE__ */ i(() => () => {
    }, "assumption"),
    addExternalDependency: /* @__PURE__ */ i(() => () => {
    }, "addExternalDependency")
  });
  function oD(e) {
    return (t, r, s) => {
      let n;
      for (let a of Object.keys(P2))
        t[a] || (n ?? (n = J1e(t)), n[a] = P2[a](n));
      return e(n ?? t, r || {}, s);
    };
  }
  i(oD, "declare");
  var aIe = Qo.declarePreset = oD;
  function J1e(e) {
    let t = null;
    return typeof e.version == "string" && /^7\./.test(e.version) && (t = Object.getPrototypeOf(e), t && (!hasOwnProperty.call(t, "version") ||
    !hasOwnProperty.call(t, "transform") || !hasOwnProperty.call(t, "template") || !hasOwnProperty.call(t, "types")) && (t = null)), Object.
    assign({}, t, e);
  }
  i(J1e, "copyApiObject");
  function G1e(e, t) {
    if (typeof e == "number") {
      if (!Number.isInteger(e))
        throw new Error("Expected string or integer value.");
      e = `^${e}.0.0-0`;
    }
    if (typeof e != "string")
      throw new Error("Expected string or integer value.");
    let r = Error.stackTraceLimit;
    typeof r == "number" && r < 25 && (Error.stackTraceLimit = 25);
    let s;
    throw t.slice(0, 2) === "7." ? s = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t}". You'll need to update your @b\
abel/core version.`) : s = new Error(`Requires Babel "${e}", but was loaded with "${t}". If you are sure you have a compatible version of @b\
abel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for\
 the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof r == "number" && (Error.stackTraceLimit =
    r), Object.assign(s, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: t,
      range: e
    });
  }
  i(G1e, "throwVersionError");
});

// ../node_modules/@babel/plugin-syntax-typescript/lib/index.js
var lD = D((bp) => {
  "use strict";
  Object.defineProperty(bp, "__esModule", {
    value: !0
  });
  bp.default = void 0;
  var X1e = la();
  A2 = /* @__PURE__ */ i(function(e, t) {
    let r = [];
    e.forEach((s, n) => {
      (Array.isArray(s) ? s[0] : s) === t && r.unshift(n);
    });
    for (let s of r)
      e.splice(s, 1);
  }, "removePlugin");
  var A2, uIe = bp.default = (0, X1e.declare)((e, t) => {
    e.assertVersion(7);
    let {
      disallowAmbiguousJSXLike: r,
      dts: s
    } = t;
    var {
      isTSX: n
    } = t;
    return {
      name: "syntax-typescript",
      manipulateOptions(a, o) {
        {
          let {
            plugins: l
          } = o;
          A2(l, "flow"), A2(l, "jsx"), l.push("objectRestSpread", "classProperties"), n && l.push("jsx");
        }
        o.plugins.push(["typescript", {
          disallowAmbiguousJSXLike: r,
          dts: s
        }]);
      }
    };
  });
});

// ../node_modules/@babel/helper-member-expression-to-functions/lib/index.js
var I2 = D((_2) => {
  "use strict";
  Object.defineProperty(_2, "__esModule", { value: !0 });
  var z1e = ce();
  function Q1e(e) {
    if (e && e.__esModule) return e;
    var t = /* @__PURE__ */ Object.create(null);
    return e && Object.keys(e).forEach(function(r) {
      if (r !== "default") {
        var s = Object.getOwnPropertyDescriptor(e, r);
        Object.defineProperty(t, r, s.get ? s : {
          enumerable: !0,
          get: /* @__PURE__ */ i(function() {
            return e[r];
          }, "get")
        });
      }
    }), t.default = e, Object.freeze(t);
  }
  i(Q1e, "_interopNamespace");
  var Z1e = /* @__PURE__ */ Q1e(z1e);
  function w2(e) {
    let t = e, {
      node: r,
      parentPath: s
    } = t;
    if (s.isLogicalExpression()) {
      let {
        operator: n,
        right: a
      } = s.node;
      if (n === "&&" || n === "||" || n === "??" && r === a)
        return w2(s);
    }
    if (s.isSequenceExpression()) {
      let {
        expressions: n
      } = s.node;
      return n[n.length - 1] === r ? w2(s) : !0;
    }
    return s.isConditional({
      test: r
    }) || s.isUnaryExpression({
      operator: "!"
    }) || s.isLoop({
      test: r
    });
  }
  i(w2, "willPathCastToBoolean");
  var {
    LOGICAL_OPERATORS: eme,
    arrowFunctionExpression: uD,
    assignmentExpression: ua,
    binaryExpression: oi,
    booleanLiteral: tme,
    callExpression: xp,
    cloneNode: Ar,
    conditionalExpression: rme,
    identifier: hD,
    isMemberExpression: sme,
    isOptionalCallExpression: nme,
    isOptionalMemberExpression: mD,
    isUpdateExpression: ime,
    logicalExpression: Tp,
    memberExpression: cD,
    nullLiteral: gp,
    optionalCallExpression: ame,
    optionalMemberExpression: ome,
    sequenceExpression: C2,
    updateExpression: pD
  } = Z1e, D2 = class {
    static {
      i(this, "AssignmentMemoiser");
    }
    constructor() {
      this._map = void 0, this._map = /* @__PURE__ */ new WeakMap();
    }
    has(t) {
      return this._map.has(t);
    }
    get(t) {
      if (!this.has(t)) return;
      let r = this._map.get(t), {
        value: s
      } = r;
      return r.count--, r.count === 0 ? ua("=", s, t) : s;
    }
    set(t, r, s) {
      return this._map.set(t, {
        count: s,
        value: r
      });
    }
  };
  function fD(e, t) {
    let {
      node: r
    } = e;
    if (mD(r))
      return cD(t, r.property, r.computed);
    if (e.isOptionalCallExpression()) {
      let s = e.get("callee");
      if (e.node.optional && s.isOptionalMemberExpression()) {
        let n = s.node.object, a = e.scope.maybeGenerateMemoised(n);
        return s.get("object").replaceWith(ua("=", a, n)), xp(cD(t, hD("call")), [a, ...e.node.arguments]);
      }
      return xp(t, e.node.arguments);
    }
    return e.node;
  }
  i(fD, "toNonOptional");
  function lme(e) {
    for (; e && !e.isProgram(); ) {
      let {
        parentPath: t,
        container: r,
        listKey: s
      } = e, n = t.node;
      if (s) {
        if (r !== n[s])
          return !0;
      } else if (r !== n) return !0;
      e = t;
    }
    return !1;
  }
  i(lme, "isInDetachedTree");
  var ume = {
    memoise() {
    },
    handle(e, t) {
      let {
        node: r,
        parent: s,
        parentPath: n,
        scope: a
      } = e;
      if (e.isOptionalMemberExpression()) {
        if (lme(e)) return;
        let o = e.find(({
          node: M,
          parent: K
        }) => mD(K) ? K.optional || K.object !== M : nme(K) ? M !== e.node && K.optional || K.callee !== M : !0);
        if (a.path.isPattern()) {
          o.replaceWith(xp(uD([], o.node), []));
          return;
        }
        let l = w2(o), u = o.parentPath;
        if (u.isUpdateExpression({
          argument: r
        }))
          throw e.buildCodeFrameError("can't handle update expression");
        let c = u.isAssignmentExpression({
          left: o.node
        }), p = u.isUnaryExpression({
          operator: "delete"
        });
        if (p && o.isOptionalMemberExpression() && o.get("property").isPrivateName())
          throw e.buildCodeFrameError("can't delete a private class element");
        let f = e;
        for (; ; ) {
          if (f.isOptionalMemberExpression()) {
            if (f.node.optional) break;
            f = f.get("object");
            continue;
          } else if (f.isOptionalCallExpression()) {
            if (f.node.optional) break;
            f = f.get("callee");
            continue;
          }
          throw new Error(`Internal error: unexpected ${f.node.type}`);
        }
        let h = f.isOptionalMemberExpression() ? f.node.object : f.node.callee, b = a.maybeGenerateMemoised(h), T = b ?? h, d = n.isOptionalCallExpression(
        {
          callee: r
        }), g = /* @__PURE__ */ i((M) => d, "isOptionalCall"), E = n.isCallExpression({
          callee: r
        });
        f.replaceWith(fD(f, T)), g() ? s.optional ? n.replaceWith(this.optionalCall(e, s.arguments)) : n.replaceWith(this.call(e, s.arguments)) :
        E ? e.replaceWith(this.boundGet(e)) : this.delete && n.isUnaryExpression({
          operator: "delete"
        }) ? n.replaceWith(this.delete(e)) : n.isAssignmentExpression() ? dD(this, e, n) : e.replaceWith(this.get(e));
        let _ = e.node;
        for (let M = e; M !== o; ) {
          let K = M.parentPath;
          if (K === o && g() && s.optional) {
            _ = K.node;
            break;
          }
          _ = fD(K, _), M = K;
        }
        let N, k = o.parentPath;
        if (sme(_) && k.isOptionalCallExpression({
          callee: o.node,
          optional: !0
        })) {
          let {
            object: M
          } = _;
          N = e.scope.maybeGenerateMemoised(M), N && (_.object = ua("=", N, M));
        }
        let j = o;
        (p || c) && (j = k, _ = k.node);
        let U = b ? ua("=", Ar(T), Ar(h)) : Ar(T);
        if (l) {
          let M;
          t ? M = oi("!=", U, gp()) : M = Tp("&&", oi("!==", U, gp()), oi("!==", Ar(T), a.buildUndefinedNode())), j.replaceWith(Tp("&&", M, _));
        } else {
          let M;
          t ? M = oi("==", U, gp()) : M = Tp("||", oi("===", U, gp()), oi("===", Ar(T), a.buildUndefinedNode())), j.replaceWith(rme(M, p ? tme(
          !0) : a.buildUndefinedNode(), _));
        }
        if (N) {
          let M = k.node;
          k.replaceWith(ame(ome(M.callee, hD("call"), !1, !0), [Ar(N), ...M.arguments], !1));
        }
        return;
      }
      if (ime(s, {
        argument: r
      })) {
        if (this.simpleSet) {
          e.replaceWith(this.simpleSet(e));
          return;
        }
        let {
          operator: o,
          prefix: l
        } = s;
        this.memoise(e, 2);
        let u = a.generateUidIdentifierBasedOnNode(r);
        a.push({
          id: u
        });
        let c = [ua("=", Ar(u), this.get(e))];
        if (l) {
          c.push(pD(o, Ar(u), l));
          let p = C2(c);
          n.replaceWith(this.set(e, p));
          return;
        } else {
          let p = a.generateUidIdentifierBasedOnNode(r);
          a.push({
            id: p
          }), c.push(ua("=", Ar(p), pD(o, Ar(u), l)), Ar(u));
          let f = C2(c);
          n.replaceWith(C2([this.set(e, f), Ar(p)]));
          return;
        }
      }
      if (n.isAssignmentExpression({
        left: r
      })) {
        dD(this, e, n);
        return;
      }
      if (n.isCallExpression({
        callee: r
      })) {
        n.replaceWith(this.call(e, n.node.arguments));
        return;
      }
      if (n.isOptionalCallExpression({
        callee: r
      })) {
        if (a.path.isPattern()) {
          n.replaceWith(xp(uD([], n.node), []));
          return;
        }
        n.replaceWith(this.optionalCall(e, n.node.arguments));
        return;
      }
      if (this.delete && n.isUnaryExpression({
        operator: "delete"
      })) {
        n.replaceWith(this.delete(e));
        return;
      }
      if (n.isForXStatement({
        left: r
      }) || n.isObjectProperty({
        value: r
      }) && n.parentPath.isObjectPattern() || n.isAssignmentPattern({
        left: r
      }) && n.parentPath.isObjectProperty({
        value: s
      }) && n.parentPath.parentPath.isObjectPattern() || n.isArrayPattern() || n.isAssignmentPattern({
        left: r
      }) && n.parentPath.isArrayPattern() || n.isRestElement()) {
        e.replaceWith(this.destructureSet(e));
        return;
      }
      n.isTaggedTemplateExpression() ? e.replaceWith(this.boundGet(e)) : e.replaceWith(this.get(e));
    }
  };
  function dD(e, t, r) {
    if (e.simpleSet) {
      t.replaceWith(e.simpleSet(t));
      return;
    }
    let {
      operator: s,
      right: n
    } = r.node;
    if (s === "=")
      r.replaceWith(e.set(t, n));
    else {
      let a = s.slice(0, -1);
      eme.includes(a) ? (e.memoise(t, 1), r.replaceWith(Tp(a, e.get(t), e.set(t, n)))) : (e.memoise(t, 2), r.replaceWith(e.set(t, oi(a, e.get(
      t), n))));
    }
  }
  i(dD, "handleAssignment");
  function cme(e, t, r) {
    e.traverse(t, Object.assign({}, ume, r, {
      memoiser: new D2()
    }));
  }
  i(cme, "memberExpressionToFunctions");
  _2.default = cme;
});

// ../node_modules/@babel/helper-optimise-call-expression/lib/index.js
var N2 = D((O2) => {
  "use strict";
  Object.defineProperty(O2, "__esModule", {
    value: !0
  });
  O2.default = hme;
  var pme = ce(), {
    callExpression: yD,
    identifier: Ep,
    isIdentifier: fme,
    isSpreadElement: dme,
    memberExpression: bD,
    optionalCallExpression: gD,
    optionalMemberExpression: TD
  } = pme;
  function hme(e, t, r, s) {
    return r.length === 1 && dme(r[0]) && fme(r[0].argument, {
      name: "arguments"
    }) ? s ? gD(TD(e, Ep("apply"), !1, !0), [t, r[0].argument], !1) : yD(bD(e, Ep("apply")), [t, r[0].argument]) : s ? gD(TD(e, Ep("call"), !1,
    !0), [t, ...r], !1) : yD(bD(e, Ep("call")), [t, ...r]);
  }
  i(hme, "optimiseCallExpression");
});

// ../node_modules/@babel/helper-replace-supers/lib/index.js
var vp = D((pa) => {
  "use strict";
  Object.defineProperty(pa, "__esModule", {
    value: !0
  });
  pa.default = void 0;
  var mme = I2(), Sp = N2(), Lt = et(), k2 = nt(), {
    assignmentExpression: yme,
    callExpression: Ls,
    cloneNode: At,
    identifier: ca,
    memberExpression: li,
    sequenceExpression: ui,
    stringLiteral: ED,
    thisExpression: jt
  } = Lt.types;
  pa.environmentVisitor = k2.visitors.environmentVisitor({}), pa.skipAllButComputedKey = /* @__PURE__ */ i(function(t) {
    t.skip(), t.node.computed && t.context.maybeQueue(t.get("key"));
  }, "skipAllButComputedKey");
  var xD = k2.visitors.environmentVisitor({
    Super(e, t) {
      let {
        node: r,
        parentPath: s
      } = e;
      s.isMemberExpression({
        object: r
      }) && t.handle(s);
    }
  }), bme = k2.visitors.environmentVisitor({
    Scopable(e, {
      refName: t
    }) {
      let r = e.scope.getOwnBinding(t);
      r && r.identifier.name === t && e.scope.rename(t);
    }
  }), SD = {
    memoise(e, t) {
      let {
        scope: r,
        node: s
      } = e, {
        computed: n,
        property: a
      } = s;
      if (!n)
        return;
      let o = r.maybeGenerateMemoised(a);
      o && this.memoiser.set(a, o, t);
    },
    prop(e) {
      let {
        computed: t,
        property: r
      } = e.node;
      return this.memoiser.has(r) ? At(this.memoiser.get(r)) : t ? At(r) : ED(r.name);
    },
    _getPrototypeOfExpression() {
      let e = At(this.getObjectRef()), t = this.isStatic || this.isPrivateMethod ? e : li(e, ca("prototype"));
      return Ls(this.file.addHelper("getPrototypeOf"), [t]);
    },
    get(e) {
      let t = At(this.getObjectRef());
      return Ls(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? ui([jt(), t]) : t, this.prop(e), jt(), ...this.isStatic ||
      this.isPrivateMethod ? [] : [Lt.types.numericLiteral(1)]]);
    },
    _call(e, t, r) {
      let s = At(this.getObjectRef()), n;
      t.length === 1 && Lt.types.isSpreadElement(t[0]) && (Lt.types.isIdentifier(t[0].argument) || Lt.types.isArrayExpression(t[0].argument)) ?
      n = t[0].argument : n = Lt.types.arrayExpression(t);
      let a = Lt.types.callExpression(this.file.addHelper("superPropGet"), [this.isDerivedConstructor ? ui([jt(), s]) : s, this.prop(e), jt(),
      Lt.types.numericLiteral(2 | (this.isStatic || this.isPrivateMethod ? 0 : 1))]);
      return r ? Lt.types.optionalCallExpression(a, [n], !0) : Ls(a, [n]);
    },
    set(e, t) {
      let r = At(this.getObjectRef());
      return Ls(this.file.addHelper("superPropSet"), [this.isDerivedConstructor ? ui([jt(), r]) : r, this.prop(e), t, jt(), Lt.types.numericLiteral(
      e.isInStrictMode() ? 1 : 0), ...this.isStatic || this.isPrivateMethod ? [] : [Lt.types.numericLiteral(1)]]);
    },
    destructureSet(e) {
      throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.");
    },
    call(e, t) {
      return this._call(e, t, !1);
    },
    optionalCall(e, t) {
      return this._call(e, t, !0);
    },
    delete(e) {
      return e.node.computed ? ui([Ls(this.file.addHelper("toPropertyKey"), [At(e.node.property)]), Lt.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : Lt.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
    }
  }, gme = {
    memoise(e, t) {
      let {
        scope: r,
        node: s
      } = e, {
        computed: n,
        property: a
      } = s;
      if (!n)
        return;
      let o = r.maybeGenerateMemoised(a);
      o && this.memoiser.set(a, o, t);
    },
    prop(e) {
      let {
        computed: t,
        property: r
      } = e.node;
      return this.memoiser.has(r) ? At(this.memoiser.get(r)) : t ? At(r) : ED(r.name);
    },
    _getPrototypeOfExpression() {
      let e = At(this.getObjectRef()), t = this.isStatic || this.isPrivateMethod ? e : li(e, ca("prototype"));
      return Ls(this.file.addHelper("getPrototypeOf"), [t]);
    },
    get(e) {
      return this._get(e);
    },
    _get(e) {
      let t = this._getPrototypeOfExpression();
      return Ls(this.file.addHelper("get"), [this.isDerivedConstructor ? ui([jt(), t]) : t, this.prop(e), jt()]);
    },
    set(e, t) {
      let r = this._getPrototypeOfExpression();
      return Ls(this.file.addHelper("set"), [this.isDerivedConstructor ? ui([jt(), r]) : r, this.prop(e), t, jt(), Lt.types.booleanLiteral(e.
      isInStrictMode())]);
    },
    destructureSet(e) {
      throw e.buildCodeFrameError("Destructuring to a super field is not supported yet.");
    },
    call(e, t) {
      return (0, Sp.default)(this._get(e), jt(), t, !1);
    },
    optionalCall(e, t) {
      return (0, Sp.default)(this._get(e), At(jt()), t, !0);
    },
    delete(e) {
      return e.node.computed ? ui([Ls(this.file.addHelper("toPropertyKey"), [At(e.node.property)]), Lt.template.expression.ast`
          function () { throw new ReferenceError("'delete super[expr]' is invalid"); }()
        `]) : Lt.template.expression.ast`
        function () { throw new ReferenceError("'delete super.prop' is invalid"); }()
      `;
    }
  }, Tme = Object.assign({}, SD, {
    prop(e) {
      let {
        property: t
      } = e.node;
      return this.memoiser.has(t) ? At(this.memoiser.get(t)) : At(t);
    },
    get(e) {
      let {
        isStatic: t,
        getSuperRef: r
      } = this, {
        computed: s
      } = e.node, n = this.prop(e), a;
      if (t) {
        var o;
        a = (o = r()) != null ? o : li(ca("Function"), ca("prototype"));
      } else {
        var l;
        a = li((l = r()) != null ? l : ca("Object"), ca("prototype"));
      }
      return li(a, n, s);
    },
    set(e, t) {
      let {
        computed: r
      } = e.node, s = this.prop(e);
      return yme("=", li(jt(), s, r), t);
    },
    destructureSet(e) {
      let {
        computed: t
      } = e.node, r = this.prop(e);
      return li(jt(), r, t);
    },
    call(e, t) {
      return (0, Sp.default)(this.get(e), jt(), t, !1);
    },
    optionalCall(e, t) {
      return (0, Sp.default)(this.get(e), jt(), t, !0);
    }
  }), B2 = class {
    static {
      i(this, "ReplaceSupers");
    }
    constructor(t) {
      var r;
      let s = t.methodPath;
      this.methodPath = s, this.isDerivedConstructor = s.isClassMethod({
        kind: "constructor"
      }) && !!t.superRef, this.isStatic = s.isObjectMethod() || s.node.static || (s.isStaticBlock == null ? void 0 : s.isStaticBlock()), this.
      isPrivateMethod = s.isPrivate() && s.isMethod(), this.file = t.file, this.constantSuper = (r = t.constantSuper) != null ? r : t.isLoose,
      this.opts = t;
    }
    getObjectRef() {
      return At(this.opts.objectRef || this.opts.getObjectRef());
    }
    getSuperRef() {
      if (this.opts.superRef) return At(this.opts.superRef);
      if (this.opts.getSuperRef)
        return At(this.opts.getSuperRef());
    }
    replace() {
      let {
        methodPath: t
      } = this;
      this.opts.refToPreserve && t.traverse(bme, {
        refName: this.opts.refToPreserve.name
      });
      let r = this.constantSuper ? Tme : this.file.availableHelper("superPropSet") ? SD : gme;
      xD.shouldSkip = (s) => {
        if (s.parentPath === t && (s.parentKey === "decorators" || s.parentKey === "key"))
          return !0;
      }, (0, mme.default)(t, xD, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        getSuperRef: this.getSuperRef.bind(this),
        boundGet: r.get
      }, r));
    }
  };
  pa.default = B2;
});

// ../node_modules/@babel/helper-annotate-as-pure/lib/index.js
var L2 = D((F2) => {
  "use strict";
  Object.defineProperty(F2, "__esModule", {
    value: !0
  });
  F2.default = Pme;
  var xme = ce(), {
    addComment: Eme
  } = xme, Sme = "#__PURE__", vme = /* @__PURE__ */ i(({
    leadingComments: e
  }) => !!e && e.some((t) => /[@#]__PURE__/.test(t.value)), "isPureAnnotated");
  function Pme(e) {
    let t = e.node || e;
    vme(t) || Eme(t, "leading", Sme);
  }
  i(Pme, "annotateAsPure");
});

// ../node_modules/@babel/helper-skip-transparent-expression-wrappers/lib/index.js
var Pp = D((Zo) => {
  "use strict";
  Object.defineProperty(Zo, "__esModule", {
    value: !0
  });
  Zo.isTransparentExprWrapper = j2;
  Zo.skipTransparentExprWrapperNodes = Bme;
  Zo.skipTransparentExprWrappers = Nme;
  var Ame = ce(), {
    isParenthesizedExpression: Cme,
    isTSAsExpression: wme,
    isTSNonNullExpression: Dme,
    isTSSatisfiesExpression: _me,
    isTSTypeAssertion: Ime,
    isTypeCastExpression: Ome
  } = Ame;
  function j2(e) {
    return wme(e) || _me(e) || Ime(e) || Dme(e) || Ome(e) || Cme(e);
  }
  i(j2, "isTransparentExprWrapper");
  function Nme(e) {
    for (; j2(e.node); )
      e = e.get("expression");
    return e;
  }
  i(Nme, "skipTransparentExprWrappers");
  function Bme(e) {
    for (; j2(e); )
      e = e.expression;
    return e;
  }
  i(Bme, "skipTransparentExprWrapperNodes");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/typescript.js
var R2 = D((M2) => {
  "use strict";
  Object.defineProperty(M2, "__esModule", {
    value: !0
  });
  M2.assertFieldTransformed = kme;
  function kme(e) {
    if (e.node.declare)
      throw e.buildCodeFrameError(`TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.
If you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional clas\
s features:
 - @babel/plugin-transform-class-properties
 - @babel/plugin-transform-private-methods
 - @babel/plugin-proposal-decorators`);
  }
  i(kme, "assertFieldTransformed");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/fields.js
var K2 = D((mn) => {
  "use strict";
  Object.defineProperty(mn, "__esModule", {
    value: !0
  });
  mn.buildCheckInRHS = wp;
  mn.buildFieldsInitNodes = nye;
  mn.buildPrivateNamesMap = qme;
  mn.buildPrivateNamesNodes = Ume;
  mn.privateNameVisitorFactory = V2;
  mn.transformPrivateNamesUsage = Hme;
  var F = et(), DD = nt(), Fme = vp(), Lme = I2(), vD = N2(), jme = L2(), Mme = Pp(), Rme = R2();
  Mt = /* @__PURE__ */ i((e) => e.availableHelper("classPrivateFieldGet2"), "newHelpers");
  var Mt;
  function qme(e, t, r, s) {
    let n = /* @__PURE__ */ new Map(), a;
    for (let o of r)
      if (o.isPrivate()) {
        let {
          name: l
        } = o.node.key.id, u = n.get(l);
        if (!u) {
          let c = !o.isProperty(), p = o.node.static, f = !1, h;
          !t && Mt(s) && c && !p ? (f = !!a, a ?? (a = o.scope.generateUidIdentifier(`${e}_brand`)), h = a) : h = o.scope.generateUidIdentifier(
          l), u = {
            id: h,
            static: p,
            method: c,
            initAdded: f
          }, n.set(l, u);
        }
        if (o.isClassPrivateMethod())
          if (o.node.kind === "get") {
            let {
              body: c
            } = o.node.body, p;
            c.length === 1 && F.types.isReturnStatement(p = c[0]) && F.types.isCallExpression(p = p.argument) && p.arguments.length === 1 &&
            F.types.isThisExpression(p.arguments[0]) && F.types.isIdentifier(p = p.callee) ? (u.getId = F.types.cloneNode(p), u.getterDeclared =
            !0) : u.getId = o.scope.generateUidIdentifier(`get_${l}`);
          } else if (o.node.kind === "set") {
            let {
              params: c
            } = o.node, {
              body: p
            } = o.node.body, f;
            p.length === 1 && F.types.isExpressionStatement(f = p[0]) && F.types.isCallExpression(f = f.expression) && f.arguments.length ===
            2 && F.types.isThisExpression(f.arguments[0]) && F.types.isIdentifier(f.arguments[1], {
              name: c[0].name
            }) && F.types.isIdentifier(f = f.callee) ? (u.setId = F.types.cloneNode(f), u.setterDeclared = !0) : u.setId = o.scope.generateUidIdentifier(
            `set_${l}`);
          } else o.node.kind === "method" && (u.methodId = o.scope.generateUidIdentifier(l));
        n.set(l, u);
      }
    return n;
  }
  i(qme, "buildPrivateNamesMap");
  function Ume(e, t, r, s) {
    let n = [], a = /* @__PURE__ */ new Set();
    for (let [o, l] of e) {
      let {
        static: u,
        method: c,
        getId: p,
        setId: f
      } = l, h = p || f, b = F.types.cloneNode(l.id), T;
      if (t)
        T = F.types.callExpression(s.addHelper("classPrivateFieldLooseKey"), [F.types.stringLiteral(o)]);
      else if (r)
        T = F.types.callExpression(F.types.identifier("Symbol"), [F.types.stringLiteral(o)]);
      else if (!u) {
        if (a.has(b.name)) continue;
        a.add(b.name), T = F.types.newExpression(F.types.identifier(c && (!h || Mt(s)) ? "WeakSet" : "WeakMap"), []);
      }
      T && (r || (0, jme.default)(T), n.push(F.template.statement.ast`var ${b} = ${T}`));
    }
    return n;
  }
  i(Ume, "buildPrivateNamesNodes");
  function V2(e) {
    let t = DD.visitors.environmentVisitor(Object.assign({}, e)), r = Object.assign({}, e, {
      Class(s) {
        let {
          privateNamesMap: n
        } = this, a = s.get("body.body"), o = new Map(n), l = [];
        for (let u of a) {
          if (!u.isPrivate()) continue;
          let {
            name: c
          } = u.node.key.id;
          o.delete(c), l.push(c);
        }
        l.length && (s.get("body").traverse(t, Object.assign({}, this, {
          redeclared: l
        })), s.traverse(r, Object.assign({}, this, {
          privateNamesMap: o
        })), s.skipKey("body"));
      }
    });
    return r;
  }
  i(V2, "privateNameVisitorFactory");
  var $me = V2({
    PrivateName(e, {
      noDocumentAll: t
    }) {
      let {
        privateNamesMap: r,
        redeclared: s
      } = this, {
        node: n,
        parentPath: a
      } = e;
      if (!a.isMemberExpression({
        property: n
      }) && !a.isOptionalMemberExpression({
        property: n
      }))
        return;
      let {
        name: o
      } = n.id;
      r.has(o) && (s != null && s.includes(o) || this.handle(a, t));
    }
  });
  function _D(e, t, r) {
    for (; (s = t) != null && s.hasBinding(e) && !t.bindingIdentifierEquals(e, r); ) {
      var s;
      t.rename(e), t = t.parent;
    }
  }
  i(_D, "unshadow");
  function wp(e, t, r) {
    return r || !(t.availableHelper != null && t.availableHelper("checkInRHS")) ? e : F.types.callExpression(t.addHelper("checkInRHS"), [e]);
  }
  i(wp, "buildCheckInRHS");
  var Vme = V2({
    BinaryExpression(e, {
      file: t
    }) {
      let {
        operator: r,
        left: s,
        right: n
      } = e.node;
      if (r !== "in" || !F.types.isPrivateName(s)) return;
      let {
        privateFieldsAsProperties: a,
        privateNamesMap: o,
        redeclared: l
      } = this, {
        name: u
      } = s.id;
      if (!o.has(u) || l != null && l.includes(u)) return;
      if (_D(this.classRef.name, e.scope, this.innerBinding), a) {
        let {
          id: f
        } = o.get(u);
        e.replaceWith(F.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${wp(n, t)}, ${F.types.cloneNode(f)})
      `);
        return;
      }
      let {
        id: c,
        static: p
      } = o.get(u);
      if (p) {
        e.replaceWith(F.template.expression.ast`${wp(n, t)} === ${F.types.cloneNode(this.classRef)}`);
        return;
      }
      e.replaceWith(F.template.expression.ast`${F.types.cloneNode(c)}.has(${wp(n, t)})`);
    }
  });
  function Ap(e, t) {
    return F.types.callExpression(e.addHelper("readOnlyError"), [F.types.stringLiteral(`#${t}`)]);
  }
  i(Ap, "readOnlyError");
  function Kme(e, t) {
    return e.availableHelper("writeOnlyError") ? F.types.callExpression(e.addHelper("writeOnlyError"), [F.types.stringLiteral(`#${t}`)]) : (console.
    warn("@babel/helpers is outdated, update it to silence this warning."), F.types.buildUndefinedNode());
  }
  i(Kme, "writeOnlyError");
  function q2(e, t) {
    return t ? e : F.types.memberExpression(e, F.types.identifier("_"));
  }
  i(q2, "buildStaticPrivateFieldAccess");
  function PD(e) {
    return function(t) {
      return F.types.inherits(e.apply(this, arguments), t.node);
    };
  }
  i(PD, "autoInherits");
  var Wme = {
    memoise(e, t) {
      let {
        scope: r
      } = e, {
        object: s
      } = e.node, n = r.maybeGenerateMemoised(s);
      n && this.memoiser.set(s, n, t);
    },
    receiver(e) {
      let {
        object: t
      } = e.node;
      return this.memoiser.has(t) ? F.types.cloneNode(this.memoiser.get(t)) : F.types.cloneNode(t);
    },
    get: PD(function(e) {
      let {
        classRef: t,
        privateNamesMap: r,
        file: s,
        innerBinding: n,
        noUninitializedPrivateFieldAccess: a
      } = this, o = e.node.property, {
        name: l
      } = o.id, {
        id: u,
        static: c,
        method: p,
        methodId: f,
        getId: h,
        setId: b
      } = r.get(l), T = h || b, d = /* @__PURE__ */ i((g) => F.types.inherits(F.types.cloneNode(g), o), "cloneId");
      if (c) {
        if (_D(t.name, e.scope, n), !Mt(s)) {
          let _ = p && !T ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
          return F.types.callExpression(s.addHelper(_), [this.receiver(e), F.types.cloneNode(t), d(u)]);
        }
        let g = this.receiver(e), E = F.types.isIdentifier(g) && g.name === t.name;
        if (!p)
          return q2(E ? d(u) : F.types.callExpression(s.addHelper("assertClassBrand"), [F.types.cloneNode(t), g, d(u)]), a);
        if (h)
          return E ? F.types.callExpression(d(h), [g]) : F.types.callExpression(s.addHelper("classPrivateGetter"), [F.types.cloneNode(t), g,
          d(h)]);
        if (b) {
          let _ = F.types.buildUndefinedNode();
          return E ? _ : F.types.sequenceExpression([F.types.callExpression(s.addHelper("assertClassBrand"), [F.types.cloneNode(t), g]), _]);
        }
        return E ? d(u) : F.types.callExpression(s.addHelper("assertClassBrand"), [F.types.cloneNode(t), g, d(u)]);
      }
      return p ? T ? h ? Mt(s) ? F.types.callExpression(s.addHelper("classPrivateGetter"), [F.types.cloneNode(u), this.receiver(e), d(h)]) :
      F.types.callExpression(s.addHelper("classPrivateFieldGet"), [this.receiver(e), d(u)]) : F.types.sequenceExpression([this.receiver(e), Kme(
      s, l)]) : Mt(s) ? F.types.callExpression(s.addHelper("assertClassBrand"), [F.types.cloneNode(u), this.receiver(e), d(f)]) : F.types.callExpression(
      s.addHelper("classPrivateMethodGet"), [this.receiver(e), F.types.cloneNode(u), d(f)]) : Mt(s) ? F.types.callExpression(s.addHelper("cl\
assPrivateFieldGet2"), [d(u), this.receiver(e)]) : F.types.callExpression(s.addHelper("classPrivateFieldGet"), [this.receiver(e), d(u)]);
    }),
    boundGet(e) {
      return this.memoise(e, 1), F.types.callExpression(F.types.memberExpression(this.get(e), F.types.identifier("bind")), [this.receiver(e)]);
    },
    set: PD(function(e, t) {
      let {
        classRef: r,
        privateNamesMap: s,
        file: n,
        noUninitializedPrivateFieldAccess: a
      } = this, o = e.node.property, {
        name: l
      } = o.id, {
        id: u,
        static: c,
        method: p,
        setId: f,
        getId: h
      } = s.get(l), b = h || f, T = /* @__PURE__ */ i((d) => F.types.inherits(F.types.cloneNode(d), o), "cloneId");
      if (c) {
        if (!Mt(n)) {
          let E = p && !b ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
          return F.types.callExpression(n.addHelper(E), [this.receiver(e), F.types.cloneNode(r), T(u), t]);
        }
        let d = this.receiver(e), g = F.types.isIdentifier(d) && d.name === r.name;
        if (p && !f) {
          let E = Ap(n, l);
          return g ? F.types.sequenceExpression([t, E]) : F.types.sequenceExpression([t, F.types.callExpression(n.addHelper("assertClassBran\
d"), [F.types.cloneNode(r), d]), Ap(n, l)]);
        }
        return f ? g ? F.types.callExpression(F.types.cloneNode(f), [d, t]) : F.types.callExpression(n.addHelper("classPrivateSetter"), [F.types.
        cloneNode(r), T(f), d, t]) : F.types.assignmentExpression("=", q2(T(u), a), g ? t : F.types.callExpression(n.addHelper("assertClassB\
rand"), [F.types.cloneNode(r), d, t]));
      }
      return p ? f ? Mt(n) ? F.types.callExpression(n.addHelper("classPrivateSetter"), [F.types.cloneNode(u), T(f), this.receiver(e), t]) : F.
      types.callExpression(n.addHelper("classPrivateFieldSet"), [this.receiver(e), T(u), t]) : F.types.sequenceExpression([this.receiver(e),
      t, Ap(n, l)]) : Mt(n) ? F.types.callExpression(n.addHelper("classPrivateFieldSet2"), [T(u), this.receiver(e), t]) : F.types.callExpression(
      n.addHelper("classPrivateFieldSet"), [this.receiver(e), T(u), t]);
    }),
    destructureSet(e) {
      let {
        classRef: t,
        privateNamesMap: r,
        file: s,
        noUninitializedPrivateFieldAccess: n
      } = this, a = e.node.property, {
        name: o
      } = a.id, {
        id: l,
        static: u,
        method: c,
        setId: p
      } = r.get(o), f = /* @__PURE__ */ i((d) => F.types.inherits(F.types.cloneNode(d), a), "cloneId");
      if (!Mt(s)) {
        if (u) {
          try {
            var h = s.addHelper("classStaticPrivateFieldDestructureSet");
          } catch {
            throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the late\
st version.");
          }
          return F.types.memberExpression(F.types.callExpression(h, [this.receiver(e), F.types.cloneNode(t), f(l)]), F.types.identifier("val\
ue"));
        }
        return F.types.memberExpression(F.types.callExpression(s.addHelper("classPrivateFieldDestructureSet"), [this.receiver(e), f(l)]), F.
        types.identifier("value"));
      }
      if (c && !p)
        return F.types.memberExpression(F.types.sequenceExpression([e.node.object, Ap(s, o)]), F.types.identifier("_"));
      if (u && !c) {
        let d = this.get(e);
        if (!n || !F.types.isCallExpression(d))
          return d;
        let g = d.arguments.pop();
        return d.arguments.push(F.template.expression.ast`(_) => ${g} = _`), F.types.memberExpression(F.types.callExpression(s.addHelper("to\
Setter"), [d]), F.types.identifier("_"));
      }
      let b = this.set(e, F.types.identifier("_"));
      if (!F.types.isCallExpression(b) || !F.types.isIdentifier(b.arguments[b.arguments.length - 1], {
        name: "_"
      }))
        throw e.buildCodeFrameError("Internal Babel error while compiling this code. This is a Babel bug. Please report it at https://github\
.com/babel/babel/issues.");
      let T;
      return F.types.isMemberExpression(b.callee, {
        computed: !1
      }) && F.types.isIdentifier(b.callee.property) && b.callee.property.name === "call" ? T = [b.callee.object, F.types.arrayExpression(b.arguments.
      slice(1, -1)), b.arguments[0]] : T = [b.callee, F.types.arrayExpression(b.arguments.slice(0, -1))], F.types.memberExpression(F.types.callExpression(
      s.addHelper("toSetter"), T), F.types.identifier("_"));
    },
    call(e, t) {
      return this.memoise(e, 1), (0, vD.default)(this.get(e), this.receiver(e), t, !1);
    },
    optionalCall(e, t) {
      return this.memoise(e, 1), (0, vD.default)(this.get(e), this.receiver(e), t, !0);
    },
    delete() {
      throw new Error("Internal Babel error: deleting private elements is a parsing error.");
    }
  }, Yme = {
    get(e) {
      let {
        privateNamesMap: t,
        file: r
      } = this, {
        object: s
      } = e.node, {
        name: n
      } = e.node.property.id;
      return F.template.expression`BASE(REF, PROP)[PROP]`({
        BASE: r.addHelper("classPrivateFieldLooseBase"),
        REF: F.types.cloneNode(s),
        PROP: F.types.cloneNode(t.get(n).id)
      });
    },
    set() {
      throw new Error("private name handler with loose = true don't need set()");
    },
    boundGet(e) {
      return F.types.callExpression(F.types.memberExpression(this.get(e), F.types.identifier("bind")), [F.types.cloneNode(e.node.object)]);
    },
    simpleSet(e) {
      return this.get(e);
    },
    destructureSet(e) {
      return this.get(e);
    },
    call(e, t) {
      return F.types.callExpression(this.get(e), t);
    },
    optionalCall(e, t) {
      return F.types.optionalCallExpression(this.get(e), t, !0);
    },
    delete() {
      throw new Error("Internal Babel error: deleting private elements is a parsing error.");
    }
  };
  function Hme(e, t, r, {
    privateFieldsAsProperties: s,
    noUninitializedPrivateFieldAccess: n,
    noDocumentAll: a,
    innerBinding: o
  }, l) {
    if (!r.size) return;
    let u = t.get("body"), c = s ? Yme : Wme;
    (0, Lme.default)(u, $me, Object.assign({
      privateNamesMap: r,
      classRef: e,
      file: l
    }, c, {
      noDocumentAll: a,
      noUninitializedPrivateFieldAccess: n,
      innerBinding: o
    })), u.traverse(Vme, {
      privateNamesMap: r,
      classRef: e,
      file: l,
      privateFieldsAsProperties: s,
      innerBinding: o
    });
  }
  i(Hme, "transformPrivateNamesUsage");
  function AD(e, t, r) {
    let {
      id: s
    } = r.get(t.node.key.id.name), n = t.node.value || t.scope.buildUndefinedNode();
    return gt(F.template.statement.ast`
      Object.defineProperty(${e}, ${F.types.cloneNode(s)}, {
        // configurable is false by default
        // enumerable is false by default
        writable: true,
        value: ${n}
      });
    `, t);
  }
  i(AD, "buildPrivateFieldInitLoose");
  function Jme(e, t, r, s) {
    let {
      id: n
    } = r.get(t.node.key.id.name), a = t.node.value || t.scope.buildUndefinedNode();
    if (!s.availableHelper("classPrivateFieldInitSpec"))
      return gt(F.template.statement.ast`${F.types.cloneNode(n)}.set(${e}, {
          // configurable is always false for private elements
          // enumerable is always false for private elements
          writable: true,
          value: ${a},
        })`, t);
    let o = s.addHelper("classPrivateFieldInitSpec");
    return $2(gt(F.types.expressionStatement(F.types.callExpression(o, [F.types.thisExpression(), $2(F.types.cloneNode(n), t.node.key), Mt(s) ?
    a : F.template.expression.ast`{ writable: true, value: ${a} }`])), t), t.node);
  }
  i(Jme, "buildPrivateInstanceFieldInitSpec");
  function Gme(e, t, r) {
    let s = t.get(e.node.key.id.name), n = r ? e.node.value : F.template.expression.ast`{
        _: ${e.node.value || F.types.buildUndefinedNode()}
      }`;
    return gt(F.types.variableDeclaration("var", [F.types.variableDeclarator(F.types.cloneNode(s.id), n)]), e);
  }
  i(Gme, "buildPrivateStaticFieldInitSpec");
  U2 = /* @__PURE__ */ i(function(e, t) {
    let r = t.get(e.node.key.id.name), {
      id: s,
      getId: n,
      setId: a,
      initAdded: o
    } = r, l = n || a;
    if (!e.isProperty() && (o || !l)) return;
    if (l)
      return t.set(e.node.key.id.name, Object.assign({}, r, {
        initAdded: !0
      })), gt(F.template.statement.ast`
          var ${F.types.cloneNode(s)} = {
            // configurable is false by default
            // enumerable is false by default
            // writable is false by default
            get: ${n ? n.name : e.scope.buildUndefinedNode()},
            set: ${a ? a.name : e.scope.buildUndefinedNode()}
          }
        `, e);
    let u = e.node.value || e.scope.buildUndefinedNode();
    return gt(F.template.statement.ast`
        var ${F.types.cloneNode(s)} = {
          // configurable is false by default
          // enumerable is false by default
          writable: true,
          value: ${u}
        };
      `, e);
  }, "buildPrivateStaticFieldInitSpecOld");
  var U2;
  function Xme(e, t, r) {
    let s = r.get(t.node.key.id.name), {
      methodId: n,
      id: a,
      getId: o,
      setId: l,
      initAdded: u
    } = s;
    if (u) return;
    if (n)
      return gt(F.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${n.name}
        });
      `, t);
    if (o || l)
      return r.set(t.node.key.id.name, Object.assign({}, s, {
        initAdded: !0
      })), gt(F.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${o ? o.name : t.scope.buildUndefinedNode()},
          set: ${l ? l.name : t.scope.buildUndefinedNode()}
        });
      `, t);
  }
  i(Xme, "buildPrivateMethodInitLoose");
  function zme(e, t, r, s) {
    let n = r.get(t.node.key.id.name);
    if (!n.initAdded)
      return !Mt(s) && (n.getId || n.setId) ? Qme(e, t, r, s) : Zme(e, t, r, s);
  }
  i(zme, "buildPrivateInstanceMethodInitSpec");
  function Qme(e, t, r, s) {
    let n = r.get(t.node.key.id.name), {
      id: a,
      getId: o,
      setId: l
    } = n;
    if (r.set(t.node.key.id.name, Object.assign({}, n, {
      initAdded: !0
    })), !s.availableHelper("classPrivateFieldInitSpec"))
      return gt(F.template.statement.ast`
          ${a}.set(${e}, {
            get: ${o ? o.name : t.scope.buildUndefinedNode()},
            set: ${l ? l.name : t.scope.buildUndefinedNode()}
          });
        `, t);
    let u = s.addHelper("classPrivateFieldInitSpec");
    return $2(gt(F.template.statement.ast`${u}(
      ${F.types.thisExpression()},
      ${F.types.cloneNode(a)},
      {
        get: ${o ? o.name : t.scope.buildUndefinedNode()},
        set: ${l ? l.name : t.scope.buildUndefinedNode()}
      },
    )`, t), t.node);
  }
  i(Qme, "buildPrivateAccessorInitialization");
  function Zme(e, t, r, s) {
    let n = r.get(t.node.key.id.name), {
      id: a
    } = n;
    if (!s.availableHelper("classPrivateMethodInitSpec"))
      return gt(F.template.statement.ast`${a}.add(${e})`, t);
    let o = s.addHelper("classPrivateMethodInitSpec");
    return gt(F.template.statement.ast`${o}(
      ${F.types.thisExpression()},
      ${F.types.cloneNode(a)}
    )`, t);
  }
  i(Zme, "buildPrivateInstanceMethodInitialization");
  function CD(e, t) {
    let {
      key: r,
      computed: s
    } = t.node, n = t.node.value || t.scope.buildUndefinedNode();
    return gt(F.types.expressionStatement(F.types.assignmentExpression("=", F.types.memberExpression(e, r, s || F.types.isLiteral(r)), n)), t);
  }
  i(CD, "buildPublicFieldInitLoose");
  function wD(e, t, r) {
    let {
      key: s,
      computed: n
    } = t.node, a = t.node.value || t.scope.buildUndefinedNode();
    return gt(F.types.expressionStatement(F.types.callExpression(r.addHelper("defineProperty"), [e, n || F.types.isLiteral(s) ? s : F.types.
    stringLiteral(s.name), a])), t);
  }
  i(wD, "buildPublicFieldInitSpec");
  function eye(e, t, r, s) {
    let n = s.get(t.node.key.id.name), {
      id: a,
      methodId: o,
      getId: l,
      setId: u,
      initAdded: c
    } = n;
    return c ? void 0 : l || u ? (s.set(t.node.key.id.name, Object.assign({}, n, {
      initAdded: !0
    })), gt(F.template.statement.ast`
        Object.defineProperty(${e}, ${a}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          get: ${l ? l.name : t.scope.buildUndefinedNode()},
          set: ${u ? u.name : t.scope.buildUndefinedNode()}
        })
      `, t)) : gt(F.template.statement.ast`
      Object.defineProperty(${e}, ${a}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        value: ${o.name}
      });
    `, t);
  }
  i(eye, "buildPrivateStaticMethodInitLoose");
  function Cp(e, t, r, s = !1) {
    let n = r.get(t.node.key.id.name), {
      id: a,
      methodId: o,
      getId: l,
      setId: u,
      getterDeclared: c,
      setterDeclared: p,
      static: f
    } = n, {
      params: h,
      body: b,
      generator: T,
      async: d
    } = t.node, g = l && h.length === 0, E = u && h.length > 0;
    if (g && c || E && p)
      return r.set(t.node.key.id.name, Object.assign({}, n, {
        initAdded: !0
      })), null;
    if (Mt(e) && (g || E) && !s) {
      let N = t.get("body").scope, k = N.generateUidIdentifier("this"), j = {
        thisRef: k,
        argumentsPath: []
      };
      if (t.traverse(ID, j), j.argumentsPath.length) {
        let U = N.generateUidIdentifier("arguments");
        N.push({
          id: U,
          init: F.template.expression.ast`[].slice.call(arguments, 1)`
        });
        for (let M of j.argumentsPath)
          M.replaceWith(F.types.cloneNode(U));
      }
      h.unshift(F.types.cloneNode(k));
    }
    let _ = o;
    return g ? (r.set(t.node.key.id.name, Object.assign({}, n, {
      getterDeclared: !0,
      initAdded: !0
    })), _ = l) : E ? (r.set(t.node.key.id.name, Object.assign({}, n, {
      setterDeclared: !0,
      initAdded: !0
    })), _ = u) : f && !s && (_ = a), gt(F.types.functionDeclaration(F.types.cloneNode(_), h, b, T, d), t);
  }
  i(Cp, "buildPrivateMethodDeclaration");
  var ID = DD.visitors.environmentVisitor({
    Identifier(e, t) {
      t.argumentsPath && e.node.name === "arguments" && t.argumentsPath.push(e);
    },
    UnaryExpression(e) {
      let {
        node: t
      } = e;
      if (t.operator === "delete") {
        let r = (0, Mme.skipTransparentExprWrapperNodes)(t.argument);
        F.types.isThisExpression(r) && e.replaceWith(F.types.booleanLiteral(!0));
      }
    },
    ThisExpression(e, t) {
      t.needsClassRef = !0, e.replaceWith(F.types.cloneNode(t.thisRef));
    },
    MetaProperty(e) {
      let {
        node: t,
        scope: r
      } = e;
      t.meta.name === "new" && t.property.name === "target" && e.replaceWith(r.buildUndefinedNode());
    }
  }), tye = {
    ReferencedIdentifier(e, t) {
      e.scope.bindingIdentifierEquals(e.node.name, t.innerBinding) && (t.needsClassRef = !0, e.node.name = t.thisRef.name);
    }
  };
  function rye(e, t, r) {
    var s;
    let n = {
      thisRef: t,
      needsClassRef: !1,
      innerBinding: r
    };
    return e.isMethod() || e.traverse(ID, n), r != null && (s = n.thisRef) != null && s.name && n.thisRef.name !== r.name && e.traverse(tye,
    n), n.needsClassRef;
  }
  i(rye, "replaceThisContext");
  function sye({
    key: e,
    computed: t
  }) {
    return e.type === "Identifier" ? !t && (e.name === "name" || e.name === "length") : e.type === "StringLiteral" ? e.value === "name" || e.
    value === "length" : !1;
  }
  i(sye, "isNameOrLength");
  function gt(e, t) {
    return F.types.inheritLeadingComments(e, t.node), F.types.inheritInnerComments(e, t.node), e;
  }
  i(gt, "inheritPropComments");
  function $2(e, t) {
    return e.start = t.start, e.end = t.end, e.loc = t.loc, e;
  }
  i($2, "inheritLoc");
  function nye(e, t, r, s, n, a, o, l, u, c) {
    let p = 0, f, h = [], b = [], T = !1, d = [], g = null, E = F.types.isIdentifier(t) ? () => t : () => (f ?? (f = r[0].scope.generateUidIdentifierBasedOnNode(
    t)), f), _ = e ?? r[0].scope.generateUidIdentifier(c?.name || "Class");
    e ?? (e = F.types.cloneNode(c));
    for (let N of r) {
      N.isClassProperty() && Rme.assertFieldTransformed(N);
      let k = !(F.types.isStaticBlock != null && F.types.isStaticBlock(N.node)) && N.node.static, j = !k, U = N.isPrivate(), M = !U, K = N.isProperty(),
      G = !K, ue = N.isStaticBlock == null ? void 0 : N.isStaticBlock();
      switch (k && (p |= 1), (k || G && U || ue) && (new Fme.default({
        methodPath: N,
        constantSuper: u,
        file: n,
        refToPreserve: c,
        getSuperRef: E,
        getObjectRef() {
          return p |= 2, k || ue ? _ : F.types.memberExpression(_, F.types.identifier("prototype"));
        }
      }).replace(), rye(N, _, c) && (p |= 2)), T = !1, !0) {
        case ue: {
          let te = N.node.body;
          te.length === 1 && F.types.isExpressionStatement(te[0]) ? h.push(gt(te[0], N)) : h.push(F.types.inheritsComments(F.template.statement.
          ast`(() => { ${te} })()`, N.node));
          break;
        }
        case (k && U && K && o):
          h.push(AD(F.types.cloneNode(e), N, s));
          break;
        case (k && U && K && !o):
          Mt(n) ? h.push(Gme(N, s, l)) : h.push(U2(N, s));
          break;
        case (k && M && K && a):
          if (!sye(N.node)) {
            h.push(CD(F.types.cloneNode(e), N));
            break;
          }
        case (k && M && K && !a):
          h.push(wD(F.types.cloneNode(e), N, n));
          break;
        case (j && U && K && o):
          b.push(AD(F.types.thisExpression(), N, s));
          break;
        case (j && U && K && !o):
          b.push(Jme(F.types.thisExpression(), N, s, n));
          break;
        case (j && U && G && o):
          b.unshift(Xme(F.types.thisExpression(), N, s)), d.push(Cp(n, N, s, o));
          break;
        case (j && U && G && !o):
          b.unshift(zme(F.types.thisExpression(), N, s, n)), d.push(Cp(n, N, s, o));
          break;
        case (k && U && G && !o):
          Mt(n) || h.unshift(U2(N, s)), d.push(Cp(n, N, s, o));
          break;
        case (k && U && G && o):
          h.unshift(eye(F.types.cloneNode(e), N, n, s)), d.push(Cp(n, N, s, o));
          break;
        case (j && M && K && a):
          b.push(CD(F.types.thisExpression(), N));
          break;
        case (j && M && K && !a):
          T = !0, b.push(wD(F.types.thisExpression(), N, n));
          break;
        default:
          throw new Error("Unreachable.");
      }
    }
    return p & 2 && c != null && (g = F.types.expressionStatement(F.types.assignmentExpression("=", F.types.cloneNode(_), F.types.cloneNode(
    c)))), {
      staticNodes: h.filter(Boolean),
      instanceNodes: b.filter(Boolean),
      lastInstanceNodeReturnsThis: T,
      pureStaticNodes: d.filter(Boolean),
      classBindingNode: g,
      wrapClass(N) {
        for (let k of r)
          k.node.leadingComments = null, k.remove();
        return f && (N.scope.push({
          id: F.types.cloneNode(f)
        }), N.set("superClass", F.types.assignmentExpression("=", f, N.node.superClass))), p !== 0 && (N.isClassExpression() ? (N.scope.push(
        {
          id: e
        }), N.replaceWith(F.types.assignmentExpression("=", F.types.cloneNode(e), N.node))) : (c == null && (N.node.id = e), g != null && N.
        scope.push({
          id: _
        }))), N;
      }
    };
  }
  i(nye, "buildFieldsInitNodes");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/misc.js
var W2 = D((el) => {
  "use strict";
  Object.defineProperty(el, "__esModule", {
    value: !0
  });
  el.extractComputedKeys = cye;
  el.injectInitialization = uye;
  el.memoiseComputedKey = ND;
  var st = et(), iye = nt(), aye = iye.visitors.environmentVisitor({
    Super(e) {
      let {
        node: t,
        parentPath: r
      } = e;
      r.isCallExpression({
        callee: t
      }) && this.push(r);
    }
  }), oye = {
    "TSTypeAnnotation|TypeAnnotation"(e) {
      e.skip();
    },
    ReferencedIdentifier(e, {
      scope: t
    }) {
      t.hasOwnBinding(e.node.name) && (t.rename(e.node.name), e.skip());
    }
  };
  function OD(e, t) {
    if (t.classBinding && t.classBinding === e.scope.getBinding(e.node.name)) {
      let r = t.file.addHelper("classNameTDZError"), s = st.types.callExpression(r, [st.types.stringLiteral(e.node.name)]);
      e.replaceWith(st.types.sequenceExpression([s, e.node])), e.skip();
    }
  }
  i(OD, "handleClassTDZ");
  var lye = {
    ReferencedIdentifier: OD,
    "TSTypeAnnotation|TypeAnnotation"(e) {
      e.skip();
    }
  };
  function uye(e, t, r, s, n) {
    if (!r.length) return;
    let a = !!e.node.superClass;
    if (!t) {
      let o = st.types.classMethod("constructor", st.types.identifier("constructor"), [], st.types.blockStatement([]));
      a && (o.params = [st.types.restElement(st.types.identifier("args"))], o.body.body.push(st.template.statement.ast`super(...args)`)), [t] =
      e.get("body").unshiftContainer("body", o);
    }
    if (s && s(oye, {
      scope: t.scope
    }), a) {
      let o = [];
      t.traverse(aye, o);
      let l = !0;
      for (let u of o)
        if (l ? l = !1 : r = r.map((c) => st.types.cloneNode(c)), u.parentPath.isExpressionStatement())
          u.insertAfter(r);
        else {
          let c = [u.node, ...r.map((p) => st.types.toExpression(p))];
          n || c.push(st.types.thisExpression()), u.replaceWith(st.types.sequenceExpression(c));
        }
    } else
      t.get("body").unshiftContainer("body", r);
  }
  i(uye, "injectInitialization");
  function ND(e, t, r) {
    if (st.types.isIdentifier(e) && t.hasUid(e.name))
      return;
    if (st.types.isAssignmentExpression(e, {
      operator: "="
    }) && st.types.isIdentifier(e.left) && t.hasUid(e.left.name))
      return st.types.cloneNode(e);
    {
      let a = st.types.identifier(r);
      return t.push({
        id: a,
        kind: "let"
      }), st.types.assignmentExpression("=", st.types.cloneNode(a), e);
    }
  }
  i(ND, "memoiseComputedKey");
  function cye(e, t, r) {
    let {
      scope: s
    } = e, n = [], a = {
      classBinding: e.node.id && s.getBinding(e.node.id.name),
      file: r
    };
    for (let o of t) {
      let l = o.get("key");
      l.isReferencedIdentifier() ? OD(l, a) : l.traverse(lye, a);
      let u = o.node;
      if (!l.isConstantExpression()) {
        let c = ND(l.node, s, s.generateUidBasedOnNode(l.node));
        c && (n.push(st.types.expressionStatement(c)), u.key = st.types.cloneNode(c.left));
      }
    }
    return n;
  }
  i(cye, "extractComputedKeys");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/decorators.js
var Z2 = D((fa) => {
  "use strict";
  Object.defineProperty(fa, "__esModule", {
    value: !0
  });
  fa.buildNamedEvaluationVisitor = HD;
  fa.default = Vye;
  fa.hasDecorators = pye;
  fa.hasOwnDecorators = X2;
  var w = et(), BD = vp(), yn = Pp(), VD = K2(), Dp = W2();
  function X2(e) {
    var t;
    return !!((t = e.decorators) != null && t.length);
  }
  i(X2, "hasOwnDecorators");
  function pye(e) {
    return X2(e) || e.body.body.some(X2);
  }
  i(pye, "hasDecorators");
  function KD(e, t = e.length - 1) {
    if (t === -1) {
      e.unshift(65);
      return;
    }
    let r = e[t];
    r === 90 ? e[t] = 97 : r === 122 ? (e[t] = 65, KD(e, t - 1)) : e[t] = r + 1;
  }
  i(KD, "incrementId");
  function fye(e) {
    let t = [], r = /* @__PURE__ */ new Set();
    return e.traverse({
      PrivateName(s) {
        r.add(s.node.id.name);
      }
    }), () => {
      let s;
      do
        KD(t), s = String.fromCharCode(...t);
      while (r.has(s));
      return w.types.privateName(w.types.identifier(s));
    };
  }
  i(fye, "createPrivateUidGeneratorForClass");
  function dye(e) {
    let t;
    return () => (t || (t = fye(e)), t());
  }
  i(dye, "createLazyPrivateUidGeneratorForClass");
  function hye(e, t) {
    let r = e.node.id, s = e.scope;
    if (e.type === "ClassDeclaration") {
      let n = r.name, a = s.generateUidIdentifierBasedOnNode(r), o = w.types.identifier(n);
      return s.rename(n, a.name), e.get("id").replaceWith(o), {
        id: w.types.cloneNode(a),
        path: e
      };
    } else {
      let n;
      r ? (t = r.name, n = lr(s.parent, t), s.rename(t, n.name)) : n = lr(s.parent, typeof t == "string" ? t : "decorated_class");
      let a = w.types.classExpression(typeof t == "string" ? w.types.identifier(t) : null, e.node.superClass, e.node.body), [o] = e.replaceWith(
      w.types.sequenceExpression([a, n]));
      return {
        id: w.types.cloneNode(n),
        path: o.get("expressions.0")
      };
    }
  }
  i(hye, "replaceClassWithVar");
  function kD(e, t, r) {
    return e.type === "PrivateName" ? w.types.classPrivateProperty(e, t, void 0, r) : w.types.classProperty(e, t, void 0, void 0, r);
  }
  i(kD, "generateClassProperty");
  function Y2(e, t) {
    e.node.id || (e.node.id = typeof t == "string" ? w.types.identifier(t) : e.scope.generateUidIdentifier("Class"));
  }
  i(Y2, "assignIdForAnonymousClass");
  function FD(e, t, r, s, n, a, o, l) {
    let u = (l === "2023-11" || l === "2023-05") && o ? e : w.types.thisExpression(), c = w.types.blockStatement([w.types.returnStatement(w.
    types.memberExpression(w.types.cloneNode(u), w.types.cloneNode(n)))]), p = w.types.blockStatement([w.types.expressionStatement(w.types.assignmentExpression(
    "=", w.types.memberExpression(w.types.cloneNode(u), w.types.cloneNode(n)), w.types.identifier("v")))]), f, h;
    r.type === "PrivateName" ? (f = w.types.classPrivateMethod("get", r, [], c, o), h = w.types.classPrivateMethod("set", s, [w.types.identifier(
    "v")], p, o)) : (f = w.types.classMethod("get", r, [], c, a, o), h = w.types.classMethod("set", s, [w.types.identifier("v")], p, a, o)),
    t.insertAfter(h), t.insertAfter(f);
  }
  i(FD, "addProxyAccessorsFor");
  function LD(e, t) {
    return t !== "2023-11" && t !== "2023-05" && t !== "2023-01" ? [w.template.expression.ast`
        function () {
          return this.${w.types.cloneNode(e)};
        }
      `, w.template.expression.ast`
        function (value) {
          this.${w.types.cloneNode(e)} = value;
        }
      `] : [w.template.expression.ast`
      o => o.${w.types.cloneNode(e)}
    `, w.template.expression.ast`
      (o, v) => o.${w.types.cloneNode(e)} = v
    `];
  }
  i(LD, "extractProxyAccessorsFor");
  function Q2(e) {
    if (e = (0, yn.skipTransparentExprWrappers)(e), e.isSequenceExpression()) {
      let t = e.get("expressions");
      return Q2(t[t.length - 1]);
    }
    return e;
  }
  i(Q2, "getComputedKeyLastElement");
  function mye(e) {
    let t = Q2(e);
    if (t.isConstantExpression())
      return w.types.cloneNode(e.node);
    if (t.isIdentifier() && e.scope.hasUid(t.node.name))
      return w.types.cloneNode(e.node);
    if (t.isAssignmentExpression() && t.get("left").isIdentifier())
      return w.types.cloneNode(t.node.left);
    throw new Error(`Internal Error: the computed key ${e.toString()} has not yet been memoised.`);
  }
  i(mye, "getComputedKeyMemoiser");
  function tl(e, t) {
    let r = t.get("key");
    r.isSequenceExpression() ? e.push(...r.node.expressions) : e.push(r.node), r.replaceWith(gn(e));
  }
  i(tl, "prependExpressionsToComputedKey");
  function yye(e, t) {
    let r = t.get("key"), s = Q2(r);
    if (s.isConstantExpression())
      tl(e, t);
    else {
      let n = r.scope.parent, a = (0, Dp.memoiseComputedKey)(s.node, n, n.generateUid("computedKey"));
      if (!a)
        tl(e, t);
      else {
        let o = [...e, w.types.cloneNode(a.left)], l = s.parentPath;
        l.isSequenceExpression() ? l.pushContainer("expressions", o) : s.replaceWith(gn([w.types.cloneNode(a), ...o]));
      }
    }
  }
  i(yye, "appendExpressionsToComputedKey");
  function H2(e, t) {
    let r = t.get("value");
    r.node ? e.push(r.node) : e.length > 0 && (e[e.length - 1] = w.types.unaryExpression("void", e[e.length - 1])), r.replaceWith(gn(e));
  }
  i(H2, "prependExpressionsToFieldInitializer");
  function bye(e, t) {
    t.unshiftContainer("body", w.types.expressionStatement(gn(e)));
  }
  i(bye, "prependExpressionsToStaticBlock");
  function gye(e, t) {
    t.node.body.body.unshift(w.types.expressionStatement(gn(e)));
  }
  i(gye, "prependExpressionsToConstructor");
  function jD(e, t) {
    return w.types.isCallExpression(e) && w.types.isIdentifier(e.callee, {
      name: t.name
    });
  }
  i(jD, "isProtoInitCallExpression");
  function Tye(e, t) {
    if (t) {
      if (e.length >= 2 && jD(e[1], t)) {
        let r = w.types.callExpression(w.types.cloneNode(t), [e[0]]);
        e.splice(0, 2, r);
      }
      e.length >= 2 && w.types.isThisExpression(e[e.length - 1]) && jD(e[e.length - 2], t) && e.splice(e.length - 1, 1);
    }
    return gn(e);
  }
  i(Tye, "optimizeSuperCallAndExpressions");
  function xye(e, t, r) {
    t.traverse({
      CallExpression: {
        exit(s) {
          if (!s.get("callee").isSuper()) return;
          let n = [s.node, ...e.map((a) => w.types.cloneNode(a))];
          s.isCompletionRecord() && n.push(w.types.thisExpression()), s.replaceWith(Tye(n, r)), s.skip();
        }
      },
      ClassMethod(s) {
        s.node.kind === "constructor" && s.skip();
      }
    });
  }
  i(xye, "insertExpressionsAfterSuperCallAndOptimize");
  function MD(e, t) {
    let r = [w.types.expressionStatement(gn(e))];
    return t && r.unshift(w.types.expressionStatement(w.types.callExpression(w.types.super(), [w.types.spreadElement(w.types.identifier("arg\
s"))]))), w.types.classMethod("constructor", w.types.identifier("constructor"), t ? [w.types.restElement(w.types.identifier("args"))] : [], w.
    types.blockStatement(r));
  }
  i(MD, "createConstructorFromExpressions");
  function RD(e) {
    return w.types.staticBlock([w.types.expressionStatement(gn(e))]);
  }
  i(RD, "createStaticBlockFromExpressions");
  var ci = 0, bn = 1, Eye = 2, WD = 3, _p = 4, Sye = 5, vye = 8, Pye = 16;
  function Aye(e) {
    switch (e.node.type) {
      case "ClassProperty":
      case "ClassPrivateProperty":
        return ci;
      case "ClassAccessorProperty":
        return bn;
      case "ClassMethod":
      case "ClassPrivateMethod":
        return e.node.kind === "get" ? WD : e.node.kind === "set" ? _p : Eye;
    }
  }
  i(Aye, "getElementKind");
  function Cye(e) {
    return [...e.filter((t) => t.isStatic && t.kind >= bn && t.kind <= _p), ...e.filter((t) => !t.isStatic && t.kind >= bn && t.kind <= _p),
    ...e.filter((t) => t.isStatic && t.kind === ci), ...e.filter((t) => !t.isStatic && t.kind === ci)];
  }
  i(Cye, "toSortedDecoratorInfo");
  function qD(e, t, r) {
    let s = e.length, n = t.some(Boolean), a = [];
    for (let o = 0; o < s; o++)
      (r === "2023-11" || r === "2023-05") && n && a.push(t[o] || w.types.unaryExpression("void", w.types.numericLiteral(0))), a.push(e[o].expression);
    return {
      haveThis: n,
      decs: a
    };
  }
  i(qD, "generateDecorationList");
  function wye(e, t) {
    return w.types.arrayExpression(e.map((r) => {
      let s = r.kind;
      return r.isStatic && (s += t === "2023-11" || t === "2023-05" ? vye : Sye), r.decoratorsHaveThis && (s += Pye), w.types.arrayExpression(
      [r.decoratorsArray, w.types.numericLiteral(s), r.name, ...r.privateMethods || []]);
    }));
  }
  i(wye, "generateDecorationExprs");
  function Dye(e) {
    let t = [];
    for (let r of e) {
      let {
        locals: s
      } = r;
      Array.isArray(s) ? t.push(...s) : s !== void 0 && t.push(s);
    }
    return t;
  }
  i(Dye, "extractElementLocalAssignments");
  function _ye(e, t, r, s, n, a) {
    t.insertAfter(w.types.classPrivateMethod("get", w.types.cloneNode(r), [], w.types.blockStatement([w.types.returnStatement(w.types.callExpression(
    w.types.cloneNode(s), e === "2023-11" && a ? [] : [w.types.thisExpression()]))]), a)), t.insertAfter(w.types.classPrivateMethod("set", w.
    types.cloneNode(r), [w.types.identifier("v")], w.types.blockStatement([w.types.expressionStatement(w.types.callExpression(w.types.cloneNode(
    n), e === "2023-11" && a ? [w.types.identifier("v")] : [w.types.thisExpression(), w.types.identifier("v")]))]), a));
  }
  i(_ye, "addCallAccessorsFor");
  function Iye(e, t, r, s) {
    let n, a;
    e.node.kind === "set" ? (n = [w.types.identifier("v")], a = [w.types.expressionStatement(w.types.callExpression(r, [w.types.thisExpression(),
    w.types.identifier("v")]))]) : (n = [], a = [w.types.returnStatement(w.types.callExpression(r, [w.types.thisExpression()]))]), e.replaceWith(
    w.types.classPrivateMethod(e.node.kind, w.types.cloneNode(t), n, w.types.blockStatement(a), s));
  }
  i(Iye, "movePrivateAccessor");
  function UD(e) {
    let {
      type: t
    } = e;
    return t !== "TSDeclareMethod" && t !== "TSIndexSignature" && t !== "StaticBlock";
  }
  i(UD, "isClassDecoratableElementPath");
  function Oye(e) {
    return w.types.callExpression(w.types.arrowFunctionExpression([], w.types.blockStatement(e.body)), []);
  }
  i(Oye, "staticBlockToIIFE");
  function Nye(e) {
    return w.types.functionExpression(null, [], w.types.blockStatement(e.body));
  }
  i(Nye, "staticBlockToFunctionClosure");
  function Bye(e) {
    return w.types.functionExpression(null, [], w.types.blockStatement([w.types.returnStatement(e)]));
  }
  i(Bye, "fieldInitializerToClosure");
  function gn(e) {
    return e.length === 0 ? w.types.unaryExpression("void", w.types.numericLiteral(0)) : e.length === 1 ? e[0] : w.types.sequenceExpression(
    e);
  }
  i(gn, "maybeSequenceExpression");
  function $D(e) {
    let {
      params: t,
      body: r,
      generator: s,
      async: n
    } = e;
    return w.types.functionExpression(void 0, t, r, s, n);
  }
  i($D, "createFunctionExpressionFromPrivateMethod");
  function YD(e, t) {
    return w.types.callExpression(e.addHelper("setFunctionName"), [w.types.thisExpression(), t]);
  }
  i(YD, "createSetFunctionNameCall");
  function z2(e, t) {
    return w.types.callExpression(e.addHelper("toPropertyKey"), [t]);
  }
  i(z2, "createToPropertyKeyCall");
  function J2(e) {
    return w.types.arrowFunctionExpression([w.types.identifier("_")], w.types.binaryExpression("in", w.types.cloneNode(e), w.types.identifier(
    "_")));
  }
  i(J2, "createPrivateBrandCheckClosure");
  function kye(e) {
    try {
      return w.types.traverseFast(e, (t) => {
        if (w.types.isPrivateName(t))
          throw null;
      }), !1;
    } catch {
      return !0;
    }
  }
  i(kye, "usesPrivateField");
  function Fye(e) {
    let {
      node: t
    } = e;
    t.computed = !0, w.types.isIdentifier(t.key) && (t.key = w.types.stringLiteral(t.key.name));
  }
  i(Fye, "convertToComputedKey");
  function G2(e, t) {
    let r = !1;
    if (t.length > 0) {
      let s = (0, VD.privateNameVisitorFactory)({
        PrivateName(a, o) {
          o.privateNamesMap.has(a.node.id.name) && (r = !0, a.stop());
        }
      }), n = /* @__PURE__ */ new Map();
      for (let a of t)
        n.set(a, null);
      e.traverse(s, {
        privateNamesMap: n
      });
    }
    return r;
  }
  i(G2, "hasInstancePrivateAccess");
  function Lye(e, t) {
    let r = (0, VD.privateNameVisitorFactory)({
      PrivateName(n, a) {
        if (!a.privateNamesMap.has(n.node.id.name)) return;
        let o = n.parentPath, l = o.parentPath;
        if (l.node.type === "AssignmentExpression" && l.node.left === o.node || l.node.type === "UpdateExpression" || l.node.type === "RestE\
lement" || l.node.type === "ArrayPattern" || l.node.type === "ObjectProperty" && l.node.value === o.node && l.parentPath.type === "ObjectPat\
tern" || l.node.type === "ForOfStatement" && l.node.left === o.node)
          throw n.buildCodeFrameError(`Decorated private methods are read-only, but "#${n.node.id.name}" is updated via this expression.`);
      }
    }), s = /* @__PURE__ */ new Map();
    for (let n of t)
      s.set(n, null);
    e.traverse(r, {
      privateNamesMap: s
    });
  }
  i(Lye, "checkPrivateMethodUpdateError");
  function jye(e, t, r, s, n, a, o) {
    var l;
    let u = e.get("body.body"), c = e.node.decorators, p = !1, f = !1, h = !1, b = dye(e), T = [], d = e.scope.parent, g = /* @__PURE__ */ i(
    (Q, H, he) => {
      let qe = lr(d, H);
      return he.push(w.types.assignmentExpression("=", qe, Q)), w.types.cloneNode(qe);
    }, "memoiseExpression"), E, _, N = (l = e.node.id) == null ? void 0 : l.name, k = typeof n == "object" ? n : void 0, j = /* @__PURE__ */ i(
    (Q) => {
      try {
        return w.types.traverseFast(Q, (H) => {
          if (w.types.isThisExpression(H) || w.types.isSuper(H) || w.types.isYieldExpression(H) || w.types.isAwaitExpression(H) || w.types.isIdentifier(
          H, {
            name: "arguments"
          }) || N && w.types.isIdentifier(H, {
            name: N
          }) || w.types.isMetaProperty(H) && H.meta.name !== "import")
            throw null;
        }), !1;
      } catch {
        return !0;
      }
    }, "usesFunctionContextOrYieldAwait"), U = [];
    for (let Q of u) {
      if (!UD(Q))
        continue;
      let H = Q.node;
      if (!H.static && w.types.isPrivateName(H.key) && U.push(H.key.id.name), rl(H)) {
        switch (H.type) {
          case "ClassProperty":
            a.ClassProperty(Q, t);
            break;
          case "ClassPrivateProperty":
            a.ClassPrivateProperty(Q, t);
            break;
          case "ClassAccessorProperty":
            if (a.ClassAccessorProperty(Q, t), o === "2023-11")
              break;
          default:
            H.static ? _ ?? (_ = lr(d, "initStatic")) : E ?? (E = lr(d, "initProto"));
            break;
        }
        p = !0, h || (h = H.decorators.some(j));
      } else if (H.type === "ClassAccessorProperty") {
        a.ClassAccessorProperty(Q, t);
        let {
          key: he,
          value: qe,
          static: at,
          computed: Ye
        } = H, xt = b(), hs = kD(xt, qe, at), ut = Q.get("key"), [It] = Q.replaceWith(hs), tr, Ot;
        Ye && !ut.isConstantExpression() ? (tr = (0, Dp.memoiseComputedKey)(z2(t, he), d, d.generateUid("computedKey")), Ot = w.types.cloneNode(
        tr.left)) : (tr = w.types.cloneNode(he), Ot = w.types.cloneNode(he)), Y2(e, n), FD(e.node.id, It, tr, Ot, xt, Ye, at, o);
      }
      "computed" in Q.node && Q.node.computed && (f || (f = !d.isStatic(Q.node.key)));
    }
    if (!c && !p) {
      !e.node.id && typeof n == "string" && (e.node.id = w.types.identifier(n)), k && e.node.body.body.unshift(RD([YD(t, k)]));
      return;
    }
    let M = [], K, G = /* @__PURE__ */ new Set(), ue, te, De = null;
    function je(Q) {
      let H = !1, he = !1, qe = [];
      for (let at of Q) {
        let {
          expression: Ye
        } = at, xt;
        (o === "2023-11" || o === "2023-05") && w.types.isMemberExpression(Ye) && (w.types.isSuper(Ye.object) ? xt = w.types.thisExpression() :
        d.isStatic(Ye.object) ? xt = w.types.cloneNode(Ye.object) : (De ?? (De = lr(d, "obj")), xt = w.types.assignmentExpression("=", w.types.
        cloneNode(De), Ye.object), Ye.object = w.types.cloneNode(De))), qe.push(xt), H || (H = !d.isStatic(Ye)), he || (he = j(at));
      }
      return {
        hasSideEffects: H,
        usesFnContext: he,
        decoratorsThis: qe
      };
    }
    i(je, "handleDecorators");
    let wt = f || h || o !== "2023-11", pr = !1, Rt = 0, Dr = [], _r, Xe = [];
    if (c) {
      ue = lr(d, "initClass"), pr = e.isClassDeclaration(), {
        id: te,
        path: e
      } = hye(e, n), e.node.decorators = null;
      let Q = c.some(kye), {
        hasSideEffects: H,
        usesFnContext: he,
        decoratorsThis: qe
      } = je(c), {
        haveThis: at,
        decs: Ye
      } = qD(c, qe, o);
      if (Rt = at ? 1 : 0, Dr = Ye, (he || H && wt || Q) && (_r = g(w.types.arrayExpression(Dr), "classDecs", T)), !p)
        for (let xt of e.get("body.body")) {
          let {
            node: hs
          } = xt;
          if ("computed" in hs && hs.computed)
            if (xt.isClassProperty({
              static: !0
            })) {
              if (!xt.get("key").isConstantExpression()) {
                let It = hs.key, tr = (0, Dp.memoiseComputedKey)(It, d, d.generateUid("computedKey"));
                tr != null && (hs.key = w.types.cloneNode(tr.left), Xe.push(tr));
              }
            } else Xe.length > 0 && (tl(Xe, xt), Xe = []);
        }
    } else
      Y2(e, n), te = w.types.cloneNode(e.node.id);
    let Ir, ds = !1, Tt = [], Re = [];
    if (p) {
      if (E) {
        let Q = w.types.callExpression(w.types.cloneNode(E), [w.types.thisExpression()]);
        Tt.push(Q);
      }
      for (let Q of u) {
        if (!UD(Q)) {
          Re.length > 0 && Q.isStaticBlock() && (bye(Re, Q), Re = []);
          continue;
        }
        let {
          node: H
        } = Q, he = H.decorators, qe = !!(he != null && he.length), at = "computed" in H && H.computed, Ye = "computedKey";
        H.key.type === "PrivateName" ? Ye = H.key.id.name : !at && H.key.type === "Identifier" && (Ye = H.key.name);
        let xt, hs;
        if (qe) {
          let {
            hasSideEffects: fr,
            usesFnContext: qt,
            decoratorsThis: Nr
          } = je(he), {
            decs: Br,
            haveThis: Qr
          } = qD(he, Nr, o);
          hs = Qr, xt = Br.length === 1 ? Br[0] : w.types.arrayExpression(Br), (qt || fr && wt) && (xt = g(xt, Ye + "Decs", Xe));
        }
        if (at && !Q.get("key").isConstantExpression()) {
          let fr = H.key, qt = (0, Dp.memoiseComputedKey)(qe ? z2(t, fr) : fr, d, d.generateUid("computedKey"));
          qt != null && (c && Q.isClassProperty({
            static: !0
          }) ? (H.key = w.types.cloneNode(qt.left), Xe.push(qt)) : H.key = qt);
        }
        let {
          key: ut,
          static: It
        } = H, tr = ut.type === "PrivateName", Ot = Aye(Q);
        tr && !It && (qe && (ds = !0), (w.types.isClassPrivateProperty(H) || !Ir) && (Ir = ut)), Q.isClassMethod({
          kind: "constructor"
        }) && (K = Q);
        let hi;
        if (qe) {
          let fr, qt;
          if (at ? qt = mye(Q.get("key")) : ut.type === "PrivateName" ? qt = w.types.stringLiteral(ut.id.name) : ut.type === "Identifier" ? qt =
          w.types.stringLiteral(ut.name) : qt = w.types.cloneNode(ut), Ot === bn) {
            let {
              value: Nr
            } = Q.node, Br = o === "2023-11" && It ? [] : [w.types.thisExpression()];
            Nr && Br.push(w.types.cloneNode(Nr));
            let Qr = b(), rf = lr(d, `init_${Ye}`), k5 = w.types.callExpression(w.types.cloneNode(rf), Br), F5 = kD(Qr, k5, It), [Yb] = Q.replaceWith(
            F5);
            if (tr) {
              fr = LD(Qr, o);
              let Hb = lr(d, `get_${Ye}`), Jb = lr(d, `set_${Ye}`);
              _ye(o, Yb, ut, Hb, Jb, It), hi = [rf, Hb, Jb];
            } else
              Y2(e, n), FD(e.node.id, Yb, w.types.cloneNode(ut), w.types.isAssignmentExpression(ut) ? w.types.cloneNode(ut.left) : w.types.cloneNode(
              ut), Qr, at, It, o), hi = [rf];
          } else if (Ot === ci) {
            let Nr = lr(d, `init_${Ye}`), Br = Q.get("value"), Qr = o === "2023-11" && It ? [] : [w.types.thisExpression()];
            Br.node && Qr.push(Br.node), Br.replaceWith(w.types.callExpression(w.types.cloneNode(Nr), Qr)), hi = [Nr], tr && (fr = LD(ut, o));
          } else if (tr) {
            let Nr = lr(d, `call_${Ye}`);
            if (hi = [Nr], new BD.default({
              constantSuper: r,
              methodPath: Q,
              objectRef: te,
              superRef: e.node.superClass,
              file: t.file,
              refToPreserve: te
            }).replace(), fr = [$D(Q.node)], Ot === WD || Ot === _p)
              Iye(Q, w.types.cloneNode(ut), w.types.cloneNode(Nr), It);
            else {
              let Qr = Q.node;
              e.node.body.body.unshift(w.types.classPrivateProperty(ut, w.types.cloneNode(Nr), [], Qr.static)), G.add(ut.id.name), Q.remove();
            }
          }
          M.push({
            kind: Ot,
            decoratorsArray: xt,
            decoratorsHaveThis: hs,
            name: qt,
            isStatic: It,
            privateMethods: fr,
            locals: hi
          }), Q.node && (Q.node.decorators = null);
        }
        if (at && Xe.length > 0 && (c && Q.isClassProperty({
          static: !0
        }) || (tl(Xe, Ot === bn ? Q.getNextSibling() : Q), Xe = [])), Tt.length > 0 && !It && (Ot === ci || Ot === bn) && (H2(Tt, Q), Tt = []),
        Re.length > 0 && It && (Ot === ci || Ot === bn) && (H2(Re, Q), Re = []), qe && o === "2023-11" && (Ot === ci || Ot === bn)) {
          let fr = lr(d, `init_extra_${Ye}`);
          hi.push(fr);
          let qt = w.types.callExpression(w.types.cloneNode(fr), It ? [] : [w.types.thisExpression()]);
          It ? Re.push(qt) : Tt.push(qt);
        }
      }
    }
    if (Xe.length > 0) {
      let Q = e.get("body.body"), H;
      for (let he = Q.length - 1; he >= 0; he--) {
        let qe = Q[he], at = qe.node;
        if (at.computed) {
          if (c && w.types.isClassProperty(at, {
            static: !0
          }))
            continue;
          H = qe;
          break;
        }
      }
      H != null && (yye(Xe, H), Xe = []);
    }
    if (Tt.length > 0) {
      let Q = !!e.node.superClass;
      K ? Q ? xye(Tt, K, E) : gye(Tt, K) : e.node.body.body.unshift(MD(Tt, Q)), Tt = [];
    }
    Re.length > 0 && (e.node.body.body.push(RD(Re)), Re = []);
    let Be = Cye(M), Dt = wye(o === "2023-11" ? M : Be, o), _t = Dye(Be);
    E && _t.push(E), _ && _t.push(_);
    let Or = [], va = !1, vn = ue && w.types.callExpression(w.types.cloneNode(ue), []), Pa = e, $s = e.node, Vs = [];
    if (c) {
      Or.push(te, ue);
      let Q = [];
      if (e.get("body.body").forEach((H) => {
        if (H.isStaticBlock()) {
          if (G2(H, U)) {
            let he = g(Nye(H.node), "staticBlock", Vs);
            Re.push(w.types.callExpression(w.types.memberExpression(he, w.types.identifier("call")), [w.types.thisExpression()]));
          } else
            Re.push(Oye(H.node));
          H.remove();
          return;
        }
        if ((H.isClassProperty() || H.isClassPrivateProperty()) && H.node.static) {
          let he = H.get("value");
          if (G2(he, U)) {
            let qe = g(Bye(he.node), "fieldValue", Vs);
            he.replaceWith(w.types.callExpression(w.types.memberExpression(qe, w.types.identifier("call")), [w.types.thisExpression()]));
          }
          Re.length > 0 && (H2(Re, H), Re = []), H.node.static = !1, Q.push(H.node), H.remove();
        } else if (H.isClassPrivateMethod({
          static: !0
        })) {
          if (G2(H, U)) {
            new BD.default({
              constantSuper: r,
              methodPath: H,
              objectRef: te,
              superRef: e.node.superClass,
              file: t.file,
              refToPreserve: te
            }).replace();
            let qe = g($D(H.node), H.get("key.id").node.name, Vs);
            s ? (H.node.params = [w.types.restElement(w.types.identifier("arg"))], H.node.body = w.types.blockStatement([w.types.returnStatement(
            w.types.callExpression(w.types.memberExpression(qe, w.types.identifier("apply")), [w.types.thisExpression(), w.types.identifier(
            "arg")]))])) : (H.node.params = H.node.params.map((at, Ye) => w.types.isRestElement(at) ? w.types.restElement(w.types.identifier(
            "arg")) : w.types.identifier("_" + Ye)), H.node.body = w.types.blockStatement([w.types.returnStatement(w.types.callExpression(w.
            types.memberExpression(qe, w.types.identifier("apply")), [w.types.thisExpression(), w.types.identifier("arguments")]))]));
          }
          H.node.static = !1, Q.push(H.node), H.remove();
        }
      }), Q.length > 0 || Re.length > 0) {
        let H = w.template.expression.ast`
        class extends ${t.addHelper("identity")} {}
      `;
        H.body.body = [w.types.classProperty(w.types.toExpression($s), void 0, void 0, void 0, !0, !0), ...Q];
        let he = [], qe = w.types.newExpression(H, []);
        Re.length > 0 && he.push(...Re), vn && (va = !0, he.push(vn)), he.length > 0 ? (he.unshift(w.types.callExpression(w.types.super(), [
        w.types.cloneNode(te)])), H.body.body.push(MD(he, !1))) : qe.arguments.push(w.types.cloneNode(te));
        let [at] = e.replaceWith(qe);
        Pa = at.get("callee").get("body").get("body.0.key");
      }
    }
    !va && vn && e.node.body.body.push(w.types.staticBlock([w.types.expressionStatement(vn)]));
    let {
      superClass: Ks
    } = $s;
    if (Ks && (o === "2023-11" || o === "2023-05")) {
      let Q = e.scope.maybeGenerateMemoised(Ks);
      Q && ($s.superClass = w.types.assignmentExpression("=", Q, Ks), Ks = Q);
    }
    let Aa = w.types.staticBlock([]);
    $s.body.body.unshift(Aa);
    let dl = Aa.body;
    if (Xe.length > 0) {
      let Q = Pa.get("body.body"), H;
      for (let he of Q)
        if ((he.isClassProperty() || he.isClassMethod()) && he.node.kind !== "constructor") {
          H = he;
          break;
        }
      H != null ? (Fye(H), tl(Xe, H)) : ($s.body.body.unshift(w.types.classProperty(w.types.sequenceExpression([...Xe, w.types.stringLiteral(
      "_")]), void 0, void 0, void 0, !0, !0)), dl.push(w.types.expressionStatement(w.types.unaryExpression("delete", w.types.memberExpression(
      w.types.thisExpression(), w.types.identifier("_")))))), Xe = [];
    }
    if (dl.push(w.types.expressionStatement(Mye(_t, Or, Dt, _r ?? w.types.arrayExpression(Dr), w.types.numericLiteral(Rt), ds ? Ir : null, k,
    w.types.cloneNode(Ks), t, o))), _ && dl.push(w.types.expressionStatement(w.types.callExpression(w.types.cloneNode(_), [w.types.thisExpression()]))),
    Vs.length > 0 && dl.push(...Vs.map((Q) => w.types.expressionStatement(Q))), e.insertBefore(T.map((Q) => w.types.expressionStatement(Q))),
    pr)
      if (!d.getBinding(te.name).constantViolations.length)
        e.insertBefore(w.types.variableDeclaration("let", [w.types.variableDeclarator(w.types.cloneNode(te))]));
      else {
        let H = d.generateUidIdentifier("t" + te.name), he = te;
        e.replaceWithMultiple([w.types.variableDeclaration("let", [w.types.variableDeclarator(w.types.cloneNode(he)), w.types.variableDeclarator(
        H)]), w.types.blockStatement([w.types.variableDeclaration("let", [w.types.variableDeclarator(w.types.cloneNode(te))]), e.node, w.types.
        expressionStatement(w.types.assignmentExpression("=", w.types.cloneNode(H), w.types.cloneNode(te)))]), w.types.expressionStatement(w.
        types.assignmentExpression("=", w.types.cloneNode(he), w.types.cloneNode(H)))]);
      }
    return G.size > 0 && Lye(e, G), e.scope.crawl(), e;
  }
  i(jye, "transformClass");
  function Mye(e, t, r, s, n, a, o, l, u, c) {
    let p, f, h = [o ? YD(u, o) : w.types.thisExpression(), s, r];
    {
      if (c !== "2023-11" && h.splice(1, 2, r, s), c === "2021-12" || c === "2022-03" && !u.availableHelper("applyDecs2203R"))
        return p = w.types.arrayPattern([...e, ...t]), f = w.types.callExpression(u.addHelper(c === "2021-12" ? "applyDecs" : "applyDecs2203"),
        h), w.types.assignmentExpression("=", p, f);
      c === "2022-03" ? f = w.types.callExpression(u.addHelper("applyDecs2203R"), h) : c === "2023-01" ? (a && h.push(J2(a)), f = w.types.callExpression(
      u.addHelper("applyDecs2301"), h)) : c === "2023-05" && ((a || l || n.value !== 0) && h.push(n), a ? h.push(J2(a)) : l && h.push(w.types.
      unaryExpression("void", w.types.numericLiteral(0))), l && h.push(l), f = w.types.callExpression(u.addHelper("applyDecs2305"), h));
    }
    return c === "2023-11" && ((a || l || n.value !== 0) && h.push(n), a ? h.push(J2(a)) : l && h.push(w.types.unaryExpression("void", w.types.
    numericLiteral(0))), l && h.push(l), f = w.types.callExpression(u.addHelper("applyDecs2311"), h)), e.length > 0 ? t.length > 0 ? p = w.types.
    objectPattern([w.types.objectProperty(w.types.identifier("e"), w.types.arrayPattern(e)), w.types.objectProperty(w.types.identifier("c"),
    w.types.arrayPattern(t))]) : (p = w.types.arrayPattern(e), f = w.types.memberExpression(f, w.types.identifier("e"), !1, !1)) : (p = w.types.
    arrayPattern(t), f = w.types.memberExpression(f, w.types.identifier("c"), !1, !1)), w.types.assignmentExpression("=", p, f);
  }
  i(Mye, "createLocalsAssignment");
  function Rye(e) {
    return e.type === "Identifier" ? e.name === "__proto__" : e.value === "__proto__";
  }
  i(Rye, "isProtoKey");
  function rl(e) {
    return e.decorators && e.decorators.length > 0;
  }
  i(rl, "isDecorated");
  function qye(e) {
    switch (e.type) {
      case "ClassAccessorProperty":
        return !0;
      case "ClassMethod":
      case "ClassProperty":
      case "ClassPrivateMethod":
      case "ClassPrivateProperty":
        return rl(e);
      default:
        return !1;
    }
  }
  i(qye, "shouldTransformElement");
  function Uye(e) {
    return rl(e) || e.body.body.some(qye);
  }
  i(Uye, "shouldTransformClass");
  function HD(e, t) {
    function r(s, n, a) {
      switch (n.type) {
        case "StringLiteral":
          return w.types.stringLiteral(n.value);
        case "NumericLiteral":
        case "BigIntLiteral": {
          let o = n.value + "";
          return s.get("key").replaceWith(w.types.stringLiteral(o)), w.types.stringLiteral(o);
        }
        default: {
          let o = s.scope.maybeGenerateMemoised(n);
          return s.get("key").replaceWith(w.types.assignmentExpression("=", o, z2(a, n))), w.types.cloneNode(o);
        }
      }
    }
    return i(r, "handleComputedProperty"), {
      VariableDeclarator(s, n) {
        let a = s.node.id;
        if (a.type === "Identifier") {
          let o = (0, yn.skipTransparentExprWrappers)(s.get("init"));
          if (e(o)) {
            let l = a.name;
            t(o, n, l);
          }
        }
      },
      AssignmentExpression(s, n) {
        let a = s.node.left;
        if (a.type === "Identifier") {
          let o = (0, yn.skipTransparentExprWrappers)(s.get("right"));
          if (e(o))
            switch (s.node.operator) {
              case "=":
              case "&&=":
              case "||=":
              case "??=":
                t(o, n, a.name);
            }
        }
      },
      AssignmentPattern(s, n) {
        let a = s.node.left;
        if (a.type === "Identifier") {
          let o = (0, yn.skipTransparentExprWrappers)(s.get("right"));
          if (e(o)) {
            let l = a.name;
            t(o, n, l);
          }
        }
      },
      ObjectExpression(s, n) {
        for (let a of s.get("properties")) {
          if (!a.isObjectProperty()) continue;
          let {
            node: o
          } = a, l = o.key, u = (0, yn.skipTransparentExprWrappers)(a.get("value"));
          if (e(u)) {
            if (o.computed) {
              let c = r(a, l, n);
              t(u, n, c);
            } else if (!Rye(l))
              if (l.type === "Identifier")
                t(u, n, l.name);
              else {
                let c = w.types.stringLiteral(l.value + "");
                t(u, n, c);
              }
          }
        }
      },
      ClassPrivateProperty(s, n) {
        let {
          node: a
        } = s, o = (0, yn.skipTransparentExprWrappers)(s.get("value"));
        if (e(o)) {
          let l = w.types.stringLiteral("#" + a.key.id.name);
          t(o, n, l);
        }
      },
      ClassAccessorProperty(s, n) {
        let {
          node: a
        } = s, o = a.key, l = (0, yn.skipTransparentExprWrappers)(s.get("value"));
        if (e(l))
          if (a.computed) {
            let u = r(s, o, n);
            t(l, n, u);
          } else if (o.type === "Identifier")
            t(l, n, o.name);
          else if (o.type === "PrivateName") {
            let u = w.types.stringLiteral("#" + o.id.name);
            t(l, n, u);
          } else {
            let u = w.types.stringLiteral(o.value + "");
            t(l, n, u);
          }
      },
      ClassProperty(s, n) {
        let {
          node: a
        } = s, o = a.key, l = (0, yn.skipTransparentExprWrappers)(s.get("value"));
        if (e(l))
          if (a.computed) {
            let u = r(s, o, n);
            t(l, n, u);
          } else if (o.type === "Identifier")
            t(l, n, o.name);
          else {
            let u = w.types.stringLiteral(o.value + "");
            t(l, n, u);
          }
      }
    };
  }
  i(HD, "buildNamedEvaluationVisitor");
  function $ye(e) {
    return e.isClassExpression({
      id: null
    }) && Uye(e.node);
  }
  i($ye, "isDecoratedAnonymousClassExpression");
  function lr(e, t) {
    let r = e.generateUidIdentifier(t);
    return e.push({
      id: r,
      kind: "let"
    }), w.types.cloneNode(r);
  }
  i(lr, "generateLetUidIdentifier");
  function Vye({
    assertVersion: e,
    assumption: t
  }, {
    loose: r
  }, s, n) {
    var a, o;
    e(s === "2023-11" || s === "2023-05" || s === "2023-01" ? "^7.21.0" : s === "2021-12" ? "^7.16.0" : "^7.19.0");
    let l = /* @__PURE__ */ new WeakSet(), u = (a = t("constantSuper")) != null ? a : r, c = (o = t("ignoreFunctionLength")) != null ? o : r,
    p = HD($ye, f);
    function f(h, b, T) {
      var d;
      if (l.has(h)) return;
      let {
        node: g
      } = h;
      T ?? (T = (d = g.id) == null ? void 0 : d.name);
      let E = jye(h, b, u, c, T, p, s);
      if (E) {
        l.add(E);
        return;
      }
      l.add(h);
    }
    return i(f, "visitClass"), {
      name: "proposal-decorators",
      inherits: n,
      visitor: Object.assign({
        ExportDefaultDeclaration(h, b) {
          let {
            declaration: T
          } = h.node;
          if (T?.type === "ClassDeclaration" && rl(T)) {
            let g = !T.id;
            {
              var d;
              (d = h.splitExportDeclaration) != null || (h.splitExportDeclaration = nt().NodePath.prototype.splitExportDeclaration);
            }
            let E = h.splitExportDeclaration();
            g && f(E, b, w.types.stringLiteral("default"));
          }
        },
        ExportNamedDeclaration(h) {
          let {
            declaration: b
          } = h.node;
          if (b?.type === "ClassDeclaration" && rl(b)) {
            {
              var T;
              (T = h.splitExportDeclaration) != null || (h.splitExportDeclaration = nt().NodePath.prototype.splitExportDeclaration);
            }
            h.splitExportDeclaration();
          }
        },
        Class(h, b) {
          f(h, b, void 0);
        }
      }, p)
    };
  }
  i(Vye, "_default");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/decorators-2018-09.js
var GD = D((eb) => {
  "use strict";
  Object.defineProperty(eb, "__esModule", {
    value: !0
  });
  eb.buildDecoratedClass = Gye;
  var Me = et(), Kye = vp();
  function da(e, t) {
    return t ? Me.types.objectProperty(Me.types.identifier(e), t) : null;
  }
  i(da, "prop");
  function Wye(e, t) {
    return Me.types.objectMethod("method", Me.types.identifier(e), [], Me.types.blockStatement(t));
  }
  i(Wye, "method");
  function JD(e) {
    let t;
    return e.decorators && e.decorators.length > 0 && (t = Me.types.arrayExpression(e.decorators.map((r) => r.expression))), e.decorators = void 0,
    t;
  }
  i(JD, "takeDecorators");
  function Yye(e) {
    return e.computed ? e.key : Me.types.isIdentifier(e.key) ? Me.types.stringLiteral(e.key.name) : Me.types.stringLiteral(String(e.key.value));
  }
  i(Yye, "getKey");
  function Hye(e, t, r, s) {
    let n = s.isClassMethod();
    if (s.isPrivate())
      throw s.buildCodeFrameError(`Private ${n ? "methods" : "fields"} in decorated classes are not supported yet.`);
    if (s.node.type === "ClassAccessorProperty")
      throw s.buildCodeFrameError('Accessor properties are not supported in 2018-09 decorator transform, please specify { "version": "2021-1\
2" } instead.');
    if (s.node.type === "StaticBlock")
      throw s.buildCodeFrameError('Static blocks are not supported in 2018-09 decorator transform, please specify { "version": "2021-12" } i\
nstead.');
    let {
      node: a,
      scope: o
    } = s;
    s.isTSDeclareMethod() || new Kye.default({
      methodPath: s,
      objectRef: t,
      superRef: r,
      file: e,
      refToPreserve: t
    }).replace();
    let l = [da("kind", Me.types.stringLiteral(Me.types.isClassMethod(a) ? a.kind : "field")), da("decorators", JD(a)), da("static", a.static &&
    Me.types.booleanLiteral(!0)), da("key", Yye(a))].filter(Boolean);
    if (n) {
      {
        var u;
        (u = s.ensureFunctionName) != null || (s.ensureFunctionName = nt().NodePath.prototype.ensureFunctionName);
      }
      s.ensureFunctionName(!1), l.push(da("value", Me.types.toExpression(s.node)));
    } else Me.types.isClassProperty(a) && a.value ? l.push(Wye("value", Me.template.statements.ast`return ${a.value}`)) : l.push(da("value",
    o.buildUndefinedNode()));
    return s.remove(), Me.types.objectExpression(l);
  }
  i(Hye, "extractElementDescriptor");
  function Jye(e) {
    return e.addHelper("decorate");
  }
  i(Jye, "addDecorateHelper");
  function Gye(e, t, r, s) {
    let {
      node: n,
      scope: a
    } = t, o = a.generateUidIdentifier("initialize"), l = n.id && t.isDeclaration(), u = t.isInStrictMode(), {
      superClass: c
    } = n;
    n.type = "ClassDeclaration", n.id || (n.id = Me.types.cloneNode(e));
    let p;
    c && (p = a.generateUidIdentifierBasedOnNode(n.superClass, "super"), n.superClass = p);
    let f = JD(n), h = Me.types.arrayExpression(r.filter((g) => !g.node.abstract && g.node.type !== "TSIndexSignature").map((g) => Hye(s, n.
    id, p, g))), b = Me.template.expression.ast`
    ${Jye(s)}(
      ${f || Me.types.nullLiteral()},
      function (${o}, ${c ? Me.types.cloneNode(p) : null}) {
        ${n}
        return { F: ${Me.types.cloneNode(n.id)}, d: ${h} };
      },
      ${c}
    )
  `;
    u || b.arguments[1].body.directives.push(Me.types.directive(Me.types.directiveLiteral("use strict")));
    let T = b, d = "arguments.1.body.body.0";
    return l && (T = Me.template.statement.ast`let ${e} = ${b}`, d = "declarations.0.init." + d), {
      instanceNodes: [Me.template.statement.ast`
        ${Me.types.cloneNode(o)}(this)
      `],
      wrapClass(g) {
        return g.replaceWith(T), g.get(d);
      }
    };
  }
  i(Gye, "buildDecoratedClass");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/features.js
var ZD = D((pi) => {
  "use strict";
  Object.defineProperty(pi, "__esModule", {
    value: !0
  });
  pi.FEATURES = void 0;
  pi.enableFeature = Xye;
  pi.isLoose = sb;
  pi.shouldTransform = zye;
  var XD = Z2(), js = pi.FEATURES = Object.freeze({
    fields: 2,
    privateMethods: 4,
    decorators: 8,
    privateIn: 16,
    staticBlocks: 32
  }), zD = /* @__PURE__ */ new Map([[js.fields, "@babel/plugin-transform-class-properties"], [js.privateMethods, "@babel/plugin-transform-pr\
ivate-methods"], [js.privateIn, "@babel/plugin-transform-private-property-in-object"]]), tb = "@babel/plugin-class-features/featuresKey", sl = "\
@babel/plugin-class-features/looseKey";
  Tn = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
  var Tn;
  rb = /* @__PURE__ */ i(function(e, t) {
    return !!(e.get(Tn) & t);
  }, "canIgnoreLoose");
  var rb;
  function Xye(e, t, r) {
    (!Ms(e, t) || rb(e, t)) && (e.set(tb, e.get(tb) | t), r === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-\
an-error" ? (Ip(e, t, !0), e.set(Tn, e.get(Tn) | t)) : r === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-\
error" ? (Ip(e, t, !1), e.set(Tn, e.get(Tn) | t)) : Ip(e, t, r));
    let s;
    for (let [a, o] of zD) {
      if (!Ms(e, a) || rb(e, a)) continue;
      let l = sb(e, a);
      if (s === !l)
        throw new Error(`'loose' mode configuration must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-p\
rivate-methods and @babel/plugin-transform-private-property-in-object (when they are enabled).

` + QD(e));
      s = l;
      var n = o;
    }
    if (s !== void 0)
      for (let [a, o] of zD)
        Ms(e, a) && sb(e, a) !== s && (Ip(e, a, s), console.warn(`Though the "loose" option was set to "${!s}" in your @babel/preset-env con\
fig, it will not be used for ${o} since the "loose" mode option was set to "${s}" for ${n}.
The "loose" option must be the same for @babel/plugin-transform-class-properties, @babel/plugin-transform-private-methods and @babel/plugin-\
transform-private-property-in-object (when they are enabled): you can silence this warning by explicitly adding
	["${o}", { "loose": ${s} }]
to the "plugins" section of your Babel config.

` + QD(e)));
  }
  i(Xye, "enableFeature");
  function QD(e) {
    let {
      filename: t
    } = e.opts;
    return (!t || t === "unknown") && (t = "[name of the input file]"), `If you already set the same 'loose' mode for these plugins in your \
config, it's possible that they are enabled multiple times with different options.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${t} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.`;
  }
  i(QD, "getBabelShowConfigForHint");
  function Ms(e, t) {
    return !!(e.get(tb) & t);
  }
  i(Ms, "hasFeature");
  function sb(e, t) {
    return !!(e.get(sl) & t);
  }
  i(sb, "isLoose");
  function Ip(e, t, r) {
    r ? e.set(sl, e.get(sl) | t) : e.set(sl, e.get(sl) & ~t), e.set(Tn, e.get(Tn) & ~t);
  }
  i(Ip, "setLoose");
  function zye(e, t) {
    let r = null, s = null, n = null, a = null, o = null;
    (0, XD.hasOwnDecorators)(e.node) && (r = e.get("decorators.0"));
    for (let l of e.get("body.body"))
      !r && (0, XD.hasOwnDecorators)(l.node) && (r = l.get("decorators.0")), !s && l.isClassProperty() && (s = l), !n && l.isClassPrivateProperty() &&
      (n = l), !a && l.isClassPrivateMethod != null && l.isClassPrivateMethod() && (a = l), !o && l.isStaticBlock != null && l.isStaticBlock() &&
      (o = l);
    if (r && n)
      throw n.buildCodeFrameError("Private fields in decorated classes are not supported yet.");
    if (r && a)
      throw a.buildCodeFrameError("Private methods in decorated classes are not supported yet.");
    if (r && !Ms(t, js.decorators))
      throw e.buildCodeFrameError(`Decorators are not enabled.
If you are using ["@babel/plugin-proposal-decorators", { "version": "legacy" }], make sure it comes *before* "@babel/plugin-transform-class-\
properties" and enable loose mode, like so:
	["@babel/plugin-proposal-decorators", { "version": "legacy" }]
	["@babel/plugin-transform-class-properties", { "loose": true }]`);
    if (a && !Ms(t, js.privateMethods))
      throw a.buildCodeFrameError("Class private methods are not enabled. Please add `@babel/plugin-transform-private-methods` to your confi\
guration.");
    if ((s || n) && !Ms(t, js.fields) && !Ms(t, js.privateMethods))
      throw e.buildCodeFrameError("Class fields are not enabled. Please add `@babel/plugin-transform-class-properties` to your configuration\
.");
    if (o && !Ms(t, js.staticBlocks))
      throw e.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-transform-class-static-block` to your conf\
iguration.");
    return !!(r || a || o || (s || n) && Ms(t, js.fields));
  }
  i(zye, "shouldTransform");
});

// ../node_modules/@babel/helper-create-class-features-plugin/lib/index.js
var e8 = D((xn) => {
  "use strict";
  Object.defineProperty(xn, "__esModule", {
    value: !0
  });
  Object.defineProperty(xn, "FEATURES", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return ha.FEATURES;
    }, "get")
  });
  Object.defineProperty(xn, "buildCheckInRHS", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return nl.buildCheckInRHS;
    }, "get")
  });
  Object.defineProperty(xn, "buildNamedEvaluationVisitor", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Op.buildNamedEvaluationVisitor;
    }, "get")
  });
  xn.createClassFeaturePlugin = t2e;
  Object.defineProperty(xn, "enableFeature", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return ha.enableFeature;
    }, "get")
  });
  Object.defineProperty(xn, "injectInitialization", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return ib.injectInitialization;
    }, "get")
  });
  var nb = et(), Qye = z("semver"), nl = K2(), Op = Z2(), Zye = GD(), ib = W2(), ha = ZD(), e2e = R2(), fi = "@babel/plugin-class-features/v\
ersion";
  function t2e({
    name: e,
    feature: t,
    loose: r,
    manipulateOptions: s,
    api: n,
    inherits: a,
    decoratorVersion: o
  }) {
    var l;
    if (t & ha.FEATURES.decorators && (o === "2023-11" || o === "2023-05" || o === "2023-01" || o === "2022-03" || o === "2021-12"))
      return (0, Op.default)(n, {
        loose: r
      }, o, a);
    n ?? (n = {
      assumption: /* @__PURE__ */ i(() => {
      }, "assumption")
    });
    let u = n.assumption("setPublicClassFields"), c = n.assumption("privateFieldsAsSymbols"), p = n.assumption("privateFieldsAsProperties"),
    f = (l = n.assumption("noUninitializedPrivateFieldAccess")) != null ? l : !1, h = n.assumption("constantSuper"), b = n.assumption("noDoc\
umentAll");
    if (p && c)
      throw new Error('Cannot enable both the "privateFieldsAsProperties" and "privateFieldsAsSymbols" assumptions as the same time.');
    let T = p || c;
    if (r === !0) {
      let d = [];
      u !== void 0 && d.push('"setPublicClassFields"'), p !== void 0 && d.push('"privateFieldsAsProperties"'), c !== void 0 && d.push('"priv\
ateFieldsAsSymbols"'), d.length !== 0 && console.warn(`[${e}]: You are using the "loose: true" option and you are explicitly setting a value\
 for the ${d.join(" and ")} assumption${d.length > 1 ? "s" : ""}. The "loose" option can cause incompatibilities with the other class featur\
es plugins, so it's recommended that you replace it with the following top-level option:
	"assumptions": {
		"setPublicClassFields": true,
		"privateFieldsAsSymbols": true
	}`);
    }
    return {
      name: e,
      manipulateOptions: s,
      inherits: a,
      pre(d) {
        if ((0, ha.enableFeature)(d, t, r), typeof d.get(fi) == "number") {
          d.set(fi, "7.28.3");
          return;
        }
        (!d.get(fi) || Qye.lt(d.get(fi), "7.28.3")) && d.set(fi, "7.28.3");
      },
      visitor: {
        Class(d, {
          file: g
        }) {
          if (g.get(fi) !== "7.28.3" || !(0, ha.shouldTransform)(d, g)) return;
          let E = d.isClassDeclaration();
          E && (0, e2e.assertFieldTransformed)(d);
          let _ = (0, ha.isLoose)(g, t), N, k = (0, Op.hasDecorators)(d.node), j = [], U = [], M = [], K = /* @__PURE__ */ new Set(), G = d.
          get("body");
          for (let Be of G.get("body")) {
            if ((Be.isClassProperty() || Be.isClassMethod()) && Be.node.computed && M.push(Be), Be.isPrivate()) {
              let {
                name: Dt
              } = Be.node.key.id, _t = `get ${Dt}`, Or = `set ${Dt}`;
              if (Be.isClassPrivateMethod()) {
                if (Be.node.kind === "get") {
                  if (K.has(_t) || K.has(Dt) && !K.has(Or))
                    throw Be.buildCodeFrameError("Duplicate private field");
                  K.add(_t).add(Dt);
                } else if (Be.node.kind === "set") {
                  if (K.has(Or) || K.has(Dt) && !K.has(_t))
                    throw Be.buildCodeFrameError("Duplicate private field");
                  K.add(Or).add(Dt);
                }
              } else {
                if (K.has(Dt) && !K.has(_t) && !K.has(Or) || K.has(Dt) && (K.has(_t) || K.has(Or)))
                  throw Be.buildCodeFrameError("Duplicate private field");
                K.add(Dt);
              }
            }
            Be.isClassMethod({
              kind: "constructor"
            }) ? N = Be : (U.push(Be), (Be.isProperty() || Be.isPrivate() || Be.isStaticBlock != null && Be.isStaticBlock()) && j.push(Be));
          }
          if (!j.length && !k) return;
          let ue = d.node.id, te;
          if (!ue || !E) {
            {
              var De;
              (De = d.ensureFunctionName) != null || (d.ensureFunctionName = nt().NodePath.prototype.ensureFunctionName);
            }
            d.ensureFunctionName(!1), te = d.scope.generateUidIdentifier(ue?.name || "Class");
          }
          let je = te ?? nb.types.cloneNode(ue), wt = (0, nl.buildPrivateNamesMap)(je.name, T ?? _, j, g), pr = (0, nl.buildPrivateNamesNodes)(
          wt, p ?? _, c ?? !1, g);
          (0, nl.transformPrivateNamesUsage)(je, d, wt, {
            privateFieldsAsProperties: T ?? _,
            noUninitializedPrivateFieldAccess: f,
            noDocumentAll: b,
            innerBinding: ue
          }, g);
          let Rt, Dr, _r, Xe, Ir, ds, Tt;
          k ? (Dr = Ir = Rt = [], {
            instanceNodes: _r,
            wrapClass: Tt
          } = (0, Zye.buildDecoratedClass)(je, d, U, g)) : (Rt = (0, ib.extractComputedKeys)(d, M, g), {
            staticNodes: Dr,
            pureStaticNodes: Ir,
            instanceNodes: _r,
            lastInstanceNodeReturnsThis: Xe,
            classBindingNode: ds,
            wrapClass: Tt
          } = (0, nl.buildFieldsInitNodes)(te, d.node.superClass, j, wt, g, u ?? _, T ?? _, f, h ?? _, ue)), _r.length > 0 && (0, ib.injectInitialization)(
          d, N, _r, (Be, Dt) => {
            if (!k)
              for (let _t of j)
                nb.types.isStaticBlock != null && nb.types.isStaticBlock(_t.node) || _t.node.static || _t.traverse(Be, Dt);
          }, Xe);
          let Re = Tt(d);
          Re.insertBefore([...pr, ...Rt]), Dr.length > 0 && Re.insertAfter(Dr), Ir.length > 0 && Re.find((Be) => Be.isStatement() || Be.isDeclaration()).
          insertAfter(Ir), ds != null && E && Re.insertAfter(ds);
        },
        ExportDefaultDeclaration(d, {
          file: g
        }) {
          {
            if (g.get(fi) !== "7.28.3") return;
            let _ = d.get("declaration");
            if (_.isClassDeclaration() && (0, Op.hasDecorators)(_.node))
              if (_.node.id) {
                {
                  var E;
                  (E = d.splitExportDeclaration) != null || (d.splitExportDeclaration = nt().NodePath.prototype.splitExportDeclaration);
                }
                d.splitExportDeclaration();
              } else
                _.node.type = "ClassExpression";
          }
        }
      }
    };
  }
  i(t2e, "createClassFeaturePlugin");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/enum.js
var ob = D((il) => {
  "use strict";
  Object.defineProperty(il, "__esModule", {
    value: !0
  });
  il.default = a2e;
  il.isSyntacticallyString = Np;
  il.translateEnumValues = r8;
  var ma = et(), r2e = z("assert"), s2e = L2(), n2e = Pp(), ab = /* @__PURE__ */ new WeakMap(), i2e = ma.template.expression(`
    (function (ID) {
      ASSIGNMENTS;
      return ID;
    })(INIT)
  `);
  function a2e(e, t) {
    let {
      node: r,
      parentPath: s
    } = e;
    if (r.declare) {
      e.remove();
      return;
    }
    let n = r.id.name, {
      fill: a,
      data: o,
      isPure: l
    } = c2e(e, t, r.id);
    switch (s.type) {
      case "BlockStatement":
      case "ExportNamedDeclaration":
      case "Program": {
        let c = t.isProgram(e.parent), p = u(s), f = t.objectExpression([]);
        (p || c) && (f = t.logicalExpression("||", t.cloneNode(a.ID), f));
        let h = i2e(Object.assign({}, a, {
          INIT: f
        }));
        l && (0, s2e.default)(h), p ? (s.isExportDeclaration() ? s : e).replaceWith(t.expressionStatement(t.assignmentExpression("=", t.cloneNode(
        r.id), h))) : e.scope.registerDeclaration(e.replaceWith(t.variableDeclaration(c ? "var" : "let", [t.variableDeclarator(r.id, h)]))[0]),
        ab.set(e.scope.getBindingIdentifier(n), o);
        break;
      }
      default:
        throw new Error(`Unexpected enum parent '${e.parent.type}`);
    }
    function u(c) {
      return c.isExportDeclaration() ? u(c.parentPath) : c.getData(n) ? !0 : (c.setData(n, !0), !1);
    }
    i(u, "seen");
  }
  i(a2e, "transpileEnum");
  var o2e = ma.template.statement(`
  ENUM["NAME"] = VALUE;
`), l2e = ma.template.statement(`
  ENUM[ENUM["NAME"] = VALUE] = "NAME";
`), u2e = /* @__PURE__ */ i((e, t) => (e ? o2e : l2e)(t), "buildEnumMember");
  function c2e(e, t, r) {
    let {
      enumValues: s,
      data: n,
      isPure: a
    } = r8(e, t), o = e.get("members"), l = [];
    for (let u = 0; u < o.length; u++) {
      let [c, p] = s[u];
      l.push(t.inheritsComments(u2e(Np(p), {
        ENUM: t.cloneNode(r),
        NAME: c,
        VALUE: p
      }), o[u].node));
    }
    return {
      fill: {
        ID: t.cloneNode(r),
        ASSIGNMENTS: l
      },
      data: n,
      isPure: a
    };
  }
  i(c2e, "enumFill");
  function Np(e) {
    switch (e = (0, n2e.skipTransparentExprWrapperNodes)(e), e.type) {
      case "BinaryExpression": {
        let t = e.left, r = e.right;
        return e.operator === "+" && (Np(t) || Np(r));
      }
      case "TemplateLiteral":
      case "StringLiteral":
        return !0;
    }
    return !1;
  }
  i(Np, "isSyntacticallyString");
  function t8(e, t) {
    let {
      seen: r,
      path: s,
      t: n
    } = t, a = e.node.name;
    if (r.has(a)) {
      for (let o = e.scope; o !== s.scope; o = o.parent)
        if (o.hasOwnBinding(a))
          return;
      e.replaceWith(n.memberExpression(n.cloneNode(s.node.id), n.cloneNode(e.node))), e.skip();
    }
  }
  i(t8, "ReferencedIdentifier");
  var p2e = {
    ReferencedIdentifier: t8
  };
  function r8(e, t) {
    var r;
    let s = e.scope.getBindingIdentifier(e.node.id.name), n = (r = ab.get(s)) != null ? r : /* @__PURE__ */ new Map(), a = -1, o, l = !0, c = e.
    get("members").map((p) => {
      let f = p.node, h = t.isIdentifier(f.id) ? f.id.name : f.id.value, b = p.get("initializer"), T = f.initializer, d;
      if (T)
        a = s8(b, n), a !== void 0 ? (n.set(h, a), r2e(typeof a == "number" || typeof a == "string"), a === 1 / 0 || Number.isNaN(a) ? d = t.
        identifier(String(a)) : a === -1 / 0 ? d = t.unaryExpression("-", t.identifier("Infinity")) : d = t.valueToNode(a)) : (l && (l = b.isPure()),
        b.isReferencedIdentifier() ? t8(b, {
          t,
          seen: n,
          path: e
        }) : b.traverse(p2e, {
          t,
          seen: n,
          path: e
        }), d = b.node, n.set(h, void 0));
      else if (typeof a == "number")
        a += 1, d = t.numericLiteral(a), n.set(h, a);
      else {
        if (typeof a == "string")
          throw e.buildCodeFrameError("Enum member must have initializer.");
        {
          let g = t.memberExpression(t.cloneNode(e.node.id), t.stringLiteral(o), !0);
          d = t.binaryExpression("+", t.numericLiteral(1), g), n.set(h, void 0);
        }
      }
      return o = h, [h, d];
    });
    return {
      isPure: l,
      data: n,
      enumValues: c
    };
  }
  i(r8, "translateEnumValues");
  function s8(e, t, r = /* @__PURE__ */ new Set()) {
    return s(e);
    function s(l) {
      let u = l.node;
      switch (u.type) {
        case "MemberExpression":
          return n(l, t, r);
        case "StringLiteral":
          return u.value;
        case "UnaryExpression":
          return a(l);
        case "BinaryExpression":
          return o(l);
        case "NumericLiteral":
          return u.value;
        case "ParenthesizedExpression":
          return s(l.get("expression"));
        case "Identifier":
          return n(l, t, r);
        case "TemplateLiteral": {
          if (u.quasis.length === 1)
            return u.quasis[0].value.cooked;
          let c = l.get("expressions"), p = u.quasis, f = "";
          for (let h = 0; h < p.length; h++)
            if (f += p[h].value.cooked, h + 1 < p.length) {
              let b = n(c[h], t, r);
              if (b === void 0) return;
              f += b;
            }
          return f;
        }
        default:
          return;
      }
    }
    function n(l, u, c) {
      if (l.isMemberExpression()) {
        let p = l.node, f = p.object, h = p.property;
        if (!ma.types.isIdentifier(f) || (p.computed ? !ma.types.isStringLiteral(h) : !ma.types.isIdentifier(h)))
          return;
        let b = l.scope.getBindingIdentifier(f.name), T = ab.get(b);
        return T ? T.get(h.computed ? h.value : h.name) : void 0;
      } else if (l.isIdentifier()) {
        let p = l.node.name;
        if (["Infinity", "NaN"].includes(p))
          return Number(p);
        let f = u?.get(p);
        return f !== void 0 ? f : u != null && u.has(p) || c.has(l.node) ? void 0 : (c.add(l.node), f = s8(l.resolve(), u, c), f);
      }
    }
    function a(l) {
      let u = s(l.get("argument"));
      if (u !== void 0)
        switch (l.node.operator) {
          case "+":
            return u;
          case "-":
            return -u;
          case "~":
            return ~u;
          default:
            return;
        }
    }
    function o(l) {
      let u = s(l.get("left"));
      if (u === void 0)
        return;
      let c = s(l.get("right"));
      if (c !== void 0)
        switch (l.node.operator) {
          case "|":
            return u | c;
          case "&":
            return u & c;
          case ">>":
            return u >> c;
          case ">>>":
            return u >>> c;
          case "<<":
            return u << c;
          case "^":
            return u ^ c;
          case "*":
            return u * c;
          case "/":
            return u / c;
          case "+":
            return u + c;
          case "-":
            return u - c;
          case "%":
            return u % c;
          case "**":
            return Math.pow(u, c);
          default:
            return;
        }
    }
  }
  i(s8, "computeConstantValue");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/const-enum.js
var lb = D((al) => {
  "use strict";
  Object.defineProperty(al, "__esModule", {
    value: !0
  });
  al.EXPORTED_CONST_ENUMS_IN_NAMESPACE = void 0;
  al.default = h2e;
  var f2e = ob(), d2e = al.EXPORTED_CONST_ENUMS_IN_NAMESPACE = /* @__PURE__ */ new WeakSet();
  function h2e(e, t) {
    let {
      name: r
    } = e.node.id, s = e.parentPath.isExportNamedDeclaration(), n = s;
    !n && t.isProgram(e.parent) && (n = e.parent.body.some((l) => t.isExportNamedDeclaration(l) && l.exportKind !== "type" && !l.source && l.
    specifiers.some((u) => t.isExportSpecifier(u) && u.exportKind !== "type" && u.local.name === r)));
    let {
      enumValues: a
    } = (0, f2e.translateEnumValues)(e, t);
    if (n || d2e.has(e.node)) {
      let l = t.objectExpression(a.map(([u, c]) => t.objectProperty(t.isValidIdentifier(u) ? t.identifier(u) : t.stringLiteral(u), c)));
      e.scope.hasOwnBinding(r) ? (s ? e.parentPath : e).replaceWith(t.expressionStatement(t.callExpression(t.memberExpression(t.identifier("\
Object"), t.identifier("assign")), [e.node.id, l]))) : (e.replaceWith(t.variableDeclaration("var", [t.variableDeclarator(e.node.id, l)])), e.
      scope.registerDeclaration(e));
      return;
    }
    let o = new Map(a);
    e.scope.path.traverse({
      Scope(l) {
        l.scope.hasOwnBinding(r) && l.skip();
      },
      MemberExpression(l) {
        if (!t.isIdentifier(l.node.object, {
          name: r
        })) return;
        let u;
        if (l.node.computed)
          if (t.isStringLiteral(l.node.property))
            u = l.node.property.value;
          else
            return;
        else if (t.isIdentifier(l.node.property))
          u = l.node.property.name;
        else
          return;
        o.has(u) && l.replaceWith(t.cloneNode(o.get(u)));
      }
    }), e.remove();
  }
  i(h2e, "transpileConstEnum");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/global-types.js
var ub = D((ya) => {
  "use strict";
  Object.defineProperty(ya, "__esModule", {
    value: !0
  });
  ya.GLOBAL_TYPES = void 0;
  ya.isGlobalType = m2e;
  ya.registerGlobalType = y2e;
  var n8 = ya.GLOBAL_TYPES = /* @__PURE__ */ new WeakMap();
  function m2e({
    scope: e
  }, t) {
    return e.hasBinding(t) ? !1 : n8.get(e).has(t) ? !0 : (console.warn(`The exported identifier "${t}" is not declared in Babel's scope tra\
cker
as a JavaScript value binding, and "@babel/plugin-transform-typescript"
never encountered it as a TypeScript type declaration.
It will be treated as a JavaScript value.

This problem is likely caused by another plugin injecting
"${t}" without registering it in the scope tracker. If you are the author
 of that plugin, please use "scope.registerDeclaration(declarationPath)".`), !1);
  }
  i(m2e, "isGlobalType");
  function y2e(e, t) {
    n8.get(e).add(t);
  }
  i(y2e, "registerGlobalType");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/namespace.js
var a8 = D((Bp) => {
  "use strict";
  Object.defineProperty(Bp, "__esModule", {
    value: !0
  });
  Bp.default = T2e;
  Bp.getFirstIdentifier = db;
  var Ne = et(), b2e = ub(), g2e = lb();
  function db(e) {
    return Ne.types.isIdentifier(e) ? e : db(e.left);
  }
  i(db, "getFirstIdentifier");
  function T2e(e, t) {
    if (e.node.declare || e.node.id.type === "StringLiteral") {
      e.remove();
      return;
    }
    if (!t)
      throw e.get("id").buildCodeFrameError("Namespace not marked type-only declare. Non-declarative namespaces are only supported experimen\
tally in Babel. To enable and review caveats see: https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    let r = db(e.node.id).name, s = fb(e, e.node);
    if (s === null) {
      let n = e.findParent((a) => a.isProgram());
      (0, b2e.registerGlobalType)(n.scope, r), e.remove();
    } else e.scope.hasOwnBinding(r) ? e.replaceWith(s) : e.scope.registerDeclaration(e.replaceWithMultiple([cb(r), s])[0]);
  }
  i(T2e, "transpileNamespace");
  function cb(e) {
    return Ne.types.variableDeclaration("let", [Ne.types.variableDeclarator(Ne.types.identifier(e))]);
  }
  i(cb, "getDeclaration");
  function pb(e, t) {
    return Ne.types.memberExpression(Ne.types.identifier(e), Ne.types.identifier(t));
  }
  i(pb, "getMemberExpression");
  function x2e(e, t, r) {
    if (e.kind !== "const")
      throw r.file.buildCodeFrameError(e, "Namespaces exporting non-const are not supported by Babel. Change to const or see: https://babelj\
s.io/docs/en/babel-plugin-transform-typescript");
    let {
      declarations: s
    } = e;
    if (s.every((o) => Ne.types.isIdentifier(o.id))) {
      for (let o of s)
        o.init = Ne.types.assignmentExpression("=", pb(t, o.id.name), o.init);
      return [e];
    }
    let n = Ne.types.getBindingIdentifiers(e), a = [];
    for (let o in n)
      a.push(Ne.types.assignmentExpression("=", pb(t, o), Ne.types.cloneNode(n[o])));
    return [e, Ne.types.expressionStatement(Ne.types.sequenceExpression(a))];
  }
  i(x2e, "handleVariableDeclaration");
  function i8(e, t) {
    return e.hub.buildError(t, "Ambient modules cannot be nested in other modules or namespaces.", Error);
  }
  i(i8, "buildNestedAmbientModuleError");
  function fb(e, t, r) {
    let s = /* @__PURE__ */ new Set(), n = t.id, a = e.scope.generateUid(n.name), o = t.body, l = t.id, u;
    u = Ne.types.isTSModuleBlock(o) ? o.body : [Ne.types.exportNamedDeclaration(o)];
    let c = !0;
    for (let f = 0; f < u.length; f++) {
      let h = u[f];
      switch (h.type) {
        case "TSModuleDeclaration": {
          if (!Ne.types.isIdentifier(h.id))
            throw i8(e, h);
          let b = fb(e, h);
          if (b !== null) {
            c = !1;
            let T = h.id.name;
            s.has(T) ? u[f] = b : (s.add(T), u.splice(f++, 1, cb(T), b));
          }
          continue;
        }
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          c = !1, s.add(h.id.name);
          continue;
        case "VariableDeclaration": {
          c = !1;
          for (let b in Ne.types.getBindingIdentifiers(h))
            s.add(b);
          continue;
        }
        default:
          c && (c = Ne.types.isTypeScript(h));
          continue;
        case "ExportNamedDeclaration":
      }
      if (!("declare" in h.declaration && h.declaration.declare))
        switch (h.declaration.type) {
          case "TSEnumDeclaration":
            g2e.EXPORTED_CONST_ENUMS_IN_NAMESPACE.add(h.declaration);
          case "FunctionDeclaration":
          case "ClassDeclaration": {
            c = !1;
            let b = h.declaration.id.name;
            s.add(b), u.splice(f++, 1, h.declaration, Ne.types.expressionStatement(Ne.types.assignmentExpression("=", pb(a, b), Ne.types.identifier(
            b))));
            break;
          }
          case "VariableDeclaration": {
            c = !1;
            let b = x2e(h.declaration, a, e.hub);
            u.splice(f, b.length, ...b), f += b.length - 1;
            break;
          }
          case "TSModuleDeclaration": {
            if (!Ne.types.isIdentifier(h.declaration.id))
              throw i8(e, h.declaration);
            let b = fb(e, h.declaration, Ne.types.identifier(a));
            if (b !== null) {
              c = !1;
              let T = h.declaration.id.name;
              s.has(T) ? u[f] = b : (s.add(T), u.splice(f++, 1, cb(T), b));
            } else
              u.splice(f, 1), f--;
          }
        }
    }
    if (c) return null;
    let p = Ne.types.objectExpression([]);
    if (r) {
      let f = Ne.types.memberExpression(r, n);
      p = Ne.template.expression.ast`
      ${Ne.types.cloneNode(f)} ||
        (${Ne.types.cloneNode(f)} = ${p})
    `;
    }
    return Ne.template.statement.ast`
    (function (${Ne.types.identifier(a)}) {
      ${u}
    })(${n} || (${Ne.types.cloneNode(n)} = ${p}));
  `;
  }
  i(fb, "handleNested");
});

// ../node_modules/@babel/plugin-transform-typescript/lib/index.js
var c8 = D((Fp) => {
  "use strict";
  Object.defineProperty(Fp, "__esModule", {
    value: !0
  });
  Fp.default = void 0;
  var E2e = la(), S2e = lD(), v2e = e8(), P2e = lb(), A2e = ob(), Rs = ub(), o8 = a8();
  function C2e(e) {
    switch (e.parent.type) {
      case "TSTypeReference":
      case "TSExpressionWithTypeArguments":
      case "TSExpressionWithTypeArguments":
      case "TSTypeQuery":
        return !0;
      case "TSQualifiedName":
        return e.parentPath.findParent((t) => t.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration";
      case "ExportSpecifier":
        return e.parent.exportKind === "type" || e.parentPath.parent.exportKind === "type";
      default:
        return !1;
    }
  }
  i(C2e, "isInType");
  var Cr = /* @__PURE__ */ new WeakMap(), l8 = /* @__PURE__ */ new WeakSet();
  function kp(e) {
    let t = e.getBindingIdentifiers();
    for (let r of Object.keys(t)) {
      let s = e.scope.getBinding(r);
      s && s.identifier === t[r] && s.scope.removeBinding(r);
    }
    e.opts.noScope = !0, e.remove(), e.opts.noScope = !1;
  }
  i(kp, "safeRemove");
  function u8(e, t, r, s, n = "") {
    if (t.file.get("@babel/plugin-transform-modules-*") !== "commonjs")
      throw e.buildCodeFrameError(`\`${r}\` is only supported when compiling modules to CommonJS.
Please consider using \`${s}\`${n}, or add @babel/plugin-transform-modules-commonjs to your Babel config.`);
  }
  i(u8, "assertCjsTransformEnabled");
  var KIe = Fp.default = (0, E2e.declare)((e, t) => {
    let {
      types: r,
      template: s
    } = e;
    e.assertVersion(7);
    let n = /\*?\s*@jsx((?:Frag)?)\s+(\S+)/, {
      allowNamespaces: a = !0,
      jsxPragma: o = "React.createElement",
      jsxPragmaFrag: l = "React.Fragment",
      onlyRemoveTypeImports: u = !1,
      optimizeConstEnums: c = !1
    } = t;
    var {
      allowDeclareFields: p = !1
    } = t;
    let f = {
      field(d) {
        let {
          node: g
        } = d;
        if (!p && g.declare)
          throw d.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of @babel/plugin-transfor\
m-typescript or @babel/preset-typescript is enabled.");
        if (g.declare) {
          if (g.value)
            throw d.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
          g.decorators || d.remove();
        } else if (g.definite) {
          if (g.value)
            throw d.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
          !p && !g.decorators && !r.isClassPrivateProperty(g) && d.remove();
        } else (g.abstract || !p && !g.value && !g.decorators && !r.isClassPrivateProperty(g)) && d.remove();
        g.accessibility && (g.accessibility = null), g.abstract && (g.abstract = null), g.readonly && (g.readonly = null), g.optional && (g.
        optional = null), g.typeAnnotation && (g.typeAnnotation = null), g.definite && (g.definite = null), g.declare && (g.declare = null),
        g.override && (g.override = null);
      },
      method({
        node: d
      }) {
        d.accessibility && (d.accessibility = null), d.abstract && (d.abstract = null), d.optional && (d.optional = null), d.override && (d.
        override = null);
      },
      constructor(d, g) {
        d.node.accessibility && (d.node.accessibility = null);
        let E = [], {
          scope: _
        } = d;
        for (let N of d.get("params")) {
          let k = N.node;
          if (k.type === "TSParameterProperty") {
            let j = k.parameter;
            if (l8.has(j)) continue;
            l8.add(j);
            let U;
            if (r.isIdentifier(j))
              U = j;
            else if (r.isAssignmentPattern(j) && r.isIdentifier(j.left))
              U = j.left;
            else
              throw N.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
            E.push(s.statement.ast`
              this.${r.cloneNode(U)} = ${r.cloneNode(U)}
            `), N.replaceWith(N.get("parameter")), _.registerBinding("param", N);
          }
        }
        (0, v2e.injectInitialization)(g, d, E);
      }
    };
    return {
      name: "transform-typescript",
      inherits: S2e.default,
      visitor: {
        Pattern: b,
        Identifier: b,
        RestElement: b,
        Program: {
          enter(d, g) {
            let {
              file: E
            } = g, _ = null, N = null, k = d.scope;
            if (Rs.GLOBAL_TYPES.has(k) || Rs.GLOBAL_TYPES.set(k, /* @__PURE__ */ new Set()), E.ast.comments)
              for (let M of E.ast.comments) {
                let K = n.exec(M.value);
                K && (K[1] ? N = K[2] : _ = K[2]);
              }
            let j = _ || o;
            j && ([j] = j.split("."));
            let U = N || l;
            U && ([U] = U.split("."));
            for (let M of d.get("body")) {
              if (M.isImportDeclaration()) {
                if (Cr.has(g.file.ast.program) || Cr.set(g.file.ast.program, !0), M.node.importKind === "type") {
                  for (let te of M.node.specifiers)
                    (0, Rs.registerGlobalType)(k, te.local.name);
                  M.remove();
                  continue;
                }
                let K = /* @__PURE__ */ new Set(), G = M.node.specifiers.length, ue = /* @__PURE__ */ i(() => G > 0 && G === K.size, "isAllS\
pecifiersElided");
                for (let te of M.node.specifiers)
                  if (te.type === "ImportSpecifier" && te.importKind === "type") {
                    (0, Rs.registerGlobalType)(k, te.local.name);
                    let De = M.scope.getBinding(te.local.name);
                    De && K.add(De.path);
                  }
                if (u)
                  Cr.set(d.node, !1);
                else {
                  if (M.node.specifiers.length === 0) {
                    Cr.set(d.node, !1);
                    continue;
                  }
                  for (let te of M.node.specifiers) {
                    let De = M.scope.getBinding(te.local.name);
                    De && !K.has(De.path) && (T({
                      binding: De,
                      programPath: d,
                      pragmaImportName: j,
                      pragmaFragImportName: U
                    }) ? K.add(De.path) : Cr.set(d.node, !1));
                  }
                }
                if (ue() && !u)
                  M.remove();
                else
                  for (let te of K)
                    te.remove();
                continue;
              }
              if (!u && M.isTSImportEqualsDeclaration()) {
                let {
                  id: K
                } = M.node, G = M.scope.getBinding(K.name);
                if (G && !M.node.isExport && T({
                  binding: G,
                  programPath: d,
                  pragmaImportName: j,
                  pragmaFragImportName: U
                })) {
                  M.remove();
                  continue;
                }
              }
              if (M.isExportDeclaration() && (M = M.get("declaration")), M.isVariableDeclaration({
                declare: !0
              }))
                for (let K of Object.keys(M.getBindingIdentifiers()))
                  (0, Rs.registerGlobalType)(k, K);
              else (M.isTSTypeAliasDeclaration() || M.isTSDeclareFunction() && M.get("id").isIdentifier() || M.isTSInterfaceDeclaration() ||
              M.isClassDeclaration({
                declare: !0
              }) || M.isTSEnumDeclaration({
                declare: !0
              }) || M.isTSModuleDeclaration({
                declare: !0
              }) && M.get("id").isIdentifier()) && (0, Rs.registerGlobalType)(k, M.node.id.name);
            }
          },
          exit(d) {
            d.node.sourceType === "module" && Cr.get(d.node) && d.pushContainer("body", r.exportNamedDeclaration());
          }
        },
        ExportNamedDeclaration(d, g) {
          if (Cr.has(g.file.ast.program) || Cr.set(g.file.ast.program, !0), d.node.exportKind === "type") {
            d.remove();
            return;
          }
          if (d.node.source && d.node.specifiers.length > 0 && d.node.specifiers.every((E) => E.type === "ExportSpecifier" && E.exportKind ===
          "type")) {
            d.remove();
            return;
          }
          if (!d.node.source && d.node.specifiers.length > 0 && d.node.specifiers.every((E) => r.isExportSpecifier(E) && (0, Rs.isGlobalType)(
          d, E.local.name))) {
            d.remove();
            return;
          }
          if (r.isTSModuleDeclaration(d.node.declaration)) {
            let E = d.node.declaration;
            if (!r.isStringLiteral(E.id)) {
              let _ = (0, o8.getFirstIdentifier)(E.id);
              if (d.scope.hasOwnBinding(_.name))
                d.replaceWith(E);
              else {
                let [N] = d.replaceWithMultiple([r.exportNamedDeclaration(r.variableDeclaration("let", [r.variableDeclarator(r.cloneNode(_))])),
                E]);
                d.scope.registerDeclaration(N);
              }
            }
          }
          Cr.set(g.file.ast.program, !1);
        },
        ExportAllDeclaration(d) {
          d.node.exportKind === "type" && d.remove();
        },
        ExportSpecifier(d) {
          (!d.parent.source && (0, Rs.isGlobalType)(d, d.node.local.name) || d.node.exportKind === "type") && d.remove();
        },
        ExportDefaultDeclaration(d, g) {
          if (Cr.has(g.file.ast.program) || Cr.set(g.file.ast.program, !0), r.isIdentifier(d.node.declaration) && (0, Rs.isGlobalType)(d, d.
          node.declaration.name)) {
            d.remove();
            return;
          }
          Cr.set(g.file.ast.program, !1);
        },
        TSDeclareFunction(d) {
          kp(d);
        },
        TSDeclareMethod(d) {
          kp(d);
        },
        VariableDeclaration(d) {
          d.node.declare && kp(d);
        },
        VariableDeclarator({
          node: d
        }) {
          d.definite && (d.definite = null);
        },
        TSIndexSignature(d) {
          d.remove();
        },
        ClassDeclaration(d) {
          let {
            node: g
          } = d;
          g.declare && kp(d);
        },
        Class(d) {
          let {
            node: g
          } = d;
          g.typeParameters && (g.typeParameters = null), g.superTypeParameters && (g.superTypeParameters = null), g.implements && (g.implements =
          null), g.abstract && (g.abstract = null), d.get("body.body").forEach((E) => {
            E.isClassMethod() || E.isClassPrivateMethod() ? E.node.kind === "constructor" ? f.constructor(E, d) : f.method(E) : (E.isClassProperty() ||
            E.isClassPrivateProperty() || E.isClassAccessorProperty()) && f.field(E);
          });
        },
        Function(d) {
          let {
            node: g
          } = d;
          g.typeParameters && (g.typeParameters = null), g.returnType && (g.returnType = null);
          let E = g.params;
          E.length > 0 && r.isIdentifier(E[0], {
            name: "this"
          }) && E.shift();
        },
        TSModuleDeclaration(d) {
          (0, o8.default)(d, a);
        },
        TSInterfaceDeclaration(d) {
          d.remove();
        },
        TSTypeAliasDeclaration(d) {
          d.remove();
        },
        TSEnumDeclaration(d) {
          c && d.node.const ? (0, P2e.default)(d, r) : (0, A2e.default)(d, r);
        },
        TSImportEqualsDeclaration(d, g) {
          let {
            id: E,
            moduleReference: _
          } = d.node, N, k;
          r.isTSExternalModuleReference(_) ? (u8(d, g, `import ${E.name} = require(...);`, `import ${E.name} from '...';`, " alongside Types\
cript's --allowSyntheticDefaultImports option"), N = r.callExpression(r.identifier("require"), [_.expression]), k = "const") : (N = h(_), k =
          "var");
          let j = r.variableDeclaration(k, [r.variableDeclarator(E, N)]);
          d.replaceWith(d.node.isExport ? r.exportNamedDeclaration(j) : j), d.scope.registerDeclaration(d);
        },
        TSExportAssignment(d, g) {
          u8(d, g, "export = <value>;", "export default <value>;"), d.replaceWith(s.statement.ast`module.exports = ${d.node.expression}`);
        },
        TSTypeAssertion(d) {
          d.replaceWith(d.node.expression);
        },
        [`TSAsExpression${r.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""}`](d) {
          let {
            node: g
          } = d;
          do
            g = g.expression;
          while (r.isTSAsExpression(g) || r.isTSSatisfiesExpression != null && r.isTSSatisfiesExpression(g));
          d.replaceWith(g);
        },
        [e.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](d) {
          d.replaceWith(d.node.expression);
        },
        CallExpression(d) {
          d.node.typeParameters = null;
        },
        OptionalCallExpression(d) {
          d.node.typeParameters = null;
        },
        NewExpression(d) {
          d.node.typeParameters = null;
        },
        JSXOpeningElement(d) {
          d.node.typeParameters = null;
        },
        TaggedTemplateExpression(d) {
          d.node.typeParameters = null;
        }
      }
    };
    function h(d) {
      return r.isTSQualifiedName(d) ? r.memberExpression(h(d.left), d.right) : d;
    }
    function b({
      node: d
    }) {
      d.typeAnnotation && (d.typeAnnotation = null), r.isIdentifier(d) && d.optional && (d.optional = null);
    }
    function T({
      binding: d,
      programPath: g,
      pragmaImportName: E,
      pragmaFragImportName: _
    }) {
      for (let k of d.referencePaths)
        if (!C2e(k))
          return !1;
      if (d.identifier.name !== E && d.identifier.name !== _)
        return !0;
      let N = !1;
      return g.traverse({
        "JSXElement|JSXFragment"(k) {
          N = !0, k.stop();
        }
      }), !N;
    }
  });
});

// ../node_modules/@babel/plugin-syntax-jsx/lib/index.js
var p8 = D((Lp) => {
  "use strict";
  Object.defineProperty(Lp, "__esModule", {
    value: !0
  });
  Lp.default = void 0;
  var w2e = la(), HIe = Lp.default = (0, w2e.declare)((e) => (e.assertVersion(7), {
    name: "syntax-jsx",
    manipulateOptions(t, r) {
      r.plugins.some((s) => (Array.isArray(s) ? s[0] : s) === "typescript") || r.plugins.push("jsx");
    }
  }));
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/dynamic-import.js
var h8 = D((hb) => {
  "use strict";
  Object.defineProperty(hb, "__esModule", {
    value: !0
  });
  hb.transformDynamicImport = I2e;
  var f8 = et(), D2e = Do(), d8 = /* @__PURE__ */ i((e) => f8.template.expression.ast`require(${e})`, "requireNoInterop"), _2e = /* @__PURE__ */ i(
  (e, t) => f8.types.callExpression(t.addHelper("interopRequireWildcard"), [d8(e)]), "requireInterop");
  function I2e(e, t, r) {
    let s = t ? d8 : _2e;
    e.replaceWith((0, D2e.buildDynamicImport)(e.node, !0, !1, (n) => s(n, r)));
  }
  i(I2e, "transformDynamicImport");
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/lazy.js
var y8 = D((jp) => {
  "use strict";
  Object.defineProperty(jp, "__esModule", {
    value: !0
  });
  jp.lazyImportsHook = void 0;
  var m8 = et(), O2e = Do(), N2e = /* @__PURE__ */ i((e) => ({
    name: "@babel/plugin-transform-modules-commonjs/lazy",
    version: "7.27.1",
    getWrapperPayload(t, r) {
      if ((0, O2e.isSideEffectImport)(r) || r.reexportAll)
        return null;
      if (e === !0)
        return t.includes(".") ? null : "lazy/function";
      if (Array.isArray(e))
        return e.includes(t) ? "lazy/function" : null;
      if (typeof e == "function")
        return e(t) ? "lazy/function" : null;
    },
    buildRequireWrapper(t, r, s, n) {
      if (s === "lazy/function")
        return n ? m8.template.statement.ast`
        function ${t}() {
          const data = ${r};
          ${t} = function(){ return data; };
          return data;
        }
      ` : !1;
    },
    wrapReference(t, r) {
      if (r === "lazy/function") return m8.types.callExpression(t, []);
    }
  }), "lazyImportsHook");
  jp.lazyImportsHook = N2e;
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/hooks.js
var b8 = D((Mp) => {
  "use strict";
  Object.defineProperty(Mp, "__esModule", {
    value: !0
  });
  Mp.defineCommonJSHook = B2e;
  Mp.makeInvokers = k2e;
  var yb = "@babel/plugin-transform-modules-commonjs/customWrapperPlugin";
  function B2e(e, t) {
    let r = e.get(yb);
    r || e.set(yb, r = []), r.push(t);
  }
  i(B2e, "defineCommonJSHook");
  function mb(e, t) {
    if (e)
      for (let r of e) {
        let s = t(r);
        if (s != null) return s;
      }
  }
  i(mb, "findMap");
  function k2e(e) {
    let t = e.get(yb);
    return {
      getWrapperPayload(...r) {
        return mb(t, (s) => s.getWrapperPayload == null ? void 0 : s.getWrapperPayload(...r));
      },
      wrapReference(...r) {
        return mb(t, (s) => s.wrapReference == null ? void 0 : s.wrapReference(...r));
      },
      buildRequireWrapper(...r) {
        return mb(t, (s) => s.buildRequireWrapper == null ? void 0 : s.buildRequireWrapper(...r));
      }
    };
  }
  i(k2e, "makeInvokers");
});

// ../node_modules/@babel/plugin-transform-modules-commonjs/lib/index.js
var g8 = D((ol) => {
  "use strict";
  Object.defineProperty(ol, "__esModule", {
    value: !0
  });
  ol.default = void 0;
  Object.defineProperty(ol, "defineCommonJSHook", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return bb.defineCommonJSHook;
    }, "get")
  });
  var F2e = la(), di = Do(), Xr = et(), L2e = h8(), j2e = y8(), bb = b8(), t7e = ol.default = (0, F2e.declare)((e, t) => {
    var r, s, n;
    e.assertVersion(7);
    let {
      strictNamespace: a = !1,
      mjsStrictNamespace: o = a,
      allowTopLevelThis: l,
      strict: u,
      strictMode: c,
      noInterop: p,
      importInterop: f,
      lazy: h = !1,
      allowCommonJSExports: b = !0,
      loose: T = !1
    } = t, d = (r = e.assumption("constantReexports")) != null ? r : T, g = (s = e.assumption("enumerableModuleMeta")) != null ? s : T, E = (n =
    e.assumption("noIncompleteNsImportDetection")) != null ? n : !1;
    if (typeof h != "boolean" && typeof h != "function" && (!Array.isArray(h) || !h.every((k) => typeof k == "string")))
      throw new Error(".lazy must be a boolean, array of strings, or a function");
    if (typeof a != "boolean")
      throw new Error(".strictNamespace must be a boolean, or undefined");
    if (typeof o != "boolean")
      throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
    let _ = /* @__PURE__ */ i((k) => Xr.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${k}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, "getAssertion"), N = {
      ReferencedIdentifier(k) {
        let j = k.node.name;
        if (j !== "module" && j !== "exports") return;
        let U = k.scope.getBinding(j);
        this.scope.getBinding(j) !== U || k.parentPath.isObjectProperty({
          value: k.node
        }) && k.parentPath.parentPath.isObjectPattern() || k.parentPath.isAssignmentExpression({
          left: k.node
        }) || k.isAssignmentExpression({
          left: k.node
        }) || k.replaceWith(_(j));
      },
      UpdateExpression(k) {
        let j = k.get("argument");
        if (!j.isIdentifier()) return;
        let U = j.node.name;
        if (U !== "module" && U !== "exports") return;
        let M = k.scope.getBinding(U);
        this.scope.getBinding(U) === M && k.replaceWith(Xr.types.assignmentExpression(k.node.operator[0] + "=", j.node, _(U)));
      },
      AssignmentExpression(k) {
        let j = k.get("left");
        if (j.isIdentifier()) {
          let U = j.node.name;
          if (U !== "module" && U !== "exports") return;
          let M = k.scope.getBinding(U);
          if (this.scope.getBinding(U) !== M) return;
          let G = k.get("right");
          G.replaceWith(Xr.types.sequenceExpression([G.node, _(U)]));
        } else if (j.isPattern()) {
          let U = j.getOuterBindingIdentifiers(), M = Object.keys(U).find((K) => K !== "module" && K !== "exports" ? !1 : this.scope.getBinding(
          K) === k.scope.getBinding(K));
          if (M) {
            let K = k.get("right");
            K.replaceWith(Xr.types.sequenceExpression([K.node, _(M)]));
          }
        }
      }
    };
    return {
      name: "transform-modules-commonjs",
      pre() {
        this.file.set("@babel/plugin-transform-modules-*", "commonjs"), h && (0, bb.defineCommonJSHook)(this.file, (0, j2e.lazyImportsHook)(
        h));
      },
      visitor: {
        ["CallExpression" + (e.types.importExpression ? "|ImportExpression" : "")](k) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import") || k.isCallExpression() && !Xr.types.isImport(k.node.callee)) return;
          let {
            scope: j
          } = k;
          do
            j.rename("require");
          while (j = j.parent);
          (0, L2e.transformDynamicImport)(k, p, this.file);
        },
        Program: {
          exit(k, j) {
            if (!(0, di.isModule)(k)) return;
            k.scope.rename("exports"), k.scope.rename("module"), k.scope.rename("require"), k.scope.rename("__filename"), k.scope.rename("__\
dirname"), b || k.traverse(N, {
              scope: k.scope
            });
            let U = (0, di.getModuleName)(this.file.opts, t);
            U && (U = Xr.types.stringLiteral(U));
            let M = (0, bb.makeInvokers)(this.file), {
              meta: K,
              headers: G
            } = (0, di.rewriteModuleStatementsAndPrepareHeader)(k, {
              exportName: "exports",
              constantReexports: d,
              enumerableModuleMeta: g,
              strict: u,
              strictMode: c,
              allowTopLevelThis: l,
              noInterop: p,
              importInterop: f,
              wrapReference: M.wrapReference,
              getWrapperPayload: M.getWrapperPayload,
              esNamespaceOnly: typeof j.filename == "string" && /\.mjs$/.test(j.filename) ? o : a,
              noIncompleteNsImportDetection: E,
              filename: this.file.opts.filename
            });
            for (let [ue, te] of K.source) {
              let De = Xr.types.callExpression(Xr.types.identifier("require"), [Xr.types.stringLiteral(ue)]), je;
              if ((0, di.isSideEffectImport)(te)) {
                if (h && te.wrap === "function")
                  throw new Error("Assertion failure");
                je = Xr.types.expressionStatement(De);
              } else {
                let wt = (0, di.wrapInterop)(k, De, te.interop) || De;
                if (te.wrap) {
                  let pr = M.buildRequireWrapper(te.name, wt, te.wrap, te.referenced);
                  if (pr === !1) continue;
                  je = pr;
                }
                je ?? (je = Xr.template.statement.ast`
                var ${te.name} = ${wt};
              `);
              }
              je.loc = te.loc, G.push(je), G.push(...(0, di.buildNamespaceInitStatements)(K, te, d, M.wrapReference));
            }
            (0, di.ensureStatementsHoisted)(G), k.unshiftContainer("body", G), k.get("body").forEach((ue) => {
              G.includes(ue.node) && ue.isVariableDeclaration() && ue.scope.registerDeclaration(ue);
            });
          }
        }
      }
    };
  });
});

// ../node_modules/@babel/preset-typescript/lib/index.js
var S8 = D((gb) => {
  "use strict";
  Object.defineProperty(gb, "__esModule", { value: !0 });
  var x8 = la(), M2e = c8();
  p8();
  var R2e = g8(), q2e = qc();
  function E8(e) {
    return e && e.__esModule ? e : { default: e };
  }
  i(E8, "_interopDefault");
  var T8 = /* @__PURE__ */ E8(M2e), U2e = /* @__PURE__ */ E8(R2e), qs = new q2e.OptionValidator("@babel/preset-typescript");
  function $2e(e = {}) {
    let {
      allowNamespaces: t = !0,
      jsxPragma: r,
      onlyRemoveTypeImports: s
    } = e, n = {
      ignoreExtensions: "ignoreExtensions",
      allowNamespaces: "allowNamespaces",
      disallowAmbiguousJSXLike: "disallowAmbiguousJSXLike",
      jsxPragma: "jsxPragma",
      jsxPragmaFrag: "jsxPragmaFrag",
      onlyRemoveTypeImports: "onlyRemoveTypeImports",
      optimizeConstEnums: "optimizeConstEnums",
      rewriteImportExtensions: "rewriteImportExtensions",
      allExtensions: "allExtensions",
      isTSX: "isTSX"
    }, a = qs.validateStringOption(n.jsxPragmaFrag, e.jsxPragmaFrag, "React.Fragment");
    {
      var o = qs.validateBooleanOption(n.allExtensions, e.allExtensions, !1), l = qs.validateBooleanOption(n.isTSX, e.isTSX, !1);
      l && qs.invariant(o, "isTSX:true requires allExtensions:true");
    }
    let u = qs.validateBooleanOption(n.ignoreExtensions, e.ignoreExtensions, !1), c = qs.validateBooleanOption(n.disallowAmbiguousJSXLike, e.
    disallowAmbiguousJSXLike, !1);
    c && qs.invariant(o, "disallowAmbiguousJSXLike:true requires allExtensions:true");
    let p = qs.validateBooleanOption(n.optimizeConstEnums, e.optimizeConstEnums, !1), f = qs.validateBooleanOption(n.rewriteImportExtensions,
    e.rewriteImportExtensions, !1), h = {
      ignoreExtensions: u,
      allowNamespaces: t,
      disallowAmbiguousJSXLike: c,
      jsxPragma: r,
      jsxPragmaFrag: a,
      onlyRemoveTypeImports: s,
      optimizeConstEnums: p,
      rewriteImportExtensions: f
    };
    return h.allExtensions = o, h.isTSX = l, h;
  }
  i($2e, "normalizeOptions");
  var V2e = x8.declare(function({
    types: e,
    template: t
  }) {
    function r(s, n, a) {
      if (s) {
        if (e.isStringLiteral(s)) {
          /^\.\.?\//.test(s.value) && (s.value = s.value.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+)?)\.([cm]?)ts$/i, function(o, l, u, c, p) {
            return l ? ".js" : u && (!c || !p) ? o : u + c + "." + p.toLowerCase() + "js";
          }));
          return;
        }
        a.availableHelper("tsRewriteRelativeImportExtensions") ? n.replaceWith(e.callExpression(a.addHelper("tsRewriteRelativeImportExtensio\
ns"), [s])) : n.replaceWith(t.expression.ast`(${s} + "").replace(/([\\/].*\.[mc]?)tsx?$/, "$1js")`);
      }
    }
    return i(r, "maybeReplace"), {
      name: "preset-typescript/plugin-rewrite-ts-imports",
      visitor: {
        "ImportDeclaration|ExportAllDeclaration|ExportNamedDeclaration"(s, n) {
          let a = s.node;
          (e.isImportDeclaration(a) ? a.importKind : a.exportKind) === "value" && r(a.source, s.get("source"), n);
        },
        CallExpression(s, n) {
          e.isImport(s.node.callee) && r(s.node.arguments[0], s.get("arguments.0"), n);
        },
        ImportExpression(s, n) {
          r(s.node.source, s.get("source"), n);
        }
      }
    };
  }), K2e = x8.declarePreset((e, t) => {
    e.assertVersion(7);
    let {
      allExtensions: r,
      ignoreExtensions: s,
      allowNamespaces: n,
      disallowAmbiguousJSXLike: a,
      isTSX: o,
      jsxPragma: l,
      jsxPragmaFrag: u,
      onlyRemoveTypeImports: c,
      optimizeConstEnums: p,
      rewriteImportExtensions: f
    } = $2e(t), h = /* @__PURE__ */ i((d) => ({
      allowDeclareFields: t.allowDeclareFields,
      allowNamespaces: n,
      disallowAmbiguousJSXLike: d,
      jsxPragma: l,
      jsxPragmaFrag: u,
      onlyRemoveTypeImports: c,
      optimizeConstEnums: p
    }), "pluginOptions"), b = /* @__PURE__ */ i((d, g) => [[T8.default, Object.assign({
      isTSX: d
    }, h(g))]], "getPlugins");
    return {
      plugins: f ? [V2e] : [],
      overrides: r || s ? [{
        plugins: b(o, a)
      }] : [{
        test: /\.ts$/,
        plugins: b(!1, !1)
      }, {
        test: /\.mts$/,
        sourceType: "module",
        plugins: b(!1, !0)
      }, {
        test: /\.cts$/,
        sourceType: "unambiguous",
        plugins: [[U2e.default, {
          allowTopLevelThis: !0
        }], [T8.default, h(!0)]]
      }, {
        test: /\.tsx$/,
        plugins: b(!0, !1)
      }]
    };
  });
  gb.default = K2e;
});

// ../node_modules/@babel/core/lib/config/files/module-types.js
var Ab = D((ll) => {
  "use strict";
  Object.defineProperty(ll, "__esModule", {
    value: !0
  });
  ll.default = J2e;
  ll.supportsESM = void 0;
  var Tb = un();
  function vb() {
    let e = z("path");
    return vb = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(vb, "_path");
  function w8() {
    let e = z("url");
    return w8 = /* @__PURE__ */ i(function() {
      return e;
    }, "_url"), e;
  }
  i(w8, "_url");
  z("module");
  function Pb() {
    let e = z("semver");
    return Pb = /* @__PURE__ */ i(function() {
      return e;
    }, "_semver"), e;
  }
  i(Pb, "_semver");
  function D8() {
    let e = Fn();
    return D8 = /* @__PURE__ */ i(function() {
      return e;
    }, "_debug"), e;
  }
  i(D8, "_debug");
  var _8 = ws(), ba = ei(), W2e = v2();
  function v8(e, t, r, s, n, a, o) {
    try {
      var l = e[a](o), u = l.value;
    } catch (c) {
      return void r(c);
    }
    l.done ? t(u) : Promise.resolve(u).then(s, n);
  }
  i(v8, "asyncGeneratorStep");
  function Y2e(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(s, n) {
        var a = e.apply(t, r);
        function o(u) {
          v8(a, s, n, o, l, "next", u);
        }
        i(o, "_next");
        function l(u) {
          v8(a, s, n, o, l, "throw", u);
        }
        i(l, "_throw"), o(void 0);
      });
    };
  }
  i(Y2e, "_asyncToGenerator");
  var H2e = D8()("babel:config:loading:files:module-types");
  try {
    Sb = iD();
  } catch {
  }
  var Sb, a7e = ll.supportsESM = Pb().satisfies(process.versions.node, "^12.17 || >=13.2"), xb = /* @__PURE__ */ new Set();
  function Rp(e) {
    if (xb.has(e))
      return H2e("Auto-ignoring usage of config %o.", e), {};
    let t;
    try {
      xb.add(e), t = (0, _8.endHiddenCallStack)(z)(e);
    } finally {
      xb.delete(e);
    }
    return t != null && (t.__esModule || t[Symbol.toStringTag] === "Module") ? t.default || (arguments[1] ? t : void 0) : t;
  }
  i(Rp, "loadCjsDefault");
  var P8 = (0, _8.endHiddenCallStack)(function() {
    var e = Y2e(function* (r) {
      let s = (0, w8().pathToFileURL)(r).toString() + "?import";
      {
        if (!Sb)
          throw new ba.default(`Internal error: Native ECMAScript modules aren't supported by this platform.
`, r);
        return yield Sb(s);
      }
    });
    function t(r) {
      return e.apply(this, arguments);
    }
    return i(t, "loadMjsFromPath"), t;
  }()), I8 = /* @__PURE__ */ i((e) => `You are using a ${e} config file, but Babel only supports transpiling .cts configs. Either:
- Use a .cts config file
- Update to Node.js 23.6.0, which has native TypeScript support
- Install tsx to transpile ${e} files on the fly`, "tsNotSupportedError"), A8 = {
    ".js": "unknown",
    ".mjs": "esm",
    ".cjs": "cjs",
    ".ts": "unknown",
    ".mts": "esm",
    ".cts": "cjs"
  }, C8 = /* @__PURE__ */ new Set();
  function* J2e(e, t, r, s) {
    let n, a = vb().extname(e), o = a === ".ts" || a === ".cts" || a === ".mts", l = A8[hasOwnProperty.call(A8, a) ? a : ".js"];
    switch (`${t} ${l}`) {
      case "require cjs":
      case "auto cjs":
        return o ? Eb(e, a, () => Rp(e)) : Rp(e, arguments[2]);
      case "auto unknown":
      case "require unknown":
      case "require esm":
        try {
          return o ? Eb(e, a, () => Rp(e)) : Rp(e, arguments[2]);
        } catch (c) {
          if (c.code === "ERR_REQUIRE_ASYNC_MODULE" || c.code === "ERR_REQUIRE_CYCLE_MODULE" && C8.has(e)) {
            if (C8.add(e), !(n ?? (n = yield* (0, Tb.isAsync)())))
              throw new ba.default(s, e);
          } else if (!(c.code === "ERR_REQUIRE_ESM" || l === "esm"))
            throw c;
        }
      case "auto esm":
        if (n ?? (n = yield* (0, Tb.isAsync)())) {
          let c = o ? Eb(e, a, () => P8(e)) : P8(e);
          return (yield* (0, Tb.waitFor)(c)).default;
        }
        throw o ? new ba.default(I8(a), e) : new ba.default(r, e);
      default:
        throw new Error("Internal Babel error: unreachable code.");
    }
  }
  i(J2e, "loadCodeDefault");
  function Eb(e, t, r) {
    if (process.features.typescript || z.extensions[".ts"] || z.extensions[".cts"] || z.extensions[".mts"])
      return r();
    if (t !== ".cts")
      throw new ba.default(I8(t), e);
    let s = {
      babelrc: !1,
      configFile: !1,
      sourceType: "unambiguous",
      sourceMaps: "inline",
      sourceFileName: vb().basename(e),
      presets: [[G2e(e), Object.assign({
        onlyRemoveTypeImports: !0,
        optimizeConstEnums: !0
      }, {
        allowDeclareFields: !0
      })]]
    }, n = /* @__PURE__ */ i(function(a, o) {
      if (n && o.endsWith(".cts"))
        try {
          return a._compile((0, W2e.transformFileSync)(o, Object.assign({}, s, {
            filename: o
          })).code, o);
        } catch (l) {
          let u = aD();
          throw Pb().lt(u.version, "7.21.4") && console.error("`.cts` configuration file failed to load, please try to update `@babel/preset\
-typescript`."), l;
        }
      return z.extensions[".js"](a, o);
    }, "handler");
    z.extensions[t] = n;
    try {
      return r();
    } finally {
      z.extensions[t] === n && delete z.extensions[t], n = void 0;
    }
  }
  i(Eb, "ensureTsSupport");
  function G2e(e) {
    try {
      return S8();
    } catch (t) {
      if (t.code !== "MODULE_NOT_FOUND") throw t;
      let r = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please i\
nstall it!";
      throw process.versions.pnp && (r += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`), new ba.default(r, e);
    }
  }
  i(G2e, "getTSPreset");
});

// ../node_modules/@babel/core/lib/config/files/configuration.js
var q8 = D((Us) => {
  "use strict";
  Object.defineProperty(Us, "__esModule", {
    value: !0
  });
  Us.ROOT_CONFIG_FILENAMES = void 0;
  Us.findConfigUpwards = cbe;
  Us.findRelativeConfig = pbe;
  Us.findRootConfig = fbe;
  Us.loadConfig = dbe;
  Us.resolveShowConfigPath = hbe;
  function N8() {
    let e = Fn();
    return N8 = /* @__PURE__ */ i(function() {
      return e;
    }, "_debug"), e;
  }
  i(N8, "_debug");
  function Cb() {
    let e = z("fs");
    return Cb = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs"), e;
  }
  i(Cb, "_fs");
  function ur() {
    let e = z("path");
    return ur = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(ur, "_path");
  function B8() {
    let e = S3();
    return B8 = /* @__PURE__ */ i(function() {
      return e;
    }, "_json"), e;
  }
  i(B8, "_json");
  function k8() {
    let e = ir();
    return k8 = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(k8, "_gensync");
  var F8 = Zn(), X2e = jm(), L8 = Am(), z2e = Ab(), Q2e = Iy(), zr = ei(), Z2e = mc();
  z("module");
  var ebe = ws(), tbe = un(), wb = N8()("babel:config:loading:files:configuration"), j8 = Us.ROOT_CONFIG_FILENAMES = ["babel.config.js", "ba\
bel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config.cts", "babel.config.ts", "babel.config.mts"], rbe = [".babelrc", ".b\
abelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"], sbe = ".babelignore", nbe = (0, F8.makeWeakCache)(/* @__PURE__ */ i(
  function* (t, r) {
    return yield* [], {
      options: (0, ebe.endHiddenCallStack)(t)((0, X2e.makeConfigAPI)(r)),
      cacheNeedsConfiguration: !r.configured()
    };
  }, "runConfig"));
  function* ibe(e, t) {
    if (!Cb().existsSync(e)) return null;
    let r = yield* (0, z2e.default)(e, (yield* (0, tbe.isAsync)()) ? "auto" : "require", "You appear to be using a native ECMAScript module \
configuration file, which is only supported when running Babel asynchronously or when using the Node.js `--experimental-require-module` flag\
.", "You appear to be using a configuration file that contains top-level await, which is only supported when running Babel asynchronously."),
    s = !1;
    if (typeof r == "function" && ({
      options: r,
      cacheNeedsConfiguration: s
    } = yield* nbe(r, t)), !r || typeof r != "object" || Array.isArray(r))
      throw new zr.default("Configuration should be an exported JavaScript object.", e);
    if (typeof r.then == "function")
      throw r.catch == null || r.catch(() => {
      }), new zr.default("You appear to be using an async configuration, which your current version of Babel does not support. We may add su\
pport for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synch\
ronously return your config.", e);
    return s && mbe(e), abe(r, e);
  }
  i(ibe, "readConfigCode");
  var O8 = /* @__PURE__ */ new WeakMap();
  function abe(e, t) {
    let r = O8.get(e);
    r || O8.set(e, r = /* @__PURE__ */ new Map());
    let s = r.get(t);
    return s || (s = {
      filepath: t,
      dirname: ur().dirname(t),
      options: e
    }, r.set(t, s)), s;
  }
  i(abe, "buildConfigFileObject");
  var obe = (0, F8.makeWeakCacheSync)((e) => {
    let t = e.options.babel;
    if (t === void 0) return null;
    if (typeof t != "object" || Array.isArray(t) || t === null)
      throw new zr.default(".babel property must be an object", e.filepath);
    return {
      filepath: e.filepath,
      dirname: e.dirname,
      options: t
    };
  }), lbe = (0, L8.makeStaticFileCache)((e, t) => {
    let r;
    try {
      r = B8().parse(t);
    } catch (s) {
      throw new zr.default(`Error while parsing config - ${s.message}`, e);
    }
    if (!r) throw new zr.default("No config detected", e);
    if (typeof r != "object")
      throw new zr.default(`Config returned typeof ${typeof r}`, e);
    if (Array.isArray(r))
      throw new zr.default("Expected config object but found array", e);
    return delete r.$schema, {
      filepath: e,
      dirname: ur().dirname(e),
      options: r
    };
  }), ube = (0, L8.makeStaticFileCache)((e, t) => {
    let r = ur().dirname(e), s = t.split(`
`).map((n) => n.replace(/#.*$/, "").trim()).filter(Boolean);
    for (let n of s)
      if (n[0] === "!")
        throw new zr.default("Negation of file paths is not supported.", e);
    return {
      filepath: e,
      dirname: ur().dirname(e),
      ignore: s.map((n) => (0, Q2e.default)(n, r))
    };
  });
  function cbe(e) {
    let t = e;
    for (; ; ) {
      for (let s of j8)
        if (Cb().existsSync(ur().join(t, s)))
          return t;
      let r = ur().dirname(t);
      if (t === r) break;
      t = r;
    }
    return null;
  }
  i(cbe, "findConfigUpwards");
  function* pbe(e, t, r) {
    let s = null, n = null, a = ur().dirname(e.filepath);
    for (let l of e.directories) {
      if (!s) {
        var o;
        s = yield* M8(rbe, l, t, r, ((o = e.pkg) == null ? void 0 : o.dirname) === l ? obe(e.pkg) : null);
      }
      if (!n) {
        let u = ur().join(l, sbe);
        n = yield* ube(u), n && wb("Found ignore %o from %o.", n.filepath, a);
      }
    }
    return {
      config: s,
      ignore: n
    };
  }
  i(pbe, "findRelativeConfig");
  function fbe(e, t, r) {
    return M8(j8, e, t, r);
  }
  i(fbe, "findRootConfig");
  function* M8(e, t, r, s, n = null) {
    let o = (yield* k8().all(e.map((l) => R8(ur().join(t, l), r, s)))).reduce((l, u) => {
      if (u && l)
        throw new zr.default(`Multiple configuration files found. Please remove one:
 - ${ur().basename(l.filepath)}
 - ${u.filepath}
from ${t}`);
      return u || l;
    }, n);
    return o && wb("Found configuration %o from %o.", o.filepath, t), o;
  }
  i(M8, "loadOneConfig");
  function* dbe(e, t, r, s) {
    let n = (((o, l) => (o = o.split("."), l = l.split("."), +o[0] > +l[0] || o[0] == l[0] && +o[1] >= +l[1]))(process.versions.node, "8.9") ?
    z.resolve : (o, {
      paths: [l]
    }, u = z("module")) => {
      let c = u._findPath(o, u._nodeModulePaths(l).concat(l));
      if (c) return c;
      throw c = new Error(`Cannot resolve module '${o}'`), c.code = "MODULE_NOT_FOUND", c;
    })(e, {
      paths: [t]
    }), a = yield* R8(n, r, s);
    if (!a)
      throw new zr.default("Config file contains no configuration data", n);
    return wb("Loaded config %o from %o.", e, t), a;
  }
  i(dbe, "loadConfig");
  function R8(e, t, r) {
    switch (ur().extname(e)) {
      case ".js":
      case ".cjs":
      case ".mjs":
      case ".ts":
      case ".cts":
      case ".mts":
        return ibe(e, {
          envName: t,
          caller: r
        });
      default:
        return lbe(e);
    }
  }
  i(R8, "readConfig");
  function* hbe(e) {
    let t = process.env.BABEL_SHOW_CONFIG_FOR;
    if (t != null) {
      let r = ur().resolve(e, t);
      if (!(yield* Z2e.stat(r)).isFile())
        throw new Error(`${r}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
      return r;
    }
    return null;
  }
  i(hbe, "resolveShowConfigPath");
  function mbe(e) {
    throw new zr.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, e);
  }
  i(mbe, "throwConfigError");
});

// ../node_modules/@babel/core/lib/vendor/import-meta-resolve.js
var p5 = D((Wp) => {
  "use strict";
  Object.defineProperty(Wp, "__esModule", {
    value: !0
  });
  Wp.moduleResolve = c5;
  Wp.resolve = age;
  function ps() {
    let e = z("assert");
    return ps = /* @__PURE__ */ i(function() {
      return e;
    }, "_assert"), e;
  }
  i(ps, "_assert");
  function fl() {
    let e = e5(z("fs"), !0);
    return fl = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs"), e;
  }
  i(fl, "_fs");
  function En() {
    let e = z("process");
    return En = /* @__PURE__ */ i(function() {
      return e;
    }, "_process"), e;
  }
  i(En, "_process");
  function ie() {
    let e = z("url");
    return ie = /* @__PURE__ */ i(function() {
      return e;
    }, "_url"), e;
  }
  i(ie, "_url");
  function $p() {
    let e = z("path");
    return $p = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i($p, "_path");
  function Vp() {
    let e = z("module");
    return Vp = /* @__PURE__ */ i(function() {
      return e;
    }, "_module"), e;
  }
  i(Vp, "_module");
  function Z8() {
    let e = z("v8");
    return Z8 = /* @__PURE__ */ i(function() {
      return e;
    }, "_v"), e;
  }
  i(Z8, "_v");
  function pl() {
    let e = z("util");
    return pl = /* @__PURE__ */ i(function() {
      return e;
    }, "_util"), e;
  }
  i(pl, "_util");
  function e5(e, t) {
    if (typeof WeakMap == "function") var r = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new WeakMap();
    return (e5 = /* @__PURE__ */ i(function(n, a) {
      if (!a && n && n.__esModule) return n;
      var o, l, u = { __proto__: null, default: n };
      if (n === null || typeof n != "object" && typeof n != "function") return u;
      if (o = a ? s : r) {
        if (o.has(n)) return o.get(n);
        o.set(n, u);
      }
      for (let c in n) c !== "default" && {}.hasOwnProperty.call(n, c) && ((l = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(
      n, c)) && (l.get || l.set) ? o(u, c, l) : u[c] = n[c]);
      return u;
    }, "_interopRequireWildcard"))(e, t);
  }
  i(e5, "_interopRequireWildcard");
  var ybe = {}.hasOwnProperty, bbe = /^([A-Z][a-z\d]*)+$/, gbe = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Functio\
n", "Object", "boolean", "bigint", "symbol"]), Ct = {};
  function Db(e, t = "and") {
    return e.length < 3 ? e.join(` ${t} `) : `${e.slice(0, -1).join(", ")}, ${t} ${e[e.length - 1]}`;
  }
  i(Db, "formatList");
  var t5 = /* @__PURE__ */ new Map(), Tbe = "__node_internal_", U8;
  Ct.ERR_INVALID_ARG_TYPE = wr("ERR_INVALID_ARG_TYPE", (e, t, r) => {
    ps()(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
    let s = "The ";
    if (e.endsWith(" argument"))
      s += `${e} `;
    else {
      let l = e.includes(".") ? "property" : "argument";
      s += `"${e}" ${l} `;
    }
    s += "must be ";
    let n = [], a = [], o = [];
    for (let l of t)
      ps()(typeof l == "string", "All expected entries have to be of type string"), gbe.has(l) ? n.push(l.toLowerCase()) : bbe.exec(l) === null ?
      (ps()(l !== "object", 'The value "object" should be written as "Object"'), o.push(l)) : a.push(l);
    if (a.length > 0) {
      let l = n.indexOf("object");
      l !== -1 && (n.slice(l, 1), a.push("Object"));
    }
    return n.length > 0 && (s += `${n.length > 1 ? "one of type" : "of type"} ${Db(n, "or")}`, (a.length > 0 || o.length > 0) && (s += " or ")),
    a.length > 0 && (s += `an instance of ${Db(a, "or")}`, o.length > 0 && (s += " or ")), o.length > 0 && (o.length > 1 ? s += `one of ${Db(
    o, "or")}` : (o[0].toLowerCase() !== o[0] && (s += "an "), s += `${o[0]}`)), s += `. Received ${Pbe(r)}`, s;
  }, TypeError);
  Ct.ERR_INVALID_MODULE_SPECIFIER = wr("ERR_INVALID_MODULE_SPECIFIER", (e, t, r = void 0) => `Invalid module "${e}" ${t}${r ? ` imported fro\
m ${r}` : ""}`, TypeError);
  Ct.ERR_INVALID_PACKAGE_CONFIG = wr("ERR_INVALID_PACKAGE_CONFIG", (e, t, r) => `Invalid package config ${e}${t ? ` while importing ${t}` : ""}${r ?
  `. ${r}` : ""}`, Error);
  Ct.ERR_INVALID_PACKAGE_TARGET = wr("ERR_INVALID_PACKAGE_TARGET", (e, t, r, s = !1, n = void 0) => {
    let a = typeof r == "string" && !s && r.length > 0 && !r.startsWith("./");
    return t === "." ? (ps()(s === !1), `Invalid "exports" main target ${JSON.stringify(r)} defined in the package config ${e}package.json${n ?
    ` imported from ${n}` : ""}${a ? '; targets must start with "./"' : ""}`) : `Invalid "${s ? "imports" : "exports"}" target ${JSON.stringify(
    r)} defined for '${t}' in the package config ${e}package.json${n ? ` imported from ${n}` : ""}${a ? '; targets must start with "./"' : ""}`;
  }, Error);
  Ct.ERR_MODULE_NOT_FOUND = wr("ERR_MODULE_NOT_FOUND", (e, t, r = !1) => `Cannot find ${r ? "module" : "package"} '${e}' imported from ${t}`,
  Error);
  Ct.ERR_NETWORK_IMPORT_DISALLOWED = wr("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
  Ct.ERR_PACKAGE_IMPORT_NOT_DEFINED = wr("ERR_PACKAGE_IMPORT_NOT_DEFINED", (e, t, r) => `Package import specifier "${e}" is not defined${t ?
  ` in package ${t}package.json` : ""} imported from ${r}`, TypeError);
  Ct.ERR_PACKAGE_PATH_NOT_EXPORTED = wr("ERR_PACKAGE_PATH_NOT_EXPORTED", (e, t, r = void 0) => t === "." ? `No "exports" main defined in ${e}\
package.json${r ? ` imported from ${r}` : ""}` : `Package subpath '${t}' is not defined by "exports" in ${e}package.json${r ? ` imported fro\
m ${r}` : ""}`, Error);
  Ct.ERR_UNSUPPORTED_DIR_IMPORT = wr("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported fro\
m %s", Error);
  Ct.ERR_UNSUPPORTED_RESOLVE_REQUEST = wr("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid rel\
ative URL or base scheme is not hierarchical.', TypeError);
  Ct.ERR_UNKNOWN_FILE_EXTENSION = wr("ERR_UNKNOWN_FILE_EXTENSION", (e, t) => `Unknown file extension "${e}" for ${t}`, TypeError);
  Ct.ERR_INVALID_ARG_VALUE = wr("ERR_INVALID_ARG_VALUE", (e, t, r = "is invalid") => {
    let s = (0, pl().inspect)(t);
    return s.length > 128 && (s = `${s.slice(0, 128)}...`), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${s}`;
  }, TypeError);
  function wr(e, t, r) {
    return t5.set(e, t), xbe(r, e);
  }
  i(wr, "createError");
  function xbe(e, t) {
    return r;
    function r(...s) {
      let n = Error.stackTraceLimit;
      Nb() && (Error.stackTraceLimit = 0);
      let a = new e();
      Nb() && (Error.stackTraceLimit = n);
      let o = vbe(t, s, a);
      return Object.defineProperties(a, {
        message: {
          value: o,
          enumerable: !1,
          writable: !0,
          configurable: !0
        },
        toString: {
          value() {
            return `${this.name} [${t}]: ${this.message}`;
          },
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), Sbe(a), a.code = t, a;
    }
  }
  i(xbe, "makeNodeErrorWithCode");
  function Nb() {
    try {
      if (Z8().startupSnapshot.isBuildingSnapshot())
        return !1;
    } catch {
    }
    let e = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
    return e === void 0 ? Object.isExtensible(Error) : ybe.call(e, "writable") && e.writable !== void 0 ? e.writable : e.set !== void 0;
  }
  i(Nb, "isErrorStackTraceLimitWritable");
  function Ebe(e) {
    let t = Tbe + e.name;
    return Object.defineProperty(e, "name", {
      value: t
    }), e;
  }
  i(Ebe, "hideStackFrames");
  var Sbe = Ebe(function(e) {
    let t = Nb();
    return t && (U8 = Error.stackTraceLimit, Error.stackTraceLimit = Number.POSITIVE_INFINITY), Error.captureStackTrace(e), t && (Error.stackTraceLimit =
    U8), e;
  });
  function vbe(e, t, r) {
    let s = t5.get(e);
    if (ps()(s !== void 0, "expected `message` to be found"), typeof s == "function")
      return ps()(s.length <= t.length, `Code: ${e}; The provided arguments length (${t.length}) does not match the required ones (${s.length}\
).`), Reflect.apply(s, r, t);
    let n = /%[dfijoOs]/g, a = 0;
    for (; n.exec(s) !== null; ) a++;
    return ps()(a === t.length, `Code: ${e}; The provided arguments length (${t.length}) does not match the required ones (${a}).`), t.length ===
    0 ? s : (t.unshift(s), Reflect.apply(pl().format, null, t));
  }
  i(vbe, "getMessage");
  function Pbe(e) {
    if (e == null)
      return String(e);
    if (typeof e == "function" && e.name)
      return `function ${e.name}`;
    if (typeof e == "object")
      return e.constructor && e.constructor.name ? `an instance of ${e.constructor.name}` : `${(0, pl().inspect)(e, {
        depth: -1
      })}`;
    let t = (0, pl().inspect)(e, {
      colors: !1
    });
    return t.length > 28 && (t = `${t.slice(0, 25)}...`), `type ${typeof e} (${t})`;
  }
  i(Pbe, "determineSpecificType");
  var ul = {}.hasOwnProperty, {
    ERR_INVALID_PACKAGE_CONFIG: Abe
  } = Ct, $8 = /* @__PURE__ */ new Map();
  function r5(e, {
    base: t,
    specifier: r
  }) {
    let s = $8.get(e);
    if (s)
      return s;
    let n;
    try {
      n = fl().default.readFileSync($p().toNamespacedPath(e), "utf8");
    } catch (o) {
      let l = o;
      if (l.code !== "ENOENT")
        throw l;
    }
    let a = {
      exists: !1,
      pjsonPath: e,
      main: void 0,
      name: void 0,
      type: "none",
      exports: void 0,
      imports: void 0
    };
    if (n !== void 0) {
      let o;
      try {
        o = JSON.parse(n);
      } catch (l) {
        let u = l, c = new Abe(e, (t ? `"${r}" from ` : "") + (0, ie().fileURLToPath)(t || r), u.message);
        throw c.cause = u, c;
      }
      a.exists = !0, ul.call(o, "name") && typeof o.name == "string" && (a.name = o.name), ul.call(o, "main") && typeof o.main == "string" &&
      (a.main = o.main), ul.call(o, "exports") && (a.exports = o.exports), ul.call(o, "imports") && (a.imports = o.imports), ul.call(o, "typ\
e") && (o.type === "commonjs" || o.type === "module") && (a.type = o.type);
    }
    return $8.set(e, a), a;
  }
  i(r5, "read");
  function Bb(e) {
    let t = new URL("package.json", e);
    for (; !t.pathname.endsWith("node_modules/package.json"); ) {
      let n = r5((0, ie().fileURLToPath)(t), {
        specifier: e
      });
      if (n.exists)
        return n;
      let a = t;
      if (t = new URL("../package.json", t), t.pathname === a.pathname)
        break;
    }
    return {
      pjsonPath: (0, ie().fileURLToPath)(t),
      exists: !1,
      type: "none"
    };
  }
  i(Bb, "getPackageScopeConfig");
  function V8(e) {
    return Bb(e).type;
  }
  i(V8, "getPackageType");
  var {
    ERR_UNKNOWN_FILE_EXTENSION: Cbe
  } = Ct, wbe = {}.hasOwnProperty, Dbe = {
    __proto__: null,
    ".cjs": "commonjs",
    ".js": "module",
    ".json": "json",
    ".mjs": "module"
  };
  function _be(e) {
    return e && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(e) ? "module" : e === "application/json" ? "json" : null;
  }
  i(_be, "mimeToFormat");
  var K8 = {
    __proto__: null,
    "data:": Ibe,
    "file:": Nbe,
    "http:": W8,
    "https:": W8,
    "node:"() {
      return "builtin";
    }
  };
  function Ibe(e) {
    let {
      1: t
    } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(e.pathname) || [null, null, null];
    return _be(t);
  }
  i(Ibe, "getDataProtocolModuleFormat");
  function Obe(e) {
    let t = e.pathname, r = t.length;
    for (; r--; ) {
      let s = t.codePointAt(r);
      if (s === 47)
        return "";
      if (s === 46)
        return t.codePointAt(r - 1) === 47 ? "" : t.slice(r);
    }
    return "";
  }
  i(Obe, "extname");
  function Nbe(e, t, r) {
    let s = Obe(e);
    if (s === ".js") {
      let o = V8(e);
      return o !== "none" ? o : "commonjs";
    }
    if (s === "") {
      let o = V8(e);
      return o === "none" || o === "commonjs" ? "commonjs" : "module";
    }
    let n = Dbe[s];
    if (n) return n;
    if (r)
      return;
    let a = (0, ie().fileURLToPath)(e);
    throw new Cbe(s, a);
  }
  i(Nbe, "getFileProtocolModuleFormat");
  function W8() {
  }
  i(W8, "getHttpProtocolModuleFormat");
  function s5(e, t) {
    let r = e.protocol;
    return wbe.call(K8, r) && K8[r](e, t, !0) || null;
  }
  i(s5, "defaultGetFormatWithoutErrors");
  var {
    ERR_INVALID_ARG_VALUE: Bbe
  } = Ct, n5 = Object.freeze(["node", "import"]), kbe = new Set(n5);
  function Fbe() {
    return n5;
  }
  i(Fbe, "getDefaultConditions");
  function Lbe() {
    return kbe;
  }
  i(Lbe, "getDefaultConditionsSet");
  function jbe(e) {
    if (e !== void 0 && e !== Fbe()) {
      if (!Array.isArray(e))
        throw new Bbe("conditions", e, "expected an array");
      return new Set(e);
    }
    return Lbe();
  }
  i(jbe, "getConditionsSet");
  var qp = RegExp.prototype[Symbol.replace], {
    ERR_NETWORK_IMPORT_DISALLOWED: _b,
    ERR_INVALID_MODULE_SPECIFIER: Kp,
    ERR_INVALID_PACKAGE_CONFIG: i5,
    ERR_INVALID_PACKAGE_TARGET: Mbe,
    ERR_MODULE_NOT_FOUND: kb,
    ERR_PACKAGE_IMPORT_NOT_DEFINED: Rbe,
    ERR_PACKAGE_PATH_NOT_EXPORTED: qbe,
    ERR_UNSUPPORTED_DIR_IMPORT: Ube,
    ERR_UNSUPPORTED_RESOLVE_REQUEST: Y8
  } = Ct, a5 = {}.hasOwnProperty, H8 = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i,
  J8 = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i,
  $be = /^\.|%|\\/, Up = /\*/g, Vbe = /%2f|%5c/i, G8 = /* @__PURE__ */ new Set(), Kbe = /[/\\]{2}/;
  function X8(e, t, r, s, n, a, o) {
    if (En().noDeprecation)
      return;
    let l = (0, ie().fileURLToPath)(s), u = Kbe.exec(o ? e : t) !== null;
    En().emitWarning(`Use of deprecated ${u ? "double slash" : "leading or trailing slash matching"} resolving "${e}" for module request "${t}\
" ${t === r ? "" : `matched to "${r}" `}in the "${n ? "imports" : "exports"}" field module resolution of the package at ${l}${a ? ` imported\
 from ${(0, ie().fileURLToPath)(a)}` : ""}.`, "DeprecationWarning", "DEP0166");
  }
  i(X8, "emitInvalidSegmentDeprecation");
  function z8(e, t, r, s) {
    if (En().noDeprecation || s5(e, {
      parentURL: r.href
    }) !== "module") return;
    let a = (0, ie().fileURLToPath)(e.href), o = (0, ie().fileURLToPath)(new (ie()).URL(".", t)), l = (0, ie().fileURLToPath)(r);
    s ? $p().resolve(o, s) !== a && En().emitWarning(`Package ${o} has a "main" field set to "${s}", excluding the full filename and extensi\
on to the resolved file at "${a.slice(o.length)}", imported from ${l}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151") : En().emitWarning(`No \
"main" or "exports" field defined in the package.json for ${o} resolving the main entry point "${a.slice(o.length)}", imported from ${l}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
  }
  i(z8, "emitLegacyIndexDeprecation");
  function o5(e) {
    try {
      return (0, fl().statSync)(e);
    } catch {
    }
  }
  i(o5, "tryStatSync");
  function Ib(e) {
    let t = (0, fl().statSync)(e, {
      throwIfNoEntry: !1
    }), r = t ? t.isFile() : void 0;
    return r ?? !1;
  }
  i(Ib, "fileExists");
  function Wbe(e, t, r) {
    let s;
    if (t.main !== void 0) {
      if (s = new (ie()).URL(t.main, e), Ib(s)) return s;
      let o = [`./${t.main}.js`, `./${t.main}.json`, `./${t.main}.node`, `./${t.main}/index.js`, `./${t.main}/index.json`, `./${t.main}/inde\
x.node`], l = -1;
      for (; ++l < o.length && (s = new (ie()).URL(o[l], e), !Ib(s)); )
        s = void 0;
      if (s)
        return z8(s, e, r, t.main), s;
    }
    let n = ["./index.js", "./index.json", "./index.node"], a = -1;
    for (; ++a < n.length && (s = new (ie()).URL(n[a], e), !Ib(s)); )
      s = void 0;
    if (s)
      return z8(s, e, r, t.main), s;
    throw new kb((0, ie().fileURLToPath)(new (ie()).URL(".", e)), (0, ie().fileURLToPath)(r));
  }
  i(Wbe, "legacyMainResolve");
  function Ybe(e, t, r) {
    if (Vbe.exec(e.pathname) !== null)
      throw new Kp(e.pathname, 'must not include encoded "/" or "\\" characters', (0, ie().fileURLToPath)(t));
    let s;
    try {
      s = (0, ie().fileURLToPath)(e);
    } catch (a) {
      let o = a;
      throw Object.defineProperty(o, "input", {
        value: String(e)
      }), Object.defineProperty(o, "module", {
        value: String(t)
      }), o;
    }
    let n = o5(s.endsWith("/") ? s.slice(-1) : s);
    if (n && n.isDirectory()) {
      let a = new Ube(s, (0, ie().fileURLToPath)(t));
      throw a.url = String(e), a;
    }
    if (!n || !n.isFile()) {
      let a = new kb(s || e.pathname, t && (0, ie().fileURLToPath)(t), !0);
      throw a.url = String(e), a;
    }
    if (!r) {
      let a = (0, fl().realpathSync)(s), {
        search: o,
        hash: l
      } = e;
      e = (0, ie().pathToFileURL)(a + (s.endsWith($p().sep) ? "/" : "")), e.search = o, e.hash = l;
    }
    return e;
  }
  i(Ybe, "finalizeResolution");
  function Hbe(e, t, r) {
    return new Rbe(e, t && (0, ie().fileURLToPath)(new (ie()).URL(".", t)), (0, ie().fileURLToPath)(r));
  }
  i(Hbe, "importNotDefined");
  function Ob(e, t, r) {
    return new qbe((0, ie().fileURLToPath)(new (ie()).URL(".", t)), e, r && (0, ie().fileURLToPath)(r));
  }
  i(Ob, "exportsNotFound");
  function Jbe(e, t, r, s, n) {
    let a = `request is not a valid match in pattern "${t}" for the "${s ? "imports" : "exports"}" resolution of ${(0, ie().fileURLToPath)(r)}`;
    throw new Kp(e, a, n && (0, ie().fileURLToPath)(n));
  }
  i(Jbe, "throwInvalidSubpath");
  function cl(e, t, r, s, n) {
    return t = typeof t == "object" && t !== null ? JSON.stringify(t, null, "") : `${t}`, new Mbe((0, ie().fileURLToPath)(new (ie()).URL(".",
    r)), e, t, s, n && (0, ie().fileURLToPath)(n));
  }
  i(cl, "invalidPackageTarget");
  function Gbe(e, t, r, s, n, a, o, l, u) {
    if (t !== "" && !a && e[e.length - 1] !== "/") throw cl(r, e, s, o, n);
    if (!e.startsWith("./")) {
      if (o && !e.startsWith("../") && !e.startsWith("/")) {
        let h = !1;
        try {
          new (ie()).URL(e), h = !0;
        } catch {
        }
        if (!h) {
          let b = a ? qp.call(Up, e, () => t) : e + t;
          return u5(b, s, u);
        }
      }
      throw cl(r, e, s, o, n);
    }
    if (H8.exec(e.slice(2)) !== null)
      if (J8.exec(e.slice(2)) === null) {
        if (!l) {
          let h = a ? r.replace("*", () => t) : r + t, b = a ? qp.call(Up, e, () => t) : e;
          X8(b, h, r, s, o, n, !0);
        }
      } else
        throw cl(r, e, s, o, n);
    let c = new (ie()).URL(e, s), p = c.pathname, f = new (ie()).URL(".", s).pathname;
    if (!p.startsWith(f)) throw cl(r, e, s, o, n);
    if (t === "") return c;
    if (H8.exec(t) !== null) {
      let h = a ? r.replace("*", () => t) : r + t;
      if (J8.exec(t) === null) {
        if (!l) {
          let b = a ? qp.call(Up, e, () => t) : e;
          X8(b, h, r, s, o, n, !1);
        }
      } else
        Jbe(h, r, s, o, n);
    }
    return a ? new (ie()).URL(qp.call(Up, c.href, () => t)) : new (ie()).URL(t, c);
  }
  i(Gbe, "resolvePackageTargetString");
  function Xbe(e) {
    let t = Number(e);
    return `${t}` !== e ? !1 : t >= 0 && t < 4294967295;
  }
  i(Xbe, "isArrayIndex");
  function ga(e, t, r, s, n, a, o, l, u) {
    if (typeof t == "string")
      return Gbe(t, r, s, e, n, a, o, l, u);
    if (Array.isArray(t)) {
      let c = t;
      if (c.length === 0) return null;
      let p, f = -1;
      for (; ++f < c.length; ) {
        let h = c[f], b;
        try {
          b = ga(e, h, r, s, n, a, o, l, u);
        } catch (T) {
          let d = T;
          if (p = d, d.code === "ERR_INVALID_PACKAGE_TARGET") continue;
          throw T;
        }
        if (b !== void 0) {
          if (b === null) {
            p = null;
            continue;
          }
          return b;
        }
      }
      if (p == null)
        return null;
      throw p;
    }
    if (typeof t == "object" && t !== null) {
      let c = Object.getOwnPropertyNames(t), p = -1;
      for (; ++p < c.length; ) {
        let f = c[p];
        if (Xbe(f))
          throw new i5((0, ie().fileURLToPath)(e), n, '"exports" cannot contain numeric property keys.');
      }
      for (p = -1; ++p < c.length; ) {
        let f = c[p];
        if (f === "default" || u && u.has(f)) {
          let h = t[f], b = ga(e, h, r, s, n, a, o, l, u);
          if (b === void 0) continue;
          return b;
        }
      }
      return null;
    }
    if (t === null)
      return null;
    throw cl(s, t, e, o, n);
  }
  i(ga, "resolvePackageTarget");
  function zbe(e, t, r) {
    if (typeof e == "string" || Array.isArray(e)) return !0;
    if (typeof e != "object" || e === null) return !1;
    let s = Object.getOwnPropertyNames(e), n = !1, a = 0, o = -1;
    for (; ++o < s.length; ) {
      let l = s[o], u = l === "" || l[0] !== ".";
      if (a++ === 0)
        n = u;
      else if (n !== u)
        throw new i5((0, ie().fileURLToPath)(t), r, `"exports" cannot contain some keys starting with '.' and some not. The exports object m\
ust either be an object of package subpath keys or an object of main entry condition name keys only.`);
    }
    return n;
  }
  i(zbe, "isConditionalExportsMainSugar");
  function Qbe(e, t, r) {
    if (En().noDeprecation)
      return;
    let s = (0, ie().fileURLToPath)(t);
    G8.has(s + "|" + e) || (G8.add(s + "|" + e), En().emitWarning(`Use of deprecated trailing slash pattern mapping "${e}" in the "exports" \
field module resolution of the package at ${s}${r ? ` imported from ${(0, ie().fileURLToPath)(r)}` : ""}. Mapping specifiers ending in "/" i\
s no longer supported.`, "DeprecationWarning", "DEP0155"));
  }
  i(Qbe, "emitTrailingSlashPatternDeprecation");
  function Q8(e, t, r, s, n) {
    let a = r.exports;
    if (zbe(a, e, s) && (a = {
      ".": a
    }), a5.call(a, t) && !t.includes("*") && !t.endsWith("/")) {
      let p = a[t], f = ga(e, p, "", t, s, !1, !1, !1, n);
      if (f == null)
        throw Ob(t, e, s);
      return f;
    }
    let o = "", l = "", u = Object.getOwnPropertyNames(a), c = -1;
    for (; ++c < u.length; ) {
      let p = u[c], f = p.indexOf("*");
      if (f !== -1 && t.startsWith(p.slice(0, f))) {
        t.endsWith("/") && Qbe(t, e, s);
        let h = p.slice(f + 1);
        t.length >= p.length && t.endsWith(h) && l5(o, p) === 1 && p.lastIndexOf("*") === f && (o = p, l = t.slice(f, t.length - h.length));
      }
    }
    if (o) {
      let p = a[o], f = ga(e, p, l, o, s, !0, !1, t.endsWith("/"), n);
      if (f == null)
        throw Ob(t, e, s);
      return f;
    }
    throw Ob(t, e, s);
  }
  i(Q8, "packageExportsResolve");
  function l5(e, t) {
    let r = e.indexOf("*"), s = t.indexOf("*"), n = r === -1 ? e.length : r + 1, a = s === -1 ? t.length : s + 1;
    return n > a ? -1 : a > n || r === -1 ? 1 : s === -1 || e.length > t.length ? -1 : t.length > e.length ? 1 : 0;
  }
  i(l5, "patternKeyCompare");
  function Zbe(e, t, r) {
    if (e === "#" || e.startsWith("#/") || e.endsWith("/")) {
      let a = "is not a valid internal imports specifier name";
      throw new Kp(e, a, (0, ie().fileURLToPath)(t));
    }
    let s, n = Bb(t);
    if (n.exists) {
      s = (0, ie().pathToFileURL)(n.pjsonPath);
      let a = n.imports;
      if (a)
        if (a5.call(a, e) && !e.includes("*")) {
          let o = ga(s, a[e], "", e, t, !1, !0, !1, r);
          if (o != null)
            return o;
        } else {
          let o = "", l = "", u = Object.getOwnPropertyNames(a), c = -1;
          for (; ++c < u.length; ) {
            let p = u[c], f = p.indexOf("*");
            if (f !== -1 && e.startsWith(p.slice(0, -1))) {
              let h = p.slice(f + 1);
              e.length >= p.length && e.endsWith(h) && l5(o, p) === 1 && p.lastIndexOf("*") === f && (o = p, l = e.slice(f, e.length - h.length));
            }
          }
          if (o) {
            let p = a[o], f = ga(s, p, l, o, t, !0, !0, !1, r);
            if (f != null)
              return f;
          }
        }
    }
    throw Hbe(e, s, t);
  }
  i(Zbe, "packageImportsResolve");
  function ege(e, t) {
    let r = e.indexOf("/"), s = !0, n = !1;
    e[0] === "@" && (n = !0, r === -1 || e.length === 0 ? s = !1 : r = e.indexOf("/", r + 1));
    let a = r === -1 ? e : e.slice(0, r);
    if ($be.exec(a) !== null && (s = !1), !s)
      throw new Kp(e, "is not a valid package name", (0, ie().fileURLToPath)(t));
    let o = "." + (r === -1 ? "" : e.slice(r));
    return {
      packageName: a,
      packageSubpath: o,
      isScoped: n
    };
  }
  i(ege, "parsePackageName");
  function u5(e, t, r) {
    if (Vp().builtinModules.includes(e))
      return new (ie()).URL("node:" + e);
    let {
      packageName: s,
      packageSubpath: n,
      isScoped: a
    } = ege(e, t), o = Bb(t);
    if (o.exists) {
      let p = (0, ie().pathToFileURL)(o.pjsonPath);
      if (o.name === s && o.exports !== void 0 && o.exports !== null)
        return Q8(p, n, o, t, r);
    }
    let l = new (ie()).URL("./node_modules/" + s + "/package.json", t), u = (0, ie().fileURLToPath)(l), c;
    do {
      let p = o5(u.slice(0, -13));
      if (!p || !p.isDirectory()) {
        c = u, l = new (ie()).URL((a ? "../../../../node_modules/" : "../../../node_modules/") + s + "/package.json", l), u = (0, ie().fileURLToPath)(
        l);
        continue;
      }
      let f = r5(u, {
        base: t,
        specifier: e
      });
      return f.exports !== void 0 && f.exports !== null ? Q8(l, n, f, t, r) : n === "." ? Wbe(l, f, t) : new (ie()).URL(n, l);
    } while (u.length !== c.length);
    throw new kb(s, (0, ie().fileURLToPath)(t), !1);
  }
  i(u5, "packageResolve");
  function tge(e) {
    return e[0] === "." && (e.length === 1 || e[1] === "/" || e[1] === "." && (e.length === 2 || e[2] === "/"));
  }
  i(tge, "isRelativeSpecifier");
  function Fb(e) {
    return e === "" ? !1 : e[0] === "/" ? !0 : tge(e);
  }
  i(Fb, "shouldBeTreatedAsRelativeOrAbsolutePath");
  function c5(e, t, r, s) {
    let n = t.protocol, o = n === "data:" || n === "http:" || n === "https:", l;
    if (Fb(e))
      try {
        l = new (ie()).URL(e, t);
      } catch (u) {
        let c = new Y8(e, t);
        throw c.cause = u, c;
      }
    else if (n === "file:" && e[0] === "#")
      l = Zbe(e, t, r);
    else
      try {
        l = new (ie()).URL(e);
      } catch (u) {
        if (o && !Vp().builtinModules.includes(e)) {
          let c = new Y8(e, t);
          throw c.cause = u, c;
        }
        l = u5(e, t, r);
      }
    return ps()(l !== void 0, "expected to be defined"), l.protocol !== "file:" ? l : Ybe(l, t, s);
  }
  i(c5, "moduleResolve");
  function rge(e, t, r) {
    if (r) {
      let s = r.protocol;
      if (s === "http:" || s === "https:") {
        if (Fb(e)) {
          let n = t?.protocol;
          if (n && n !== "https:" && n !== "http:")
            throw new _b(e, r, "remote imports cannot import from a local location.");
          return {
            url: t?.href || ""
          };
        }
        throw Vp().builtinModules.includes(e) ? new _b(e, r, "remote imports cannot import from a local location.") : new _b(e, r, "only rel\
ative and absolute specifiers are supported.");
      }
    }
  }
  i(rge, "checkIfDisallowedImport");
  function sge(e) {
    return !!(e && typeof e == "object" && "href" in e && typeof e.href == "string" && "protocol" in e && typeof e.protocol == "string" && e.
    href && e.protocol);
  }
  i(sge, "isURL");
  function nge(e) {
    if (e !== void 0 && typeof e != "string" && !sge(e))
      throw new Ct.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], e);
  }
  i(nge, "throwIfInvalidParentURL");
  function ige(e, t = {}) {
    let {
      parentURL: r
    } = t;
    ps()(r !== void 0, "expected `parentURL` to be defined"), nge(r);
    let s;
    if (r)
      try {
        s = new (ie()).URL(r);
      } catch {
      }
    let n, a;
    try {
      if (n = Fb(e) ? new (ie()).URL(e, s) : new (ie()).URL(e), a = n.protocol, a === "data:")
        return {
          url: n.href,
          format: null
        };
    } catch {
    }
    let o = rge(e, n, s);
    if (o) return o;
    if (a === void 0 && n && (a = n.protocol), a === "node:")
      return {
        url: e
      };
    if (n && n.protocol === "node:") return {
      url: e
    };
    let l = jbe(t.conditions), u = c5(e, new (ie()).URL(r), l, !1);
    return {
      url: u.href,
      format: s5(u, {
        parentURL: r
      })
    };
  }
  i(ige, "defaultResolve");
  function age(e, t) {
    if (!t)
      throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
    try {
      return ige(e, {
        parentURL: t
      }).url;
    } catch (r) {
      let s = r;
      if ((s.code === "ERR_UNSUPPORTED_DIR_IMPORT" || s.code === "ERR_MODULE_NOT_FOUND") && typeof s.url == "string")
        return s.url;
      throw r;
    }
  }
  i(age, "resolve");
});

// ../node_modules/@babel/core/lib/config/files/plugins.js
var x5 = D((Sn) => {
  "use strict";
  Object.defineProperty(Sn, "__esModule", {
    value: !0
  });
  Sn.loadPlugin = gge;
  Sn.loadPreset = Tge;
  Sn.resolvePreset = Sn.resolvePlugin = void 0;
  function d5() {
    let e = Fn();
    return d5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_debug"), e;
  }
  i(d5, "_debug");
  function Mb() {
    let e = z("path");
    return Mb = /* @__PURE__ */ i(function() {
      return e;
    }, "_path"), e;
  }
  i(Mb, "_path");
  var Rb = un(), h5 = Ab();
  function jb() {
    let e = z("url");
    return jb = /* @__PURE__ */ i(function() {
      return e;
    }, "_url"), e;
  }
  i(jb, "_url");
  var oge = p5();
  z("module");
  function m5() {
    let e = z("fs");
    return m5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_fs"), e;
  }
  i(m5, "_fs");
  var y5 = d5()("babel:config:loading:files:plugins"), lge = /^module:/, uge = /^(?!@|module:|[^/]+\/|babel-plugin-)/, cge = /^(?!@|module:|[^/]+\/|babel-preset-)/,
  pge = /^(@babel\/)(?!plugin-|[^/]+\/)/, fge = /^(@babel\/)(?!preset-|[^/]+\/)/, dge = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/,
  hge = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/, mge = /^(@(?!babel$)[^/]+)$/, yge = Sn.resolvePlugin = g5.bind(null,
  "plugin"), bge = Sn.resolvePreset = g5.bind(null, "preset");
  function* gge(e, t) {
    let {
      filepath: r,
      loader: s
    } = yge(e, t, yield* (0, Rb.isAsync)()), n = yield* T5("plugin", s, r);
    return y5("Loaded plugin %o from %o.", e, t), {
      filepath: r,
      value: n
    };
  }
  i(gge, "loadPlugin");
  function* Tge(e, t) {
    let {
      filepath: r,
      loader: s
    } = bge(e, t, yield* (0, Rb.isAsync)()), n = yield* T5("preset", s, r);
    return y5("Loaded preset %o from %o.", e, t), {
      filepath: r,
      value: n
    };
  }
  i(Tge, "loadPreset");
  function Lb(e, t) {
    if (Mb().isAbsolute(t)) return t;
    let r = e === "preset";
    return t.replace(r ? cge : uge, `babel-${e}-`).replace(r ? fge : pge, `$1${e}-`).replace(r ? hge : dge, `$1babel-${e}-`).replace(mge, `$\
1/babel-${e}`).replace(lge, "");
  }
  i(Lb, "standardizeName");
  function* b5(e, t) {
    let r = Lb(e, t), {
      error: s,
      value: n
    } = yield r;
    if (!s) return n;
    if (s.code !== "MODULE_NOT_FOUND") throw s;
    r !== t && !(yield t).error && (s.message += `
- If you want to resolve "${t}", use "module:${t}"`), (yield Lb(e, "@babel/" + t)).error || (s.message += `
- Did you mean "@babel/${t}"?`);
    let a = e === "preset" ? "plugin" : "preset";
    if ((yield Lb(a, t)).error || (s.message += `
- Did you accidentally pass a ${a} as a ${e}?`), e === "plugin") {
      let o = r.replace("-proposal-", "-transform-");
      o !== r && !(yield o).error && (s.message += `
- Did you mean "${o}"?`);
    }
    throw s.message += `

Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`, s;
  }
  i(b5, "resolveAlternativesHelper");
  function xge(e, t) {
    try {
      return t ? {
        error: null,
        value: (((r, s) => (r = r.split("."), s = s.split("."), +r[0] > +s[0] || r[0] == s[0] && +r[1] >= +s[1]))(process.versions.node, "8.\
9") ? z.resolve : (r, {
          paths: [s]
        }, n = z("module")) => {
          let a = n._findPath(r, n._nodeModulePaths(s).concat(s));
          if (a) return a;
          throw a = new Error(`Cannot resolve module '${r}'`), a.code = "MODULE_NOT_FOUND", a;
        })(e, {
          paths: [t]
        })
      } : {
        error: null,
        value: z.resolve(e)
      };
    } catch (r) {
      return {
        error: r,
        value: null
      };
    }
  }
  i(xge, "tryRequireResolve");
  function Ege(e, t) {
    try {
      return {
        error: null,
        value: (0, oge.resolve)(e, t)
      };
    } catch (r) {
      return {
        error: r,
        value: null
      };
    }
  }
  i(Ege, "tryImportMetaResolve");
  function f5(e, t, r) {
    let s = b5(e, t), n = s.next();
    for (; !n.done; )
      n = s.next(xge(n.value, r));
    return {
      loader: "require",
      filepath: n.value
    };
  }
  i(f5, "resolveStandardizedNameForRequire");
  function Sge(e, t, r) {
    let s = (0, jb().pathToFileURL)(Mb().join(r, "./babel-virtual-resolve-base.js")).href, n = b5(e, t), a = n.next();
    for (; !a.done; )
      a = n.next(Ege(a.value, s));
    return {
      loader: "auto",
      filepath: (0, jb().fileURLToPath)(a.value)
    };
  }
  i(Sge, "resolveStandardizedNameForImport");
  function g5(e, t, r, s) {
    if (!h5.supportsESM || !s)
      return f5(e, t, r);
    try {
      let n = Sge(e, t, r);
      if (!(0, m5().existsSync)(n.filepath))
        throw Object.assign(new Error(`Could not resolve "${t}" in file ${r}.`), {
          type: "MODULE_NOT_FOUND"
        });
      return n;
    } catch (n) {
      try {
        return f5(e, t, r);
      } catch (a) {
        throw n.type === "MODULE_NOT_FOUND" ? n : a.type === "MODULE_NOT_FOUND" ? a : n;
      }
    }
  }
  i(g5, "resolveStandardizedName");
  Yp = /* @__PURE__ */ new Set();
  var Yp;
  function* T5(e, t, r) {
    if (!(yield* (0, Rb.isAsync)()) && Yp.has(r))
      throw new Error(`Reentrant ${e} detected trying to load "${r}". This module is not ignored and is trying to load itself while compilin\
g itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
    try {
      return Yp.add(r), yield* (0, h5.default)(r, t, `You appear to be using a native ECMAScript module ${e}, which is only supported when r\
unning Babel asynchronously or when using the Node.js \`--experimental-require-module\` flag.`, `You appear to be using a ${e} that contains\
 top-level await, which is only supported when running Babel asynchronously.`, !0);
    } catch (s) {
      throw s.message = `[BABEL]: ${s.message} (While processing: ${r})`, s;
    } finally {
      Yp.delete(r);
    }
  }
  i(T5, "requireModule");
});

// ../node_modules/@babel/core/lib/config/files/index.js
var Vo = D((cr) => {
  "use strict";
  Object.defineProperty(cr, "__esModule", {
    value: !0
  });
  Object.defineProperty(cr, "ROOT_CONFIG_FILENAMES", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ta.ROOT_CONFIG_FILENAMES;
    }, "get")
  });
  Object.defineProperty(cr, "findConfigUpwards", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ta.findConfigUpwards;
    }, "get")
  });
  Object.defineProperty(cr, "findPackageData", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return vge.findPackageData;
    }, "get")
  });
  Object.defineProperty(cr, "findRelativeConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ta.findRelativeConfig;
    }, "get")
  });
  Object.defineProperty(cr, "findRootConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ta.findRootConfig;
    }, "get")
  });
  Object.defineProperty(cr, "loadConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ta.loadConfig;
    }, "get")
  });
  Object.defineProperty(cr, "loadPlugin", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Hp.loadPlugin;
    }, "get")
  });
  Object.defineProperty(cr, "loadPreset", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Hp.loadPreset;
    }, "get")
  });
  Object.defineProperty(cr, "resolvePlugin", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Hp.resolvePlugin;
    }, "get")
  });
  Object.defineProperty(cr, "resolvePreset", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Hp.resolvePreset;
    }, "get")
  });
  Object.defineProperty(cr, "resolveShowConfigPath", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ta.resolveShowConfigPath;
    }, "get")
  });
  var vge = p3(), Ta = q8(), Hp = x5();
});

// ../node_modules/@babel/core/lib/transform.js
var S5 = D((xa) => {
  "use strict";
  Object.defineProperty(xa, "__esModule", {
    value: !0
  });
  xa.transform = void 0;
  xa.transformAsync = wge;
  xa.transformSync = Cge;
  function E5() {
    let e = ir();
    return E5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(E5, "_gensync");
  var Pge = oa(), Age = yp(), Jp = ws(), Gp = E5()(/* @__PURE__ */ i(function* (t, r) {
    let s = yield* (0, Pge.default)(r);
    return s === null ? null : yield* (0, Age.run)(s, t);
  }, "transform")), b7e = xa.transform = /* @__PURE__ */ i(function(t, r, s) {
    let n, a;
    if (typeof r == "function" ? (a = r, n = void 0) : (n = r, a = s), a === void 0)
      return (0, Jp.beginHiddenCallStack)(Gp.sync)(t, n);
    (0, Jp.beginHiddenCallStack)(Gp.errback)(t, n, a);
  }, "transform");
  function Cge(...e) {
    return (0, Jp.beginHiddenCallStack)(Gp.sync)(...e);
  }
  i(Cge, "transformSync");
  function wge(...e) {
    return (0, Jp.beginHiddenCallStack)(Gp.async)(...e);
  }
  i(wge, "transformAsync");
});

// ../node_modules/@babel/core/lib/transform-ast.js
var P5 = D((Ea) => {
  "use strict";
  Object.defineProperty(Ea, "__esModule", {
    value: !0
  });
  Ea.transformFromAst = void 0;
  Ea.transformFromAstAsync = Oge;
  Ea.transformFromAstSync = Ige;
  function v5() {
    let e = ir();
    return v5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(v5, "_gensync");
  var Dge = oa(), _ge = yp(), Xp = ws(), zp = v5()(function* (e, t, r) {
    let s = yield* (0, Dge.default)(r);
    if (s === null) return null;
    if (!e) throw new Error("No AST given");
    return yield* (0, _ge.run)(s, t, e);
  }), x7e = Ea.transformFromAst = /* @__PURE__ */ i(function(t, r, s, n) {
    let a, o;
    if (typeof s == "function" ? (o = s, a = void 0) : (a = s, o = n), o === void 0)
      return (0, Xp.beginHiddenCallStack)(zp.sync)(t, r, a);
    (0, Xp.beginHiddenCallStack)(zp.errback)(t, r, a, o);
  }, "transformFromAst");
  function Ige(...e) {
    return (0, Xp.beginHiddenCallStack)(zp.sync)(...e);
  }
  i(Ige, "transformFromAstSync");
  function Oge(...e) {
    return (0, Xp.beginHiddenCallStack)(zp.async)(...e);
  }
  i(Oge, "transformFromAstAsync");
});

// ../node_modules/@babel/core/lib/parse.js
var C5 = D((Sa) => {
  "use strict";
  Object.defineProperty(Sa, "__esModule", {
    value: !0
  });
  Sa.parse = void 0;
  Sa.parseAsync = Lge;
  Sa.parseSync = Fge;
  function A5() {
    let e = ir();
    return A5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_gensync"), e;
  }
  i(A5, "_gensync");
  var Nge = oa(), Bge = l2(), kge = s2(), Qp = ws(), Zp = A5()(/* @__PURE__ */ i(function* (t, r) {
    let s = yield* (0, Nge.default)(r);
    return s === null ? null : yield* (0, Bge.default)(s.passes, (0, kge.default)(s), t);
  }, "parse")), v7e = Sa.parse = /* @__PURE__ */ i(function(t, r, s) {
    if (typeof r == "function" && (s = r, r = void 0), s === void 0)
      return (0, Qp.beginHiddenCallStack)(Zp.sync)(t, r);
    (0, Qp.beginHiddenCallStack)(Zp.errback)(t, r, s);
  }, "parse");
  function Fge(...e) {
    return (0, Qp.beginHiddenCallStack)(Zp.sync)(...e);
  }
  i(Fge, "parseSync");
  function Lge(...e) {
    return (0, Qp.beginHiddenCallStack)(Zp.async)(...e);
  }
  i(Lge, "parseAsync");
});

// ../node_modules/@babel/core/lib/index.js
var et = D((me) => {
  "use strict";
  Object.defineProperty(me, "__esModule", {
    value: !0
  });
  me.DEFAULT_EXTENSIONS = void 0;
  Object.defineProperty(me, "File", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return jge.default;
    }, "get")
  });
  Object.defineProperty(me, "buildExternalHelpers", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Mge.default;
    }, "get")
  });
  Object.defineProperty(me, "createConfigItem", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fs.createConfigItem;
    }, "get")
  });
  Object.defineProperty(me, "createConfigItemAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fs.createConfigItemAsync;
    }, "get")
  });
  Object.defineProperty(me, "createConfigItemSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fs.createConfigItemSync;
    }, "get")
  });
  Object.defineProperty(me, "getEnv", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Rge.getEnv;
    }, "get")
  });
  Object.defineProperty(me, "loadOptions", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fs.loadOptions;
    }, "get")
  });
  Object.defineProperty(me, "loadOptionsAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fs.loadOptionsAsync;
    }, "get")
  });
  Object.defineProperty(me, "loadOptionsSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fs.loadOptionsSync;
    }, "get")
  });
  Object.defineProperty(me, "loadPartialConfig", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fs.loadPartialConfig;
    }, "get")
  });
  Object.defineProperty(me, "loadPartialConfigAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fs.loadPartialConfigAsync;
    }, "get")
  });
  Object.defineProperty(me, "loadPartialConfigSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return fs.loadPartialConfigSync;
    }, "get")
  });
  Object.defineProperty(me, "parse", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vb.parse;
    }, "get")
  });
  Object.defineProperty(me, "parseAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vb.parseAsync;
    }, "get")
  });
  Object.defineProperty(me, "parseSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Vb.parseSync;
    }, "get")
  });
  me.resolvePreset = me.resolvePlugin = void 0;
  Object.defineProperty(me, "template", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return O5().default;
    }, "get")
  });
  Object.defineProperty(me, "tokTypes", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return _5().tokTypes;
    }, "get")
  });
  Object.defineProperty(me, "transform", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return qb.transform;
    }, "get")
  });
  Object.defineProperty(me, "transformAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return qb.transformAsync;
    }, "get")
  });
  Object.defineProperty(me, "transformFile", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ub.transformFile;
    }, "get")
  });
  Object.defineProperty(me, "transformFileAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ub.transformFileAsync;
    }, "get")
  });
  Object.defineProperty(me, "transformFileSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return Ub.transformFileSync;
    }, "get")
  });
  Object.defineProperty(me, "transformFromAst", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return $b.transformFromAst;
    }, "get")
  });
  Object.defineProperty(me, "transformFromAstAsync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return $b.transformFromAstAsync;
    }, "get")
  });
  Object.defineProperty(me, "transformFromAstSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return $b.transformFromAstSync;
    }, "get")
  });
  Object.defineProperty(me, "transformSync", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return qb.transformSync;
    }, "get")
  });
  Object.defineProperty(me, "traverse", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return I5().default;
    }, "get")
  });
  me.version = me.types = void 0;
  var jge = cm(), Mge = MA(), w5 = Vo(), Rge = Wy();
  function D5() {
    let e = ce();
    return D5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_types"), e;
  }
  i(D5, "_types");
  Object.defineProperty(me, "types", {
    enumerable: !0,
    get: /* @__PURE__ */ i(function() {
      return D5();
    }, "get")
  });
  function _5() {
    let e = Bn();
    return _5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_parser"), e;
  }
  i(_5, "_parser");
  function I5() {
    let e = nt();
    return I5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_traverse"), e;
  }
  i(I5, "_traverse");
  function O5() {
    let e = ro();
    return O5 = /* @__PURE__ */ i(function() {
      return e;
    }, "_template"), e;
  }
  i(O5, "_template");
  var fs = oa(), qb = S5(), Ub = v2(), $b = P5(), Vb = C5(), C7e = me.version = "7.28.4", qge = /* @__PURE__ */ i((e, t) => w5.resolvePlugin(
  e, t, !1).filepath, "resolvePlugin");
  me.resolvePlugin = qge;
  var Uge = /* @__PURE__ */ i((e, t) => w5.resolvePreset(e, t, !1).filepath, "resolvePreset");
  me.resolvePreset = Uge;
  var w7e = me.DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
  me.OptionManager = class {
    static {
      i(this, "OptionManager");
    }
    init(t) {
      return (0, fs.loadOptionsSync)(t);
    }
  }, me.Plugin = /* @__PURE__ */ i(function(t) {
    throw new Error(`The (${t}) Babel 5 plugin is being run with an unsupported Babel version.`);
  }, "Plugin");
});

// src/babel/index.ts
var Vge = ms(et(), 1), L7e = ms(et(), 1), B5 = ms(et(), 1), Kb = ms(bo(), 1), j7e = ms(Bn(), 1), Wb = ms(nt(), 1), M7e = ms(ce(), 1);
import * as R7e from "recast";

// src/babel/babelParse.ts
var ef = ms(Bn(), 1);
import * as tf from "recast";
function $ge(e, t) {
  let n = /^\s*\/\/\s*@flow/.test(e) ? ["flow"] : ["typescript"], a = {
    ...t,
    plugins: [...t.plugins ?? [], ...n]
  };
  return ef.parse(e, a);
}
i($ge, "parseWithFlowOrTypescript");
var N5 = {
  sourceType: "module",
  // FIXME: we should get this from the project config somehow?
  plugins: ["jsx", "decorators-legacy", "classProperties"],
  tokens: !0
}, O7e = /* @__PURE__ */ i((e) => tf.parse(e, {
  parser: {
    parse(t) {
      return $ge(t, N5);
    }
  }
}), "babelParse"), N7e = /* @__PURE__ */ i((e) => tf.print(e, {
  quote: "single",
  trailingComma: !0,
  tabWidth: 2,
  wrapColumn: 80,
  arrowParensAlways: !0
}).code, "babelPrint"), B7e = /* @__PURE__ */ i((e) => ef.parseExpression(e, N5), "babelParseExpression");

// src/babel/index.ts
var q7e = Wb.default.default || Wb.default, U7e = Kb.default.default || Kb.default, $7e = B5.File;
var export_transformSync = Vge.transformSync;
export {
  $7e as BabelFileClass,
  O7e as babelParse,
  B7e as babelParseExpression,
  N7e as babelPrint,
  L7e as core,
  U7e as generate,
  j7e as parser,
  N5 as parserOptions,
  R7e as recast,
  export_transformSync as transformSync,
  q7e as traverse,
  M7e as types
};
